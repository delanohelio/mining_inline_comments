{"pr_number": 244, "pr_title": "Implemented JSON Schema serde support", "pr_createdAt": "2020-01-28T14:04:40Z", "pr_url": "https://github.com/Apicurio/apicurio-registry/pull/244", "timeline": [{"oid": "8146172da42b3fb522aeb4714fb5fc35c15e0f75", "url": "https://github.com/Apicurio/apicurio-registry/commit/8146172da42b3fb522aeb4714fb5fc35c15e0f75", "message": "Initial impl of \"serde\" for JSON Schema.  Fixes #180", "committedDate": "2020-01-24T20:11:23Z", "type": "commit"}, {"oid": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8", "url": "https://github.com/Apicurio/apicurio-registry/commit/bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8", "message": "updates to the JSON Schema serde based on feedback", "committedDate": "2020-01-27T19:21:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1NDAzNg==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372354036", "bodyText": "Should not be needed ... getIdHandler() takes care of null ...", "author": "alesj", "createdAt": "2020-01-29T12:28:27Z", "path": "utils/serde/src/main/java/io/apicurio/registry/utils/serde/AbstractKafkaSerDe.java", "diffHunk": "@@ -109,6 +107,9 @@ protected void configure(Map<String, ?> configs) {\n         }\n         if (idHandler == null) {\n             Object idh = configs.get(REGISTRY_ID_HANDLER_CONFIG_PARAM);\n+            if (idh == null) {", "originalCommit": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3MDA3OQ==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372370079", "bodyText": "Ah yes, forgot to revert that change.  On it.", "author": "EricWittmann", "createdAt": "2020-01-29T13:05:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1NDAzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1NTM2Mg==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372355362", "bodyText": "Just use ByteBuffer.allocate(header.value()) ?", "author": "alesj", "createdAt": "2020-01-29T12:31:53Z", "path": "utils/serde/src/main/java/io/apicurio/registry/utils/serde/JsonSchemaKafkaDeserializer.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.utils.serde;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Deserializer;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.worldturner.medeia.api.StringSchemaSource;\n+import com.worldturner.medeia.api.jackson.MedeiaJacksonApi;\n+import com.worldturner.medeia.schema.validation.SchemaValidator;\n+\n+import io.apicurio.registry.client.RegistryService;\n+import io.apicurio.registry.rest.beans.ArtifactMetaData;\n+import io.apicurio.registry.rest.beans.VersionMetaData;\n+import io.apicurio.registry.utils.serde.util.Utils;\n+\n+/**\n+ * @author eric.wittmann@gmail.com\n+ */\n+public class JsonSchemaKafkaDeserializer<T> extends AbstractKafkaSerDe<JsonSchemaKafkaDeserializer<T>> implements Deserializer<T> {\n+\n+    public static final String REGISTRY_JSON_SCHEMA_DESERIALIZER_VALIDATION_ENABLED = \"apicurio.registry.serdes.json-schema.validation-enabled\";\n+\n+    private static MedeiaJacksonApi api = new MedeiaJacksonApi();\n+    private static ObjectMapper mapper = new ObjectMapper();\n+    \n+    private boolean validationEnabled = false;\n+    private SchemaCache<SchemaValidator> schemaCache;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public JsonSchemaKafkaDeserializer() {\n+        this(null);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * @param client\n+     */\n+    public JsonSchemaKafkaDeserializer(RegistryService client) {\n+        super(client);\n+    }\n+\n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#configure(java.util.Map, boolean)\n+     */\n+    @Override\n+    public void configure(Map<String, ?> configs, boolean isKey) {\n+        super.configure(configs);\n+\n+        Object ve = configs.get(REGISTRY_JSON_SCHEMA_DESERIALIZER_VALIDATION_ENABLED);\n+        this.validationEnabled = Utils.isTrue(ve);\n+\n+        this.schemaCache = new SchemaCache<SchemaValidator>(getClient()) {\n+            @Override\n+            protected SchemaValidator toSchema(Response response) {\n+                String schema = response.readEntity(String.class);\n+                return api.loadSchema(new StringSchemaSource(schema));\n+            }\n+        };\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#deserialize(java.lang.String, byte[])\n+     */\n+    @Override\n+    public T deserialize(String topic, byte[] data) {\n+        throw new UnsupportedOperationException();\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#deserialize(java.lang.String, org.apache.kafka.common.header.Headers, byte[])\n+     */\n+    @Override\n+    public T deserialize(String topic, Headers headers, byte[] data) {\n+        if (data == null) {\n+            return null;\n+        }\n+        \n+        try {\n+            JsonParser parser = mapper.getFactory().createParser(data);\n+            if (validationEnabled) {\n+                Long globalId = getGlobalId(headers);\n+                \n+                // If no globalId is provided, check the alternative - which is to check for artifactId and \n+                // (optionally) version.  If these are found, then convert that info to globalId.\n+                if (globalId == null) {\n+                    String artifactId = getArtifactId(headers);\n+                    Integer version = getVersion(headers);\n+                    if (version == null) {\n+                        version = getLatestVersion(artifactId);\n+                    }\n+                    globalId = toGlobalId(artifactId, version);\n+                }\n+                \n+                SchemaValidator schema = schemaCache.getSchema(globalId);\n+                parser = api.decorateJsonParser(schema, parser);\n+            }\n+            \n+            Class<T> messageType = getMessageType(headers);\n+\n+            return mapper.readValue(parser, messageType);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    /**\n+     * Gets the global id from the headers.  Returns null if not found.\n+     * @param headers\n+     */\n+    protected Long getGlobalId(Headers headers) {\n+        Header header = headers.lastHeader(JsonSchemaSerDeConstants.HEADER_GLOBAL_ID);\n+        if (header == null) {\n+            return null;\n+        }\n+        ByteBuffer buffer = ByteBuffer.allocate(8);", "originalCommit": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2OTY0OA==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372369648", "bodyText": "I assume you mean this:  ByteBuffer.allocate(header.value().length) which is fine.  I can change that.", "author": "EricWittmann", "createdAt": "2020-01-29T13:04:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1NTM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3NTIyOA==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372375228", "bodyText": "Eh, missed it again ... I meant ByteBuffer.wrap()", "author": "alesj", "createdAt": "2020-01-29T13:17:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1NTM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1NTc1Mw==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372355753", "bodyText": "Use IoUtils to handle byte[] --> String ...\n(a single place to handle such things)", "author": "alesj", "createdAt": "2020-01-29T12:32:45Z", "path": "utils/serde/src/main/java/io/apicurio/registry/utils/serde/JsonSchemaKafkaDeserializer.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.utils.serde;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Deserializer;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.worldturner.medeia.api.StringSchemaSource;\n+import com.worldturner.medeia.api.jackson.MedeiaJacksonApi;\n+import com.worldturner.medeia.schema.validation.SchemaValidator;\n+\n+import io.apicurio.registry.client.RegistryService;\n+import io.apicurio.registry.rest.beans.ArtifactMetaData;\n+import io.apicurio.registry.rest.beans.VersionMetaData;\n+import io.apicurio.registry.utils.serde.util.Utils;\n+\n+/**\n+ * @author eric.wittmann@gmail.com\n+ */\n+public class JsonSchemaKafkaDeserializer<T> extends AbstractKafkaSerDe<JsonSchemaKafkaDeserializer<T>> implements Deserializer<T> {\n+\n+    public static final String REGISTRY_JSON_SCHEMA_DESERIALIZER_VALIDATION_ENABLED = \"apicurio.registry.serdes.json-schema.validation-enabled\";\n+\n+    private static MedeiaJacksonApi api = new MedeiaJacksonApi();\n+    private static ObjectMapper mapper = new ObjectMapper();\n+    \n+    private boolean validationEnabled = false;\n+    private SchemaCache<SchemaValidator> schemaCache;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public JsonSchemaKafkaDeserializer() {\n+        this(null);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * @param client\n+     */\n+    public JsonSchemaKafkaDeserializer(RegistryService client) {\n+        super(client);\n+    }\n+\n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#configure(java.util.Map, boolean)\n+     */\n+    @Override\n+    public void configure(Map<String, ?> configs, boolean isKey) {\n+        super.configure(configs);\n+\n+        Object ve = configs.get(REGISTRY_JSON_SCHEMA_DESERIALIZER_VALIDATION_ENABLED);\n+        this.validationEnabled = Utils.isTrue(ve);\n+\n+        this.schemaCache = new SchemaCache<SchemaValidator>(getClient()) {\n+            @Override\n+            protected SchemaValidator toSchema(Response response) {\n+                String schema = response.readEntity(String.class);\n+                return api.loadSchema(new StringSchemaSource(schema));\n+            }\n+        };\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#deserialize(java.lang.String, byte[])\n+     */\n+    @Override\n+    public T deserialize(String topic, byte[] data) {\n+        throw new UnsupportedOperationException();\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#deserialize(java.lang.String, org.apache.kafka.common.header.Headers, byte[])\n+     */\n+    @Override\n+    public T deserialize(String topic, Headers headers, byte[] data) {\n+        if (data == null) {\n+            return null;\n+        }\n+        \n+        try {\n+            JsonParser parser = mapper.getFactory().createParser(data);\n+            if (validationEnabled) {\n+                Long globalId = getGlobalId(headers);\n+                \n+                // If no globalId is provided, check the alternative - which is to check for artifactId and \n+                // (optionally) version.  If these are found, then convert that info to globalId.\n+                if (globalId == null) {\n+                    String artifactId = getArtifactId(headers);\n+                    Integer version = getVersion(headers);\n+                    if (version == null) {\n+                        version = getLatestVersion(artifactId);\n+                    }\n+                    globalId = toGlobalId(artifactId, version);\n+                }\n+                \n+                SchemaValidator schema = schemaCache.getSchema(globalId);\n+                parser = api.decorateJsonParser(schema, parser);\n+            }\n+            \n+            Class<T> messageType = getMessageType(headers);\n+\n+            return mapper.readValue(parser, messageType);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    /**\n+     * Gets the global id from the headers.  Returns null if not found.\n+     * @param headers\n+     */\n+    protected Long getGlobalId(Headers headers) {\n+        Header header = headers.lastHeader(JsonSchemaSerDeConstants.HEADER_GLOBAL_ID);\n+        if (header == null) {\n+            return null;\n+        }\n+        ByteBuffer buffer = ByteBuffer.allocate(8);\n+        buffer.put(header.value());\n+        buffer.position(0);\n+        return buffer.getLong();\n+    }\n+\n+    /**\n+     * Gets the artifact id from the headers.  Throws if not found.\n+     * @param headers\n+     */\n+    protected String getArtifactId(Headers headers) {\n+        Header header = headers.lastHeader(JsonSchemaSerDeConstants.HEADER_ARTIFACT_ID);\n+        if (header == null) {\n+            throw new RuntimeException(\"ArtifactId not found in headers.\");\n+        }\n+        return new String(header.value(), StandardCharsets.UTF_8);", "originalCommit": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2OTAzNg==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372369036", "bodyText": "I think using the String constructor is superior in this case.  The toString(byte[], String) method declares an IOException (even though it can't throw one) and then just calls the same String c'tor that I'm using here.  It's even slightly worse though because it parses the Charset from string rather than just using one.\nSo -1 for me on this change. :)", "author": "EricWittmann", "createdAt": "2020-01-29T13:03:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1NTc1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3NDY5Mw==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372374693", "bodyText": "Ah, it's our IoUtil:\npublic static byte[] toBytes(String string) {\n    return (string == null ? null : string.getBytes(StandardCharsets.UTF_8));\n}\n\nIt's just that we have the selection of charset in a single place / class.", "author": "alesj", "createdAt": "2020-01-29T13:16:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1NTc1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3NjY5Ng==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372376696", "bodyText": "Oh I see.  Didn't notice that class.  I've made that change in all relevant places (I think).", "author": "EricWittmann", "createdAt": "2020-01-29T13:20:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1NTc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1NjY4NA==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372356684", "bodyText": "No need for this call ... just diff between when looking up metadata when you have the version and when not == single call.", "author": "alesj", "createdAt": "2020-01-29T12:35:01Z", "path": "utils/serde/src/main/java/io/apicurio/registry/utils/serde/JsonSchemaKafkaDeserializer.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.utils.serde;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Deserializer;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.worldturner.medeia.api.StringSchemaSource;\n+import com.worldturner.medeia.api.jackson.MedeiaJacksonApi;\n+import com.worldturner.medeia.schema.validation.SchemaValidator;\n+\n+import io.apicurio.registry.client.RegistryService;\n+import io.apicurio.registry.rest.beans.ArtifactMetaData;\n+import io.apicurio.registry.rest.beans.VersionMetaData;\n+import io.apicurio.registry.utils.serde.util.Utils;\n+\n+/**\n+ * @author eric.wittmann@gmail.com\n+ */\n+public class JsonSchemaKafkaDeserializer<T> extends AbstractKafkaSerDe<JsonSchemaKafkaDeserializer<T>> implements Deserializer<T> {\n+\n+    public static final String REGISTRY_JSON_SCHEMA_DESERIALIZER_VALIDATION_ENABLED = \"apicurio.registry.serdes.json-schema.validation-enabled\";\n+\n+    private static MedeiaJacksonApi api = new MedeiaJacksonApi();\n+    private static ObjectMapper mapper = new ObjectMapper();\n+    \n+    private boolean validationEnabled = false;\n+    private SchemaCache<SchemaValidator> schemaCache;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public JsonSchemaKafkaDeserializer() {\n+        this(null);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * @param client\n+     */\n+    public JsonSchemaKafkaDeserializer(RegistryService client) {\n+        super(client);\n+    }\n+\n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#configure(java.util.Map, boolean)\n+     */\n+    @Override\n+    public void configure(Map<String, ?> configs, boolean isKey) {\n+        super.configure(configs);\n+\n+        Object ve = configs.get(REGISTRY_JSON_SCHEMA_DESERIALIZER_VALIDATION_ENABLED);\n+        this.validationEnabled = Utils.isTrue(ve);\n+\n+        this.schemaCache = new SchemaCache<SchemaValidator>(getClient()) {\n+            @Override\n+            protected SchemaValidator toSchema(Response response) {\n+                String schema = response.readEntity(String.class);\n+                return api.loadSchema(new StringSchemaSource(schema));\n+            }\n+        };\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#deserialize(java.lang.String, byte[])\n+     */\n+    @Override\n+    public T deserialize(String topic, byte[] data) {\n+        throw new UnsupportedOperationException();\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#deserialize(java.lang.String, org.apache.kafka.common.header.Headers, byte[])\n+     */\n+    @Override\n+    public T deserialize(String topic, Headers headers, byte[] data) {\n+        if (data == null) {\n+            return null;\n+        }\n+        \n+        try {\n+            JsonParser parser = mapper.getFactory().createParser(data);\n+            if (validationEnabled) {\n+                Long globalId = getGlobalId(headers);\n+                \n+                // If no globalId is provided, check the alternative - which is to check for artifactId and \n+                // (optionally) version.  If these are found, then convert that info to globalId.\n+                if (globalId == null) {\n+                    String artifactId = getArtifactId(headers);\n+                    Integer version = getVersion(headers);\n+                    if (version == null) {\n+                        version = getLatestVersion(artifactId);", "originalCommit": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1NzE5NQ==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372357195", "bodyText": "There is already an instance of GlobalIdStrategy in AbstractKafkaStrategyAwareSerDe ... which this class extends, so I would just use that one.", "author": "alesj", "createdAt": "2020-01-29T12:36:13Z", "path": "utils/serde/src/main/java/io/apicurio/registry/utils/serde/JsonSchemaKafkaSerializer.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.utils.serde;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.kafka.common.errors.SerializationException;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Serializer;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.worldturner.medeia.api.StringSchemaSource;\n+import com.worldturner.medeia.api.jackson.MedeiaJacksonApi;\n+import com.worldturner.medeia.schema.validation.SchemaValidator;\n+\n+import io.apicurio.registry.client.RegistryService;\n+import io.apicurio.registry.types.ArtifactType;\n+import io.apicurio.registry.utils.serde.strategy.FindLatestIdStrategy;\n+import io.apicurio.registry.utils.serde.strategy.GlobalIdStrategy;\n+import io.apicurio.registry.utils.serde.util.Utils;\n+\n+/**\n+ * An implementation of the Kafka Serializer for JSON Schema use-cases. This serializer assumes that the\n+ * user's application needs to serialize a Java Bean to JSON data using Jackson. In addition to standard\n+ * serialization of the bean, this implementation can also optionally validate it against a JSON schema.\n+ * \n+ * @author eric.wittmann@gmail.com\n+ */\n+public class JsonSchemaKafkaSerializer<T>\n+        extends AbstractKafkaStrategyAwareSerDe<SchemaValidator, JsonSchemaKafkaSerializer<T>>\n+        implements Serializer<T> {\n+    \n+    public static final String REGISTRY_JSON_SCHEMA_SERIALIZER_VALIDATION_ENABLED = \"apicurio.registry.serdes.json-schema.validation-enabled\";\n+\n+    private static MedeiaJacksonApi api = new MedeiaJacksonApi();\n+    private static ObjectMapper mapper = new ObjectMapper();\n+    private static GlobalIdStrategy<SchemaValidator> latestVersionStrategy = new FindLatestIdStrategy<>();", "originalCommit": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2MjkwMw==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372362903", "bodyText": "Ah, OK, I see ... you need 2 ...", "author": "alesj", "createdAt": "2020-01-29T12:49:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1NzE5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1ODAwOA==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372358008", "bodyText": "Cache needs to be instantiated outside configure() ... as this method might not be called -- when this deserializer is instantiated outside Kafka code.", "author": "alesj", "createdAt": "2020-01-29T12:37:58Z", "path": "utils/serde/src/main/java/io/apicurio/registry/utils/serde/JsonSchemaKafkaDeserializer.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.utils.serde;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Deserializer;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.worldturner.medeia.api.StringSchemaSource;\n+import com.worldturner.medeia.api.jackson.MedeiaJacksonApi;\n+import com.worldturner.medeia.schema.validation.SchemaValidator;\n+\n+import io.apicurio.registry.client.RegistryService;\n+import io.apicurio.registry.rest.beans.ArtifactMetaData;\n+import io.apicurio.registry.rest.beans.VersionMetaData;\n+import io.apicurio.registry.utils.serde.util.Utils;\n+\n+/**\n+ * @author eric.wittmann@gmail.com\n+ */\n+public class JsonSchemaKafkaDeserializer<T> extends AbstractKafkaSerDe<JsonSchemaKafkaDeserializer<T>> implements Deserializer<T> {\n+\n+    public static final String REGISTRY_JSON_SCHEMA_DESERIALIZER_VALIDATION_ENABLED = \"apicurio.registry.serdes.json-schema.validation-enabled\";\n+\n+    private static MedeiaJacksonApi api = new MedeiaJacksonApi();\n+    private static ObjectMapper mapper = new ObjectMapper();\n+    \n+    private boolean validationEnabled = false;\n+    private SchemaCache<SchemaValidator> schemaCache;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public JsonSchemaKafkaDeserializer() {\n+        this(null);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * @param client\n+     */\n+    public JsonSchemaKafkaDeserializer(RegistryService client) {\n+        super(client);\n+    }\n+\n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#configure(java.util.Map, boolean)\n+     */\n+    @Override\n+    public void configure(Map<String, ?> configs, boolean isKey) {\n+        super.configure(configs);\n+\n+        Object ve = configs.get(REGISTRY_JSON_SCHEMA_DESERIALIZER_VALIDATION_ENABLED);\n+        this.validationEnabled = Utils.isTrue(ve);\n+\n+        this.schemaCache = new SchemaCache<SchemaValidator>(getClient()) {", "originalCommit": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3MTE5NQ==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372371195", "bodyText": "Ah ok - that goes for validationEnabled too then.", "author": "EricWittmann", "createdAt": "2020-01-29T13:08:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1ODAwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3NjM0MQ==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372376341", "bodyText": "Yeah ... I would make validationEnabled a Boolean (non-primitive), add a setter, and if it was explicitly set (not-null), I wouldn't handle it in configure()", "author": "alesj", "createdAt": "2020-01-29T13:19:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1ODAwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1OTA1Mg==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372359052", "bodyText": "Perhaps a common constant for both serde ?", "author": "alesj", "createdAt": "2020-01-29T12:40:31Z", "path": "utils/serde/src/main/java/io/apicurio/registry/utils/serde/JsonSchemaKafkaSerializer.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.utils.serde;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.kafka.common.errors.SerializationException;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Serializer;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.worldturner.medeia.api.StringSchemaSource;\n+import com.worldturner.medeia.api.jackson.MedeiaJacksonApi;\n+import com.worldturner.medeia.schema.validation.SchemaValidator;\n+\n+import io.apicurio.registry.client.RegistryService;\n+import io.apicurio.registry.types.ArtifactType;\n+import io.apicurio.registry.utils.serde.strategy.FindLatestIdStrategy;\n+import io.apicurio.registry.utils.serde.strategy.GlobalIdStrategy;\n+import io.apicurio.registry.utils.serde.util.Utils;\n+\n+/**\n+ * An implementation of the Kafka Serializer for JSON Schema use-cases. This serializer assumes that the\n+ * user's application needs to serialize a Java Bean to JSON data using Jackson. In addition to standard\n+ * serialization of the bean, this implementation can also optionally validate it against a JSON schema.\n+ * \n+ * @author eric.wittmann@gmail.com\n+ */\n+public class JsonSchemaKafkaSerializer<T>\n+        extends AbstractKafkaStrategyAwareSerDe<SchemaValidator, JsonSchemaKafkaSerializer<T>>\n+        implements Serializer<T> {\n+    \n+    public static final String REGISTRY_JSON_SCHEMA_SERIALIZER_VALIDATION_ENABLED = \"apicurio.registry.serdes.json-schema.validation-enabled\";", "originalCommit": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2MzM2OA==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372363368", "bodyText": "Hmmm ... why exactly 2 tries ?", "author": "alesj", "createdAt": "2020-01-29T12:50:39Z", "path": "utils/serde/src/main/java/io/apicurio/registry/utils/serde/JsonSchemaKafkaSerializer.java", "diffHunk": "@@ -0,0 +1,188 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.utils.serde;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.kafka.common.errors.SerializationException;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Serializer;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.worldturner.medeia.api.StringSchemaSource;\n+import com.worldturner.medeia.api.jackson.MedeiaJacksonApi;\n+import com.worldturner.medeia.schema.validation.SchemaValidator;\n+\n+import io.apicurio.registry.client.RegistryService;\n+import io.apicurio.registry.types.ArtifactType;\n+import io.apicurio.registry.utils.serde.strategy.FindLatestIdStrategy;\n+import io.apicurio.registry.utils.serde.strategy.GlobalIdStrategy;\n+import io.apicurio.registry.utils.serde.util.Utils;\n+\n+/**\n+ * An implementation of the Kafka Serializer for JSON Schema use-cases. This serializer assumes that the\n+ * user's application needs to serialize a Java Bean to JSON data using Jackson. In addition to standard\n+ * serialization of the bean, this implementation can also optionally validate it against a JSON schema.\n+ * \n+ * @author eric.wittmann@gmail.com\n+ */\n+public class JsonSchemaKafkaSerializer<T>\n+        extends AbstractKafkaStrategyAwareSerDe<SchemaValidator, JsonSchemaKafkaSerializer<T>>\n+        implements Serializer<T> {\n+    \n+    public static final String REGISTRY_JSON_SCHEMA_SERIALIZER_VALIDATION_ENABLED = \"apicurio.registry.serdes.json-schema.validation-enabled\";\n+\n+    private static MedeiaJacksonApi api = new MedeiaJacksonApi();\n+    private static ObjectMapper mapper = new ObjectMapper();\n+    private static GlobalIdStrategy<SchemaValidator> latestVersionStrategy = new FindLatestIdStrategy<>();\n+    \n+    private boolean validationEnabled = false;\n+    private SchemaCache<SchemaValidator> schemaCache;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public JsonSchemaKafkaSerializer() {\n+    }\n+\n+    /**\n+     * Constructor.\n+     * @param client\n+     */\n+    public JsonSchemaKafkaSerializer(RegistryService client) {\n+        super(client);\n+    }\n+\n+    /**\n+     * @see org.apache.kafka.common.serialization.Serializer#configure(java.util.Map, boolean)\n+     */\n+    @Override\n+    public void configure(Map<String, ?> configs, boolean isKey) {\n+        super.configure(configs, isKey);\n+        \n+        Object ve = configs.get(REGISTRY_JSON_SCHEMA_SERIALIZER_VALIDATION_ENABLED);\n+        this.validationEnabled = Utils.isTrue(ve);\n+        \n+        this.schemaCache = new SchemaCache<SchemaValidator>(getClient()) {\n+            @Override\n+            protected SchemaValidator toSchema(Response response) {\n+                String schema = response.readEntity(String.class);\n+                return api.loadSchema(new StringSchemaSource(schema));\n+            }\n+        };\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Serializer#serialize(java.lang.String, java.lang.Object)\n+     */\n+    @Override\n+    public byte[] serialize(String topic, T data) {\n+        // Headers are required when sending data using this serdes impl\n+        throw new UnsupportedOperationException();\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Serializer#serialize(java.lang.String, org.apache.kafka.common.header.Headers, java.lang.Object)\n+     */\n+    @Override\n+    public byte[] serialize(String topic, Headers headers, T data) {\n+        if (data == null) {\n+            return new byte[0];\n+        }\n+\n+        // Now serialize the data\n+        try {\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            JsonGenerator generator = mapper.getFactory().createGenerator(baos);\n+            if (validationEnabled) {\n+                String artifactId = getArtifactId(topic, data);\n+                Long globalId = getArtifactVersionGlobalId(artifactId, topic, data);\n+                if (globalId == null) {\n+                    globalId = latestVersionStrategy.findId(getClient(), artifactId, ArtifactType.JSON, null);", "originalCommit": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3NDEyNw==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372374127", "bodyText": "This is weird and a holdover from the previous implementation.  I'll modify it so it makes more sense.", "author": "EricWittmann", "createdAt": "2020-01-29T13:14:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2MzM2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2NDUwMw==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372364503", "bodyText": "We said we're gonna add another strategy for this - ToStreamStrategy ...", "author": "alesj", "createdAt": "2020-01-29T12:53:08Z", "path": "utils/serde/src/main/java/io/apicurio/registry/utils/serde/strategy/GlobalIdStrategy.java", "diffHunk": "@@ -47,14 +47,15 @@\n     /**\n      * Create InputStream from schema.\n      * By default we just take string bytes.\n-     *\n+     * \n      * @param schema the schema\n      * @return schema's input stream\n      */\n     default InputStream toStream(T schema) {", "originalCommit": "bc40f115f0961e3467f9d1614f7d4f6be7c7f2f8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3NDU1MQ==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372374551", "bodyText": "Yeah it turned out I didn't need it, so left it alone for now.  Since for JSON Schema we never have the schema, toStream() will never be called (or at least never be called with anything other than null).", "author": "EricWittmann", "createdAt": "2020-01-29T13:15:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2NDUwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3NzA0Nw==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372377047", "bodyText": "OK, makes sense", "author": "alesj", "createdAt": "2020-01-29T13:20:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2NDUwMw=="}], "type": "inlineReview"}, {"oid": "09138bae00a771bd38bbcc79ca587347219ac783", "url": "https://github.com/Apicurio/apicurio-registry/commit/09138bae00a771bd38bbcc79ca587347219ac783", "message": "Additional changes based on PR review", "committedDate": "2020-01-29T13:16:12Z", "type": "commit"}, {"oid": "b062d6e3e47bc873c06133ad2c21e59166f37e88", "url": "https://github.com/Apicurio/apicurio-registry/commit/b062d6e3e47bc873c06133ad2c21e59166f37e88", "message": "use IoUtil", "committedDate": "2020-01-29T13:19:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3ODg3OQ==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372378879", "bodyText": "BB::wrap ...", "author": "alesj", "createdAt": "2020-01-29T13:24:42Z", "path": "utils/serde/src/main/java/io/apicurio/registry/utils/serde/JsonSchemaKafkaDeserializer.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.utils.serde;\n+\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.nio.ByteBuffer;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.kafka.common.header.Header;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Deserializer;\n+\n+import com.fasterxml.jackson.core.JsonParser;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.worldturner.medeia.api.StringSchemaSource;\n+import com.worldturner.medeia.api.jackson.MedeiaJacksonApi;\n+import com.worldturner.medeia.schema.validation.SchemaValidator;\n+\n+import io.apicurio.registry.client.RegistryService;\n+import io.apicurio.registry.rest.beans.ArtifactMetaData;\n+import io.apicurio.registry.rest.beans.VersionMetaData;\n+import io.apicurio.registry.utils.IoUtil;\n+import io.apicurio.registry.utils.serde.util.Utils;\n+\n+/**\n+ * @author eric.wittmann@gmail.com\n+ */\n+public class JsonSchemaKafkaDeserializer<T> extends AbstractKafkaSerDe<JsonSchemaKafkaDeserializer<T>> implements Deserializer<T> {\n+\n+    private static MedeiaJacksonApi api = new MedeiaJacksonApi();\n+    private static ObjectMapper mapper = new ObjectMapper();\n+    \n+    private boolean validationEnabled = false;\n+    private SchemaCache<SchemaValidator> schemaCache;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public JsonSchemaKafkaDeserializer() {\n+        this(null, false);\n+    }\n+\n+    /**\n+     * Constructor.\n+     * @param client\n+     */\n+    public JsonSchemaKafkaDeserializer(RegistryService client, boolean validationEnabled) {\n+        super(client);\n+        \n+        this.validationEnabled = validationEnabled;\n+        \n+        this.schemaCache = new SchemaCache<SchemaValidator>(getClient()) {\n+            @Override\n+            protected SchemaValidator toSchema(Response response) {\n+                String schema = response.readEntity(String.class);\n+                return api.loadSchema(new StringSchemaSource(schema));\n+            }\n+        };\n+    }\n+\n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#configure(java.util.Map, boolean)\n+     */\n+    @Override\n+    public void configure(Map<String, ?> configs, boolean isKey) {\n+        super.configure(configs);\n+\n+        Object ve = configs.get(JsonSchemaSerDeConstants.REGISTRY_JSON_SCHEMA_VALIDATION_ENABLED);\n+        this.validationEnabled = Utils.isTrue(ve);\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#deserialize(java.lang.String, byte[])\n+     */\n+    @Override\n+    public T deserialize(String topic, byte[] data) {\n+        throw new UnsupportedOperationException();\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Deserializer#deserialize(java.lang.String, org.apache.kafka.common.header.Headers, byte[])\n+     */\n+    @Override\n+    public T deserialize(String topic, Headers headers, byte[] data) {\n+        if (data == null) {\n+            return null;\n+        }\n+        \n+        try {\n+            JsonParser parser = mapper.getFactory().createParser(data);\n+            if (validationEnabled) {\n+                Long globalId = getGlobalId(headers);\n+                \n+                // If no globalId is provided, check the alternative - which is to check for artifactId and \n+                // (optionally) version.  If these are found, then convert that info to globalId.\n+                if (globalId == null) {\n+                    String artifactId = getArtifactId(headers);\n+                    Integer version = getVersion(headers);\n+                    globalId = toGlobalId(artifactId, version);\n+                }\n+                \n+                SchemaValidator schema = schemaCache.getSchema(globalId);\n+                parser = api.decorateJsonParser(schema, parser);\n+            }\n+            \n+            Class<T> messageType = getMessageType(headers);\n+\n+            return mapper.readValue(parser, messageType);\n+        } catch (IOException e) {\n+            throw new UncheckedIOException(e);\n+        }\n+    }\n+\n+    /**\n+     * Gets the global id from the headers.  Returns null if not found.\n+     * @param headers\n+     */\n+    protected Long getGlobalId(Headers headers) {\n+        Header header = headers.lastHeader(JsonSchemaSerDeConstants.HEADER_GLOBAL_ID);\n+        if (header == null) {\n+            return null;\n+        }\n+        ByteBuffer buffer = ByteBuffer.allocate(header.value().length);", "originalCommit": "b062d6e3e47bc873c06133ad2c21e59166f37e88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDE2MA==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372390160", "bodyText": "Wrap!  Nice.", "author": "EricWittmann", "createdAt": "2020-01-29T13:46:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3ODg3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MDIwNw==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372380207", "bodyText": "Why not really just use existing globalIdStrategy instance? I still don't see why the 2?", "author": "alesj", "createdAt": "2020-01-29T13:27:24Z", "path": "utils/serde/src/main/java/io/apicurio/registry/utils/serde/JsonSchemaKafkaSerializer.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright 2020 Red Hat\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package io.apicurio.registry.utils.serde;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.Response;\n+\n+import org.apache.kafka.common.errors.SerializationException;\n+import org.apache.kafka.common.header.Headers;\n+import org.apache.kafka.common.serialization.Serializer;\n+\n+import com.fasterxml.jackson.core.JsonGenerator;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.worldturner.medeia.api.StringSchemaSource;\n+import com.worldturner.medeia.api.jackson.MedeiaJacksonApi;\n+import com.worldturner.medeia.schema.validation.SchemaValidator;\n+\n+import io.apicurio.registry.client.RegistryService;\n+import io.apicurio.registry.types.ArtifactType;\n+import io.apicurio.registry.utils.IoUtil;\n+import io.apicurio.registry.utils.serde.strategy.FindLatestIdStrategy;\n+import io.apicurio.registry.utils.serde.strategy.GlobalIdStrategy;\n+import io.apicurio.registry.utils.serde.util.Utils;\n+\n+/**\n+ * An implementation of the Kafka Serializer for JSON Schema use-cases. This serializer assumes that the\n+ * user's application needs to serialize a Java Bean to JSON data using Jackson. In addition to standard\n+ * serialization of the bean, this implementation can also optionally validate it against a JSON schema.\n+ * \n+ * @author eric.wittmann@gmail.com\n+ */\n+public class JsonSchemaKafkaSerializer<T>\n+        extends AbstractKafkaStrategyAwareSerDe<SchemaValidator, JsonSchemaKafkaSerializer<T>>\n+        implements Serializer<T> {\n+    \n+    private static MedeiaJacksonApi api = new MedeiaJacksonApi();\n+    private static ObjectMapper mapper = new ObjectMapper();\n+    private static GlobalIdStrategy<SchemaValidator> latestVersionStrategy = new FindLatestIdStrategy<>();\n+    \n+    private boolean validationEnabled = false;\n+    private SchemaCache<SchemaValidator> schemaCache;\n+\n+    /**\n+     * Constructor.\n+     */\n+    public JsonSchemaKafkaSerializer() {\n+    }\n+\n+    /**\n+     * Constructor.\n+     * @param client\n+     * @param validationEnabled\n+     */\n+    public JsonSchemaKafkaSerializer(RegistryService client, boolean validationEnabled) {\n+        super(client);\n+        \n+        this.validationEnabled = validationEnabled;\n+        this.schemaCache = new SchemaCache<SchemaValidator>(getClient()) {\n+            @Override\n+            protected SchemaValidator toSchema(Response response) {\n+                String schema = response.readEntity(String.class);\n+                return api.loadSchema(new StringSchemaSource(schema));\n+            }\n+        };\n+\n+    }\n+\n+    /**\n+     * @see org.apache.kafka.common.serialization.Serializer#configure(java.util.Map, boolean)\n+     */\n+    @Override\n+    public void configure(Map<String, ?> configs, boolean isKey) {\n+        super.configure(configs, isKey);\n+        \n+        Object ve = configs.get(JsonSchemaSerDeConstants.REGISTRY_JSON_SCHEMA_VALIDATION_ENABLED);\n+        this.validationEnabled = Utils.isTrue(ve);\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Serializer#serialize(java.lang.String, java.lang.Object)\n+     */\n+    @Override\n+    public byte[] serialize(String topic, T data) {\n+        // Headers are required when sending data using this serdes impl\n+        throw new UnsupportedOperationException();\n+    }\n+    \n+    /**\n+     * @see org.apache.kafka.common.serialization.Serializer#serialize(java.lang.String, org.apache.kafka.common.header.Headers, java.lang.Object)\n+     */\n+    @Override\n+    public byte[] serialize(String topic, Headers headers, T data) {\n+        if (data == null) {\n+            return new byte[0];\n+        }\n+\n+        // Now serialize the data\n+        try {\n+            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+            JsonGenerator generator = mapper.getFactory().createGenerator(baos);\n+            if (validationEnabled) {\n+                String artifactId = getArtifactId(topic, data);\n+                Long globalId = getArtifactVersionGlobalId(artifactId, topic, data);\n+                addSchemaHeaders(headers, artifactId, globalId);\n+\n+                SchemaValidator schemaValidator = schemaCache.getSchema(globalId);\n+                generator = api.decorateJsonGenerator(schemaValidator, generator);\n+            }\n+            addTypeHeaders(headers, data);\n+\n+            mapper.writeValue(generator, data);\n+            \n+            return baos.toByteArray();\n+        } catch (IOException e) {\n+            throw new SerializationException(e);\n+        }\n+    }\n+\n+    /**\n+     * Figure out the artifact ID from the topic name and data.\n+     * @param topic\n+     * @param data\n+     */\n+    protected String getArtifactId(String topic, T data) {\n+        // Note - for JSON Schema, we don't yet have the schema so we pass null to the strategy.\n+        return getArtifactIdStrategy().artifactId(topic, isKey(), null);\n+    }\n+\n+    /**\n+     * Gets the global id of the schema to use for validation.\n+     * @param artifactId\n+     * @param topic\n+     * @param data\n+     */\n+    protected Long getArtifactVersionGlobalId(String artifactId, String topic, T data) {\n+        if (getGlobalIdStrategy() == null) {\n+            return latestVersionStrategy.findId(getClient(), artifactId, ArtifactType.JSON, null);", "originalCommit": "b062d6e3e47bc873c06133ad2c21e59166f37e88", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MzMwMg==", "url": "https://github.com/Apicurio/apicurio-registry/pull/244#discussion_r372393302", "bodyText": "It was supposed to just be a default.  But maybe you're right and it's not needed.  Just fail if it's not set...  Originally when I was using ArtifactId and Version this made more sense, but maybe not anymore.  I've changed this to make the intention more clear, but let me know if you think we should just fail when the strategy is not set.", "author": "EricWittmann", "createdAt": "2020-01-29T13:52:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MDIwNw=="}], "type": "inlineReview"}, {"oid": "f5dd2dd010fb3111607174e697c43108f32184a8", "url": "https://github.com/Apicurio/apicurio-registry/commit/f5dd2dd010fb3111607174e697c43108f32184a8", "message": "make the default global id strategy clearer", "committedDate": "2020-01-29T13:51:28Z", "type": "commit"}]}