{"pr_number": 8940, "pr_title": "ISPN-11398 Change XSiteStateTransferProviderImpl to be non blocking", "pr_createdAt": "2020-12-16T16:56:44Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8940", "timeline": [{"oid": "18bb9f284c6f7350114d13a631ee81ae2511ad86", "url": "https://github.com/infinispan/infinispan/commit/18bb9f284c6f7350114d13a631ee81ae2511ad86", "message": "ISPN-11398 Change XSiteStateTransferProviderImpl to be non blocking", "committedDate": "2020-12-16T17:10:35Z", "type": "forcePushed"}, {"oid": "6da3f34ce5317e73d6cd48365b37c85ad0e4d899", "url": "https://github.com/infinispan/infinispan/commit/6da3f34ce5317e73d6cd48365b37c85ad0e4d899", "message": "ISPN-11398 Change XSiteStateTransferProviderImpl to be non blocking", "committedDate": "2021-01-06T10:08:37Z", "type": "forcePushed"}, {"oid": "86aa26ca2e9d2df66c0f2312dc80db897dd682f3", "url": "https://github.com/infinispan/infinispan/commit/86aa26ca2e9d2df66c0f2312dc80db897dd682f3", "message": "ISPN-11398 Change XSiteStateTransferProviderImpl to be non blocking", "committedDate": "2021-01-06T15:14:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg4MjM2Mg==", "url": "https://github.com/infinispan/infinispan/pull/8940#discussion_r552882362", "bodyText": "Is this executor really needed? I would think the concatMap operation should be non blocking.", "author": "wburns", "createdAt": "2021-01-06T18:18:39Z", "path": "core/src/main/java/org/infinispan/xsite/statetransfer/SyncProviderState.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package org.infinispan.xsite.statetransfer;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.XSiteStateTransferConfiguration;\n+import org.infinispan.remoting.transport.Address;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.infinispan.xsite.XSiteBackup;\n+\n+import io.reactivex.rxjava3.annotations.NonNull;\n+import io.reactivex.rxjava3.core.Completable;\n+import io.reactivex.rxjava3.core.CompletableObserver;\n+import io.reactivex.rxjava3.core.CompletableSource;\n+import io.reactivex.rxjava3.core.Flowable;\n+import io.reactivex.rxjava3.disposables.Disposable;\n+import io.reactivex.rxjava3.functions.Function;\n+import io.reactivex.rxjava3.functions.Predicate;\n+import net.jcip.annotations.GuardedBy;\n+\n+/**\n+ * A {@link XSiteStateProviderState} for synchronous cross-site replication state transfer.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12.0\n+ */\n+public class SyncProviderState implements XSiteStateProviderState {\n+\n+   private static final Log log = LogFactory.getLog(SyncProviderState.class);\n+   private static final AtomicReferenceFieldUpdater<SyncProviderState, OutboundTask> TASK_UPDATER = AtomicReferenceFieldUpdater.newUpdater(SyncProviderState.class, OutboundTask.class, \"task\");\n+\n+   private final XSiteBackup backup;\n+   private final XSiteStateTransferConfiguration configuration;\n+   private volatile OutboundTask task;\n+\n+   private SyncProviderState(XSiteBackup backup, XSiteStateTransferConfiguration configuration) {\n+      this.backup = backup;\n+      this.configuration = configuration;\n+   }\n+\n+   public static SyncProviderState create(BackupConfiguration config) {\n+      XSiteBackup backup = new XSiteBackup(config.site(), true, config.stateTransfer().timeout());\n+      return new SyncProviderState(backup, config.stateTransfer());\n+   }\n+\n+   @Override\n+   public XSiteStatePushTask createPushTask(Address originator, XSiteStateProvider provider) {\n+      OutboundTask newTask = new OutboundTask(originator, provider, this);\n+      return TASK_UPDATER.compareAndSet(this, null, newTask) ? newTask : null;\n+   }\n+\n+   @Override\n+   public void cancelTransfer() {\n+      OutboundTask currentTask = TASK_UPDATER.getAndSet(this, null);\n+      if (currentTask != null) {\n+         currentTask.cancel();\n+      }\n+   }\n+\n+   @Override\n+   public boolean isSending() {\n+      return task != null;\n+   }\n+\n+   @Override\n+   public boolean isOriginatorMissing(Collection<Address> members) {\n+      OutboundTask currentTask = task;\n+      return currentTask != null && !members.contains(currentTask.coordinator);\n+   }\n+\n+   // methods for OutboundTask\n+   void taskFinished() {\n+      TASK_UPDATER.set(this, null);\n+   }\n+\n+   XSiteBackup getBackup() {\n+      return backup;\n+   }\n+\n+   int getChunkSize() {\n+      return configuration.chunkSize();\n+   }\n+\n+   long getWaitTimeMillis() {\n+      return configuration.waitTime();\n+   }\n+\n+   int getMaxRetries() {\n+      return configuration.maxRetries();\n+   }\n+\n+   private static class OutboundTask implements XSiteStatePushTask, Predicate<List<XSiteState>>, Function<List<XSiteState>, CompletableSource>, CompletableObserver {\n+\n+      private final Address coordinator;\n+      private final XSiteStateProvider provider;\n+      private final SyncProviderState state;\n+      private volatile boolean canceled = false;\n+\n+      private OutboundTask(Address coordinator, XSiteStateProvider provider, SyncProviderState state) {\n+         this.coordinator = coordinator;\n+         this.provider = provider;\n+         this.state = state;\n+      }\n+\n+      @Override\n+      public void execute(Flowable<XSiteState> flowable, CompletionStage<Void> delayer) {\n+         //delayer is the cache topology future. we need to ensure the topology id is installed before iterating\n+         delayer.thenRunAsync(() -> flowable\n+                     .buffer(state.getChunkSize())\n+                     .takeUntil(this)\n+                     .concatMapCompletable(this, 1)\n+                     .subscribe(this),\n+               provider.getExecutor());", "originalCommit": "86aa26ca2e9d2df66c0f2312dc80db897dd682f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIxNzAzNw==", "url": "https://github.com/infinispan/infinispan/pull/8940#discussion_r553217037", "bodyText": "really needed? no.\nBut is it better to do the iteration in another thread. The delayer future is completed in org.infinispan.statetransfer.StateTransferLockImpl#notifyTopologyInstalled when the node is installing the CacheTopology. I don't want to start iterating the data container entries while there is pending work to finish the CacheTopology update.", "author": "pruivo", "createdAt": "2021-01-07T09:44:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg4MjM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTg3NDkxNQ==", "url": "https://github.com/infinispan/infinispan/pull/8940#discussion_r555874915", "bodyText": "Ah okay I wasn't aware this is invoked during a topology update. Then I agree to make sure it completes as quick as possible offloading to another thread is good.", "author": "wburns", "createdAt": "2021-01-12T15:47:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg4MjM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg4MzIxNA==", "url": "https://github.com/infinispan/infinispan/pull/8940#discussion_r552883214", "bodyText": "Is this throwable logged somewhere?", "author": "wburns", "createdAt": "2021-01-06T18:19:38Z", "path": "core/src/main/java/org/infinispan/xsite/statetransfer/SyncProviderState.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package org.infinispan.xsite.statetransfer;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.XSiteStateTransferConfiguration;\n+import org.infinispan.remoting.transport.Address;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.infinispan.xsite.XSiteBackup;\n+\n+import io.reactivex.rxjava3.annotations.NonNull;\n+import io.reactivex.rxjava3.core.Completable;\n+import io.reactivex.rxjava3.core.CompletableObserver;\n+import io.reactivex.rxjava3.core.CompletableSource;\n+import io.reactivex.rxjava3.core.Flowable;\n+import io.reactivex.rxjava3.disposables.Disposable;\n+import io.reactivex.rxjava3.functions.Function;\n+import io.reactivex.rxjava3.functions.Predicate;\n+import net.jcip.annotations.GuardedBy;\n+\n+/**\n+ * A {@link XSiteStateProviderState} for synchronous cross-site replication state transfer.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12.0\n+ */\n+public class SyncProviderState implements XSiteStateProviderState {\n+\n+   private static final Log log = LogFactory.getLog(SyncProviderState.class);\n+   private static final AtomicReferenceFieldUpdater<SyncProviderState, OutboundTask> TASK_UPDATER = AtomicReferenceFieldUpdater.newUpdater(SyncProviderState.class, OutboundTask.class, \"task\");\n+\n+   private final XSiteBackup backup;\n+   private final XSiteStateTransferConfiguration configuration;\n+   private volatile OutboundTask task;\n+\n+   private SyncProviderState(XSiteBackup backup, XSiteStateTransferConfiguration configuration) {\n+      this.backup = backup;\n+      this.configuration = configuration;\n+   }\n+\n+   public static SyncProviderState create(BackupConfiguration config) {\n+      XSiteBackup backup = new XSiteBackup(config.site(), true, config.stateTransfer().timeout());\n+      return new SyncProviderState(backup, config.stateTransfer());\n+   }\n+\n+   @Override\n+   public XSiteStatePushTask createPushTask(Address originator, XSiteStateProvider provider) {\n+      OutboundTask newTask = new OutboundTask(originator, provider, this);\n+      return TASK_UPDATER.compareAndSet(this, null, newTask) ? newTask : null;\n+   }\n+\n+   @Override\n+   public void cancelTransfer() {\n+      OutboundTask currentTask = TASK_UPDATER.getAndSet(this, null);\n+      if (currentTask != null) {\n+         currentTask.cancel();\n+      }\n+   }\n+\n+   @Override\n+   public boolean isSending() {\n+      return task != null;\n+   }\n+\n+   @Override\n+   public boolean isOriginatorMissing(Collection<Address> members) {\n+      OutboundTask currentTask = task;\n+      return currentTask != null && !members.contains(currentTask.coordinator);\n+   }\n+\n+   // methods for OutboundTask\n+   void taskFinished() {\n+      TASK_UPDATER.set(this, null);\n+   }\n+\n+   XSiteBackup getBackup() {\n+      return backup;\n+   }\n+\n+   int getChunkSize() {\n+      return configuration.chunkSize();\n+   }\n+\n+   long getWaitTimeMillis() {\n+      return configuration.waitTime();\n+   }\n+\n+   int getMaxRetries() {\n+      return configuration.maxRetries();\n+   }\n+\n+   private static class OutboundTask implements XSiteStatePushTask, Predicate<List<XSiteState>>, Function<List<XSiteState>, CompletableSource>, CompletableObserver {\n+\n+      private final Address coordinator;\n+      private final XSiteStateProvider provider;\n+      private final SyncProviderState state;\n+      private volatile boolean canceled = false;\n+\n+      private OutboundTask(Address coordinator, XSiteStateProvider provider, SyncProviderState state) {\n+         this.coordinator = coordinator;\n+         this.provider = provider;\n+         this.state = state;\n+      }\n+\n+      @Override\n+      public void execute(Flowable<XSiteState> flowable, CompletionStage<Void> delayer) {\n+         //delayer is the cache topology future. we need to ensure the topology id is installed before iterating\n+         delayer.thenRunAsync(() -> flowable\n+                     .buffer(state.getChunkSize())\n+                     .takeUntil(this)\n+                     .concatMapCompletable(this, 1)\n+                     .subscribe(this),\n+               provider.getExecutor());\n+\n+      }\n+\n+      public void cancel() {\n+         canceled = true;\n+      }\n+\n+      @Override\n+      public boolean test(List<XSiteState> ignored) {\n+         //Flowable#takeUntil method\n+         return canceled;\n+      }\n+\n+      @Override\n+      public void onSubscribe(@NonNull Disposable d) {\n+\n+      }\n+\n+      @Override\n+      public void onComplete() {\n+         //if canceled, the coordinator already cleanup the resources. There is nothing to be done here.\n+         if (canceled) {\n+            return;\n+         }\n+         provider.notifyStateTransferEnd(state.getBackup().getSiteName(), coordinator, true);\n+         state.taskFinished();\n+      }\n+\n+      @Override\n+      public void onError(@NonNull Throwable e) {\n+         //if canceled, the coordinator already cleanup the resources. There is nothing to be done here.\n+         if (canceled) {\n+            return;\n+         }\n+         provider.notifyStateTransferEnd(state.getBackup().getSiteName(), coordinator, false);", "originalCommit": "86aa26ca2e9d2df66c0f2312dc80db897dd682f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIxMzE5Nw==", "url": "https://github.com/infinispan/infinispan/pull/8940#discussion_r553213197", "bodyText": "no, I'll add it to the CommandRetry class.", "author": "pruivo", "createdAt": "2021-01-07T09:37:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg4MzIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg4NTYzOA==", "url": "https://github.com/infinispan/infinispan/pull/8940#discussion_r552885638", "bodyText": "Same thing here about the use of the executor, does the RpcManager#invokeXSite method block or something?", "author": "wburns", "createdAt": "2021-01-06T18:22:15Z", "path": "core/src/main/java/org/infinispan/xsite/statetransfer/SyncProviderState.java", "diffHunk": "@@ -0,0 +1,239 @@\n+package org.infinispan.xsite.statetransfer;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.CompletionStage;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n+\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.XSiteStateTransferConfiguration;\n+import org.infinispan.remoting.transport.Address;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+import org.infinispan.util.logging.Log;\n+import org.infinispan.util.logging.LogFactory;\n+import org.infinispan.xsite.XSiteBackup;\n+\n+import io.reactivex.rxjava3.annotations.NonNull;\n+import io.reactivex.rxjava3.core.Completable;\n+import io.reactivex.rxjava3.core.CompletableObserver;\n+import io.reactivex.rxjava3.core.CompletableSource;\n+import io.reactivex.rxjava3.core.Flowable;\n+import io.reactivex.rxjava3.disposables.Disposable;\n+import io.reactivex.rxjava3.functions.Function;\n+import io.reactivex.rxjava3.functions.Predicate;\n+import net.jcip.annotations.GuardedBy;\n+\n+/**\n+ * A {@link XSiteStateProviderState} for synchronous cross-site replication state transfer.\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12.0\n+ */\n+public class SyncProviderState implements XSiteStateProviderState {\n+\n+   private static final Log log = LogFactory.getLog(SyncProviderState.class);\n+   private static final AtomicReferenceFieldUpdater<SyncProviderState, OutboundTask> TASK_UPDATER = AtomicReferenceFieldUpdater.newUpdater(SyncProviderState.class, OutboundTask.class, \"task\");\n+\n+   private final XSiteBackup backup;\n+   private final XSiteStateTransferConfiguration configuration;\n+   private volatile OutboundTask task;\n+\n+   private SyncProviderState(XSiteBackup backup, XSiteStateTransferConfiguration configuration) {\n+      this.backup = backup;\n+      this.configuration = configuration;\n+   }\n+\n+   public static SyncProviderState create(BackupConfiguration config) {\n+      XSiteBackup backup = new XSiteBackup(config.site(), true, config.stateTransfer().timeout());\n+      return new SyncProviderState(backup, config.stateTransfer());\n+   }\n+\n+   @Override\n+   public XSiteStatePushTask createPushTask(Address originator, XSiteStateProvider provider) {\n+      OutboundTask newTask = new OutboundTask(originator, provider, this);\n+      return TASK_UPDATER.compareAndSet(this, null, newTask) ? newTask : null;\n+   }\n+\n+   @Override\n+   public void cancelTransfer() {\n+      OutboundTask currentTask = TASK_UPDATER.getAndSet(this, null);\n+      if (currentTask != null) {\n+         currentTask.cancel();\n+      }\n+   }\n+\n+   @Override\n+   public boolean isSending() {\n+      return task != null;\n+   }\n+\n+   @Override\n+   public boolean isOriginatorMissing(Collection<Address> members) {\n+      OutboundTask currentTask = task;\n+      return currentTask != null && !members.contains(currentTask.coordinator);\n+   }\n+\n+   // methods for OutboundTask\n+   void taskFinished() {\n+      TASK_UPDATER.set(this, null);\n+   }\n+\n+   XSiteBackup getBackup() {\n+      return backup;\n+   }\n+\n+   int getChunkSize() {\n+      return configuration.chunkSize();\n+   }\n+\n+   long getWaitTimeMillis() {\n+      return configuration.waitTime();\n+   }\n+\n+   int getMaxRetries() {\n+      return configuration.maxRetries();\n+   }\n+\n+   private static class OutboundTask implements XSiteStatePushTask, Predicate<List<XSiteState>>, Function<List<XSiteState>, CompletableSource>, CompletableObserver {\n+\n+      private final Address coordinator;\n+      private final XSiteStateProvider provider;\n+      private final SyncProviderState state;\n+      private volatile boolean canceled = false;\n+\n+      private OutboundTask(Address coordinator, XSiteStateProvider provider, SyncProviderState state) {\n+         this.coordinator = coordinator;\n+         this.provider = provider;\n+         this.state = state;\n+      }\n+\n+      @Override\n+      public void execute(Flowable<XSiteState> flowable, CompletionStage<Void> delayer) {\n+         //delayer is the cache topology future. we need to ensure the topology id is installed before iterating\n+         delayer.thenRunAsync(() -> flowable\n+                     .buffer(state.getChunkSize())\n+                     .takeUntil(this)\n+                     .concatMapCompletable(this, 1)\n+                     .subscribe(this),\n+               provider.getExecutor());\n+\n+      }\n+\n+      public void cancel() {\n+         canceled = true;\n+      }\n+\n+      @Override\n+      public boolean test(List<XSiteState> ignored) {\n+         //Flowable#takeUntil method\n+         return canceled;\n+      }\n+\n+      @Override\n+      public void onSubscribe(@NonNull Disposable d) {\n+\n+      }\n+\n+      @Override\n+      public void onComplete() {\n+         //if canceled, the coordinator already cleanup the resources. There is nothing to be done here.\n+         if (canceled) {\n+            return;\n+         }\n+         provider.notifyStateTransferEnd(state.getBackup().getSiteName(), coordinator, true);\n+         state.taskFinished();\n+      }\n+\n+      @Override\n+      public void onError(@NonNull Throwable e) {\n+         //if canceled, the coordinator already cleanup the resources. There is nothing to be done here.\n+         if (canceled) {\n+            return;\n+         }\n+         provider.notifyStateTransferEnd(state.getBackup().getSiteName(), coordinator, false);\n+         state.taskFinished();\n+      }\n+\n+      @Override\n+      public CompletableSource apply(List<XSiteState> xSiteStates) {\n+         //Flowable#concatMapCompletable method\n+         XSiteBackup backup = state.getBackup();\n+         //TODO!? can we use xSiteStates directly instead of copying?\n+         XSiteState[] privateBuffer = xSiteStates.toArray(new XSiteState[0]);\n+\n+         if (log.isDebugEnabled()) {\n+            log.debugf(\"Sending chunk to site '%s'. Chunk has %s keys.\", backup.getSiteName(), privateBuffer.length);\n+         }\n+\n+         XSiteStatePushCommand command = provider.getCommandsFactory().buildXSiteStatePushCommand(privateBuffer, backup.getTimeout());\n+         return Completable.fromCompletionStage(new CommandRetry(backup, command, provider, state.getWaitTimeMillis(), state.getMaxRetries()).send());\n+      }\n+   }\n+\n+   private static class CommandRetry extends CompletableFuture<Void> implements java.util.function.BiConsumer<Void, Throwable> {\n+\n+      private final XSiteBackup backup;\n+      private final XSiteStatePushCommand cmd;\n+      private final XSiteStateProvider provider;\n+      private final long waitTimeMillis;\n+      @GuardedBy(\"this\")\n+      private int maxRetries;\n+\n+      private CommandRetry(XSiteBackup backup, XSiteStatePushCommand cmd, XSiteStateProvider provider, long waitTimeMillis, int maxRetries) {\n+         this.backup = backup;\n+         this.cmd = cmd;\n+         this.provider = provider;\n+         this.waitTimeMillis = waitTimeMillis;\n+         this.maxRetries = maxRetries;\n+      }\n+\n+      //method to invoke from other class\n+      CompletionStage<Void> send() {\n+         doSend();\n+         return this;\n+      }\n+\n+      //used in scheduled executor, invokes doSend after the wait time.\n+      void nonBlockingSend() {\n+         provider.getExecutor().execute(this::doSend);", "originalCommit": "86aa26ca2e9d2df66c0f2312dc80db897dd682f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzIxODkzMg==", "url": "https://github.com/infinispan/infinispan/pull/8940#discussion_r553218932", "bodyText": "it can block in JGroups' flow control. And since the ScheduledExecutorService (TIMEOUT_SCHEDULE_EXECUTOR) only contains a single thread, if the thread blocks you will be unable to trigger timeouts :/", "author": "pruivo", "createdAt": "2021-01-07T09:47:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg4NTYzOA=="}], "type": "inlineReview"}, {"oid": "f1d50b5cb2f313e93e87311399a9e37a3039866d", "url": "https://github.com/infinispan/infinispan/commit/f1d50b5cb2f313e93e87311399a9e37a3039866d", "message": "ISPN-11398 Change XSiteStateTransferProviderImpl to be non blocking", "committedDate": "2021-01-07T10:03:29Z", "type": "commit"}, {"oid": "f1d50b5cb2f313e93e87311399a9e37a3039866d", "url": "https://github.com/infinispan/infinispan/commit/f1d50b5cb2f313e93e87311399a9e37a3039866d", "message": "ISPN-11398 Change XSiteStateTransferProviderImpl to be non blocking", "committedDate": "2021-01-07T10:03:29Z", "type": "forcePushed"}]}