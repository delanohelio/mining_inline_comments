{"pr_number": 7742, "pr_title": "ISPN-11164 clustered max idle doc update", "pr_createdAt": "2020-01-16T12:06:09Z", "pr_url": "https://github.com/infinispan/infinispan/pull/7742", "timeline": [{"oid": "a2a59649ffcc2203906aeaf5f0a9247f9c86dde1", "url": "https://github.com/infinispan/infinispan/commit/a2a59649ffcc2203906aeaf5f0a9247f9c86dde1", "message": "off heap and cache stores not supported", "committedDate": "2020-01-16T16:47:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NTUxNA==", "url": "https://github.com/infinispan/infinispan/pull/7742#discussion_r367555514", "bodyText": "It also isn't implemented :)", "author": "wburns", "createdAt": "2020-01-16T17:35:14Z", "path": "documentation/src/main/asciidoc/topics/eviction.adoc", "diffHunk": "@@ -211,44 +211,53 @@ Maximum idle expiration has different behavior in local and clustered cache envi\n \n [[expiration_maxidle_local]]\n ==== Local Max Idle\n+In local cache mode, {brandname} expires entries with the `maxIdle` configuration when:\n \n-In non-clustered cache environments, the `maxIdle` configuration expires entries when:\n-\n-* accessed directly (`Cache.get`).\n-* iterated upon (`Cache.size`).\n+* accessed directly (`Cache.get()`).\n+* iterated upon (`Cache.size()`).\n * the expiration reaper thread runs.\n \n [[expiration_maxidle_clustered]]\n ==== Clustered Max Idle\n+In clustered cache modes, when clients read entries that have `max-idle`\n+expiration values, {brandname} sends touch commands to all owners. This ensures\n+that the entries have the same relative access time across the cluster.\n \n-In clustered environments, nodes in the cluster can have different access times\n-for the same entry. Entries do not expire from the cache until they reach the\n-maxium idle time for all owners across the cluster.\n+When nodes detect that an entry reaches the maximum idle time, {brandname}\n+removes it from the cache and does not return the entry to the client that\n+requested it.\n \n-When a node detects that an entry has reached the maximum idle time and is\n-expired, the node gets the last time that the entry was accessed from the other\n-owners in the cluster. If the other owners indicate that the entry is expired,\n-that entry is not returned to the requester and removed from the cache.\n+[IMPORTANT]\n+====\n+Clustered `max-idle` does not work with entries stored in off-heap memory.\n+\n+Likewise, using clustered `max-idle` with entries persisted via cache stores\n+results in significant performance degradation. You should not use clustered ", "originalCommit": "a2a59649ffcc2203906aeaf5f0a9247f9c86dde1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NTk2Mg==", "url": "https://github.com/infinispan/infinispan/pull/7742#discussion_r367555962", "bodyText": "This can now be removed.", "author": "wburns", "createdAt": "2020-01-16T17:36:13Z", "path": "documentation/src/main/asciidoc/topics/eviction.adoc", "diffHunk": "@@ -211,44 +211,53 @@ Maximum idle expiration has different behavior in local and clustered cache envi\n \n [[expiration_maxidle_local]]\n ==== Local Max Idle\n+In local cache mode, {brandname} expires entries with the `maxIdle` configuration when:\n \n-In non-clustered cache environments, the `maxIdle` configuration expires entries when:\n-\n-* accessed directly (`Cache.get`).\n-* iterated upon (`Cache.size`).\n+* accessed directly (`Cache.get()`).\n+* iterated upon (`Cache.size()`).\n * the expiration reaper thread runs.\n \n [[expiration_maxidle_clustered]]\n ==== Clustered Max Idle\n+In clustered cache modes, when clients read entries that have `max-idle`\n+expiration values, {brandname} sends touch commands to all owners. This ensures\n+that the entries have the same relative access time across the cluster.\n \n-In clustered environments, nodes in the cluster can have different access times\n-for the same entry. Entries do not expire from the cache until they reach the\n-maxium idle time for all owners across the cluster.\n+When nodes detect that an entry reaches the maximum idle time, {brandname}\n+removes it from the cache and does not return the entry to the client that\n+requested it.\n \n-When a node detects that an entry has reached the maximum idle time and is\n-expired, the node gets the last time that the entry was accessed from the other\n-owners in the cluster. If the other owners indicate that the entry is expired,\n-that entry is not returned to the requester and removed from the cache.\n+[IMPORTANT]\n+====\n+Clustered `max-idle` does not work with entries stored in off-heap memory.\n+\n+Likewise, using clustered `max-idle` with entries persisted via cache stores\n+results in significant performance degradation. You should not use clustered \n+`max-idle` with cache stores.\n+====\n \n-The following points apply to using the `maxIdle` configuration with clustered\n-caches:\n+Before using clustered `max-idle`, you should review the following points:\n \n-* If one or more owner in the cluster detects that an entry is not expired,\n-then a `Cache.get` operation returns the entry. The last access time for that\n-entry is also updated to the current time.\n+* `Cache.get()` does not return until the touch commands complete. This synchronous behavior increases latency of client requests.\n+* Clustered `max-idle` also updates the recent access count for eviction on all owners.\n+//Scattered cache is community only\n+ifndef::productized[]\n+* With scattered cache mode, {brandname} sends touch commands to all nodes, not\n+just primary and backup owners.\n+endif::productized[]\n * When the expiration reaper finds entries that might be expired with the", "originalCommit": "a2a59649ffcc2203906aeaf5f0a9247f9c86dde1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NjAzOQ==", "url": "https://github.com/infinispan/infinispan/pull/7742#discussion_r367556039", "bodyText": "This can now be removed.", "author": "wburns", "createdAt": "2020-01-16T17:36:25Z", "path": "documentation/src/main/asciidoc/topics/eviction.adoc", "diffHunk": "@@ -211,44 +211,53 @@ Maximum idle expiration has different behavior in local and clustered cache envi\n \n [[expiration_maxidle_local]]\n ==== Local Max Idle\n+In local cache mode, {brandname} expires entries with the `maxIdle` configuration when:\n \n-In non-clustered cache environments, the `maxIdle` configuration expires entries when:\n-\n-* accessed directly (`Cache.get`).\n-* iterated upon (`Cache.size`).\n+* accessed directly (`Cache.get()`).\n+* iterated upon (`Cache.size()`).\n * the expiration reaper thread runs.\n \n [[expiration_maxidle_clustered]]\n ==== Clustered Max Idle\n+In clustered cache modes, when clients read entries that have `max-idle`\n+expiration values, {brandname} sends touch commands to all owners. This ensures\n+that the entries have the same relative access time across the cluster.\n \n-In clustered environments, nodes in the cluster can have different access times\n-for the same entry. Entries do not expire from the cache until they reach the\n-maxium idle time for all owners across the cluster.\n+When nodes detect that an entry reaches the maximum idle time, {brandname}\n+removes it from the cache and does not return the entry to the client that\n+requested it.\n \n-When a node detects that an entry has reached the maximum idle time and is\n-expired, the node gets the last time that the entry was accessed from the other\n-owners in the cluster. If the other owners indicate that the entry is expired,\n-that entry is not returned to the requester and removed from the cache.\n+[IMPORTANT]\n+====\n+Clustered `max-idle` does not work with entries stored in off-heap memory.\n+\n+Likewise, using clustered `max-idle` with entries persisted via cache stores\n+results in significant performance degradation. You should not use clustered \n+`max-idle` with cache stores.\n+====\n \n-The following points apply to using the `maxIdle` configuration with clustered\n-caches:\n+Before using clustered `max-idle`, you should review the following points:\n \n-* If one or more owner in the cluster detects that an entry is not expired,\n-then a `Cache.get` operation returns the entry. The last access time for that\n-entry is also updated to the current time.\n+* `Cache.get()` does not return until the touch commands complete. This synchronous behavior increases latency of client requests.\n+* Clustered `max-idle` also updates the recent access count for eviction on all owners.\n+//Scattered cache is community only\n+ifndef::productized[]\n+* With scattered cache mode, {brandname} sends touch commands to all nodes, not\n+just primary and backup owners.\n+endif::productized[]\n * When the expiration reaper finds entries that might be expired with the\n maximum idle time, all nodes update the last access time for those entries\n to the most recent access time before the `maxIdle` time. In this way, the\n reaper prevents invalid expiration of entries.\n * Clustered transactional caches do *not* remove entries that are expired", "originalCommit": "a2a59649ffcc2203906aeaf5f0a9247f9c86dde1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NzM4Mg==", "url": "https://github.com/infinispan/infinispan/pull/7742#discussion_r367557382", "bodyText": "This is actually just max-idle in general not even clustered.", "author": "wburns", "createdAt": "2020-01-16T17:39:24Z", "path": "documentation/src/main/asciidoc/topics/eviction.adoc", "diffHunk": "@@ -211,44 +211,53 @@ Maximum idle expiration has different behavior in local and clustered cache envi\n \n [[expiration_maxidle_local]]\n ==== Local Max Idle\n+In local cache mode, {brandname} expires entries with the `maxIdle` configuration when:\n \n-In non-clustered cache environments, the `maxIdle` configuration expires entries when:\n-\n-* accessed directly (`Cache.get`).\n-* iterated upon (`Cache.size`).\n+* accessed directly (`Cache.get()`).\n+* iterated upon (`Cache.size()`).\n * the expiration reaper thread runs.\n \n [[expiration_maxidle_clustered]]\n ==== Clustered Max Idle\n+In clustered cache modes, when clients read entries that have `max-idle`\n+expiration values, {brandname} sends touch commands to all owners. This ensures\n+that the entries have the same relative access time across the cluster.\n \n-In clustered environments, nodes in the cluster can have different access times\n-for the same entry. Entries do not expire from the cache until they reach the\n-maxium idle time for all owners across the cluster.\n+When nodes detect that an entry reaches the maximum idle time, {brandname}\n+removes it from the cache and does not return the entry to the client that\n+requested it.\n \n-When a node detects that an entry has reached the maximum idle time and is\n-expired, the node gets the last time that the entry was accessed from the other\n-owners in the cluster. If the other owners indicate that the entry is expired,\n-that entry is not returned to the requester and removed from the cache.\n+[IMPORTANT]\n+====\n+Clustered `max-idle` does not work with entries stored in off-heap memory.", "originalCommit": "a2a59649ffcc2203906aeaf5f0a9247f9c86dde1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzU1NzQ1OQ==", "url": "https://github.com/infinispan/infinispan/pull/7742#discussion_r367557459", "bodyText": "Same here it is just max-idle in general.", "author": "wburns", "createdAt": "2020-01-16T17:39:34Z", "path": "documentation/src/main/asciidoc/topics/eviction.adoc", "diffHunk": "@@ -211,44 +211,53 @@ Maximum idle expiration has different behavior in local and clustered cache envi\n \n [[expiration_maxidle_local]]\n ==== Local Max Idle\n+In local cache mode, {brandname} expires entries with the `maxIdle` configuration when:\n \n-In non-clustered cache environments, the `maxIdle` configuration expires entries when:\n-\n-* accessed directly (`Cache.get`).\n-* iterated upon (`Cache.size`).\n+* accessed directly (`Cache.get()`).\n+* iterated upon (`Cache.size()`).\n * the expiration reaper thread runs.\n \n [[expiration_maxidle_clustered]]\n ==== Clustered Max Idle\n+In clustered cache modes, when clients read entries that have `max-idle`\n+expiration values, {brandname} sends touch commands to all owners. This ensures\n+that the entries have the same relative access time across the cluster.\n \n-In clustered environments, nodes in the cluster can have different access times\n-for the same entry. Entries do not expire from the cache until they reach the\n-maxium idle time for all owners across the cluster.\n+When nodes detect that an entry reaches the maximum idle time, {brandname}\n+removes it from the cache and does not return the entry to the client that\n+requested it.\n \n-When a node detects that an entry has reached the maximum idle time and is\n-expired, the node gets the last time that the entry was accessed from the other\n-owners in the cluster. If the other owners indicate that the entry is expired,\n-that entry is not returned to the requester and removed from the cache.\n+[IMPORTANT]\n+====\n+Clustered `max-idle` does not work with entries stored in off-heap memory.\n+\n+Likewise, using clustered `max-idle` with entries persisted via cache stores", "originalCommit": "a2a59649ffcc2203906aeaf5f0a9247f9c86dde1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b2469a789e0b038dc7908f53046cf40e75b87852", "url": "https://github.com/infinispan/infinispan/commit/b2469a789e0b038dc7908f53046cf40e75b87852", "message": "ISPN-11164 clustered max idle doc update", "committedDate": "2020-01-16T18:13:51Z", "type": "commit"}, {"oid": "b2469a789e0b038dc7908f53046cf40e75b87852", "url": "https://github.com/infinispan/infinispan/commit/b2469a789e0b038dc7908f53046cf40e75b87852", "message": "ISPN-11164 clustered max idle doc update", "committedDate": "2020-01-16T18:13:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzMjQ3Nw==", "url": "https://github.com/infinispan/infinispan/pull/7742#discussion_r367832477", "bodyText": "Nitpicking, but we don't give the users a choice between clustered and non-clustered max-idle.", "author": "danberindei", "createdAt": "2020-01-17T09:10:05Z", "path": "documentation/src/main/asciidoc/topics/eviction.adoc", "diffHunk": "@@ -209,46 +209,45 @@ can result in slower operation times.\n \n Maximum idle expiration has different behavior in local and clustered cache environments.\n \n+[IMPORTANT]\n+====\n+Maximum idle expiration, `max-idle`, does not currently work with entries stored in off-heap memory.\n+\n+Likewise, `max-idle` does not work if caches use cache stores as a persistence layer.\n+====\n+\n [[expiration_maxidle_local]]\n ==== Local Max Idle\n+In local cache mode, {brandname} expires entries with the `maxIdle` configuration when:\n \n-In non-clustered cache environments, the `maxIdle` configuration expires entries when:\n-\n-* accessed directly (`Cache.get`).\n-* iterated upon (`Cache.size`).\n+* accessed directly (`Cache.get()`).\n+* iterated upon (`Cache.size()`).\n * the expiration reaper thread runs.\n \n [[expiration_maxidle_clustered]]\n ==== Clustered Max Idle\n-\n-In clustered environments, nodes in the cluster can have different access times\n-for the same entry. Entries do not expire from the cache until they reach the\n-maxium idle time for all owners across the cluster.\n-\n-When a node detects that an entry has reached the maximum idle time and is\n-expired, the node gets the last time that the entry was accessed from the other\n-owners in the cluster. If the other owners indicate that the entry is expired,\n-that entry is not returned to the requester and removed from the cache.\n-\n-The following points apply to using the `maxIdle` configuration with clustered\n-caches:\n-\n-* If one or more owner in the cluster detects that an entry is not expired,\n-then a `Cache.get` operation returns the entry. The last access time for that\n-entry is also updated to the current time.\n-* When the expiration reaper finds entries that might be expired with the\n-maximum idle time, all nodes update the last access time for those entries\n-to the most recent access time before the `maxIdle` time. In this way, the\n-reaper prevents invalid expiration of entries.\n-* Clustered transactional caches do *not* remove entries that are expired\n-with the maximum idle time on `Cache.get` operations. These expired entries\n-are removed with the expiration reaper thread only, otherwise deadlocking\n-can occur.\n+In clustered cache modes, when clients read entries that have `max-idle`\n+expiration values, {brandname} sends touch commands to all owners. This ensures\n+that the entries have the same relative access time across the cluster.\n+\n+When nodes detect that an entry reaches the maximum idle time, {brandname}\n+removes it from the cache and does not return the entry to the client that\n+requested it.\n+\n+Before using clustered `max-idle`, you should review the following points:", "originalCommit": "b2469a789e0b038dc7908f53046cf40e75b87852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg1OTMyOA==", "url": "https://github.com/infinispan/infinispan/pull/7742#discussion_r367859328", "bodyText": "@danberindei good point. how about \"before using max-idle with clustered cache modes...\"", "author": "oraNod", "createdAt": "2020-01-17T10:10:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzMjQ3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzMjgyMA==", "url": "https://github.com/infinispan/infinispan/pull/7742#discussion_r367832820", "bodyText": "count is too specific, I don't think Caffeine keeps an actual count, and we definitely don't keep a count in our off-heap LRU implementation.", "author": "danberindei", "createdAt": "2020-01-17T09:10:56Z", "path": "documentation/src/main/asciidoc/topics/eviction.adoc", "diffHunk": "@@ -209,46 +209,45 @@ can result in slower operation times.\n \n Maximum idle expiration has different behavior in local and clustered cache environments.\n \n+[IMPORTANT]\n+====\n+Maximum idle expiration, `max-idle`, does not currently work with entries stored in off-heap memory.\n+\n+Likewise, `max-idle` does not work if caches use cache stores as a persistence layer.\n+====\n+\n [[expiration_maxidle_local]]\n ==== Local Max Idle\n+In local cache mode, {brandname} expires entries with the `maxIdle` configuration when:\n \n-In non-clustered cache environments, the `maxIdle` configuration expires entries when:\n-\n-* accessed directly (`Cache.get`).\n-* iterated upon (`Cache.size`).\n+* accessed directly (`Cache.get()`).\n+* iterated upon (`Cache.size()`).\n * the expiration reaper thread runs.\n \n [[expiration_maxidle_clustered]]\n ==== Clustered Max Idle\n-\n-In clustered environments, nodes in the cluster can have different access times\n-for the same entry. Entries do not expire from the cache until they reach the\n-maxium idle time for all owners across the cluster.\n-\n-When a node detects that an entry has reached the maximum idle time and is\n-expired, the node gets the last time that the entry was accessed from the other\n-owners in the cluster. If the other owners indicate that the entry is expired,\n-that entry is not returned to the requester and removed from the cache.\n-\n-The following points apply to using the `maxIdle` configuration with clustered\n-caches:\n-\n-* If one or more owner in the cluster detects that an entry is not expired,\n-then a `Cache.get` operation returns the entry. The last access time for that\n-entry is also updated to the current time.\n-* When the expiration reaper finds entries that might be expired with the\n-maximum idle time, all nodes update the last access time for those entries\n-to the most recent access time before the `maxIdle` time. In this way, the\n-reaper prevents invalid expiration of entries.\n-* Clustered transactional caches do *not* remove entries that are expired\n-with the maximum idle time on `Cache.get` operations. These expired entries\n-are removed with the expiration reaper thread only, otherwise deadlocking\n-can occur.\n+In clustered cache modes, when clients read entries that have `max-idle`\n+expiration values, {brandname} sends touch commands to all owners. This ensures\n+that the entries have the same relative access time across the cluster.\n+\n+When nodes detect that an entry reaches the maximum idle time, {brandname}\n+removes it from the cache and does not return the entry to the client that\n+requested it.\n+\n+Before using clustered `max-idle`, you should review the following points:\n+\n+* `Cache.get()` does not return until the touch commands complete. This synchronous behavior increases latency of client requests.\n+* Clustered `max-idle` also updates the recent access count for eviction on all owners.", "originalCommit": "b2469a789e0b038dc7908f53046cf40e75b87852", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Nzg1OTU5MQ==", "url": "https://github.com/infinispan/infinispan/pull/7742#discussion_r367859591", "bodyText": "@danberindei  rather than count should we say recent access time?", "author": "oraNod", "createdAt": "2020-01-17T10:11:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzgzMjgyMA=="}], "type": "inlineReview"}]}