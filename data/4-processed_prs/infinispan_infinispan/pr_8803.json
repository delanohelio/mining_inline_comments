{"pr_number": 8803, "pr_title": "ISPN-12438 off heap details", "pr_createdAt": "2020-10-21T19:03:10Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8803", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzNjc4MA==", "url": "https://github.com/infinispan/infinispan/pull/8803#discussion_r510436780", "bodyText": "Gives sounds a bit weird. Maybe \"requires less overhead per entry\" ?", "author": "wburns", "createdAt": "2020-10-22T20:27:45Z", "path": "documentation/src/main/asciidoc/topics/con_off_heap_memory.adoc", "diffHunk": "@@ -0,0 +1,66 @@\n+[id='off_heap_memory']\n+= Storing Data in Off Heap Memory\n+{brandname} can store cache entries in JVM heap memory or off heap.\n+Off heap storage lets you use unmanaged, native memory space for the JVM.\n+\n+Off heap storage gives you less overhead per entry than in JVM heap memory.", "originalCommit": "22ddaf90bfb424f0d37f95ed39e78ff60e0e6dd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzNzAwOQ==", "url": "https://github.com/infinispan/infinispan/pull/8803#discussion_r510437009", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Off heap storage lets you use unmanaged, native memory space for the JVM.\n          \n          \n            \n            Off heap storage lets you use unmanaged, native memory space for the JVM.\n          \n      \n    \n    \n  \n\nOff heap storage lets your objects occupy native memory outside of the managed JVM memory.", "author": "wburns", "createdAt": "2020-10-22T20:28:15Z", "path": "documentation/src/main/asciidoc/topics/con_off_heap_memory.adoc", "diffHunk": "@@ -0,0 +1,66 @@\n+[id='off_heap_memory']\n+= Storing Data in Off Heap Memory\n+{brandname} can store cache entries in JVM heap memory or off heap.\n+Off heap storage lets you use unmanaged, native memory space for the JVM.", "originalCommit": "22ddaf90bfb424f0d37f95ed39e78ff60e0e6dd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzNzYzMg==", "url": "https://github.com/infinispan/infinispan/pull/8803#discussion_r510437632", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Likewise you cannot change the JVM heap space at run-time but, when using off heap storage, {brandname} dynamically allocates memory.\n          \n          \n            \n            Likewise you cannot change the JVM heap space at run-time, but when using off heap storage, {brandname} dynamically allocates memory for each entry.", "author": "wburns", "createdAt": "2020-10-22T20:29:24Z", "path": "documentation/src/main/asciidoc/topics/con_off_heap_memory.adoc", "diffHunk": "@@ -0,0 +1,66 @@\n+[id='off_heap_memory']\n+= Storing Data in Off Heap Memory\n+{brandname} can store cache entries in JVM heap memory or off heap.\n+Off heap storage lets you use unmanaged, native memory space for the JVM.\n+\n+Off heap storage gives you less overhead per entry than in JVM heap memory.\n+In other words, off heap storage uses less memory than heap storage for the same amount of data.\n+Another benefit of off heap storage is that it is not affected by Garbage Collector runs, which can improve overall JVM performance.\n+Likewise you cannot change the JVM heap space at run-time but, when using off heap storage, {brandname} dynamically allocates memory.", "originalCommit": "22ddaf90bfb424f0d37f95ed39e78ff60e0e6dd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzODE4Ng==", "url": "https://github.com/infinispan/infinispan/pull/8803#discussion_r510438186", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            However there are some trade-offs such as that heap dumps become worthless.\n          \n          \n            \n            However there are some trade-offs such as JVM heap dumps will now show entries stored in an off heap cache.", "author": "wburns", "createdAt": "2020-10-22T20:30:22Z", "path": "documentation/src/main/asciidoc/topics/con_off_heap_memory.adoc", "diffHunk": "@@ -0,0 +1,66 @@\n+[id='off_heap_memory']\n+= Storing Data in Off Heap Memory\n+{brandname} can store cache entries in JVM heap memory or off heap.\n+Off heap storage lets you use unmanaged, native memory space for the JVM.\n+\n+Off heap storage gives you less overhead per entry than in JVM heap memory.\n+In other words, off heap storage uses less memory than heap storage for the same amount of data.\n+Another benefit of off heap storage is that it is not affected by Garbage Collector runs, which can improve overall JVM performance.\n+Likewise you cannot change the JVM heap space at run-time but, when using off heap storage, {brandname} dynamically allocates memory.\n+However there are some trade-offs such as that heap dumps become worthless.", "originalCommit": "22ddaf90bfb424f0d37f95ed39e78ff60e0e6dd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzODk1Mg==", "url": "https://github.com/infinispan/infinispan/pull/8803#discussion_r510438952", "bodyText": "We may want to rename this something different as the Code native region is not where objects allocated via Infinispan.", "author": "wburns", "createdAt": "2020-10-22T20:31:54Z", "path": "documentation/src/main/asciidoc/topics/con_off_heap_memory.adoc", "diffHunk": "@@ -0,0 +1,66 @@\n+[id='off_heap_memory']\n+= Storing Data in Off Heap Memory\n+{brandname} can store cache entries in JVM heap memory or off heap.\n+Off heap storage lets you use unmanaged, native memory space for the JVM.\n+\n+Off heap storage gives you less overhead per entry than in JVM heap memory.\n+In other words, off heap storage uses less memory than heap storage for the same amount of data.\n+Another benefit of off heap storage is that it is not affected by Garbage Collector runs, which can improve overall JVM performance.\n+Likewise you cannot change the JVM heap space at run-time but, when using off heap storage, {brandname} dynamically allocates memory.\n+However there are some trade-offs such as that heap dumps become worthless.\n+\n+Consider the following illustration of memory space for a JVM process where\n+{brandname} is running:\n+\n+image::offheap.svg[]\n+\n+JVM heap memory, as shown in the preceding diagram, holds Java objects and other application data.\n+The heap is divided into young and old generations that help keep referenced objects in memory.\n+The Garbage Collector (GC) process reclaims space from unreachable objects, running more frequently on the young generation memory pool.\n+\n+When {brandname} stores cache entries in JVM heap memory, GC runs can take longer to complete as you start adding data to your caches.\n+Because GC is a fairly intensive process, longer and more frequent runs can degrade application performance.\n+\n+Using off heap memory configures {brandname} to store data in native memory, or available system memory that is outside JVM memory management.\n+Depending on your JVM implementation, native memory is also allocated for thread stacks, Just-in-Time (JIT) compiler code, and so on.\n+As an example, the preceding diagram shows two memory pools that are allocated from native memory:\n+\n+* Metaspace holds class metadata.\n+* Code Cache holds generated native code and internal structures.", "originalCommit": "22ddaf90bfb424f0d37f95ed39e78ff60e0e6dd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDc1MDAyNA==", "url": "https://github.com/infinispan/infinispan/pull/8803#discussion_r510750024", "bodyText": "indeed. I'm reworking this part. I thought that's what I was observing when adding to an off heap cache through the Java console.", "author": "oraNod", "createdAt": "2020-10-23T09:17:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzODk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDgxMzMxOQ==", "url": "https://github.com/infinispan/infinispan/pull/8803#discussion_r510813319", "bodyText": "What if we leave it as-is in the diagram as a basic representation of what we mean when we say \"off heap\"?\nHere Code Cache is just one type of un-managed memory pool.", "author": "oraNod", "createdAt": "2020-10-23T11:18:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzODk1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzOTEwMw==", "url": "https://github.com/infinispan/infinispan/pull/8803#discussion_r510439103", "bodyText": "Technically they are allocated in the \"Unknown\" region as shown by native memory tracking.", "author": "wburns", "createdAt": "2020-10-22T20:32:13Z", "path": "documentation/src/main/asciidoc/topics/con_off_heap_memory.adoc", "diffHunk": "@@ -0,0 +1,66 @@\n+[id='off_heap_memory']\n+= Storing Data in Off Heap Memory\n+{brandname} can store cache entries in JVM heap memory or off heap.\n+Off heap storage lets you use unmanaged, native memory space for the JVM.\n+\n+Off heap storage gives you less overhead per entry than in JVM heap memory.\n+In other words, off heap storage uses less memory than heap storage for the same amount of data.\n+Another benefit of off heap storage is that it is not affected by Garbage Collector runs, which can improve overall JVM performance.\n+Likewise you cannot change the JVM heap space at run-time but, when using off heap storage, {brandname} dynamically allocates memory.\n+However there are some trade-offs such as that heap dumps become worthless.\n+\n+Consider the following illustration of memory space for a JVM process where\n+{brandname} is running:\n+\n+image::offheap.svg[]\n+\n+JVM heap memory, as shown in the preceding diagram, holds Java objects and other application data.\n+The heap is divided into young and old generations that help keep referenced objects in memory.\n+The Garbage Collector (GC) process reclaims space from unreachable objects, running more frequently on the young generation memory pool.\n+\n+When {brandname} stores cache entries in JVM heap memory, GC runs can take longer to complete as you start adding data to your caches.\n+Because GC is a fairly intensive process, longer and more frequent runs can degrade application performance.\n+\n+Using off heap memory configures {brandname} to store data in native memory, or available system memory that is outside JVM memory management.\n+Depending on your JVM implementation, native memory is also allocated for thread stacks, Just-in-Time (JIT) compiler code, and so on.\n+As an example, the preceding diagram shows two memory pools that are allocated from native memory:\n+\n+* Metaspace holds class metadata.\n+* Code Cache holds generated native code and internal structures.\n+\n+Taking the diagram as an example, when you use off heap storage {brandname} adds data to the Code Cache memory pool.", "originalCommit": "22ddaf90bfb424f0d37f95ed39e78ff60e0e6dd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDgxMTAyNg==", "url": "https://github.com/infinispan/infinispan/pull/8803#discussion_r510811026", "bodyText": "I've updated to keep the wording a little more general. \"Infinispan allocates native memory to data\" is probably the thing we should say rather than mentioning specific memory pools.", "author": "oraNod", "createdAt": "2020-10-23T11:13:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzOTEwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzOTM3OQ==", "url": "https://github.com/infinispan/infinispan/pull/8803#discussion_r510439379", "bodyText": "maybe links instead of chains? It is really a linked list.", "author": "wburns", "createdAt": "2020-10-22T20:32:45Z", "path": "documentation/src/main/asciidoc/topics/con_off_heap_memory.adoc", "diffHunk": "@@ -0,0 +1,66 @@\n+[id='off_heap_memory']\n+= Storing Data in Off Heap Memory\n+{brandname} can store cache entries in JVM heap memory or off heap.\n+Off heap storage lets you use unmanaged, native memory space for the JVM.\n+\n+Off heap storage gives you less overhead per entry than in JVM heap memory.\n+In other words, off heap storage uses less memory than heap storage for the same amount of data.\n+Another benefit of off heap storage is that it is not affected by Garbage Collector runs, which can improve overall JVM performance.\n+Likewise you cannot change the JVM heap space at run-time but, when using off heap storage, {brandname} dynamically allocates memory.\n+However there are some trade-offs such as that heap dumps become worthless.\n+\n+Consider the following illustration of memory space for a JVM process where\n+{brandname} is running:\n+\n+image::offheap.svg[]\n+\n+JVM heap memory, as shown in the preceding diagram, holds Java objects and other application data.\n+The heap is divided into young and old generations that help keep referenced objects in memory.\n+The Garbage Collector (GC) process reclaims space from unreachable objects, running more frequently on the young generation memory pool.\n+\n+When {brandname} stores cache entries in JVM heap memory, GC runs can take longer to complete as you start adding data to your caches.\n+Because GC is a fairly intensive process, longer and more frequent runs can degrade application performance.\n+\n+Using off heap memory configures {brandname} to store data in native memory, or available system memory that is outside JVM memory management.\n+Depending on your JVM implementation, native memory is also allocated for thread stacks, Just-in-Time (JIT) compiler code, and so on.\n+As an example, the preceding diagram shows two memory pools that are allocated from native memory:\n+\n+* Metaspace holds class metadata.\n+* Code Cache holds generated native code and internal structures.\n+\n+Taking the diagram as an example, when you use off heap storage {brandname} adds data to the Code Cache memory pool.\n+\n+When you add an entry to a cache that uses off heap storage, {brandname} hashes the serialized `byte[]` for the key into buckets that are similar to a standard Java `HashMap`.\n+Buckets include address pointers that {brandname} use to locate entries in off heap memory.\n+\n+The following diagram shows a set of keys with names, the hash for each key and bucket array of address pointers, as well as the entries with the name and phone number:\n+\n+image::offheap_hashmap.svg[]\n+\n+In cases where key hashes collide, {brandname} chains entries.", "originalCommit": "22ddaf90bfb424f0d37f95ed39e78ff60e0e6dd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzOTg1Mw==", "url": "https://github.com/infinispan/infinispan/pull/8803#discussion_r510439853", "bodyText": "Technically we use StampedLock now, but you can think of it as a ReadWriteLock.", "author": "wburns", "createdAt": "2020-10-22T20:33:40Z", "path": "documentation/src/main/asciidoc/topics/con_off_heap_memory.adoc", "diffHunk": "@@ -0,0 +1,66 @@\n+[id='off_heap_memory']\n+= Storing Data in Off Heap Memory\n+{brandname} can store cache entries in JVM heap memory or off heap.\n+Off heap storage lets you use unmanaged, native memory space for the JVM.\n+\n+Off heap storage gives you less overhead per entry than in JVM heap memory.\n+In other words, off heap storage uses less memory than heap storage for the same amount of data.\n+Another benefit of off heap storage is that it is not affected by Garbage Collector runs, which can improve overall JVM performance.\n+Likewise you cannot change the JVM heap space at run-time but, when using off heap storage, {brandname} dynamically allocates memory.\n+However there are some trade-offs such as that heap dumps become worthless.\n+\n+Consider the following illustration of memory space for a JVM process where\n+{brandname} is running:\n+\n+image::offheap.svg[]\n+\n+JVM heap memory, as shown in the preceding diagram, holds Java objects and other application data.\n+The heap is divided into young and old generations that help keep referenced objects in memory.\n+The Garbage Collector (GC) process reclaims space from unreachable objects, running more frequently on the young generation memory pool.\n+\n+When {brandname} stores cache entries in JVM heap memory, GC runs can take longer to complete as you start adding data to your caches.\n+Because GC is a fairly intensive process, longer and more frequent runs can degrade application performance.\n+\n+Using off heap memory configures {brandname} to store data in native memory, or available system memory that is outside JVM memory management.\n+Depending on your JVM implementation, native memory is also allocated for thread stacks, Just-in-Time (JIT) compiler code, and so on.\n+As an example, the preceding diagram shows two memory pools that are allocated from native memory:\n+\n+* Metaspace holds class metadata.\n+* Code Cache holds generated native code and internal structures.\n+\n+Taking the diagram as an example, when you use off heap storage {brandname} adds data to the Code Cache memory pool.\n+\n+When you add an entry to a cache that uses off heap storage, {brandname} hashes the serialized `byte[]` for the key into buckets that are similar to a standard Java `HashMap`.\n+Buckets include address pointers that {brandname} use to locate entries in off heap memory.\n+\n+The following diagram shows a set of keys with names, the hash for each key and bucket array of address pointers, as well as the entries with the name and phone number:\n+\n+image::offheap_hashmap.svg[]\n+\n+In cases where key hashes collide, {brandname} chains entries.\n+As in the preceding diagram, if the William Clay and Luke Cage keys have the same hash, then the first entry added to the cache is the first element in the bucket.\n+\n+.Memory overhead\n+\n+Memory overhead is the additional memory that {brandname} uses to store entries.\n+{brandname} uses 25 bytes for each entry entry in the cache.\n+\n+Using eviction to create a bounded off heap data container increases memory overhead by 36 bytes.\n+This happens because {brandname} creates an additional linked list to track entries in the cache and perform eviction.\n+\n+However, compared with storing entries in the JVM heap, a total memory overhead of 61 bytes per entry is significantly lower.\n+\n+.Data consistency\n+\n+{brandname} uses an array of `ReadWriteLock` instances to protect off heap address spaces.", "originalCommit": "22ddaf90bfb424f0d37f95ed39e78ff60e0e6dd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDczNzI0Nw==", "url": "https://github.com/infinispan/infinispan/pull/8803#discussion_r510737247", "bodyText": "how about if we just say locks as a more generic thing?", "author": "oraNod", "createdAt": "2020-10-23T08:55:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzOTg1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ0MDQyMQ==", "url": "https://github.com/infinispan/infinispan/pull/8803#discussion_r510440421", "bodyText": "The distribution of read locks is not so they wouldn't block each other as a the read portion of a read write lock will not block another read. The distribution is to prevent reads from being blocked by a write lock.", "author": "wburns", "createdAt": "2020-10-22T20:34:44Z", "path": "documentation/src/main/asciidoc/topics/con_off_heap_memory.adoc", "diffHunk": "@@ -0,0 +1,66 @@\n+[id='off_heap_memory']\n+= Storing Data in Off Heap Memory\n+{brandname} can store cache entries in JVM heap memory or off heap.\n+Off heap storage lets you use unmanaged, native memory space for the JVM.\n+\n+Off heap storage gives you less overhead per entry than in JVM heap memory.\n+In other words, off heap storage uses less memory than heap storage for the same amount of data.\n+Another benefit of off heap storage is that it is not affected by Garbage Collector runs, which can improve overall JVM performance.\n+Likewise you cannot change the JVM heap space at run-time but, when using off heap storage, {brandname} dynamically allocates memory.\n+However there are some trade-offs such as that heap dumps become worthless.\n+\n+Consider the following illustration of memory space for a JVM process where\n+{brandname} is running:\n+\n+image::offheap.svg[]\n+\n+JVM heap memory, as shown in the preceding diagram, holds Java objects and other application data.\n+The heap is divided into young and old generations that help keep referenced objects in memory.\n+The Garbage Collector (GC) process reclaims space from unreachable objects, running more frequently on the young generation memory pool.\n+\n+When {brandname} stores cache entries in JVM heap memory, GC runs can take longer to complete as you start adding data to your caches.\n+Because GC is a fairly intensive process, longer and more frequent runs can degrade application performance.\n+\n+Using off heap memory configures {brandname} to store data in native memory, or available system memory that is outside JVM memory management.\n+Depending on your JVM implementation, native memory is also allocated for thread stacks, Just-in-Time (JIT) compiler code, and so on.\n+As an example, the preceding diagram shows two memory pools that are allocated from native memory:\n+\n+* Metaspace holds class metadata.\n+* Code Cache holds generated native code and internal structures.\n+\n+Taking the diagram as an example, when you use off heap storage {brandname} adds data to the Code Cache memory pool.\n+\n+When you add an entry to a cache that uses off heap storage, {brandname} hashes the serialized `byte[]` for the key into buckets that are similar to a standard Java `HashMap`.\n+Buckets include address pointers that {brandname} use to locate entries in off heap memory.\n+\n+The following diagram shows a set of keys with names, the hash for each key and bucket array of address pointers, as well as the entries with the name and phone number:\n+\n+image::offheap_hashmap.svg[]\n+\n+In cases where key hashes collide, {brandname} chains entries.\n+As in the preceding diagram, if the William Clay and Luke Cage keys have the same hash, then the first entry added to the cache is the first element in the bucket.\n+\n+.Memory overhead\n+\n+Memory overhead is the additional memory that {brandname} uses to store entries.\n+{brandname} uses 25 bytes for each entry entry in the cache.\n+\n+Using eviction to create a bounded off heap data container increases memory overhead by 36 bytes.\n+This happens because {brandname} creates an additional linked list to track entries in the cache and perform eviction.\n+\n+However, compared with storing entries in the JVM heap, a total memory overhead of 61 bytes per entry is significantly lower.\n+\n+.Data consistency\n+\n+{brandname} uses an array of `ReadWriteLock` instances to protect off heap address spaces.\n+The number of `ReadWriteLock` instances is twice the number of cores and then rounded to the nearest power of two.\n+This ensures that there is an even distribution of `ReadWriteLock` instances to prevent read operations from blocking each other.", "originalCommit": "22ddaf90bfb424f0d37f95ed39e78ff60e0e6dd6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ0MjAxNw==", "url": "https://github.com/infinispan/infinispan/pull/8803#discussion_r510442017", "bodyText": "I wonder if this should be more like `While entries are stored in native memory, operations require using a JVM heap representation of those objects. For instance, a get operation will read the object into native memory before returning. Likewise, state transfer will hold a subset of objects in memory while transferring them another node.\"\nSomething like that maybe?", "author": "wburns", "createdAt": "2020-10-22T20:37:58Z", "path": "documentation/src/main/asciidoc/topics/con_off_heap_memory.adoc", "diffHunk": "@@ -0,0 +1,66 @@\n+[id='off_heap_memory']\n+= Storing Data in Off Heap Memory\n+{brandname} can store cache entries in JVM heap memory or off heap.\n+Off heap storage lets you use unmanaged, native memory space for the JVM.\n+\n+Off heap storage gives you less overhead per entry than in JVM heap memory.\n+In other words, off heap storage uses less memory than heap storage for the same amount of data.\n+Another benefit of off heap storage is that it is not affected by Garbage Collector runs, which can improve overall JVM performance.\n+Likewise you cannot change the JVM heap space at run-time but, when using off heap storage, {brandname} dynamically allocates memory.\n+However there are some trade-offs such as that heap dumps become worthless.\n+\n+Consider the following illustration of memory space for a JVM process where\n+{brandname} is running:\n+\n+image::offheap.svg[]\n+\n+JVM heap memory, as shown in the preceding diagram, holds Java objects and other application data.\n+The heap is divided into young and old generations that help keep referenced objects in memory.\n+The Garbage Collector (GC) process reclaims space from unreachable objects, running more frequently on the young generation memory pool.\n+\n+When {brandname} stores cache entries in JVM heap memory, GC runs can take longer to complete as you start adding data to your caches.\n+Because GC is a fairly intensive process, longer and more frequent runs can degrade application performance.\n+\n+Using off heap memory configures {brandname} to store data in native memory, or available system memory that is outside JVM memory management.\n+Depending on your JVM implementation, native memory is also allocated for thread stacks, Just-in-Time (JIT) compiler code, and so on.\n+As an example, the preceding diagram shows two memory pools that are allocated from native memory:\n+\n+* Metaspace holds class metadata.\n+* Code Cache holds generated native code and internal structures.\n+\n+Taking the diagram as an example, when you use off heap storage {brandname} adds data to the Code Cache memory pool.\n+\n+When you add an entry to a cache that uses off heap storage, {brandname} hashes the serialized `byte[]` for the key into buckets that are similar to a standard Java `HashMap`.\n+Buckets include address pointers that {brandname} use to locate entries in off heap memory.\n+\n+The following diagram shows a set of keys with names, the hash for each key and bucket array of address pointers, as well as the entries with the name and phone number:\n+\n+image::offheap_hashmap.svg[]\n+\n+In cases where key hashes collide, {brandname} chains entries.\n+As in the preceding diagram, if the William Clay and Luke Cage keys have the same hash, then the first entry added to the cache is the first element in the bucket.\n+\n+.Memory overhead\n+\n+Memory overhead is the additional memory that {brandname} uses to store entries.\n+{brandname} uses 25 bytes for each entry entry in the cache.\n+\n+Using eviction to create a bounded off heap data container increases memory overhead by 36 bytes.\n+This happens because {brandname} creates an additional linked list to track entries in the cache and perform eviction.\n+\n+However, compared with storing entries in the JVM heap, a total memory overhead of 61 bytes per entry is significantly lower.\n+\n+.Data consistency\n+\n+{brandname} uses an array of `ReadWriteLock` instances to protect off heap address spaces.\n+The number of `ReadWriteLock` instances is twice the number of cores and then rounded to the nearest power of two.\n+This ensures that there is an even distribution of `ReadWriteLock` instances to prevent read operations from blocking each other.\n+However write operations wait to complete, which blocks read operations.\n+\n+[NOTE]\n+====\n+{brandname} requires JVM heap memory for normal operations. For instance, state", "originalCommit": "22ddaf90bfb424f0d37f95ed39e78ff60e0e6dd6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDgyMTg1Ng==", "url": "https://github.com/infinispan/infinispan/pull/8803#discussion_r510821856", "bodyText": "nice. I've updated with that.", "author": "oraNod", "createdAt": "2020-10-23T11:36:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ0MjAxNw=="}], "type": "inlineReview"}, {"oid": "7a476ef1f0575f75f7208022f9fbf940c152b8b7", "url": "https://github.com/infinispan/infinispan/commit/7a476ef1f0575f75f7208022f9fbf940c152b8b7", "message": "ISPN-12438 off heap details", "committedDate": "2020-10-23T09:43:20Z", "type": "forcePushed"}, {"oid": "7583f269cc0e63a2a7ea378a4237096ef13ca43e", "url": "https://github.com/infinispan/infinispan/commit/7583f269cc0e63a2a7ea378a4237096ef13ca43e", "message": "ISPN-12438 off heap details", "committedDate": "2020-10-23T14:21:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwNDE1OA==", "url": "https://github.com/infinispan/infinispan/pull/8803#discussion_r512004158", "bodyText": "We should probably mention that this means that equality is done via the serialized bytes and not the object representation as well. I believe we had that somewhere before... but don't remember where.", "author": "wburns", "createdAt": "2020-10-26T14:30:39Z", "path": "documentation/src/main/asciidoc/topics/con_off_heap_memory.adoc", "diffHunk": "@@ -0,0 +1,61 @@\n+[id='off_heap_memory']\n+= Off Heap Memory\n+{brandname} can store cache entries in JVM heap memory or off heap.\n+Off heap storage lets your Java objects occupy native memory outside the managed JVM memory space.\n+\n+Off heap storage requires less overhead per entry than in JVM heap memory.\n+In other words, off heap storage uses less memory than heap storage for the same amount of data.\n+Another benefit of off heap storage is that it is not affected by Garbage Collector runs, which can improve overall JVM performance.\n+There are some trade-offs with off heap storage; for example, JVM heap dumps do not show entries stored in off heap memory.\n+\n+Consider the following simplified illustration of memory space for a JVM process where {brandname} is running:\n+\n+image::offheap.svg[]\n+\n+.JVM heap memory\n+The heap is divided into young and old generations that help keep referenced Java objects and other application data in memory.\n+The Garbage Collector (GC) process reclaims space from unreachable objects, running more frequently on the young generation memory pool.\n+\n+When {brandname} stores cache entries in JVM heap memory, GC runs can take longer to complete as you start adding data to your caches.\n+Because GC is a fairly intensive process, longer and more frequent runs can degrade application performance.\n+\n+.Off heap memory\n+Off heap memory is native available system memory outside JVM memory management.\n+The preceding diagram shows the `Metaspace` memory pool that holds class metadata and is allocated from native memory.\n+The diagram also represents a section of native memory that holds {brandname} cache entries.\n+\n+.Storing data off heap\n+When you add entries to off heap caches, {brandname} dynamically allocates native memory to your data.\n+\n+{brandname} hashes the serialized `byte[]` for each key into buckets that are similar to a standard Java `HashMap`.", "originalCommit": "7583f269cc0e63a2a7ea378a4237096ef13ca43e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyMzczNw==", "url": "https://github.com/infinispan/infinispan/pull/8803#discussion_r515023737", "bodyText": "@wburns Please check the note I added about equality: https://github.com/infinispan/infinispan/pull/8803/files#diff-b632766944b1fc30eb18b540ff43965eb166f1f10211f64cab65b295daa5a70eR39", "author": "oraNod", "createdAt": "2020-10-30T11:14:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwNDE1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY1OTc2NA==", "url": "https://github.com/infinispan/infinispan/pull/8803#discussion_r512659764", "bodyText": "s/entry entry/entry/", "author": "tristantarrant", "createdAt": "2020-10-27T12:43:06Z", "path": "documentation/src/main/asciidoc/topics/con_off_heap_memory.adoc", "diffHunk": "@@ -0,0 +1,61 @@\n+[id='off_heap_memory']\n+= Off Heap Memory\n+{brandname} can store cache entries in JVM heap memory or off heap.\n+Off heap storage lets your Java objects occupy native memory outside the managed JVM memory space.\n+\n+Off heap storage requires less overhead per entry than in JVM heap memory.\n+In other words, off heap storage uses less memory than heap storage for the same amount of data.\n+Another benefit of off heap storage is that it is not affected by Garbage Collector runs, which can improve overall JVM performance.\n+There are some trade-offs with off heap storage; for example, JVM heap dumps do not show entries stored in off heap memory.\n+\n+Consider the following simplified illustration of memory space for a JVM process where {brandname} is running:\n+\n+image::offheap.svg[]\n+\n+.JVM heap memory\n+The heap is divided into young and old generations that help keep referenced Java objects and other application data in memory.\n+The Garbage Collector (GC) process reclaims space from unreachable objects, running more frequently on the young generation memory pool.\n+\n+When {brandname} stores cache entries in JVM heap memory, GC runs can take longer to complete as you start adding data to your caches.\n+Because GC is a fairly intensive process, longer and more frequent runs can degrade application performance.\n+\n+.Off heap memory\n+Off heap memory is native available system memory outside JVM memory management.\n+The preceding diagram shows the `Metaspace` memory pool that holds class metadata and is allocated from native memory.\n+The diagram also represents a section of native memory that holds {brandname} cache entries.\n+\n+.Storing data off heap\n+When you add entries to off heap caches, {brandname} dynamically allocates native memory to your data.\n+\n+{brandname} hashes the serialized `byte[]` for each key into buckets that are similar to a standard Java `HashMap`.\n+Buckets include address pointers that {brandname} use to locate entries that you store in off heap memory.\n+\n+The following diagram shows a set of keys with names, the hash for each key and bucket array of address pointers, as well as the entries with the name and phone number:\n+\n+image::offheap_hashmap.svg[]\n+\n+In cases where key hashes collide, {brandname} links entries.\n+As in the preceding diagram, if the William Clay and Luke Cage keys have the same hash, then the first entry added to the cache is the first element in the bucket.\n+\n+[NOTE]\n+====\n+Even though {brandname} stores cache entries in native memory, run-time operations require JVM heap representations of those objects.\n+For instance, `cache.get()` operations read objects into heap memory before returning.\n+Likewise, state transfer operations hold subsets of objects in heap memory while they take place.\n+====\n+\n+.Memory overhead\n+\n+Memory overhead is the additional memory that {brandname} uses to store entries.\n+{brandname} uses 25 bytes for each entry entry in the cache.", "originalCommit": "7583f269cc0e63a2a7ea378a4237096ef13ca43e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY2MDk2MQ==", "url": "https://github.com/infinispan/infinispan/pull/8803#discussion_r512660961", "bodyText": "I would not leave the total implied. You are mentioning it below, but it's clearer if brought here,", "author": "tristantarrant", "createdAt": "2020-10-27T12:45:05Z", "path": "documentation/src/main/asciidoc/topics/con_off_heap_memory.adoc", "diffHunk": "@@ -0,0 +1,61 @@\n+[id='off_heap_memory']\n+= Off Heap Memory\n+{brandname} can store cache entries in JVM heap memory or off heap.\n+Off heap storage lets your Java objects occupy native memory outside the managed JVM memory space.\n+\n+Off heap storage requires less overhead per entry than in JVM heap memory.\n+In other words, off heap storage uses less memory than heap storage for the same amount of data.\n+Another benefit of off heap storage is that it is not affected by Garbage Collector runs, which can improve overall JVM performance.\n+There are some trade-offs with off heap storage; for example, JVM heap dumps do not show entries stored in off heap memory.\n+\n+Consider the following simplified illustration of memory space for a JVM process where {brandname} is running:\n+\n+image::offheap.svg[]\n+\n+.JVM heap memory\n+The heap is divided into young and old generations that help keep referenced Java objects and other application data in memory.\n+The Garbage Collector (GC) process reclaims space from unreachable objects, running more frequently on the young generation memory pool.\n+\n+When {brandname} stores cache entries in JVM heap memory, GC runs can take longer to complete as you start adding data to your caches.\n+Because GC is a fairly intensive process, longer and more frequent runs can degrade application performance.\n+\n+.Off heap memory\n+Off heap memory is native available system memory outside JVM memory management.\n+The preceding diagram shows the `Metaspace` memory pool that holds class metadata and is allocated from native memory.\n+The diagram also represents a section of native memory that holds {brandname} cache entries.\n+\n+.Storing data off heap\n+When you add entries to off heap caches, {brandname} dynamically allocates native memory to your data.\n+\n+{brandname} hashes the serialized `byte[]` for each key into buckets that are similar to a standard Java `HashMap`.\n+Buckets include address pointers that {brandname} use to locate entries that you store in off heap memory.\n+\n+The following diagram shows a set of keys with names, the hash for each key and bucket array of address pointers, as well as the entries with the name and phone number:\n+\n+image::offheap_hashmap.svg[]\n+\n+In cases where key hashes collide, {brandname} links entries.\n+As in the preceding diagram, if the William Clay and Luke Cage keys have the same hash, then the first entry added to the cache is the first element in the bucket.\n+\n+[NOTE]\n+====\n+Even though {brandname} stores cache entries in native memory, run-time operations require JVM heap representations of those objects.\n+For instance, `cache.get()` operations read objects into heap memory before returning.\n+Likewise, state transfer operations hold subsets of objects in heap memory while they take place.\n+====\n+\n+.Memory overhead\n+\n+Memory overhead is the additional memory that {brandname} uses to store entries.\n+{brandname} uses 25 bytes for each entry entry in the cache.\n+\n+Using eviction to create a bounded off heap data container increases memory overhead by 36 bytes.", "originalCommit": "7583f269cc0e63a2a7ea378a4237096ef13ca43e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY2MTUxOA==", "url": "https://github.com/infinispan/infinispan/pull/8803#discussion_r512661518", "bodyText": "@wburns can we provide a rough estimation of on heap overhead ?", "author": "tristantarrant", "createdAt": "2020-10-27T12:46:01Z", "path": "documentation/src/main/asciidoc/topics/con_off_heap_memory.adoc", "diffHunk": "@@ -0,0 +1,61 @@\n+[id='off_heap_memory']\n+= Off Heap Memory\n+{brandname} can store cache entries in JVM heap memory or off heap.\n+Off heap storage lets your Java objects occupy native memory outside the managed JVM memory space.\n+\n+Off heap storage requires less overhead per entry than in JVM heap memory.\n+In other words, off heap storage uses less memory than heap storage for the same amount of data.\n+Another benefit of off heap storage is that it is not affected by Garbage Collector runs, which can improve overall JVM performance.\n+There are some trade-offs with off heap storage; for example, JVM heap dumps do not show entries stored in off heap memory.\n+\n+Consider the following simplified illustration of memory space for a JVM process where {brandname} is running:\n+\n+image::offheap.svg[]\n+\n+.JVM heap memory\n+The heap is divided into young and old generations that help keep referenced Java objects and other application data in memory.\n+The Garbage Collector (GC) process reclaims space from unreachable objects, running more frequently on the young generation memory pool.\n+\n+When {brandname} stores cache entries in JVM heap memory, GC runs can take longer to complete as you start adding data to your caches.\n+Because GC is a fairly intensive process, longer and more frequent runs can degrade application performance.\n+\n+.Off heap memory\n+Off heap memory is native available system memory outside JVM memory management.\n+The preceding diagram shows the `Metaspace` memory pool that holds class metadata and is allocated from native memory.\n+The diagram also represents a section of native memory that holds {brandname} cache entries.\n+\n+.Storing data off heap\n+When you add entries to off heap caches, {brandname} dynamically allocates native memory to your data.\n+\n+{brandname} hashes the serialized `byte[]` for each key into buckets that are similar to a standard Java `HashMap`.\n+Buckets include address pointers that {brandname} use to locate entries that you store in off heap memory.\n+\n+The following diagram shows a set of keys with names, the hash for each key and bucket array of address pointers, as well as the entries with the name and phone number:\n+\n+image::offheap_hashmap.svg[]\n+\n+In cases where key hashes collide, {brandname} links entries.\n+As in the preceding diagram, if the William Clay and Luke Cage keys have the same hash, then the first entry added to the cache is the first element in the bucket.\n+\n+[NOTE]\n+====\n+Even though {brandname} stores cache entries in native memory, run-time operations require JVM heap representations of those objects.\n+For instance, `cache.get()` operations read objects into heap memory before returning.\n+Likewise, state transfer operations hold subsets of objects in heap memory while they take place.\n+====\n+\n+.Memory overhead\n+\n+Memory overhead is the additional memory that {brandname} uses to store entries.\n+{brandname} uses 25 bytes for each entry entry in the cache.\n+\n+Using eviction to create a bounded off heap data container increases memory overhead by 36 bytes.\n+This happens because {brandname} creates an additional linked list to track entries in the cache and perform eviction.\n+\n+However, compared with storing entries in the JVM heap, a total memory overhead of 61 bytes per entry is significantly lower.", "originalCommit": "7583f269cc0e63a2a7ea378a4237096ef13ca43e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTAyNDU5MA==", "url": "https://github.com/infinispan/infinispan/pull/8803#discussion_r515024590", "bodyText": "@wburns I agree that it would be good, if possible, to provide a rough estimation of on-heap. That way we can back up the statement that off-heap overhead is much less.", "author": "oraNod", "createdAt": "2020-10-30T11:15:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY2MTUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY2MTkzNg==", "url": "https://github.com/infinispan/infinispan/pull/8803#discussion_r512661936", "bodyText": "entries in Protobuf format.", "author": "tristantarrant", "createdAt": "2020-10-27T12:46:43Z", "path": "documentation/src/main/asciidoc/topics/proc_configuring_memory_offheap.adoc", "diffHunk": "@@ -1,29 +1,28 @@\n [id='configure_off_heap-{context}']\n-= Configuring {brandname} to Store Cache Entries Off Heap\n-{brandname} can use either JVM heap memory or off-heap native memory as the\n-data container for cache entries. By default {brandname} stores cache entries\n-in JVM heap memory.\n-\n-{brandname} can use off-heap storage with eviction based on the total number of\n-entries or maximum amount of memory. When using off-heap, {brandname} stores\n-cache entries in Protobuf format with the `application/x-protostream` encoding.\n+= Using Off Heap Memory\n+Configure {brandname} to store cache entries in native memory outside the JVM\n+heap space.\n \n .Procedure\n \n-To store cache entries in off-heap memory, configure {brandname} in one of the\n-following ways:\n-\n+. Create a configuration for any type of cache.\n+. Store cache entries in off heap memory.\n++\n * Declaratively: Add the `storage=\"OFF_HEAP\"` attribute to the `memory` element.\n * Programmatically: Call the `storage(OFF_HEAP)` method in the `MemoryConfigurationBuilder` class.\n++\n+. Configure eviction to limit the amount of off heap memory that the cache can use. You can use eviction based on total number of entries (`max-count`) or maximum amount of memory (`max-size`).\n+. Configure any binary encoding for cache entries. For optimal results, use the `application/x-protostream` MediaType to store entries Protobuf format.", "originalCommit": "7583f269cc0e63a2a7ea378a4237096ef13ca43e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "946577e89a6785831b5fafdf2f14f2de9d0cef5c", "url": "https://github.com/infinispan/infinispan/commit/946577e89a6785831b5fafdf2f14f2de9d0cef5c", "message": "use the hyphen. fix feedback.", "committedDate": "2020-10-27T17:46:48Z", "type": "forcePushed"}, {"oid": "af05f573eed94bc3f7df1bf54163f3d848b3afad", "url": "https://github.com/infinispan/infinispan/commit/af05f573eed94bc3f7df1bf54163f3d848b3afad", "message": "ISPN-12438 off heap details", "committedDate": "2020-10-30T10:49:29Z", "type": "commit"}, {"oid": "af05f573eed94bc3f7df1bf54163f3d848b3afad", "url": "https://github.com/infinispan/infinispan/commit/af05f573eed94bc3f7df1bf54163f3d848b3afad", "message": "ISPN-12438 off heap details", "committedDate": "2020-10-30T10:49:29Z", "type": "forcePushed"}]}