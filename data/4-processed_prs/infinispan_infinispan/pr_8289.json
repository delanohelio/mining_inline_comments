{"pr_number": 8289, "pr_title": "ISPN-11780 updating xsite docs for IRAC implementation", "pr_createdAt": "2020-05-06T19:16:36Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8289", "timeline": [{"oid": "33364793a73e7e3d490d13a1c7e1e856b5e59cbf", "url": "https://github.com/infinispan/infinispan/commit/33364793a73e7e3d490d13a1c7e1e856b5e59cbf", "message": "ISPN-11780 updating xsite docs for IRAC implementation", "committedDate": "2020-05-06T19:54:56Z", "type": "forcePushed"}, {"oid": "fb1bdfdf02cc1d665aaa601cf1e211ce1c4bce69", "url": "https://github.com/infinispan/infinispan/commit/fb1bdfdf02cc1d665aaa601cf1e211ce1c4bce69", "message": "be more explicit about conflict resolution", "committedDate": "2020-05-12T15:41:56Z", "type": "forcePushed"}, {"oid": "edc8eb82ebcf42a8127a49c2eecb7a9403f789f7", "url": "https://github.com/infinispan/infinispan/commit/edc8eb82ebcf42a8127a49c2eecb7a9403f789f7", "message": "ISPN-11780 updating xsite docs for IRAC implementation", "committedDate": "2020-05-14T09:45:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYyOTYyNA==", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425629624", "bodyText": "remove  {infinispanversion}? wdyt?", "author": "pruivo", "createdAt": "2020-05-15T07:55:53Z", "path": "documentation/src/main/asciidoc/titles/xsite/xsite.asciidoc", "diffHunk": "@@ -14,7 +14,12 @@ include::../{topics}/attributes/community-attributes.adoc[]\n :stem: asciimath\n \n //Title\n-= Replicating Data Across Sites with {brandname} {infinispanversion}\n+= {brandname} {infinispanversion} Guide to Cross-Site Replication", "originalCommit": "edc8eb82ebcf42a8127a49c2eecb7a9403f789f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY0MjYxNQ==", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425642615", "bodyText": "sounds good", "author": "oraNod", "createdAt": "2020-05-15T08:21:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYyOTYyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYzMDI3Ng==", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425630276", "bodyText": "typo? is => isn't", "author": "pruivo", "createdAt": "2020-05-15T07:57:13Z", "path": "documentation/src/main/asciidoc/topics/con_xsite_concurrent_writes.adoc", "diffHunk": "@@ -1,59 +1,51 @@\n-[id='conflicts-{context}']\n-= Conflicting Entries with Cross-Site Replication\n+[id='conflicting_entries-{context}']\n+= Concurrent Writes and Conflicting Entries\n Conflicting entries can occur with Active/Active site configurations if clients\n write to the same entries at the same time but at different sites.\n \n For example, client A writes to \"k1\" in **LON** at the same time that client B\n writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-than in **NYC**.\n+than in **NYC**. After replication occurs, there is no guarantee which value\n+for \"k1\" exists at which site.\n \n-With synchronous replication, concurrent writes result in deadlocks because\n-both sites lock the same key in different orders. To resolve deadlocks, client\n-applications must wait until the locks time out.\n+To ensure data consistency, {brandname} uses a vector clock algorithm to detect\n+conflicting entries during backup operations, as in the following illustration:\n \n-With asynchronous replication, concurrent writes result in conflicting values\n-because sites replicate after entries are modified locally.  After replication\n-occurs, there is no guarantee which value for \"k1\" exists at which site.\n+[source,options=\"nowrap\"]\n+----\n+            LON       NYC\n \n-* Keys have conflicting values.\n+k1=(n/a)    0,0       0,0\n \n-* One of the conflicting values is overwritten if sites do not replicate values\n-at the same time. In this case, one of the values is lost and there is no\n-guarantee which value is saved.\n+k1=2        1,0  -->  1,0   k1=2\n \n-In all cases, inconsistencies in key values are resolved after the next\n-non-conflicting `put()` operation updates the value.\n+k1=3        1,1  <--  1,1   k1=3\n \n-[NOTE]\n-====\n-There currently is no conflict resolution policy that client applications can\n-use to handle conflicts in asynchronous mode. However, conflict resolution\n-techniques are planned for a future {brandname} version.\n-====\n+k1=5        2,1       1,2   k1=8\n \n-//dnaro: notes for IRAC conflict resolution\n+                 -->  2,1 (conflict)\n+(conflict)  1,2  <--\n+----\n \n-//Conflict Resolution with Cross-Site Replication\n-//Conflicting entries can occur with Active/Active site configurations if\n-//clients write to the same entries at the same time but at different sites.\n+Vector clocks are timestamp metadata that increment with each write to an\n+entry. In the preceding example, `0,0` represents the initial value for the\n+vector clock on \"k1\".\n \n-//For example, client A writes to \"k1\" in **LON** at the same time that client B\n-//writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-//than in **NYC**. After replication occurs, there is no guarantee which value\n-//for \"k1\" exists at which site.\n+A client puts \"k1=2\" in **LON** and the vector clock is `1,0`, which\n+{brandname} replicates to **NYC**. A client then puts \"k1=3\" in **NYC** and the\n+vector clock updates to `1,1`, which {brandname} replicates to **LON**.\n \n-//{brandname} uses version information for keys to detect conflicts during a\n-//backup. If {brandname} finds entries that conflict, it compares site names\n-//based on alphabetical order. The site name with the highest alphabetical\n-//ordering wins.\n+However if a client puts \"k1=5\" in **LON** at the same time that a client puts\n+\"k1=8\" in **NYC**, {brandname} detects a conflicting entry because the vector\n+value for \"k1\" is strictly greater or less between **LON** and **NYC**.", "originalCommit": "edc8eb82ebcf42a8127a49c2eecb7a9403f789f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwMDUzNg==", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425700536", "bodyText": "@pruivo I'm not sure. if the vector value is greater or less then it means there is a conflict, right?\nmaybe we should say if the vector value for \"k1\" does not match?", "author": "oraNod", "createdAt": "2020-05-15T10:07:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYzMDI3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcwOTQyOQ==", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425709429", "bodyText": "This is my point of view:\n[1,1] is \"strictly\" less than [2,1], [1,2] (no conflict)\n[2,1] is \"strictly\" greater than [1,1], [0,1], [1,0] (no conflict)\n[1,2] is conflicting with [2,1]\nso, I have no idea how to put that in words xD", "author": "pruivo", "createdAt": "2020-05-15T10:24:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYzMDI3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTcyMjkxNA==", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425722914", "bodyText": "thanks @pruivo that's a great catch.", "author": "oraNod", "createdAt": "2020-05-15T10:53:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYzMDI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYzMTcwNg==", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425631706", "bodyText": "link to compareTo javadoc?\nhttps://docs.oracle.com/javase/8/docs/api/java/lang/String.html#compareTo-java.lang.String-", "author": "pruivo", "createdAt": "2020-05-15T07:59:52Z", "path": "documentation/src/main/asciidoc/topics/con_xsite_concurrent_writes.adoc", "diffHunk": "@@ -1,59 +1,51 @@\n-[id='conflicts-{context}']\n-= Conflicting Entries with Cross-Site Replication\n+[id='conflicting_entries-{context}']\n+= Concurrent Writes and Conflicting Entries\n Conflicting entries can occur with Active/Active site configurations if clients\n write to the same entries at the same time but at different sites.\n \n For example, client A writes to \"k1\" in **LON** at the same time that client B\n writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-than in **NYC**.\n+than in **NYC**. After replication occurs, there is no guarantee which value\n+for \"k1\" exists at which site.\n \n-With synchronous replication, concurrent writes result in deadlocks because\n-both sites lock the same key in different orders. To resolve deadlocks, client\n-applications must wait until the locks time out.\n+To ensure data consistency, {brandname} uses a vector clock algorithm to detect\n+conflicting entries during backup operations, as in the following illustration:\n \n-With asynchronous replication, concurrent writes result in conflicting values\n-because sites replicate after entries are modified locally.  After replication\n-occurs, there is no guarantee which value for \"k1\" exists at which site.\n+[source,options=\"nowrap\"]\n+----\n+            LON       NYC\n \n-* Keys have conflicting values.\n+k1=(n/a)    0,0       0,0\n \n-* One of the conflicting values is overwritten if sites do not replicate values\n-at the same time. In this case, one of the values is lost and there is no\n-guarantee which value is saved.\n+k1=2        1,0  -->  1,0   k1=2\n \n-In all cases, inconsistencies in key values are resolved after the next\n-non-conflicting `put()` operation updates the value.\n+k1=3        1,1  <--  1,1   k1=3\n \n-[NOTE]\n-====\n-There currently is no conflict resolution policy that client applications can\n-use to handle conflicts in asynchronous mode. However, conflict resolution\n-techniques are planned for a future {brandname} version.\n-====\n+k1=5        2,1       1,2   k1=8\n \n-//dnaro: notes for IRAC conflict resolution\n+                 -->  2,1 (conflict)\n+(conflict)  1,2  <--\n+----\n \n-//Conflict Resolution with Cross-Site Replication\n-//Conflicting entries can occur with Active/Active site configurations if\n-//clients write to the same entries at the same time but at different sites.\n+Vector clocks are timestamp metadata that increment with each write to an\n+entry. In the preceding example, `0,0` represents the initial value for the\n+vector clock on \"k1\".\n \n-//For example, client A writes to \"k1\" in **LON** at the same time that client B\n-//writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-//than in **NYC**. After replication occurs, there is no guarantee which value\n-//for \"k1\" exists at which site.\n+A client puts \"k1=2\" in **LON** and the vector clock is `1,0`, which\n+{brandname} replicates to **NYC**. A client then puts \"k1=3\" in **NYC** and the\n+vector clock updates to `1,1`, which {brandname} replicates to **LON**.\n \n-//{brandname} uses version information for keys to detect conflicts during a\n-//backup. If {brandname} finds entries that conflict, it compares site names\n-//based on alphabetical order. The site name with the highest alphabetical\n-//ordering wins.\n+However if a client puts \"k1=5\" in **LON** at the same time that a client puts\n+\"k1=8\" in **NYC**, {brandname} detects a conflicting entry because the vector\n+value for \"k1\" is strictly greater or less between **LON** and **NYC**.\n \n-//Following the same example, if \"k1\" conflicts between **LON** and **NYC**,\n-//{brandname} always uses \"k1\" in **LON**.\n+When it finds conflicting entries, {brandname} uses the Java `compareTo(String", "originalCommit": "edc8eb82ebcf42a8127a49c2eecb7a9403f789f7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTY0NDkwNw==", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425644907", "bodyText": "added. thanks.", "author": "oraNod", "createdAt": "2020-05-15T08:25:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYzMTcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYzMjQ1OA==", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425632458", "bodyText": "I may be confused, but I think it is lexicographically lower/lesser... A is preceding B.", "author": "pruivo", "createdAt": "2020-05-15T08:01:14Z", "path": "documentation/src/main/asciidoc/topics/con_xsite_concurrent_writes.adoc", "diffHunk": "@@ -1,59 +1,51 @@\n-[id='conflicts-{context}']\n-= Conflicting Entries with Cross-Site Replication\n+[id='conflicting_entries-{context}']\n+= Concurrent Writes and Conflicting Entries\n Conflicting entries can occur with Active/Active site configurations if clients\n write to the same entries at the same time but at different sites.\n \n For example, client A writes to \"k1\" in **LON** at the same time that client B\n writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-than in **NYC**.\n+than in **NYC**. After replication occurs, there is no guarantee which value\n+for \"k1\" exists at which site.\n \n-With synchronous replication, concurrent writes result in deadlocks because\n-both sites lock the same key in different orders. To resolve deadlocks, client\n-applications must wait until the locks time out.\n+To ensure data consistency, {brandname} uses a vector clock algorithm to detect\n+conflicting entries during backup operations, as in the following illustration:\n \n-With asynchronous replication, concurrent writes result in conflicting values\n-because sites replicate after entries are modified locally.  After replication\n-occurs, there is no guarantee which value for \"k1\" exists at which site.\n+[source,options=\"nowrap\"]\n+----\n+            LON       NYC\n \n-* Keys have conflicting values.\n+k1=(n/a)    0,0       0,0\n \n-* One of the conflicting values is overwritten if sites do not replicate values\n-at the same time. In this case, one of the values is lost and there is no\n-guarantee which value is saved.\n+k1=2        1,0  -->  1,0   k1=2\n \n-In all cases, inconsistencies in key values are resolved after the next\n-non-conflicting `put()` operation updates the value.\n+k1=3        1,1  <--  1,1   k1=3\n \n-[NOTE]\n-====\n-There currently is no conflict resolution policy that client applications can\n-use to handle conflicts in asynchronous mode. However, conflict resolution\n-techniques are planned for a future {brandname} version.\n-====\n+k1=5        2,1       1,2   k1=8\n \n-//dnaro: notes for IRAC conflict resolution\n+                 -->  2,1 (conflict)\n+(conflict)  1,2  <--\n+----\n \n-//Conflict Resolution with Cross-Site Replication\n-//Conflicting entries can occur with Active/Active site configurations if\n-//clients write to the same entries at the same time but at different sites.\n+Vector clocks are timestamp metadata that increment with each write to an\n+entry. In the preceding example, `0,0` represents the initial value for the\n+vector clock on \"k1\".\n \n-//For example, client A writes to \"k1\" in **LON** at the same time that client B\n-//writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-//than in **NYC**. After replication occurs, there is no guarantee which value\n-//for \"k1\" exists at which site.\n+A client puts \"k1=2\" in **LON** and the vector clock is `1,0`, which\n+{brandname} replicates to **NYC**. A client then puts \"k1=3\" in **NYC** and the\n+vector clock updates to `1,1`, which {brandname} replicates to **LON**.\n \n-//{brandname} uses version information for keys to detect conflicts during a\n-//backup. If {brandname} finds entries that conflict, it compares site names\n-//based on alphabetical order. The site name with the highest alphabetical\n-//ordering wins.\n+However if a client puts \"k1=5\" in **LON** at the same time that a client puts\n+\"k1=8\" in **NYC**, {brandname} detects a conflicting entry because the vector\n+value for \"k1\" is strictly greater or less between **LON** and **NYC**.\n \n-//Following the same example, if \"k1\" conflicts between **LON** and **NYC**,\n-//{brandname} always uses \"k1\" in **LON**.\n+When it finds conflicting entries, {brandname} uses the Java `compareTo(String\n+anotherString)` method to compare site names. To determine which key takes\n+priority, {brandname} selects the site name that is lexicographically greater", "originalCommit": "edc8eb82ebcf42a8127a49c2eecb7a9403f789f7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "04640f384c300c0d56f05484e6275fdc2295a94c", "url": "https://github.com/infinispan/infinispan/commit/04640f384c300c0d56f05484e6275fdc2295a94c", "message": "ISPN-11780 updating xsite docs for IRAC implementation", "committedDate": "2020-05-15T10:52:19Z", "type": "commit"}, {"oid": "04640f384c300c0d56f05484e6275fdc2295a94c", "url": "https://github.com/infinispan/infinispan/commit/04640f384c300c0d56f05484e6275fdc2295a94c", "message": "ISPN-11780 updating xsite docs for IRAC implementation", "committedDate": "2020-05-15T10:52:19Z", "type": "forcePushed"}, {"oid": "06893859b617d2bb99aac03c29774e2c4fce3475", "url": "https://github.com/infinispan/infinispan/commit/06893859b617d2bb99aac03c29774e2c4fce3475", "message": "add tip for number in site name", "committedDate": "2020-05-15T14:52:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg1NzEzNw==", "url": "https://github.com/infinispan/infinispan/pull/8289#discussion_r425857137", "bodyText": "@tristantarrant How about this as a tip to assign priority to sites?", "author": "oraNod", "createdAt": "2020-05-15T14:54:08Z", "path": "documentation/src/main/asciidoc/topics/con_xsite_concurrent_writes.adoc", "diffHunk": "@@ -1,59 +1,61 @@\n-[id='conflicts-{context}']\n-= Conflicting Entries with Cross-Site Replication\n+[id='conflicting_entries-{context}']\n+= Concurrent Writes and Conflicting Entries\n Conflicting entries can occur with Active/Active site configurations if clients\n write to the same entries at the same time but at different sites.\n \n For example, client A writes to \"k1\" in **LON** at the same time that client B\n writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-than in **NYC**.\n+than in **NYC**. After replication occurs, there is no guarantee which value\n+for \"k1\" exists at which site.\n \n-With synchronous replication, concurrent writes result in deadlocks because\n-both sites lock the same key in different orders. To resolve deadlocks, client\n-applications must wait until the locks time out.\n+To ensure data consistency, {brandname} uses a vector clock algorithm to detect\n+conflicting entries during backup operations, as in the following illustration:\n \n-With asynchronous replication, concurrent writes result in conflicting values\n-because sites replicate after entries are modified locally.  After replication\n-occurs, there is no guarantee which value for \"k1\" exists at which site.\n+[source,options=\"nowrap\"]\n+----\n+            LON       NYC\n \n-* Keys have conflicting values.\n+k1=(n/a)    0,0       0,0\n \n-* One of the conflicting values is overwritten if sites do not replicate values\n-at the same time. In this case, one of the values is lost and there is no\n-guarantee which value is saved.\n+k1=2        1,0  -->  1,0   k1=2\n \n-In all cases, inconsistencies in key values are resolved after the next\n-non-conflicting `put()` operation updates the value.\n+k1=3        1,1  <--  1,1   k1=3\n \n-[NOTE]\n-====\n-There currently is no conflict resolution policy that client applications can\n-use to handle conflicts in asynchronous mode. However, conflict resolution\n-techniques are planned for a future {brandname} version.\n-====\n+k1=5        2,1       1,2   k1=8\n+\n+                 -->  2,1 (conflict)\n+(conflict)  1,2  <--\n+----\n \n-//dnaro: notes for IRAC conflict resolution\n+Vector clocks are timestamp metadata that increment with each write to an\n+entry. In the preceding example, `0,0` represents the initial value for the\n+vector clock on \"k1\".\n \n-//Conflict Resolution with Cross-Site Replication\n-//Conflicting entries can occur with Active/Active site configurations if\n-//clients write to the same entries at the same time but at different sites.\n+A client puts \"k1=2\" in **LON** and the vector clock is `1,0`, which\n+{brandname} replicates to **NYC**. A client then puts \"k1=3\" in **NYC** and the\n+vector clock updates to `1,1`, which {brandname} replicates to **LON**.\n \n-//For example, client A writes to \"k1\" in **LON** at the same time that client B\n-//writes to \"k1\" in **NYC**. In this case, \"k1\" has a different value in **LON**\n-//than in **NYC**. After replication occurs, there is no guarantee which value\n-//for \"k1\" exists at which site.\n+However if a client puts \"k1=5\" in **LON** at the same time that a client puts\n+\"k1=8\" in **NYC**, {brandname} detects a conflicting entry because the vector\n+value for \"k1\" is not strictly greater or less between **LON** and **NYC**.\n \n-//{brandname} uses version information for keys to detect conflicts during a\n-//backup. If {brandname} finds entries that conflict, it compares site names\n-//based on alphabetical order. The site name with the highest alphabetical\n-//ordering wins.\n+When it finds conflicting entries, {brandname} uses the Java `compareTo(String\n+anotherString)` method to compare site names. To determine which key takes\n+priority, {brandname} selects the site name that is lexicographically less\n+than the other. Keys from a site named **AAA** take priority over keys from a\n+site named **AAB** and so on.\n \n-//Following the same example, if \"k1\" conflicts between **LON** and **NYC**,\n-//{brandname} always uses \"k1\" in **LON**.\n+Following the same example, to resolve the conflict for \"k1\", {brandname} uses\n+the value for \"k1\" that originates from **LON**. This results in \"k1=5\" in both\n+**LON** and **NYC** after {brandname} resolves the conflict and replicates the\n+value.\n+\n+[TIP]\n+====\n+Prepend site names with numbers as a simple way to represent the order of\n+priority for resolving conflicting entries; for example, **1LON** and **2NYC**.\n+====", "originalCommit": "06893859b617d2bb99aac03c29774e2c4fce3475", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}