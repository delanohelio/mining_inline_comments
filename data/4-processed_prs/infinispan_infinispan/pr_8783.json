{"pr_number": 8783, "pr_title": "ISPN-12430 AsyncNonBlockingStore can have many more modifications tha\u2026", "pr_createdAt": "2020-10-15T01:09:56Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8783", "timeline": [{"oid": "789067501e6bb7bd8bdab8a6921650ee247b4c19", "url": "https://github.com/infinispan/infinispan/commit/789067501e6bb7bd8bdab8a6921650ee247b4c19", "message": "ISPN-12430 AsyncNonBlockingStore can have many more modifications than modification queue size", "committedDate": "2020-10-15T15:51:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2ODQ2NA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r510468464", "bodyText": "I'd like to see a comment explaining why is this true, or even better separate methods to manipulate the shared state atomically. It might also help to put hasPendingClear + pendingModifications in a State object, which could be then reused for the replicating modifications/clear.\nAlso, shouldn't this be checking replicatingClear as well?", "author": "danberindei", "createdAt": "2020-10-22T21:28:31Z", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         assert replicatingModifications == null || replicatingModifications.isEmpty();", "originalCommit": "789067501e6bb7bd8bdab8a6921650ee247b4c19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAwNjI4Ng==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r511006286", "bodyText": "Hrmm, I will look to see if I can make this a bit more clear.\nAnd sure replicatingClear should be false as well.", "author": "wburns", "createdAt": "2020-10-23T16:37:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2ODQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM4MTgwNA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r514381804", "bodyText": "I tried to add in the State object and I am not sold on it, I think the variables as they are currently is much simpler and obv requires less allocations.", "author": "wburns", "createdAt": "2020-10-29T16:08:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2ODQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjYwMTY4NA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r562601684", "bodyText": "Ok, let's keep it this way then", "author": "danberindei", "createdAt": "2021-01-22T12:35:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2ODQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ2ODU1Ng==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r510468556", "bodyText": "The javadoc is outdated.", "author": "danberindei", "createdAt": "2020-10-22T21:28:46Z", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {", "originalCommit": "789067501e6bb7bd8bdab8a6921650ee247b4c19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r510477735", "bodyText": "Isn't it a risk that you're deciding to submit a new batch in one synchronized block and actually submitting the batch in a different block?", "author": "danberindei", "createdAt": "2020-10-22T21:48:19Z", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -199,82 +173,75 @@ private synchronized void putClearModification() {\n    /**\n     * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n     * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         assert replicatingModifications == null || replicatingModifications.isEmpty();\n+         replicatingModifications = pendingModifications;\n+         ourModificationsToReplicate = pendingModifications;\n+         pendingModifications = newMap;\n+         isReplicatingClear = hasPendingClear;\n+         ourClearToReplicate = hasPendingClear;\n+         hasPendingClear = false;\n+      }\n \n-               CompletionStage<Void> asyncBatchStage;\n-               if (ourClearToReplicate) {\n-                  if (trace) {\n-                     log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n-                     synchronized (this) {\n-                        isReplicatingClear = false;\n-                     }\n-                  });\n-               } else {\n-                  asyncBatchStage = CompletableFutures.completedNull();\n-               }\n+      CompletionStage<Void> asyncBatchStage;\n+      if (ourClearToReplicate) {\n+         if (trace) {\n+            log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n+            synchronized (this) {\n+               isReplicatingClear = false;\n+            }\n+         });\n+      } else {\n+         asyncBatchStage = CompletableFutures.completedNull();\n+      }\n \n-               if (!ourModificationsToReplicate.isEmpty()) {\n-                  asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n-                     if (trace) {\n-                        log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.values(),\n-                              System.identityHashCode(ourModificationsToReplicate));\n-                     }\n-                     return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n-                        synchronized (this) {\n-                           replicatingModifications = null;\n-                        }\n-                     });\n-                  });\n+      if (!ourModificationsToReplicate.isEmpty()) {\n+         asyncBatchStage = asyncBatchStage.thenCompose(ignore -> {\n+            if (trace) {\n+               log.tracef(\"Sending batch write/remove operations %s to underlying store with id %s\", ourModificationsToReplicate.size(),\n+                     System.identityHashCode(ourModificationsToReplicate));\n+            }\n+            return retry(() -> replicateModifications(ourModificationsToReplicate), persistenceConfiguration.connectionAttempts()).whenComplete((ignore2, t) -> {\n+               synchronized (this) {\n+                  replicatingModifications = null;\n                }\n-\n-               asyncBatchStage.whenComplete((ignore, t) -> {\n-                  if (trace) {\n-                     log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  boolean submitNewBatch;\n-                  CompletableFuture<Void> future;\n-                  synchronized (this) {\n-                     submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;\n-                     future = batchFuture;\n-                     batchFuture = submitNewBatch ? new CompletableFuture<>() : null;\n-                  }\n-                  if (t != null) {\n-                     future.completeExceptionally(t);\n-                  } else {\n-                     future.complete(null);\n-                  }\n-                  if (submitNewBatch) {\n-                     if (trace) {\n-                        log.trace(\"Submitting new batch after completion of prior\");\n-                     }\n-                     requestFlowable.onNext(requestFlowable);\n-                  }\n-               });\n             });\n+         });\n+      }\n+\n+      asyncBatchStage.whenComplete((ignore, t) -> {\n+         if (trace) {\n+            log.tracef(\"Async operations completed for id %s\", System.identityHashCode(ourModificationsToReplicate));\n+         }\n+         boolean submitNewBatch;\n+         CompletableFuture<Void> future;\n+         synchronized (this) {\n+            submitNewBatch = !pendingModifications.isEmpty() || hasPendingClear;", "originalCommit": "789067501e6bb7bd8bdab8a6921650ee247b4c19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAwNzM5Ng==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r511007396", "bodyText": "The assignment of batchFuture protects that. You can only submit a batch if you assigned it to a new value.", "author": "wburns", "createdAt": "2020-10-23T16:39:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5MDgxMA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r511990810", "bodyText": "I'm pretty sure the assignment of batchFuture protects agains two threads both seeing a non-empty pendingModifications and each assigning its own CompletableFuture to batchFuture.\nOTOH I'm sure there's something else preventing 2 threads from both submitting a batch, it's just not clear from the code here.", "author": "danberindei", "createdAt": "2020-10-26T14:13:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxMDU2MA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r512010560", "bodyText": "You can only submit a batch if you wrote to batchFuture though.", "author": "wburns", "createdAt": "2020-10-26T14:38:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxMDkwMA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r512010900", "bodyText": "writing to batchFuture and submitting the batch are tied together and should only change together.", "author": "wburns", "createdAt": "2020-10-26T14:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4NTkxOA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547285918", "bodyText": "I was a bit scared of coming back to this, but let me try to understand this again.\n\nThe assignment of batchFuture protects that. You can only submit a batch if you assigned it to a new value.\n\nThe assignment of batchFuture itself doesn't really protect against anything. If thread A sees !pendingModifications.isEmpty() || hasPendingClear, it writes to batchFuture, but that doesn't prevent thread B from also seeing that !pendingModifications.isEmpty() || hasPendingClear and also writing to batchFuture.\n\nI'm pretty sure the assignment of batchFuture protects agains two threads both seeing a non-empty pendingModifications\n\nI think I meant \"I'm not sure\", at least that's how I see it now.\n\nYou can only submit a batch if you wrote to batchFuture though.\n\nBut there's nothing preventing you from writing to batchFuture here. If there is something somewhere else, I think that link should be made clearer by adding a comment or by moving that code closer.", "author": "danberindei", "createdAt": "2020-12-22T13:46:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4MDc5Nw==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r551580797", "bodyText": "Okay, I understand your concern. The part you are missing is that it isn't possible for two threads to invoke this to begin with as only a single thread can invoke submitTask at a time at \n  \n    \n      infinispan/core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java\n    \n    \n         Line 476\n      in\n      6729d3b\n    \n    \n    \n    \n\n        \n          \n           if (startNewBatch = batchFuture == null) { \n        \n    \n  \n\n.\nSo with this only one thread in submitModitification can assign the batchFuture and only if it is null. This means that submitTask is invoked in a thread at a time and batchFuture will be non null at the beginning, so its assignment you linked here will either put it to null or a new non null value. In the former case the loop doesn't continue, otherwise it resubmits the task again.\nI can add a more explicit comment to submitTask detailing this. It had a very brief comment, but wasn't really detailing this.", "author": "wburns", "createdAt": "2021-01-04T21:32:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAyODA2Mg==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560028062", "bodyText": "It's still not very clear to me, I'll definitely need a more explicit comment :)\nSo you're saying that when this code executes, batchFuture must be non-null, and any submitTask() running on another thread cannot submit a new batch?", "author": "danberindei", "createdAt": "2021-01-19T09:23:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQ3OTQxMA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560479410", "bodyText": "It's still not very clear to me, I'll definitely need a more explicit comment :)\nSo you're saying that when this code executes, batchFuture must be non-null, and any submitTask() running on another thread cannot submit a new batch?\n\nNo, as mentioned on the submitTask method it states that submitModification checks the variable and ensures that only single modification can start the call. So it isn't possible for submitTask to be invoked from multiple threads concurrently. I have added the latter part to the method description as well.", "author": "wburns", "createdAt": "2021-01-19T20:36:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDczOTIxMA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560739210", "bodyText": "It would be simpler if submitModification() was the only caller of submitTask().\nBut in submitTask() itself you have\nasyncBatchStage.whenComplete((ignore, t) -> {\n...\n            submitTask();\n         }", "author": "danberindei", "createdAt": "2021-01-20T07:47:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MTk4MDcwMQ==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r561980701", "bodyText": "Which is why I mentioned Invoking this method outside of this method... in the submitTask javadoc.\nBut the submitTask method is the only method that ever assigns batchFuture to null, which prevents concurrent modification as well. I have added another paragraph to the Javadoc.", "author": "wburns", "createdAt": "2021-01-21T15:39:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY0NzEzNg==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r562647136", "bodyText": "Which is why I mentioned Invoking this method outside of this method... in the submitTask javadoc.\n\nSorry, that was too subtle for me... I guess my eyes just glazed over the second \"this method\".\n\nBut the submitTask method is the only method that ever assigns batchFuture to null, which prevents concurrent modification as well. I have added another paragraph to the Javadoc.\n\nPart of the reason I didn't read the javadoc correctly is that I didn't see the whenComplete() lambda as part of \"this method\". Lexically it's a part of submitTask(), but at the JVM level it's a separate method, and it runs separately, not during the submitTask() invocation.", "author": "danberindei", "createdAt": "2021-01-22T13:56:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3NzczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3ODkwNg==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r510478906", "bodyText": "The apply() implementations expect the call to be synchronized on this, but there's no hint in the interface.", "author": "danberindei", "createdAt": "2020-10-22T21:51:02Z", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +441,67 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n+      CompletionStage<Void> nextBatchStage;\n       boolean startNewBatch;\n       synchronized (this) {\n+         modification.apply(this);", "originalCommit": "789067501e6bb7bd8bdab8a6921650ee247b4c19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAwNzc0NQ==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r511007745", "bodyText": "Yeah, I had it this way originally. Been changed a few times now :) I can add it to the interface.", "author": "wburns", "createdAt": "2020-10-23T16:40:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3ODkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NjAzOA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r511986038", "bodyText": "Yeah, I had it this way originally\n\nDid you mean the apply method was declared synchronized?", "author": "danberindei", "createdAt": "2020-10-26T14:06:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3ODkwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxMzU5NQ==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r512013595", "bodyText": "Yeah, that was in an early revision.", "author": "wburns", "createdAt": "2020-10-26T14:42:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQ3ODkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3NTIxNg==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r510675216", "bodyText": "Hmmm, the javadoc of delete() doesn't say anything about the return value being optional.\nBut since it clearly is optional, could it be that we don't need the return value at all?", "author": "danberindei", "createdAt": "2020-10-23T07:01:24Z", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +441,67 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n+      CompletionStage<Void> nextBatchStage;\n       boolean startNewBatch;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+\n+         if (pendingModifications.size() > modificationQueueSize) {\n+            if (trace) {\n+               log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n+            }\n+            nextBatchStage = batchFuture.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);\n+         } else {\n+            nextBatchStage = CompletableFutures.completedNull();\n+         }\n       }\n \n       if (startNewBatch) {\n          if (trace) {\n             log.tracef(\"Requesting a new async batch operation to be ran!\");\n          }\n          // Any old object will work\n-         requestFlowable.onNext(requestFlowable);\n+         submitTask();\n       }\n+      return nextBatchStage;\n    }\n \n-   private synchronized CompletionStage<Void> asyncOrThrottledStage() {\n-      if (pendingModifications.size() > modificationQueueSize) {\n-         if (trace) {\n-            log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n-         }\n-         // We could have multiple waiting on the stage, so make sure we can don't block the thread\n-         // that completes the stage\n-         return batchFuture.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);\n-      }\n-      return CompletableFutures.completedNull();\n+   @Override\n+   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n+      assertNotStopped();\n+      return submitModification(new PutModification(segment, entry));\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> delete(int segment, Object key) {\n+      assertNotStopped();\n+      return submitModification(new RemoveModification(segment, key))\n+            // We always assume it was removed with async", "originalCommit": "789067501e6bb7bd8bdab8a6921650ee247b4c19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxOTQ1MA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r512019450", "bodyText": "It is used by stuff like Map.remove and stats. It is just that when the store is async we essentially make it optional for performance. The prior async store did the same thing.  https://github.com/infinispan/infinispan/blob/10.1.x/core/src/main/java/org/infinispan/persistence/async/AsyncCacheWriter.java#L233", "author": "wburns", "createdAt": "2020-10-26T14:49:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3NTIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMxMTgxNQ==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547311815", "bodyText": "I don't think the result of store.delete() is needed for Cache.remove(key) or for cache statistics, CacheWriterInterceptor ignores it:\n\n  \n    \n      infinispan/core/src/main/java/org/infinispan/interceptors/impl/CacheWriterInterceptor.java\n    \n    \n         Line 219\n      in\n      7206596\n    \n    \n    \n    \n\n        \n          \n           return delayedValue(resultStage, rv);", "author": "danberindei", "createdAt": "2020-12-22T14:35:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3NTIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5NDg4Mg==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r551594882", "bodyText": "I agree, but I am guessing we may want a stat for removes at some point. Either way there is no way the async store can properly update it the way it is used in CacheWriterInterceptor.", "author": "wburns", "createdAt": "2021-01-04T21:59:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3NTIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA0MDcwMw==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560040703", "bodyText": "We already have the stat (removeHits). It's just that it's computed in CacheMgmtInterceptor based on the value that was loaded in the invocation context, not on the result of the store operation:\n\n  \n    \n      infinispan/core/src/main/java/org/infinispan/interceptors/impl/CacheMgmtInterceptor.java\n    \n    \n         Line 495\n      in\n      2d53d0a\n    \n    \n    \n    \n\n        \n          \n           if (removeCommand.isConditional()) {", "author": "danberindei", "createdAt": "2021-01-19T09:41:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3NTIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQ4MzA2Nw==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560483067", "bodyText": "Either way this seems like a discussion for another time. I really hate getting stuck in the weeds on something unrelated to the original PR making the PR wait on it. If you would I love for you to create a JIRA about changing the store SPI to not have that return value and we can discuss on Zulip or something.", "author": "wburns", "createdAt": "2021-01-19T20:43:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3NTIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDc1MTk1OA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560751958", "bodyText": "Sorry if I gave that impression, but I never meant to hold this PR, I was just asking a question because I didn't have a close look at this in the non-blocking SPI PR.\nAnyway, I created https://issues.redhat.com/browse/ISPN-12638 to replace the Boolean with Void", "author": "danberindei", "createdAt": "2021-01-20T08:12:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY3NTIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4MTA3Mg==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r510681072", "bodyText": "There should be a comment explaining how these executors changes the test compared to using NamedExecutorsFactory.", "author": "danberindei", "createdAt": "2020-10-23T07:14:33Z", "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "diffHunk": "@@ -100,12 +106,19 @@ void startMarshaller() {\n \n       nonBlockingExecutor = new ThreadPoolExecutor(0, ProcessorInfo.availableProcessors() * 2,\n             60L, TimeUnit.SECONDS,\n-            new LinkedBlockingQueue<>(),\n-            getTestThreadFactory(\"NonBlocking\"));\n+            new ArrayBlockingQueue<>(1),", "originalCommit": "789067501e6bb7bd8bdab8a6921650ee247b4c19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAwODUzNg==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r511008536", "bodyText": "This test was just like this before. I was only fixing it :(", "author": "wburns", "createdAt": "2020-10-23T16:41:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4MTA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NTMwNA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r511985304", "bodyText": "Well, the queue was unbound before, and and it has a fixed capacity of 1 now. Is that fixing something?", "author": "danberindei", "createdAt": "2020-10-26T14:05:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4MTA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5MTU3MQ==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r511991571", "bodyText": "The big fix is that it is using the correct thread pools as before it wasn't using threads that were non blocking.\nI only put the queue size to 1 to force more contention, I can undo that.", "author": "wburns", "createdAt": "2020-10-26T14:14:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4MTA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUzOTAxMw==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r513539013", "bodyText": "I only put the queue size to 1 to force more contention, I can undo that.\n\nSince this is a stress test that might be useful, but it would need a code comment explaining where it creates more contention and why it's useful to test that way.", "author": "danberindei", "createdAt": "2020-10-28T15:29:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4MTA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM4OTUyNw==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r514389527", "bodyText": "Okay.", "author": "wburns", "createdAt": "2020-10-29T16:18:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4MTA3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDM5MDIzNA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r514390234", "bodyText": "I have just reverted for now since the test doesn't exhibit enough pressure on the non blocking pool to cause a backpressure exception.", "author": "wburns", "createdAt": "2020-10-29T16:19:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4MTA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4NDk5OQ==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r510684999", "bodyText": "IMO the comment is misleading. It says \"This per-key lock holder provides guarantees that the final expected\nstate has not been affected by ordering issues\", but the key lock is held while performing the store write as well, not just while updating the expectedState map.\nSame with the withStore method, it should be withKeyLock IMO. Also, the worker thread blocks to wait for the key lock and for the store write, and I'm not sure if that scenario is still relevant.", "author": "danberindei", "createdAt": "2020-10-23T07:22:39Z", "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "diffHunk": "@@ -134,7 +147,7 @@ void stopMarshaller() throws InterruptedException {\n    // ImmortalCacheEntry{key=key165168, value=ImmortalCacheValue {value=61456}}}\n    // (Thread-194:) Expected state updated with key=key165168, value=61456\n    // (Thread-200:) Expected state updated with key=key165168, value=60483\n-   private LockContainer locks = new PerKeyLockContainer();\n+   private LockContainer locks;", "originalCommit": "789067501e6bb7bd8bdab8a6921650ee247b4c19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAwODkzMA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r511008930", "bodyText": "I didn't write this test at all. I would rather just remove all the garbage tbh. But I wasn't trying to completely rewrite this test, just get it to work.", "author": "wburns", "createdAt": "2020-10-23T16:42:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4NDk5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk4NDcwNA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r511984704", "bodyText": "I know the test is quite old and there's a lot of stuff that's out of date, but I don't think we're going to get any better opportunity to fix the outdated stuff later.", "author": "danberindei", "createdAt": "2020-10-26T14:05:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4NDk5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQxMTc0OQ==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r514411749", "bodyText": "So I change the name of withStore to withKeyLock but I am not sure how you want me to change the description for this method.\nI don't quite understand your comment about that the lock is held while doing the store write. That is how ISPN works. If the write is enqueued then it will release before it is written to the store and if it is enqueued but was \"full\" then it has to wait until it can be written before releasing the lock.", "author": "wburns", "createdAt": "2020-10-29T16:49:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4NDk5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMyNDk4Mw==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547324983", "bodyText": "Thanks for renaming the method.\nYou're right that the key lock must be held while doing the write. I was thinking that if you changed the test to acquire and release the lock in a non-blocking way, the thread performing the store operation would no longer necessarily be the worker thread. It could be the same non-blocking thread that performed the previous operation on that key, and the lack of a context switch between the 2 operations might make a potential race more or less likely.\nThinking again, it's not worth the trouble to make this test more life-like, when we can stress-test a full cache instead.", "author": "danberindei", "createdAt": "2020-12-22T14:59:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDY4NDk5OQ=="}], "type": "inlineReview"}, {"oid": "3915680c3e8d7623fe00252287b542d9ebfebea4", "url": "https://github.com/infinispan/infinispan/commit/3915680c3e8d7623fe00252287b542d9ebfebea4", "message": "Rework comments", "committedDate": "2020-10-29T17:39:44Z", "type": "forcePushed"}, {"oid": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641", "url": "https://github.com/infinispan/infinispan/commit/6729d3bca7492b317e5ce0d8a6e1c2b8fec93641", "message": "ISPN-12430 AsyncNonBlockingStore can have many more modifications than modification queue size", "committedDate": "2020-12-10T21:09:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NDIxNQ==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547264215", "bodyText": "Kind of off-topic, but shouldn't we also set a stopping flag so new requests are rejected?", "author": "danberindei", "createdAt": "2020-12-22T12:59:38Z", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -130,36 +117,23 @@ public AsyncNonBlockingStore(NonBlockingStore<K, V> actual) {\n       segmentCount = storeConfiguration.segmented() ? cacheConfiguration.clustering().hash().numSegments() : 1;\n       asyncConfiguration = storeConfiguration.async();\n       modificationQueueSize = asyncConfiguration.modificationQueueSize();\n-      // It is possible for multiple threads to write to this processor at the same time\n-      submissionFlowable = UnicastProcessor.<Modification>create(1).toSerialized();\n       nonBlockingExecutor = ctx.getNonBlockingExecutor();\n-      startSub = submissionFlowable.window(requestFlowable).subscribe(this);\n+      stopped = false;\n       return actual.start(ctx);\n    }\n \n    @Override\n    public CompletionStage<Void> stop() {\n       CompletionStage<Void> asyncStage;\n-      if (submissionFlowable != null) {\n-         if (trace) {\n-            log.tracef(\"Stopping async store containing store %s\", actual);\n-         }\n-         submissionFlowable = null;\n-         asyncStage = awaitQuiescence().whenComplete((ignore, t) -> {\n-            // We can only dispose of the subscription after we are sure we are totally stopped\n-            if (startSub != null) {\n-               startSub.dispose();\n-               startSub = null;\n-            }\n-         });\n-\n-      } else {\n-         asyncStage = CompletableFutures.completedNull();\n+      if (trace) {\n+         log.tracef(\"Stopping async store containing store %s\", actual);\n       }\n+      asyncStage = awaitQuiescence();", "originalCommit": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU3NTc5NQ==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r551575795", "bodyText": "Hrmm, I think it should be okay if I just move stopped = true; to the line before calling awaitQuiescence. There is still technically a tiny window, as this would really require a check before submitting to be 100%, but I am not too worried about that.", "author": "wburns", "createdAt": "2021-01-04T21:21:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NDIxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAwOTg1MQ==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560009851", "bodyText": "I don't think that will work, unless you also remove the assertNotStopped() check in batch().", "author": "danberindei", "createdAt": "2021-01-19T08:56:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NDIxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY2ODAwNA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r562668004", "bodyText": "I created https://issues.redhat.com/browse/ISPN-12647 to look more closely at the shutdown procedure in all the bundled store implementations.", "author": "danberindei", "createdAt": "2021-01-22T14:29:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI2NDIxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI4MDMyNw==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547280327", "bodyText": "Shouldn't this be\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     assert replicatingModifications == null || replicatingModifications.isEmpty() && !isReplicatingClear;\n          \n          \n            \n                     assert (replicatingModifications == null || replicatingModifications.isEmpty()) && !isReplicatingClear;", "author": "danberindei", "createdAt": "2020-12-22T13:34:25Z", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -197,84 +171,78 @@ private synchronized void putClearModification() {\n    }\n \n    /**\n-    * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n-    * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n+    * This method should only be invoked after the `batchFuture` was written to in a synchronized block.\n     */\n-   @Override\n-   public void accept(Flowable<Modification> modificationFlowable) {\n-      modificationFlowable.subscribe(modification -> modification.apply(this),\n-            RxJavaInterop.emptyConsumer(),\n-            () -> {\n-               Map<Object, Modification> newMap = new HashMap<>();\n-               if (trace) {\n-                  log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n-               }\n-               boolean ourClearToReplicate;\n-               Map<Object, Modification> ourModificationsToReplicate;\n-               synchronized (this) {\n-                  assert replicatingModifications == null || replicatingModifications.isEmpty();\n-                  replicatingModifications = pendingModifications;\n-                  ourModificationsToReplicate = pendingModifications;\n-                  pendingModifications = newMap;\n-                  isReplicatingClear = hasPendingClear;\n-                  ourClearToReplicate = hasPendingClear;\n-                  hasPendingClear = false;\n-               }\n-\n-\n-               CompletionStage<Void> asyncBatchStage;\n-               if (ourClearToReplicate) {\n-                  if (trace) {\n-                     log.tracef(\"Sending clear to underlying store for id %s\", System.identityHashCode(ourModificationsToReplicate));\n-                  }\n-                  asyncBatchStage = retry(actual::clear, persistenceConfiguration.connectionAttempts()).whenComplete((ignore, t) -> {\n-                     synchronized (this) {\n-                        isReplicatingClear = false;\n-                     }\n-                  });\n-               } else {\n-                  asyncBatchStage = CompletableFutures.completedNull();\n-               }\n+   public void submitTask() {\n+      Map<Object, Modification> newMap = new HashMap<>();\n+      if (trace) {\n+         log.tracef(\"Starting new batch with id %s\", System.identityHashCode(newMap));\n+      }\n+      boolean ourClearToReplicate;\n+      Map<Object, Modification> ourModificationsToReplicate;\n+      synchronized (this) {\n+         // The isReplicatingClear would be true or replicatingModifications non empty if an update was currently pending\n+         // But we should only allow one at a time\n+         assert replicatingModifications == null || replicatingModifications.isEmpty() && !isReplicatingClear;", "originalCommit": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5MzY5NA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547293694", "bodyText": "Since the elements of the flatMap() flowable are CompletionStages, is it really ok to ignore all but the last element?", "author": "danberindei", "createdAt": "2020-12-22T14:01:03Z", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();", "originalCommit": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4MzIzOA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r551583238", "bodyText": "Yes, as we are invoking submitModification in a single thread it guarantees the last invocation will be later than any other invocation in the underlying batched queue. And since all elements in a given batch are completed at the same time, it is okay. I can add a comment though, good call out.", "author": "wburns", "createdAt": "2021-01-04T21:37:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5MzY5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAzMDk2Mw==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560030963", "bodyText": "That too, but I was also thinking about what happens if one CompletionStage completes with an exception and then the last CompletionStage completes successfully.", "author": "danberindei", "createdAt": "2021-01-19T09:27:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5MzY5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDQ4MzQ5MQ==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560483491", "bodyText": "Okay.", "author": "wburns", "createdAt": "2021-01-19T20:44:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5MzY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NTU5Ng==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547295596", "bodyText": "Incomplete statement.\nI'd also replace the passive voice (\"It is assumed that\") w/ something more imperative, e.g. \"This method is not thread safe, callers must ensure that it is not invoked on multiple threads in parallel.\"", "author": "danberindei", "createdAt": "2020-12-22T14:04:46Z", "path": "core/src/main/java/org/infinispan/persistence/async/Modification.java", "diffHunk": "@@ -0,0 +1,35 @@\n+package org.infinispan.persistence.async;\n+\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.persistence.spi.MarshallableEntry;\n+\n+interface Modification {\n+   /**\n+    * Applies the modification to the provided async store.\n+    * <p>\n+    * It is assumed that callers of this method are done in a thread safe way, either by synchronizing\n+    * the invocation of this invocation, limiting concurrent invocations of this method or by\n+    * protecting", "originalCommit": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4NDUyMQ==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r551584521", "bodyText": "Okay, I just changed it to your text :)", "author": "wburns", "createdAt": "2021-01-04T21:40:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NTU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NTk3NA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547295974", "bodyText": "Can this be removed?", "author": "danberindei", "createdAt": "2020-12-22T14:05:35Z", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n       boolean startNewBatch;\n+      CompletionStage<Void> stageToWaitFor;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+         int replicatingSize = replicatingModifications == null ? 0 : replicatingModifications.size();\n+\n+         stageToWaitFor = pendingModifications.size() + replicatingSize > modificationQueueSize\n+               ? batchFuture : null;\n+         if (stageToWaitFor != null) {\n+            System.currentTimeMillis();", "originalCommit": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4NDYwMQ==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r551584601", "bodyText": "Yes, had it for a debug spot :D", "author": "wburns", "createdAt": "2021-01-04T21:40:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NTk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NzM1NA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547297354", "bodyText": "Maybe replicatingModifications should start non-null, so we can remove these null checks?", "author": "danberindei", "createdAt": "2020-12-22T14:08:18Z", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n       boolean startNewBatch;\n+      CompletionStage<Void> stageToWaitFor;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+         int replicatingSize = replicatingModifications == null ? 0 : replicatingModifications.size();", "originalCommit": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4OTEzMw==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r551589133", "bodyText": "Sure, will try assigning it to empty map.", "author": "wburns", "createdAt": "2021-01-04T21:50:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzI5NzM1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMwMTMyMg==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547301322", "bodyText": "How about submitStage instead? stageToWaitFor sounds like it could be anything.", "author": "danberindei", "createdAt": "2020-12-22T14:16:12Z", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n       boolean startNewBatch;\n+      CompletionStage<Void> stageToWaitFor;", "originalCommit": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU4OTQ2Mw==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r551589463", "bodyText": "Okay.", "author": "wburns", "createdAt": "2021-01-04T21:51:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMwMTMyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMwNjM5Mw==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547306393", "bodyText": "Is this really needed?\nThe way I see it, either store operations can complete on any thread, and switching to a non-blocking thread here is not needed, or store operations must complete on a non-blocking thread, and the batch future must have been completed on a non-blocking thread as well.", "author": "danberindei", "createdAt": "2020-12-22T14:25:40Z", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -474,72 +454,72 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      Maybe<CompletionStage<Void>> maybeRemove = Flowable.fromPublisher(removePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(key -> submitModification(new RemoveModification(sp.getSegment(), key))), publisherCount)\n+            .lastElement();\n+      Maybe<CompletionStage<Void>> maybeModify = Flowable.fromPublisher(writePublisher)\n+            .flatMap(sp -> Flowable.fromPublisher(sp)\n+                  .map(me -> submitModification(new PutModification(sp.getSegment(), me))), publisherCount)\n+            .lastElement();\n+      return maybeRemove.mergeWith(maybeModify)\n+            .lastStage(CompletableFutures.completedNull())\n+            .thenCompose(java.util.function.Function.identity());\n+   }\n+\n+   CompletionStage<Void> submitModification(Modification modification) {\n       boolean startNewBatch;\n+      CompletionStage<Void> stageToWaitFor;\n       synchronized (this) {\n+         modification.apply(this);\n+\n          if (startNewBatch = batchFuture == null) {\n             batchFuture = new CompletableFuture<>();\n          }\n+         int replicatingSize = replicatingModifications == null ? 0 : replicatingModifications.size();\n+\n+         stageToWaitFor = pendingModifications.size() + replicatingSize > modificationQueueSize\n+               ? batchFuture : null;\n+         if (stageToWaitFor != null) {\n+            System.currentTimeMillis();\n+         }\n+      }\n+\n+      if (trace) {\n+         log.tracef(\"A new modification %s has been enqueued with async store\", modification);\n       }\n \n       if (startNewBatch) {\n          if (trace) {\n             log.tracef(\"Requesting a new async batch operation to be ran!\");\n          }\n-         // Any old object will work\n-         requestFlowable.onNext(requestFlowable);\n+         submitTask();\n+      }\n+      if (stageToWaitFor != null && trace) {\n+         log.tracef(\"Operation will not return immediately, must wait until current batch completes\");\n       }\n+      return stageToWaitFor == null ? CompletableFutures.completedNull() :\n+            stageToWaitFor.thenApplyAsync(CompletableFutures.toNullFunction(), nonBlockingExecutor);", "originalCommit": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5MTE2Nw==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r551591167", "bodyText": "The problem isn't what thread it is invoked on but rather that a bunch of these could be enqueued waiting for the completion of this stage. The stageToWaitFor is the batchFuture so you could have hundreds or thousands depending upon this one stage, so we may not want to block completion of all of these on a single thread. But maybe that is okay?", "author": "wburns", "createdAt": "2021-01-04T21:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMwNjM5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY1OTIxNg==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r562659216", "bodyText": "I see.\nI was thinking running them on a single thread might be better for throughput, because you have less context switching. But submitting them to the executor is potentially better for latency, so let's keep it this way unless it comes up in the profiler at some point in the future.", "author": "danberindei", "createdAt": "2021-01-22T14:16:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMwNjM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMxNDI5Mg==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547314292", "bodyText": "I didn't get this comment, which test method has this problem? And what does the store write to key X get in a deadlock with?", "author": "danberindei", "createdAt": "2020-12-22T14:40:14Z", "path": "core/src/test/java/org/infinispan/persistence/support/AsyncStoreTest.java", "diffHunk": "@@ -370,7 +370,10 @@ private static ConfigurationBuilder config(boolean passivation) {\n          ConfigurationBuilder config = new ConfigurationBuilder();\n          config.memory().maxCount(1).persistence().passivation(passivation).addStore(LockableStoreConfigurationBuilder.class)\n                .async()\n-                  .modificationQueueSize(1)\n+                  // When using passivation we block a store write to key X - which in turn\n+                  // gets in a deadlock as it never completes - make sure to set queue size one\n+                  // higher so it can complete", "originalCommit": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5NzEwOA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r551597108", "bodyText": "The ordering in passivation. The problem is the doTestEndToEndPutPut test delays the store write from completing in the test directly. Thus the batch can't complete and thus if you submit a new write to the store it will be enqueued in the async batch and wont' complete.", "author": "wburns", "createdAt": "2021-01-04T22:05:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMxNDI5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY2MjQ3Mg==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r562662472", "bodyText": "I like the new comment \ud83d\udc4d", "author": "danberindei", "createdAt": "2021-01-22T14:20:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMxNDI5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMxNjI0Mg==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547316242", "bodyText": "SLOW_STORE_WAIT is 100, waiting 205ms every time is too much IMO.\nThe store only has slow(true) for testConcurrentClearAndStop, so waiting 10ms to get a timeout should be enough.", "author": "danberindei", "createdAt": "2020-12-22T14:43:42Z", "path": "core/src/test/java/org/infinispan/persistence/support/AsyncStoreTest.java", "diffHunk": "@@ -412,7 +415,7 @@ public void call() throws InterruptedException {\n                   }\n                });\n \n-               Exceptions.expectException(TimeoutException.class, () -> f.get(100, TimeUnit.MILLISECONDS));\n+               Exceptions.expectException(TimeoutException.class, () -> f.get(DummyInMemoryStore.SLOW_STORE_WAIT * 2 + 5, TimeUnit.MILLISECONDS));", "originalCommit": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU5NjI2MQ==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r551596261", "bodyText": "IIRC passivation actually has to hit the store twice, so it really should have been 200 originally. So the original number was too low. So I really only added 5 milliseconds. The biggest change is that it is based on the dummy slow time so you can tweak it in tests if needed.", "author": "wburns", "createdAt": "2021-01-04T22:03:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMxNjI0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA0ODQ2Nw==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560048467", "bodyText": "This test's writes would finish in <1ms if they weren't waiting for store.delayedFuture (unless you're debugging, and then 200ms vs 10ms doesn't change anything).\nIf it was using slow(true), then it would make sense to give it 200ms to finish both writes, but it's not, so f will complete as soon as store.delayedFuture is completed.", "author": "danberindei", "createdAt": "2021-01-19T09:52:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMxNjI0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzMyNzA5OQ==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r547327099", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        .location(\"/tmp\")\n          \n          \n            \n                        .location(location)", "author": "danberindei", "createdAt": "2020-12-22T15:03:13Z", "path": "core/src/test/java/org/infinispan/stress/AsyncStoreStressTest.java", "diffHunk": "@@ -153,6 +166,7 @@ void stopMarshaller() throws InterruptedException {\n             .getDefaultCacheConfiguration(false)\n             .persistence()\n             .addSingleFileStore()\n+            .location(\"/tmp\")", "originalCommit": "6729d3bca7492b317e5ce0d8a6e1c2b8fec93641", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8249ad48b8202fdab57607c4d01090b4ae518d6e", "url": "https://github.com/infinispan/infinispan/commit/8249ad48b8202fdab57607c4d01090b4ae518d6e", "message": "ISPN-12430 AsyncNonBlockingStore can have many more modifications than modification queue size", "committedDate": "2021-01-04T22:08:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDAxMTgyNg==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560011826", "bodyText": "Markdown alert :)", "author": "danberindei", "createdAt": "2021-01-19T08:59:14Z", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -196,84 +171,81 @@ private synchronized void putClearModification() {\n    }\n \n    /**\n-    * This method is invoked every time a new batch of entries is generated. When the Flowable is completed, any\n-    * enqueued values should be replicated to the underlying store.\n-    * @param modificationFlowable the next stream of values to enqueue and eventually send\n+    * This method is protected by the `batchFuture` instance variable. Invoking this method outside of this method", "originalCommit": "8249ad48b8202fdab57607c4d01090b4ae518d6e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA0MTUxMQ==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560041511", "bodyText": "Typo: IThis", "author": "danberindei", "createdAt": "2021-01-19T09:42:29Z", "path": "core/src/main/java/org/infinispan/persistence/async/Modification.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package org.infinispan.persistence.async;\n+\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.persistence.spi.MarshallableEntry;\n+\n+interface Modification {\n+   /**\n+    * Applies the modification to the provided async store.\n+    * <p>\n+    * IThis method is not thread safe, callers must ensure that it is not invoked on multiple threads in parallel.", "originalCommit": "8249ad48b8202fdab57607c4d01090b4ae518d6e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MDA0MjQzOA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r560042438", "bodyText": "Forgot to remove the segment-related stuff :)", "author": "danberindei", "createdAt": "2021-01-19T09:43:51Z", "path": "core/src/main/java/org/infinispan/persistence/async/Modification.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package org.infinispan.persistence.async;\n+\n+import java.util.concurrent.CompletionStage;\n+\n+import org.infinispan.persistence.spi.MarshallableEntry;\n+\n+interface Modification {\n+   /**\n+    * Applies the modification to the provided async store.\n+    * <p>\n+    * IThis method is not thread safe, callers must ensure that it is not invoked on multiple threads in parallel.\n+    * @param store the store to apply the modification to\n+    * @param <K> key type\n+    * @param <V> value type\n+    */\n+   <K, V> void apply(AsyncNonBlockingStore<K, V> store);\n+\n+   /**\n+    * Returns the segment that maps to this modification. Some modifications may not map to a given\n+    * segment and may throw an {@link UnsupportedOperationException}.\n+    * @return the segment that maps to the modification\n+    */\n+   int getSegment();\n+\n+   /**\n+    * Returns this modification as a stage that is already complete. Some modifications may not map\n+    * to a given segment and may throw an {@link UnsupportedOperationException}.", "originalCommit": "8249ad48b8202fdab57607c4d01090b4ae518d6e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4f70ef6bb1a8a28dd7c75522d1de4e12f5076261", "url": "https://github.com/infinispan/infinispan/commit/4f70ef6bb1a8a28dd7c75522d1de4e12f5076261", "message": "rework comments", "committedDate": "2021-01-19T20:53:44Z", "type": "forcePushed"}, {"oid": "9d1174dc9dfc362b2a6a2937a7491eb16d99d7ae", "url": "https://github.com/infinispan/infinispan/commit/9d1174dc9dfc362b2a6a2937a7491eb16d99d7ae", "message": "ISPN-12430 AsyncNonBlockingStore can have many more modifications than modification queue size", "committedDate": "2021-01-21T16:08:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY3MDU2NA==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r562670564", "bodyText": "You removed the lastElement() call, so I think you can also remove this comment.", "author": "danberindei", "createdAt": "2021-01-22T14:32:59Z", "path": "core/src/main/java/org/infinispan/persistence/async/AsyncNonBlockingStore.java", "diffHunk": "@@ -473,72 +459,70 @@ public void run() {\n    public CompletionStage<Void> batch(int publisherCount, Publisher<SegmentedPublisher<Object>> removePublisher,\n          Publisher<SegmentedPublisher<MarshallableEntry<K, V>>> writePublisher) {\n       assertNotStopped();\n-      Flowable.fromPublisher(removePublisher)\n-            .subscribe(sp ->\n-               Flowable.fromPublisher(sp)\n-                     .subscribe(key -> submissionFlowable.onNext(new RemoveModification(sp.getSegment(), key)))\n-            );\n-      Flowable.fromPublisher(writePublisher)\n-            .subscribe(sp ->\n-                  Flowable.fromPublisher(sp)\n-                        .subscribe(me -> submissionFlowable.onNext(new PutModification(sp.getSegment(), me)))\n-            );\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new PutModification(segment, entry));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage();\n-   }\n-\n-   @Override\n-   public CompletionStage<Boolean> delete(int segment, Object key) {\n-      assertNotStopped();\n-      submissionFlowable.onNext(new RemoveModification(segment, key));\n-      submitBatchIfNecessary();\n-      return asyncOrThrottledStage()\n-            // We always assume it was removed with async\n-            .thenCompose(ignore -> CompletableFutures.completedTrue());\n-   }\n-\n-   private void submitBatchIfNecessary() {\n+      // Note that all of these use the lastElement method to detect completion. This is okay only because the", "originalCommit": "9d1174dc9dfc362b2a6a2937a7491eb16d99d7ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY5MzMzOQ==", "url": "https://github.com/infinispan/infinispan/pull/8783#discussion_r562693339", "bodyText": "Sure.", "author": "wburns", "createdAt": "2021-01-22T15:05:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2MjY3MDU2NA=="}], "type": "inlineReview"}, {"oid": "49ec44202e094e6c168733c42f62a0ec3c1c2384", "url": "https://github.com/infinispan/infinispan/commit/49ec44202e094e6c168733c42f62a0ec3c1c2384", "message": "ISPN-12430 AsyncNonBlockingStore can have many more modifications than modification queue size", "committedDate": "2021-01-22T15:11:55Z", "type": "forcePushed"}, {"oid": "2d9b52b4bda2a871abdb2c7af3335900907df682", "url": "https://github.com/infinispan/infinispan/commit/2d9b52b4bda2a871abdb2c7af3335900907df682", "message": "ISPN-12430 AsyncNonBlockingStore can have many more modifications than modification queue size", "committedDate": "2021-01-22T15:16:53Z", "type": "commit"}, {"oid": "2d9b52b4bda2a871abdb2c7af3335900907df682", "url": "https://github.com/infinispan/infinispan/commit/2d9b52b4bda2a871abdb2c7af3335900907df682", "message": "ISPN-12430 AsyncNonBlockingStore can have many more modifications than modification queue size", "committedDate": "2021-01-22T15:16:53Z", "type": "forcePushed"}]}