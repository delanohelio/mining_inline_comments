{"pr_number": 7775, "pr_title": "ISPN-9082 Off Heap max idle", "pr_createdAt": "2020-01-22T15:16:11Z", "pr_url": "https://github.com/infinispan/infinispan/pull/7775", "timeline": [{"oid": "6f4a7efa3f3c1508d915a80601b258021296167d", "url": "https://github.com/infinispan/infinispan/commit/6f4a7efa3f3c1508d915a80601b258021296167d", "message": "retry for optimistic reads", "committedDate": "2020-01-28T19:07:57Z", "type": "forcePushed"}, {"oid": "430f81df9b0b6b82afad9db3c89330e3fa37953d", "url": "https://github.com/infinispan/infinispan/commit/430f81df9b0b6b82afad9db3c89330e3fa37953d", "message": "retry for optimistic reads", "committedDate": "2020-01-28T19:32:50Z", "type": "forcePushed"}, {"oid": "cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06", "url": "https://github.com/infinispan/infinispan/commit/cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06", "message": "Retry for max idle and optimistic reads in addition to writes", "committedDate": "2020-01-28T20:08:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyODUyNA==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372428524", "bodyText": "Couldn't getMapForSegment() return a TouchableMap, or rather a PeekableTouchableMap, in order to avoid the instanceof check?", "author": "danberindei", "createdAt": "2020-01-29T14:53:11Z", "path": "core/src/main/java/org/infinispan/container/impl/AbstractInternalDataContainer.java", "diffHunk": "@@ -124,6 +124,12 @@ public void start() {\n    public boolean touch(int segment, Object k, long currentTimeMillis) {\n       ConcurrentMap<K, InternalCacheEntry<K, V>> entries = getMapForSegment(segment);\n       if (entries != null) {\n+         if (trace) {\n+            log.tracef(\"Touching key %s in container with time of %d\", k, currentTimeMillis);\n+         }\n+         if (entries instanceof TouchableMap) {", "originalCommit": "cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU4OTE4NA==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372589184", "bodyText": "Unfortunately getMapForSegment can return a Caffeine map, which doesn't implement those interfaces.", "author": "wburns", "createdAt": "2020-01-29T19:36:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyODUyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkwNzk4MQ==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372907981", "bodyText": "I know, but I was thinking that the Caffeine map could be wrapped, and the wrapper could touch the entry in the entries map instead.", "author": "danberindei", "createdAt": "2020-01-30T11:56:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyODUyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk3NTMzNg==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372975336", "bodyText": "I guess that should be doable. However let me do that in a separate JIRA. More specifically I can test that out in the perf issue.", "author": "wburns", "createdAt": "2020-01-30T14:21:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyODUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ1ODM1Nw==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372458357", "bodyText": "Shouldn't it throw an exception instead?", "author": "danberindei", "createdAt": "2020-01-29T15:38:24Z", "path": "core/src/main/java/org/infinispan/container/offheap/OffHeapConcurrentMap.java", "diffHunk": "@@ -160,6 +161,52 @@ public OffHeapConcurrentMap(OffHeapMemoryAllocator allocator,\n       }\n    }\n \n+   @Override\n+   public boolean touchKey(Object k, long currentTimeMillis) {\n+      if (!(k instanceof WrappedBytes)) {\n+         return false;", "originalCommit": "cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU4ODc3OA==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372588778", "bodyText": "We could, but I was being consistent with the other methods, such as get that just returns null.", "author": "wburns", "createdAt": "2020-01-29T19:35:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ1ODM1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkwODgyNw==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372908827", "bodyText": "Ok, I guess it implements Map so in theory get() could be called with any type.", "author": "danberindei", "createdAt": "2020-01-30T11:58:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ1ODM1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ4Mjk5NQ==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372482995", "bodyText": "Why would the metadata size be different?", "author": "danberindei", "createdAt": "2020-01-29T16:17:23Z", "path": "core/src/main/java/org/infinispan/container/offheap/OffHeapEntryFactoryImpl.java", "diffHunk": "@@ -503,4 +523,105 @@ public long calculateSize(WrappedBytes key, WrappedBytes value, Metadata metadat\n       }\n       return UnpooledOffHeapMemoryAllocator.estimateSizeOverhead(totalSize + metadataSize);\n    }\n+\n+   @Override\n+   public long updateMaxIdle(long address, long currentTimeMillis) {\n+      // 16 bytes for eviction if needed (optional)\n+      // 8 bytes for linked pointer\n+      long offset = evictionEnabled ? 24 : 8;\n+\n+      byte metadataType = MEMORY.getByte(address, offset);\n+\n+      if ((metadataType & (IMMORTAL + MORTAL)) != 0) {\n+         return 0;\n+      }\n+\n+      // skips over metadataType, hashCode\n+      offset += 5;\n+\n+      int keySize = MEMORY.getInt(address, offset);\n+      offset += 4;\n+\n+      boolean hasVersion = (metadataType & HAS_VERSION) != 0;\n+\n+      if ((metadataType & TRANSIENT) != 0) {\n+         // Skip the metadataSize (if version present), valueSize and the keyBytes\n+         offset += ((hasVersion ? 4 : 0) + 4 + keySize);\n+         // Skip the max idle value\n+         storeLongLittleEndian(address, offset + 8, currentTimeMillis);\n+         return 0;\n+      }\n+      if ((metadataType & TRANSIENT_MORTAL) != 0) {\n+         // Skip the metadataSize (if version present), valueSize and the keyBytes\n+         offset += ((hasVersion ? 4 : 0) + 4 + keySize);\n+         // Skip the lifespan/max idle values and created\n+         storeLongLittleEndian(address, offset + 24, currentTimeMillis);\n+         return 0;\n+      }\n+\n+      byte[] metadataBytes = new byte[MEMORY.getInt(address, offset)];\n+      int metadataSize = metadataBytes.length;\n+      offset += 4;\n+\n+      int valueSize = MEMORY.getInt(address, offset);\n+      offset += 4;\n+\n+      // skips over the actual key bytes\n+      offset += keySize;\n+\n+      MEMORY.getBytes(address, offset, metadataBytes, 0, metadataSize);\n+\n+      Metadata metadata;\n+      try {\n+         metadata = (Metadata) marshaller.objectFromByteBuffer(metadataBytes);\n+      } catch (IOException | ClassNotFoundException e) {\n+         throw new CacheException(e);\n+      }\n+\n+      Metadata newMetadata = metadata.builder()\n+            .maxIdle(currentTimeMillis, TimeUnit.MILLISECONDS)\n+            .build();\n+\n+      byte[] newMetadataBytes;\n+      try {\n+         newMetadataBytes = marshaller.objectToByteBuffer(newMetadata, metadataSize);\n+      } catch (IOException e) {\n+         throw new CacheException(e);\n+      } catch (InterruptedException e) {\n+         Thread.currentThread().interrupt();\n+         throw new CacheException(e);\n+      }\n+\n+      int newMetdataSize = newMetadataBytes.length;\n+      if (newMetdataSize != metadataSize) {", "originalCommit": "cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU4ODQ2Nw==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372588467", "bodyText": "With metadata, we don't know for sure that the serialized form is the same with different timestamps. For example if they were doing some sort of UnsignedNumeric where it can vary in size.", "author": "wburns", "createdAt": "2020-01-29T19:34:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ4Mjk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkxMDA5OA==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372910098", "bodyText": "None of the InternalCacheEntry.touch() implementations change the metadata.", "author": "danberindei", "createdAt": "2020-01-30T12:01:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ4Mjk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk3MDA1OA==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372970058", "bodyText": "That isn't the point. If you notice this branch is specifically when a CUSTOM or VERSION metadata is used. In either case we set the access time on the metadata. If the serialized form is different, we have to put it somewhere...", "author": "wburns", "createdAt": "2020-01-30T14:12:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ4Mjk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mzk5NjA4Nw==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r373996087", "bodyText": "How are you actually setting the access time on the metadata?\nThe last access timestamp only exists in InternalMetadata, which is an internal type, and since 10.0 it's never stored in the container/stores, it's only used with cache.put() to preserve the timestamps.", "author": "danberindei", "createdAt": "2020-02-03T09:28:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ4Mjk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDExOTM2NQ==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r374119365", "bodyText": "The problem is calls like this \n  \n    \n      infinispan/core/src/main/java/org/infinispan/container/offheap/OffHeapEntryFactoryImpl.java\n    \n    \n         Line 581\n      in\n      0309bf4\n    \n    \n    \n    \n\n        \n          \n           Metadata newMetadata = metadata.builder() \n        \n    \n  \n\n\nI don't quite understand the obsession with InternalMetadata as a user can supply any Metadata implementation. For example the MetadataAPITest tests that the custom metadata is stored and that it can be read back.", "author": "wburns", "createdAt": "2020-02-03T14:05:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ4Mjk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUyNDA3MA==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r374524070", "bodyText": "That code is wrong: maxIdle is \"maximum idle time of the entry in number of milliseconds\", not the last access timestamp. Metadata just doesn't have any timestamps in it any more.", "author": "danberindei", "createdAt": "2020-02-04T08:11:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ4Mjk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY4MjQ5Nw==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r374682497", "bodyText": "That is the sole usage of last access timestamp is for maxIdle though.. Unless there is some other usage you can point me to, would be great to know.", "author": "wburns", "createdAt": "2020-02-04T13:55:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ4Mjk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY4NDY0MA==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r374684640", "bodyText": "And also to point out the same type of thing is used here for the Metadata Builder, so we should make sure that is correct as well.\nhttps://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/cache/impl/CacheImpl.java#L1965", "author": "wburns", "createdAt": "2020-02-04T13:58:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ4Mjk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDczMzI2OA==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r374733268", "bodyText": "Sorry I misunderstood your point earlier. That means that expiration with a custom metadata, which includes lifespan, has been broken forever in OFF_HEAP. This requires quite a bit of refactoring and changing the ordering of code to handle this assumption. The code currently assumes that if a custom metadata is used it doesn't need to persist the expiration metadata, however it does.", "author": "wburns", "createdAt": "2020-02-04T15:17:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ4Mjk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc0MTY0OQ==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r374741649", "bodyText": "I created https://issues.redhat.com/browse/ISPN-11277 to handle the custom metadata and off heap.", "author": "wburns", "createdAt": "2020-02-04T15:29:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ4Mjk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc2MDczNw==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r374760737", "bodyText": "Ok", "author": "danberindei", "createdAt": "2020-02-04T15:59:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ4Mjk5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ5MTI1Nw==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372491257", "bodyText": "\ud83d\udc4d, it's easier to reason about your own future than the previous operation's future", "author": "danberindei", "createdAt": "2020-01-29T16:30:22Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -360,17 +322,51 @@ Throwable getNestedThrowable(Throwable t) {\n          lifespan = entry.getLifespan();\n          expiredMortal = ExpiryHelper.isExpiredMortal(lifespan, entry.getCreated(), currentTime);\n       }\n+      CompletableFuture<Boolean> future;\n       if (expiredMortal) {\n-         CompletableFuture<Boolean> future = handleLifespanExpireEntry(entry.getKey(), value, lifespan, isWrite);\n+         future = handleLifespanExpireEntry(entry.getKey(), value, lifespan, isWrite);\n          // We don't want to block the user while the remove expired is happening for lifespan on a read\n-         if (waitOnLifespanExpiration(isWrite)) {\n-            return future;\n+         if (!waitOnLifespanExpiration(isWrite)) {\n+            return CompletableFutures.completedTrue();\n          }\n-         return CompletableFutures.completedTrue();\n       } else {\n          // This means it expired transiently - this will block user until we confirm the entry is okay\n-         return handleMaxIdleExpireEntry(entry.getKey(), value, entry.getMaxIdle(), isWrite);\n+         future = handleMaxIdleExpireEntry(entry.getKey(), value, entry.getMaxIdle(), isWrite);\n       }\n+\n+      return future.handle((expired, t) -> {", "originalCommit": "cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU4ODAwNw==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372588007", "bodyText": "Agreed - I like this approach a lot better.", "author": "wburns", "createdAt": "2020-01-29T19:33:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ5MTI1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUzNzExMQ==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372537111", "bodyText": "I wonder how bad would it be to copy the ICE into a MvccEntry all the time.\nI've never liked the synchronized (cacheEntry) stuff, and JMC always complains that the JVM tried biased locking and it didn't work out.", "author": "danberindei", "createdAt": "2020-01-29T17:52:51Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -452,18 +447,22 @@ public boolean entryExpiredInMemoryFromIteration(InternalCacheEntry<K, V> entry,\n             .thenCompose(Function.identity());\n    }\n \n-   private CompletionStage<Boolean> checkExpiredMaxIdle(Object key, int segment) {\n+   private CompletionStage<Boolean> attemptTouchAndReturnIfExpired(InternalCacheEntry ice, int segment) {\n       LocalizedCacheTopology lct = distributionManager.getCacheTopology();\n \n-      TouchCommand touchCommand = cf.running().buildTouchCommand(key, segment);\n+      TouchCommand touchCommand = cf.running().buildTouchCommand(ice.getKey(), segment);\n       touchCommand.setTopologyId(lct.getTopologyId());\n \n       CompletionStage<Boolean> remoteStage = invokeTouchCommandRemotely(touchCommand, lct, segment);\n       touchCommand.init(componentRegistry, false);\n+      long accessTime = timeService.wallClockTime();\n+      touchCommand.setAccessTime(accessTime);\n       CompletableFuture<Object> localStage = touchCommand.invokeAsync();\n \n       return remoteStage.thenCombine(localStage, (remoteTouch, localTouch) -> {\n          if (remoteTouch == Boolean.TRUE && localTouch == Boolean.TRUE) {\n+            // The ICE can be a copy in cases such as off heap - we need to update its time that is reported to the user", "originalCommit": "cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU4OTcxNQ==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372589715", "bodyText": "I think we were trying to avoid additional allocations for things like reads, no? I think we could investigate this in a separate JIRA though.", "author": "wburns", "createdAt": "2020-01-29T19:37:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUzNzExMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkyMjUzOA==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372922538", "bodyText": "Yeah, I was going a bit off-topic here, I created ISPN-11256", "author": "danberindei", "createdAt": "2020-01-30T12:33:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUzNzExMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUzNzU5Mw==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372537593", "bodyText": "IMO transient is better than a comment.", "author": "danberindei", "createdAt": "2020-01-29T17:53:48Z", "path": "core/src/main/java/org/infinispan/expiration/impl/TouchCommand.java", "diffHunk": "@@ -35,6 +35,9 @@\n    private TimeService timeService;\n    private DistributionManager distributionManager;\n \n+   // This is not replicated - here solely to avoid additional time lookups in callers\n+   private long accessTime = -1;", "originalCommit": "cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU4NzgwOQ==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372587809", "bodyText": "Agreed, I usually do that, forgot. Thanks for the reminder.", "author": "wburns", "createdAt": "2020-01-29T19:33:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUzNzU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUzOTg3OA==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372539878", "bodyText": "On the local node you don't need to call invokeAsync(), you can add a new method that takes the access time as a parameter. Then invokeAsync() would call the new method with timeService.wallClockTime(), and you wouldn't need a field.", "author": "danberindei", "createdAt": "2020-01-29T17:58:20Z", "path": "core/src/main/java/org/infinispan/expiration/impl/TouchCommand.java", "diffHunk": "@@ -90,9 +93,14 @@ public void setTopologyId(int topologyId) {\n       this.topologyId = topologyId;\n    }\n \n+   public void setAccessTime(long currentTimeMillis) {\n+      this.accessTime = currentTimeMillis;\n+   }\n+\n    @Override\n    public CompletableFuture<Object> invokeAsync() {\n-      boolean touched = internalDataContainer.touch(segment, key, timeService.wallClockTime());\n+      long accessTime = this.accessTime == -1 ? timeService.wallClockTime() : this.accessTime;", "originalCommit": "cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU5MDY3OA==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372590678", "bodyText": "Let me try that out.", "author": "wburns", "createdAt": "2020-01-29T19:39:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjUzOTg3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NTYzNg==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372545636", "bodyText": "-1, this is an eviction test and not a storage test.", "author": "danberindei", "createdAt": "2020-01-29T18:10:01Z", "path": "core/src/test/java/org/infinispan/expiration/impl/ClusterExpirationFunctionalTest.java", "diffHunk": "@@ -50,17 +54,37 @@\n \n    protected ConfigurationBuilder configurationBuilder;\n \n+   protected StorageType storageType;\n+\n+   protected ClusterExpirationFunctionalTest storageType(StorageType storageType) {\n+      this.storageType = storageType;\n+      return this;\n+   }\n+\n+   @Override\n+   protected String[] parameterNames() {\n+      return concat(super.parameterNames(), \"storageType\");\n+   }\n+\n+   @Override\n+   protected Object[] parameterValues() {\n+      return concat(super.parameterValues(), storageType);\n+   }\n+\n    @Override\n    public Object[] factory() {\n-      return new Object[] {\n-            new ClusterExpirationFunctionalTest().cacheMode(CacheMode.DIST_SYNC).transactional(true).lockingMode(LockingMode.OPTIMISTIC),\n-            new ClusterExpirationFunctionalTest().cacheMode(CacheMode.DIST_SYNC).transactional(true).lockingMode(LockingMode.PESSIMISTIC),\n-            new ClusterExpirationFunctionalTest().cacheMode(CacheMode.DIST_SYNC).transactional(false),\n-            new ClusterExpirationFunctionalTest().cacheMode(CacheMode.REPL_SYNC).transactional(true).lockingMode(LockingMode.OPTIMISTIC),\n-            new ClusterExpirationFunctionalTest().cacheMode(CacheMode.REPL_SYNC).transactional(true).lockingMode(LockingMode.PESSIMISTIC),\n-            new ClusterExpirationFunctionalTest().cacheMode(CacheMode.REPL_SYNC).transactional(false),\n-            new ClusterExpirationFunctionalTest().cacheMode(CacheMode.SCATTERED_SYNC).transactional(false),\n-      };\n+      return Arrays.stream(StorageType.values())", "originalCommit": "cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU4NzA0NA==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372587044", "bodyText": "Well it is an expiration test, which can work differently depending upon the storage type.", "author": "wburns", "createdAt": "2020-01-29T19:31:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NTYzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkyOTA2MQ==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372929061", "bodyText": "Different how? What's the difference between BINARY and OFF_HEAP, or between BINARY w/ DIST_SYNC and BINARY w/ REPL_SYNC, and do we need to test all locking modes for OBJECT, BINARY and OFF_HEAP?", "author": "danberindei", "createdAt": "2020-01-30T12:50:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NTYzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk2ODE3MQ==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372968171", "bodyText": "Well they work different for OFF_HEAP as it wasn't even working...\nI find that each of the locking modes has different ways of operating as well, I found that optimistic especially can work substantially different and has different intricacies with the storage.\nI agree that DIST_SYNC and REPL_SYNC in general shouldn't behave much different, so if we really wanted to we could remove those, but the different locking semantics are very important to test from what I have found.", "author": "wburns", "createdAt": "2020-01-30T14:08:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NTYzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDAyNDI3Mg==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r374024272", "bodyText": "Well they work different for OFF_HEAP as it wasn't even working...\n\nSure, there are some differences between BINARY and OFF_HEAP, but I don't understand how those differences could affect one of testLifespanExpiredOnPrimaryOwner vs. testLifespanExpiredOnBackupOwner vs. testLifespanExpiredOnBoth without affecting all of them.\nAnd of course there are differences between PESSIMISTIC and OPTIMISTIC locking, but are there any differences in PESSIMISTIC+BINARY vs. PESSIMISTIC+OFF_HEAP?\n\nI agree that DIST_SYNC and REPL_SYNC in general shouldn't behave much different\n\nAgain, I don't mind running some tests with REPL_SYNC as well, to show that the repl get optimization doesn't interfere with expiration. But I do mind running all the tests with all the storage types and all the locking modes, when the repl get optimization affects all of them in the same way.\nPerhaps you could split the tests in more classes, e.g. one with the tests that are affected by cache mode only, one with the tests that are affected by storage, and one with the tests that are affected by locking?", "author": "danberindei", "createdAt": "2020-02-03T10:25:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NTYzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDEyMjM0Ng==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r374122346", "bodyText": "Sure, there are some differences between BINARY and OFF_HEAP, but I don't understand how those differences could affect one of testLifespanExpiredOnPrimaryOwner vs. testLifespanExpiredOnBackupOwner vs. testLifespanExpiredOnBoth without affecting all of them.\n\nI have had tests where only a subset have failed.\n\nAnd of course there are differences between PESSIMISTIC and OPTIMISTIC locking, but are there any differences in PESSIMISTIC+BINARY vs. PESSIMISTIC+OFF_HEAP?\n\nI don't know, that is the beauty of adding a test for is that I know it is working for that scenario.\n\nAgain, I don't mind running some tests with REPL_SYNC as well, to show that the repl get optimization doesn't interfere with expiration.\n\nUnfortunately running a subset is not as simple as just adding one line. Do we want to go back to having different classes for the tests? Or do you want me to add a cache mode check at the beginning of each test we don't want to run (we still have startup time)?\n\nBut I do mind running all the tests with all the storage types and all the locking modes, when the repl get optimization affects all of them in the same way.\n\nIt doesn't, REPL read optimization does not work with transactions.\n\nPerhaps you could split the tests in more classes, e.g. one with the tests that are affected by cache mode only, one with the tests that are affected by storage, and one with the tests that are affected by locking?\n\nThis sounds like a step back to what we were doing before... which I am not a fan of and I thought were going away from. And tbh cherry picking tests that we think are only affected by a specific configuration sounds like a recipe for disaster. We could be wrong and there is nothing guaranteeing that assertion is true in the future (in which case we probably think we have coverage when we may not).", "author": "wburns", "createdAt": "2020-02-03T14:11:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NTYzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDU0NjQwNQ==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r374546405", "bodyText": "I have had tests where only a subset have failed.\n\nThat sounds to me like some DataContainer implementations are missing unit tests.\nExpiration should be able to rely on DataContainer working, and expiration tests should not have to be kept in sync with DataContainerFactory.construct() in order to test all the code paths in all the DataContainer implementations.\n\nI don't know, that is the beauty of adding a test for is that I know it is working for that scenario.\n\nYou have to stop at some point, if you want the test suite to finish in a reasonable time. In fact, you already did:\n\nClusterExpirationLoaderFunctionalTest only tests a small subset, how did you decide which combos to test with a loader? Why only with a DummyInMemoryStore and not with a SingleFileStore as well? Why are eviction and passivation always disabled?\nEven here, you're not testing a cache with eviction, and you're not testing DIST_ASYNC, REPL_ASYNC, INVALIDATION_SYNC, INVALIDATION_ASYNC. No useSynchronization(true), no lock striping, no L1, no encoding, no bias for scattered etc.\nYou have testMaxIdleNodeDies, but not testLifespanNodeDies. You test the node dying just before expiration, but you don't test it dying during expiration.\n\n\nUnfortunately running a subset is not as simple as just adding one line. Do we want to go back to having different classes for the tests?\n\nI never said it would be easy, I know it requires thinking hard about what features are really interlocked with each other and what features are (or should be) orthogonal.\nI don't want to go back to one class per cache mode either, because that style had the same problem: it's always easier to add a configuration and run all the existing tests, without considering whether how much that affects the test suite duration and whether they bring any value.\nBut I believe all the test methods in this class do not depend on the storage type, and that the DataContainer implementations should have their own tests that don't involve expiration or locking. In general, I believe it's impossible to test all the features with all possible configurations, so we must strive to test them independently as much as possible.", "author": "danberindei", "createdAt": "2020-02-04T09:04:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NTYzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY4MzU3Nw==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r374683577", "bodyText": "I have had tests where only a subset have failed.\n\nThat sounds to me like some DataContainer implementations are missing unit tests.\nExpiration should be able to rely on DataContainer working, and expiration tests should not have to be kept in sync with DataContainerFactory.construct() in order to test all the code paths in all the DataContainer implementations.\n\nI don't know, that is the beauty of adding a test for is that I know it is working for that scenario.\n\nYou have to stop at some point, if you want the test suite to finish in a reasonable time. In fact, you already did:\n\nClusterExpirationLoaderFunctionalTest only tests a small subset, how did you decide which combos to test with a loader? Why only with a DummyInMemoryStore and not with a SingleFileStore as well? Why are eviction and passivation always disabled?\nEven here, you're not testing a cache with eviction, and you're not testing DIST_ASYNC, REPL_ASYNC, INVALIDATION_SYNC, INVALIDATION_ASYNC. No useSynchronization(true), no lock striping, no L1, no encoding, no bias for scattered etc.\nYou have testMaxIdleNodeDies, but not testLifespanNodeDies. You test the node dying just before expiration, but you don't test it dying during expiration.\n\n\nUnfortunately running a subset is not as simple as just adding one line. Do we want to go back to having different classes for the tests?\n\nI never said it would be easy, I know it requires thinking hard about what features are really interlocked with each other and what features are (or should be) orthogonal.\nI don't want to go back to one class per cache mode either, because that style had the same problem: it's always easier to add a configuration and run all the existing tests, without considering whether how much that affects the test suite duration and whether they bring any value.\nBut I believe all the test methods in this class do not depend on the storage type, and that the DataContainer implementations should have their own tests that don't involve expiration or locking. In general, I believe it's impossible to test all the features with all possible configurations, so we must strive to test them independently as much as possible.\n\nWell I am glad you have infinite time to figure out every possible variant and isolate them to their own test classes. I however do not and am not going to change the tests here. I have been burned way too many times by not having more combinations, not less (and I am pretty sure everyone else can probably agree with that). If you want you can make the changes to the tests, but until then we won't have max idle working for off heap and it won't be making it into 9.4.x anytime soon I guess.", "author": "wburns", "createdAt": "2020-02-04T13:56:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NTYzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY4OTIwOQ==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r374689209", "bodyText": "And no offense but stuff like this is one of the reasons why we have PRs sitting in review purgatory for so long. This is a working fix and implementation (resolves other issues on CI btw) and tests cases. If you have such a strong objection I would say you should just create a separate JIRA and integrate this. Going back and forth on something that is working, especially the actual implementation, and complaint about how the tests should be reduced is a bit beyond me.\nThe test now takes 16s instead of 11s according to the difference on master and no difference in total runtime of the test suite.", "author": "wburns", "createdAt": "2020-02-04T14:07:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NTYzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY5NTIzNQ==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r374695235", "bodyText": "Even here, you're not testing a cache with eviction, and you're not testing DIST_ASYNC, REPL_ASYNC, INVALIDATION_SYNC, INVALIDATION_ASYNC. No useSynchronization(true), no lock striping, no L1, no encoding, no bias for scattered etc.\n\n\nASYNC would not work in such a test as these rely on synchronous behavior.\nInvalidation doesn't work here either as the ownership doesn't make as much sense, tbh max idle probably doesn't work at all with INVALIDATION :)\nThe useSynchronization case could probably be added here, sure.\nLock striping is that even a supported feature? I thought we were getting rid of it.\nDoes anyone even use L1 nowadays? I feel like it is another one of those features we should kill.\nEncoding, we technically cover parts of that with OFF_HEAP and BINARY. But sure we can add that if you want.\nIt should be pretty simple to add another option for bias for scattered cache too (just 1 line of code)\n\nEither way one of the disconnects it that you and I see StorageType a bit differently. StorageType is so closely intertwined with all the other features, it isn't just a DataContainer test. Many features work completely different with BINARY as they do OFF_HEAP and even more so with OBJECT. For example Query has specific logic for them (which is another PR that you have shut down and I don't want to work on because of the exact same reason of nitpicking tests). And obviously expiration works different for them. Especially as we move forward I feel that OFF_HEAP will become more and more and more and more prominent and in fact it already is in some cases (e.g. openshift). And adding its support to the functional tests seems exactly what it needs. Unless you somehow think that testing OFF_HEAP with expiration in a LOCAL cache will catch all the issues?", "author": "wburns", "createdAt": "2020-02-04T14:17:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NTYzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDc0MzI4Mg==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r374743282", "bodyText": "The test now takes 16s instead of 11s according to the difference on master and no difference in total runtime of the test suite.\n\nOk, I know it's my fault I run with trace logging enabled, but with the latest changes it takes 50s for me (it was 75s with REPL_SYNC).\n\nStorageType is so closely intertwined with all the other features, it isn't just a DataContainer test. Many features work completely different with BINARY as they do OFF_HEAP and even more so with OBJECT.\n\nThat pretty much sums up my concerns. What's so special about StorageType that we can't isolate it and we have to add new tests to every other feature for every StorageType?\n\nFor example Query has specific logic for them (which is another PR that you have shut down and I don't want to work on because of the exact same reason of nitpicking tests).\n\nNo, query does not have specific logic for other storage types. Query relies on a feature of core, WrappedBytes, which was implemented incorrectly (instanceof WrappedBytesArray instead of instanceof WrappedBytes). There is still no test for WrappedBytes in core, so we can't know whether that feature works without running the query tests.\n\nIt should be pretty simple to add another option for bias for scattered cache too (just 1 line of code)\n\nI guess my comment backfired... I was trying to prove to you that you can never run all possible configs, instead you have to exercise your judgement to decide what to test.\nI'm not going to delay integrating this PR any more, but I really feel that StorageTypes shouldn't hide behind other features any more: we should properly define an \"internal API\" for container storage, and we should have tests exercising this internal API instead of only tests exercising OFF_HEAP+something or BINARY+something.", "author": "danberindei", "createdAt": "2020-02-04T15:32:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0NTYzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0ODI3OQ==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372548279", "bodyText": "IMO MagicKey could do it, but instead of computing a hashCode and always returning it, it needs to generate a random value so that the hash of the serialized form has the required owners.", "author": "danberindei", "createdAt": "2020-01-29T18:15:31Z", "path": "core/src/test/java/org/infinispan/expiration/impl/ClusterExpirationFunctionalTest.java", "diffHunk": "@@ -139,16 +164,40 @@ private void testLifespanExpiredEntryRetrieval(Cache<Object, String> primaryOwne\n       }\n    }\n \n-   private MagicKey createKey(Cache<Object, String> primaryOwner, Cache<Object, String> backupOwner) {\n-      if (cacheMode.isScattered()) {\n-         return new MagicKey(primaryOwner);\n+   private Object createKey(Cache<Object, String> primaryOwner, Cache<Object, String> backupOwner) {\n+      if (storageType == StorageType.OBJECT) {\n+         if (cacheMode.isScattered()) {\n+            return new MagicKey(primaryOwner);\n+         } else {\n+            return new MagicKey(primaryOwner, backupOwner);\n+         }\n       } else {\n-         return new MagicKey(primaryOwner, backupOwner);\n+         // BINARY and OFF heap can't use MagicKey as they are serialized", "originalCommit": "cb809a55be517e2fe8172ee9b9fa7fd0dcb7bf06", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU4NzY4MA==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372587680", "bodyText": "Yes, I would have to create a MagicKey that when serialized mapped to the appropriate owners. It seemed better to not rely upon that and just use a simple number.", "author": "wburns", "createdAt": "2020-01-29T19:33:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0ODI3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjkzNDk1OA==", "url": "https://github.com/infinispan/infinispan/pull/7775#discussion_r372934958", "bodyText": "Ok", "author": "danberindei", "createdAt": "2020-01-30T13:04:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU0ODI3OQ=="}], "type": "inlineReview"}, {"oid": "61f75625c07d8b8c45332282999030b4d0c8098d", "url": "https://github.com/infinispan/infinispan/commit/61f75625c07d8b8c45332282999030b4d0c8098d", "message": "ISPN-9082 Off Heap maxIdle expiration works like lifespan", "committedDate": "2020-01-30T14:23:33Z", "type": "commit"}, {"oid": "0309bf41bc84451836853a95f4fda22f02704c1b", "url": "https://github.com/infinispan/infinispan/commit/0309bf41bc84451836853a95f4fda22f02704c1b", "message": "ISPN-11204 Response Collector addResponse value can be ignored", "committedDate": "2020-01-30T14:23:33Z", "type": "commit"}, {"oid": "0309bf41bc84451836853a95f4fda22f02704c1b", "url": "https://github.com/infinispan/infinispan/commit/0309bf41bc84451836853a95f4fda22f02704c1b", "message": "ISPN-11204 Response Collector addResponse value can be ignored", "committedDate": "2020-01-30T14:23:33Z", "type": "forcePushed"}]}