{"pr_number": 8072, "pr_title": "ISPN-11299 Stale values can be indexed during State Transfer", "pr_createdAt": "2020-03-20T11:45:37Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8072", "timeline": [{"oid": "9f35cbaaa37dff173730437f13387b0033f8cd74", "url": "https://github.com/infinispan/infinispan/commit/9f35cbaaa37dff173730437f13387b0033f8cd74", "message": "ISPN-11299 Stale values can be indexed during State Transfer", "committedDate": "2020-03-26T11:54:30Z", "type": "forcePushed"}, {"oid": "8d833fe4f4897918083868c93807d3f809a9a5f3", "url": "https://github.com/infinispan/infinispan/commit/8d833fe4f4897918083868c93807d3f809a9a5f3", "message": "ISPN-11299 Stale values can be indexed during State Transfer", "committedDate": "2020-05-19T10:32:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxNTYyOQ==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427215629", "bodyText": "I think you need to move the oldMetadata to ReadCommittedEntry", "author": "pruivo", "createdAt": "2020-05-19T11:03:35Z", "path": "core/src/main/java/org/infinispan/container/entries/RepeatableReadEntry.java", "diffHunk": "@@ -17,12 +17,10 @@\n    private static final boolean trace = log.isTraceEnabled();\n \n    /* Value before the last modification. Serves as the previous value when the operation is retried */\n-   protected Object oldValue;\n    protected Metadata oldMetadata;\n \n    public RepeatableReadEntry(Object key, Object value, Metadata metadata) {\n       super(key, value, metadata);\n-      this.oldValue = value;\n       this.oldMetadata = metadata;", "originalCommit": "8d833fe4f4897918083868c93807d3f809a9a5f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM1MTQzMg==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427351432", "bodyText": "moved", "author": "gustavonalle", "createdAt": "2020-05-19T14:34:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxNTYyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxNTg4Ng==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427215886", "bodyText": "missing committed\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        log.tracef(\"Updating entry (key=%s removed=%s changed=%s created=%s value=%s metadata=%s)\",\n          \n          \n            \n                        log.tracef(\"Updating entry (key=%s removed=%s changed=%s created=%s committed=%s value=%s metadata=%s)\",", "author": "pruivo", "createdAt": "2020-05-19T11:04:06Z", "path": "core/src/main/java/org/infinispan/container/entries/ReadCommittedEntry.java", "diffHunk": "@@ -157,7 +167,7 @@ private boolean shouldCommit() {\n       if (isChanged()) {\n          if (trace)\n             log.tracef(\"Updating entry (key=%s removed=%s changed=%s created=%s value=%s metadata=%s)\",", "originalCommit": "8d833fe4f4897918083868c93807d3f809a9a5f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMwMjc2Nw==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427302767", "bodyText": "fixed", "author": "gustavonalle", "createdAt": "2020-05-19T13:29:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxNTg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxODIxNg==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427218216", "bodyText": "I'm not sure if I agree with this change. if we have a case where setValue() is invoked multiple times, I would rather return \"prev\" than \"oldValue\".", "author": "pruivo", "createdAt": "2020-05-19T11:08:20Z", "path": "core/src/main/java/org/infinispan/container/entries/ReadCommittedEntry.java", "diffHunk": "@@ -196,9 +206,8 @@ public long getLastUsed() {\n \n    @Override\n    public Object setValue(Object value) {\n-      Object prev = this.value;\n       this.value = value;\n-      return prev;\n+      return oldValue;", "originalCommit": "8d833fe4f4897918083868c93807d3f809a9a5f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIyMjIzNg==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427222236", "bodyText": "right, this should have a test, what scenario causes setValue() to be invoked multiple times?", "author": "gustavonalle", "createdAt": "2020-05-19T11:15:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxODIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI3MzUzMA==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427273530", "bodyText": "It seems it is only ever called once, but I agree with you, it should not simply keep returning  the same oldValue...", "author": "gustavonalle", "createdAt": "2020-05-19T12:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxODIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMwMjg2Mg==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427302862", "bodyText": "fixed", "author": "gustavonalle", "createdAt": "2020-05-19T13:30:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxODIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM0Mjg5OA==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427342898", "bodyText": "AFAICT CallInterceptor.performPut() is the only caller that uses the return value, and it expects it to be prev (because the 2nd put in the same tx should return the value set by the 1st put.", "author": "danberindei", "createdAt": "2020-05-19T14:24:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxODIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0OTY4NQ==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427849685", "bodyText": "Sorry, I am confused now: which prev should I return? The initial value when the ReadCommittedEntry was created, or the value it had before the change(s)?", "author": "gustavonalle", "createdAt": "2020-05-20T08:56:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxODIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg2NTc2OQ==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427865769", "bodyText": "It seems the idea is to keep the initial value when the RCE was created, and always return it, regardless of how many times setValue() is called. So oldValue is more like a initialValue. Since we only ever call setValue() once, I think it makes no difference from the testsuite's POV", "author": "gustavonalle", "createdAt": "2020-05-20T09:21:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxODIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg5NjIwMg==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427896202", "bodyText": "@gustavonalle IMO, add a test in org.infinispan.api.CacheAPITest that tests write to the same key in the same tx:\ntm.begin\nassert cache.put(k, v1) == null;\nassert cache.put(k, v2) == v1;\nassert cache.put(k, v3) == v2\ntm.commit\n\nthen you can tune the \"old value\" field to your use case.\nAFAIK, tx never retries in the originator and remotely, it cleanups the context before replaying the transaction writes.", "author": "pruivo", "createdAt": "2020-05-20T10:12:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxODIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk4OTY2OA==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427989668", "bodyText": "I've added the test and also reverted the changes in setValue, keeping the same as master", "author": "gustavonalle", "createdAt": "2020-05-20T13:01:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIxODIxNg=="}], "type": "inlineReview"}, {"oid": "faf3b801d592f991f4ded689e20da811375e1527", "url": "https://github.com/infinispan/infinispan/commit/faf3b801d592f991f4ded689e20da811375e1527", "message": "ISPN-11299 Stale values can be indexed during State Transfer", "committedDate": "2020-05-19T13:29:27Z", "type": "forcePushed"}, {"oid": "94a38ee74572b1f7e99a3ba25bf375bffd16553a", "url": "https://github.com/infinispan/infinispan/commit/94a38ee74572b1f7e99a3ba25bf375bffd16553a", "message": "ISPN-11299 Stale values can be indexed during State Transfer", "committedDate": "2020-05-19T14:33:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMwMTI2Ng==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427301266", "bodyText": "Why not call setCommitted() immediately after shouldCommit()?", "author": "danberindei", "createdAt": "2020-05-19T13:27:57Z", "path": "core/src/main/java/org/infinispan/container/entries/ReadCommittedEntry.java", "diffHunk": "@@ -143,11 +149,15 @@ public final void commit(DataContainer container) {\n       // only do stuff if there are changes.\n       if (shouldCommit()) {\n          if (isEvicted()) {\n-            return container.evict(segment, key);\n+            CompletionStage<Void> evict = container.evict(segment, key);\n+            setCommitted();", "originalCommit": "8d833fe4f4897918083868c93807d3f809a9a5f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkwNzA0NA==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427907044", "bodyText": "changed", "author": "gustavonalle", "createdAt": "2020-05-20T10:32:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzMwMTI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM1MTI3Ng==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427351276", "bodyText": "Needs javadoc, is this the value at the start of the transaction/operation, or is it supposed to be updated after every operation on this entry in the tx or after every retry that invokes setValue()?", "author": "danberindei", "createdAt": "2020-05-19T14:33:58Z", "path": "core/src/main/java/org/infinispan/container/entries/ReadCommittedEntry.java", "diffHunk": "@@ -115,6 +117,10 @@ public final Object getValue() {\n       return value;\n    }\n \n+   public Object getOldValue() {", "originalCommit": "faf3b801d592f991f4ded689e20da811375e1527", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ3OTA4Ng==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427479086", "bodyText": "I would say it is the current value stored in DataContainer when you access it for the first time.", "author": "pruivo", "createdAt": "2020-05-19T17:34:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM1MTI3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg2ODU1MQ==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427868551", "bodyText": "The oldValue was promoted from RepeatableReadEntry and it says\nValue before the last modification. Serves as the previous value when the operation is retried\nIf you agree with it, I will bring it to this method", "author": "gustavonalle", "createdAt": "2020-05-20T09:26:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM1MTI3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3NDI2OA==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r428274268", "bodyText": "I'm fine with it, but is that what you need for the query interceptor? Don't you need the value that was in the data container when you first read the key, like Pedro said?\nEdit: I just read the other comment thread and I guess that javadoc is not correct (was never correct?), oldValue is the value before the first modification. I'm pretty sure it's not used when the command is retried in non-tx dist caches, but it may be used when a tx prepare is replayed on a remote node, or in scattered mode, so I can't say whether it's ok to keep the 2nd sentence or not.", "author": "danberindei", "createdAt": "2020-05-20T20:01:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM1MTI3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ3NDIxMA==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r428474210", "bodyText": "Don't you need the value that was in the data container when you first read the key,\n\nYes, that's pretty much it", "author": "gustavonalle", "createdAt": "2020-05-21T06:42:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM1MTI3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODQ3NTQ2MA==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r428475460", "bodyText": "In RepeatableReadEntry oldValue behaves like the initialValue. There's also a method to update it: updatePreviousValue", "author": "gustavonalle", "createdAt": "2020-05-21T06:46:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM1MTI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM1MjY2MA==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427352660", "bodyText": "Not sure how this is supposed to work when a tx writes to the same key 2 times, 3 times, etc. Personally I'd prefer an explicit update of oldValue and setValue always returning the current value (aka this.value) -- something CallInterceptor.performPut() already does?\nAt least the entry is removed from the context when a command is retried, so you don't have to worry about non-tx caches.", "author": "danberindei", "createdAt": "2020-05-19T14:35:41Z", "path": "core/src/main/java/org/infinispan/container/entries/ReadCommittedEntry.java", "diffHunk": "@@ -195,9 +213,10 @@ public long getLastUsed() {\n    }\n \n    @Override\n-   public Object setValue(Object value) {\n-      Object prev = this.value;\n-      this.value = value;\n+   public Object setValue(Object newValue) {\n+      Object prev = oldValue;\n+      this.oldValue = this.value;\n+      this.value = newValue;", "originalCommit": "94a38ee74572b1f7e99a3ba25bf375bffd16553a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4MDg1OA==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427480858", "bodyText": "hmmm... I wasn't expecting the \"old value\" to be updated every time.", "author": "pruivo", "createdAt": "2020-05-19T17:37:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM1MjY2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk4OTg1Mw==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427989853", "bodyText": "reverted", "author": "gustavonalle", "createdAt": "2020-05-20T13:01:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM1MjY2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM2ODIxOQ==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427368219", "bodyText": "I'd do it without the AtomicInteger\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        countPerEntity.computeIfAbsent(entity, aClass -> new AtomicInteger(0)).incrementAndGet();\n          \n          \n            \n                        countPerEntity.merge(entity, 1, Integer::sum);", "author": "danberindei", "createdAt": "2020-05-19T14:54:53Z", "path": "query/src/test/java/org/infinispan/query/blackbox/IndexingDuringStateTransferTest.java", "diffHunk": "@@ -214,4 +228,21 @@ private void test(Consumer<Cache<Object, Object>> op, Consumer<SearchManager> ch\n    private void assertFluffyIndexed(SearchManager sm) {\n       assertEquals(Collections.singletonList(FLUFFY), queryAll(sm, AnotherGrassEater.class));\n    }\n+\n+   private void waitForIndexSynced() {\n+      List<Cache<String, Object>> caches = caches();\n+      caches.forEach(c -> {\n+         SearchManager sm = Search.getSearchManager(c);\n+         DataContainer<String, Object> dataContainer = c.getAdvancedCache().getDataContainer();\n+         Map<Class<?>, AtomicInteger> countPerEntity = new HashMap<>();\n+         dataContainer.forEach(e -> {\n+            Class<?> entity = e.getValue().getClass();\n+            countPerEntity.computeIfAbsent(entity, aClass -> new AtomicInteger(0)).incrementAndGet();", "originalCommit": "94a38ee74572b1f7e99a3ba25bf375bffd16553a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg2MjE2Nw==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427862167", "bodyText": "right, looks better your way", "author": "gustavonalle", "createdAt": "2020-05-20T09:16:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM2ODIxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkwNzE1MQ==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r427907151", "bodyText": "changed", "author": "gustavonalle", "createdAt": "2020-05-20T10:32:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM2ODIxOQ=="}], "type": "inlineReview"}, {"oid": "827003297a8b8f617f0d64e106e03bc157126e4f", "url": "https://github.com/infinispan/infinispan/commit/827003297a8b8f617f0d64e106e03bc157126e4f", "message": "ISPN-11299 Stale values can be indexed during State Transfer", "committedDate": "2020-05-20T10:19:53Z", "type": "forcePushed"}, {"oid": "889ae26b4de2045c05252e62c564edc6f1bd747a", "url": "https://github.com/infinispan/infinispan/commit/889ae26b4de2045c05252e62c564edc6f1bd747a", "message": "ISPN-11299 Stale values can be indexed during State Transfer", "committedDate": "2020-05-20T12:58:43Z", "type": "forcePushed"}, {"oid": "1f2172847bf7c24aa2eda91286b06a87d57974e9", "url": "https://github.com/infinispan/infinispan/commit/1f2172847bf7c24aa2eda91286b06a87d57974e9", "message": "wip", "committedDate": "2021-03-05T17:40:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTA1Mjg5Mw==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r595052893", "bodyText": "since processChange() returns a CompletionStage, you can change indexIfNeeded() to return the CompletionStage and void using the BlockingManager.", "author": "pruivo", "createdAt": "2021-03-16T10:46:21Z", "path": "query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java", "diffHunk": "@@ -145,77 +145,79 @@ private Object handleDataWriteCommand(InvocationContext ctx, DataWriteCommand co\n       if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n       }\n-      CacheEntry entry = ctx.lookupEntry(command.getKey());\n-      if (ctx.isInTxScope()) {\n-         // replay of modifications on remote node by EntryWrappingVisitor\n-         if (entry != null && !entry.isChanged() && (entry.getValue() != null || !unreliablePreviousValue(command))) {\n-            Map<Object, Object> oldValues = registerOldValues((TxInvocationContext) ctx);\n-            oldValues.putIfAbsent(command.getKey(), entry.getValue());\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return rv;\n          }\n+         boolean unreliablePrevious = unreliablePreviousValue(command);\n+         if (ctx.isInTxScope()) {\n+            Map<Object, Object> oldValues = getOldValuesMap((TxInvocationContext<?>) ctx);\n+            registerOldValue(ctx, command.getKey(), unreliablePrevious, oldValues);\n+         } else {\n+            // TODO: need to reduce the scope of the blocking thread to less if possible later as part of\n+            // https://issues.redhat.com/browse/ISPN-11731\n+            return asyncValue(blockingManager.runBlocking(() -> indexIfNeeded(rCtx, cmd, unreliablePrevious, cmd.getKey()), cmd)", "originalCommit": "1f2172847bf7c24aa2eda91286b06a87d57974e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTA5NDk5MA==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r595094990", "bodyText": "makes sense @pruivo , thanks", "author": "gustavonalle", "createdAt": "2021-03-16T11:49:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTA1Mjg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTA1MzYwOQ==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r595053609", "bodyText": "lambda here and in handleManyWriteCommand() are \"the same\". you could cache it and use it in both places.", "author": "pruivo", "createdAt": "2021-03-16T10:47:16Z", "path": "query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java", "diffHunk": "@@ -145,77 +145,79 @@ private Object handleDataWriteCommand(InvocationContext ctx, DataWriteCommand co\n       if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n       }\n-      CacheEntry entry = ctx.lookupEntry(command.getKey());\n-      if (ctx.isInTxScope()) {\n-         // replay of modifications on remote node by EntryWrappingVisitor\n-         if (entry != null && !entry.isChanged() && (entry.getValue() != null || !unreliablePreviousValue(command))) {\n-            Map<Object, Object> oldValues = registerOldValues((TxInvocationContext) ctx);\n-            oldValues.putIfAbsent(command.getKey(), entry.getValue());\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {", "originalCommit": "1f2172847bf7c24aa2eda91286b06a87d57974e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzYwOTg2OA==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r597609868", "bodyText": "They are not quite the same: one uses single values the other multiple values, one use WriteCommand and the other DataWriteCommand, how do you suggest to reuse them?", "author": "gustavonalle", "createdAt": "2021-03-19T11:36:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTA1MzYwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzcyMjYzNg==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r597722636", "bodyText": "DataWriteCommand is a subclass of WriteCommand.\nCreating a method like updateIndexes(InvocationContext ctx, WriteCommand cmd, Object rv) and you can use it in invokeNextThenApply() method.", "author": "pruivo", "createdAt": "2021-03-19T14:28:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTA1MzYwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzc3NDAyNw==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r597774027", "bodyText": "Not all WriteCommand are DataCommads and expose getKey(), so I'd need to treat all commands as \"multiple keys\" command and put some conditions to avoid extra allocations and work, I think I gave up after 5min into the refactor :)", "author": "gustavonalle", "createdAt": "2021-03-19T15:31:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTA1MzYwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5Nzc4NTg2MA==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r597785860", "bodyText": "ok. I had something like this in mind: pruivo@627bb42", "author": "pruivo", "createdAt": "2021-03-19T15:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTA1MzYwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzgwOTM2Ng==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r597809366", "bodyText": "@pruivo could you please send a follow up PR, after this one is merged?", "author": "gustavonalle", "createdAt": "2021-03-19T16:19:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTA1MzYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTA1NDcyOA==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r595054728", "bodyText": "actually, you aren't waiting for the index to complete. maybe it is the source of your issues? I just notice you never wait on processChange() CompletableFuture", "author": "pruivo", "createdAt": "2021-03-16T10:48:41Z", "path": "query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java", "diffHunk": "@@ -145,77 +145,79 @@ private Object handleDataWriteCommand(InvocationContext ctx, DataWriteCommand co\n       if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n       }\n-      CacheEntry entry = ctx.lookupEntry(command.getKey());\n-      if (ctx.isInTxScope()) {\n-         // replay of modifications on remote node by EntryWrappingVisitor\n-         if (entry != null && !entry.isChanged() && (entry.getValue() != null || !unreliablePreviousValue(command))) {\n-            Map<Object, Object> oldValues = registerOldValues((TxInvocationContext) ctx);\n-            oldValues.putIfAbsent(command.getKey(), entry.getValue());\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return rv;\n          }\n+         boolean unreliablePrevious = unreliablePreviousValue(command);\n+         if (ctx.isInTxScope()) {\n+            Map<Object, Object> oldValues = getOldValuesMap((TxInvocationContext<?>) ctx);\n+            registerOldValue(ctx, command.getKey(), unreliablePrevious, oldValues);\n+         } else {\n+            // TODO: need to reduce the scope of the blocking thread to less if possible later as part of\n+            // https://issues.redhat.com/browse/ISPN-11731\n+            return asyncValue(blockingManager.runBlocking(() -> indexIfNeeded(rCtx, cmd, unreliablePrevious, cmd.getKey()), cmd)\n+                  .thenApply(ignore -> rv));\n+         }\n+         return rv;\n+      });\n+   }\n+\n+   private Object handleManyWriteCommand(InvocationContext ctx, WriteCommand command) {\n+      if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n-      } else {\n-         Object prev = entry != null ? entry.getValue() : UNKNOWN;\n-         if (prev == null && unreliablePreviousValue(command)) {\n-            prev = UNKNOWN;\n+      }\n+      return invokeNextThenAccept(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return;\n          }\n-         Object oldValue = prev;\n-         return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n-            if (!cmd.isSuccessful()) {\n-               return rv;\n+         boolean unreliablePrevious = unreliablePreviousValue(command);\n+         if (ctx.isInTxScope()) {\n+            Map<Object, Object> oldValues = getOldValuesMap((TxInvocationContext<?>) ctx);\n+            for (Object key : command.getAffectedKeys()) {\n+               registerOldValue(ctx, key, unreliablePrevious, oldValues);\n             }\n-            CacheEntry entry2 = entry != null ? entry : rCtx.lookupEntry(cmd.getKey());\n-            if (entry2 != null && entry2.isChanged()) {\n-               // TODO: need to reduce the scope of the blocking thread to less if possible later as part of\n-               // https://issues.redhat.com/browse/ISPN-11731\n-               return asyncValue(processChange(rCtx, cmd, cmd.getKey(), oldValue, entry2.getValue())\n-                     .thenApply(ignore -> rv));\n+         } else {\n+            for (Object key : cmd.getAffectedKeys()) {\n+               indexIfNeeded(rCtx, cmd, unreliablePrevious, key);", "originalCommit": "1f2172847bf7c24aa2eda91286b06a87d57974e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTA5ODkwOQ==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r595098909", "bodyText": "yes, it's not waiting here and in the other place it is called. I fix it yesterday but still getting errors, I am debugging now, thanks for the help @pruivo", "author": "gustavonalle", "createdAt": "2021-03-16T11:55:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NTA1NDcyOA=="}], "type": "inlineReview"}, {"oid": "8b59e2607fb13db97010e10a9efa7cedb33ae0df", "url": "https://github.com/infinispan/infinispan/commit/8b59e2607fb13db97010e10a9efa7cedb33ae0df", "message": "ISPN-11299 Stale values can be indexed during State Transfer", "committedDate": "2021-03-17T17:39:25Z", "type": "forcePushed"}, {"oid": "59d322420ca091e9a7bd0aac4195db9e85da6865", "url": "https://github.com/infinispan/infinispan/commit/59d322420ca091e9a7bd0aac4195db9e85da6865", "message": "ISPN-11299 Stale values can be indexed during State Transfer", "committedDate": "2021-03-17T17:41:08Z", "type": "forcePushed"}, {"oid": "71e05019f291a12ed6c7284feaca8c8ac0c4b118", "url": "https://github.com/infinispan/infinispan/commit/71e05019f291a12ed6c7284feaca8c8ac0c4b118", "message": "ISPN-11299 Stale values can be indexed during State Transfer", "committedDate": "2021-03-18T15:50:15Z", "type": "forcePushed"}, {"oid": "239da3e1d4e73602159a55cc5cd561f862e295e0", "url": "https://github.com/infinispan/infinispan/commit/239da3e1d4e73602159a55cc5cd561f862e295e0", "message": "ISPN-11299 Stale values can be indexed during State Transfer", "committedDate": "2021-03-18T21:27:49Z", "type": "forcePushed"}, {"oid": "4a1d43ae5e377defef471bb892e95b624010d22d", "url": "https://github.com/infinispan/infinispan/commit/4a1d43ae5e377defef471bb892e95b624010d22d", "message": "ISPN-11299 Stale values can be indexed during State Transfer", "committedDate": "2021-03-19T00:14:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODUzNzI5MQ==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r598537291", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                     boolean unreliablePrevious = unreliablePreviousValue(command);\n          \n          \n            \n                     boolean unreliablePrevious = unreliablePreviousValue(cmd);", "author": "pruivo", "createdAt": "2021-03-22T09:12:49Z", "path": "query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java", "diffHunk": "@@ -145,78 +147,77 @@ private Object handleDataWriteCommand(InvocationContext ctx, DataWriteCommand co\n       if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n       }\n-      CacheEntry entry = ctx.lookupEntry(command.getKey());\n-      if (ctx.isInTxScope()) {\n-         // replay of modifications on remote node by EntryWrappingVisitor\n-         if (entry != null && !entry.isChanged() && (entry.getValue() != null || !unreliablePreviousValue(command))) {\n-            Map<Object, Object> oldValues = registerOldValues((TxInvocationContext) ctx);\n-            oldValues.putIfAbsent(command.getKey(), entry.getValue());\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return rv;\n+         }\n+         boolean unreliablePrevious = unreliablePreviousValue(command);", "originalCommit": "4a1d43ae5e377defef471bb892e95b624010d22d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODc0MDM5Mw==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r598740393", "bodyText": "fixed", "author": "gustavonalle", "createdAt": "2021-03-22T14:00:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODUzNzI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODUzNzczMw==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r598537733", "bodyText": "sed command => cmd\nsed ctx => rCtx", "author": "pruivo", "createdAt": "2021-03-22T09:13:28Z", "path": "query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java", "diffHunk": "@@ -145,78 +147,77 @@ private Object handleDataWriteCommand(InvocationContext ctx, DataWriteCommand co\n       if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n       }\n-      CacheEntry entry = ctx.lookupEntry(command.getKey());\n-      if (ctx.isInTxScope()) {\n-         // replay of modifications on remote node by EntryWrappingVisitor\n-         if (entry != null && !entry.isChanged() && (entry.getValue() != null || !unreliablePreviousValue(command))) {\n-            Map<Object, Object> oldValues = registerOldValues((TxInvocationContext) ctx);\n-            oldValues.putIfAbsent(command.getKey(), entry.getValue());\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return rv;\n+         }\n+         boolean unreliablePrevious = unreliablePreviousValue(command);\n+         if (ctx.isInTxScope()) {\n+            Map<Object, Object> oldValues = getOldValuesMap((TxInvocationContext<?>) ctx);\n+            registerOldValue(ctx, command.getKey(), unreliablePrevious, oldValues);", "originalCommit": "4a1d43ae5e377defef471bb892e95b624010d22d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODc0MDY0OQ==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r598740649", "bodyText": "fixed the rest too", "author": "gustavonalle", "createdAt": "2021-03-22T14:00:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODUzNzczMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODUzODQ5Mw==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r598538493", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return asyncValue(indexIfNeeded(rCtx, cmd, unreliablePrevious, cmd.getKey()).thenApply(ignored -> rv));\n          \n          \n            \n                        return delayedValue(indexIfNeeded(rCtx, cmd, unreliablePrevious, cmd.getKey()), rv);", "author": "pruivo", "createdAt": "2021-03-22T09:14:32Z", "path": "query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java", "diffHunk": "@@ -145,78 +147,77 @@ private Object handleDataWriteCommand(InvocationContext ctx, DataWriteCommand co\n       if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n       }\n-      CacheEntry entry = ctx.lookupEntry(command.getKey());\n-      if (ctx.isInTxScope()) {\n-         // replay of modifications on remote node by EntryWrappingVisitor\n-         if (entry != null && !entry.isChanged() && (entry.getValue() != null || !unreliablePreviousValue(command))) {\n-            Map<Object, Object> oldValues = registerOldValues((TxInvocationContext) ctx);\n-            oldValues.putIfAbsent(command.getKey(), entry.getValue());\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return rv;\n+         }\n+         boolean unreliablePrevious = unreliablePreviousValue(command);\n+         if (ctx.isInTxScope()) {\n+            Map<Object, Object> oldValues = getOldValuesMap((TxInvocationContext<?>) ctx);\n+            registerOldValue(ctx, command.getKey(), unreliablePrevious, oldValues);\n+         } else {\n+            return asyncValue(indexIfNeeded(rCtx, cmd, unreliablePrevious, cmd.getKey()).thenApply(ignored -> rv));", "originalCommit": "4a1d43ae5e377defef471bb892e95b624010d22d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODUzOTIzNQ==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r598539235", "bodyText": "sed command => cmd\nsed ctx => rCtx", "author": "pruivo", "createdAt": "2021-03-22T09:15:31Z", "path": "query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java", "diffHunk": "@@ -145,78 +147,77 @@ private Object handleDataWriteCommand(InvocationContext ctx, DataWriteCommand co\n       if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n       }\n-      CacheEntry entry = ctx.lookupEntry(command.getKey());\n-      if (ctx.isInTxScope()) {\n-         // replay of modifications on remote node by EntryWrappingVisitor\n-         if (entry != null && !entry.isChanged() && (entry.getValue() != null || !unreliablePreviousValue(command))) {\n-            Map<Object, Object> oldValues = registerOldValues((TxInvocationContext) ctx);\n-            oldValues.putIfAbsent(command.getKey(), entry.getValue());\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return rv;\n+         }\n+         boolean unreliablePrevious = unreliablePreviousValue(command);\n+         if (ctx.isInTxScope()) {\n+            Map<Object, Object> oldValues = getOldValuesMap((TxInvocationContext<?>) ctx);\n+            registerOldValue(ctx, command.getKey(), unreliablePrevious, oldValues);\n+         } else {\n+            return asyncValue(indexIfNeeded(rCtx, cmd, unreliablePrevious, cmd.getKey()).thenApply(ignored -> rv));\n          }\n+         return rv;\n+      });\n+   }\n+\n+   private Object handleManyWriteCommand(InvocationContext ctx, WriteCommand command) {\n+      if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n-      } else {\n-         Object prev = entry != null ? entry.getValue() : UNKNOWN;\n-         if (prev == null && unreliablePreviousValue(command)) {\n-            prev = UNKNOWN;\n+      }\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return rv;\n          }\n-         Object oldValue = prev;\n-         return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n-            if (!cmd.isSuccessful()) {\n-               return rv;\n-            }\n-            CacheEntry entry2 = entry != null ? entry : rCtx.lookupEntry(cmd.getKey());\n-            if (entry2 != null && entry2.isChanged()) {\n-               // TODO: need to reduce the scope of the blocking thread to less if possible later as part of\n-               // https://issues.redhat.com/browse/ISPN-11731\n-               return asyncValue(processChange(rCtx, cmd, cmd.getKey(), oldValue, entry2.getValue())\n-                     .thenApply(ignore -> rv));\n+         boolean unreliablePrevious = unreliablePreviousValue(command);\n+         if (ctx.isInTxScope()) {\n+            Map<Object, Object> oldValues = getOldValuesMap((TxInvocationContext<?>) ctx);\n+            for (Object key : command.getAffectedKeys()) {\n+               registerOldValue(ctx, key, unreliablePrevious, oldValues);", "originalCommit": "4a1d43ae5e377defef471bb892e95b624010d22d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODU0MDY0NA==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r598540644", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        return asyncValue(allOf(cmd.getAffectedKeys().stream().map(key -> indexIfNeeded(rCtx, cmd, unreliablePrevious, key)).toArray(CompletableFuture[]::new)));\n          \n          \n            \n                        return return delayedValue(allOf(cmd.getAffectedKeys().stream().map(key -> indexIfNeeded(rCtx, cmd, unreliablePrevious, key)).toArray(CompletableFuture[]::new)), rv);", "author": "pruivo", "createdAt": "2021-03-22T09:17:29Z", "path": "query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java", "diffHunk": "@@ -145,78 +147,77 @@ private Object handleDataWriteCommand(InvocationContext ctx, DataWriteCommand co\n       if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n       }\n-      CacheEntry entry = ctx.lookupEntry(command.getKey());\n-      if (ctx.isInTxScope()) {\n-         // replay of modifications on remote node by EntryWrappingVisitor\n-         if (entry != null && !entry.isChanged() && (entry.getValue() != null || !unreliablePreviousValue(command))) {\n-            Map<Object, Object> oldValues = registerOldValues((TxInvocationContext) ctx);\n-            oldValues.putIfAbsent(command.getKey(), entry.getValue());\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return rv;\n+         }\n+         boolean unreliablePrevious = unreliablePreviousValue(command);\n+         if (ctx.isInTxScope()) {\n+            Map<Object, Object> oldValues = getOldValuesMap((TxInvocationContext<?>) ctx);\n+            registerOldValue(ctx, command.getKey(), unreliablePrevious, oldValues);\n+         } else {\n+            return asyncValue(indexIfNeeded(rCtx, cmd, unreliablePrevious, cmd.getKey()).thenApply(ignored -> rv));\n          }\n+         return rv;\n+      });\n+   }\n+\n+   private Object handleManyWriteCommand(InvocationContext ctx, WriteCommand command) {\n+      if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n-      } else {\n-         Object prev = entry != null ? entry.getValue() : UNKNOWN;\n-         if (prev == null && unreliablePreviousValue(command)) {\n-            prev = UNKNOWN;\n+      }\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return rv;\n          }\n-         Object oldValue = prev;\n-         return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n-            if (!cmd.isSuccessful()) {\n-               return rv;\n-            }\n-            CacheEntry entry2 = entry != null ? entry : rCtx.lookupEntry(cmd.getKey());\n-            if (entry2 != null && entry2.isChanged()) {\n-               // TODO: need to reduce the scope of the blocking thread to less if possible later as part of\n-               // https://issues.redhat.com/browse/ISPN-11731\n-               return asyncValue(processChange(rCtx, cmd, cmd.getKey(), oldValue, entry2.getValue())\n-                     .thenApply(ignore -> rv));\n+         boolean unreliablePrevious = unreliablePreviousValue(command);\n+         if (ctx.isInTxScope()) {\n+            Map<Object, Object> oldValues = getOldValuesMap((TxInvocationContext<?>) ctx);\n+            for (Object key : command.getAffectedKeys()) {\n+               registerOldValue(ctx, key, unreliablePrevious, oldValues);\n             }\n             return rv;\n-         });\n+         } else {\n+            return asyncValue(allOf(cmd.getAffectedKeys().stream().map(key -> indexIfNeeded(rCtx, cmd, unreliablePrevious, key)).toArray(CompletableFuture[]::new)));", "originalCommit": "4a1d43ae5e377defef471bb892e95b624010d22d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODU0MTI5NQ==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r598541295", "bodyText": "isStale is always false", "author": "pruivo", "createdAt": "2021-03-22T09:18:29Z", "path": "query/src/main/java/org/infinispan/query/backend/QueryInterceptor.java", "diffHunk": "@@ -145,78 +147,77 @@ private Object handleDataWriteCommand(InvocationContext ctx, DataWriteCommand co\n       if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n       }\n-      CacheEntry entry = ctx.lookupEntry(command.getKey());\n-      if (ctx.isInTxScope()) {\n-         // replay of modifications on remote node by EntryWrappingVisitor\n-         if (entry != null && !entry.isChanged() && (entry.getValue() != null || !unreliablePreviousValue(command))) {\n-            Map<Object, Object> oldValues = registerOldValues((TxInvocationContext) ctx);\n-            oldValues.putIfAbsent(command.getKey(), entry.getValue());\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return rv;\n+         }\n+         boolean unreliablePrevious = unreliablePreviousValue(command);\n+         if (ctx.isInTxScope()) {\n+            Map<Object, Object> oldValues = getOldValuesMap((TxInvocationContext<?>) ctx);\n+            registerOldValue(ctx, command.getKey(), unreliablePrevious, oldValues);\n+         } else {\n+            return asyncValue(indexIfNeeded(rCtx, cmd, unreliablePrevious, cmd.getKey()).thenApply(ignored -> rv));\n          }\n+         return rv;\n+      });\n+   }\n+\n+   private Object handleManyWriteCommand(InvocationContext ctx, WriteCommand command) {\n+      if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n          return invokeNext(ctx, command);\n-      } else {\n-         Object prev = entry != null ? entry.getValue() : UNKNOWN;\n-         if (prev == null && unreliablePreviousValue(command)) {\n-            prev = UNKNOWN;\n+      }\n+      return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n+         if (!cmd.isSuccessful()) {\n+            return rv;\n          }\n-         Object oldValue = prev;\n-         return invokeNextThenApply(ctx, command, (rCtx, cmd, rv) -> {\n-            if (!cmd.isSuccessful()) {\n-               return rv;\n-            }\n-            CacheEntry entry2 = entry != null ? entry : rCtx.lookupEntry(cmd.getKey());\n-            if (entry2 != null && entry2.isChanged()) {\n-               // TODO: need to reduce the scope of the blocking thread to less if possible later as part of\n-               // https://issues.redhat.com/browse/ISPN-11731\n-               return asyncValue(processChange(rCtx, cmd, cmd.getKey(), oldValue, entry2.getValue())\n-                     .thenApply(ignore -> rv));\n+         boolean unreliablePrevious = unreliablePreviousValue(command);\n+         if (ctx.isInTxScope()) {\n+            Map<Object, Object> oldValues = getOldValuesMap((TxInvocationContext<?>) ctx);\n+            for (Object key : command.getAffectedKeys()) {\n+               registerOldValue(ctx, key, unreliablePrevious, oldValues);\n             }\n             return rv;\n-         });\n+         } else {\n+            return asyncValue(allOf(cmd.getAffectedKeys().stream().map(key -> indexIfNeeded(rCtx, cmd, unreliablePrevious, key)).toArray(CompletableFuture[]::new)));\n+         }\n+      });\n+   }\n+\n+   private void registerOldValue(InvocationContext ctx, Object key, boolean unreliablePrevious, Map<Object, Object> oldValues) {\n+      CacheEntry<?, ?> entryTx = ctx.lookupEntry(key);\n+      if (entryTx != null && (entryTx.getValue() != null || !unreliablePrevious)) {\n+         ReadCommittedEntry<?, ?> mvccEntry = (ReadCommittedEntry<?, ?>) entryTx;\n+         oldValues.putIfAbsent(key, mvccEntry.getOldValue());\n       }\n    }\n \n-   private Map<Object, Object> registerOldValues(TxInvocationContext ctx) {\n+   private Map<Object, Object> getOldValuesMap(TxInvocationContext<?> ctx) {\n       return txOldValues.computeIfAbsent(ctx.getGlobalTransaction(), gid -> {\n          ctx.getCacheTransaction().addListener(() -> txOldValues.remove(gid));\n          return new HashMap<>();\n       });\n    }\n \n-   private Object handleManyWriteCommand(InvocationContext ctx, WriteCommand command) {\n-      if (command.hasAnyFlag(FlagBitSets.SKIP_INDEXING)) {\n-         return invokeNext(ctx, command);\n+   private CompletableFuture<?> indexIfNeeded(InvocationContext rCtx, WriteCommand cmd, boolean unreliablePrevious, Object key) {\n+      CacheEntry<?, ?> entry = rCtx.lookupEntry(key);\n+      boolean isStale = false;\n+      Object old = null;\n+      if (entry instanceof MVCCEntry) {\n+         ReadCommittedEntry<?, ?> mvccEntry = (ReadCommittedEntry<?, ?>) entry;\n+         isStale = !mvccEntry.isCommitted();\n+         old = unreliablePrevious ? UNKNOWN : mvccEntry.getOldValue();\n       }\n-      if (ctx.isInTxScope()) {\n-         Map<Object, Object> oldValues = registerOldValues((TxInvocationContext) ctx);\n-         for (Object key : command.getAffectedKeys()) {\n-            CacheEntry entry = ctx.lookupEntry(key);\n-            if (entry != null && !entry.isChanged() && (entry.getValue() != null || !unreliablePreviousValue(command))) {\n-               oldValues.putIfAbsent(key, entry.getValue());\n-            }\n+      if (entry != null && entry.isChanged() && !isStale) {\n+         if (log.isDebugEnabled()) {\n+            log.debugf(\"Try indexing command '%s',key='%s', oldValue='%s', stale='%s'\", cmd, key, old, isStale);", "originalCommit": "4a1d43ae5e377defef471bb892e95b624010d22d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODcwMTM1OQ==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r598701359", "bodyText": "isStale can be true if the entry is not committed:\ncd query\nmvn -Dtest=IndexingDuringStateTransferTest test\ngrep -R \"stale='true'\" target/infinispan-infinispan-query.log\n\n10:11:30,147 DEBUG (jgroups-7,IndexingDuringStateTransferTest-NodeA:[]) [QueryInterceptor] Skipping indexing for command 'PutKeyValueCommand{key=k, value=AnotherGrassEater{name='Fluffy', blurb='Very cute.'}, flags=[CACHE_MODE_LOCAL, SKIP_LOCKING, SKIP_REMOTE_LOOKUP, PUT_FOR_STATE_TRANSFER, SKIP_SHARED_CACHE_STORE, SKIP_OWNERSHIP_CHECK, IGNORE_RETURN_VALUES, SKIP_XSITE_BACKUP, IRAC_STATE], commandInvocationId=CommandInvocation:IndexingDuringStateTransferTest-NodeA:148, putIfAbsent=false, valueMatcher=MATCH_ALWAYS, metadata=InternalMetadataImpl{actual=EmbeddedMetadata{version=null}, created=-1, lastUsed=-1}, internalMetadata=null, successful=true, topologyId=65}',key='k', oldValue='AnotherGrassEater{name='Fluffy', blurb='Very cute.'}', stale='true'", "author": "gustavonalle", "createdAt": "2021-03-22T13:12:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODU0MTI5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODc4MzcwMg==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r598783702", "bodyText": "I mean isStale is always false in this log message :)\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        log.debugf(\"Try indexing command '%s',key='%s', oldValue='%s', stale='%s'\", cmd, key, old, isStale);\n          \n          \n            \n                        log.debugf(\"Try indexing command '%s',key='%s', oldValue='%s', stale='false'\", cmd, key, old);", "author": "pruivo", "createdAt": "2021-03-22T14:48:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODU0MTI5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODc5MTQ4NA==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r598791484", "bodyText": "no prob!", "author": "gustavonalle", "createdAt": "2021-03-22T14:56:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODU0MTI5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODg2OTIxNg==", "url": "https://github.com/infinispan/infinispan/pull/8072#discussion_r598869216", "bodyText": "fixed @pruivo", "author": "gustavonalle", "createdAt": "2021-03-22T16:15:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5ODU0MTI5NQ=="}], "type": "inlineReview"}, {"oid": "f3058224420a698d8f66636efbdfbb71059a239b", "url": "https://github.com/infinispan/infinispan/commit/f3058224420a698d8f66636efbdfbb71059a239b", "message": "ISPN-11299 Stale values can be indexed during State Transfer", "committedDate": "2021-03-22T13:59:03Z", "type": "forcePushed"}, {"oid": "6cf802b883faed62a4d9460efc307bc176904e15", "url": "https://github.com/infinispan/infinispan/commit/6cf802b883faed62a4d9460efc307bc176904e15", "message": "ISPN-11299 Stale values can be indexed during State Transfer", "committedDate": "2021-03-22T16:14:29Z", "type": "commit"}, {"oid": "6cf802b883faed62a4d9460efc307bc176904e15", "url": "https://github.com/infinispan/infinispan/commit/6cf802b883faed62a4d9460efc307bc176904e15", "message": "ISPN-11299 Stale values can be indexed during State Transfer", "committedDate": "2021-03-22T16:14:29Z", "type": "forcePushed"}]}