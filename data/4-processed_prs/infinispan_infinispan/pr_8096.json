{"pr_number": 8096, "pr_title": "ISPN-10457 Convert bulk blocking stream operations to publisher", "pr_createdAt": "2020-03-25T14:13:29Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8096", "timeline": [{"oid": "c9a896855ff67626c655a8e69d15272718d57cf6", "url": "https://github.com/infinispan/infinispan/commit/c9a896855ff67626c655a8e69d15272718d57cf6", "message": "ISPN-10457 Convert bulk blocking stream operations to publisher", "committedDate": "2020-03-25T18:43:54Z", "type": "forcePushed"}, {"oid": "12ee76412a2e024a6312fb4a405d50fe87e1939e", "url": "https://github.com/infinispan/infinispan/commit/12ee76412a2e024a6312fb4a405d50fe87e1939e", "message": "ISPN-11533 Convert ClientListenerRegistry to use non blocking calls", "committedDate": "2020-03-25T21:17:28Z", "type": "forcePushed"}, {"oid": "880533e8ede9667ad4435de82ac59d39305c2c10", "url": "https://github.com/infinispan/infinispan/commit/880533e8ede9667ad4435de82ac59d39305c2c10", "message": "ISPN-11533 Convert ClientListenerRegistry to use non blocking calls", "committedDate": "2020-03-25T21:22:17Z", "type": "forcePushed"}, {"oid": "84ff3c9abc0bf8c5955061ca66c84c99e813f322", "url": "https://github.com/infinispan/infinispan/commit/84ff3c9abc0bf8c5955061ca66c84c99e813f322", "message": "ISPN-11533 Convert ClientListenerRegistry to use non blocking calls", "committedDate": "2020-03-25T22:17:59Z", "type": "forcePushed"}, {"oid": "512f3dc8392095a3b890b07354e734a2ba228f34", "url": "https://github.com/infinispan/infinispan/commit/512f3dc8392095a3b890b07354e734a2ba228f34", "message": "ISPN-11533 Convert ClientListenerRegistry to use non blocking calls", "committedDate": "2020-03-26T14:31:02Z", "type": "forcePushed"}, {"oid": "3826a12f399e0f190c801fd8210efc763237963b", "url": "https://github.com/infinispan/infinispan/commit/3826a12f399e0f190c801fd8210efc763237963b", "message": "ISPN-10457 Convert bulk blocking stream operations to publisher", "committedDate": "2020-04-06T13:16:07Z", "type": "commit"}, {"oid": "84ba727899b552c8e6c45c036ae8b73c533d1a19", "url": "https://github.com/infinispan/infinispan/commit/84ba727899b552c8e6c45c036ae8b73c533d1a19", "message": "ISPN-11533 Convert ClientListenerRegistry to use non blocking calls", "committedDate": "2020-04-06T13:16:07Z", "type": "commit"}, {"oid": "84ba727899b552c8e6c45c036ae8b73c533d1a19", "url": "https://github.com/infinispan/infinispan/commit/84ba727899b552c8e6c45c036ae8b73c533d1a19", "message": "ISPN-11533 Convert ClientListenerRegistry to use non blocking calls", "committedDate": "2020-04-06T13:16:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM4NDk5OA==", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r405384998", "bodyText": "I suggest nullableToStream, I find the repetition of flatMap in the call sites a bit confusing.", "author": "danberindei", "createdAt": "2020-04-08T09:26:19Z", "path": "core/src/main/java/org/infinispan/filter/CacheFilters.java", "diffHunk": "@@ -80,13 +80,17 @@ private CacheFilters() { }\n    public static <K, V, C> Stream<CacheEntry<K, C>> filterAndConvert(Stream<CacheEntry<K, V>> stream,\n            KeyValueFilterConverter<? super K, ? super V, C> filterConverter) {\n       // Have to use flatMap instead of map/filter as reactive streams spec doesn't allow null values\n-      return stream.flatMap(new FilterConverterAsCacheEntryFunction(filterConverter));\n+      return stream.flatMap(flatMap(filterConverter));\n    }\n \n    public static <K, V, C> CacheStream<CacheEntry<K, C>> filterAndConvert(CacheStream<CacheEntry<K, V>> stream,\n             KeyValueFilterConverter<? super K, ? super V, C> filterConverter) {\n       // Have to use flatMap instead of map/filter as reactive streams spec doesn't allow null values\n-      return stream.flatMap(new FilterConverterAsCacheEntryFunction(filterConverter));\n+      return stream.flatMap(flatMap(filterConverter));\n+   }\n+\n+   public static <K, V, C> Function<CacheEntry<K, V>, Stream<CacheEntry<K, C>>> flatMap(KeyValueFilterConverter<? super K, ? super V, C> filterConverter) {", "originalCommit": "84ba727899b552c8e6c45c036ae8b73c533d1a19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ2NjY0Mg==", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r406466642", "bodyText": "I agree the naming could be better. I am not sure I like the nullable part. Maybe filterConverterToFlatMapFunction is more descriptive :D", "author": "wburns", "createdAt": "2020-04-09T20:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM4NDk5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYyNTk2MQ==", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r406625961", "bodyText": "My thinking was it's just a function, it's not only usable in flatMap, but you're right, we can't focus just on the return type and ignore the function types.\nHowever, that made me look again at the usages of flatMap(), and it seems to me that we always create the KeyValueFilterConverter instance just before we wrap it with flatMap(). Couldn't we simplify things by replacing IterationFilter and CacheEventFilterConverterAsKeyValueFilterConverter with implementations of Function<CacheEntry<K, V>, Stream<CacheEntry<K, C>>>?\nThe same applies to function() (it's used to wrap an unknown Converter in Caches.entrySet(), but that method is never used and it's not API) and predicate() (Caches.entrySet() is only called with AcceptAllKeyValueFilter).\nThinking further about flatMap(), I'm not even sure flatMap() is the best Stream method to use to handle the null values. Because the stream values are actually entries, we can use NullCacheEntry, something like this:\n   /**\n    * Adapt {@link KeyValueFilterConverter} for use with streams by replacing null values with NullCacheEntry instances.\n    */\n   @Scope(Scopes.NONE)\n   static class FilterConverterAsCacheEntryMapper<K, V, C> implements Function<CacheEntry<K, V>, CacheEntry<K, C>> {\n      protected final KeyValueFilterConverter<? super K, ? super V, C> converter;\n\n      protected InternalEntryFactory factory;\n\n      public FilterConverterAsCacheEntryMapper(KeyValueFilterConverter<? super K, ? super V, C> converter) {\n         Objects.requireNonNull(converter);\n         this.converter = converter;\n      }\n\n      @Inject\n      public void inject(InternalEntryFactory factory, ComponentRegistry registry) {\n         this.factory = factory;\n         registry.wireDependencies(converter);\n      }\n\n      @Override\n      public CacheEntry<K, C> apply(CacheEntry<K, V> kvCacheEntry) {\n         K key = kvCacheEntry.getKey();\n         V value = kvCacheEntry.getValue();\n         Metadata metadata = kvCacheEntry.getMetadata();\n         C converted = converter.filterAndConvert(key, value, metadata);\n         if (converted == null) {\n            return NullCacheEntry.getInstance();\n         }\n         return factory.create(key, converted, metadata);\n      }\n   }\n\n   public static <K, V, C> CacheStream<CacheEntry<K, C>> filterAndConvert(CacheStream<CacheEntry<K, V>> stream,\n                                                                          KeyValueFilterConverter<? super K, ?\n                                                                                super V, C> filterConverter) {\n      return stream.map(new FilterConverterAsCacheEntryMapper<>(filterConverter))\n                   .filter(c -> c != NullCacheEntry.getInstance());\n   }\nEven when MortalCacheEntry is not available, it may be cheaper to use a new Object() as a null marker to get less allocations (at the expense of more lambdas):\n   public static final Object NULL_MARKER = new Object();\n\n   @Scope(Scopes.NONE)\n   static class FilterConverterAsValueMapper<K, V, C> implements Function<CacheEntry<K, V>, Object> {\n      protected final KeyValueFilterConverter<? super K, ? super V, C> converter;\n\n      public FilterConverterAsValueMapper(KeyValueFilterConverter<? super K, ? super V, C> converter) {\n         Objects.requireNonNull(converter);\n         this.converter = converter;\n      }\n\n      @Inject\n      public void inject(ComponentRegistry registry) {\n         registry.wireDependencies(converter);\n      }\n\n      @Override\n      public Object apply(CacheEntry<K, V> entry) {\n         C converted = converter.filterAndConvert(entry.getKey(), entry.getValue(), entry.getMetadata());\n         if (converted == null) {\n            return NULL_MARKER;\n         }\n         return converted;\n      }\n   }\n   \n   public static <K, V, C> CacheStream<C> filterAndConvertToValue(CacheStream<CacheEntry<K, V>> stream,\n         KeyValueFilterConverter<? super K, ? super V, C> filterConverter) {\n      // Have to use flatMap instead of map/filter as reactive streams spec doesn't allow null values\n      return stream.map(new FilterConverterAsValueMapper<>(filterConverter))\n            .filter(Objects::nonNull)\n            .map(c -> (C) c);\n   }\nI'm not sure how it would work out for RxJava and Maybe, but I did notice some usages of RxJavaInterop.completionStageToMaybe() that can be simplified, either by returning null and removing the additional filter() step, or by replacing it with completionStageToSingle() and removing the additional toSingle() step.", "author": "danberindei", "createdAt": "2020-04-10T06:42:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM4NDk5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ4MDU4Mg==", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r407480582", "bodyText": "Thinking further about flatMap(), I'm not even sure flatMap() is the best Stream method to use to handle the null values. Because the stream values are actually entries, we can use NullCacheEntry, something like this:\n\nThis was my idea originally, but something prevented it a while back. My guess is this is probably fine now though. The only problem is that these methods are public, so I will have to make some new methods instead. I will mess with it a bit though.\nAnd I agree that IterationFilter can be redone, but I figure that is a bit out of scope of this PR at this time.", "author": "wburns", "createdAt": "2020-04-13T13:34:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM4NDk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzMTY2Nw==", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r406031667", "bodyText": "IMO there's no need to avoid the allocation here, because it happens at most once per segment.", "author": "danberindei", "createdAt": "2020-04-09T08:12:43Z", "path": "core/src/main/java/org/infinispan/notifications/cachelistener/DistributedQueueingSegmentListener.java", "diffHunk": "@@ -137,8 +115,34 @@ public boolean handleEvent(EventWrapper<K, V, CacheEntryEvent<K, V>> wrapped, Li\n    }\n \n    @Override\n-   public void accept(Supplier<PrimitiveIterator.OfInt> segments) {\n-      justCompletedSegments = segments.get();\n+   public void accept(int segment) {\n+      if (justCompletedSegments == null) {\n+         justCompletedSegments = IntSets.mutableEmptySet();\n+      }\n+      justCompletedSegments.set(segment);\n+   }\n+\n+   @Override\n+   public CompletionStage<Void> delayProcessing() {\n+      AggregateCompletionStage<Void> aggregateCompletionStage = null;\n+      if (justCompletedSegments != null) {\n+         if (trace) {\n+            log.tracef(\"Segments %s completed for listener\", justCompletedSegments);\n+         }\n+         // This relies on the fact that notifiedKey is immediately called after the entry has finished being iterated on\n+         PrimitiveIterator.OfInt iter = justCompletedSegments.iterator();\n+         while (iter.hasNext()) {\n+            CompletionStage<Void> segmentStage = completeSegment(iter.nextInt());\n+            if (segmentStage != null) {\n+               if (aggregateCompletionStage == null) {", "originalCommit": "84ba727899b552c8e6c45c036ae8b73c533d1a19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ2MzczMA==", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r406463730", "bodyText": "I won't revert it now, but if this stage is not null there is a high chance that it will be complete as most of our listeners in this case will be complete.", "author": "wburns", "createdAt": "2020-04-09T20:39:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzMTY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzMzYwNA==", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r406033604", "bodyText": "This should never be necessary, only the main test thread should block on BEFORE_INVOCATION.", "author": "danberindei", "createdAt": "2020-04-09T08:15:59Z", "path": "core/src/test/java/org/infinispan/notifications/cachelistener/CacheNotifierImplInitialTransferDistTest.java", "diffHunk": "@@ -295,15 +278,10 @@ private void testModificationAfterIterationBeganAndCompletedSegmentValueOwner(fi\n \n       CheckPoint checkPoint = new CheckPoint();\n \n-      AsyncInterceptorChain chain = mockEntrySet(cache, (mock, real, additional) -> {\n-         doAnswer(i -> {\n-            // Wait for main thread to sync up\n-            checkPoint.trigger(\"pre_close_iter_invoked\");\n-            // Now wait until main thread lets us through\n-            checkPoint.awaitStrict(\"pre_close_iter_released\", 10, TimeUnit.SECONDS);\n-            return invokeAndReturnMock(i, real);\n-         }).when(mock).close();\n-      });\n+      registerBlockingPublisher(checkPoint, cache);\n+\n+      checkPoint.triggerForever(Mocks.BEFORE_INVOCATION);", "originalCommit": "84ba727899b552c8e6c45c036ae8b73c533d1a19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ2NTUyMQ==", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r406465521", "bodyText": "Agreed, I normally just did this in the tests as more of a way to document that nothing should be blocking on these invocations for this test. It is harmless imo.", "author": "wburns", "createdAt": "2020-04-09T20:43:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzMzYwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjYxNDY1MQ==", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r406614651", "bodyText": "I guess it's a problem with the CheckPoint API and the Mocks \"extensions\", it's not obvious which events the test is supposed to wait on and which events the mocks are supposed to block on. But IMO triggering extra events only makes it harder to understand.", "author": "danberindei", "createdAt": "2020-04-10T05:56:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzMzYwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ4MTAyOQ==", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r407481029", "bodyText": "Okay, I figured the ones triggered forever at the beginning was a clear sign that those events were not used in the test, but I guess not.", "author": "wburns", "createdAt": "2020-04-13T13:35:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzMzYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzNDI1Ng==", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r406034256", "bodyText": "Same here, because that's how the Mocks methods all create mocks that trigger BEFORE/AFTER_INVOCATION and block on BEFORE/AFTER_RELEASE.", "author": "danberindei", "createdAt": "2020-04-09T08:17:07Z", "path": "core/src/test/java/org/infinispan/notifications/cachelistener/CacheNotifierImplInitialTransferDistTest.java", "diffHunk": "@@ -485,23 +462,24 @@ protected void testIterationBeganAndSegmentNotComplete(final StateListener<Strin\n       }\n \n       CheckPoint checkPoint = new CheckPoint();\n+      checkPoint.triggerForever(Mocks.AFTER_RELEASE);\n+      checkPoint.triggerForever(Mocks.AFTER_INVOCATION);", "originalCommit": "84ba727899b552c8e6c45c036ae8b73c533d1a19", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzNjQzOQ==", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r406036439", "bodyText": "Surefire won't run this test because it doesn't end in Test\nAlso, what exactly is non-blocking about this test compared to other cluster listener tests?", "author": "danberindei", "createdAt": "2020-04-09T08:20:59Z", "path": "core/src/test/java/org/infinispan/notifications/cachelistener/cluster/NonBlockingClusterListener.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package org.infinispan.notifications.cachelistener.cluster;\n+\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.factories.KnownComponentNames;\n+import org.infinispan.notifications.Listener;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryCreated;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryModified;\n+import org.infinispan.notifications.cachelistener.annotation.CacheEntryRemoved;\n+import org.infinispan.notifications.cachelistener.event.CacheEntryEvent;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.util.concurrent.CompletableFutures;\n+import org.testng.annotations.Test;\n+\n+@Test(groups = \"functional\", testName = \"notifications.cachelistener.NonBlockingClusterListener\")\n+public class NonBlockingClusterListener extends AbstractClusterListenerUtilTest {", "originalCommit": "84ba727899b552c8e6c45c036ae8b73c533d1a19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ2MjAyMw==", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r406462023", "bodyText": "Hrmm, not sure why this test is here. Guessing it was just something I was using it as a temporary class. I can remove it.", "author": "wburns", "createdAt": "2020-04-09T20:36:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzNjQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3MjQ2OQ==", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r406172469", "bodyText": "This also works and avoids all the unchecked warnings:\n         Queue<IntermediateOperation<?, ?, ?, ?>> intermediateOperations = new ArrayDeque<>();\n\n         if (keyDataConversion != DataConversion.IDENTITY_KEY && valueDataConversion != DataConversion.IDENTITY_VALUE) {\n            intermediateOperations.add(new MapOperation<>(EncoderEntryMapper.newCacheEntryMapper(\n                  keyDataConversion, valueDataConversion, entryFactory)));\n         }\n\n         if (filter instanceof CacheEventFilterConverter && (filter == converter || converter == null)) {\n            intermediateOperations.add(new FlatMapOperation<>(CacheFilters.flatMap(\n                  new CacheEventFilterConverterAsKeyValueFilterConverter<>((CacheEventFilterConverter<?, ?, ?>) filter))));\n         } else {\n            if (filter != null) {\n               intermediateOperations.add(new FilterOperation<>(CacheFilters.predicate(\n                     new CacheEventFilterAsKeyValueFilter<>(filter))));\n            }\n            if (converter != null) {\n               intermediateOperations.add(new MapOperation<>(CacheFilters.function(\n                     new CacheEventConverterAsConverter<>(converter))));\n            }\n         }", "author": "danberindei", "createdAt": "2020-04-09T12:35:57Z", "path": "core/src/main/java/org/infinispan/notifications/cachelistener/CacheNotifierImpl.java", "diffHunk": "@@ -1070,51 +1085,89 @@ public void addListener(Object listener, KeyFilter<? super K> filter, ClassLoade\n       }\n \n       // If we have a segment listener handler, it means we have to do initial state\n-      QueueingSegmentListener handler = segmentHandler.remove(generatedId);\n+      QueueingSegmentListener<K, V, ? extends Event<K, V>> handler = segmentHandler.remove(generatedId);\n       if (handler != null) {\n          if (trace) {\n             log.tracef(\"Listener %s requests initial state for cache\", generatedId);\n          }\n-         CacheStream entryStream = cache.wired().withEncoding(keyConversion.getEncoderClass(), valueConversion.getEncoderClass()).cacheEntrySet().stream();\n-         Stream<CacheEntry<K, V>> usedStream = entryStream.segmentCompletionListener(handler);\n+         Queue<IntermediateOperation> intermediateOperations = new ArrayDeque<>();\n+\n+         if (keyDataConversion != DataConversion.IDENTITY_KEY && valueDataConversion != DataConversion.IDENTITY_VALUE) {\n+            intermediateOperations.add(new MapOperation(EncoderEntryMapper.newCacheEntryMapper(\n+                  keyDataConversion, valueDataConversion, entryFactory)));\n+         }\n \n          if (filter instanceof CacheEventFilterConverter && (filter == converter || converter == null)) {\n             // Hacky cast to prevent other casts\n-            usedStream = CacheFilters.filterAndConvert(usedStream,\n-                  new CacheEventFilterConverterAsKeyValueFilterConverter<>((CacheEventFilterConverter<K, V, V>) filter));\n+            intermediateOperations.add(new FlatMapOperation(CacheFilters.flatMap(\n+                  new CacheEventFilterConverterAsKeyValueFilterConverter<>((CacheEventFilterConverter) filter))));", "originalCommit": "84ba727899b552c8e6c45c036ae8b73c533d1a19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3OTg3OA==", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r406479878", "bodyText": "Sure", "author": "wburns", "createdAt": "2020-04-09T21:11:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3MjQ2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NDE0MQ==", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r406174141", "bodyText": "Queue suggests that items are being removed from the front, but AFAICT it's only iterated, so I'd replace it with a List.", "author": "danberindei", "createdAt": "2020-04-09T12:39:04Z", "path": "core/src/main/java/org/infinispan/notifications/cachelistener/CacheNotifierImpl.java", "diffHunk": "@@ -1070,51 +1085,89 @@ public void addListener(Object listener, KeyFilter<? super K> filter, ClassLoade\n       }\n \n       // If we have a segment listener handler, it means we have to do initial state\n-      QueueingSegmentListener handler = segmentHandler.remove(generatedId);\n+      QueueingSegmentListener<K, V, ? extends Event<K, V>> handler = segmentHandler.remove(generatedId);\n       if (handler != null) {\n          if (trace) {\n             log.tracef(\"Listener %s requests initial state for cache\", generatedId);\n          }\n-         CacheStream entryStream = cache.wired().withEncoding(keyConversion.getEncoderClass(), valueConversion.getEncoderClass()).cacheEntrySet().stream();\n-         Stream<CacheEntry<K, V>> usedStream = entryStream.segmentCompletionListener(handler);\n+         Queue<IntermediateOperation> intermediateOperations = new ArrayDeque<>();", "originalCommit": "84ba727899b552c8e6c45c036ae8b73c533d1a19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjQ3OTA3MA==", "url": "https://github.com/infinispan/infinispan/pull/8096#discussion_r406479070", "bodyText": "tbh just Collection would work. I believe this originates from old DistributedStream code where I used a Queue and removed first elements at some point. This is no longer true though.", "author": "wburns", "createdAt": "2020-04-09T21:09:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NDE0MQ=="}], "type": "inlineReview"}]}