{"pr_number": 8699, "pr_title": "ISPN-11176 Xsite Max Idle", "pr_createdAt": "2020-09-17T16:11:32Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8699", "timeline": [{"oid": "2eb9d8811c5c6b3c12462c24ffb29de70460d51a", "url": "https://github.com/infinispan/infinispan/commit/2eb9d8811c5c6b3c12462c24ffb29de70460d51a", "message": "ISPN-12337 Clustered Expiration can deadlock with Pessimistic Tx on a non owner", "committedDate": "2020-09-17T19:54:29Z", "type": "forcePushed"}, {"oid": "fada47639ef487654143532eb32e0e84f62f40cc", "url": "https://github.com/infinispan/infinispan/commit/fada47639ef487654143532eb32e0e84f62f40cc", "message": "ISPN-12337 Clustered Expiration can deadlock with Pessimistic Tx on a non owner", "committedDate": "2020-09-21T14:02:12Z", "type": "forcePushed"}, {"oid": "77ae2bce5a7f84055893424ebca447555505b7d7", "url": "https://github.com/infinispan/infinispan/commit/77ae2bce5a7f84055893424ebca447555505b7d7", "message": "ISPN-11176 XSite Max Idle\n\n* Refactor touch to be a visitable command\n* Add Touch logic to interceptors", "committedDate": "2020-09-24T05:01:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA3OTg3Ng==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495079876", "bodyText": "since the method is exposed to users, I would check <0 instead.", "author": "pruivo", "createdAt": "2020-09-25T15:52:07Z", "path": "core/src/main/java/org/infinispan/cache/impl/CacheImpl.java", "diffHunk": "@@ -1218,6 +1220,24 @@ public String toString() {\n       return \"Cache '\" + name + \"'@\" + (config != null && config.clustering().cacheMode().isClustered() ? getRpcManager().getAddress() : Util.hexIdHashCode(getCacheManager()));\n    }\n \n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n+      return touch(key, -1, touchEvenIfExpired, 0);\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired) {\n+      return touch(key, segment, touchEvenIfExpired, 0);\n+   }\n+\n+   public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired, long flagBitSet) {\n+      if (segment == -1) {", "originalCommit": "77ae2bce5a7f84055893424ebca447555505b7d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk4NTA3MQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495985071", "bodyText": "Sure", "author": "wburns", "createdAt": "2020-09-28T14:32:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA3OTg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MDIzOA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495080238", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return touch(key, -1, touchEvenIfExpired, 0);\n          \n          \n            \n                  return touch(key, -1, touchEvenIfExpired, EnumUtil.EMPTY_BIT_SET);", "author": "pruivo", "createdAt": "2020-09-25T15:52:40Z", "path": "core/src/main/java/org/infinispan/cache/impl/CacheImpl.java", "diffHunk": "@@ -1218,6 +1220,24 @@ public String toString() {\n       return \"Cache '\" + name + \"'@\" + (config != null && config.clustering().cacheMode().isClustered() ? getRpcManager().getAddress() : Util.hexIdHashCode(getCacheManager()));\n    }\n \n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n+      return touch(key, -1, touchEvenIfExpired, 0);", "originalCommit": "77ae2bce5a7f84055893424ebca447555505b7d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk4NTE1NQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495985155", "bodyText": "\ud83d\udc4d", "author": "wburns", "createdAt": "2020-09-28T14:32:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MDIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MDUxMQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495080511", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  return touch(key, segment, touchEvenIfExpired, 0);\n          \n          \n            \n                  return touch(key, segment, touchEvenIfExpired, EnumUtil.EMPTY_BIT_SET);", "author": "pruivo", "createdAt": "2020-09-25T15:53:07Z", "path": "core/src/main/java/org/infinispan/cache/impl/CacheImpl.java", "diffHunk": "@@ -1218,6 +1220,24 @@ public String toString() {\n       return \"Cache '\" + name + \"'@\" + (config != null && config.clustering().cacheMode().isClustered() ? getRpcManager().getAddress() : Util.hexIdHashCode(getCacheManager()));\n    }\n \n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n+      return touch(key, -1, touchEvenIfExpired, 0);\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired) {\n+      return touch(key, segment, touchEvenIfExpired, 0);", "originalCommit": "77ae2bce5a7f84055893424ebca447555505b7d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk4NTIyNQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495985225", "bodyText": "\ud83d\udc4d", "author": "wburns", "createdAt": "2020-09-28T14:32:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MDUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MTI3Mw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495081273", "bodyText": "use -1 as  segment?", "author": "pruivo", "createdAt": "2020-09-25T15:54:20Z", "path": "core/src/main/java/org/infinispan/cache/impl/SimpleCacheImpl.java", "diffHunk": "@@ -390,6 +392,26 @@ public void setAvailability(AvailabilityMode availabilityMode) {\n       throw new UnsupportedOperationException();\n    }\n \n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n+      Objects.requireNonNull(key, NULL_KEYS_NOT_SUPPORTED);\n+      int segment = keyPartitioner.getSegment(key);\n+      return touch(key, segment, touchEvenIfExpired);", "originalCommit": "77ae2bce5a7f84055893424ebca447555505b7d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MTU1NA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495081554", "bodyText": "ps. Objects.requireNonNull() isn't required here. the other method checks it.", "author": "pruivo", "createdAt": "2020-09-25T15:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MTI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk4NTUzOQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495985539", "bodyText": "I was just being consistent with the rest of the SimpleCacheImpl methods.", "author": "wburns", "createdAt": "2020-09-28T14:32:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MTI3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAwOTc1NA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496009754", "bodyText": "But now that I look again, I agree it isn't required.", "author": "wburns", "createdAt": "2020-09-28T15:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4MTI3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4Mjk2Nw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495082967", "bodyText": "check if segment is valid?\nofftopic, would be good to have an \"utility\" method like\nint requireValidSegment(Object k, int segment, KeyPartitioner p) {\n  return segment if segement in [0..numSegments] else p.getSegment(k)\n}", "author": "pruivo", "createdAt": "2020-09-25T15:57:01Z", "path": "core/src/main/java/org/infinispan/cache/impl/SimpleCacheImpl.java", "diffHunk": "@@ -390,6 +392,26 @@ public void setAvailability(AvailabilityMode availabilityMode) {\n       throw new UnsupportedOperationException();\n    }\n \n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n+      Objects.requireNonNull(key, NULL_KEYS_NOT_SUPPORTED);\n+      int segment = keyPartitioner.getSegment(key);\n+      return touch(key, segment, touchEvenIfExpired);\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired) {\n+      Objects.requireNonNull(key, NULL_KEYS_NOT_SUPPORTED);\n+      InternalCacheEntry<K, V> entry = dataContainer.peek(segment, key);", "originalCommit": "77ae2bce5a7f84055893424ebca447555505b7d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAxNDQwMA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496014400", "bodyText": "I added a segment < 0 check.", "author": "wburns", "createdAt": "2020-09-28T15:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4Mjk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4NDczNw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495084737", "bodyText": "question: is the flag bitset used?", "author": "pruivo", "createdAt": "2020-09-25T15:59:40Z", "path": "core/src/main/java/org/infinispan/commands/CommandsFactoryImpl.java", "diffHunk": "@@ -694,8 +695,8 @@ public CheckTransactionRpcCommand buildCheckTransactionRpcCommand(Collection<Glo\n    }\n \n    @Override\n-   public TouchCommand buildTouchCommand(Object key, int segment) {\n-      return new TouchCommand(cacheName, key, segment);\n+   public TouchCommand buildTouchCommand(Object key, int segment, boolean touchEvenIfExpired, long flagBitSet) {\n+      return new TouchCommand(key, segment, flagBitSet, touchEvenIfExpired);", "originalCommit": "77ae2bce5a7f84055893424ebca447555505b7d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTk5NjQ4Ng==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495996486", "bodyText": "Not currently, the idea was we may at some point want a LOCAL forced touch for example.", "author": "wburns", "createdAt": "2020-09-28T14:47:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4NDczNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE5NzAyNQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496197025", "bodyText": "yeah, I was just worried if the user invokes the touch() with some weird flags (like, skip remote)", "author": "pruivo", "createdAt": "2020-09-28T19:56:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4NDczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4Nzg3MQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495087871", "bodyText": "shouldn't be sent to the primary owner?", "author": "pruivo", "createdAt": "2020-09-25T16:05:03Z", "path": "core/src/main/java/org/infinispan/xsite/ClusteredCacheBackupReceiver.java", "diffHunk": "@@ -257,6 +260,25 @@ private XSiteStatePushCommand newStatePushCommand(List<XSiteState> stateList) {\n       return defaultHandler.cache().clearAsync();\n    }\n \n+   @Override\n+   public CompletionStage<Boolean> touchEntry(Object key) {\n+      int segment = clusteringDependentLogic.getCacheTopology().getSegment(key);", "originalCommit": "77ae2bce5a7f84055893424ebca447555505b7d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAwNDgyMA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496004820", "bodyText": "Hrmm, yeah this should invoke the touch command. Let me do that.", "author": "wburns", "createdAt": "2020-09-28T14:55:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4Nzg3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4OTE1Nw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r495089157", "bodyText": "can you revert this and remove the `componentRegistry' field? I know I'm complaining just to save 8 bytes eh eh", "author": "pruivo", "createdAt": "2020-09-25T16:07:25Z", "path": "core/src/main/java/org/infinispan/xsite/ClusteredCacheBackupReceiver.java", "diffHunk": "@@ -126,9 +130,8 @@ public ClusteredCacheBackupReceiver(String cacheName) {\n    public void start() {\n       //it would be nice if we could inject bootstrap component\n       //this feels kind hacky but saves 3 fields in this class\n-      ComponentRegistry cr = cache.getAdvancedCache().getComponentRegistry();\n-      TransactionHandler txHandler = new TransactionHandler(cache, cr.getTransactionTable());\n-      defaultHandler = new DefaultHandler(txHandler, cr.getComponent(BlockingManager.class));\n+      TransactionHandler txHandler = new TransactionHandler(cache, componentRegistry.getTransactionTable());", "originalCommit": "77ae2bce5a7f84055893424ebca447555505b7d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjAwMDUxMQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496000511", "bodyText": "Okay.", "author": "wburns", "createdAt": "2020-09-28T14:52:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTA4OTE1Nw=="}], "type": "inlineReview"}, {"oid": "405a8b2b22032e146866a8f8dca8515df4882200", "url": "https://github.com/infinispan/infinispan/commit/405a8b2b22032e146866a8f8dca8515df4882200", "message": "ISPN-11176 XSite Max Idle\n\n* Refactor touch to be a visitable command\n* Add Touch logic to interceptors", "committedDate": "2020-09-28T19:46:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE5ODU5MQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496198591", "bodyText": "nit: no longer used. can be removed.", "author": "pruivo", "createdAt": "2020-09-28T19:59:30Z", "path": "core/src/main/java/org/infinispan/xsite/ClusteredCacheBackupReceiver.java", "diffHunk": "@@ -111,7 +113,7 @@\n    @Inject InvocationContextFactory invocationContextFactory;\n    @Inject RpcManager rpcManager;\n    @Inject ClusteringDependentLogic clusteringDependentLogic;\n-   @Inject ComponentRegistry componentRegistry;\n+   @Inject InternalDataContainer<Object, Object> dataContainer;", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwMjM2MA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496202360", "bodyText": "is it ok to use 0 as a segment? shouldn't be -1 since 0 is valid? or split the entries per segment.\nAre you plan to use the segment in the future? currently isn't used and could be removed.", "author": "pruivo", "createdAt": "2020-09-28T20:07:07Z", "path": "core/src/main/java/org/infinispan/container/impl/DefaultDataContainer.java", "diffHunk": "@@ -233,4 +232,10 @@ public void cleanUp() {\n          evictionCache.cleanUp();\n       }\n    }\n+\n+\n+   @Override\n+   public void forEachSegment(ObjIntConsumer<PeekableTouchableMap<K, V>> segmentMapConsumer) {\n+      segmentMapConsumer.accept(entries, 0);", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc2Njk4Mg==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496766982", "bodyText": "The point is to iterate over all the various segmented maps of the container. I can't see having the API not have the segment.\nAnd the reason for 0 is because this container has a single map. This is inline with what the SingleSegmentKeyPartitioner does as well.", "author": "wburns", "createdAt": "2020-09-29T14:31:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwMjM2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNDgyOA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496204828", "bodyText": "I'm not sure if this is correct. setting isWrite = hasLock will skip the max-idle expiration check. is it intentional?\nIn a pessimisitc transaction, you can lock a key never write to it.", "author": "pruivo", "createdAt": "2020-09-28T20:12:03Z", "path": "core/src/main/java/org/infinispan/container/impl/EntryFactoryImpl.java", "diffHunk": "@@ -84,7 +85,7 @@ public void init() {\n             }\n          } else if (isOwner || readEntry.isL1Entry()) {\n             if (readEntry.canExpire()) {\n-               CompletionStage<Boolean> expiredStage = expirationManager.handlePossibleExpiration(readEntry, segment, false);\n+               CompletionStage<Boolean> expiredStage = expirationManager.handlePossibleExpiration(readEntry, segment, hasLock);", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc2ODUwMw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496768503", "bodyText": "It doesn't skip the max-idle expiration check. What it does is change the flags on the cache that the remove (max idle | lifespan) expired command is invoked on. For pessimistic transactions if it already has the lock we can't fire the expiration command and get a lock as it is already held.\nhttps://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/expiration/impl/TxClusterExpirationManager.java#L37", "author": "wburns", "createdAt": "2020-09-29T14:33:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNDgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkwNjk1NA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496906954", "bodyText": "I'm looking at https://github.com/infinispan/infinispan/blob/master/core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java#L261\nin pessimistic cache, checkExpiredMaxIdle(ice, segment) isn't invoked because isWrite==true", "author": "pruivo", "createdAt": "2020-09-29T17:15:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNDgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkwNzk3NA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496907974", "bodyText": "That is because the entry wasn't expired. In this case we don't want to touch the entry on a write as it will be overwritten anyways.", "author": "wburns", "createdAt": "2020-09-29T17:17:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNDgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzMTE0Ng==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496931146", "bodyText": "yeah, but a get+force_write_lock doesn't mean the key will be written in the transaction. Not sure if I'm making my concern clear...", "author": "pruivo", "createdAt": "2020-09-29T17:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNDgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQxMzM3Ng==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r497413376", "bodyText": "I made the following test: https://github.com/pruivo/infinispan/blob/8d5d98492df393c344fe2707dcd12dcf7498464f/core/src/test/java/org/infinispan/expiration/impl/MaxIdlePessimisticTxTest.java\n\ntx read + rollback, touches the key (it makes senses IMO)\ntx write + rollback, doesn't touch the key (it should IMO)\ntx read on expired key +  rollback, StackOverflowException (bug!) org.infinispan.expiration.impl.ClusterExpirationManager.entryExpiredInMemory\ntx write on expired key +  rollback, it is fine!", "author": "pruivo", "createdAt": "2020-09-30T10:43:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNDgyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxMTIyMA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r498311220", "bodyText": "So I am changing my mind on #2. Originally max idle didn't block the user read operation, but now it does so I don't believe it makes any sense any longer.\n#3 is because we need to pass the hasLock variable on a read when using Pessimistic tx with WRITE_LOCK flag present. So it isn't just any tx read :)", "author": "wburns", "createdAt": "2020-10-01T14:58:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNDgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNTQ0Ng==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496205446", "bodyText": "segment=0 here too. same comment as somewhere above :)", "author": "pruivo", "createdAt": "2020-09-28T20:13:17Z", "path": "core/src/main/java/org/infinispan/container/offheap/OffHeapDataContainer.java", "diffHunk": "@@ -107,4 +108,9 @@ public int sizeIncludingExpired() {\n    public void clear() {\n       map.clear();\n    }\n+\n+   @Override\n+   public void forEachSegment(ObjIntConsumer<PeekableTouchableMap<WrappedBytes, WrappedBytes>> segmentMapConsumer) {\n+      segmentMapConsumer.accept(map, 0);", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc2ODc1NA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496768754", "bodyText": "I think 0 is the correct value as this is what we do for other cases when we don't have segmentation.", "author": "wburns", "createdAt": "2020-09-29T14:34:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNTQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwNjM5MA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496206390", "bodyText": "typo:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               private Map<String, TopologyIracVersion> getVectorFunctiton(Integer s,\n          \n          \n            \n               private Map<String, TopologyIracVersion> getVectorFunction(Integer s,", "author": "pruivo", "createdAt": "2020-09-28T20:15:15Z", "path": "core/src/main/java/org/infinispan/container/versioning/irac/DefaultIracVersionGenerator.java", "diffHunk": "@@ -112,6 +118,15 @@ public void removeTombstone(Object key) {\n       }\n    }\n \n+   private Map<String, TopologyIracVersion> getVectorFunctiton(Integer s,", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwODY5MQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496208691", "bodyText": "hmm, I thought the cache stored in ComponentRegistry didn't have any encoding...", "author": "pruivo", "createdAt": "2020-09-28T20:20:02Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java", "diffHunk": "@@ -99,6 +88,9 @@ public void start() {\n                   expWakeUpInt, expWakeUpInt, TimeUnit.MILLISECONDS);\n          }\n       }\n+      // Data container entries are retrieved directly, so we don't need to worry about an encodings\n+      this.cache = AbstractDelegatingCache.unwrapCache(cacheRef.wired()).getAdvancedCache();", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3MDgzMw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496770833", "bodyText": "It used to, believe it still does. This was just moved over from the ClusterExpirationManager as they both use the cache instance now.", "author": "wburns", "createdAt": "2020-09-29T14:36:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIwODY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxMjYyMQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496212621", "bodyText": "why? this will trigger unnecessary replication and xsite replications.", "author": "pruivo", "createdAt": "2020-09-28T20:27:56Z", "path": "core/src/main/java/org/infinispan/interceptors/impl/CallInterceptor.java", "diffHunk": "@@ -592,8 +593,11 @@ public Object visitRemoveExpiredCommand(InvocationContext ctx, RemoveExpiredComm\n          } else if (trace) {\n             log.trace(\"Cannot remove entry as its lifespan or value do not match\");\n          }\n-      } else if (trace) {\n-         log.trace(\"Nothing to remove since the entry doesn't exist in the context or it is already removed\");\n+      } else {\n+         if (trace) {\n+            log.trace(\"Nothing to remove since the entry doesn't exist in the context or it is already removed - assume command was successful\");", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3MTY3OQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496771679", "bodyText": "We don't want to let something like an eviction to cause the expiration command to fail. If the value isn't present we have to assume it can be expired.", "author": "wburns", "createdAt": "2020-09-29T14:37:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxMjYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNDI0MQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496214241", "bodyText": "why returning Boolean.FALSE? it is something I'm not used to seeing very often.", "author": "pruivo", "createdAt": "2020-09-28T20:30:59Z", "path": "core/src/main/java/org/infinispan/interceptors/impl/CallInterceptor.java", "diffHunk": "@@ -1115,6 +1119,32 @@ public Object visitReadWriteManyEntriesCommand(InvocationContext ctx, ReadWriteM\n       return returns;\n    }\n \n+   @Override\n+   public Object visitTouchCommand(InvocationContext ctx, TouchCommand command) throws Throwable {\n+      int segment = command.getSegment();\n+      Object key = command.getKey();\n+      InternalCacheEntry<?, ?> ice = dataContainer.peek(segment, key);\n+      if (ice == null) {\n+         if (trace) {\n+            log.tracef(\"Entry was not in the container to touch for key %s\", key);\n+         }\n+         return Boolean.FALSE;", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3MTk5MA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496771990", "bodyText": "It will be boxed anyways, may as well be explicit :)", "author": "wburns", "createdAt": "2020-09-29T14:38:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNDI0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNTU0OA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496215548", "bodyText": "I'm wondering if we could invoke touch() directly to avoid multiple gets (get segment map and get key twice)", "author": "pruivo", "createdAt": "2020-09-28T20:33:34Z", "path": "core/src/main/java/org/infinispan/interceptors/impl/CallInterceptor.java", "diffHunk": "@@ -1115,6 +1119,32 @@ public Object visitReadWriteManyEntriesCommand(InvocationContext ctx, ReadWriteM\n       return returns;\n    }\n \n+   @Override\n+   public Object visitTouchCommand(InvocationContext ctx, TouchCommand command) throws Throwable {\n+      int segment = command.getSegment();\n+      Object key = command.getKey();\n+      InternalCacheEntry<?, ?> ice = dataContainer.peek(segment, key);", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3MzAyMw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496773023", "bodyText": "No, unfortunately. We don't want to touch in the case of isTouchEvenIfExpired is false. We could have different code paths where if this is true we just call peek if you really wanted though.", "author": "wburns", "createdAt": "2020-09-29T14:39:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNTU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkwODc0Mg==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496908742", "bodyText": "isTouchEvenIfExpired could be a parameter :)", "author": "pruivo", "createdAt": "2020-09-29T17:18:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNTU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxMDA1Mg==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496910052", "bodyText": "Hrmm? It is in the TouchCommand.", "author": "wburns", "createdAt": "2020-09-29T17:20:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNTU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzMDQ1NA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496930454", "bodyText": "I mean DataContainer.touch(segment, key, currentTime,command.isTouchEvenIfExpired())", "author": "pruivo", "createdAt": "2020-09-29T17:53:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNTU0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzNjY0NA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496936644", "bodyText": "Hrmm, sure, that could work.", "author": "wburns", "createdAt": "2020-09-29T18:04:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNTU0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNzI1Mg==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496217252", "bodyText": "hmmm, I still think it should use the IracMetadata stored in the context's CacheEntry\nEven if \"this key\" isn't changed, the segment version will always move.", "author": "pruivo", "createdAt": "2020-09-28T20:36:49Z", "path": "core/src/main/java/org/infinispan/interceptors/impl/NonTxIracLocalSiteInterceptor.java", "diffHunk": "@@ -194,7 +189,13 @@ private void visitKey(Object key, WriteCommand command) {\n       if (getOwnership(segment) != Ownership.PRIMARY) {\n          return;\n       }\n-      IracMetadata metadata = iracVersionGenerator.generateNewMetadata(segment);\n+      IracMetadata metadata;\n+      // RemoveExpired should lose to any other conflicting write\n+      if (command instanceof RemoveExpiredCommand) {\n+         metadata = iracVersionGenerator.generateMetadataWithCurrentVersion(segment);", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgzNDQ3NQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496834475", "bodyText": "I have done a mixture, because unfortunately with eviction it is possible the entry is not in the container as well.", "author": "wburns", "createdAt": "2020-09-29T15:47:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxNzI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxOTI1OQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496219259", "bodyText": "Use the handleExpiredReturn field and the rCommand\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                           return invokeNextThenAccept(rCtx, command, this::handleExpiredReturn);\n          \n          \n            \n                           return invokeNextThenAccept(rCtx, rCommand, handleExpiredReturn);", "author": "pruivo", "createdAt": "2020-09-28T20:40:44Z", "path": "core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java", "diffHunk": "@@ -51,6 +56,38 @@ Object invokeNextAndWaitForCrossSite(TxInvocationContext<?> ctx, VisitableComman\n       return invokeNextThenApply(ctx, command, stage::thenReturn);\n    }\n \n+   @Override\n+   public Object visitRemoveExpiredCommand(InvocationContext ctx, RemoveExpiredCommand command) {\n+      if (skipXSiteBackup(command) || !command.isMaxIdle()) {\n+         return invokeNext(ctx, command);\n+      }\n+      // Max idle command shouldn't fail as the timestamps are updated on access, however the remote site may have\n+      // a read that we aren't aware of - so we must synchronously remove the entry if expired on the remote site\n+      // and if it isn't expired on the remote site we must update the access time locally here\n+      int segment = command.getSegment();\n+      DistributionInfo dInfo = clusteringDependentLogic.getCacheTopology().getSegmentDistribution(segment);\n+      // Only require primary to check remote site and add to irac queue - If primary dies then a backup will end up\n+      // doing the same as promoted primary - We also don't add tracked up to backup as we don't care if the\n+      // remove expired is lost due to topology change it just will cause another check later but maintain consistency\n+      if (dInfo.isPrimary()) {\n+         CompletionStage<Boolean> expired = iracManager.checkAndTrackExpiration(command.getKey());\n+         return asyncValue(expired).thenApply(ctx, command, (rCtx, rCommand, rv) -> {\n+            if ((Boolean) rv) {\n+               return invokeNextThenAccept(rCtx, command, this::handleExpiredReturn);", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3NDE4Ng==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496774186", "bodyText": "Did you want me to make the lambda an object as well? :D I personally don't think it is worth it as this shouldn't happen that often.", "author": "wburns", "createdAt": "2020-09-29T14:40:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxOTI1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3NDc1MQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496774751", "bodyText": "Oh you mention that below :)", "author": "wburns", "createdAt": "2020-09-29T14:41:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxOTI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxOTM1NQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496219355", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        command.fail();\n          \n          \n            \n                        rCommand.fail();", "author": "pruivo", "createdAt": "2020-09-28T20:40:56Z", "path": "core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java", "diffHunk": "@@ -51,6 +56,38 @@ Object invokeNextAndWaitForCrossSite(TxInvocationContext<?> ctx, VisitableComman\n       return invokeNextThenApply(ctx, command, stage::thenReturn);\n    }\n \n+   @Override\n+   public Object visitRemoveExpiredCommand(InvocationContext ctx, RemoveExpiredCommand command) {\n+      if (skipXSiteBackup(command) || !command.isMaxIdle()) {\n+         return invokeNext(ctx, command);\n+      }\n+      // Max idle command shouldn't fail as the timestamps are updated on access, however the remote site may have\n+      // a read that we aren't aware of - so we must synchronously remove the entry if expired on the remote site\n+      // and if it isn't expired on the remote site we must update the access time locally here\n+      int segment = command.getSegment();\n+      DistributionInfo dInfo = clusteringDependentLogic.getCacheTopology().getSegmentDistribution(segment);\n+      // Only require primary to check remote site and add to irac queue - If primary dies then a backup will end up\n+      // doing the same as promoted primary - We also don't add tracked up to backup as we don't care if the\n+      // remove expired is lost due to topology change it just will cause another check later but maintain consistency\n+      if (dInfo.isPrimary()) {\n+         CompletionStage<Boolean> expired = iracManager.checkAndTrackExpiration(command.getKey());\n+         return asyncValue(expired).thenApply(ctx, command, (rCtx, rCommand, rv) -> {\n+            if ((Boolean) rv) {\n+               return invokeNextThenAccept(rCtx, command, this::handleExpiredReturn);\n+            }\n+            command.fail();", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxOTYwNw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496219607", "bodyText": "this lambda could be cached", "author": "pruivo", "createdAt": "2020-09-28T20:41:27Z", "path": "core/src/main/java/org/infinispan/interceptors/xsite/BaseBackupInterceptor.java", "diffHunk": "@@ -51,6 +56,38 @@ Object invokeNextAndWaitForCrossSite(TxInvocationContext<?> ctx, VisitableComman\n       return invokeNextThenApply(ctx, command, stage::thenReturn);\n    }\n \n+   @Override\n+   public Object visitRemoveExpiredCommand(InvocationContext ctx, RemoveExpiredCommand command) {\n+      if (skipXSiteBackup(command) || !command.isMaxIdle()) {\n+         return invokeNext(ctx, command);\n+      }\n+      // Max idle command shouldn't fail as the timestamps are updated on access, however the remote site may have\n+      // a read that we aren't aware of - so we must synchronously remove the entry if expired on the remote site\n+      // and if it isn't expired on the remote site we must update the access time locally here\n+      int segment = command.getSegment();\n+      DistributionInfo dInfo = clusteringDependentLogic.getCacheTopology().getSegmentDistribution(segment);\n+      // Only require primary to check remote site and add to irac queue - If primary dies then a backup will end up\n+      // doing the same as promoted primary - We also don't add tracked up to backup as we don't care if the\n+      // remove expired is lost due to topology change it just will cause another check later but maintain consistency\n+      if (dInfo.isPrimary()) {\n+         CompletionStage<Boolean> expired = iracManager.checkAndTrackExpiration(command.getKey());\n+         return asyncValue(expired).thenApply(ctx, command, (rCtx, rCommand, rv) -> {", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4MDA3MA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496780070", "bodyText": "I personally don't think it is worth it given how infrequently it should be called, but I can add it in.", "author": "wburns", "createdAt": "2020-09-29T14:47:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIxOTYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyMzUxNA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496223514", "bodyText": "unused", "author": "pruivo", "createdAt": "2020-09-28T20:49:02Z", "path": "core/src/main/java/org/infinispan/xsite/status/DefaultTakeOfflineManager.java", "diffHunk": "@@ -52,6 +56,9 @@\n    @Inject Configuration config;\n    @Inject EventLogManager eventLogManager;\n    @Inject RpcManager rpcManager;\n+   @ComponentName(KnownComponentNames.NON_BLOCKING_EXECUTOR)\n+   @Inject Executor nonBlockingExecutor;", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyMzg1Nw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496223857", "bodyText": "you could have created a touchAll() and avoid some lambdas :)", "author": "pruivo", "createdAt": "2020-09-28T20:49:42Z", "path": "core/src/main/java/org/infinispan/xsite/status/DefaultTakeOfflineManager.java", "diffHunk": "@@ -197,6 +204,10 @@ public void siteOnline() {\n       @Override\n       public void siteOffline() {\n          getEventLogger().info(EventLogCategory.CLUSTER, MESSAGES.siteOffline(siteName));\n+         log.debug(\"Touching all in memory entries as a site has gone offline\");\n+         long currentTimeMillis = timeService.wallClockTime();\n+         dataContainer.forEachSegment((map, segment) ->", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc4MTkyMg==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496781922", "bodyText": "Hrmm, yeah we can add that to the PeekableTouchableMap interface :)", "author": "wburns", "createdAt": "2020-09-29T14:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyMzg1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNDUxNg==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496224516", "bodyText": "is this intentional? couldn't just invoke touch(key, -1, touchEvenIfExpired)", "author": "pruivo", "createdAt": "2020-09-28T20:51:01Z", "path": "core/src/test/java/org/infinispan/functional/decorators/FunctionalAdvancedCache.java", "diffHunk": "@@ -282,6 +282,16 @@ public void start() {\n       cache.start();\n    }\n \n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, int segment, boolean touchEvenIfExpired) {\n+      return cache.touch(key, segment, touchEvenIfExpired);\n+   }\n+\n+   @Override\n+   public CompletionStage<Boolean> touch(Object key, boolean touchEvenIfExpired) {\n+      return null;", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc5OTQwOQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496799409", "bodyText": "I changed it.", "author": "wburns", "createdAt": "2020-09-29T15:12:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNDUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNjk5MQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496226991", "bodyText": "why checking \"k\"?", "author": "pruivo", "createdAt": "2020-09-28T20:55:50Z", "path": "core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package org.infinispan.xsite;\n+\n+import static org.infinispan.test.TestingUtil.extractComponent;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNull;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.distribution.MagicKey;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.transaction.LockingMode;\n+import org.infinispan.util.ControlledTimeService;\n+import org.infinispan.util.concurrent.IsolationLevel;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * @author William Burns\n+ * @since 12.0\n+ */\n+@Test(groups = \"xsite\", testName = \"xsite.AsyncBackupExpirationTest\")\n+public class AsyncBackupExpirationTest extends AbstractTwoSitesTest {\n+\n+   private ConfigMode lonConfigMode;\n+   private ConfigMode nycConfigMode;\n+\n+   private static ConfigurationBuilder getConfig(ConfigMode configMode) {\n+      if (configMode == ConfigMode.NON_TX) {\n+         return getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      }\n+      ConfigurationBuilder builder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, true);\n+      switch (configMode) {\n+         case OPTIMISTIC_TX_RC:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.READ_COMMITTED);\n+            break;\n+         case OPTIMISTIC_TX_RR:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.REPEATABLE_READ);\n+            break;\n+         case PESSIMISTIC_TX:\n+            builder.transaction().lockingMode(LockingMode.PESSIMISTIC);\n+            break;\n+      }\n+      builder.expiration().wakeUpInterval(-1);\n+      return builder;\n+   }\n+\n+   @Override\n+   protected GlobalConfigurationBuilder globalConfigurationBuilderForSite(String siteName) {\n+      return super.globalConfigurationBuilderForSite(siteName);\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      List<AsyncBackupExpirationTest> tests = new LinkedList<>();\n+      for (ConfigMode lon : ConfigMode.values()) {\n+         for (ConfigMode nyc : ConfigMode.values()) {\n+            tests.add(new AsyncBackupExpirationTest().setLonConfigMode(lon).setNycConfigMode(nyc));\n+         }\n+      }\n+      return tests.toArray();\n+   }\n+\n+   @Override\n+   protected String[] parameterNames() {\n+      return new String[]{\"LON\", \"NYC\"};\n+   }\n+\n+   @Override\n+   protected Object[] parameterValues() {\n+      return new Object[]{lonConfigMode, nycConfigMode};\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getNycActiveConfig() {\n+      return getConfig(nycConfigMode);\n+   }\n+\n+   @BeforeMethod\n+   public void ensureSitesOnline() {\n+      // Now we take the backup offline - which should refresh our access times\n+      XSiteAdminOperations adminOperations = extractComponent(cache(LON, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(NYC))) {\n+         adminOperations.bringSiteOnline(NYC);\n+      }\n+\n+      adminOperations = extractComponent(cache(NYC, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(LON))) {\n+         adminOperations.bringSiteOnline(LON);\n+      }\n+   }\n+\n+   public AsyncBackupExpirationTest() {\n+      super.lonBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.nycBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.implicitBackupCache = true;\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getLonActiveConfig() {\n+      return getConfig(lonConfigMode);\n+   }\n+\n+   private AsyncBackupExpirationTest setLonConfigMode(ConfigMode configMode) {\n+      this.lonConfigMode = configMode;\n+      return this;\n+   }\n+\n+   private AsyncBackupExpirationTest setNycConfigMode(ConfigMode configMode) {\n+      this.nycConfigMode = configMode;\n+      return this;\n+   }\n+\n+   @DataProvider(name = \"two boolean cross product\")\n+   public Object[][] tx() {\n+      return new Object[][]{\n+            {false, false},\n+            {false, true},\n+            {true, false},\n+            {true, true}\n+      };\n+   }\n+\n+   private ControlledTimeService replaceTimeService() {\n+      ControlledTimeService timeService = new ControlledTimeService();\n+      // Max idle requires all caches to show it as expired to be removed.\n+      for (Cache<?, ?> c : caches(LON)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      for (Cache<?, ?> c : caches(NYC)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      return timeService;\n+   }\n+\n+   @Test(dataProvider = \"two boolean cross product\")\n+   public void testExpiredAccess(boolean lifespan, boolean readOnPrimary) throws InterruptedException {\n+      Cache<MagicKey, String> cache = cache(LON, 0);\n+\n+      ControlledTimeService timeService = replaceTimeService();\n+\n+      MagicKey key = readOnPrimary ? new MagicKey(cache) : new MagicKey(cache(LON, 1));\n+      if (lifespan) {\n+         cache.put(key, \"v\", 1, TimeUnit.SECONDS);\n+      } else {\n+         cache.put(key, \"v\", -1, TimeUnit.SECONDS, 1, TimeUnit.SECONDS);\n+      }\n+      eventuallyEquals(\"v\", () -> cache(LON, 0).get(key));\n+      eventuallyEquals(\"v\", () -> cache(LON, 1).get(key));\n+      Cache<Object, Object> backupCache = backup(LON);\n+      assertNull(backupCache.get(\"k\"));", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwMDM4OQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496800389", "bodyText": "Refactoring mistake, thought I had removed it.", "author": "wburns", "createdAt": "2020-09-29T15:13:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNjk5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNzI4Nw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496227287", "bodyText": "shouldn't check if backupCache also returns null?", "author": "pruivo", "createdAt": "2020-09-28T20:56:21Z", "path": "core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package org.infinispan.xsite;\n+\n+import static org.infinispan.test.TestingUtil.extractComponent;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNull;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.distribution.MagicKey;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.transaction.LockingMode;\n+import org.infinispan.util.ControlledTimeService;\n+import org.infinispan.util.concurrent.IsolationLevel;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * @author William Burns\n+ * @since 12.0\n+ */\n+@Test(groups = \"xsite\", testName = \"xsite.AsyncBackupExpirationTest\")\n+public class AsyncBackupExpirationTest extends AbstractTwoSitesTest {\n+\n+   private ConfigMode lonConfigMode;\n+   private ConfigMode nycConfigMode;\n+\n+   private static ConfigurationBuilder getConfig(ConfigMode configMode) {\n+      if (configMode == ConfigMode.NON_TX) {\n+         return getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      }\n+      ConfigurationBuilder builder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, true);\n+      switch (configMode) {\n+         case OPTIMISTIC_TX_RC:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.READ_COMMITTED);\n+            break;\n+         case OPTIMISTIC_TX_RR:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.REPEATABLE_READ);\n+            break;\n+         case PESSIMISTIC_TX:\n+            builder.transaction().lockingMode(LockingMode.PESSIMISTIC);\n+            break;\n+      }\n+      builder.expiration().wakeUpInterval(-1);\n+      return builder;\n+   }\n+\n+   @Override\n+   protected GlobalConfigurationBuilder globalConfigurationBuilderForSite(String siteName) {\n+      return super.globalConfigurationBuilderForSite(siteName);\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      List<AsyncBackupExpirationTest> tests = new LinkedList<>();\n+      for (ConfigMode lon : ConfigMode.values()) {\n+         for (ConfigMode nyc : ConfigMode.values()) {\n+            tests.add(new AsyncBackupExpirationTest().setLonConfigMode(lon).setNycConfigMode(nyc));\n+         }\n+      }\n+      return tests.toArray();\n+   }\n+\n+   @Override\n+   protected String[] parameterNames() {\n+      return new String[]{\"LON\", \"NYC\"};\n+   }\n+\n+   @Override\n+   protected Object[] parameterValues() {\n+      return new Object[]{lonConfigMode, nycConfigMode};\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getNycActiveConfig() {\n+      return getConfig(nycConfigMode);\n+   }\n+\n+   @BeforeMethod\n+   public void ensureSitesOnline() {\n+      // Now we take the backup offline - which should refresh our access times\n+      XSiteAdminOperations adminOperations = extractComponent(cache(LON, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(NYC))) {\n+         adminOperations.bringSiteOnline(NYC);\n+      }\n+\n+      adminOperations = extractComponent(cache(NYC, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(LON))) {\n+         adminOperations.bringSiteOnline(LON);\n+      }\n+   }\n+\n+   public AsyncBackupExpirationTest() {\n+      super.lonBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.nycBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.implicitBackupCache = true;\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getLonActiveConfig() {\n+      return getConfig(lonConfigMode);\n+   }\n+\n+   private AsyncBackupExpirationTest setLonConfigMode(ConfigMode configMode) {\n+      this.lonConfigMode = configMode;\n+      return this;\n+   }\n+\n+   private AsyncBackupExpirationTest setNycConfigMode(ConfigMode configMode) {\n+      this.nycConfigMode = configMode;\n+      return this;\n+   }\n+\n+   @DataProvider(name = \"two boolean cross product\")\n+   public Object[][] tx() {\n+      return new Object[][]{\n+            {false, false},\n+            {false, true},\n+            {true, false},\n+            {true, true}\n+      };\n+   }\n+\n+   private ControlledTimeService replaceTimeService() {\n+      ControlledTimeService timeService = new ControlledTimeService();\n+      // Max idle requires all caches to show it as expired to be removed.\n+      for (Cache<?, ?> c : caches(LON)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      for (Cache<?, ?> c : caches(NYC)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      return timeService;\n+   }\n+\n+   @Test(dataProvider = \"two boolean cross product\")\n+   public void testExpiredAccess(boolean lifespan, boolean readOnPrimary) throws InterruptedException {\n+      Cache<MagicKey, String> cache = cache(LON, 0);\n+\n+      ControlledTimeService timeService = replaceTimeService();\n+\n+      MagicKey key = readOnPrimary ? new MagicKey(cache) : new MagicKey(cache(LON, 1));\n+      if (lifespan) {\n+         cache.put(key, \"v\", 1, TimeUnit.SECONDS);\n+      } else {\n+         cache.put(key, \"v\", -1, TimeUnit.SECONDS, 1, TimeUnit.SECONDS);\n+      }\n+      eventuallyEquals(\"v\", () -> cache(LON, 0).get(key));\n+      eventuallyEquals(\"v\", () -> cache(LON, 1).get(key));\n+      Cache<Object, Object> backupCache = backup(LON);\n+      assertNull(backupCache.get(\"k\"));\n+      eventuallyEquals(\"v\", () -> backup(LON).get(key));\n+\n+      // Now expire the entry\n+      timeService.advance(TimeUnit.SECONDS.toMillis(2));\n+      assertNull(cache.get(key));", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwMDg4OQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496800889", "bodyText": "Sure", "author": "wburns", "createdAt": "2020-09-29T15:14:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNzI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNzQ4Ng==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496227486", "bodyText": "InterruptedExceptionnever thrown", "author": "pruivo", "createdAt": "2020-09-28T20:56:43Z", "path": "core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package org.infinispan.xsite;\n+\n+import static org.infinispan.test.TestingUtil.extractComponent;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNull;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.distribution.MagicKey;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.transaction.LockingMode;\n+import org.infinispan.util.ControlledTimeService;\n+import org.infinispan.util.concurrent.IsolationLevel;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * @author William Burns\n+ * @since 12.0\n+ */\n+@Test(groups = \"xsite\", testName = \"xsite.AsyncBackupExpirationTest\")\n+public class AsyncBackupExpirationTest extends AbstractTwoSitesTest {\n+\n+   private ConfigMode lonConfigMode;\n+   private ConfigMode nycConfigMode;\n+\n+   private static ConfigurationBuilder getConfig(ConfigMode configMode) {\n+      if (configMode == ConfigMode.NON_TX) {\n+         return getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      }\n+      ConfigurationBuilder builder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, true);\n+      switch (configMode) {\n+         case OPTIMISTIC_TX_RC:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.READ_COMMITTED);\n+            break;\n+         case OPTIMISTIC_TX_RR:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.REPEATABLE_READ);\n+            break;\n+         case PESSIMISTIC_TX:\n+            builder.transaction().lockingMode(LockingMode.PESSIMISTIC);\n+            break;\n+      }\n+      builder.expiration().wakeUpInterval(-1);\n+      return builder;\n+   }\n+\n+   @Override\n+   protected GlobalConfigurationBuilder globalConfigurationBuilderForSite(String siteName) {\n+      return super.globalConfigurationBuilderForSite(siteName);\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      List<AsyncBackupExpirationTest> tests = new LinkedList<>();\n+      for (ConfigMode lon : ConfigMode.values()) {\n+         for (ConfigMode nyc : ConfigMode.values()) {\n+            tests.add(new AsyncBackupExpirationTest().setLonConfigMode(lon).setNycConfigMode(nyc));\n+         }\n+      }\n+      return tests.toArray();\n+   }\n+\n+   @Override\n+   protected String[] parameterNames() {\n+      return new String[]{\"LON\", \"NYC\"};\n+   }\n+\n+   @Override\n+   protected Object[] parameterValues() {\n+      return new Object[]{lonConfigMode, nycConfigMode};\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getNycActiveConfig() {\n+      return getConfig(nycConfigMode);\n+   }\n+\n+   @BeforeMethod\n+   public void ensureSitesOnline() {\n+      // Now we take the backup offline - which should refresh our access times\n+      XSiteAdminOperations adminOperations = extractComponent(cache(LON, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(NYC))) {\n+         adminOperations.bringSiteOnline(NYC);\n+      }\n+\n+      adminOperations = extractComponent(cache(NYC, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(LON))) {\n+         adminOperations.bringSiteOnline(LON);\n+      }\n+   }\n+\n+   public AsyncBackupExpirationTest() {\n+      super.lonBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.nycBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.implicitBackupCache = true;\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getLonActiveConfig() {\n+      return getConfig(lonConfigMode);\n+   }\n+\n+   private AsyncBackupExpirationTest setLonConfigMode(ConfigMode configMode) {\n+      this.lonConfigMode = configMode;\n+      return this;\n+   }\n+\n+   private AsyncBackupExpirationTest setNycConfigMode(ConfigMode configMode) {\n+      this.nycConfigMode = configMode;\n+      return this;\n+   }\n+\n+   @DataProvider(name = \"two boolean cross product\")\n+   public Object[][] tx() {\n+      return new Object[][]{\n+            {false, false},\n+            {false, true},\n+            {true, false},\n+            {true, true}\n+      };\n+   }\n+\n+   private ControlledTimeService replaceTimeService() {\n+      ControlledTimeService timeService = new ControlledTimeService();\n+      // Max idle requires all caches to show it as expired to be removed.\n+      for (Cache<?, ?> c : caches(LON)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      for (Cache<?, ?> c : caches(NYC)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      return timeService;\n+   }\n+\n+   @Test(dataProvider = \"two boolean cross product\")\n+   public void testExpiredAccess(boolean lifespan, boolean readOnPrimary) throws InterruptedException {", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIyNzU1Mw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496227553", "bodyText": "InterruptedExceptionnever thrown", "author": "pruivo", "createdAt": "2020-09-28T20:56:50Z", "path": "core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package org.infinispan.xsite;\n+\n+import static org.infinispan.test.TestingUtil.extractComponent;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNull;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.distribution.MagicKey;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.transaction.LockingMode;\n+import org.infinispan.util.ControlledTimeService;\n+import org.infinispan.util.concurrent.IsolationLevel;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * @author William Burns\n+ * @since 12.0\n+ */\n+@Test(groups = \"xsite\", testName = \"xsite.AsyncBackupExpirationTest\")\n+public class AsyncBackupExpirationTest extends AbstractTwoSitesTest {\n+\n+   private ConfigMode lonConfigMode;\n+   private ConfigMode nycConfigMode;\n+\n+   private static ConfigurationBuilder getConfig(ConfigMode configMode) {\n+      if (configMode == ConfigMode.NON_TX) {\n+         return getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      }\n+      ConfigurationBuilder builder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, true);\n+      switch (configMode) {\n+         case OPTIMISTIC_TX_RC:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.READ_COMMITTED);\n+            break;\n+         case OPTIMISTIC_TX_RR:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.REPEATABLE_READ);\n+            break;\n+         case PESSIMISTIC_TX:\n+            builder.transaction().lockingMode(LockingMode.PESSIMISTIC);\n+            break;\n+      }\n+      builder.expiration().wakeUpInterval(-1);\n+      return builder;\n+   }\n+\n+   @Override\n+   protected GlobalConfigurationBuilder globalConfigurationBuilderForSite(String siteName) {\n+      return super.globalConfigurationBuilderForSite(siteName);\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      List<AsyncBackupExpirationTest> tests = new LinkedList<>();\n+      for (ConfigMode lon : ConfigMode.values()) {\n+         for (ConfigMode nyc : ConfigMode.values()) {\n+            tests.add(new AsyncBackupExpirationTest().setLonConfigMode(lon).setNycConfigMode(nyc));\n+         }\n+      }\n+      return tests.toArray();\n+   }\n+\n+   @Override\n+   protected String[] parameterNames() {\n+      return new String[]{\"LON\", \"NYC\"};\n+   }\n+\n+   @Override\n+   protected Object[] parameterValues() {\n+      return new Object[]{lonConfigMode, nycConfigMode};\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getNycActiveConfig() {\n+      return getConfig(nycConfigMode);\n+   }\n+\n+   @BeforeMethod\n+   public void ensureSitesOnline() {\n+      // Now we take the backup offline - which should refresh our access times\n+      XSiteAdminOperations adminOperations = extractComponent(cache(LON, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(NYC))) {\n+         adminOperations.bringSiteOnline(NYC);\n+      }\n+\n+      adminOperations = extractComponent(cache(NYC, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(LON))) {\n+         adminOperations.bringSiteOnline(LON);\n+      }\n+   }\n+\n+   public AsyncBackupExpirationTest() {\n+      super.lonBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.nycBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.implicitBackupCache = true;\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getLonActiveConfig() {\n+      return getConfig(lonConfigMode);\n+   }\n+\n+   private AsyncBackupExpirationTest setLonConfigMode(ConfigMode configMode) {\n+      this.lonConfigMode = configMode;\n+      return this;\n+   }\n+\n+   private AsyncBackupExpirationTest setNycConfigMode(ConfigMode configMode) {\n+      this.nycConfigMode = configMode;\n+      return this;\n+   }\n+\n+   @DataProvider(name = \"two boolean cross product\")\n+   public Object[][] tx() {\n+      return new Object[][]{\n+            {false, false},\n+            {false, true},\n+            {true, false},\n+            {true, true}\n+      };\n+   }\n+\n+   private ControlledTimeService replaceTimeService() {\n+      ControlledTimeService timeService = new ControlledTimeService();\n+      // Max idle requires all caches to show it as expired to be removed.\n+      for (Cache<?, ?> c : caches(LON)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      for (Cache<?, ?> c : caches(NYC)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      return timeService;\n+   }\n+\n+   @Test(dataProvider = \"two boolean cross product\")\n+   public void testExpiredAccess(boolean lifespan, boolean readOnPrimary) throws InterruptedException {\n+      Cache<MagicKey, String> cache = cache(LON, 0);\n+\n+      ControlledTimeService timeService = replaceTimeService();\n+\n+      MagicKey key = readOnPrimary ? new MagicKey(cache) : new MagicKey(cache(LON, 1));\n+      if (lifespan) {\n+         cache.put(key, \"v\", 1, TimeUnit.SECONDS);\n+      } else {\n+         cache.put(key, \"v\", -1, TimeUnit.SECONDS, 1, TimeUnit.SECONDS);\n+      }\n+      eventuallyEquals(\"v\", () -> cache(LON, 0).get(key));\n+      eventuallyEquals(\"v\", () -> cache(LON, 1).get(key));\n+      Cache<Object, Object> backupCache = backup(LON);\n+      assertNull(backupCache.get(\"k\"));\n+      eventuallyEquals(\"v\", () -> backup(LON).get(key));\n+\n+      // Now expire the entry\n+      timeService.advance(TimeUnit.SECONDS.toMillis(2));\n+      assertNull(cache.get(key));\n+\n+      // TODO: check for the touch command being invoked on the remote site for lifespan = false\n+   }\n+\n+   @Test(dataProvider = \"two boolean cross product\")\n+   public void testMaxIdleWithRecentAccess(boolean readFromWrittenSite, boolean readOnAccessedSite) throws InterruptedException {", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzMDYwMA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496230600", "bodyText": "actually, I would inspect the DataContainer to ensure the InternalCacheEntry's lastUsed is the expected value", "author": "pruivo", "createdAt": "2020-09-28T21:02:40Z", "path": "core/src/test/java/org/infinispan/xsite/AsyncBackupExpirationTest.java", "diffHunk": "@@ -0,0 +1,260 @@\n+package org.infinispan.xsite;\n+\n+import static org.infinispan.test.TestingUtil.extractComponent;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertNull;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.configuration.cache.BackupConfiguration;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.configuration.global.GlobalConfigurationBuilder;\n+import org.infinispan.distribution.MagicKey;\n+import org.infinispan.test.TestingUtil;\n+import org.infinispan.transaction.LockingMode;\n+import org.infinispan.util.ControlledTimeService;\n+import org.infinispan.util.concurrent.IsolationLevel;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Factory;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * @author William Burns\n+ * @since 12.0\n+ */\n+@Test(groups = \"xsite\", testName = \"xsite.AsyncBackupExpirationTest\")\n+public class AsyncBackupExpirationTest extends AbstractTwoSitesTest {\n+\n+   private ConfigMode lonConfigMode;\n+   private ConfigMode nycConfigMode;\n+\n+   private static ConfigurationBuilder getConfig(ConfigMode configMode) {\n+      if (configMode == ConfigMode.NON_TX) {\n+         return getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, false);\n+      }\n+      ConfigurationBuilder builder = getDefaultClusteredCacheConfig(CacheMode.DIST_SYNC, true);\n+      switch (configMode) {\n+         case OPTIMISTIC_TX_RC:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.READ_COMMITTED);\n+            break;\n+         case OPTIMISTIC_TX_RR:\n+            builder.transaction().lockingMode(LockingMode.OPTIMISTIC);\n+            builder.locking().isolationLevel(IsolationLevel.REPEATABLE_READ);\n+            break;\n+         case PESSIMISTIC_TX:\n+            builder.transaction().lockingMode(LockingMode.PESSIMISTIC);\n+            break;\n+      }\n+      builder.expiration().wakeUpInterval(-1);\n+      return builder;\n+   }\n+\n+   @Override\n+   protected GlobalConfigurationBuilder globalConfigurationBuilderForSite(String siteName) {\n+      return super.globalConfigurationBuilderForSite(siteName);\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      List<AsyncBackupExpirationTest> tests = new LinkedList<>();\n+      for (ConfigMode lon : ConfigMode.values()) {\n+         for (ConfigMode nyc : ConfigMode.values()) {\n+            tests.add(new AsyncBackupExpirationTest().setLonConfigMode(lon).setNycConfigMode(nyc));\n+         }\n+      }\n+      return tests.toArray();\n+   }\n+\n+   @Override\n+   protected String[] parameterNames() {\n+      return new String[]{\"LON\", \"NYC\"};\n+   }\n+\n+   @Override\n+   protected Object[] parameterValues() {\n+      return new Object[]{lonConfigMode, nycConfigMode};\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getNycActiveConfig() {\n+      return getConfig(nycConfigMode);\n+   }\n+\n+   @BeforeMethod\n+   public void ensureSitesOnline() {\n+      // Now we take the backup offline - which should refresh our access times\n+      XSiteAdminOperations adminOperations = extractComponent(cache(LON, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(NYC))) {\n+         adminOperations.bringSiteOnline(NYC);\n+      }\n+\n+      adminOperations = extractComponent(cache(NYC, 0), XSiteAdminOperations.class);\n+      if (XSiteAdminOperations.OFFLINE.equals(adminOperations.siteStatus(LON))) {\n+         adminOperations.bringSiteOnline(LON);\n+      }\n+   }\n+\n+   public AsyncBackupExpirationTest() {\n+      super.lonBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.nycBackupStrategy = BackupConfiguration.BackupStrategy.ASYNC;\n+      super.implicitBackupCache = true;\n+   }\n+\n+   @Override\n+   protected ConfigurationBuilder getLonActiveConfig() {\n+      return getConfig(lonConfigMode);\n+   }\n+\n+   private AsyncBackupExpirationTest setLonConfigMode(ConfigMode configMode) {\n+      this.lonConfigMode = configMode;\n+      return this;\n+   }\n+\n+   private AsyncBackupExpirationTest setNycConfigMode(ConfigMode configMode) {\n+      this.nycConfigMode = configMode;\n+      return this;\n+   }\n+\n+   @DataProvider(name = \"two boolean cross product\")\n+   public Object[][] tx() {\n+      return new Object[][]{\n+            {false, false},\n+            {false, true},\n+            {true, false},\n+            {true, true}\n+      };\n+   }\n+\n+   private ControlledTimeService replaceTimeService() {\n+      ControlledTimeService timeService = new ControlledTimeService();\n+      // Max idle requires all caches to show it as expired to be removed.\n+      for (Cache<?, ?> c : caches(LON)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      for (Cache<?, ?> c : caches(NYC)) {\n+         TestingUtil.replaceComponent(c.getCacheManager(), TimeService.class, timeService, true);\n+      }\n+\n+      return timeService;\n+   }\n+\n+   @Test(dataProvider = \"two boolean cross product\")\n+   public void testExpiredAccess(boolean lifespan, boolean readOnPrimary) throws InterruptedException {\n+      Cache<MagicKey, String> cache = cache(LON, 0);\n+\n+      ControlledTimeService timeService = replaceTimeService();\n+\n+      MagicKey key = readOnPrimary ? new MagicKey(cache) : new MagicKey(cache(LON, 1));\n+      if (lifespan) {\n+         cache.put(key, \"v\", 1, TimeUnit.SECONDS);\n+      } else {\n+         cache.put(key, \"v\", -1, TimeUnit.SECONDS, 1, TimeUnit.SECONDS);\n+      }\n+      eventuallyEquals(\"v\", () -> cache(LON, 0).get(key));\n+      eventuallyEquals(\"v\", () -> cache(LON, 1).get(key));\n+      Cache<Object, Object> backupCache = backup(LON);\n+      assertNull(backupCache.get(\"k\"));\n+      eventuallyEquals(\"v\", () -> backup(LON).get(key));\n+\n+      // Now expire the entry\n+      timeService.advance(TimeUnit.SECONDS.toMillis(2));\n+      assertNull(cache.get(key));\n+\n+      // TODO: check for the touch command being invoked on the remote site for lifespan = false", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwMzY2OQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496803669", "bodyText": "Yeah, that is what I meant by it actually.", "author": "wburns", "createdAt": "2020-09-29T15:17:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzMDYwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxNTM5OA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496815398", "bodyText": "I moved it up a bit before the expiration to verify the last access was correct.", "author": "wburns", "createdAt": "2020-09-29T15:29:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzMDYwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzMjk2MQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496232961", "bodyText": "what does sync/async mean here? the xsite is async only in this class.", "author": "pruivo", "createdAt": "2020-09-28T21:07:15Z", "path": "core/src/test/java/org/infinispan/xsite/irac/Irac3SitesConflictTest.java", "diffHunk": "@@ -30,32 +37,159 @@\n    private static final int CLUSTER_SIZE = 3;\n    private final List<ManualIracManager> iracManagerList;\n \n+   private ConfigMode configMode;\n+\n+   public Irac3SitesConflictTest configMode(ConfigMode configMode) {\n+      this.configMode = configMode;\n+      return this;\n+   }\n+\n+   private enum ConfigMode {\n+      NON_TX,\n+      PESSIMISTIC_TX,\n+      OPTIMISTIC_TX_RC,\n+      OPTIMISTIC_TX_RR,\n+   }\n+\n+   @Factory\n+   public Object[] factory() {\n+      List<Irac3SitesConflictTest> tests = new ArrayList<>();\n+      for (ConfigMode configMode : ConfigMode.values()) {\n+         tests.add(new Irac3SitesConflictTest().configMode(configMode));\n+      }\n+      return tests.toArray();\n+   }\n+\n+   @Override\n+   protected String[] parameterNames() {\n+      return new String[]{\"configMode\"};\n+   }\n+\n+   @Override\n+   protected Object[] parameterValues() {\n+      return new Object[]{configMode};\n+   }\n+\n    protected Irac3SitesConflictTest() {\n       this.iracManagerList = new ArrayList<>(N_SITES * CLUSTER_SIZE);\n    }\n \n    public void testPutIfAbsent(Method method) {\n-      doTest(method, TestOperation.PUT_IF_ABSENT);\n+      doTest(method, new TestOperationInterop(TestOperation.PUT_IF_ABSENT));\n    }\n \n    public void testPut(Method method) {\n-      doTest(method, TestOperation.PUT);\n+      doTest(method, new TestOperationInterop(TestOperation.PUT));\n    }\n \n    public void testReplace(Method method) {\n-      doTest(method, TestOperation.REPLACE);\n+      doTest(method, new TestOperationInterop(TestOperation.REPLACE));\n    }\n \n    public void testConditionalReplace(Method method) {\n-      doTest(method, TestOperation.REPLACE_CONDITIONAL);\n+      doTest(method, new TestOperationInterop(TestOperation.REPLACE_CONDITIONAL));\n    }\n \n    public void testRemove(Method method) {\n-      doTest(method, TestOperation.REMOVE);\n+      doTest(method, new TestOperationInterop(TestOperation.REMOVE));\n    }\n \n    public void testConditionalRemove(Method method) {\n-      doTest(method, TestOperation.REMOVE_CONDITIONAL);\n+      doTest(method, new TestOperationInterop(TestOperation.REMOVE_CONDITIONAL));\n+   }\n+\n+   // TODO: need to do this still?\n+   //   public void testMaxIdleExpirationASync(Method method) {", "originalCommit": "405a8b2b22032e146866a8f8dca8515df4882200", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgwMTg3Nw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496801877", "bodyText": "I meant the remove expired command itself. The test waits for its completion. If it didn't then we could have a remove expired and other puts running concurrently.", "author": "wburns", "createdAt": "2020-09-29T15:15:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzMjk2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyOTMxMg==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496929312", "bodyText": "I'm not sure if it matters. the IracManager is blocking everything until the end. You don't have the remove/put going to the other sites.", "author": "pruivo", "createdAt": "2020-09-29T17:51:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzMjk2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzMjc3Mw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496932773", "bodyText": "It shouldn't block the invoking thread. It returns a CompletionStage.", "author": "wburns", "createdAt": "2020-09-29T17:57:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzMjk2MQ=="}], "type": "inlineReview"}, {"oid": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "url": "https://github.com/infinispan/infinispan/commit/65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "message": "rework comments", "committedDate": "2020-09-29T15:51:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxNTI4MA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496915280", "bodyText": "can be removed. it is available in super class", "author": "pruivo", "createdAt": "2020-09-29T17:29:02Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ClusterExpirationManager.java", "diffHunk": "@@ -70,21 +63,16 @@\n     */\n    private static final int MAX_CONCURRENT_EXPIRATIONS = 100;\n \n-   @Inject protected ComponentRef<AdvancedCache<K, V>> cacheRef;\n    @Inject protected RpcManager rpcManager;\n    @Inject protected DistributionManager distributionManager;\n \n-   protected AdvancedCache<K, V> cache;\n    private Address localAddress;\n    private long timeout;\n    private String cacheName;", "originalCommit": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyMjcxNA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496922714", "bodyText": "why do you need to wait for the remote operation? can't you return touchedLocally directly?", "author": "pruivo", "createdAt": "2020-09-29T17:41:11Z", "path": "core/src/main/java/org/infinispan/interceptors/impl/ClusteringInterceptor.java", "diffHunk": "@@ -34,6 +48,120 @@\n    @Inject protected InternalDataContainer dataContainer;\n    @Inject protected DistributionManager distributionManager;\n \n+   protected LocalizedCacheTopology checkTopologyId(TopologyAffectedCommand command) {\n+      LocalizedCacheTopology cacheTopology = distributionManager.getCacheTopology();\n+      int currentTopologyId = cacheTopology.getTopologyId();\n+      int cmdTopology = command.getTopologyId();\n+      if (command instanceof FlagAffectedCommand && ((((FlagAffectedCommand) command).hasAnyFlag(FlagBitSets.SKIP_OWNERSHIP_CHECK | FlagBitSets.CACHE_MODE_LOCAL)))) {\n+         getLog().tracef(\"Skipping topology check for command %s\", command);\n+         return cacheTopology;\n+      }\n+      if (trace) {\n+         getLog().tracef(\"Current topology %d, command topology %d\", currentTopologyId, cmdTopology);\n+      }\n+      if (cmdTopology >= 0 && currentTopologyId != cmdTopology) {\n+         throw OutdatedTopologyException.RETRY_NEXT_TOPOLOGY;\n+      }\n+      return cacheTopology;\n+   }\n+\n+   private static abstract class AbstractTouchResponseCollector extends ValidResponseCollector<Boolean> {\n+      @Override\n+      protected Boolean addTargetNotFound(Address sender) {\n+         throw OutdatedTopologyException.RETRY_NEXT_TOPOLOGY;\n+      }\n+\n+      @Override\n+      protected Boolean addException(Address sender, Exception exception) {\n+         if (exception instanceof CacheException) {\n+            throw (CacheException) exception;\n+         }\n+         throw new CacheException(exception);\n+      }\n+\n+      @Override\n+      protected final Boolean addValidResponse(Address sender, ValidResponse response) {\n+         return (Boolean) response.getResponseValue();\n+      }\n+\n+      abstract Boolean addBooleanResponse(Address sender, Boolean response);\n+   }\n+\n+   private static class ScatteredTouchResponseCollector extends AbstractTouchResponseCollector {\n+\n+      private static final ScatteredTouchResponseCollector INSTANCE = new ScatteredTouchResponseCollector();\n+\n+      @Override\n+      public Boolean finish() {\n+         // No other node was touched\n+         return Boolean.FALSE;\n+      }\n+\n+      @Override\n+      protected Boolean addBooleanResponse(Address sender, Boolean response) {\n+         if (response == Boolean.TRUE) {\n+            // Return early if any node touched the value - as SCATTERED only exists on a single backup!\n+            // TODO: what if the read was when one of the backups or primary died?\n+            return Boolean.TRUE;\n+         }\n+         return null;\n+      }\n+   }\n+\n+   private static class TouchResponseCollector extends AbstractTouchResponseCollector {\n+\n+      private static final TouchResponseCollector INSTANCE = new TouchResponseCollector();\n+\n+      @Override\n+      public Boolean finish() {\n+         // If all were touched, then the value isn't expired\n+         return Boolean.TRUE;\n+      }\n+\n+      @Override\n+      protected Boolean addBooleanResponse(Address sender, Boolean response) {\n+         if (response == Boolean.FALSE) {\n+            // Return early if any value wasn't touched!\n+            return Boolean.FALSE;\n+         }\n+         return null;\n+      }\n+   }\n+\n+   @Override\n+   public Object visitTouchCommand(InvocationContext ctx, TouchCommand command) throws Throwable {\n+      if (isLocalModeForced(command)) {\n+         return invokeNext(ctx, command);\n+      }\n+      LocalizedCacheTopology cacheTopology = checkTopologyId(command);\n+      DistributionInfo info = cacheTopology.getSegmentDistribution(command.getSegment());\n+\n+      if (info.isPrimary()) {\n+         boolean isScattered = cacheConfiguration.clustering().cacheMode().isScattered();\n+         // Scattered any node could be a backup, so we have to touch all members\n+         List<Address> owners = isScattered ? cacheTopology.getActualMembers() : info.readOwners();\n+         AbstractTouchResponseCollector collector = isScattered ? ScatteredTouchResponseCollector.INSTANCE :\n+               TouchResponseCollector.INSTANCE;\n+         CompletionStage<Boolean> remoteInvocation = rpcManager.invokeCommand(owners, command, collector,\n+               rpcManager.getSyncRpcOptions());\n+         return invokeNextThenApply(ctx, command, (rCtx, rCommand, rValue) -> {\n+            Boolean touchedLocally = (Boolean) rValue;\n+            Boolean collectedResponse = collector.addBooleanResponse(null, touchedLocally);\n+            if (collectedResponse != null) {\n+               return asyncValue(remoteInvocation.thenApply(ignore -> touchedLocally));", "originalCommit": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzNDU0OQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496934549", "bodyText": "It needs to be sync to maintain the cluster max idle guarantees that if a node goes down after a touch that it won't expire early.", "author": "wburns", "createdAt": "2020-09-29T18:00:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyMjcxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNDI5Mw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496924293", "bodyText": "I'm going to take some time to think about this... not 100% convinced eh eh\nalso, you could check iracVersionGenerator.getTombstone(key); before invoking the \"generate\" method", "author": "pruivo", "createdAt": "2020-09-29T17:43:43Z", "path": "core/src/main/java/org/infinispan/interceptors/impl/NonTxIracLocalSiteInterceptor.java", "diffHunk": "@@ -189,12 +186,26 @@ private boolean skipCommand(InvocationContext ctx, FlagAffectedCommand command)\n     * <p>\n     * The primary owner generates a new {@link IracMetadata} and stores it in the {@link WriteCommand}.\n     */\n-   private void visitKey(Object key, WriteCommand command) {\n+   private void visitKey(InvocationContext ctx, Object key, WriteCommand command) {\n       int segment = getSegment(command, key);\n       if (getOwnership(segment) != Ownership.PRIMARY) {\n          return;\n       }\n-      IracMetadata metadata = iracVersionGenerator.generateNewMetadata(segment);\n+      IracMetadata metadata = null;\n+      // RemoveExpired should lose to any other conflicting write\n+      if (command instanceof RemoveExpiredCommand) {\n+         CacheEntry<?, ?> ce = ctx.lookupEntry(key);\n+         PrivateMetadata pm = ce.getInternalMetadata();\n+         if (pm != null) {\n+            metadata = pm.iracMetadata();\n+         }\n+\n+         if (metadata == null) {\n+            metadata = iracVersionGenerator.generateMetadataWithCurrentVersion(segment);", "originalCommit": "65fd7fb8e6bd5e1baa1f3277ee521693d98bd8b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkzNDc1Nw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r496934757", "bodyText": "Sure, I trust you on it ;)", "author": "wburns", "createdAt": "2020-09-29T18:00:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNDI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzQzNTU2NQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r497435565", "bodyText": "I'm writing a test to make sure it is correct... but now I have a question. why do you need to send the remove to the remote site?\norg.infinispan.xsite.irac.IracManager#checkAndTrackExpiration() already makes sure the key is expired everywhere. You can avoid sending the remove expired to the remote site and let them expired the key locally when they access it (or by the expiration reaper?).\nAm I missing something?", "author": "pruivo", "createdAt": "2020-09-30T11:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNDI5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwNDgzNQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r498304835", "bodyText": "We technically don't have to, but it seemed better for us just to send a single IRAC remove expired command instead of waiting for the other site to see the value is expired then ask the original site if it is expired synchronously again.", "author": "wburns", "createdAt": "2020-10-01T14:49:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyNDI5Mw=="}], "type": "inlineReview"}, {"oid": "294f4f142999a94e8e025ae1b1aea1c89452f429", "url": "https://github.com/infinispan/infinispan/commit/294f4f142999a94e8e025ae1b1aea1c89452f429", "message": "second review comments", "committedDate": "2020-10-01T17:17:46Z", "type": "forcePushed"}, {"oid": "09e7d55e2cff05fc6c30bab0155fa0f046aabd14", "url": "https://github.com/infinispan/infinispan/commit/09e7d55e2cff05fc6c30bab0155fa0f046aabd14", "message": "second review comments", "committedDate": "2020-10-01T17:19:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc2NTg3MQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r498765871", "bodyText": "shouldn't touchEvenIfExpired be  false here?", "author": "pruivo", "createdAt": "2020-10-02T11:30:05Z", "path": "core/src/main/java/org/infinispan/expiration/impl/ExpirationManagerImpl.java", "diffHunk": "@@ -269,11 +261,11 @@ private void deleteFromStoresAndNotify(K key, V value, Metadata metadata, Privat\n     * or not, that is if it couldn't be touched - we assumed expired (as it was removed in some way).\n     * @param entry the entry to check expiration and touch\n     * @param segment the segment the entry maps to\n+    * @param currentTime the current time in milliseconds\n     * @return whether the entry was expired or not\n     */\n-   protected CompletionStage<Boolean> checkExpiredMaxIdle(InternalCacheEntry entry, int segment) {\n-      TouchCommand touchCommand = cf.running().buildTouchCommand(entry.getKey(), segment);\n-      CompletionStage<Boolean> future = (CompletionStage) touchCommand.invokeAsync(componentRegistry);\n+   protected CompletionStage<Boolean> checkExpiredMaxIdle(InternalCacheEntry entry, int segment, long currentTime) {\n+      CompletionStage<Boolean> future = cache.touch(entry.getKey(), segment, true);", "originalCommit": "09e7d55e2cff05fc6c30bab0155fa0f046aabd14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0NTEyNA==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r498845124", "bodyText": "No, it is to cover the edge case of the entry expiring between when we check and then actually touching. We just don't want to touch for things like the xsite max idle check.", "author": "wburns", "createdAt": "2020-10-02T14:08:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc2NTg3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc5NTk1Mg==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r498795952", "bodyText": "Actually, the comments are wrong (same comments, in all tests) :) my bad!\nNot sure you notice, but there is a test missing:\npruivo@1cdac79#diff-5932593a9461e5deec52370525a2cf35R144", "author": "pruivo", "createdAt": "2020-10-02T12:41:05Z", "path": "core/src/test/java/org/infinispan/expiration/impl/MaxIdlePessimisticTxTest.java", "diffHunk": "@@ -0,0 +1,181 @@\n+package org.infinispan.expiration.impl;\n+\n+import static org.infinispan.test.TestingUtil.extractComponent;\n+import static org.infinispan.test.TestingUtil.k;\n+import static org.infinispan.test.TestingUtil.replaceComponent;\n+import static org.infinispan.test.TestingUtil.v;\n+import static org.testng.AssertJUnit.assertEquals;\n+import static org.testng.AssertJUnit.assertFalse;\n+import static org.testng.AssertJUnit.assertNull;\n+import static org.testng.AssertJUnit.assertTrue;\n+import static org.testng.AssertJUnit.fail;\n+\n+import java.lang.reflect.Method;\n+import java.util.Objects;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Stream;\n+\n+import org.infinispan.Cache;\n+import org.infinispan.commons.time.TimeService;\n+import org.infinispan.configuration.cache.CacheMode;\n+import org.infinispan.configuration.cache.ConfigurationBuilder;\n+import org.infinispan.container.entries.InternalCacheEntry;\n+import org.infinispan.container.impl.InternalDataContainer;\n+import org.infinispan.context.Flag;\n+import org.infinispan.distribution.ch.KeyPartitioner;\n+import org.infinispan.interceptors.locking.ClusteringDependentLogic;\n+import org.infinispan.test.MultipleCacheManagersTest;\n+import org.infinispan.transaction.LockingMode;\n+import org.infinispan.util.ControlledTimeService;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Test to verify clustered max idle in a pessimistic transaction\n+ *\n+ * @author Pedro Ruivo\n+ * @since 12.0\n+ */\n+@Test(groups = \"functional\", testName = \"expiration.impl.MaxIdlePessimisticTxTest\")\n+public class MaxIdlePessimisticTxTest extends MultipleCacheManagersTest {\n+\n+   private static final int NUM_NODES = 3;\n+   private static final long MAX_IDLE = 10;\n+   private final ControlledTimeService timeService = new ControlledTimeService();\n+\n+   public void testWriteLock(Method method) throws Exception {\n+      final String key = k(method);\n+      final String value = v(method, 0);\n+      final String value2 = v(method, 1);\n+\n+\n+      Cache<String, String> cache = findNonOwnerCache(key);\n+      cache.put(key, value, -1, TimeUnit.SECONDS, MAX_IDLE, TimeUnit.MILLISECONDS);\n+\n+      long lastWallClock = timeService.wallClockTime();\n+      timeService.advance(MAX_IDLE - 1);\n+\n+      assertNotExpired(key);\n+      assertLastUsed(key, lastWallClock);\n+\n+      cache.getAdvancedCache().getTransactionManager().begin();\n+      assertEquals(value, cache.put(key, value2, -1, TimeUnit.SECONDS, MAX_IDLE, TimeUnit.MILLISECONDS));\n+      assertEquals(value2, cache.get(key));\n+      // rollback the transaction\n+      cache.getAdvancedCache().getTransactionManager().rollback();\n+\n+      lastWallClock = timeService.wallClockTime();\n+      assertNotExpired(key);\n+      assertLastUsed(key, lastWallClock);\n+\n+      // if the tx didn't touch the key, this advance should expire it", "originalCommit": "09e7d55e2cff05fc6c30bab0155fa0f046aabd14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0NjQzMQ==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r498846431", "bodyText": "Not sure you notice, but there is a test missing:\npruivo@1cdac79#diff-5932593a9461e5deec52370525a2cf35R144\n\nWeird, I copied the file directly, must have had two commits before?", "author": "wburns", "createdAt": "2020-10-02T14:11:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc5NTk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODg0ODg1Mw==", "url": "https://github.com/infinispan/infinispan/pull/8699#discussion_r498848853", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  // if the tx didn't touch the key, this advance should expire it\n          \n          \n            \n                  // the tx touches the key, this advance should not expire it", "author": "pruivo", "createdAt": "2020-10-02T14:15:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc5NTk1Mg=="}], "type": "inlineReview"}, {"oid": "e6ea97a47274016c08f1a5e9c83f184ba02a5638", "url": "https://github.com/infinispan/infinispan/commit/e6ea97a47274016c08f1a5e9c83f184ba02a5638", "message": "fixing hibernate test failures - touch now can delay completion on same thread", "committedDate": "2020-10-02T14:55:50Z", "type": "forcePushed"}, {"oid": "3690b0019376055e1eb1fa8fbe762f1d70f791be", "url": "https://github.com/infinispan/infinispan/commit/3690b0019376055e1eb1fa8fbe762f1d70f791be", "message": "Comment tweak, add in missing test and fix hibernate tests", "committedDate": "2020-10-02T14:56:30Z", "type": "forcePushed"}, {"oid": "7f23a1c66f11c1b07bb9f283c358f17b4695c955", "url": "https://github.com/infinispan/infinispan/commit/7f23a1c66f11c1b07bb9f283c358f17b4695c955", "message": "ISPN-11176 XSite Max Idle\n\n* Implements check other site upon max idle expiration found\n* Refreshes all entry access times upon site loss", "committedDate": "2020-10-05T15:53:50Z", "type": "commit"}, {"oid": "b6622335944dee7cc64b17febdf1515c5648434f", "url": "https://github.com/infinispan/infinispan/commit/b6622335944dee7cc64b17febdf1515c5648434f", "message": "ISPN-12337 Clustered Expiration can deadlock with Pessimistic Tx on a non owner", "committedDate": "2020-10-05T15:53:50Z", "type": "commit"}, {"oid": "9e8119e800120347114017874f58eecaa2fc69fa", "url": "https://github.com/infinispan/infinispan/commit/9e8119e800120347114017874f58eecaa2fc69fa", "message": "ISPN-11176 XSite Max Idle\n\n* Refactor touch to be a visitable command\n* Add Touch logic to interceptors", "committedDate": "2020-10-05T17:11:22Z", "type": "commit"}, {"oid": "9e8119e800120347114017874f58eecaa2fc69fa", "url": "https://github.com/infinispan/infinispan/commit/9e8119e800120347114017874f58eecaa2fc69fa", "message": "ISPN-11176 XSite Max Idle\n\n* Refactor touch to be a visitable command\n* Add Touch logic to interceptors", "committedDate": "2020-10-05T17:11:22Z", "type": "forcePushed"}]}