{"pr_number": 8385, "pr_title": "ISPN-11896 non blocking cache store SPI docs", "pr_createdAt": "2020-05-25T15:38:42Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8385", "timeline": [{"oid": "66376032cb3c2a209962460bbe8a476728f63a5d", "url": "https://github.com/infinispan/infinispan/commit/66376032cb3c2a209962460bbe8a476728f63a5d", "message": "ISPN-11896 non blocking cache store SPI docs", "committedDate": "2020-05-25T15:41:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk5NzcxMw==", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r429997713", "bodyText": "@wburns here do we lose meaning if we change \"signals\" to \"indicates\"? or is \"signals\" terminology that is consistent with rxjava etc?", "author": "oraNod", "createdAt": "2020-05-25T15:47:34Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -87,146 +83,145 @@\n     */\n    enum Characteristic {\n       /**\n-       * Whether this cache can be shared between multiple nodes. An example would be an external system, such as\n-       * a database. This characteristic is here solely for validation of the store configuration.\n+       * If this store can be shared across multiple Infinispan nodes; for example, an external system such as\n+       * a database. This characteristic allows validation of the store configuration.\n        */\n       SHAREABLE,\n       /**\n-       * If this store only supports being read from.  Any write based operations will never be invoked on this store.\n+       * If this store supports only being read from. Write-based operations are never invoked on this store.\n        * No optional methods map to this characteristic. The {@link #write(int, MarshallableEntry)},\n        * {@link #delete(int, Object)}, {@link #bulkWrite(int, Publisher)}, and {@link #bulkDelete(int, Publisher)} methods\n-       * will not be invoked on a store that has this characteristic.\n+       * are not invoked on stores with this characteristic.\n        */\n       READ_ONLY,\n       /**\n-       * If this store only supports being written to. Any read based operations will never be invoked on this store.\n+       * If this store supports only being written to. Read-based operations are never invoked on this store.\n        * No optional methods map to this characteristic. The {@link #load(int, Object)} and\n-       * {@link #containsKey(int, Object)} methods will not be invoked on a store that has this characteristic.\n+       * {@link #containsKey(int, Object)} methods are not invoked on stores with this characteristic.\n        */\n       WRITE_ONLY,\n       /**\n-       * If this store supports bulk read operations. If a store does not have this characteristic operations such\n-       * as {@link Cache#size()} and {@code Cache.entrySet().stream()} will not utilize this store.\n+       * If this store supports bulk read operations. If a store does not have this characteristic, operations such\n+       * as {@link Cache#size()} and {@code Cache.entrySet().stream()} do not use this store.\n        * <p>\n        * Stores that have this characteristic must override the {@link #publishKeys(IntSet, Predicate)},\n-       * {@link #publishEntries(IntSet, Predicate, boolean)}  and {@link #size(IntSet)} methods.\n+       * {@link #publishEntries(IntSet, Predicate, boolean)} and {@link #size(IntSet)} methods.\n        * <p>\n-       * This characteristic is ignored if the store also contains {@link #WRITE_ONLY}\n+       * This characteristic is ignored if the store also contains {@link #WRITE_ONLY}.\n        */\n       BULK_READ,\n       /**\n-       * If this store supports being invoked in a transactional context with a prepare and commit or rollback phases.\n-       * Stores of this type may take part of the actual transaction if present.\n+       * If this store supports being invoked in a transactional context with prepare and commit or rollback phases.\n+       * Stores of this type can participate in the actual transaction, if present.\n        * <p>\n        * Stores that have this characteristic must override the\n        * {@link #prepareWithModifications(Transaction, BatchModification)}, {@link #commit(Transaction)} and\n        * {@link #rollback(Transaction)} methods.\n        * <p>\n-       * This characteristic is ignored if the store also contains {@link #READ_ONLY}\n+       * This characteristic is ignored if the store also contains {@link #READ_ONLY}.\n        */\n       TRANSACTIONAL,\n       /**\n-       * Whether this store supports being segmented. All methods in this SPI take as an argument a way to map a given\n+       * If this store supports segmentation. All methods in this SPI take as an argument a way to map a given\n        * entry to a segment. A segment in Infinispan is an int that acts as a bucket for many keys. Many store\n        * implementations may be able to store and load entries in a more performant way if they segment their data\n        * accordingly.\n        * <p>\n        * If this store is not segmentable then invokers of this SPI are not required to calculate these segments before\n-       * invoking these methods and thus these methods may be invoked with any int value, null or equivalent. Please\n-       * see each method to see how they may be affected when this store is not segmentable.\n+       * invoking these methods and thus these methods may be invoked with any int value, null or equivalent. Refer to\n+       * each method to determine their effect when this store is not segmented.\n        * <p>\n-       * Note that a store may also be configured at runtime to be segmented or not. If this store is configured to not\n-       * be segmented this store will be treated as if it does not have the SEGMENTABLE characteristic (causing possible\n-       * parameters to be null or invalid segment numbers). A store implementation may want to block this configuration\n-       * by throwing an exception in the {@link #start(InitializationContext)} method if it does not want to support this.\n+       * Note that you can also configure stores at runtime to be segmented or not. If the runtime configuration of this\n+       * store is non-segmented, it is equivalent to the store not having the SEGMENTABLE characteristic, which might cause\n+       * parameters to be null or invalid segment numbers. Store implementation can block this configuration\n+       * by throwing an exception in the {@link #start(InitializationContext)} method.\n        * <p>\n-       * While it is possible that a SEGMENTABLE store can be configured as not segmented, a store that is not\n-       * SEGMENTABLE will never be allowed to be configured as segmented.\n+       * While it is possible that a SEGMENTABLE store can be configured as non-segmented, a store that is not\n+       * SEGMENTABLE can never then later be configured as segmented.\n        * <p>\n        * Stores that have this characteristic must override the {@link #addSegments(IntSet)} and\n-       * {@link #removeSegments(IntSet)} methods. If a store is {@link #SHAREABLE} and is configured to be shared\n-       * via configuration these methods will not be invoked though.\n+       * {@link #removeSegments(IntSet)} methods. However, if a store is {@link #SHAREABLE} and is configured to be shared\n+       * via configuration these methods are not invoked.\n        */\n       SEGMENTABLE,\n       /**\n-       * If this store supports storing expiration metadata. That is this store should never return an expired entry\n+       * If this store uses expiration metadata so that it never returns expired entries\n        * via any methods such as {@link #load(int, Object)}, {@link #publishKeys(IntSet, Predicate)} or\n-       * {@link #publishEntries(IntSet, Predicate, boolean)}. It is recommended that a store use the provided\n-       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if an\n-       * entry has expired.\n+       * {@link #publishEntries(IntSet, Predicate, boolean)}. Stores should use the provided\n+       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if entries are\n+       * expired.\n        * <p>\n-       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata}\n-       * which is accessible from the {@link MarshallableEntry} which is provided.\n+       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata},\n+       * accessible from the {@link MarshallableEntry} that is provided.\n        * <p>\n        * Stores that have this characteristic must override the {@link #purgeExpired()} method.\n        */\n       EXPIRATION\n    }\n \n    /**\n-    * The first method that will be invoked to allow the store to be configured and for any additional steps, such as\n-    * connecting via a socket or opening file descriptors, to be performed.\n+    * The first method to invoke so that the store can be configured and additional steps, such as connecting through\n+    * a socket or opening file descriptors, are performed.\n     * <p>\n     * The provided {@link InitializationContext} contains many helpful objects, including the configuration of the\n     * cache and store, concurrency utilities such as {@link org.infinispan.util.concurrent.BlockingManager} or\n-    * an executor reserved for non blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n+    * an executor reserved for non-blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This means another method\n-    * will not be invoked on this store until after the returned Stage completes.\n+    * This method is guaranteed not to be invoked concurrently with other operations. This means other methods are\n+    * not invoked on this store until after the returned Stage completes.\n     * <p>\n     * It is expected that an implementation should be able to \"restart\" by invoking {@code start} a second time if\n     * {@link #stop()} has been invoked and allowed for its stage to complete.\n-    * @param ctx initialization context used to initialize this store\n-    * @return a stage that when complete signals that this store has been successfully started\n+    * @param ctx initialization context used to initialize this store.\n+    * @return a stage that, when complete, signals that this store has started successfully.", "originalCommit": "66376032cb3c2a209962460bbe8a476728f63a5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMxNzk1Mw==", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r431317953", "bodyText": "No, signal is just a term I used here. This is specific to CompletionStage as well at this point, so I am fine either way.", "author": "wburns", "createdAt": "2020-05-27T17:29:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTk5NzcxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk0NjYwMw==", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r430946603", "bodyText": "How about just \"an executor for non-blocking tasks\"?", "author": "ryanemerson", "createdAt": "2020-05-27T08:30:53Z", "path": "core/src/main/java/org/infinispan/persistence/spi/InitializationContext.java", "diffHunk": "@@ -51,17 +51,18 @@\n    ExecutorService getExecutor();\n \n    /**\n-    * Returns an executor that Infinispan uses internally for non blocking tasks. The user must guarantee tasks\n-    * submitted to this executor will not block the thread it is ran on. Failure to do so can slow down Infinispan's\n-    * handling of operations as these threads are limited to the number of cores and are used extensively.\n-    * @return an executor that can be used to submit tasks that will not block the thread it runs on\n+    * Returns an executor that Infinispan uses to perform tasks in a non-blocking manner. Users must guarantee that the tasks they\n+    * submit to this executor do not block the thread in which the executor runs. Doing so can cause Infinispan to handle operations\n+    * more slowly, reducing performance, because threads are limited to the number of cores and are used extensively.\n+    * @return an executor that can submit non-blocking tasks.", "originalCommit": "66376032cb3c2a209962460bbe8a476728f63a5d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk0NzUyOQ==", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r430947529", "bodyText": "IMO the original better conveys the purpose of the BlockingManager.", "author": "ryanemerson", "createdAt": "2020-05-27T08:32:27Z", "path": "core/src/main/java/org/infinispan/persistence/spi/InitializationContext.java", "diffHunk": "@@ -51,17 +51,18 @@\n    ExecutorService getExecutor();\n \n    /**\n-    * Returns an executor that Infinispan uses internally for non blocking tasks. The user must guarantee tasks\n-    * submitted to this executor will not block the thread it is ran on. Failure to do so can slow down Infinispan's\n-    * handling of operations as these threads are limited to the number of cores and are used extensively.\n-    * @return an executor that can be used to submit tasks that will not block the thread it runs on\n+    * Returns an executor that Infinispan uses to perform tasks in a non-blocking manner. Users must guarantee that the tasks they\n+    * submit to this executor do not block the thread in which the executor runs. Doing so can cause Infinispan to handle operations\n+    * more slowly, reducing performance, because threads are limited to the number of cores and are used extensively.\n+    * @return an executor that can submit non-blocking tasks.\n     */\n    Executor getNonBlockingExecutor();\n \n    /**\n-    * Returns a manager that is designed to execute tasks that may block. This manager ensures that only the blocking\n-    * portion is ran on a blocking thread and any stage is continued on a non blocking thread.\n-    * @return a manager that should be used to execute blocking operations\n+    * Returns a manager that can execute thread-blocking operations. The manager runs any blocking operations on blocking threads,\n+    * any stages continue on non-blocking threads. Use this manager to ensure that blocking operations do not leak into the\n+    * Infinispan internal system.\n+    * @return a manager that can execute blocking operations.", "originalCommit": "66376032cb3c2a209962460bbe8a476728f63a5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5MjgxMg==", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r430992812", "bodyText": "thanks @ryanemerson I've changed back to the original (with a couple minor tweaks)", "author": "oraNod", "createdAt": "2020-05-27T09:45:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk0NzUyOQ=="}], "type": "inlineReview"}, {"oid": "68d4004e376a2d9c4f14c8e16a1875388b371d59", "url": "https://github.com/infinispan/infinispan/commit/68d4004e376a2d9c4f14c8e16a1875388b371d59", "message": "ryan feedback", "committedDate": "2020-05-27T09:41:48Z", "type": "forcePushed"}, {"oid": "8dffd152256336ba0cdfeb1311ee5e50234a39fb", "url": "https://github.com/infinispan/infinispan/commit/8dffd152256336ba0cdfeb1311ee5e50234a39fb", "message": "ISPN-11896 non blocking cache store SPI docs", "committedDate": "2020-05-27T12:54:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMyNzI5NA==", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r431327294", "bodyText": "can determine if stores are segmented\nThis is really more that the store itself is configured to be segmented. I am not sure of the best way to word this. But basically if a store is SEGMENTABLE it doesn't mean it is configured to be so.", "author": "wburns", "createdAt": "2020-05-27T17:45:10Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -24,53 +24,49 @@\n import io.reactivex.rxjava3.core.Flowable;\n \n /**\n- * The contract for defining a way for a cache to interface with external source of data, such as a database,\n- * filesystem etc. As the name implies, all of the methods in this class must <b>never</b> block the invoking thread.\n+ * The contract for defining how caches interface with external sources of data, such as databases or filesystems.\n+ * As the name implies, any method in this class must <b>never</b> block the invoking thread.\n  * <p>\n- * The first method that will be invoked on this store will be the {@link #start(InitializationContext)} to allow\n- * it to initialize and startup. Once the returned stage has completed the store is assumed to be in working state\n- * and is ready to handle operations. Infinispan guarantees the visibility of variables written during\n- * the start method, so there is no need to synchronize these manually, unless they are mutated in the normal operations\n- * of the store itself.\n+ * The first method invoked on this store is {@link #start(InitializationContext)}, which starts the store.\n+ * Once the returned stage has completed, the store is assumed to be in working state and ready to handle operations.\n+ * Infinispan guarantees the visibility of variables written during the start method, so you do not need to\n+ * synchronize them manually unless they are mutated in the normal operations of the store itself.\n  * <p>\n- * After the store has started, Infinispan will utilise the {@link #characteristics()} method to query the store's\n- * characteristics. It is highly recommended that this method never change the values it returns once the\n- * store has been started as these may or may not be cached. For more information on how the characteristics affect\n- * the store operations, please see {@link Characteristic} and its various values.\n+ * After the store starts, Infinispan uses the {@link #characteristics()} method to query the characteristics of\n+ * the store. It is highly recommended that this method never change the values it returns after the\n+ * store starts because characteristics might not be cached. For more information, see {@link Characteristic}\n+ * and its various values.\n  * <p>\n- * By default this interface only requires half a dozen or so methods to be implemented. However, there are more\n- * optional methods that may be implemented. If you implement such a method, please be sure to advertise the appropriate\n- * characteristic for that method, so Infinispan knows to invoke it. If Infinispan has been told a\n+ * By default, this interface has only a few required methods. If you implement any of the optional methods,\n+ * ensure that you advertise the appropriate characteristic for that method so that Infinispan invokes it.\n+ * If Infinispan is instructed that a\n  * characteristic is available and the method is not overridden, an {@link UnsupportedOperationException} will be\n  * thrown when trying to invoke the appropriate method. Each {@link Characteristic} defines what methods map to which\n  * characteristic.\n  * <p>\n- * Although recommended, Segmentation support in a store implementation is not required. Segment parameters are provided\n- * for all methods where segment information would be required, for example {@link #load(int, Object)} and\n- * {@link #publishEntries(IntSet, Predicate, boolean). When a store does not support segmentation, these parameters can\n- * simply be ignored by the implementation. As previously stated, it's recommended that segmentation is supported as an\n- * Infinispan cache can perform much more efficiently when segmentation is supported when\n- * performing bulk operations such as {@code Cache.size()} or {@code Cache.entrySet().stream()}. It also decreases state\n- * transfer duration when {@link PersistenceConfiguration#fetchPersistentState()} is enabled, as well as the time\n- * required to remove data by segments. To indicate that a store implementation supports segmentation, it's necessary\n- * that the {@link Characteristic#SEGMENTABLE} characteristic is returned via the {@link #characteristics()} method. A\n- * store implementation can tell if segmentation is enabled by checking the store configuration\n- * {@link StoreConfiguration#segmented()} available from the {@code InitializationContext}.\n+ * Although recommended, segmentation support in store implementations is optional. Segment parameters are provided\n+ * for all methods where segment information is required, for example {@link #load(int, Object)} and\n+ * {@link #publishEntries(IntSet, Predicate, boolean). If your store implementation does not support segmentation,\n+ * you can ignore these parameters. However, you should note that segmented stores allow Infinispan caches to more\n+ * efficiently perform bulk operations such as {@code Cache.size()} or {@code Cache.entrySet().stream()}. Segmentation\n+ * also decreases the duration of state transfers when {@link PersistenceConfiguration#fetchPersistentState()} is enabled,\n+ * as well as the time required to remove data by segments. To indicate that a store implementation supports segmentation,\n+ * the {@link Characteristic#SEGMENTABLE} characteristic must be returned by the {@link #characteristics()} method. Store\n+ * implementations can determine if stores are segmented if {@link StoreConfiguration#segmented()} is enabled, which is", "originalCommit": "8dffd152256336ba0cdfeb1311ee5e50234a39fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQxOTgxNg==", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r431419816", "bodyText": "@wburns hmm. thanks, I updated but maybe the phrasing still isn't 100%. could you look at this line again please?", "author": "oraNod", "createdAt": "2020-05-27T20:23:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMyNzI5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ1MzAzNw==", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r432453037", "bodyText": "Seems okay to me.", "author": "wburns", "createdAt": "2020-05-29T12:35:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMyNzI5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMyNzgxMg==", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r431327812", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * by running runs any blocking operations on blocking threads, while any stages continue on non-blocking threads.\n          \n          \n            \n             * by running any blocking operations on blocking threads, while any stages continue on non-blocking threads.", "author": "wburns", "createdAt": "2020-05-27T17:46:06Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -24,53 +24,49 @@\n import io.reactivex.rxjava3.core.Flowable;\n \n /**\n- * The contract for defining a way for a cache to interface with external source of data, such as a database,\n- * filesystem etc. As the name implies, all of the methods in this class must <b>never</b> block the invoking thread.\n+ * The contract for defining how caches interface with external sources of data, such as databases or filesystems.\n+ * As the name implies, any method in this class must <b>never</b> block the invoking thread.\n  * <p>\n- * The first method that will be invoked on this store will be the {@link #start(InitializationContext)} to allow\n- * it to initialize and startup. Once the returned stage has completed the store is assumed to be in working state\n- * and is ready to handle operations. Infinispan guarantees the visibility of variables written during\n- * the start method, so there is no need to synchronize these manually, unless they are mutated in the normal operations\n- * of the store itself.\n+ * The first method invoked on this store is {@link #start(InitializationContext)}, which starts the store.\n+ * Once the returned stage has completed, the store is assumed to be in working state and ready to handle operations.\n+ * Infinispan guarantees the visibility of variables written during the start method, so you do not need to\n+ * synchronize them manually unless they are mutated in the normal operations of the store itself.\n  * <p>\n- * After the store has started, Infinispan will utilise the {@link #characteristics()} method to query the store's\n- * characteristics. It is highly recommended that this method never change the values it returns once the\n- * store has been started as these may or may not be cached. For more information on how the characteristics affect\n- * the store operations, please see {@link Characteristic} and its various values.\n+ * After the store starts, Infinispan uses the {@link #characteristics()} method to query the characteristics of\n+ * the store. It is highly recommended that this method never change the values it returns after the\n+ * store starts because characteristics might not be cached. For more information, see {@link Characteristic}\n+ * and its various values.\n  * <p>\n- * By default this interface only requires half a dozen or so methods to be implemented. However, there are more\n- * optional methods that may be implemented. If you implement such a method, please be sure to advertise the appropriate\n- * characteristic for that method, so Infinispan knows to invoke it. If Infinispan has been told a\n+ * By default, this interface has only a few required methods. If you implement any of the optional methods,\n+ * ensure that you advertise the appropriate characteristic for that method so that Infinispan invokes it.\n+ * If Infinispan is instructed that a\n  * characteristic is available and the method is not overridden, an {@link UnsupportedOperationException} will be\n  * thrown when trying to invoke the appropriate method. Each {@link Characteristic} defines what methods map to which\n  * characteristic.\n  * <p>\n- * Although recommended, Segmentation support in a store implementation is not required. Segment parameters are provided\n- * for all methods where segment information would be required, for example {@link #load(int, Object)} and\n- * {@link #publishEntries(IntSet, Predicate, boolean). When a store does not support segmentation, these parameters can\n- * simply be ignored by the implementation. As previously stated, it's recommended that segmentation is supported as an\n- * Infinispan cache can perform much more efficiently when segmentation is supported when\n- * performing bulk operations such as {@code Cache.size()} or {@code Cache.entrySet().stream()}. It also decreases state\n- * transfer duration when {@link PersistenceConfiguration#fetchPersistentState()} is enabled, as well as the time\n- * required to remove data by segments. To indicate that a store implementation supports segmentation, it's necessary\n- * that the {@link Characteristic#SEGMENTABLE} characteristic is returned via the {@link #characteristics()} method. A\n- * store implementation can tell if segmentation is enabled by checking the store configuration\n- * {@link StoreConfiguration#segmented()} available from the {@code InitializationContext}.\n+ * Although recommended, segmentation support in store implementations is optional. Segment parameters are provided\n+ * for all methods where segment information is required, for example {@link #load(int, Object)} and\n+ * {@link #publishEntries(IntSet, Predicate, boolean). If your store implementation does not support segmentation,\n+ * you can ignore these parameters. However, you should note that segmented stores allow Infinispan caches to more\n+ * efficiently perform bulk operations such as {@code Cache.size()} or {@code Cache.entrySet().stream()}. Segmentation\n+ * also decreases the duration of state transfers when {@link PersistenceConfiguration#fetchPersistentState()} is enabled,\n+ * as well as the time required to remove data by segments. To indicate that a store implementation supports segmentation,\n+ * the {@link Characteristic#SEGMENTABLE} characteristic must be returned by the {@link #characteristics()} method. Store\n+ * implementations can determine if stores are segmented if {@link StoreConfiguration#segmented()} is enabled, which is\n+ * available from the {@code InitializationContext}.\n  * <p>\n- * A store implementation may have to interact with blocking APIs to perform their required operations, however we\n- * should never block the invoking thread, therefore Infinispan provides a utility helper for these operations. This is\n- * the {@link org.infinispan.util.concurrent.BlockingManager} and may be obtained by invoking\n- * {@link InitializationContext#getBlockingManager()} on the provided context in the start method. This utility class\n- * comes with an assortment of methods ranging from equivalent methods for more commonly used methods such as\n- * {@link java.util.concurrent.CompletableFuture#supplyAsync(Supplier, Executor)} to a wrapper around a\n- * {@link Publisher} that ensures it is subscribed and obversed on the proper threads. The {@code BlockingManager} is\n- * special in that it guarantees the code that is blocking is ran on a blocking thread but any stages it produces are\n- * continued on a non blocking thread, which is very important to not leak blocking threads to the internal Infinispan\n- * system.\n+ * Store implementations might need to interact with blocking APIs to perform their required operations. However the invoking\n+ * thread must never be blocked, so Infinispan provides a {@link org.infinispan.util.concurrent.BlockingManager} utility class\n+ * that handles blocking operations to ensure that they do not leak into the internal system. {@code BlockingManager} does this\n+ * by running runs any blocking operations on blocking threads, while any stages continue on non-blocking threads.", "originalCommit": "8dffd152256336ba0cdfeb1311ee5e50234a39fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMzMTYxOQ==", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r431331619", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                * The default implementations return a completed stage with the value {@code Boolean.TRUE}.\n          \n          \n            \n                * The default implementation returns a completed stage with the value {@code Boolean.TRUE}.", "author": "wburns", "createdAt": "2020-05-27T17:50:54Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -87,146 +83,145 @@\n     */\n    enum Characteristic {\n       /**\n-       * Whether this cache can be shared between multiple nodes. An example would be an external system, such as\n-       * a database. This characteristic is here solely for validation of the store configuration.\n+       * If this store can be shared across multiple Infinispan nodes; for example, an external system such as\n+       * a database. This characteristic allows validation of the store configuration.\n        */\n       SHAREABLE,\n       /**\n-       * If this store only supports being read from.  Any write based operations will never be invoked on this store.\n+       * If this store supports only being read from. Write-based operations are never invoked on this store.\n        * No optional methods map to this characteristic. The {@link #write(int, MarshallableEntry)},\n        * {@link #delete(int, Object)}, {@link #bulkWrite(int, Publisher)}, and {@link #bulkDelete(int, Publisher)} methods\n-       * will not be invoked on a store that has this characteristic.\n+       * are not invoked on stores with this characteristic.\n        */\n       READ_ONLY,\n       /**\n-       * If this store only supports being written to. Any read based operations will never be invoked on this store.\n+       * If this store supports only being written to. Read-based operations are never invoked on this store.\n        * No optional methods map to this characteristic. The {@link #load(int, Object)} and\n-       * {@link #containsKey(int, Object)} methods will not be invoked on a store that has this characteristic.\n+       * {@link #containsKey(int, Object)} methods are not invoked on stores with this characteristic.\n        */\n       WRITE_ONLY,\n       /**\n-       * If this store supports bulk read operations. If a store does not have this characteristic operations such\n-       * as {@link Cache#size()} and {@code Cache.entrySet().stream()} will not utilize this store.\n+       * If this store supports bulk read operations. If a store does not have this characteristic, operations such\n+       * as {@link Cache#size()} and {@code Cache.entrySet().stream()} do not use this store.\n        * <p>\n        * Stores that have this characteristic must override the {@link #publishKeys(IntSet, Predicate)},\n-       * {@link #publishEntries(IntSet, Predicate, boolean)}  and {@link #size(IntSet)} methods.\n+       * {@link #publishEntries(IntSet, Predicate, boolean)} and {@link #size(IntSet)} methods.\n        * <p>\n-       * This characteristic is ignored if the store also contains {@link #WRITE_ONLY}\n+       * This characteristic is ignored if the store also contains {@link #WRITE_ONLY}.\n        */\n       BULK_READ,\n       /**\n-       * If this store supports being invoked in a transactional context with a prepare and commit or rollback phases.\n-       * Stores of this type may take part of the actual transaction if present.\n+       * If this store supports being invoked in a transactional context with prepare and commit or rollback phases.\n+       * Stores of this type can participate in the actual transaction, if present.\n        * <p>\n        * Stores that have this characteristic must override the\n        * {@link #prepareWithModifications(Transaction, BatchModification)}, {@link #commit(Transaction)} and\n        * {@link #rollback(Transaction)} methods.\n        * <p>\n-       * This characteristic is ignored if the store also contains {@link #READ_ONLY}\n+       * This characteristic is ignored if the store also contains {@link #READ_ONLY}.\n        */\n       TRANSACTIONAL,\n       /**\n-       * Whether this store supports being segmented. All methods in this SPI take as an argument a way to map a given\n+       * If this store supports segmentation. All methods in this SPI take as an argument a way to map a given\n        * entry to a segment. A segment in Infinispan is an int that acts as a bucket for many keys. Many store\n        * implementations may be able to store and load entries in a more performant way if they segment their data\n        * accordingly.\n        * <p>\n        * If this store is not segmentable then invokers of this SPI are not required to calculate these segments before\n-       * invoking these methods and thus these methods may be invoked with any int value, null or equivalent. Please\n-       * see each method to see how they may be affected when this store is not segmentable.\n+       * invoking these methods and thus these methods may be invoked with any int value, null or equivalent. Refer to\n+       * each method to determine their effect when this store is not segmented.\n        * <p>\n-       * Note that a store may also be configured at runtime to be segmented or not. If this store is configured to not\n-       * be segmented this store will be treated as if it does not have the SEGMENTABLE characteristic (causing possible\n-       * parameters to be null or invalid segment numbers). A store implementation may want to block this configuration\n-       * by throwing an exception in the {@link #start(InitializationContext)} method if it does not want to support this.\n+       * Note that you can also configure stores at runtime to be segmented or not. If the runtime configuration of this\n+       * store is non-segmented, it is equivalent to the store not having the SEGMENTABLE characteristic, which might cause\n+       * parameters to be null or invalid segment numbers. Store implementation can block this configuration\n+       * by throwing an exception in the {@link #start(InitializationContext)} method.\n        * <p>\n-       * While it is possible that a SEGMENTABLE store can be configured as not segmented, a store that is not\n-       * SEGMENTABLE will never be allowed to be configured as segmented.\n+       * While it is possible that a SEGMENTABLE store can be configured as non-segmented, a store that is not\n+       * SEGMENTABLE can never then later be configured as segmented.\n        * <p>\n        * Stores that have this characteristic must override the {@link #addSegments(IntSet)} and\n-       * {@link #removeSegments(IntSet)} methods. If a store is {@link #SHAREABLE} and is configured to be shared\n-       * via configuration these methods will not be invoked though.\n+       * {@link #removeSegments(IntSet)} methods. However, if a store is {@link #SHAREABLE} and is configured to be shared\n+       * via configuration these methods are not invoked.\n        */\n       SEGMENTABLE,\n       /**\n-       * If this store supports storing expiration metadata. That is this store should never return an expired entry\n+       * If this store uses expiration metadata so that it never returns expired entries\n        * via any methods such as {@link #load(int, Object)}, {@link #publishKeys(IntSet, Predicate)} or\n-       * {@link #publishEntries(IntSet, Predicate, boolean)}. It is recommended that a store use the provided\n-       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if an\n-       * entry has expired.\n+       * {@link #publishEntries(IntSet, Predicate, boolean)}. Stores should use the provided\n+       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if entries are\n+       * expired.\n        * <p>\n-       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata}\n-       * which is accessible from the {@link MarshallableEntry} which is provided.\n+       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata},\n+       * accessible from the {@link MarshallableEntry} that is provided.\n        * <p>\n        * Stores that have this characteristic must override the {@link #purgeExpired()} method.\n        */\n       EXPIRATION\n    }\n \n    /**\n-    * The first method that will be invoked to allow the store to be configured and for any additional steps, such as\n-    * connecting via a socket or opening file descriptors, to be performed.\n+    * The first method to invoke so that the store can be configured and additional steps, such as connecting through\n+    * a socket or opening file descriptors, are performed.\n     * <p>\n     * The provided {@link InitializationContext} contains many helpful objects, including the configuration of the\n     * cache and store, concurrency utilities such as {@link org.infinispan.util.concurrent.BlockingManager} or\n-    * an executor reserved for non blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n+    * an executor reserved for non-blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This means another method\n-    * will not be invoked on this store until after the returned Stage completes.\n+    * This method is guaranteed not to be invoked concurrently with other operations. This means other methods are\n+    * not invoked on this store until after the returned Stage completes.\n     * <p>\n     * It is expected that an implementation should be able to \"restart\" by invoking {@code start} a second time if\n     * {@link #stop()} has been invoked and allowed for its stage to complete.\n-    * @param ctx initialization context used to initialize this store\n-    * @return a stage that when complete signals that this store has been successfully started\n+    * @param ctx initialization context used to initialize this store.\n+    * @return a stage that, when complete, signals that this store has started successfully.\n     */\n    CompletionStage<Void> start(InitializationContext ctx);\n \n    /**\n-    * This method will be invoked when the cache is being shutdown. It is expected that all resources related to the\n-    * store to be freed upon completion of the returned stage.\n+    * This method is invoked when the cache is being shutdown. It is expected that all resources related to the\n+    * store are freed when the returned stage is complete.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n-    * will not be invoked on this store until after the returned Stage completes.\n+    * This method is guaranteed not to be invoked concurrently with other operations. This means other methods are\n+    * not invoked on this store until after the returned Stage completes.\n     * <p>\n     * It is expected that an implementation should be able to \"restart\" by invoking {@link #start(InitializationContext)}\n     * a second time if {@code stop} has been invoked and allowed for its stage to complete.\n-    * @return a stage that when complete signals that this store has been stopped\n+    * @return a stage that, when complete, signals that this store has stopped.\n     */\n    CompletionStage<Void> stop();\n \n    /**\n     * Returns a set of characteristics for this store and its elements. This method may be invoked multiple times\n-    * to determine which methods of the store can be used and how its data can be handled.\n+    * to determine which methods of the store can be used and how the data in the store can be handled.\n     * <p>\n-    * Please see {@link Characteristic} and its values for a description of what each characteristic declares the\n-    * store as supporting.\n+    * Refer to {@link Characteristic} and its values for descriptions of each characteristic for stores.\n     * @implSpec\n-    * The default implementation returns an empty set\n-    * @return the set of characteristics that this store supports\n+    * The default implementation returns an empty set.\n+    * @return the set of characteristics that this store supports.\n     */\n    default Set<Characteristic> characteristics() {\n       return EnumSet.noneOf(Characteristic.class);\n    }\n \n    /**\n-    * Returns a stage that when complete returns a boolean indicating whether the current store can be accessed for\n+    * Returns a stage that, when complete, returns a boolean indicating whether the current store can be accessed for\n     * requests. This can be useful for store implementations that rely on an external source, such as a remote database,\n     * that may become unreachable. This can reduce sending requests to a store that is not available, as subsequent cache\n     * requests will result in a {@link StoreUnavailableException} being thrown until the store becomes available again.\n     * <p>\n-    * Store availability is is polled periodically to update a store's status if it's availability changes. This method\n-    * will not be invoked concurrently with itself (ie. this method will not be invoked until after the previous stage\n-    * has completed), but will be invoked concurrently with other operations, excluding\n+    * Store availability is is polled periodically to update the status of stores if their availability changes. This method\n+    * is not invoked concurrently with itself. In other words, this method is not invoked until after the previous stage\n+    * has completed. However this method is invoked concurrently with other operations, except for\n     * {@link #start(InitializationContext)} and {@link #stop()}.\n     * <p>\n-    If a store is configured to be {@link StoreConfiguration#async()} and the store becomes unavailable, then it's\n+    If a store is configured to be {@link StoreConfiguration#async()} and the store becomes unavailable, then it is\n     possible for the cache operations to be accepted in the interim period between the loss of availability and the\n     modification-queue becoming full. This allows for this store to be unavailable for short periods of time without a\n-    {@link StoreUnavailableException} being thrown, however if the store does not become available before the queue\n-    fills, then a {@link StoreUnavailableException} is eventually thrown.\n+    {@link StoreUnavailableException} being thrown; however if the store does not become available before the queue\n+    fills, then a {@link StoreUnavailableException} is thrown.\n     * @implSpec\n-    * The default implementations returns a completed stage with the value {@code Boolean.TRUE}\n-    * @return stage that when complete signals if the store is available\n+    * The default implementations return a completed stage with the value {@code Boolean.TRUE}.", "originalCommit": "8dffd152256336ba0cdfeb1311ee5e50234a39fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMzODIwMg==", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r431338202", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * of operations across threads if need TRACE logs.\n          \n          \n            \n             * of operations across threads if TRACE logs are used.", "author": "wburns", "createdAt": "2020-05-27T17:58:04Z", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingManager.java", "diffHunk": "@@ -9,155 +9,156 @@\n import org.reactivestreams.Publisher;\n \n /**\n- * Runs tasks on the blocking executor and returns a {@code CompletionStage} or {@code Publisher} that continues on the\n- * non-blocking executor, similar to {@code stage.handleAsync(callback, blockingExecutor).whenCompleteAsync(NOOP, nonBlockingExecutor)}.\n+ * Manager utility for blocking operations that runs tasks on the blocking executor and returns a\n+ * {@code CompletionStage} or {@code Publisher} that continues on the non-blocking executor, similar\n+ * to {@code stage.handleAsync(callback, blockingExecutor).whenCompleteAsync(NOOP, nonBlockingExecutor)}.\n  * <p>\n- * If the current thread is blocking, it blocks until the task may run, runs the task in the current thread, and returns a\n- * completed {@code CompletionStage}, so it <em>does not</em> continue the execution on the non-blocking executor.\n+ * If the current thread is blocking, it blocks until the task can run, then runs the task in the current thread and returns a\n+ * completed {@code CompletionStage} so it <em>does not</em> continue the execution on the non-blocking executor.\n  * <p>\n- * Many of the methods on {@code BlockingManager} allow an id to be passed when performing the operation. This id will\n- * be printed to the TRACE log. It is therefore advised to provide something unique so that\n- * if a log is needed it will be easier to track the stream of operations across threads.\n+ * Many of the methods on {@code BlockingManager} let you pass an identifier (ID) when performing the operation. This ID is\n+ * printed with TRACE logs. For this reason, you should provide IDs that are unique, making it easier to track the stream\n+ * of operations across threads if need TRACE logs.", "originalCommit": "8dffd152256336ba0cdfeb1311ee5e50234a39fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c85bd6693fa890e0de9a92030007dfa9552e7abf", "url": "https://github.com/infinispan/infinispan/commit/c85bd6693fa890e0de9a92030007dfa9552e7abf", "message": "ISPN-11896 non blocking cache store SPI docs", "committedDate": "2020-05-27T20:21:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQyMDc0MA==", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r431420740", "bodyText": "@wburns could you also please check this line? \"default store implementations return\" or should it be \"default store implementation returns\"? I presume the former as Infinispan provides multiple store implementations.", "author": "oraNod", "createdAt": "2020-05-27T20:25:11Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -87,146 +83,145 @@\n     */\n    enum Characteristic {\n       /**\n-       * Whether this cache can be shared between multiple nodes. An example would be an external system, such as\n-       * a database. This characteristic is here solely for validation of the store configuration.\n+       * If this store can be shared across multiple Infinispan nodes; for example, an external system such as\n+       * a database. This characteristic allows validation of the store configuration.\n        */\n       SHAREABLE,\n       /**\n-       * If this store only supports being read from.  Any write based operations will never be invoked on this store.\n+       * If this store supports only being read from. Write-based operations are never invoked on this store.\n        * No optional methods map to this characteristic. The {@link #write(int, MarshallableEntry)},\n        * {@link #delete(int, Object)}, {@link #bulkWrite(int, Publisher)}, and {@link #bulkDelete(int, Publisher)} methods\n-       * will not be invoked on a store that has this characteristic.\n+       * are not invoked on stores with this characteristic.\n        */\n       READ_ONLY,\n       /**\n-       * If this store only supports being written to. Any read based operations will never be invoked on this store.\n+       * If this store supports only being written to. Read-based operations are never invoked on this store.\n        * No optional methods map to this characteristic. The {@link #load(int, Object)} and\n-       * {@link #containsKey(int, Object)} methods will not be invoked on a store that has this characteristic.\n+       * {@link #containsKey(int, Object)} methods are not invoked on stores with this characteristic.\n        */\n       WRITE_ONLY,\n       /**\n-       * If this store supports bulk read operations. If a store does not have this characteristic operations such\n-       * as {@link Cache#size()} and {@code Cache.entrySet().stream()} will not utilize this store.\n+       * If this store supports bulk read operations. If a store does not have this characteristic, operations such\n+       * as {@link Cache#size()} and {@code Cache.entrySet().stream()} do not use this store.\n        * <p>\n        * Stores that have this characteristic must override the {@link #publishKeys(IntSet, Predicate)},\n-       * {@link #publishEntries(IntSet, Predicate, boolean)}  and {@link #size(IntSet)} methods.\n+       * {@link #publishEntries(IntSet, Predicate, boolean)} and {@link #size(IntSet)} methods.\n        * <p>\n-       * This characteristic is ignored if the store also contains {@link #WRITE_ONLY}\n+       * This characteristic is ignored if the store also contains {@link #WRITE_ONLY}.\n        */\n       BULK_READ,\n       /**\n-       * If this store supports being invoked in a transactional context with a prepare and commit or rollback phases.\n-       * Stores of this type may take part of the actual transaction if present.\n+       * If this store supports being invoked in a transactional context with prepare and commit or rollback phases.\n+       * Stores of this type can participate in the actual transaction, if present.\n        * <p>\n        * Stores that have this characteristic must override the\n        * {@link #prepareWithModifications(Transaction, BatchModification)}, {@link #commit(Transaction)} and\n        * {@link #rollback(Transaction)} methods.\n        * <p>\n-       * This characteristic is ignored if the store also contains {@link #READ_ONLY}\n+       * This characteristic is ignored if the store also contains {@link #READ_ONLY}.\n        */\n       TRANSACTIONAL,\n       /**\n-       * Whether this store supports being segmented. All methods in this SPI take as an argument a way to map a given\n+       * If this store supports segmentation. All methods in this SPI take as an argument a way to map a given\n        * entry to a segment. A segment in Infinispan is an int that acts as a bucket for many keys. Many store\n        * implementations may be able to store and load entries in a more performant way if they segment their data\n        * accordingly.\n        * <p>\n        * If this store is not segmentable then invokers of this SPI are not required to calculate these segments before\n-       * invoking these methods and thus these methods may be invoked with any int value, null or equivalent. Please\n-       * see each method to see how they may be affected when this store is not segmentable.\n+       * invoking these methods and thus these methods may be invoked with any int value, null or equivalent. Refer to\n+       * each method to determine their effect when this store is not segmented.\n        * <p>\n-       * Note that a store may also be configured at runtime to be segmented or not. If this store is configured to not\n-       * be segmented this store will be treated as if it does not have the SEGMENTABLE characteristic (causing possible\n-       * parameters to be null or invalid segment numbers). A store implementation may want to block this configuration\n-       * by throwing an exception in the {@link #start(InitializationContext)} method if it does not want to support this.\n+       * Note that you can also configure stores at runtime to be segmented or not. If the runtime configuration of this\n+       * store is non-segmented, it is equivalent to the store not having the SEGMENTABLE characteristic, which might cause\n+       * parameters to be null or invalid segment numbers. Store implementation can block this configuration\n+       * by throwing an exception in the {@link #start(InitializationContext)} method.\n        * <p>\n-       * While it is possible that a SEGMENTABLE store can be configured as not segmented, a store that is not\n-       * SEGMENTABLE will never be allowed to be configured as segmented.\n+       * While it is possible that a SEGMENTABLE store can be configured as non-segmented, a store that is not\n+       * SEGMENTABLE can never then later be configured as segmented.\n        * <p>\n        * Stores that have this characteristic must override the {@link #addSegments(IntSet)} and\n-       * {@link #removeSegments(IntSet)} methods. If a store is {@link #SHAREABLE} and is configured to be shared\n-       * via configuration these methods will not be invoked though.\n+       * {@link #removeSegments(IntSet)} methods. However, if a store is {@link #SHAREABLE} and is configured to be shared\n+       * via configuration these methods are not invoked.\n        */\n       SEGMENTABLE,\n       /**\n-       * If this store supports storing expiration metadata. That is this store should never return an expired entry\n+       * If this store uses expiration metadata so that it never returns expired entries\n        * via any methods such as {@link #load(int, Object)}, {@link #publishKeys(IntSet, Predicate)} or\n-       * {@link #publishEntries(IntSet, Predicate, boolean)}. It is recommended that a store use the provided\n-       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if an\n-       * entry has expired.\n+       * {@link #publishEntries(IntSet, Predicate, boolean)}. Stores should use the provided\n+       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if entries are\n+       * expired.\n        * <p>\n-       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata}\n-       * which is accessible from the {@link MarshallableEntry} which is provided.\n+       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata},\n+       * accessible from the {@link MarshallableEntry} that is provided.\n        * <p>\n        * Stores that have this characteristic must override the {@link #purgeExpired()} method.\n        */\n       EXPIRATION\n    }\n \n    /**\n-    * The first method that will be invoked to allow the store to be configured and for any additional steps, such as\n-    * connecting via a socket or opening file descriptors, to be performed.\n+    * The first method to invoke so that the store can be configured and additional steps, such as connecting through\n+    * a socket or opening file descriptors, are performed.\n     * <p>\n     * The provided {@link InitializationContext} contains many helpful objects, including the configuration of the\n     * cache and store, concurrency utilities such as {@link org.infinispan.util.concurrent.BlockingManager} or\n-    * an executor reserved for non blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n+    * an executor reserved for non-blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This means another method\n-    * will not be invoked on this store until after the returned Stage completes.\n+    * This method is guaranteed not to be invoked concurrently with other operations. This means other methods are\n+    * not invoked on this store until after the returned Stage completes.\n     * <p>\n     * It is expected that an implementation should be able to \"restart\" by invoking {@code start} a second time if\n     * {@link #stop()} has been invoked and allowed for its stage to complete.\n-    * @param ctx initialization context used to initialize this store\n-    * @return a stage that when complete signals that this store has been successfully started\n+    * @param ctx initialization context used to initialize this store.\n+    * @return a stage that, when complete, indicates that this store has started successfully.\n     */\n    CompletionStage<Void> start(InitializationContext ctx);\n \n    /**\n-    * This method will be invoked when the cache is being shutdown. It is expected that all resources related to the\n-    * store to be freed upon completion of the returned stage.\n+    * This method is invoked when the cache is being shutdown. It is expected that all resources related to the\n+    * store are freed when the returned stage is complete.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n-    * will not be invoked on this store until after the returned Stage completes.\n+    * This method is guaranteed not to be invoked concurrently with other operations. This means other methods are\n+    * not invoked on this store until after the returned Stage completes.\n     * <p>\n     * It is expected that an implementation should be able to \"restart\" by invoking {@link #start(InitializationContext)}\n     * a second time if {@code stop} has been invoked and allowed for its stage to complete.\n-    * @return a stage that when complete signals that this store has been stopped\n+    * @return a stage that, when complete, indicates that this store has stopped.\n     */\n    CompletionStage<Void> stop();\n \n    /**\n     * Returns a set of characteristics for this store and its elements. This method may be invoked multiple times\n-    * to determine which methods of the store can be used and how its data can be handled.\n+    * to determine which methods of the store can be used and how the data in the store can be handled.\n     * <p>\n-    * Please see {@link Characteristic} and its values for a description of what each characteristic declares the\n-    * store as supporting.\n+    * Refer to {@link Characteristic} and its values for descriptions of each characteristic for stores.\n     * @implSpec\n-    * The default implementation returns an empty set\n-    * @return the set of characteristics that this store supports\n+    * The default implementation returns an empty set.\n+    * @return the set of characteristics that this store supports.\n     */\n    default Set<Characteristic> characteristics() {\n       return EnumSet.noneOf(Characteristic.class);\n    }\n \n    /**\n-    * Returns a stage that when complete returns a boolean indicating whether the current store can be accessed for\n+    * Returns a stage that, when complete, returns a boolean indicating whether the current store can be accessed for\n     * requests. This can be useful for store implementations that rely on an external source, such as a remote database,\n     * that may become unreachable. This can reduce sending requests to a store that is not available, as subsequent cache\n     * requests will result in a {@link StoreUnavailableException} being thrown until the store becomes available again.\n     * <p>\n-    * Store availability is is polled periodically to update a store's status if it's availability changes. This method\n-    * will not be invoked concurrently with itself (ie. this method will not be invoked until after the previous stage\n-    * has completed), but will be invoked concurrently with other operations, excluding\n+    * Store availability is is polled periodically to update the status of stores if their availability changes. This method\n+    * is not invoked concurrently with itself. In other words, this method is not invoked until after the previous stage\n+    * has completed. However this method is invoked concurrently with other operations, except for\n     * {@link #start(InitializationContext)} and {@link #stop()}.\n     * <p>\n-    If a store is configured to be {@link StoreConfiguration#async()} and the store becomes unavailable, then it's\n+    If a store is configured to be {@link StoreConfiguration#async()} and the store becomes unavailable, then it is\n     possible for the cache operations to be accepted in the interim period between the loss of availability and the\n     modification-queue becoming full. This allows for this store to be unavailable for short periods of time without a\n-    {@link StoreUnavailableException} being thrown, however if the store does not become available before the queue\n-    fills, then a {@link StoreUnavailableException} is eventually thrown.\n+    {@link StoreUnavailableException} being thrown; however if the store does not become available before the queue\n+    fills, then a {@link StoreUnavailableException} is thrown.\n     * @implSpec\n-    * The default implementations returns a completed stage with the value {@code Boolean.TRUE}\n-    * @return stage that when complete signals if the store is available\n+    * The default store implementations return a completed stage with the value {@code Boolean.TRUE}.", "originalCommit": "c85bd6693fa890e0de9a92030007dfa9552e7abf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQyMzkxOQ==", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r431423919", "bodyText": "No this is referring to the default implementation of this method. TBH I think it should just be \"The default implementation returns ..\"", "author": "wburns", "createdAt": "2020-05-27T20:31:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQyMDc0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQzMTQ4Mw==", "url": "https://github.com/infinispan/infinispan/pull/8385#discussion_r431431483", "bodyText": "thanks @wburns I see that now \ud83e\udd26 was probably over-complicating things...", "author": "oraNod", "createdAt": "2020-05-27T20:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQyMDc0MA=="}], "type": "inlineReview"}, {"oid": "405dc60a06a6b6776c0b20023e7a21ca8a0724be", "url": "https://github.com/infinispan/infinispan/commit/405dc60a06a6b6776c0b20023e7a21ca8a0724be", "message": "ISPN-11896 non blocking cache store SPI docs", "committedDate": "2020-05-27T20:46:42Z", "type": "commit"}, {"oid": "405dc60a06a6b6776c0b20023e7a21ca8a0724be", "url": "https://github.com/infinispan/infinispan/commit/405dc60a06a6b6776c0b20023e7a21ca8a0724be", "message": "ISPN-11896 non blocking cache store SPI docs", "committedDate": "2020-05-27T20:46:42Z", "type": "forcePushed"}]}