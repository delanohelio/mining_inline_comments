{"pr_number": 8370, "pr_title": "ISPN-10373 Store/Loader Non blocking SPI Documentation", "pr_createdAt": "2020-05-21T20:46:21Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8370", "timeline": [{"oid": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "url": "https://github.com/infinispan/infinispan/commit/78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "message": "ISPN-10373 Store/Loader Non blocking SPI\n\n* Deprecate old SPI", "committedDate": "2020-05-21T23:50:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE0MTI3Nw==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429141277", "bodyText": "\"are used extensively\"", "author": "ryanemerson", "createdAt": "2020-05-22T09:27:19Z", "path": "core/src/main/java/org/infinispan/persistence/spi/InitializationContext.java", "diffHunk": "@@ -51,14 +51,17 @@\n    ExecutorService getExecutor();\n \n    /**\n-    * TODO: need to document\n-    * @return\n+    * Returns an executor that Infinispan uses internally for non blocking tasks. The user must guarantee tasks\n+    * submitted to this executor will not block the thread it is ran on. Failure to do so can slow down Infinispan's\n+    * handling of operations as these threads are limited to the number of cores and used extensively.", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE0MTcyMw==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429141723", "bodyText": "\"defining a way for a cache to interface\"", "author": "ryanemerson", "createdAt": "2020-05-22T09:28:14Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -19,9 +24,51 @@\n import io.reactivex.rxjava3.core.Flowable;\n \n /**\n+ * The contract for defining a way to interface with external source of data, such as a database, filesystem etc. As", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE0MzA5NA==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429143094", "bodyText": "\"in a working state and is ready to handle operations.\"", "author": "ryanemerson", "createdAt": "2020-05-22T09:30:53Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -19,9 +24,51 @@\n import io.reactivex.rxjava3.core.Flowable;\n \n /**\n+ * The contract for defining a way to interface with external source of data, such as a database, filesystem etc. As\n+ * the name implies, all of the methods in this class must <b>never</b> block the invoking thread.\n  * <p>\n- * Implementations of this store must be thread safe if concurrent operations are performed on it. This should include\n- * possibly invoking start or stop multiple times\n+ * The first method that will be invoked on this store will be the {@link #start(InitializationContext)} to allow\n+ * it to initialize and startup. Once the returned stage has completed the store is assumed to be in working condition\n+ * for other operations to be performed upon it. Infinispan will guarantee visibility of variables written during", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE0MzQ2OQ==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429143469", "bodyText": "\"Infinispan guarantees the visibility...\"", "author": "ryanemerson", "createdAt": "2020-05-22T09:31:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE0MzA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE0NTE4OA==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429145188", "bodyText": "\"After the store has started, Infinispan will utilise the {@link #characteristics()} method to query the store's characteristics.\"", "author": "ryanemerson", "createdAt": "2020-05-22T09:35:25Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -19,9 +24,51 @@\n import io.reactivex.rxjava3.core.Flowable;\n \n /**\n+ * The contract for defining a way to interface with external source of data, such as a database, filesystem etc. As\n+ * the name implies, all of the methods in this class must <b>never</b> block the invoking thread.\n  * <p>\n- * Implementations of this store must be thread safe if concurrent operations are performed on it. This should include\n- * possibly invoking start or stop multiple times\n+ * The first method that will be invoked on this store will be the {@link #start(InitializationContext)} to allow\n+ * it to initialize and startup. Once the returned stage has completed the store is assumed to be in working condition\n+ * for other operations to be performed upon it. Infinispan will guarantee visibility of variables written during\n+ * the start method, so there is no need to synchronize these manually, unless they are mutated in the normal operations\n+ * of the store itself.\n+ * <p>\n+ * Infinispan may at any point after this store has started query what characteristics this store has via", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE0NTM0MQ==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429145341", "bodyText": "\"change the values\"", "author": "ryanemerson", "createdAt": "2020-05-22T09:35:44Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -19,9 +24,51 @@\n import io.reactivex.rxjava3.core.Flowable;\n \n /**\n+ * The contract for defining a way to interface with external source of data, such as a database, filesystem etc. As\n+ * the name implies, all of the methods in this class must <b>never</b> block the invoking thread.\n  * <p>\n- * Implementations of this store must be thread safe if concurrent operations are performed on it. This should include\n- * possibly invoking start or stop multiple times\n+ * The first method that will be invoked on this store will be the {@link #start(InitializationContext)} to allow\n+ * it to initialize and startup. Once the returned stage has completed the store is assumed to be in working condition\n+ * for other operations to be performed upon it. Infinispan will guarantee visibility of variables written during\n+ * the start method, so there is no need to synchronize these manually, unless they are mutated in the normal operations\n+ * of the store itself.\n+ * <p>\n+ * Infinispan may at any point after this store has started query what characteristics this store has via\n+ * {@link #characteristics()}. It is highly recommended that this method never change what values it returns once the", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE0NTY3MA==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429145670", "bodyText": "\"this interface\"\nThe store is the implementation.", "author": "ryanemerson", "createdAt": "2020-05-22T09:36:31Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -19,9 +24,51 @@\n import io.reactivex.rxjava3.core.Flowable;\n \n /**\n+ * The contract for defining a way to interface with external source of data, such as a database, filesystem etc. As\n+ * the name implies, all of the methods in this class must <b>never</b> block the invoking thread.\n  * <p>\n- * Implementations of this store must be thread safe if concurrent operations are performed on it. This should include\n- * possibly invoking start or stop multiple times\n+ * The first method that will be invoked on this store will be the {@link #start(InitializationContext)} to allow\n+ * it to initialize and startup. Once the returned stage has completed the store is assumed to be in working condition\n+ * for other operations to be performed upon it. Infinispan will guarantee visibility of variables written during\n+ * the start method, so there is no need to synchronize these manually, unless they are mutated in the normal operations\n+ * of the store itself.\n+ * <p>\n+ * Infinispan may at any point after this store has started query what characteristics this store has via\n+ * {@link #characteristics()}. It is highly recommended that this method never change what values it returns once the\n+ * store has been started as these may or may not be cached. For more information on how the characteristics affect\n+ * the store operations, please see {@link Characteristic} and its various values.\n+ * <p>\n+ * By default this store only requires half a dozen or so methods to be implemented. However, there are more", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE0NjEyMQ==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429146121", "bodyText": "I would remove \"Note that\" and continue with \"If Infinispan...\"", "author": "ryanemerson", "createdAt": "2020-05-22T09:37:30Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -19,9 +24,51 @@\n import io.reactivex.rxjava3.core.Flowable;\n \n /**\n+ * The contract for defining a way to interface with external source of data, such as a database, filesystem etc. As\n+ * the name implies, all of the methods in this class must <b>never</b> block the invoking thread.\n  * <p>\n- * Implementations of this store must be thread safe if concurrent operations are performed on it. This should include\n- * possibly invoking start or stop multiple times\n+ * The first method that will be invoked on this store will be the {@link #start(InitializationContext)} to allow\n+ * it to initialize and startup. Once the returned stage has completed the store is assumed to be in working condition\n+ * for other operations to be performed upon it. Infinispan will guarantee visibility of variables written during\n+ * the start method, so there is no need to synchronize these manually, unless they are mutated in the normal operations\n+ * of the store itself.\n+ * <p>\n+ * Infinispan may at any point after this store has started query what characteristics this store has via\n+ * {@link #characteristics()}. It is highly recommended that this method never change what values it returns once the\n+ * store has been started as these may or may not be cached. For more information on how the characteristics affect\n+ * the store operations, please see {@link Characteristic} and its various values.\n+ * <p>\n+ * By default this store only requires half a dozen or so methods to be implemented. However, there are more\n+ * optional methods that may be implemented. If you implement such a method, please be sure to advertise the appropriate\n+ * characteristic for that method, so Infinispan knows to invoke it. Note that if Infinispan has been told a", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1MjA2NQ==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429152065", "bodyText": "This sentence needs rewording as I don't think it's clear. How about:\n\"Although recommended, Segmentation support in a store implementation is not required. Segment parameters are provided for all methods where segment information would be required, for example {@link #load(int, Object)} and {@link #publishEntries(IntSet, Predicate, boolean). When a store does not support segmentation, these parameters can simply be ignored by the implementation. As previously stated, it's recommended that segmentation is supported as an Infinispan cache can perform ...\"", "author": "ryanemerson", "createdAt": "2020-05-22T09:50:25Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -19,9 +24,51 @@\n import io.reactivex.rxjava3.core.Flowable;\n \n /**\n+ * The contract for defining a way to interface with external source of data, such as a database, filesystem etc. As\n+ * the name implies, all of the methods in this class must <b>never</b> block the invoking thread.\n  * <p>\n- * Implementations of this store must be thread safe if concurrent operations are performed on it. This should include\n- * possibly invoking start or stop multiple times\n+ * The first method that will be invoked on this store will be the {@link #start(InitializationContext)} to allow\n+ * it to initialize and startup. Once the returned stage has completed the store is assumed to be in working condition\n+ * for other operations to be performed upon it. Infinispan will guarantee visibility of variables written during\n+ * the start method, so there is no need to synchronize these manually, unless they are mutated in the normal operations\n+ * of the store itself.\n+ * <p>\n+ * Infinispan may at any point after this store has started query what characteristics this store has via\n+ * {@link #characteristics()}. It is highly recommended that this method never change what values it returns once the\n+ * store has been started as these may or may not be cached. For more information on how the characteristics affect\n+ * the store operations, please see {@link Characteristic} and its various values.\n+ * <p>\n+ * By default this store only requires half a dozen or so methods to be implemented. However, there are more\n+ * optional methods that may be implemented. If you implement such a method, please be sure to advertise the appropriate\n+ * characteristic for that method, so Infinispan knows to invoke it. Note that if Infinispan has been told a\n+ * characteristic is available and the method is not overridden, an {@link UnsupportedOperationException} will be\n+ * thrown when trying to invoke the appropriate method. Each {@link Characteristic} defines what methods map to which\n+ * characteristic.\n+ * <p>\n+ * All methods that are able include segment arguments in them, such as {@link #load(int, Object)} and\n+ * {@link #publishEntries(IntSet, Predicate, boolean)}. It is not required, but recommended if possible, for a store", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1MjQ2MQ==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429152461", "bodyText": "\"It also decreases state transfer duration when {@link PersistenceConfiguration#fetchPersistentState()} is enabled, as well as the time required to remove data by segments.\"", "author": "ryanemerson", "createdAt": "2020-05-22T09:51:15Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -19,9 +24,51 @@\n import io.reactivex.rxjava3.core.Flowable;\n \n /**\n+ * The contract for defining a way to interface with external source of data, such as a database, filesystem etc. As\n+ * the name implies, all of the methods in this class must <b>never</b> block the invoking thread.\n  * <p>\n- * Implementations of this store must be thread safe if concurrent operations are performed on it. This should include\n- * possibly invoking start or stop multiple times\n+ * The first method that will be invoked on this store will be the {@link #start(InitializationContext)} to allow\n+ * it to initialize and startup. Once the returned stage has completed the store is assumed to be in working condition\n+ * for other operations to be performed upon it. Infinispan will guarantee visibility of variables written during\n+ * the start method, so there is no need to synchronize these manually, unless they are mutated in the normal operations\n+ * of the store itself.\n+ * <p>\n+ * Infinispan may at any point after this store has started query what characteristics this store has via\n+ * {@link #characteristics()}. It is highly recommended that this method never change what values it returns once the\n+ * store has been started as these may or may not be cached. For more information on how the characteristics affect\n+ * the store operations, please see {@link Characteristic} and its various values.\n+ * <p>\n+ * By default this store only requires half a dozen or so methods to be implemented. However, there are more\n+ * optional methods that may be implemented. If you implement such a method, please be sure to advertise the appropriate\n+ * characteristic for that method, so Infinispan knows to invoke it. Note that if Infinispan has been told a\n+ * characteristic is available and the method is not overridden, an {@link UnsupportedOperationException} will be\n+ * thrown when trying to invoke the appropriate method. Each {@link Characteristic} defines what methods map to which\n+ * characteristic.\n+ * <p>\n+ * All methods that are able include segment arguments in them, such as {@link #load(int, Object)} and\n+ * {@link #publishEntries(IntSet, Predicate, boolean)}. It is not required, but recommended if possible, for a store\n+ * to support segmentation. An Infinispan Cache can perform much more efficiently when segmentation is supported when\n+ * performing bulk operations such as {@code Cache.size()} or {@code Cache.entrySet().stream()}. It also can very greatly\n+ * increase state transfer time, when {@link PersistenceConfiguration#fetchPersistentState()} is enabled and also when", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1NTM2OA==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429155368", "bodyText": "\"To indicate that a store implementation supports segmentation, it's necessary that the {@link Characteristic#SEGMENTABLE} characteristic is returned via the {@link #characteristics()} method.\"", "author": "ryanemerson", "createdAt": "2020-05-22T09:57:34Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -19,9 +24,51 @@\n import io.reactivex.rxjava3.core.Flowable;\n \n /**\n+ * The contract for defining a way to interface with external source of data, such as a database, filesystem etc. As\n+ * the name implies, all of the methods in this class must <b>never</b> block the invoking thread.\n  * <p>\n- * Implementations of this store must be thread safe if concurrent operations are performed on it. This should include\n- * possibly invoking start or stop multiple times\n+ * The first method that will be invoked on this store will be the {@link #start(InitializationContext)} to allow\n+ * it to initialize and startup. Once the returned stage has completed the store is assumed to be in working condition\n+ * for other operations to be performed upon it. Infinispan will guarantee visibility of variables written during\n+ * the start method, so there is no need to synchronize these manually, unless they are mutated in the normal operations\n+ * of the store itself.\n+ * <p>\n+ * Infinispan may at any point after this store has started query what characteristics this store has via\n+ * {@link #characteristics()}. It is highly recommended that this method never change what values it returns once the\n+ * store has been started as these may or may not be cached. For more information on how the characteristics affect\n+ * the store operations, please see {@link Characteristic} and its various values.\n+ * <p>\n+ * By default this store only requires half a dozen or so methods to be implemented. However, there are more\n+ * optional methods that may be implemented. If you implement such a method, please be sure to advertise the appropriate\n+ * characteristic for that method, so Infinispan knows to invoke it. Note that if Infinispan has been told a\n+ * characteristic is available and the method is not overridden, an {@link UnsupportedOperationException} will be\n+ * thrown when trying to invoke the appropriate method. Each {@link Characteristic} defines what methods map to which\n+ * characteristic.\n+ * <p>\n+ * All methods that are able include segment arguments in them, such as {@link #load(int, Object)} and\n+ * {@link #publishEntries(IntSet, Predicate, boolean)}. It is not required, but recommended if possible, for a store\n+ * to support segmentation. An Infinispan Cache can perform much more efficiently when segmentation is supported when\n+ * performing bulk operations such as {@code Cache.size()} or {@code Cache.entrySet().stream()}. It also can very greatly\n+ * increase state transfer time, when {@link PersistenceConfiguration#fetchPersistentState()} is enabled and also when\n+ * removing data by segments. Ensure that it the store implementation supports segmentation that it returns the", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1NzMzMg==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429157332", "bodyText": "\"A store implementation may have to interact with blocking APIs to perform their required operations, however we should never block the invoking thread, therefore Infinispan provides a utility helper for these operations.\"", "author": "ryanemerson", "createdAt": "2020-05-22T10:01:55Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -19,9 +24,51 @@\n import io.reactivex.rxjava3.core.Flowable;\n \n /**\n+ * The contract for defining a way to interface with external source of data, such as a database, filesystem etc. As\n+ * the name implies, all of the methods in this class must <b>never</b> block the invoking thread.\n  * <p>\n- * Implementations of this store must be thread safe if concurrent operations are performed on it. This should include\n- * possibly invoking start or stop multiple times\n+ * The first method that will be invoked on this store will be the {@link #start(InitializationContext)} to allow\n+ * it to initialize and startup. Once the returned stage has completed the store is assumed to be in working condition\n+ * for other operations to be performed upon it. Infinispan will guarantee visibility of variables written during\n+ * the start method, so there is no need to synchronize these manually, unless they are mutated in the normal operations\n+ * of the store itself.\n+ * <p>\n+ * Infinispan may at any point after this store has started query what characteristics this store has via\n+ * {@link #characteristics()}. It is highly recommended that this method never change what values it returns once the\n+ * store has been started as these may or may not be cached. For more information on how the characteristics affect\n+ * the store operations, please see {@link Characteristic} and its various values.\n+ * <p>\n+ * By default this store only requires half a dozen or so methods to be implemented. However, there are more\n+ * optional methods that may be implemented. If you implement such a method, please be sure to advertise the appropriate\n+ * characteristic for that method, so Infinispan knows to invoke it. Note that if Infinispan has been told a\n+ * characteristic is available and the method is not overridden, an {@link UnsupportedOperationException} will be\n+ * thrown when trying to invoke the appropriate method. Each {@link Characteristic} defines what methods map to which\n+ * characteristic.\n+ * <p>\n+ * All methods that are able include segment arguments in them, such as {@link #load(int, Object)} and\n+ * {@link #publishEntries(IntSet, Predicate, boolean)}. It is not required, but recommended if possible, for a store\n+ * to support segmentation. An Infinispan Cache can perform much more efficiently when segmentation is supported when\n+ * performing bulk operations such as {@code Cache.size()} or {@code Cache.entrySet().stream()}. It also can very greatly\n+ * increase state transfer time, when {@link PersistenceConfiguration#fetchPersistentState()} is enabled and also when\n+ * removing data by segments. Ensure that it the store implementation supports segmentation that it returns the\n+ * {@link Characteristic#SEGMENTABLE} characteristic when {@link #characteristics()} is invoked. A store implementation\n+ * can tell if segmentation is enabled by checking the store configuration {@link StoreConfiguration#segmented()} available\n+ * from the {@code InitializationContext}.\n+ * <p>\n+ * Some stores may have to interact with blocking APIs to perform their desired operation. Since we can never block", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1OTA0NQ==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429159045", "bodyText": "Hmm this is making me thinking that even write() etc should have no-op default methods that throw a UnsupportedOperationException. If I'm creating a READ_ONLY store why should I have to implement the method?", "author": "ryanemerson", "createdAt": "2020-05-22T10:05:52Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -32,33 +79,52 @@\n @Experimental\n public interface NonBlockingStore<K, V> {\n \n+   /**\n+    * Enumeration defining the various characteristics of the underlying store to communicate what features it may\n+    * or may not support.\n+    */\n    enum Characteristic {\n       /**\n        * Whether this cache can be shared between multiple nodes. An example would be an external system, such as\n-       * a database.\n+       * a database. This characteristic is here solely for validation of the store configuration.\n        */\n       SHAREABLE,\n       /**\n        * If this store only supports being read from.  Any write based operations will never be invoked on this store.\n+       * No optional methods map to this characteristic. The {@link #write(int, MarshallableEntry)},\n+       * {@link #delete(int, Object)}, {@link #bulkWrite(int, Publisher)}, and {@link #bulkDelete(int, Publisher)} methods\n+       * will not be invoked on a store that has this characteristic.", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwMjc4NQ==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429202785", "bodyText": "I had debated about that, however I felt that this case was rare enough that it is simpler to ensure they implement it. Because you can say the same thing with load in which case we wouldn't have many method to implement.\nThe other thing is we can always add a default later, however we can't remove default once it is there.", "author": "wburns", "createdAt": "2020-05-22T11:53:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1OTA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIxMTM0Mg==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429211342", "bodyText": "Yeah that's a good point. We can always address this if required later on.", "author": "ryanemerson", "createdAt": "2020-05-22T12:14:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE1OTA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2MDAyMg==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429160022", "bodyText": "I think we should describe characteristics being ignored one way, i.e. describe on a given characteristic if another can override it. So in this case just add the Note to BULK_READ that it is ignored if WRITE_ONLY is present, no need for both Javadocs to contain the note.", "author": "ryanemerson", "createdAt": "2020-05-22T10:08:11Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -32,33 +79,52 @@\n @Experimental\n public interface NonBlockingStore<K, V> {\n \n+   /**\n+    * Enumeration defining the various characteristics of the underlying store to communicate what features it may\n+    * or may not support.\n+    */\n    enum Characteristic {\n       /**\n        * Whether this cache can be shared between multiple nodes. An example would be an external system, such as\n-       * a database.\n+       * a database. This characteristic is here solely for validation of the store configuration.\n        */\n       SHAREABLE,\n       /**\n        * If this store only supports being read from.  Any write based operations will never be invoked on this store.\n+       * No optional methods map to this characteristic. The {@link #write(int, MarshallableEntry)},\n+       * {@link #delete(int, Object)}, {@link #bulkWrite(int, Publisher)}, and {@link #bulkDelete(int, Publisher)} methods\n+       * will not be invoked on a store that has this characteristic.\n+       * <p>\n+       * If this characteristic is provided, {@link #TRANSACTIONAL} will be ignored if also present.\n        */\n       READ_ONLY,\n       /**\n        * If this store only supports being written to. Any read based operations will never be invoked on this store.\n+       * No optional methods map to this characteristic. The {@link #load(int, Object)} and\n+       * {@link #containsKey(int, Object)} methods will not be invoked on a store that has this characteristic.\n+       * <p>\n+       * If this characteristic is provided, {@link #BULK_READ} will be ignored if also present.", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwMzI4NQ==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429203285", "bodyText": "Okay. I was trying to just be overly cautious as to how they were affected, I wondered about doing this.", "author": "wburns", "createdAt": "2020-05-22T11:54:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2MDAyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2MDk5OQ==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429160999", "bodyText": "\"The first method that will be invoked to allow the store to be configured and for any additional steps, such as connecting via a socket or opening file descriptors, to be performed.\"", "author": "ryanemerson", "createdAt": "2020-05-22T10:10:35Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -80,114 +146,344 @@\n        * SEGMENTABLE will never be allowed to be configured as segmented.\n        * <p>\n        * Stores that have this characteristic must override the {@link #addSegments(IntSet)} and\n-       * {@link #removeSegments(IntSet)} methods.\n+       * {@link #removeSegments(IntSet)} methods. If a store is {@link #SHAREABLE} and is configured to be shared\n+       * via configuration these methods will not be invoked though.\n        */\n       SEGMENTABLE,\n       /**\n-       * If this store supports storing expiration metadata. Certain methods may or may not include expired entries.\n+       * If this store supports storing expiration metadata. That is this store should never return an expired entry\n+       * via any methods such as {@link #load(int, Object)}, {@link #publishKeys(IntSet, Predicate)} or\n+       * {@link #publishEntries(IntSet, Predicate, boolean)}. It is recommended that a store use the provided\n+       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if an\n+       * entry has expired.\n+       * <p>\n+       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata}\n+       * which is accessible from the {@link MarshallableEntry} which is provided.\n        * <p>\n        * Stores that have this characteristic must override the {@link #purgeExpired()} method.\n        */\n       EXPIRATION\n    }\n \n    /**\n+    * The first method that will be invoked on this store to allow for the store to configure and do any additional\n+    * steps, such as connecting via socket or opening file descriptors.", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2MTU1MQ==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429161551", "bodyText": "\"This method will be invoked when the cache is being shutdown.\"", "author": "ryanemerson", "createdAt": "2020-05-22T10:11:47Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -80,114 +146,344 @@\n        * SEGMENTABLE will never be allowed to be configured as segmented.\n        * <p>\n        * Stores that have this characteristic must override the {@link #addSegments(IntSet)} and\n-       * {@link #removeSegments(IntSet)} methods.\n+       * {@link #removeSegments(IntSet)} methods. If a store is {@link #SHAREABLE} and is configured to be shared\n+       * via configuration these methods will not be invoked though.\n        */\n       SEGMENTABLE,\n       /**\n-       * If this store supports storing expiration metadata. Certain methods may or may not include expired entries.\n+       * If this store supports storing expiration metadata. That is this store should never return an expired entry\n+       * via any methods such as {@link #load(int, Object)}, {@link #publishKeys(IntSet, Predicate)} or\n+       * {@link #publishEntries(IntSet, Predicate, boolean)}. It is recommended that a store use the provided\n+       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if an\n+       * entry has expired.\n+       * <p>\n+       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata}\n+       * which is accessible from the {@link MarshallableEntry} which is provided.\n        * <p>\n        * Stores that have this characteristic must override the {@link #purgeExpired()} method.\n        */\n       EXPIRATION\n    }\n \n    /**\n+    * The first method that will be invoked on this store to allow for the store to configure and do any additional\n+    * steps, such as connecting via socket or opening file descriptors.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n+    * The provided {@link InitializationContext} contains many helpful objects, including the configuration of the\n+    * cache and store, concurrency utilities such as {@link org.infinispan.util.concurrent.BlockingManager} or\n+    * an executor reserved for non blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n+    * <p>\n+    * This method is guaranteed to not be invoked concurrently with other operations. This means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@code start} a second time if\n+    * {@link #stop()} has been invoked and allowed for its stage to complete.\n     * @param ctx initialization context used to initialize this store\n     * @return a stage that when complete signals that this store has been successfully started\n     */\n    CompletionStage<Void> start(InitializationContext ctx);\n \n    /**\n+    * This method will be invoked is being shut down. It is expected that all resources related to the store to be", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2MTgzNQ==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429161835", "bodyText": "\"This method will be invoked multiple times to ...\"", "author": "ryanemerson", "createdAt": "2020-05-22T10:12:22Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -80,114 +146,344 @@\n        * SEGMENTABLE will never be allowed to be configured as segmented.\n        * <p>\n        * Stores that have this characteristic must override the {@link #addSegments(IntSet)} and\n-       * {@link #removeSegments(IntSet)} methods.\n+       * {@link #removeSegments(IntSet)} methods. If a store is {@link #SHAREABLE} and is configured to be shared\n+       * via configuration these methods will not be invoked though.\n        */\n       SEGMENTABLE,\n       /**\n-       * If this store supports storing expiration metadata. Certain methods may or may not include expired entries.\n+       * If this store supports storing expiration metadata. That is this store should never return an expired entry\n+       * via any methods such as {@link #load(int, Object)}, {@link #publishKeys(IntSet, Predicate)} or\n+       * {@link #publishEntries(IntSet, Predicate, boolean)}. It is recommended that a store use the provided\n+       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if an\n+       * entry has expired.\n+       * <p>\n+       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata}\n+       * which is accessible from the {@link MarshallableEntry} which is provided.\n        * <p>\n        * Stores that have this characteristic must override the {@link #purgeExpired()} method.\n        */\n       EXPIRATION\n    }\n \n    /**\n+    * The first method that will be invoked on this store to allow for the store to configure and do any additional\n+    * steps, such as connecting via socket or opening file descriptors.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n+    * The provided {@link InitializationContext} contains many helpful objects, including the configuration of the\n+    * cache and store, concurrency utilities such as {@link org.infinispan.util.concurrent.BlockingManager} or\n+    * an executor reserved for non blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n+    * <p>\n+    * This method is guaranteed to not be invoked concurrently with other operations. This means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@code start} a second time if\n+    * {@link #stop()} has been invoked and allowed for its stage to complete.\n     * @param ctx initialization context used to initialize this store\n     * @return a stage that when complete signals that this store has been successfully started\n     */\n    CompletionStage<Void> start(InitializationContext ctx);\n \n    /**\n+    * This method will be invoked is being shut down. It is expected that all resources related to the store to be\n+    * freed upon completion of the returned stage.\n     * <p>\n     * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@link #start(InitializationContext)}\n+    * a second time if {@code stop} has been invoked and allowed for its stage to complete.\n     * @return a stage that when complete signals that this store has been stopped\n     */\n    CompletionStage<Void> stop();\n \n    /**\n-    *\n-    * @return\n+    * Returns a set of characteristics for this store and its elements. This method will be invoked one to many times\n+    * to determine which methods of the store can be used and how its data can be handled.", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwNDkyMw==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429204923", "bodyText": "Tweaked to \"This method may be invoked multiple times to ...\"", "author": "wburns", "createdAt": "2020-05-22T11:58:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2MTgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwNTExMQ==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429205111", "bodyText": "Although that doesn't convey it will be invoked at least one time, which is what I was going for before. WDYT?", "author": "wburns", "createdAt": "2020-05-22T11:59:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2MTgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIxMTAxMQ==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429211011", "bodyText": "\"One or more times\"?\nAs long as the user knows to handle the fact that the method may be invoked multiple times, I don't think that it could be called just once really matters.", "author": "ryanemerson", "createdAt": "2020-05-22T12:14:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2MTgzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2MjYzOA==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429162638", "bodyText": "\"that when complete returns a boolean indicating whether the current store can be ...\"", "author": "ryanemerson", "createdAt": "2020-05-22T10:14:16Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -80,114 +146,344 @@\n        * SEGMENTABLE will never be allowed to be configured as segmented.\n        * <p>\n        * Stores that have this characteristic must override the {@link #addSegments(IntSet)} and\n-       * {@link #removeSegments(IntSet)} methods.\n+       * {@link #removeSegments(IntSet)} methods. If a store is {@link #SHAREABLE} and is configured to be shared\n+       * via configuration these methods will not be invoked though.\n        */\n       SEGMENTABLE,\n       /**\n-       * If this store supports storing expiration metadata. Certain methods may or may not include expired entries.\n+       * If this store supports storing expiration metadata. That is this store should never return an expired entry\n+       * via any methods such as {@link #load(int, Object)}, {@link #publishKeys(IntSet, Predicate)} or\n+       * {@link #publishEntries(IntSet, Predicate, boolean)}. It is recommended that a store use the provided\n+       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if an\n+       * entry has expired.\n+       * <p>\n+       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata}\n+       * which is accessible from the {@link MarshallableEntry} which is provided.\n        * <p>\n        * Stores that have this characteristic must override the {@link #purgeExpired()} method.\n        */\n       EXPIRATION\n    }\n \n    /**\n+    * The first method that will be invoked on this store to allow for the store to configure and do any additional\n+    * steps, such as connecting via socket or opening file descriptors.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n+    * The provided {@link InitializationContext} contains many helpful objects, including the configuration of the\n+    * cache and store, concurrency utilities such as {@link org.infinispan.util.concurrent.BlockingManager} or\n+    * an executor reserved for non blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n+    * <p>\n+    * This method is guaranteed to not be invoked concurrently with other operations. This means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@code start} a second time if\n+    * {@link #stop()} has been invoked and allowed for its stage to complete.\n     * @param ctx initialization context used to initialize this store\n     * @return a stage that when complete signals that this store has been successfully started\n     */\n    CompletionStage<Void> start(InitializationContext ctx);\n \n    /**\n+    * This method will be invoked is being shut down. It is expected that all resources related to the store to be\n+    * freed upon completion of the returned stage.\n     * <p>\n     * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@link #start(InitializationContext)}\n+    * a second time if {@code stop} has been invoked and allowed for its stage to complete.\n     * @return a stage that when complete signals that this store has been stopped\n     */\n    CompletionStage<Void> stop();\n \n    /**\n-    *\n-    * @return\n+    * Returns a set of characteristics for this store and its elements. This method will be invoked one to many times\n+    * to determine which methods of the store can be used and how its data can be handled.\n+    * <p>\n+    * Please see {@link Characteristic} and its values for a description of what each characteristic declares the\n+    * store as supporting.\n+    * @implSpec\n+    * The default implementation returns an empty set\n+    * @return the set of characteristics that this store supports\n     */\n    default Set<Characteristic> characteristics() {\n       return EnumSet.noneOf(Characteristic.class);\n    }\n \n    /**\n-    *\n-    * @return\n+    * Returns a stage that when complete will tell if the current store can be accessed for requests. This can be useful", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2Mjk5NA==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429162994", "bodyText": "\"This can be useful for store implementations that rely on an external source, such as a remote database, that may become unreachable.\"", "author": "ryanemerson", "createdAt": "2020-05-22T10:15:07Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -80,114 +146,344 @@\n        * SEGMENTABLE will never be allowed to be configured as segmented.\n        * <p>\n        * Stores that have this characteristic must override the {@link #addSegments(IntSet)} and\n-       * {@link #removeSegments(IntSet)} methods.\n+       * {@link #removeSegments(IntSet)} methods. If a store is {@link #SHAREABLE} and is configured to be shared\n+       * via configuration these methods will not be invoked though.\n        */\n       SEGMENTABLE,\n       /**\n-       * If this store supports storing expiration metadata. Certain methods may or may not include expired entries.\n+       * If this store supports storing expiration metadata. That is this store should never return an expired entry\n+       * via any methods such as {@link #load(int, Object)}, {@link #publishKeys(IntSet, Predicate)} or\n+       * {@link #publishEntries(IntSet, Predicate, boolean)}. It is recommended that a store use the provided\n+       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if an\n+       * entry has expired.\n+       * <p>\n+       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata}\n+       * which is accessible from the {@link MarshallableEntry} which is provided.\n        * <p>\n        * Stores that have this characteristic must override the {@link #purgeExpired()} method.\n        */\n       EXPIRATION\n    }\n \n    /**\n+    * The first method that will be invoked on this store to allow for the store to configure and do any additional\n+    * steps, such as connecting via socket or opening file descriptors.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n+    * The provided {@link InitializationContext} contains many helpful objects, including the configuration of the\n+    * cache and store, concurrency utilities such as {@link org.infinispan.util.concurrent.BlockingManager} or\n+    * an executor reserved for non blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n+    * <p>\n+    * This method is guaranteed to not be invoked concurrently with other operations. This means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@code start} a second time if\n+    * {@link #stop()} has been invoked and allowed for its stage to complete.\n     * @param ctx initialization context used to initialize this store\n     * @return a stage that when complete signals that this store has been successfully started\n     */\n    CompletionStage<Void> start(InitializationContext ctx);\n \n    /**\n+    * This method will be invoked is being shut down. It is expected that all resources related to the store to be\n+    * freed upon completion of the returned stage.\n     * <p>\n     * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@link #start(InitializationContext)}\n+    * a second time if {@code stop} has been invoked and allowed for its stage to complete.\n     * @return a stage that when complete signals that this store has been stopped\n     */\n    CompletionStage<Void> stop();\n \n    /**\n-    *\n-    * @return\n+    * Returns a set of characteristics for this store and its elements. This method will be invoked one to many times\n+    * to determine which methods of the store can be used and how its data can be handled.\n+    * <p>\n+    * Please see {@link Characteristic} and its values for a description of what each characteristic declares the\n+    * store as supporting.\n+    * @implSpec\n+    * The default implementation returns an empty set\n+    * @return the set of characteristics that this store supports\n     */\n    default Set<Characteristic> characteristics() {\n       return EnumSet.noneOf(Characteristic.class);\n    }\n \n    /**\n-    *\n-    * @return\n+    * Returns a stage that when complete will tell if the current store can be accessed for requests. This can be useful\n+    * for some store implementations that may rely on an external source that may become unreachable. This can reduce", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2MzgyMA==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429163820", "bodyText": "\"not available, as subsequent cache requests will result in a {@link StoreUnavailableException} being thrown until the store becomes available again.\"", "author": "ryanemerson", "createdAt": "2020-05-22T10:17:07Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -80,114 +146,344 @@\n        * SEGMENTABLE will never be allowed to be configured as segmented.\n        * <p>\n        * Stores that have this characteristic must override the {@link #addSegments(IntSet)} and\n-       * {@link #removeSegments(IntSet)} methods.\n+       * {@link #removeSegments(IntSet)} methods. If a store is {@link #SHAREABLE} and is configured to be shared\n+       * via configuration these methods will not be invoked though.\n        */\n       SEGMENTABLE,\n       /**\n-       * If this store supports storing expiration metadata. Certain methods may or may not include expired entries.\n+       * If this store supports storing expiration metadata. That is this store should never return an expired entry\n+       * via any methods such as {@link #load(int, Object)}, {@link #publishKeys(IntSet, Predicate)} or\n+       * {@link #publishEntries(IntSet, Predicate, boolean)}. It is recommended that a store use the provided\n+       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if an\n+       * entry has expired.\n+       * <p>\n+       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata}\n+       * which is accessible from the {@link MarshallableEntry} which is provided.\n        * <p>\n        * Stores that have this characteristic must override the {@link #purgeExpired()} method.\n        */\n       EXPIRATION\n    }\n \n    /**\n+    * The first method that will be invoked on this store to allow for the store to configure and do any additional\n+    * steps, such as connecting via socket or opening file descriptors.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n+    * The provided {@link InitializationContext} contains many helpful objects, including the configuration of the\n+    * cache and store, concurrency utilities such as {@link org.infinispan.util.concurrent.BlockingManager} or\n+    * an executor reserved for non blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n+    * <p>\n+    * This method is guaranteed to not be invoked concurrently with other operations. This means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@code start} a second time if\n+    * {@link #stop()} has been invoked and allowed for its stage to complete.\n     * @param ctx initialization context used to initialize this store\n     * @return a stage that when complete signals that this store has been successfully started\n     */\n    CompletionStage<Void> start(InitializationContext ctx);\n \n    /**\n+    * This method will be invoked is being shut down. It is expected that all resources related to the store to be\n+    * freed upon completion of the returned stage.\n     * <p>\n     * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@link #start(InitializationContext)}\n+    * a second time if {@code stop} has been invoked and allowed for its stage to complete.\n     * @return a stage that when complete signals that this store has been stopped\n     */\n    CompletionStage<Void> stop();\n \n    /**\n-    *\n-    * @return\n+    * Returns a set of characteristics for this store and its elements. This method will be invoked one to many times\n+    * to determine which methods of the store can be used and how its data can be handled.\n+    * <p>\n+    * Please see {@link Characteristic} and its values for a description of what each characteristic declares the\n+    * store as supporting.\n+    * @implSpec\n+    * The default implementation returns an empty set\n+    * @return the set of characteristics that this store supports\n     */\n    default Set<Characteristic> characteristics() {\n       return EnumSet.noneOf(Characteristic.class);\n    }\n \n    /**\n-    *\n-    * @return\n+    * Returns a stage that when complete will tell if the current store can be accessed for requests. This can be useful\n+    * for some store implementations that may rely on an external source that may become unreachable. This can reduce\n+    * sending requests to a store that is not available as future Cache requests will all be met with", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2NDE5Nw==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429164197", "bodyText": "\"is polled periodically to update a store's status if it's availability changes.", "author": "ryanemerson", "createdAt": "2020-05-22T10:17:59Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -80,114 +146,344 @@\n        * SEGMENTABLE will never be allowed to be configured as segmented.\n        * <p>\n        * Stores that have this characteristic must override the {@link #addSegments(IntSet)} and\n-       * {@link #removeSegments(IntSet)} methods.\n+       * {@link #removeSegments(IntSet)} methods. If a store is {@link #SHAREABLE} and is configured to be shared\n+       * via configuration these methods will not be invoked though.\n        */\n       SEGMENTABLE,\n       /**\n-       * If this store supports storing expiration metadata. Certain methods may or may not include expired entries.\n+       * If this store supports storing expiration metadata. That is this store should never return an expired entry\n+       * via any methods such as {@link #load(int, Object)}, {@link #publishKeys(IntSet, Predicate)} or\n+       * {@link #publishEntries(IntSet, Predicate, boolean)}. It is recommended that a store use the provided\n+       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if an\n+       * entry has expired.\n+       * <p>\n+       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata}\n+       * which is accessible from the {@link MarshallableEntry} which is provided.\n        * <p>\n        * Stores that have this characteristic must override the {@link #purgeExpired()} method.\n        */\n       EXPIRATION\n    }\n \n    /**\n+    * The first method that will be invoked on this store to allow for the store to configure and do any additional\n+    * steps, such as connecting via socket or opening file descriptors.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n+    * The provided {@link InitializationContext} contains many helpful objects, including the configuration of the\n+    * cache and store, concurrency utilities such as {@link org.infinispan.util.concurrent.BlockingManager} or\n+    * an executor reserved for non blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n+    * <p>\n+    * This method is guaranteed to not be invoked concurrently with other operations. This means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@code start} a second time if\n+    * {@link #stop()} has been invoked and allowed for its stage to complete.\n     * @param ctx initialization context used to initialize this store\n     * @return a stage that when complete signals that this store has been successfully started\n     */\n    CompletionStage<Void> start(InitializationContext ctx);\n \n    /**\n+    * This method will be invoked is being shut down. It is expected that all resources related to the store to be\n+    * freed upon completion of the returned stage.\n     * <p>\n     * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@link #start(InitializationContext)}\n+    * a second time if {@code stop} has been invoked and allowed for its stage to complete.\n     * @return a stage that when complete signals that this store has been stopped\n     */\n    CompletionStage<Void> stop();\n \n    /**\n-    *\n-    * @return\n+    * Returns a set of characteristics for this store and its elements. This method will be invoked one to many times\n+    * to determine which methods of the store can be used and how its data can be handled.\n+    * <p>\n+    * Please see {@link Characteristic} and its values for a description of what each characteristic declares the\n+    * store as supporting.\n+    * @implSpec\n+    * The default implementation returns an empty set\n+    * @return the set of characteristics that this store supports\n     */\n    default Set<Characteristic> characteristics() {\n       return EnumSet.noneOf(Characteristic.class);\n    }\n \n    /**\n-    *\n-    * @return\n+    * Returns a stage that when complete will tell if the current store can be accessed for requests. This can be useful\n+    * for some store implementations that may rely on an external source that may become unreachable. This can reduce\n+    * sending requests to a store that is not available as future Cache requests will all be met with\n+    * {@link StoreUnavailableException}.\n+    * <p>\n+    * Store availability is polled automatically every so often to update the status if the underlying store changes", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2NDM3OA==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429164378", "bodyText": "link to the methods?", "author": "ryanemerson", "createdAt": "2020-05-22T10:18:29Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -80,114 +146,344 @@\n        * SEGMENTABLE will never be allowed to be configured as segmented.\n        * <p>\n        * Stores that have this characteristic must override the {@link #addSegments(IntSet)} and\n-       * {@link #removeSegments(IntSet)} methods.\n+       * {@link #removeSegments(IntSet)} methods. If a store is {@link #SHAREABLE} and is configured to be shared\n+       * via configuration these methods will not be invoked though.\n        */\n       SEGMENTABLE,\n       /**\n-       * If this store supports storing expiration metadata. Certain methods may or may not include expired entries.\n+       * If this store supports storing expiration metadata. That is this store should never return an expired entry\n+       * via any methods such as {@link #load(int, Object)}, {@link #publishKeys(IntSet, Predicate)} or\n+       * {@link #publishEntries(IntSet, Predicate, boolean)}. It is recommended that a store use the provided\n+       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if an\n+       * entry has expired.\n+       * <p>\n+       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata}\n+       * which is accessible from the {@link MarshallableEntry} which is provided.\n        * <p>\n        * Stores that have this characteristic must override the {@link #purgeExpired()} method.\n        */\n       EXPIRATION\n    }\n \n    /**\n+    * The first method that will be invoked on this store to allow for the store to configure and do any additional\n+    * steps, such as connecting via socket or opening file descriptors.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n+    * The provided {@link InitializationContext} contains many helpful objects, including the configuration of the\n+    * cache and store, concurrency utilities such as {@link org.infinispan.util.concurrent.BlockingManager} or\n+    * an executor reserved for non blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n+    * <p>\n+    * This method is guaranteed to not be invoked concurrently with other operations. This means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@code start} a second time if\n+    * {@link #stop()} has been invoked and allowed for its stage to complete.\n     * @param ctx initialization context used to initialize this store\n     * @return a stage that when complete signals that this store has been successfully started\n     */\n    CompletionStage<Void> start(InitializationContext ctx);\n \n    /**\n+    * This method will be invoked is being shut down. It is expected that all resources related to the store to be\n+    * freed upon completion of the returned stage.\n     * <p>\n     * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@link #start(InitializationContext)}\n+    * a second time if {@code stop} has been invoked and allowed for its stage to complete.\n     * @return a stage that when complete signals that this store has been stopped\n     */\n    CompletionStage<Void> stop();\n \n    /**\n-    *\n-    * @return\n+    * Returns a set of characteristics for this store and its elements. This method will be invoked one to many times\n+    * to determine which methods of the store can be used and how its data can be handled.\n+    * <p>\n+    * Please see {@link Characteristic} and its values for a description of what each characteristic declares the\n+    * store as supporting.\n+    * @implSpec\n+    * The default implementation returns an empty set\n+    * @return the set of characteristics that this store supports\n     */\n    default Set<Characteristic> characteristics() {\n       return EnumSet.noneOf(Characteristic.class);\n    }\n \n    /**\n-    *\n-    * @return\n+    * Returns a stage that when complete will tell if the current store can be accessed for requests. This can be useful\n+    * for some store implementations that may rely on an external source that may become unreachable. This can reduce\n+    * sending requests to a store that is not available as future Cache requests will all be met with\n+    * {@link StoreUnavailableException}.\n+    * <p>\n+    * Store availability is polled automatically every so often to update the status if the underlying store changes\n+    * availability. This method will not be invoked concurrently with itself (ie. this method will not be invoked\n+    * until after the previous stage has completed), but will be invoked concurrently with other operations, excluding\n+    * start and stop.", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2Njk5NA==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429166994", "bodyText": "\"If a store is configured to be {@link StoreConfiguration#async()} and the store becomes unavailable, then it's possible for the cache operations to be accepted in the interim period between the loss of availability and the modification-queue becoming full. This allows for this store to be unavailable for short periods of time without a {@link StoreUnavailableException} being thrown, however if the store does not become available before the queue fills, then a {@link StoreUnavailableException} is eventually thrown.", "author": "ryanemerson", "createdAt": "2020-05-22T10:24:32Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -80,114 +146,344 @@\n        * SEGMENTABLE will never be allowed to be configured as segmented.\n        * <p>\n        * Stores that have this characteristic must override the {@link #addSegments(IntSet)} and\n-       * {@link #removeSegments(IntSet)} methods.\n+       * {@link #removeSegments(IntSet)} methods. If a store is {@link #SHAREABLE} and is configured to be shared\n+       * via configuration these methods will not be invoked though.\n        */\n       SEGMENTABLE,\n       /**\n-       * If this store supports storing expiration metadata. Certain methods may or may not include expired entries.\n+       * If this store supports storing expiration metadata. That is this store should never return an expired entry\n+       * via any methods such as {@link #load(int, Object)}, {@link #publishKeys(IntSet, Predicate)} or\n+       * {@link #publishEntries(IntSet, Predicate, boolean)}. It is recommended that a store use the provided\n+       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if an\n+       * entry has expired.\n+       * <p>\n+       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata}\n+       * which is accessible from the {@link MarshallableEntry} which is provided.\n        * <p>\n        * Stores that have this characteristic must override the {@link #purgeExpired()} method.\n        */\n       EXPIRATION\n    }\n \n    /**\n+    * The first method that will be invoked on this store to allow for the store to configure and do any additional\n+    * steps, such as connecting via socket or opening file descriptors.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n+    * The provided {@link InitializationContext} contains many helpful objects, including the configuration of the\n+    * cache and store, concurrency utilities such as {@link org.infinispan.util.concurrent.BlockingManager} or\n+    * an executor reserved for non blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n+    * <p>\n+    * This method is guaranteed to not be invoked concurrently with other operations. This means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@code start} a second time if\n+    * {@link #stop()} has been invoked and allowed for its stage to complete.\n     * @param ctx initialization context used to initialize this store\n     * @return a stage that when complete signals that this store has been successfully started\n     */\n    CompletionStage<Void> start(InitializationContext ctx);\n \n    /**\n+    * This method will be invoked is being shut down. It is expected that all resources related to the store to be\n+    * freed upon completion of the returned stage.\n     * <p>\n     * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@link #start(InitializationContext)}\n+    * a second time if {@code stop} has been invoked and allowed for its stage to complete.\n     * @return a stage that when complete signals that this store has been stopped\n     */\n    CompletionStage<Void> stop();\n \n    /**\n-    *\n-    * @return\n+    * Returns a set of characteristics for this store and its elements. This method will be invoked one to many times\n+    * to determine which methods of the store can be used and how its data can be handled.\n+    * <p>\n+    * Please see {@link Characteristic} and its values for a description of what each characteristic declares the\n+    * store as supporting.\n+    * @implSpec\n+    * The default implementation returns an empty set\n+    * @return the set of characteristics that this store supports\n     */\n    default Set<Characteristic> characteristics() {\n       return EnumSet.noneOf(Characteristic.class);\n    }\n \n    /**\n-    *\n-    * @return\n+    * Returns a stage that when complete will tell if the current store can be accessed for requests. This can be useful\n+    * for some store implementations that may rely on an external source that may become unreachable. This can reduce\n+    * sending requests to a store that is not available as future Cache requests will all be met with\n+    * {@link StoreUnavailableException}.\n+    * <p>\n+    * Store availability is polled automatically every so often to update the status if the underlying store changes\n+    * availability. This method will not be invoked concurrently with itself (ie. this method will not be invoked\n+    * until after the previous stage has completed), but will be invoked concurrently with other operations, excluding\n+    * start and stop.\n+    * <p>\n+    * The other benefit of implementing this method is if the store is configured to be\n+    * {@link StoreConfiguration#async()}. This allows for this store to be unavailable for short periods of time\n+    * until its buffer fills.", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2NzQwMw==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429167403", "bodyText": "\"to assist\" is redundant.", "author": "ryanemerson", "createdAt": "2020-05-22T10:25:34Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -80,114 +146,344 @@\n        * SEGMENTABLE will never be allowed to be configured as segmented.\n        * <p>\n        * Stores that have this characteristic must override the {@link #addSegments(IntSet)} and\n-       * {@link #removeSegments(IntSet)} methods.\n+       * {@link #removeSegments(IntSet)} methods. If a store is {@link #SHAREABLE} and is configured to be shared\n+       * via configuration these methods will not be invoked though.\n        */\n       SEGMENTABLE,\n       /**\n-       * If this store supports storing expiration metadata. Certain methods may or may not include expired entries.\n+       * If this store supports storing expiration metadata. That is this store should never return an expired entry\n+       * via any methods such as {@link #load(int, Object)}, {@link #publishKeys(IntSet, Predicate)} or\n+       * {@link #publishEntries(IntSet, Predicate, boolean)}. It is recommended that a store use the provided\n+       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if an\n+       * entry has expired.\n+       * <p>\n+       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata}\n+       * which is accessible from the {@link MarshallableEntry} which is provided.\n        * <p>\n        * Stores that have this characteristic must override the {@link #purgeExpired()} method.\n        */\n       EXPIRATION\n    }\n \n    /**\n+    * The first method that will be invoked on this store to allow for the store to configure and do any additional\n+    * steps, such as connecting via socket or opening file descriptors.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n+    * The provided {@link InitializationContext} contains many helpful objects, including the configuration of the\n+    * cache and store, concurrency utilities such as {@link org.infinispan.util.concurrent.BlockingManager} or\n+    * an executor reserved for non blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n+    * <p>\n+    * This method is guaranteed to not be invoked concurrently with other operations. This means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@code start} a second time if\n+    * {@link #stop()} has been invoked and allowed for its stage to complete.\n     * @param ctx initialization context used to initialize this store\n     * @return a stage that when complete signals that this store has been successfully started\n     */\n    CompletionStage<Void> start(InitializationContext ctx);\n \n    /**\n+    * This method will be invoked is being shut down. It is expected that all resources related to the store to be\n+    * freed upon completion of the returned stage.\n     * <p>\n     * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@link #start(InitializationContext)}\n+    * a second time if {@code stop} has been invoked and allowed for its stage to complete.\n     * @return a stage that when complete signals that this store has been stopped\n     */\n    CompletionStage<Void> stop();\n \n    /**\n-    *\n-    * @return\n+    * Returns a set of characteristics for this store and its elements. This method will be invoked one to many times\n+    * to determine which methods of the store can be used and how its data can be handled.\n+    * <p>\n+    * Please see {@link Characteristic} and its values for a description of what each characteristic declares the\n+    * store as supporting.\n+    * @implSpec\n+    * The default implementation returns an empty set\n+    * @return the set of characteristics that this store supports\n     */\n    default Set<Characteristic> characteristics() {\n       return EnumSet.noneOf(Characteristic.class);\n    }\n \n    /**\n-    *\n-    * @return\n+    * Returns a stage that when complete will tell if the current store can be accessed for requests. This can be useful\n+    * for some store implementations that may rely on an external source that may become unreachable. This can reduce\n+    * sending requests to a store that is not available as future Cache requests will all be met with\n+    * {@link StoreUnavailableException}.\n+    * <p>\n+    * Store availability is polled automatically every so often to update the status if the underlying store changes\n+    * availability. This method will not be invoked concurrently with itself (ie. this method will not be invoked\n+    * until after the previous stage has completed), but will be invoked concurrently with other operations, excluding\n+    * start and stop.\n+    * <p>\n+    * The other benefit of implementing this method is if the store is configured to be\n+    * {@link StoreConfiguration#async()}. This allows for this store to be unavailable for short periods of time\n+    * until its buffer fills.\n+    * @implSpec\n+    * The default implementations returns a completed stage with the value {@code Boolean.TRUE}\n+    * @return stage that when complete signals if the store is available\n     */\n    default CompletionStage<Boolean> isAvailable() {\n       return CompletableFutures.completedTrue();\n    }\n \n    /**\n-    *\n-    * @param segment\n-    * @param key\n-    * @return\n+    * Returns a stage that will contain the value loaded from the store. If a {@link MarshallableEntry} needs to be\n+    * created here, {@link InitializationContext#getMarshallableEntryFactory()} ()} and {@link\n+    * InitializationContext#getByteBufferFactory()} should be used to assist.", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTIwNzMxMA==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429207310", "bodyText": "That is what I get from copying from the original, haha.", "author": "wburns", "createdAt": "2020-05-22T12:04:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2NzQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2ODA0OA==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429168048", "bodyText": "\"If a problem is encountered, it is recommended to wrap any created/caught throwables in a {@link PersistenceException} and the stage be completed exceptionally.\"", "author": "ryanemerson", "createdAt": "2020-05-22T10:27:13Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -80,114 +146,344 @@\n        * SEGMENTABLE will never be allowed to be configured as segmented.\n        * <p>\n        * Stores that have this characteristic must override the {@link #addSegments(IntSet)} and\n-       * {@link #removeSegments(IntSet)} methods.\n+       * {@link #removeSegments(IntSet)} methods. If a store is {@link #SHAREABLE} and is configured to be shared\n+       * via configuration these methods will not be invoked though.\n        */\n       SEGMENTABLE,\n       /**\n-       * If this store supports storing expiration metadata. Certain methods may or may not include expired entries.\n+       * If this store supports storing expiration metadata. That is this store should never return an expired entry\n+       * via any methods such as {@link #load(int, Object)}, {@link #publishKeys(IntSet, Predicate)} or\n+       * {@link #publishEntries(IntSet, Predicate, boolean)}. It is recommended that a store use the provided\n+       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if an\n+       * entry has expired.\n+       * <p>\n+       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata}\n+       * which is accessible from the {@link MarshallableEntry} which is provided.\n        * <p>\n        * Stores that have this characteristic must override the {@link #purgeExpired()} method.\n        */\n       EXPIRATION\n    }\n \n    /**\n+    * The first method that will be invoked on this store to allow for the store to configure and do any additional\n+    * steps, such as connecting via socket or opening file descriptors.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n+    * The provided {@link InitializationContext} contains many helpful objects, including the configuration of the\n+    * cache and store, concurrency utilities such as {@link org.infinispan.util.concurrent.BlockingManager} or\n+    * an executor reserved for non blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n+    * <p>\n+    * This method is guaranteed to not be invoked concurrently with other operations. This means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@code start} a second time if\n+    * {@link #stop()} has been invoked and allowed for its stage to complete.\n     * @param ctx initialization context used to initialize this store\n     * @return a stage that when complete signals that this store has been successfully started\n     */\n    CompletionStage<Void> start(InitializationContext ctx);\n \n    /**\n+    * This method will be invoked is being shut down. It is expected that all resources related to the store to be\n+    * freed upon completion of the returned stage.\n     * <p>\n     * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@link #start(InitializationContext)}\n+    * a second time if {@code stop} has been invoked and allowed for its stage to complete.\n     * @return a stage that when complete signals that this store has been stopped\n     */\n    CompletionStage<Void> stop();\n \n    /**\n-    *\n-    * @return\n+    * Returns a set of characteristics for this store and its elements. This method will be invoked one to many times\n+    * to determine which methods of the store can be used and how its data can be handled.\n+    * <p>\n+    * Please see {@link Characteristic} and its values for a description of what each characteristic declares the\n+    * store as supporting.\n+    * @implSpec\n+    * The default implementation returns an empty set\n+    * @return the set of characteristics that this store supports\n     */\n    default Set<Characteristic> characteristics() {\n       return EnumSet.noneOf(Characteristic.class);\n    }\n \n    /**\n-    *\n-    * @return\n+    * Returns a stage that when complete will tell if the current store can be accessed for requests. This can be useful\n+    * for some store implementations that may rely on an external source that may become unreachable. This can reduce\n+    * sending requests to a store that is not available as future Cache requests will all be met with\n+    * {@link StoreUnavailableException}.\n+    * <p>\n+    * Store availability is polled automatically every so often to update the status if the underlying store changes\n+    * availability. This method will not be invoked concurrently with itself (ie. this method will not be invoked\n+    * until after the previous stage has completed), but will be invoked concurrently with other operations, excluding\n+    * start and stop.\n+    * <p>\n+    * The other benefit of implementing this method is if the store is configured to be\n+    * {@link StoreConfiguration#async()}. This allows for this store to be unavailable for short periods of time\n+    * until its buffer fills.\n+    * @implSpec\n+    * The default implementations returns a completed stage with the value {@code Boolean.TRUE}\n+    * @return stage that when complete signals if the store is available\n     */\n    default CompletionStage<Boolean> isAvailable() {\n       return CompletableFutures.completedTrue();\n    }\n \n    /**\n-    *\n-    * @param segment\n-    * @param key\n-    * @return\n+    * Returns a stage that will contain the value loaded from the store. If a {@link MarshallableEntry} needs to be\n+    * created here, {@link InitializationContext#getMarshallableEntryFactory()} ()} and {@link\n+    * InitializationContext#getByteBufferFactory()} should be used to assist.\n+    * <p>\n+    * <h4>Summary of Characteristics Effects</h4>\n+    * <table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" summary=\"Summary of Characteristics Effects\">\n+    *    <tr>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Characteristic</th>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Effect</th>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#WRITE_ONLY}</td>\n+    *       <td valign=\"top\">This method will never be invoked</td>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#EXPIRATION}</td>\n+    *       <td valign=\"top\">When set this method must not return expired entries</td>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#SEGMENTABLE}</td>\n+    *       <td valign=\"top\">When this is not set the provided {@code segment} parameter may be ignored</td>\n+    *    </tr>\n+    * </table>\n+    * <p>\n+    * If any problem is encountered, it is recommended that the store wrap any such Throwable in a PersistenceException\n+    * completing the stage exceptionally.", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2ODMxNw==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429168317", "bodyText": "This appers for most methods, so I won't duplicate the comment.", "author": "ryanemerson", "createdAt": "2020-05-22T10:27:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2ODA0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2ODg3OQ==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429168879", "bodyText": "\"related to the..\"", "author": "ryanemerson", "createdAt": "2020-05-22T10:29:15Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -80,114 +146,344 @@\n        * SEGMENTABLE will never be allowed to be configured as segmented.\n        * <p>\n        * Stores that have this characteristic must override the {@link #addSegments(IntSet)} and\n-       * {@link #removeSegments(IntSet)} methods.\n+       * {@link #removeSegments(IntSet)} methods. If a store is {@link #SHAREABLE} and is configured to be shared\n+       * via configuration these methods will not be invoked though.\n        */\n       SEGMENTABLE,\n       /**\n-       * If this store supports storing expiration metadata. Certain methods may or may not include expired entries.\n+       * If this store supports storing expiration metadata. That is this store should never return an expired entry\n+       * via any methods such as {@link #load(int, Object)}, {@link #publishKeys(IntSet, Predicate)} or\n+       * {@link #publishEntries(IntSet, Predicate, boolean)}. It is recommended that a store use the provided\n+       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if an\n+       * entry has expired.\n+       * <p>\n+       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata}\n+       * which is accessible from the {@link MarshallableEntry} which is provided.\n        * <p>\n        * Stores that have this characteristic must override the {@link #purgeExpired()} method.\n        */\n       EXPIRATION\n    }\n \n    /**\n+    * The first method that will be invoked on this store to allow for the store to configure and do any additional\n+    * steps, such as connecting via socket or opening file descriptors.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n+    * The provided {@link InitializationContext} contains many helpful objects, including the configuration of the\n+    * cache and store, concurrency utilities such as {@link org.infinispan.util.concurrent.BlockingManager} or\n+    * an executor reserved for non blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n+    * <p>\n+    * This method is guaranteed to not be invoked concurrently with other operations. This means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@code start} a second time if\n+    * {@link #stop()} has been invoked and allowed for its stage to complete.\n     * @param ctx initialization context used to initialize this store\n     * @return a stage that when complete signals that this store has been successfully started\n     */\n    CompletionStage<Void> start(InitializationContext ctx);\n \n    /**\n+    * This method will be invoked is being shut down. It is expected that all resources related to the store to be\n+    * freed upon completion of the returned stage.\n     * <p>\n     * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@link #start(InitializationContext)}\n+    * a second time if {@code stop} has been invoked and allowed for its stage to complete.\n     * @return a stage that when complete signals that this store has been stopped\n     */\n    CompletionStage<Void> stop();\n \n    /**\n-    *\n-    * @return\n+    * Returns a set of characteristics for this store and its elements. This method will be invoked one to many times\n+    * to determine which methods of the store can be used and how its data can be handled.\n+    * <p>\n+    * Please see {@link Characteristic} and its values for a description of what each characteristic declares the\n+    * store as supporting.\n+    * @implSpec\n+    * The default implementation returns an empty set\n+    * @return the set of characteristics that this store supports\n     */\n    default Set<Characteristic> characteristics() {\n       return EnumSet.noneOf(Characteristic.class);\n    }\n \n    /**\n-    *\n-    * @return\n+    * Returns a stage that when complete will tell if the current store can be accessed for requests. This can be useful\n+    * for some store implementations that may rely on an external source that may become unreachable. This can reduce\n+    * sending requests to a store that is not available as future Cache requests will all be met with\n+    * {@link StoreUnavailableException}.\n+    * <p>\n+    * Store availability is polled automatically every so often to update the status if the underlying store changes\n+    * availability. This method will not be invoked concurrently with itself (ie. this method will not be invoked\n+    * until after the previous stage has completed), but will be invoked concurrently with other operations, excluding\n+    * start and stop.\n+    * <p>\n+    * The other benefit of implementing this method is if the store is configured to be\n+    * {@link StoreConfiguration#async()}. This allows for this store to be unavailable for short periods of time\n+    * until its buffer fills.\n+    * @implSpec\n+    * The default implementations returns a completed stage with the value {@code Boolean.TRUE}\n+    * @return stage that when complete signals if the store is available\n     */\n    default CompletionStage<Boolean> isAvailable() {\n       return CompletableFutures.completedTrue();\n    }\n \n    /**\n-    *\n-    * @param segment\n-    * @param key\n-    * @return\n+    * Returns a stage that will contain the value loaded from the store. If a {@link MarshallableEntry} needs to be\n+    * created here, {@link InitializationContext#getMarshallableEntryFactory()} ()} and {@link\n+    * InitializationContext#getByteBufferFactory()} should be used to assist.\n+    * <p>\n+    * <h4>Summary of Characteristics Effects</h4>\n+    * <table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" summary=\"Summary of Characteristics Effects\">\n+    *    <tr>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Characteristic</th>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Effect</th>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#WRITE_ONLY}</td>\n+    *       <td valign=\"top\">This method will never be invoked</td>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#EXPIRATION}</td>\n+    *       <td valign=\"top\">When set this method must not return expired entries</td>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#SEGMENTABLE}</td>\n+    *       <td valign=\"top\">When this is not set the provided {@code segment} parameter may be ignored</td>\n+    *    </tr>\n+    * </table>\n+    * <p>\n+    * If any problem is encountered, it is recommended that the store wrap any such Throwable in a PersistenceException\n+    * completing the stage exceptionally.\n+    * @param segment the segment for the given key if segmentation is enabled otherwise 0\n+    * @param key key of the entry to load\n+    * @return a stage that when complete contains the store value or null if not present\n     */\n    CompletionStage<MarshallableEntry<K, V>> load(int segment, Object key);\n \n    /**\n-    *\n-    * @param segment\n-    * @param key\n-    * @return\n+    * Returns a stage that will contain whether the value can be found in the store.\n+    * <p>\n+    * <h4>Summary of Characteristics Effects</h4>\n+    * <table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" summary=\"Summary of Characteristics Effects\">\n+    *    <tr>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Characteristic</th>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Effect</th>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#WRITE_ONLY}</td>\n+    *       <td valign=\"top\">This method will never be invoked</td>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#EXPIRATION}</td>\n+    *       <td valign=\"top\">When set this method must not return true if the entry was expired</td>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#SEGMENTABLE}</td>\n+    *       <td valign=\"top\">When this is not set the provided {@code segment} parameter may be ignored</td>\n+    *    </tr>\n+    * </table>\n+    * <p>\n+    * If any problem is encountered, it is recommended that the store wrap any such Throwable in a PersistenceException\n+    * completing the stage exceptionally.\n+    * <p>\n+    * @implSpec\n+    * A default implementation is provided that does the following:\n+    * <pre>{@code\n+    * return load(segment, key)\n+    *        .thenApply(Objects::nonNull);}\n+    * </pre>\n+    * @param segment the segment for the given key if segmentation is enabled otherwise 0\n+    * @param key key of the entry to check\n+    * @return a stage that when complete contains a boolean stating if the value is contained in the store\n     */\n    default CompletionStage<Boolean> containsKey(int segment, Object key) {\n       return load(segment, key)\n             .thenApply(Objects::nonNull);\n    }\n \n    /**\n-    *\n-    * @param segment\n-    * @param entry\n-    * @return\n+    * Writes the entry to the store for the given segment returning a stage that completes normally when it is finished.\n+    * <p>\n+    * <h4>Summary of Characteristics Effects</h4>\n+    * <table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" summary=\"Summary of Characteristics Effects\">\n+    *    <tr>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Characteristic</th>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Effect</th>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#READ_ONLY}</td>\n+    *       <td valign=\"top\">This method will never be invoked</td>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#EXPIRATION}</td>\n+    *       <td valign=\"top\">When set this method must store the expiration metadata</td>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#SEGMENTABLE}</td>\n+    *       <td valign=\"top\">When set this method must ensure the segment is stored with the entry</td>\n+    *    </tr>\n+    * </table>\n+    * <p>\n+    * If any problem is encountered, it is recommended that the store wrap any such Throwable in a PersistenceException\n+    * completing the stage exceptionally.\n+    * @param segment the segment for the given key if segmentation is enabled otherwise 0\n+    * @param entry the entry to persist to the store\n+    * @return a stage that when complete signals that the store has written the value\n     */\n    CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry);\n \n    /**\n-    *\n-    * @param segment\n-    * @param key\n-    * @return\n+    * Removes the entry for given key and segment from the store returning a stage that when completes normally\n+    * contains whether the entry was actually removed or not.\n+    * <p>\n+    * <h4>Summary of Characteristics Effects</h4>\n+    * <table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" summary=\"Summary of Characteristics Effects\">\n+    *    <tr>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Characteristic</th>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Effect</th>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#READ_ONLY}</td>\n+    *       <td valign=\"top\">This method will never be invoked</td>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#SEGMENTABLE}</td>\n+    *       <td valign=\"top\">When this is not set the provided {@code segment} parameter may be ignored</td>\n+    *    </tr>\n+    * </table>\n+    * <p>\n+    * If any problem is encountered, it is recommended that the store wrap any such Throwable in a PersistenceException\n+    * completing the stage exceptionally.\n+    * @param segment the segment for the given key if segmentation is enabled otherwise 0\n+    * @param key key of the entry to delete from the store\n+    * @return a stage that when complete contains a boolean stating if the value was removed from the store\n     */\n    CompletionStage<Boolean> delete(int segment, Object key);\n \n    /**\n-    *\n-    * @param segments\n-    * @return\n+    * Invoked when a node becomes an owner of the given segments. Some store implementations may require initializing\n+    * additional resources when a new segment is required. For example a store could store entries in a different file\n+    * per segment.\n+    * <p>\n+    * <h4>Summary of Characteristics Effects</h4>\n+    * <table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" summary=\"Summary of Characteristics Effects\">\n+    *    <tr>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Characteristic</th>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Effect</th>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#SHAREABLE}</td>\n+    *       <td valign=\"top\">If the store has this characteristic and is configured to be {@link StoreConfiguration#shared()},\n+    *          this method will never be invoked</td>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#SEGMENTABLE}</td>\n+    *       <td valign=\"top\">This method is only invoked if the store has this characteristic</td>\n+    *    </tr>\n+    * </table>\n+    * <p>\n+    * If any problem is encountered, it is recommended that the store wrap any such Throwable in a PersistenceException\n+    * completing the stage exceptionally.\n+    * @param segments the segments to add\n+    * @return a stage that when complete signals that the segments have been added\n     */\n    default CompletionStage<Void> addSegments(IntSet segments) {\n       throw new UnsupportedOperationException(\"Store characteristic included \" + Characteristic.SEGMENTABLE + \", but it does not implement addSegments\");\n    }\n \n    /**\n-    *\n-    * @param segments\n-    * @return\n+    * Invoked when a node loses ownership of the given segments. A store must then remove any entries that map to the\n+    * given segments and can remove any resources related to the given segments. For example a database store can\n+    * delete rows of the given segment or a file based store may delete files related the given segments.", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE2OTE5OA==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429169198", "bodyText": "first comma is unnecessary", "author": "ryanemerson", "createdAt": "2020-05-22T10:29:56Z", "path": "core/src/main/java/org/infinispan/persistence/spi/NonBlockingStore.java", "diffHunk": "@@ -80,114 +146,344 @@\n        * SEGMENTABLE will never be allowed to be configured as segmented.\n        * <p>\n        * Stores that have this characteristic must override the {@link #addSegments(IntSet)} and\n-       * {@link #removeSegments(IntSet)} methods.\n+       * {@link #removeSegments(IntSet)} methods. If a store is {@link #SHAREABLE} and is configured to be shared\n+       * via configuration these methods will not be invoked though.\n        */\n       SEGMENTABLE,\n       /**\n-       * If this store supports storing expiration metadata. Certain methods may or may not include expired entries.\n+       * If this store supports storing expiration metadata. That is this store should never return an expired entry\n+       * via any methods such as {@link #load(int, Object)}, {@link #publishKeys(IntSet, Predicate)} or\n+       * {@link #publishEntries(IntSet, Predicate, boolean)}. It is recommended that a store use the provided\n+       * {@link org.infinispan.commons.time.TimeService} in the {@code InitializationContext} to determine if an\n+       * entry has expired.\n+       * <p>\n+       * The information about an entry and its expiration is included in the {@link org.infinispan.metadata.Metadata}\n+       * which is accessible from the {@link MarshallableEntry} which is provided.\n        * <p>\n        * Stores that have this characteristic must override the {@link #purgeExpired()} method.\n        */\n       EXPIRATION\n    }\n \n    /**\n+    * The first method that will be invoked on this store to allow for the store to configure and do any additional\n+    * steps, such as connecting via socket or opening file descriptors.\n     * <p>\n-    * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n+    * The provided {@link InitializationContext} contains many helpful objects, including the configuration of the\n+    * cache and store, concurrency utilities such as {@link org.infinispan.util.concurrent.BlockingManager} or\n+    * an executor reserved for non blocking operations only {@link InitializationContext#getNonBlockingExecutor()}.\n+    * <p>\n+    * This method is guaranteed to not be invoked concurrently with other operations. This means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@code start} a second time if\n+    * {@link #stop()} has been invoked and allowed for its stage to complete.\n     * @param ctx initialization context used to initialize this store\n     * @return a stage that when complete signals that this store has been successfully started\n     */\n    CompletionStage<Void> start(InitializationContext ctx);\n \n    /**\n+    * This method will be invoked is being shut down. It is expected that all resources related to the store to be\n+    * freed upon completion of the returned stage.\n     * <p>\n     * This method is guaranteed to not be invoked concurrently with other operations. This also means another method\n     * will not be invoked on this store until after the returned Stage completes.\n+    * <p>\n+    * It is expected that an implementation should be able to \"restart\" by invoking {@link #start(InitializationContext)}\n+    * a second time if {@code stop} has been invoked and allowed for its stage to complete.\n     * @return a stage that when complete signals that this store has been stopped\n     */\n    CompletionStage<Void> stop();\n \n    /**\n-    *\n-    * @return\n+    * Returns a set of characteristics for this store and its elements. This method will be invoked one to many times\n+    * to determine which methods of the store can be used and how its data can be handled.\n+    * <p>\n+    * Please see {@link Characteristic} and its values for a description of what each characteristic declares the\n+    * store as supporting.\n+    * @implSpec\n+    * The default implementation returns an empty set\n+    * @return the set of characteristics that this store supports\n     */\n    default Set<Characteristic> characteristics() {\n       return EnumSet.noneOf(Characteristic.class);\n    }\n \n    /**\n-    *\n-    * @return\n+    * Returns a stage that when complete will tell if the current store can be accessed for requests. This can be useful\n+    * for some store implementations that may rely on an external source that may become unreachable. This can reduce\n+    * sending requests to a store that is not available as future Cache requests will all be met with\n+    * {@link StoreUnavailableException}.\n+    * <p>\n+    * Store availability is polled automatically every so often to update the status if the underlying store changes\n+    * availability. This method will not be invoked concurrently with itself (ie. this method will not be invoked\n+    * until after the previous stage has completed), but will be invoked concurrently with other operations, excluding\n+    * start and stop.\n+    * <p>\n+    * The other benefit of implementing this method is if the store is configured to be\n+    * {@link StoreConfiguration#async()}. This allows for this store to be unavailable for short periods of time\n+    * until its buffer fills.\n+    * @implSpec\n+    * The default implementations returns a completed stage with the value {@code Boolean.TRUE}\n+    * @return stage that when complete signals if the store is available\n     */\n    default CompletionStage<Boolean> isAvailable() {\n       return CompletableFutures.completedTrue();\n    }\n \n    /**\n-    *\n-    * @param segment\n-    * @param key\n-    * @return\n+    * Returns a stage that will contain the value loaded from the store. If a {@link MarshallableEntry} needs to be\n+    * created here, {@link InitializationContext#getMarshallableEntryFactory()} ()} and {@link\n+    * InitializationContext#getByteBufferFactory()} should be used to assist.\n+    * <p>\n+    * <h4>Summary of Characteristics Effects</h4>\n+    * <table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" summary=\"Summary of Characteristics Effects\">\n+    *    <tr>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Characteristic</th>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Effect</th>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#WRITE_ONLY}</td>\n+    *       <td valign=\"top\">This method will never be invoked</td>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#EXPIRATION}</td>\n+    *       <td valign=\"top\">When set this method must not return expired entries</td>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#SEGMENTABLE}</td>\n+    *       <td valign=\"top\">When this is not set the provided {@code segment} parameter may be ignored</td>\n+    *    </tr>\n+    * </table>\n+    * <p>\n+    * If any problem is encountered, it is recommended that the store wrap any such Throwable in a PersistenceException\n+    * completing the stage exceptionally.\n+    * @param segment the segment for the given key if segmentation is enabled otherwise 0\n+    * @param key key of the entry to load\n+    * @return a stage that when complete contains the store value or null if not present\n     */\n    CompletionStage<MarshallableEntry<K, V>> load(int segment, Object key);\n \n    /**\n-    *\n-    * @param segment\n-    * @param key\n-    * @return\n+    * Returns a stage that will contain whether the value can be found in the store.\n+    * <p>\n+    * <h4>Summary of Characteristics Effects</h4>\n+    * <table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" summary=\"Summary of Characteristics Effects\">\n+    *    <tr>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Characteristic</th>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Effect</th>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#WRITE_ONLY}</td>\n+    *       <td valign=\"top\">This method will never be invoked</td>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#EXPIRATION}</td>\n+    *       <td valign=\"top\">When set this method must not return true if the entry was expired</td>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#SEGMENTABLE}</td>\n+    *       <td valign=\"top\">When this is not set the provided {@code segment} parameter may be ignored</td>\n+    *    </tr>\n+    * </table>\n+    * <p>\n+    * If any problem is encountered, it is recommended that the store wrap any such Throwable in a PersistenceException\n+    * completing the stage exceptionally.\n+    * <p>\n+    * @implSpec\n+    * A default implementation is provided that does the following:\n+    * <pre>{@code\n+    * return load(segment, key)\n+    *        .thenApply(Objects::nonNull);}\n+    * </pre>\n+    * @param segment the segment for the given key if segmentation is enabled otherwise 0\n+    * @param key key of the entry to check\n+    * @return a stage that when complete contains a boolean stating if the value is contained in the store\n     */\n    default CompletionStage<Boolean> containsKey(int segment, Object key) {\n       return load(segment, key)\n             .thenApply(Objects::nonNull);\n    }\n \n    /**\n-    *\n-    * @param segment\n-    * @param entry\n-    * @return\n+    * Writes the entry to the store for the given segment returning a stage that completes normally when it is finished.\n+    * <p>\n+    * <h4>Summary of Characteristics Effects</h4>\n+    * <table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" summary=\"Summary of Characteristics Effects\">\n+    *    <tr>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Characteristic</th>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Effect</th>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#READ_ONLY}</td>\n+    *       <td valign=\"top\">This method will never be invoked</td>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#EXPIRATION}</td>\n+    *       <td valign=\"top\">When set this method must store the expiration metadata</td>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#SEGMENTABLE}</td>\n+    *       <td valign=\"top\">When set this method must ensure the segment is stored with the entry</td>\n+    *    </tr>\n+    * </table>\n+    * <p>\n+    * If any problem is encountered, it is recommended that the store wrap any such Throwable in a PersistenceException\n+    * completing the stage exceptionally.\n+    * @param segment the segment for the given key if segmentation is enabled otherwise 0\n+    * @param entry the entry to persist to the store\n+    * @return a stage that when complete signals that the store has written the value\n     */\n    CompletionStage<Void> write(int segment, MarshallableEntry<? extends K, ? extends V> entry);\n \n    /**\n-    *\n-    * @param segment\n-    * @param key\n-    * @return\n+    * Removes the entry for given key and segment from the store returning a stage that when completes normally\n+    * contains whether the entry was actually removed or not.\n+    * <p>\n+    * <h4>Summary of Characteristics Effects</h4>\n+    * <table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" summary=\"Summary of Characteristics Effects\">\n+    *    <tr>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Characteristic</th>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Effect</th>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#READ_ONLY}</td>\n+    *       <td valign=\"top\">This method will never be invoked</td>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#SEGMENTABLE}</td>\n+    *       <td valign=\"top\">When this is not set the provided {@code segment} parameter may be ignored</td>\n+    *    </tr>\n+    * </table>\n+    * <p>\n+    * If any problem is encountered, it is recommended that the store wrap any such Throwable in a PersistenceException\n+    * completing the stage exceptionally.\n+    * @param segment the segment for the given key if segmentation is enabled otherwise 0\n+    * @param key key of the entry to delete from the store\n+    * @return a stage that when complete contains a boolean stating if the value was removed from the store\n     */\n    CompletionStage<Boolean> delete(int segment, Object key);\n \n    /**\n-    *\n-    * @param segments\n-    * @return\n+    * Invoked when a node becomes an owner of the given segments. Some store implementations may require initializing\n+    * additional resources when a new segment is required. For example a store could store entries in a different file\n+    * per segment.\n+    * <p>\n+    * <h4>Summary of Characteristics Effects</h4>\n+    * <table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" summary=\"Summary of Characteristics Effects\">\n+    *    <tr>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Characteristic</th>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Effect</th>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#SHAREABLE}</td>\n+    *       <td valign=\"top\">If the store has this characteristic and is configured to be {@link StoreConfiguration#shared()},\n+    *          this method will never be invoked</td>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#SEGMENTABLE}</td>\n+    *       <td valign=\"top\">This method is only invoked if the store has this characteristic</td>\n+    *    </tr>\n+    * </table>\n+    * <p>\n+    * If any problem is encountered, it is recommended that the store wrap any such Throwable in a PersistenceException\n+    * completing the stage exceptionally.\n+    * @param segments the segments to add\n+    * @return a stage that when complete signals that the segments have been added\n     */\n    default CompletionStage<Void> addSegments(IntSet segments) {\n       throw new UnsupportedOperationException(\"Store characteristic included \" + Characteristic.SEGMENTABLE + \", but it does not implement addSegments\");\n    }\n \n    /**\n-    *\n-    * @param segments\n-    * @return\n+    * Invoked when a node loses ownership of the given segments. A store must then remove any entries that map to the\n+    * given segments and can remove any resources related to the given segments. For example a database store can\n+    * delete rows of the given segment or a file based store may delete files related the given segments.\n+    * <p>\n+    * <h4>Summary of Characteristics Effects</h4>\n+    * <table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" summary=\"Summary of Characteristics Effects\">\n+    *    <tr>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Characteristic</th>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Effect</th>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#SHAREABLE}</td>\n+    *       <td valign=\"top\">If the store has this characteristic and is configured to be {@link StoreConfiguration#shared()},\n+    *          this method will never be invoked</td>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#SEGMENTABLE}</td>\n+    *       <td valign=\"top\">This method is only invoked if the store has this characteristic</td>\n+    *    </tr>\n+    * </table>\n+    * <p>\n+    * If any problem is encountered, it is recommended that the store wrap any such Throwable in a PersistenceException\n+    * completing the stage exceptionally.\n+    * @param segments the segments to remove\n+    * @return a stage that when complete signals that the segments have been removed\n     */\n    default CompletionStage<Void> removeSegments(IntSet segments) {\n       throw new UnsupportedOperationException(\"Store characteristic included \" + Characteristic.SEGMENTABLE + \", but it does not implement removeSegments\");\n    }\n \n    /**\n-    *\n-    * @return\n+    * Clears all entries from the store.\n+    * <p>\n+    * <h4>Summary of Characteristics Effects</h4>\n+    * <table border=\"1\" cellpadding=\"1\" cellspacing=\"1\" summary=\"Summary of Characteristics Effects\">\n+    *    <tr>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Characteristic</th>\n+    *       <th bgcolor=\"#CCCCFF\" align=\"left\">Effect</th>\n+    *    </tr>\n+    *    <tr>\n+    *       <td valign=\"top\">{@link Characteristic#READ_ONLY}</td>\n+    *       <td valign=\"top\">This method will never be invoked</td>\n+    *    </tr>\n+    * </table>\n+    * <p>\n+    * If any problem is encountered, it is recommended that the store wrap any such Throwable in a PersistenceException\n+    * completing the stage exceptionally.\n+    * @return a stage that when complete signals that the store has been cleared\n     */\n    CompletionStage<Void> clear();\n \n    /**\n-    *\n-    * @param publisherCount\n-    * @param publisher\n-    * @return\n+    * Writes the entries provided by the publisher into the underlying store. The Publisher will provide a\n+    * {@link SegmentedPublisher}, for every segment in the batch, which contains at least one entry that maps to", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTE3MDEzMQ==", "url": "https://github.com/infinispan/infinispan/pull/8370#discussion_r429170131", "bodyText": "Just \"This id will be printed to the TRACE log.\"?", "author": "ryanemerson", "createdAt": "2020-05-22T10:32:04Z", "path": "core/src/main/java/org/infinispan/util/concurrent/BlockingManager.java", "diffHunk": "@@ -14,6 +14,10 @@\n  * <p>\n  * If the current thread is blocking, it blocks until the task may run, runs the task in the current thread, and returns a\n  * completed {@code CompletionStage}, so it <em>does not</em> continue the execution on the non-blocking executor.\n+ * <p>\n+ * Many of the methods on {@code BlockingManager} allow an id to be passed when performing the operation. This id will\n+ * be printed to the log, assuming TRACE level is enabled. It is therefore advised to provide something unique so that", "originalCommit": "78ac5ae2b79bcea3f221fd82b59cf636ecec9ac4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6089e69a33c438e7b7b7d8d7ec4de3c44cb0ecf1", "url": "https://github.com/infinispan/infinispan/commit/6089e69a33c438e7b7b7d8d7ec4de3c44cb0ecf1", "message": "ISPN-13703 Store/Loader Non blocking SPI\n\n* Adding Javadoc\n* Adding in optimizations for non segmented stores", "committedDate": "2020-05-22T13:18:01Z", "type": "commit"}, {"oid": "833bd2315ebd6fb0d5e82ef5bbdaa31e2526fdac", "url": "https://github.com/infinispan/infinispan/commit/833bd2315ebd6fb0d5e82ef5bbdaa31e2526fdac", "message": "ISPN-10373 Store/Loader Non blocking SPI\n\n* Deprecate old SPI", "committedDate": "2020-05-22T13:18:01Z", "type": "commit"}, {"oid": "833bd2315ebd6fb0d5e82ef5bbdaa31e2526fdac", "url": "https://github.com/infinispan/infinispan/commit/833bd2315ebd6fb0d5e82ef5bbdaa31e2526fdac", "message": "ISPN-10373 Store/Loader Non blocking SPI\n\n* Deprecate old SPI", "committedDate": "2020-05-22T13:18:01Z", "type": "forcePushed"}]}