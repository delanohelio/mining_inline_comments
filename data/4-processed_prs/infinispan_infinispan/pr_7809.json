{"pr_number": 7809, "pr_title": "ISPN-10604 Eviction and Expiration Docs", "pr_createdAt": "2020-01-30T21:13:00Z", "pr_url": "https://github.com/infinispan/infinispan/pull/7809", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0MzM4MQ==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373643381", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          bytes[] instead of the object instances.\n          \n          \n            \n                          byte[] instead of the object instances.", "author": "wburns", "createdAt": "2020-01-31T19:20:37Z", "path": "core/src/main/resources/schema/infinispan-config-11.0.xsd", "diffHunk": "@@ -1232,23 +1232,32 @@\n         <xs:element name=\"object\" type=\"tns:memory-object\">\n           <xs:annotation>\n             <xs:documentation>\n-              Store keys and values as instance variables.  Instances of byte[] will be wrapped to ensure equality.\n+              Store keys and values as instance variables in the Java heap.\n+              Instances of byte[] are wrapped to ensure equality. This is the\n+              default storage format.\n             </xs:documentation>\n           </xs:annotation>\n         </xs:element>\n         <xs:element name=\"binary\" type=\"tns:memory-binary\">\n           <xs:annotation>\n             <xs:documentation>\n-              Store keys and values as byte[] instances.  Key and value will be serialized to binary representations.\n+              Store keys and values as byte[] instances in the Java heap. Cache\n+              entries are serialized to binary representations. Note that\n+              binary storage violates object equality. This occurs because\n+              equality is determined by the equivalence of the resulting\n+              bytes[] instead of the object instances.", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0MzUwNg==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373643506", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          the resulting bytes[] instead of the object instances.\n          \n          \n            \n                          the resulting byte[] instead of the object instances.", "author": "wburns", "createdAt": "2020-01-31T19:20:55Z", "path": "core/src/main/resources/schema/infinispan-config-11.0.xsd", "diffHunk": "@@ -1232,23 +1232,32 @@\n         <xs:element name=\"object\" type=\"tns:memory-object\">\n           <xs:annotation>\n             <xs:documentation>\n-              Store keys and values as instance variables.  Instances of byte[] will be wrapped to ensure equality.\n+              Store keys and values as instance variables in the Java heap.\n+              Instances of byte[] are wrapped to ensure equality. This is the\n+              default storage format.\n             </xs:documentation>\n           </xs:annotation>\n         </xs:element>\n         <xs:element name=\"binary\" type=\"tns:memory-binary\">\n           <xs:annotation>\n             <xs:documentation>\n-              Store keys and values as byte[] instances.  Key and value will be serialized to binary representations.\n+              Store keys and values as byte[] instances in the Java heap. Cache\n+              entries are serialized to binary representations. Note that\n+              binary storage violates object equality. This occurs because\n+              equality is determined by the equivalence of the resulting\n+              bytes[] instead of the object instances.\n             </xs:documentation>\n           </xs:annotation>\n         </xs:element>\n         <xs:element name=\"off-heap\" type=\"tns:memory-off-heap\">\n           <xs:annotation>\n             <xs:documentation>\n-              Store keys and values as byte[] off of the Java heap.  Key and value will be serialized to binary\n-              representations and stored in native memory as to not take up Java heap.  Temporary objects will be\n-              put onto Java heap temporarily until processing is completed.\n+              Store keys and values as byte[] instances in native memory. Cache\n+              entries are serialized to binary representations. Temporary\n+              objects are stored in the Java heap space until processing\n+              completes. Note that off-heap storage violates object equality.\n+              This occurs because equality is determined by the equivalence of\n+              the resulting bytes[] instead of the object instances.", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0Mzg3MA==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373643870", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          Store keys and values as byte[] instances in native memory. Cache\n          \n          \n            \n                          Store keys and values as bytes in native memory. Cache", "author": "wburns", "createdAt": "2020-01-31T19:21:47Z", "path": "core/src/main/resources/schema/infinispan-config-11.0.xsd", "diffHunk": "@@ -1232,23 +1232,32 @@\n         <xs:element name=\"object\" type=\"tns:memory-object\">\n           <xs:annotation>\n             <xs:documentation>\n-              Store keys and values as instance variables.  Instances of byte[] will be wrapped to ensure equality.\n+              Store keys and values as instance variables in the Java heap.\n+              Instances of byte[] are wrapped to ensure equality. This is the\n+              default storage format.\n             </xs:documentation>\n           </xs:annotation>\n         </xs:element>\n         <xs:element name=\"binary\" type=\"tns:memory-binary\">\n           <xs:annotation>\n             <xs:documentation>\n-              Store keys and values as byte[] instances.  Key and value will be serialized to binary representations.\n+              Store keys and values as byte[] instances in the Java heap. Cache\n+              entries are serialized to binary representations. Note that\n+              binary storage violates object equality. This occurs because\n+              equality is determined by the equivalence of the resulting\n+              bytes[] instead of the object instances.\n             </xs:documentation>\n           </xs:annotation>\n         </xs:element>\n         <xs:element name=\"off-heap\" type=\"tns:memory-off-heap\">\n           <xs:annotation>\n             <xs:documentation>\n-              Store keys and values as byte[] off of the Java heap.  Key and value will be serialized to binary\n-              representations and stored in native memory as to not take up Java heap.  Temporary objects will be\n-              put onto Java heap temporarily until processing is completed.\n+              Store keys and values as byte[] instances in native memory. Cache", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0NDU4Mw==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373644583", "bodyText": "This isn't true. If a size is supplied and it is NONE or MANUAL we override to REMOVE and log a message.", "author": "wburns", "createdAt": "2020-01-31T19:23:30Z", "path": "core/src/main/resources/schema/infinispan-config-11.0.xsd", "diffHunk": "@@ -1259,66 +1268,86 @@\n   <xs:complexType name=\"memory-object\">\n     <xs:attribute name=\"size\" type=\"xs:long\" default=\"-1\">\n       <xs:annotation>\n-        <xs:documentation>The size of the eviction cache as a long.  Limits the cache to this normal by the amount of\n-        entries in the cache.</xs:documentation>\n+        <xs:documentation>\n+          Defines the size of the data container as a long. Eviction occurs\n+          when the number of entries exceeds the size.\n+        </xs:documentation>\n       </xs:annotation>\n     </xs:attribute>\n     <xs:attribute name=\"strategy\" type=\"tns:eviction-strategy\">\n       <xs:annotation>\n-        <xs:documentation>The eviction strategy to use. This determines if eviction is even enabled or if it\n-          has a different variant.</xs:documentation>\n+        <xs:documentation>\n+          Specifies a strategy for evicting cache entries. The default strategy\n+          is NONE so you must specify a strategy for eviction to take place.", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDAzMDUzNg==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r374030536", "bodyText": "@wburns  so size=>0 and strategy=NONE then REMOVE\nalso if size=>0 and strategy=MANUAL then REMOVE? that sounds like manual eviction doesn't work.", "author": "oraNod", "createdAt": "2020-02-03T10:39:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0NDU4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDEyMzIyOQ==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r374123229", "bodyText": "MANUAL always works - no matter the setting. Manual is used solely for the purpose of not having a warning message when you start the cache and have passivation without eviction being explicitly enabled.\nWe are trying to help the user out, if they are setting a size they most likely want an eviction type, we don't want to block that (usually for the NONE case).", "author": "wburns", "createdAt": "2020-02-03T14:12:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0NDU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0NTA0OA==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373645048", "bodyText": "Same as other one, this isn't quite true.", "author": "wburns", "createdAt": "2020-01-31T19:24:33Z", "path": "core/src/main/resources/schema/infinispan-config-11.0.xsd", "diffHunk": "@@ -1259,66 +1268,86 @@\n   <xs:complexType name=\"memory-object\">\n     <xs:attribute name=\"size\" type=\"xs:long\" default=\"-1\">\n       <xs:annotation>\n-        <xs:documentation>The size of the eviction cache as a long.  Limits the cache to this normal by the amount of\n-        entries in the cache.</xs:documentation>\n+        <xs:documentation>\n+          Defines the size of the data container as a long. Eviction occurs\n+          when the number of entries exceeds the size.\n+        </xs:documentation>\n       </xs:annotation>\n     </xs:attribute>\n     <xs:attribute name=\"strategy\" type=\"tns:eviction-strategy\">\n       <xs:annotation>\n-        <xs:documentation>The eviction strategy to use. This determines if eviction is even enabled or if it\n-          has a different variant.</xs:documentation>\n+        <xs:documentation>\n+          Specifies a strategy for evicting cache entries. The default strategy\n+          is NONE so you must specify a strategy for eviction to take place.\n+        </xs:documentation>\n       </xs:annotation>\n     </xs:attribute>\n   </xs:complexType>\n \n   <xs:complexType name=\"memory-binary\">\n     <xs:attribute name=\"size\" type=\"xs:long\" default=\"-1\">\n       <xs:annotation>\n-        <xs:documentation>The size of the eviction cache as a long.  If the configured type is COUNT, this will be\n-          how many entries can be stored.  If the configured type is MEMORY, this will be how much memory\n-          in bytes can be stored.</xs:documentation>\n+        <xs:documentation>\n+          Defines the size of the data container as a long. Eviction occurs\n+          either when the number of entries or amount of memory exceeds the\n+          size.\n+        </xs:documentation>\n       </xs:annotation>\n     </xs:attribute>\n     <xs:attribute name=\"eviction\" type=\"tns:eviction-type\">\n       <xs:annotation>\n-        <xs:documentation>The eviction type to use whether it is COUNT or MEMORY.  COUNT will limit the cache based on\n-        the number of entries.  MEMORY will limit the cache by how much memory the entries use</xs:documentation>\n+        <xs:documentation>\n+          Specifies whether eviction is based on the number of entries or the\n+          amount of memory used.\n+        </xs:documentation>\n       </xs:annotation>\n     </xs:attribute>\n     <xs:attribute name=\"strategy\" type=\"tns:eviction-strategy\">\n       <xs:annotation>\n-        <xs:documentation>The eviction strategy to use. This determines if eviction is even enabled or if it\n-        has a different variant.</xs:documentation>\n+        <xs:documentation>\n+          Specifies a strategy for evicting cache entries. The default strategy\n+          is NONE so you must specify a strategy for eviction to take place.", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0NTI2MQ==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373645261", "bodyText": "This setting is no longer used as of 10.0. I am actually removing it in another PR.", "author": "wburns", "createdAt": "2020-01-31T19:25:00Z", "path": "core/src/main/resources/schema/infinispan-config-11.0.xsd", "diffHunk": "@@ -1259,66 +1268,86 @@\n   <xs:complexType name=\"memory-object\">\n     <xs:attribute name=\"size\" type=\"xs:long\" default=\"-1\">\n       <xs:annotation>\n-        <xs:documentation>The size of the eviction cache as a long.  Limits the cache to this normal by the amount of\n-        entries in the cache.</xs:documentation>\n+        <xs:documentation>\n+          Defines the size of the data container as a long. Eviction occurs\n+          when the number of entries exceeds the size.\n+        </xs:documentation>\n       </xs:annotation>\n     </xs:attribute>\n     <xs:attribute name=\"strategy\" type=\"tns:eviction-strategy\">\n       <xs:annotation>\n-        <xs:documentation>The eviction strategy to use. This determines if eviction is even enabled or if it\n-          has a different variant.</xs:documentation>\n+        <xs:documentation>\n+          Specifies a strategy for evicting cache entries. The default strategy\n+          is NONE so you must specify a strategy for eviction to take place.\n+        </xs:documentation>\n       </xs:annotation>\n     </xs:attribute>\n   </xs:complexType>\n \n   <xs:complexType name=\"memory-binary\">\n     <xs:attribute name=\"size\" type=\"xs:long\" default=\"-1\">\n       <xs:annotation>\n-        <xs:documentation>The size of the eviction cache as a long.  If the configured type is COUNT, this will be\n-          how many entries can be stored.  If the configured type is MEMORY, this will be how much memory\n-          in bytes can be stored.</xs:documentation>\n+        <xs:documentation>\n+          Defines the size of the data container as a long. Eviction occurs\n+          either when the number of entries or amount of memory exceeds the\n+          size.\n+        </xs:documentation>\n       </xs:annotation>\n     </xs:attribute>\n     <xs:attribute name=\"eviction\" type=\"tns:eviction-type\">\n       <xs:annotation>\n-        <xs:documentation>The eviction type to use whether it is COUNT or MEMORY.  COUNT will limit the cache based on\n-        the number of entries.  MEMORY will limit the cache by how much memory the entries use</xs:documentation>\n+        <xs:documentation>\n+          Specifies whether eviction is based on the number of entries or the\n+          amount of memory used.\n+        </xs:documentation>\n       </xs:annotation>\n     </xs:attribute>\n     <xs:attribute name=\"strategy\" type=\"tns:eviction-strategy\">\n       <xs:annotation>\n-        <xs:documentation>The eviction strategy to use. This determines if eviction is even enabled or if it\n-        has a different variant.</xs:documentation>\n+        <xs:documentation>\n+          Specifies a strategy for evicting cache entries. The default strategy\n+          is NONE so you must specify a strategy for eviction to take place.\n+        </xs:documentation>\n       </xs:annotation>\n     </xs:attribute>\n   </xs:complexType>\n \n   <xs:complexType name=\"memory-off-heap\">\n     <xs:attribute name=\"size\" type=\"xs:long\" default=\"-1\">\n       <xs:annotation>\n-        <xs:documentation>The size of the eviction cache as a long.  If the configured type is COUNT, this will be\n-          how many entries can be stored.  If the configured type is MEMORY, this will be how much memory\n-          in bytes can be stored.</xs:documentation>\n+        <xs:documentation>\n+          Defines the size of the data container as a long. Eviction occurs\n+          either when the number of entries or amount of memory exceeds the\n+          size.\n+      </xs:documentation>\n       </xs:annotation>\n     </xs:attribute>\n     <xs:attribute name=\"eviction\" type=\"tns:eviction-type\">\n       <xs:annotation>\n-        <xs:documentation>The eviction type to use whether it is COUNT or MEMORY.  COUNT will limit the cache based on\n-          the number of entries.  MEMORY will limit the cache by how much memory the entries use</xs:documentation>\n+        <xs:documentation>\n+          Specifies whether eviction is based on the number of entries or the\n+          amount of memory used.\n+        </xs:documentation>\n       </xs:annotation>\n     </xs:attribute>\n     <xs:attribute name=\"strategy\" type=\"tns:eviction-strategy\">\n       <xs:annotation>\n-        <xs:documentation>The eviction strategy to use. This determines if eviction is even enabled or if it\n-          has a different variant.</xs:documentation>\n+        <xs:documentation>\n+          Specifies a strategy for evicting cache entries. The default strategy\n+          is NONE so you must specify a strategy for eviction to take place.\n+        </xs:documentation>\n       </xs:annotation>\n     </xs:attribute>\n     <xs:attribute name=\"address-count\" type=\"xs:int\" default=\"1048576\">\n       <xs:annotation>\n-        <xs:documentation>How many address pointers to use. This number will be rounded up to a power of two.\n-          For optimal performance you will want more address pointers than you expect to have entries.  This is similar\n-          to the size of an array backing a hash map.  Without collisions lookups and writes will be constant time.\n-          Each pointer will take up 8 bytes of memory thus the default will use 8 MB of off-heap memory.\n+        <xs:documentation>\n+          Specifies the number of pointers that are available in the hash map,", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIxMzMzMg==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r374213332", "bodyText": "@wburns hey, should we keep this in the doc PR for 10.1.x and remove in this doc PR?", "author": "oraNod", "createdAt": "2020-02-03T16:44:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0NTI2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIyMDAyMQ==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r374220021", "bodyText": "Well technically as of 10.0 this configuration option does absolutely nothing.", "author": "wburns", "createdAt": "2020-02-03T16:57:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0NTI2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI2NDk0Ng==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r374264946", "bodyText": "ok, let's just drop it all together.", "author": "oraNod", "createdAt": "2020-02-03T18:27:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0NTI2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDI2NTI2Mw==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r374265263", "bodyText": "Sounds good to me.", "author": "wburns", "createdAt": "2020-02-03T18:28:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0NTI2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0NzQ3Ng==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373647476", "bodyText": "This is all being removed in my PR as well. https://github.com/infinispan/infinispan/pull/7815/files#diff-0ada09d10de5ef5b0bdbe6db4bf95349L2211", "author": "wburns", "createdAt": "2020-01-31T19:29:59Z", "path": "core/src/main/resources/schema/infinispan-config-11.0.xsd", "diffHunk": "@@ -2217,7 +2254,9 @@\n       </xs:enumeration>\n       <xs:enumeration value=\"DEFAULT\">\n         <xs:annotation>\n-          <xs:documentation>Use the default eviction listener thread policy (PIGGYBACK)</xs:documentation>", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIwNjg5MQ==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r374206891", "bodyText": "@wburns is this going to be removed in 10.1.x too?", "author": "oraNod", "createdAt": "2020-02-03T16:33:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0NzQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIwNzQwNA==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r374207404", "bodyText": "No", "author": "wburns", "createdAt": "2020-02-03T16:34:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0NzQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIxMzY0MQ==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r374213641", "bodyText": "same here @wburns keep in the doc PR for 10.1.x and remove in this doc PR?", "author": "oraNod", "createdAt": "2020-02-03T16:45:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0NzQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIyMDM4NA==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r374220384", "bodyText": "This configuration option is completely ignored for a long time, I don't even remember when.", "author": "wburns", "createdAt": "2020-02-03T16:57:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0NzQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0ODMzNw==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373648337", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Binary `byte[]` in native memory (off-heap).\n          \n          \n            \n            * Bytes in native memory (off-heap).", "author": "wburns", "createdAt": "2020-01-31T19:31:53Z", "path": "documentation/src/main/asciidoc/topics/con_eviction_overview.adoc", "diffHunk": "@@ -0,0 +1,87 @@\n+[id='how_eviction_works-{context}']\n+= How Eviction Works\n+{brandname} eviction relies on two configurations:\n+\n+* Size of the data container.\n+* Eviction strategy.\n+\n+.Calculating data container size\n+\n+You configure the maximum size of the data container and specify if {brandname}\n+stores cache entries as:\n+\n+* Object in the Java heap.\n+* Binary `byte[]` in the Java heap.\n+* Binary `byte[]` in native memory (off-heap).", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0ODc3MQ==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373648771", "bodyText": "It doesn't iterate, it just keeps a running counter as entries are inserted or removed.\nI don't know if we need to mention this part tbh.", "author": "wburns", "createdAt": "2020-01-31T19:32:54Z", "path": "documentation/src/main/asciidoc/topics/con_eviction_overview.adoc", "diffHunk": "@@ -0,0 +1,87 @@\n+[id='how_eviction_works-{context}']\n+= How Eviction Works\n+{brandname} eviction relies on two configurations:\n+\n+* Size of the data container.\n+* Eviction strategy.\n+\n+.Calculating data container size\n+\n+You configure the maximum size of the data container and specify if {brandname}\n+stores cache entries as:\n+\n+* Object in the Java heap.\n+* Binary `byte[]` in the Java heap.\n+* Binary `byte[]` in native memory (off-heap).\n+\n+|===\n+| Storage type | Size of the data container is calculated as:\n+\n+| Object\n+| Number of entries.\n+\n+| Binary\n+| Number of entries, if the eviction type is `COUNT`. +\n+Amount of memory, in bytes, if the eviction type is `MEMORY`.\n+\n+| Off-heap\n+| Number of entries, if the eviction type is `COUNT`. +\n+Amount of memory, in bytes, if the eviction type is `MEMORY`.\n+|===\n+\n+To calculate the data container size, {brandname} does one of the following:\n+\n+* Iterates over caches to count the number of entries to determine size.", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0OTAzOQ==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373649039", "bodyText": "I am not sure if we want to put %'s here as this can change as JVMs improve.", "author": "wburns", "createdAt": "2020-01-31T19:33:32Z", "path": "documentation/src/main/asciidoc/topics/con_eviction_overview.adoc", "diffHunk": "@@ -0,0 +1,87 @@\n+[id='how_eviction_works-{context}']\n+= How Eviction Works\n+{brandname} eviction relies on two configurations:\n+\n+* Size of the data container.\n+* Eviction strategy.\n+\n+.Calculating data container size\n+\n+You configure the maximum size of the data container and specify if {brandname}\n+stores cache entries as:\n+\n+* Object in the Java heap.\n+* Binary `byte[]` in the Java heap.\n+* Binary `byte[]` in native memory (off-heap).\n+\n+|===\n+| Storage type | Size of the data container is calculated as:\n+\n+| Object\n+| Number of entries.\n+\n+| Binary\n+| Number of entries, if the eviction type is `COUNT`. +\n+Amount of memory, in bytes, if the eviction type is `MEMORY`.\n+\n+| Off-heap\n+| Number of entries, if the eviction type is `COUNT`. +\n+Amount of memory, in bytes, if the eviction type is `MEMORY`.\n+|===\n+\n+To calculate the data container size, {brandname} does one of the following:\n+\n+* Iterates over caches to count the number of entries to determine size.\n+* Takes the size of each `byte[]` and includes the overhead of object pointers to determine size.\n+\n+[NOTE]\n+====\n+When using `MEMORY`, {brandname} can determine only an approximate size of data containers. For the HotSpot JVM, {brandname} can calculate an approximate size within 3% of the actual size. For other JVMs, the calculation can be within 10%.", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY0OTIxOA==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373649218", "bodyText": "Same here, we may want to just mention that it is a closer approximation that the on heap ones possibly.", "author": "wburns", "createdAt": "2020-01-31T19:33:57Z", "path": "documentation/src/main/asciidoc/topics/con_eviction_overview.adoc", "diffHunk": "@@ -0,0 +1,87 @@\n+[id='how_eviction_works-{context}']\n+= How Eviction Works\n+{brandname} eviction relies on two configurations:\n+\n+* Size of the data container.\n+* Eviction strategy.\n+\n+.Calculating data container size\n+\n+You configure the maximum size of the data container and specify if {brandname}\n+stores cache entries as:\n+\n+* Object in the Java heap.\n+* Binary `byte[]` in the Java heap.\n+* Binary `byte[]` in native memory (off-heap).\n+\n+|===\n+| Storage type | Size of the data container is calculated as:\n+\n+| Object\n+| Number of entries.\n+\n+| Binary\n+| Number of entries, if the eviction type is `COUNT`. +\n+Amount of memory, in bytes, if the eviction type is `MEMORY`.\n+\n+| Off-heap\n+| Number of entries, if the eviction type is `COUNT`. +\n+Amount of memory, in bytes, if the eviction type is `MEMORY`.\n+|===\n+\n+To calculate the data container size, {brandname} does one of the following:\n+\n+* Iterates over caches to count the number of entries to determine size.\n+* Takes the size of each `byte[]` and includes the overhead of object pointers to determine size.\n+\n+[NOTE]\n+====\n+When using `MEMORY`, {brandname} can determine only an approximate size of data containers. For the HotSpot JVM, {brandname} can calculate an approximate size within 3% of the actual size. For other JVMs, the calculation can be within 10%.\n+\n+When using `MEMORY` with off-heap storage, the calculation is more precise and typically within 1% of the actual size.", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1MDI1MQ==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373650251", "bodyText": "Maybe something more along the lines of \"When an entry is added or modified in the {brandname} data container, it compares the current eviction size with the maximum and if the current exceeds the maximum, {brandname} evicts entries. You can play with the wording obviously.", "author": "wburns", "createdAt": "2020-01-31T19:36:18Z", "path": "documentation/src/main/asciidoc/topics/con_eviction_overview.adoc", "diffHunk": "@@ -0,0 +1,87 @@\n+[id='how_eviction_works-{context}']\n+= How Eviction Works\n+{brandname} eviction relies on two configurations:\n+\n+* Size of the data container.\n+* Eviction strategy.\n+\n+.Calculating data container size\n+\n+You configure the maximum size of the data container and specify if {brandname}\n+stores cache entries as:\n+\n+* Object in the Java heap.\n+* Binary `byte[]` in the Java heap.\n+* Binary `byte[]` in native memory (off-heap).\n+\n+|===\n+| Storage type | Size of the data container is calculated as:\n+\n+| Object\n+| Number of entries.\n+\n+| Binary\n+| Number of entries, if the eviction type is `COUNT`. +\n+Amount of memory, in bytes, if the eviction type is `MEMORY`.\n+\n+| Off-heap\n+| Number of entries, if the eviction type is `COUNT`. +\n+Amount of memory, in bytes, if the eviction type is `MEMORY`.\n+|===\n+\n+To calculate the data container size, {brandname} does one of the following:\n+\n+* Iterates over caches to count the number of entries to determine size.\n+* Takes the size of each `byte[]` and includes the overhead of object pointers to determine size.\n+\n+[NOTE]\n+====\n+When using `MEMORY`, {brandname} can determine only an approximate size of data containers. For the HotSpot JVM, {brandname} can calculate an approximate size within 3% of the actual size. For other JVMs, the calculation can be within 10%.\n+\n+When using `MEMORY` with off-heap storage, the calculation is more precise and typically within 1% of the actual size.\n+====\n+\n+.Evicting cache entries\n+\n+When {brandname} calculates the size of the data container, it compares the", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1MTgzOQ==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373651839", "bodyText": "Technically it is if a given object would put it over 100 bytes. For example if you had 95 bytes in use and a new object would add another 40, then it would have to evict one or more to make room. MEMORY based eviction is special in that it can actually evict more than one entry for a single put operation.", "author": "wburns", "createdAt": "2020-01-31T19:39:54Z", "path": "documentation/src/main/asciidoc/topics/con_eviction_example.adoc", "diffHunk": "@@ -0,0 +1,96 @@\n+[id='eviction_example-{context}']\n+= Eviction Example\n+\n+You configure eviction in `infinispan.xml` as part of your cache definition.\n+\n+.Default memory configuration\n+\n+[source,xml,options=\"nowrap\",subs=attributes+]\n+----\n+<memory />\n+----\n+\n+This is the default configuration. {brandname} stores cache entries as objects\n+in the data container. Eviction is not enabled.\n+\n+.Passivation without eviction\n+\n+[source,xml,options=\"nowrap\",subs=attributes+]\n+----\n+<persistence passivation=\"true\">\n+  ...\n+</persistence>\n+\n+<memory />\n+----\n+\n+This configuration is not valid and {brandname} writes an error to log files.\n+\n+Passivation configures {brandname} to write entries to cache stores when it\n+evicts those entries. You should always enable eviction if you enable\n+passivation.\n+\n+.Manual eviction\n+\n+[source,xml,options=\"nowrap\",subs=attributes+]\n+----\n+<memory>\n+  <object strategy=\"MANUAL\" />\n+</memory>\n+----\n+\n+{brandname} stores cache entries as objects. Eviction is not enabled but\n+performed manually using the `evict()` method. In this case, {brandname} does\n+not log errors if you enable passivation.\n+\n+.Object storage with eviction\n+\n+[source,xml,options=\"nowrap\",subs=attributes+]\n+----\n+<memory>\n+  <object size=\"100\" />\n+</memory>\n+----\n+\n+{brandname} stores cache entries as objects. Eviction happens when there are\n+100 entries in the data container and {brandname} gets a request to create a\n+new entry.\n+\n+.Binary storage with memory-based eviction\n+\n+[source,xml,options=\"nowrap\",subs=attributes+]\n+----\n+<memory>\n+  <binary size=\"100\" eviction=\"MEMORY\"/>\n+</memory>\n+----\n+\n+{brandname} stores cache entries as bytes. Eviction happens when the size of\n+the data container reaches 100 bytes and {brandname} gets a request to create a", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1MjI4Ng==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373652286", "bodyText": "Do we normally call this custom types? Maybe user types or user class instances or something like that?", "author": "wburns", "createdAt": "2020-01-31T19:40:58Z", "path": "documentation/src/main/asciidoc/topics/con_eviction_custom_types.adoc", "diffHunk": "@@ -0,0 +1,19 @@\n+[id='eviction_custom_types-{context}']\n+= Custom Types with Memory-Based Eviction\n+Using custom types with memory-based eviction requires specific configuration", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1MjQwNg==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373652406", "bodyText": "You can also use off heap as well.", "author": "wburns", "createdAt": "2020-01-31T19:41:17Z", "path": "documentation/src/main/asciidoc/topics/con_eviction_custom_types.adoc", "diffHunk": "@@ -0,0 +1,19 @@\n+[id='eviction_custom_types-{context}']\n+= Custom Types with Memory-Based Eviction\n+Using custom types with memory-based eviction requires specific configuration\n+because {brandname} cannot calculate how much memory your classes use.\n+\n+You must use binary storage with memory-based eviction, as in the following", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1MzgzNA==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373653834", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            entries that are expired by not yet removed from the cache count towards the\n          \n          \n            \n            entries that are expired but not yet removed from the cache count towards the", "author": "wburns", "createdAt": "2020-01-31T19:44:41Z", "path": "documentation/src/main/asciidoc/topics/con_expiration.adoc", "diffHunk": "@@ -0,0 +1,23 @@\n+[id='expiration-{context}']\n+= Expiration\n+Expiration removes entries from memory when they reach one of the following\n+time limits:\n+\n+Lifespan::\n+Sets the maximum amount of time that entries can exist.\n+\n+Maximum idle::\n+Specifies how long entries can remain idle. If operations do not occur for\n+entries, they become idle.\n+\n+[IMPORTANT]\n+====\n+Maximum idle expiration does not currently support:\n+\n+* Entries stored in off-heap memory.\n+* Cache configurations with persistent cache stores.\n+\n+When using maximum idle expiration with an exception-based eviction policy,\n+entries that are expired by not yet removed from the cache count towards the", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1MzkzOQ==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373653939", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When using maximum idle expiration with an exception-based eviction policy,\n          \n          \n            \n            When using expiration with an exception-based eviction policy,", "author": "wburns", "createdAt": "2020-01-31T19:44:54Z", "path": "documentation/src/main/asciidoc/topics/con_expiration.adoc", "diffHunk": "@@ -0,0 +1,23 @@\n+[id='expiration-{context}']\n+= Expiration\n+Expiration removes entries from memory when they reach one of the following\n+time limits:\n+\n+Lifespan::\n+Sets the maximum amount of time that entries can exist.\n+\n+Maximum idle::\n+Specifies how long entries can remain idle. If operations do not occur for\n+entries, they become idle.\n+\n+[IMPORTANT]\n+====\n+Maximum idle expiration does not currently support:\n+\n+* Entries stored in off-heap memory.\n+* Cache configurations with persistent cache stores.\n+\n+When using maximum idle expiration with an exception-based eviction policy,", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1NDA0MQ==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373654041", "bodyText": "I am not sure why the old doc only mentioned that for maximum idle, it is all of expiration.", "author": "wburns", "createdAt": "2020-01-31T19:45:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1MzkzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1NDE4MA==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373654180", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Expiration removes entries from memory when they reach one of the following\n          \n          \n            \n            Expiration removes entries from the cache when they reach one of the following", "author": "wburns", "createdAt": "2020-01-31T19:45:28Z", "path": "documentation/src/main/asciidoc/topics/con_expiration.adoc", "diffHunk": "@@ -0,0 +1,23 @@\n+[id='expiration-{context}']\n+= Expiration\n+Expiration removes entries from memory when they reach one of the following", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1NDQ4OA==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373654488", "bodyText": "I don't know if we need this blurb or not.", "author": "wburns", "createdAt": "2020-01-31T19:46:10Z", "path": "documentation/src/main/asciidoc/topics/con_expiration_overview.adoc", "diffHunk": "@@ -0,0 +1,38 @@\n+[id='how_expiration_works-{context}']\n+= How Expiration Works\n+By default, `Cache.put()` creates immortal entries. With expiration, `Cache.put()` creates mortal entries with lifespans and maximum idle times.", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1NDczNQ==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373654735", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Expiration occurs whenever entries are accessed or iterated on.\n          \n          \n            \n            Expiration occurs whenever entries are accessed or found by the expiration reaper.", "author": "wburns", "createdAt": "2020-01-31T19:46:45Z", "path": "documentation/src/main/asciidoc/topics/con_expiration_overview.adoc", "diffHunk": "@@ -0,0 +1,38 @@\n+[id='how_expiration_works-{context}']\n+= How Expiration Works\n+By default, `Cache.put()` creates immortal entries. With expiration, `Cache.put()` creates mortal entries with lifespans and maximum idle times.\n+\n+When you configure expiration, {brandname} stores keys with metadata that\n+determines when entries expire.\n+\n+* Lifespan uses a `creation` timestamp and the value for the `lifespan` configuration property.\n+* Maximum idle uses a `last used` timestamp and the value for the `max-idle` configuration property.\n+\n+{brandname} checks if lifespan or maximum idle metadata is set and then\n+compares the values with the current time.\n+\n+If `(creation + lifespan > currentTime)` or `(lastUsed + maxIdle > currentTime)` then {brandname} detects that the entry is expired.\n+\n+Expiration occurs whenever entries are accessed or iterated on.", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1NDkxNQ==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373654915", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            expired and removes it. The `Cache.get()` call does not return.\n          \n          \n            \n            expired and removes it. The `Cache.get()` will return `null`.", "author": "wburns", "createdAt": "2020-01-31T19:47:09Z", "path": "documentation/src/main/asciidoc/topics/con_expiration_overview.adoc", "diffHunk": "@@ -0,0 +1,38 @@\n+[id='how_expiration_works-{context}']\n+= How Expiration Works\n+By default, `Cache.put()` creates immortal entries. With expiration, `Cache.put()` creates mortal entries with lifespans and maximum idle times.\n+\n+When you configure expiration, {brandname} stores keys with metadata that\n+determines when entries expire.\n+\n+* Lifespan uses a `creation` timestamp and the value for the `lifespan` configuration property.\n+* Maximum idle uses a `last used` timestamp and the value for the `max-idle` configuration property.\n+\n+{brandname} checks if lifespan or maximum idle metadata is set and then\n+compares the values with the current time.\n+\n+If `(creation + lifespan > currentTime)` or `(lastUsed + maxIdle > currentTime)` then {brandname} detects that the entry is expired.\n+\n+Expiration occurs whenever entries are accessed or iterated on.\n+\n+For example, `k1` reaches the maximum idle time and a client makes a\n+`Cache.get(k1)` request. In this case, {brandname} detects that the entry is\n+expired and removes it. The `Cache.get()` call does not return.", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1NTIyOA==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373655228", "bodyText": "So technically this is a bit different based on if it is a store vs a loader. Technically a loader would still load the value if it expired. The vast majority of cases are a store though.", "author": "wburns", "createdAt": "2020-01-31T19:47:52Z", "path": "documentation/src/main/asciidoc/topics/con_expiration_overview.adoc", "diffHunk": "@@ -0,0 +1,38 @@\n+[id='how_expiration_works-{context}']\n+= How Expiration Works\n+By default, `Cache.put()` creates immortal entries. With expiration, `Cache.put()` creates mortal entries with lifespans and maximum idle times.\n+\n+When you configure expiration, {brandname} stores keys with metadata that\n+determines when entries expire.\n+\n+* Lifespan uses a `creation` timestamp and the value for the `lifespan` configuration property.\n+* Maximum idle uses a `last used` timestamp and the value for the `max-idle` configuration property.\n+\n+{brandname} checks if lifespan or maximum idle metadata is set and then\n+compares the values with the current time.\n+\n+If `(creation + lifespan > currentTime)` or `(lastUsed + maxIdle > currentTime)` then {brandname} detects that the entry is expired.\n+\n+Expiration occurs whenever entries are accessed or iterated on.\n+\n+For example, `k1` reaches the maximum idle time and a client makes a\n+`Cache.get(k1)` request. In this case, {brandname} detects that the entry is\n+expired and removes it. The `Cache.get()` call does not return.\n+\n+//dnaro: contradicting info here. does this apply with local cache stores only?", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDA0Nzk5Mg==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r374047992", "bodyText": "@wburns does this mean expiration doesn't work with cache loaders? should we mention that?", "author": "oraNod", "createdAt": "2020-02-03T11:19:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1NTIyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDEyNDE1Ng==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r374124156", "bodyText": "No, it does work just fine.  You have to think of a loader vs a store differently. A Loader can only load values into memory from an external location. A store can update this external location. Thus an expiration cannot write to a Loader, however it can remove the in memory contents. We have use cases where a user wants to load from a Loader and have expiration so the value is only so stale for so long for example.", "author": "wburns", "createdAt": "2020-02-03T14:14:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1NTIyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1NTYxMg==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373655612", "bodyText": "I am not sure if we need to go into this much detail about the sizes of the objects and such here.", "author": "wburns", "createdAt": "2020-01-31T19:48:44Z", "path": "documentation/src/main/asciidoc/topics/con_expiration_overview.adoc", "diffHunk": "@@ -0,0 +1,38 @@\n+[id='how_expiration_works-{context}']\n+= How Expiration Works\n+By default, `Cache.put()` creates immortal entries. With expiration, `Cache.put()` creates mortal entries with lifespans and maximum idle times.\n+\n+When you configure expiration, {brandname} stores keys with metadata that\n+determines when entries expire.\n+\n+* Lifespan uses a `creation` timestamp and the value for the `lifespan` configuration property.\n+* Maximum idle uses a `last used` timestamp and the value for the `max-idle` configuration property.\n+\n+{brandname} checks if lifespan or maximum idle metadata is set and then\n+compares the values with the current time.\n+\n+If `(creation + lifespan > currentTime)` or `(lastUsed + maxIdle > currentTime)` then {brandname} detects that the entry is expired.\n+\n+Expiration occurs whenever entries are accessed or iterated on.\n+\n+For example, `k1` reaches the maximum idle time and a client makes a\n+`Cache.get(k1)` request. In this case, {brandname} detects that the entry is\n+expired and removes it. The `Cache.get()` call does not return.\n+\n+//dnaro: contradicting info here. does this apply with local cache stores only?\n+{brandname} first removes entries from the data container and then from the\n+cache store, if configured.\n+\n+[NOTE]\n+====\n+{brandname} adds expiration metadata as `long` primitive data types to cache entries.\n+\n+If you configure lifespan expiration, {brandname} adds only the corresponding\n+metadata and likewise for maximum idle. If you configure both lifespan and\n+maximum idle expiration, {brandname} adds all metadata to keys.\n+\n+`long` primitive data types are eight bytes in size. If you configure either", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1Njg3MA==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373656870", "bodyText": "We don't remove those objects as part of the iteration. This is still only done on access, ie. Cache#get, or from the reaper.", "author": "wburns", "createdAt": "2020-01-31T19:51:39Z", "path": "documentation/src/main/asciidoc/topics/con_expiration_maxidle.adoc", "diffHunk": "@@ -0,0 +1,32 @@\n+[id='maxidle_expiration-{context}']\n+= Maximum Idle and Clustered Caches\n+Because maximum idle expiration relies on the last access time for cache\n+entries, it has some limitations with clustered cache modes.\n+\n+With lifespan expiration, the creation time for cache entries provides a value\n+that is consistent across clustered caches. For example, the creation time for\n+`k1` is always the same on all nodes.\n+\n+For maximum idle expiration with clustered caches, last access time for entries\n+is not always the same on all nodes. To ensure that entries have the same\n+relative access times across clusters, {brandname} sends touch commands to all\n+owners when keys are accessed.\n+\n+The touch commands that {brandname} send have the following considerations:\n+\n+* `Cache.get()` requests do not return until all touch commands complete. This synchronous behavior increases latency of client requests.\n+* The touch command also updates the \"recently accessed\" metadata for cache entries on all owners, which {brandname} uses for eviction.\n+//Scattered cache is community only\n+ifndef::productized[]\n+* With scattered cache mode, {brandname} sends touch commands to all nodes, not\n+just primary and backup owners.\n+endif::productized[]\n+\n+[NOTE]\n+====\n+Iteration across a clustered cache can return expired entries that have\n+exceeded the maximum idle time limit. This behavior ensures performance because \n+no remote invocations are performed during the iteration. However this behavior\n+does not refresh any expired entries, which are removed after the iteration", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1NzM3OQ==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373657379", "bodyText": "We may want to mention that currently you cannot disable the expiration reaper when a store is in use.", "author": "wburns", "createdAt": "2020-01-31T19:52:52Z", "path": "documentation/src/main/asciidoc/topics/con_expiration_reaper.adoc", "diffHunk": "@@ -0,0 +1,24 @@\n+[id='expiration_reaper-{context}']\n+= Expiration Reaper\n+{brandname} uses a reaper thread that runs periodically to detect and remove\n+expired entries. The expiration reaper ensures that expired entries that are no\n+longer accessed are removed.\n+\n+The {brandname} `ExpirationManager` interface handles the expiration reaper and\n+exposes the `processExpiration()` method.\n+\n+In some cases, you can disable the expiration reaper and manually expire\n+entries by calling `processExpiration()`; for instance, if you are using local\n+cache mode with a custom application where a maintenance thread runs\n+periodically.\n+\n+[IMPORTANT]\n+====\n+If you use clustered cache modes or cache stores, you should never disable the", "originalCommit": "8df60a672c54ceae7047b574a2cc8d015e1bc05d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1Nzc5NA==", "url": "https://github.com/infinispan/infinispan/pull/7809#discussion_r373657794", "bodyText": "We may want to revisit this requirement, I can't quite remember why we did this. It was over almost 5 years ago :)", "author": "wburns", "createdAt": "2020-01-31T19:53:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY1NzM3OQ=="}], "type": "inlineReview"}, {"oid": "931bbf8fb00d8d9a2b8f714abd121d4f5b2fdde2", "url": "https://github.com/infinispan/infinispan/commit/931bbf8fb00d8d9a2b8f714abd121d4f5b2fdde2", "message": "wburns review feedback and tech corrections", "committedDate": "2020-02-03T11:19:58Z", "type": "forcePushed"}, {"oid": "3d17388c42ab7a006d1e4c9742c8fba1e17b064b", "url": "https://github.com/infinispan/infinispan/commit/3d17388c42ab7a006d1e4c9742c8fba1e17b064b", "message": "updating expiration schema docs and config examples", "committedDate": "2020-02-03T13:45:30Z", "type": "forcePushed"}, {"oid": "99762f59787931b8dc6b21c637cc1c6e908dad1c", "url": "https://github.com/infinispan/infinispan/commit/99762f59787931b8dc6b21c637cc1c6e908dad1c", "message": "ISPN-10604 eviction and expiration doc updates", "committedDate": "2020-02-03T16:08:28Z", "type": "forcePushed"}, {"oid": "ddd6e04fd0dbeb564085e82c79fb5b8127f60026", "url": "https://github.com/infinispan/infinispan/commit/ddd6e04fd0dbeb564085e82c79fb5b8127f60026", "message": "ISPN-10604 eviction and expiration doc updates", "committedDate": "2020-02-03T16:19:00Z", "type": "forcePushed"}, {"oid": "e6b71ed65917fd39ad5de22caa865ee3cc82ee75", "url": "https://github.com/infinispan/infinispan/commit/e6b71ed65917fd39ad5de22caa865ee3cc82ee75", "message": "ISPN-10604 eviction and expiration doc updates", "committedDate": "2020-02-03T16:34:48Z", "type": "forcePushed"}, {"oid": "cb3b2138c39b769a710ab3476d8f33b6f61a8839", "url": "https://github.com/infinispan/infinispan/commit/cb3b2138c39b769a710ab3476d8f33b6f61a8839", "message": "max idle and invalidation", "committedDate": "2020-02-04T15:42:56Z", "type": "forcePushed"}, {"oid": "96d4e5cee90267659503bfafcf3fd9afc499f007", "url": "https://github.com/infinispan/infinispan/commit/96d4e5cee90267659503bfafcf3fd9afc499f007", "message": "ISPN-10604 eviction and expiration doc updates", "committedDate": "2020-02-05T12:07:25Z", "type": "forcePushed"}, {"oid": "9b2e21390d40c593141e6d8d205df0e165f42d1b", "url": "https://github.com/infinispan/infinispan/commit/9b2e21390d40c593141e6d8d205df0e165f42d1b", "message": "ISPN-10604 eviction and expiration doc updates", "committedDate": "2020-02-07T15:00:32Z", "type": "commit"}, {"oid": "9b2e21390d40c593141e6d8d205df0e165f42d1b", "url": "https://github.com/infinispan/infinispan/commit/9b2e21390d40c593141e6d8d205df0e165f42d1b", "message": "ISPN-10604 eviction and expiration doc updates", "committedDate": "2020-02-07T15:00:32Z", "type": "forcePushed"}]}