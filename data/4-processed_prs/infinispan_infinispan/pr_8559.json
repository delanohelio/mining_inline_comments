{"pr_number": 8559, "pr_title": "ISPN-11304 Add anchored keys documentation in developer guide", "pr_createdAt": "2020-07-16T18:10:45Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8559", "timeline": [{"oid": "6b2b974855bb35d7c31f786a2ef0e468ff08a3a0", "url": "https://github.com/infinispan/infinispan/commit/6b2b974855bb35d7c31f786a2ef0e468ff08a3a0", "message": "ISPN-11304 Add anchored keys documentation in developer guide", "committedDate": "2020-07-21T16:39:44Z", "type": "forcePushed"}, {"oid": "690974e8e80b4081f2d2a963330c8f72cb4983fc", "url": "https://github.com/infinispan/infinispan/commit/690974e8e80b4081f2d2a963330c8f72cb4983fc", "message": "ISPN-11304 Add anchored keys documentation in developer guide", "committedDate": "2020-07-21T21:14:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTMyNzc0NQ==", "url": "https://github.com/infinispan/infinispan/pull/8559#discussion_r459327745", "bodyText": "These should be i18n logs.", "author": "ryanemerson", "createdAt": "2020-07-23T09:35:45Z", "path": "anchored-keys/src/main/java/org/infinispan/anchored/configuration/AnchoredKeysConfigurationBuilder.java", "diffHunk": "@@ -42,12 +50,46 @@ public void validate() {\n       if (!rootBuilder.clustering().cacheMode().isReplicated()) {\n          throw new CacheConfigurationException(\"Anchored keys requires cache to be in replication mode\");\n       }\n-      if (rootBuilder.transaction().transactionMode() != null && rootBuilder.transaction().transactionMode().isTransactional()) {\n+      if (rootBuilder.transaction().transactionMode() != null &&\n+          rootBuilder.transaction().transactionMode().isTransactional()) {\n          throw new CacheConfigurationException(\"Anchored keys do not support transactions\");\n       }\n+      Attribute<Boolean> stateTransferEnabledAttribute =\n+            rootBuilder.clustering().stateTransfer().attributes()\n+                       .attribute(StateTransferConfiguration.FETCH_IN_MEMORY_STATE);\n+      if (!stateTransferEnabledAttribute.get()) {\n+         throw new CacheConfigurationException(\"Anchored keys caches must have state transfer enabled\");\n+      }\n \n-      // TODO Maybe just assert that awaitInitialTransfer is disabled instead?\n+      Attribute<Boolean> awaitStateTransferAttribute =\n+            rootBuilder.clustering().stateTransfer().attributes()\n+                       .attribute(StateTransferConfiguration.AWAIT_INITIAL_TRANSFER);\n+      if (awaitStateTransferAttribute.get() && awaitStateTransferAttribute.isModified()) {\n+         throw new CacheConfigurationException(\n+               \"Anchored keys do not support awaiting for state transfer when starting a cache, please remove the \" +\n+               \"await-initial-transfer attribute from your configuration\");\n+      }\n       rootBuilder.clustering().stateTransfer().awaitInitialTransfer(false);\n+\n+      Attribute<PartitionHandling> whenSplitAttribute =\n+            rootBuilder.clustering().partitionHandling().attributes()\n+                       .attribute(PartitionHandlingConfiguration.WHEN_SPLIT);\n+      if (whenSplitAttribute.get() != PartitionHandling.ALLOW_READ_WRITES && whenSplitAttribute.isModified()) {\n+         throw new CacheConfigurationException(\n+               \"Anchored keys only support partition handling mode ALLOW_READ_WRITES, please remove the when-split \" +\n+               \"attribute from your configuration\");\n+      }\n+      rootBuilder.clustering().partitionHandling().whenSplit(PartitionHandling.ALLOW_READ_WRITES);\n+\n+      Attribute<EntryMergePolicy> mergePolicyAttribute =\n+            rootBuilder.clustering().partitionHandling().attributes()\n+                       .attribute(PartitionHandlingConfiguration.MERGE_POLICY);\n+      if (mergePolicyAttribute.get() != MergePolicy.PREFERRED_NON_NULL && mergePolicyAttribute.isModified()) {\n+         throw new CacheConfigurationException(", "originalCommit": "690974e8e80b4081f2d2a963330c8f72cb4983fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM2MjU4MQ==", "url": "https://github.com/infinispan/infinispan/pull/8559#discussion_r459362581", "bodyText": "Maybe: \"State transfer does not transfer values, only keys and anchor owner information.", "author": "oraNod", "createdAt": "2020-07-23T10:45:01Z", "path": "documentation/src/main/asciidoc/topics/anchored_keys.adoc", "diffHunk": "@@ -0,0 +1,179 @@\n+[[anchored_keys_module]]\n+= Anchored Keys module\n+\n+{brandname} version 11 introduces an experimental module that allows scaling up a cluster\n+and adding new nodes without expensive *state transfer*.\n+\n+\n+== Background\n+\n+For background, the preferred way to scale up the storage capacity of a {brandname} cluster\n+is to use distributed caches.\n+A distributed cache stores each key/value pair on `num-owners` nodes,\n+and each node can compute the location of a key (aka the key owners) directly.\n+\n+{brandname} achieves this by statically mapping cache keys to `num-segments` *consistent hash segments*,\n+and then dynamically mapping segments to nodes based on the cache's *topology*\n+(roughly the current plus the historical membership of the cache).\n+Whenever a new node joins the cluster, the cache is *rebalanced*, and the new node replaces an existing node\n+as the owner of some segments.\n+The key/value pairs in those segments are copied to the new node and removed from the no-longer-owner node\n+via *state transfer*.\n+\n+NOTE: Because the allocation of segments to nodes is based on random UUIDs generated at start time,\n+it is common (though less so after\n+link:https://issues.redhat.com/browse/ISPN-11679[ISPN-11679]\n+), for segments to also move from one old node to another old node.\n+\n+\n+== Architecture\n+\n+The basic idea is to skip the static mapping of keys to segments and to map keys directly to nodes.\n+\n+When a key/value pair is inserted into the cache,\n+the newest member becomes the **anchor owner** of that key, and the only node storing the actual value.\n+In order to make the anchor location available without an extra remote lookup,\n+all the other nodes store a reference to the anchor owner.\n+\n+That way, when another node joins, it only needs to receive the location information from the existing nodes,\n+and values can stay on the anchor owner, minimizing the amount of traffic.\n+\n+\n+== Limitations\n+\n+Only one node can be added at a time::\n+An external actor (e.g. a Kubernetes/OpenShift operator, or a human administrator)\n+must monitor the load on the current nodes, and add a new node whenever the newest node\n+is close to \"full\".\n+\n+NOTE: Because the anchor owner information is replicated on all the nodes, and values are never moved off a node,\n+the memory usage of each node will keep growing as new entries and nodes are added.\n+\n+There is no redundancy::\n+Every value is only stored on a single node.\n+When a node crashes or even stops gracefully, the values stored on that node are lost.\n+\n+Transactions are not supported::\n+A later version may add transaction support, but the fact that any node stop or crash\n+loses entries makes transactions a lot less valuable compared to a distributed cache.\n+\n+Hot Rod clients do not know the anchor owner::\n+Hot Rod clients cannot use the topology information from the servers to locate the anchor owner.\n+Instead, the server receiving a Hot Rod get request must make an additional request to the anchor owner\n+in order to retrieve the value.\n+\n+\n+== Configuration\n+\n+The module is still very young and does not yet support many Infinispan features.\n+\n+Eventually, if it proves useful, it may become another cache mode, just like scattered caches.\n+For now, configuring a cache with anchored keys requires a replicated cache with a custom element `anchored-keys`:\n+\n+[source,xml,options=\"nowrap\",subs=attributes+]\n+----\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<infinispan\n+      xmlns=\"urn:infinispan:config:{schemaversion}\"\n+      xmlns:anchored=\"urn:infinispan:config:anchored:{schemaversion}\"\n+      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+      xsi:schemaLocation=\"urn:infinispan:config:{schemaversion}\n+            https://infinispan.org/schemas/infinispan-config-{schemaversion}.xsd\n+            urn:infinispan:config:anchored:{schemaversion}\n+            https://infinispan.org/schemas/infinispan-anchored-config-{schemaversion}.xsd\">\n+\n+    <cache-container default-cache=\"default\">\n+        <transport/>\n+        <replicated-cache name=\"default\">\n+            <anchored:anchored-keys/>\n+        </replicated-cache>\n+    </cache-container>\n+\n+</infinispan>\n+----\n+\n+When the `<anchored-keys/>` element is present, the module automatically enables anchored keys\n+and makes some required configuration changes:\n+\n+* Disables `await-initial-transfer`\n+* Enables conflict resolution with the equivalent of\n++\n+`<partition-handling when-split=\"ALLOW_READ_WRITES\" merge-policy=\"PREFER_NON_NULL\"/>`\n+\n+The cache will fail to start if these attributes are explicitly set to other values,\n+if state transfer is disabled, or if transactions are enabled.\n+\n+\n+== Implementation status\n+\n+Basic operations are implemented: `put`, `putIfAbsent`, `get`, `replace`, `remove`, `putAll`, `getAll`.\n+\n+\n+=== Functional commands\n+The `FunctionalMap` API is not implemented.\n+\n+Other operations that rely on the functional API's implementation do not work either: `merge`, `compute`,\n+`computeIfPresent`, `computeIfAbsent`.\n+\n+=== Partition handling\n+When a node crashes, surviving nodes do not remove anchor references pointing to that node.\n+In theory, this could allow merges to skip conflict resolution, but currently the `PREFERRED_NON_NULL`\n+merge policy is configured automatically and cannot be changed.\n+\n+=== Listeners\n+Cluster listeners and client listeners are implemented and receive the correct notifications.\n+\n+Non-clustered embedded listeners currently receive notifications on all the nodes, not just the node\n+where the value is stored.\n+\n+\n+== Performance considerations\n+\n+=== Client/Server Latency\n+The client always contacts the primary owner, so any read has a\n+`(N-1)/N` probability of requiring a unicast RPC from the primary to the anchor owner.\n+\n+Writes require the primary to send the value to one node and the anchor address\n+to all the other nodes, which is currently done with `N-1` unicast RPCs.\n+\n+In theory we could send in parallel one unicast RPC for the value and one multicast RPC for the address,\n+but that would need additional logic to ignore the address on the anchor owner\n+and with TCP multicast RPCs are implemented as parallel unicasts anyway.\n+\n+\n+=== Memory overhead\n+Compared to a distributed cache with one owner, an anchored-keys cache\n+contains copies of all the keys and their locations, plus the overhead of the cache itself.\n+\n+Therefore, a node with anchored-keys caches should stop accepting new entries when it has less than\n+`(<key size> + <per-key overhead>) * <number of entries not yet inserted>` bytes available.\n+\n+NOTE: The number of entries not yet inserted is obviously very hard to estimate.\n+In the future we may provide a way to limit the overhead of key location information,\n+e.g. by using a distributed cache.\n+\n+The per-key overhead is lowest for off-heap storage, around 63 bytes:\n+8 bytes for the entry reference in `MemoryAddressHash.memory`,\n+29 bytes for the off-heap entry header,\n+and 26 bytes for the serialized `RemoteMetadata` with the owner's address.\n+\n+The per-key overhead of the ConcurrentHashMap-based on-heap cache,\n+assuming a 64-bit JVM with compressed OOPS, would be around 92 bytes:\n+32 bytes for `ConcurrentHashMap.Node`, 32 bytes for `MetadataImmortalCacheEntry`,\n+24 bytes for `RemoteMetadata`, and 4 bytes in the `ConcurrentHashMap.table` array.\n+\n+\n+=== State transfer\n+State transfer does not transfer the actual values, but it still needs\n+to transfer all the keys and the anchor owner information.", "originalCommit": "690974e8e80b4081f2d2a963330c8f72cb4983fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM2MzAwMg==", "url": "https://github.com/infinispan/infinispan/pull/8559#discussion_r459363002", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            the anchor cache's state transfer should also be much faster\n          \n          \n            \n            state transfer for an anchored cache should also be much faster", "author": "oraNod", "createdAt": "2020-07-23T10:46:00Z", "path": "documentation/src/main/asciidoc/topics/anchored_keys.adoc", "diffHunk": "@@ -0,0 +1,179 @@\n+[[anchored_keys_module]]\n+= Anchored Keys module\n+\n+{brandname} version 11 introduces an experimental module that allows scaling up a cluster\n+and adding new nodes without expensive *state transfer*.\n+\n+\n+== Background\n+\n+For background, the preferred way to scale up the storage capacity of a {brandname} cluster\n+is to use distributed caches.\n+A distributed cache stores each key/value pair on `num-owners` nodes,\n+and each node can compute the location of a key (aka the key owners) directly.\n+\n+{brandname} achieves this by statically mapping cache keys to `num-segments` *consistent hash segments*,\n+and then dynamically mapping segments to nodes based on the cache's *topology*\n+(roughly the current plus the historical membership of the cache).\n+Whenever a new node joins the cluster, the cache is *rebalanced*, and the new node replaces an existing node\n+as the owner of some segments.\n+The key/value pairs in those segments are copied to the new node and removed from the no-longer-owner node\n+via *state transfer*.\n+\n+NOTE: Because the allocation of segments to nodes is based on random UUIDs generated at start time,\n+it is common (though less so after\n+link:https://issues.redhat.com/browse/ISPN-11679[ISPN-11679]\n+), for segments to also move from one old node to another old node.\n+\n+\n+== Architecture\n+\n+The basic idea is to skip the static mapping of keys to segments and to map keys directly to nodes.\n+\n+When a key/value pair is inserted into the cache,\n+the newest member becomes the **anchor owner** of that key, and the only node storing the actual value.\n+In order to make the anchor location available without an extra remote lookup,\n+all the other nodes store a reference to the anchor owner.\n+\n+That way, when another node joins, it only needs to receive the location information from the existing nodes,\n+and values can stay on the anchor owner, minimizing the amount of traffic.\n+\n+\n+== Limitations\n+\n+Only one node can be added at a time::\n+An external actor (e.g. a Kubernetes/OpenShift operator, or a human administrator)\n+must monitor the load on the current nodes, and add a new node whenever the newest node\n+is close to \"full\".\n+\n+NOTE: Because the anchor owner information is replicated on all the nodes, and values are never moved off a node,\n+the memory usage of each node will keep growing as new entries and nodes are added.\n+\n+There is no redundancy::\n+Every value is only stored on a single node.\n+When a node crashes or even stops gracefully, the values stored on that node are lost.\n+\n+Transactions are not supported::\n+A later version may add transaction support, but the fact that any node stop or crash\n+loses entries makes transactions a lot less valuable compared to a distributed cache.\n+\n+Hot Rod clients do not know the anchor owner::\n+Hot Rod clients cannot use the topology information from the servers to locate the anchor owner.\n+Instead, the server receiving a Hot Rod get request must make an additional request to the anchor owner\n+in order to retrieve the value.\n+\n+\n+== Configuration\n+\n+The module is still very young and does not yet support many Infinispan features.\n+\n+Eventually, if it proves useful, it may become another cache mode, just like scattered caches.\n+For now, configuring a cache with anchored keys requires a replicated cache with a custom element `anchored-keys`:\n+\n+[source,xml,options=\"nowrap\",subs=attributes+]\n+----\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<infinispan\n+      xmlns=\"urn:infinispan:config:{schemaversion}\"\n+      xmlns:anchored=\"urn:infinispan:config:anchored:{schemaversion}\"\n+      xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+      xsi:schemaLocation=\"urn:infinispan:config:{schemaversion}\n+            https://infinispan.org/schemas/infinispan-config-{schemaversion}.xsd\n+            urn:infinispan:config:anchored:{schemaversion}\n+            https://infinispan.org/schemas/infinispan-anchored-config-{schemaversion}.xsd\">\n+\n+    <cache-container default-cache=\"default\">\n+        <transport/>\n+        <replicated-cache name=\"default\">\n+            <anchored:anchored-keys/>\n+        </replicated-cache>\n+    </cache-container>\n+\n+</infinispan>\n+----\n+\n+When the `<anchored-keys/>` element is present, the module automatically enables anchored keys\n+and makes some required configuration changes:\n+\n+* Disables `await-initial-transfer`\n+* Enables conflict resolution with the equivalent of\n++\n+`<partition-handling when-split=\"ALLOW_READ_WRITES\" merge-policy=\"PREFER_NON_NULL\"/>`\n+\n+The cache will fail to start if these attributes are explicitly set to other values,\n+if state transfer is disabled, or if transactions are enabled.\n+\n+\n+== Implementation status\n+\n+Basic operations are implemented: `put`, `putIfAbsent`, `get`, `replace`, `remove`, `putAll`, `getAll`.\n+\n+\n+=== Functional commands\n+The `FunctionalMap` API is not implemented.\n+\n+Other operations that rely on the functional API's implementation do not work either: `merge`, `compute`,\n+`computeIfPresent`, `computeIfAbsent`.\n+\n+=== Partition handling\n+When a node crashes, surviving nodes do not remove anchor references pointing to that node.\n+In theory, this could allow merges to skip conflict resolution, but currently the `PREFERRED_NON_NULL`\n+merge policy is configured automatically and cannot be changed.\n+\n+=== Listeners\n+Cluster listeners and client listeners are implemented and receive the correct notifications.\n+\n+Non-clustered embedded listeners currently receive notifications on all the nodes, not just the node\n+where the value is stored.\n+\n+\n+== Performance considerations\n+\n+=== Client/Server Latency\n+The client always contacts the primary owner, so any read has a\n+`(N-1)/N` probability of requiring a unicast RPC from the primary to the anchor owner.\n+\n+Writes require the primary to send the value to one node and the anchor address\n+to all the other nodes, which is currently done with `N-1` unicast RPCs.\n+\n+In theory we could send in parallel one unicast RPC for the value and one multicast RPC for the address,\n+but that would need additional logic to ignore the address on the anchor owner\n+and with TCP multicast RPCs are implemented as parallel unicasts anyway.\n+\n+\n+=== Memory overhead\n+Compared to a distributed cache with one owner, an anchored-keys cache\n+contains copies of all the keys and their locations, plus the overhead of the cache itself.\n+\n+Therefore, a node with anchored-keys caches should stop accepting new entries when it has less than\n+`(<key size> + <per-key overhead>) * <number of entries not yet inserted>` bytes available.\n+\n+NOTE: The number of entries not yet inserted is obviously very hard to estimate.\n+In the future we may provide a way to limit the overhead of key location information,\n+e.g. by using a distributed cache.\n+\n+The per-key overhead is lowest for off-heap storage, around 63 bytes:\n+8 bytes for the entry reference in `MemoryAddressHash.memory`,\n+29 bytes for the off-heap entry header,\n+and 26 bytes for the serialized `RemoteMetadata` with the owner's address.\n+\n+The per-key overhead of the ConcurrentHashMap-based on-heap cache,\n+assuming a 64-bit JVM with compressed OOPS, would be around 92 bytes:\n+32 bytes for `ConcurrentHashMap.Node`, 32 bytes for `MetadataImmortalCacheEntry`,\n+24 bytes for `RemoteMetadata`, and 4 bytes in the `ConcurrentHashMap.table` array.\n+\n+\n+=== State transfer\n+State transfer does not transfer the actual values, but it still needs\n+to transfer all the keys and the anchor owner information.\n+\n+Assuming that the values are much bigger compared to the keys,\n+the anchor cache's state transfer should also be much faster", "originalCommit": "690974e8e80b4081f2d2a963330c8f72cb4983fc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7f4e96fd5a58846ea3356653aa44d77c5675a6e0", "url": "https://github.com/infinispan/infinispan/commit/7f4e96fd5a58846ea3356653aa44d77c5675a6e0", "message": "ISPN-11304 Add anchored keys documentation in developer guide", "committedDate": "2020-07-23T13:40:42Z", "type": "forcePushed"}, {"oid": "3527611ad96c6d87928e269838133412e337250f", "url": "https://github.com/infinispan/infinispan/commit/3527611ad96c6d87928e269838133412e337250f", "message": "Update FAQ\n\n* Remove references to JBoss Cache\n* Replace outdated state transfer/readExternal questions\n  with a more relevant one", "committedDate": "2020-07-23T14:21:33Z", "type": "commit"}, {"oid": "30a622659ed272dce4f63631b15171162e2f0c3a", "url": "https://github.com/infinispan/infinispan/commit/30a622659ed272dce4f63631b15171162e2f0c3a", "message": "Remove ZWSP and SHY characters in documentation", "committedDate": "2020-07-23T14:21:33Z", "type": "commit"}, {"oid": "e0596a272885d18f56df0e7549d33486ffbac09e", "url": "https://github.com/infinispan/infinispan/commit/e0596a272885d18f56df0e7549d33486ffbac09e", "message": "ISPN-11304 Mark AnchoredKeysConfiguration[Builder] as experimental", "committedDate": "2020-07-23T14:21:33Z", "type": "commit"}, {"oid": "97a70205a853cce90b09399c960d13046ae52a3f", "url": "https://github.com/infinispan/infinispan/commit/97a70205a853cce90b09399c960d13046ae52a3f", "message": "ISPN-11304 Validate anchored keys configuration requirements\n\n* Require replicated mode\n* Disallow transactions\n* Require state transfer w/out await-initial-transfer\n* Require ALLOW_READ_WRITES and merge policy PREFERRED_NON_NULL", "committedDate": "2020-07-23T15:14:06Z", "type": "commit"}, {"oid": "c9b0466f7fdbb20947c9bce98506016f1a6c618b", "url": "https://github.com/infinispan/infinispan/commit/c9b0466f7fdbb20947c9bce98506016f1a6c618b", "message": "ISPN-11304 Enable anchored keys without explicit enabled=\"true\" in XML", "committedDate": "2020-07-23T15:16:47Z", "type": "commit"}, {"oid": "c5936e6c51173e2a424746b024b608f481399a43", "url": "https://github.com/infinispan/infinispan/commit/c5936e6c51173e2a424746b024b608f481399a43", "message": "adoc", "committedDate": "2020-07-23T15:16:47Z", "type": "forcePushed"}, {"oid": "d7957474bd9dc0d6a1fa86f6147515ce42bba645", "url": "https://github.com/infinispan/infinispan/commit/d7957474bd9dc0d6a1fa86f6147515ce42bba645", "message": "ISPN-11304 Add anchored keys documentation in developer guide", "committedDate": "2020-07-23T15:17:06Z", "type": "commit"}, {"oid": "d7957474bd9dc0d6a1fa86f6147515ce42bba645", "url": "https://github.com/infinispan/infinispan/commit/d7957474bd9dc0d6a1fa86f6147515ce42bba645", "message": "ISPN-11304 Add anchored keys documentation in developer guide", "committedDate": "2020-07-23T15:17:06Z", "type": "forcePushed"}]}