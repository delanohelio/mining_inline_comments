{"pr_number": 8191, "pr_title": "ISPN-11629 Initialize DataConversion storage media type only once", "pr_createdAt": "2020-04-13T06:43:13Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8191", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk5MDYxMg==", "url": "https://github.com/infinispan/infinispan/pull/8191#discussion_r407990612", "bodyText": "I don't think we can deprecate this and remove with no replacement, the problem is RemoteQuery uses a complicated Wrapper that is not part of core, and it drags lots of dependencies to Hibernate Search.", "author": "gustavonalle", "createdAt": "2020-04-14T09:20:51Z", "path": "core/src/main/java/org/infinispan/encoding/DataConversion.java", "diffHunk": "@@ -91,26 +94,29 @@ private DataConversion(Encoder encoder, Wrapper wrapper, boolean isKey) {\n       this.isKey = isKey;\n       this.storageMediaType = MediaType.APPLICATION_OBJECT;\n       this.requestMediaType = MediaType.APPLICATION_OBJECT;\n+      encoderId = EncoderIds.NO_ENCODER;\n+      wrapperId = WrapperIds.NO_WRAPPER;\n    }\n \n    public DataConversion withRequestMediaType(MediaType requestMediaType) {\n       if (Objects.equals(this.requestMediaType, requestMediaType)) return this;\n-      return new DataConversion(null, this.wrapperClass, requestMediaType, this.storageMediaType,\n-            this.isKey);\n+      return new DataConversion(null, this.wrapperClass, requestMediaType, this.isKey);\n    }\n \n    public DataConversion withEncoding(Class<? extends Encoder> encoderClass) {\n       if (Objects.equals(this.encoderClass, encoderClass)) return this;\n-      return new DataConversion(encoderClass, this.wrapperClass, this.requestMediaType, this.storageMediaType,\n-            this.isKey);\n+      return new DataConversion(encoderClass, this.wrapperClass, this.requestMediaType, this.isKey);\n    }\n \n    public DataConversion withWrapping(Class<? extends Wrapper> wrapperClass) {\n       if (Objects.equals(this.wrapperClass, wrapperClass)) return this;\n-      return new DataConversion(this.encoderClass, wrapperClass, this.requestMediaType, this.storageMediaType,\n-            this.isKey);\n+      return new DataConversion(this.encoderClass, wrapperClass, this.requestMediaType, this.isKey);\n    }\n \n+   /**\n+    * @deprecated Since 11.0, will be removed with no replacement\n+    */\n+   @Deprecated", "originalCommit": "e426708ba9e03c8b6606d7877cd55a4887521297", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk5Mzg5OA==", "url": "https://github.com/infinispan/infinispan/pull/8191#discussion_r407993898", "bodyText": "It's yet to see the role this wrapper will play after the Hibernate Search 6 migration though...", "author": "gustavonalle", "createdAt": "2020-04-14T09:25:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk5MDYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk5NjM2Mg==", "url": "https://github.com/infinispan/infinispan/pull/8191#discussion_r407996362", "bodyText": "@gustavonalle is there a description somewhere of why we need messageDescriptor as a field in ProtobufValueWrapper instead of lazily computing it from the first few bytes of the payload when needed?", "author": "danberindei", "createdAt": "2020-04-14T09:29:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk5MDYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk5OTkxNw==", "url": "https://github.com/infinispan/infinispan/pull/8191#discussion_r407999917", "bodyText": "How could it be computed? AFAICT, messageDescriptor is the schema that describe the blob", "author": "gustavonalle", "createdAt": "2020-04-14T09:35:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk5MDYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAwMDIzOQ==", "url": "https://github.com/infinispan/infinispan/pull/8191#discussion_r408000239", "bodyText": "@anistor can tell more about it", "author": "gustavonalle", "createdAt": "2020-04-14T09:35:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk5MDYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAyMTQ4MQ==", "url": "https://github.com/infinispan/infinispan/pull/8191#discussion_r408021481", "bodyText": "The description is in the javadocs of ProtobufValueWrapper, I remember I wrote something there @danberindei . ProtobufValueWrapper is required for indexing. It needs that messageDescriptor to be able to decode the protobuf object. No, it cannot be really lazily computed without any external help.  ProtobufValueWrapper can obtain the type name or type id from the first few bytes but then it need a reference to a SerializationContext to be able to obtain that descriptor. So a bit more moving parts are involved here. What it the reason to remove/deprecate? And what ? :) [I did not follow discussion here and on zulip]", "author": "anistor", "createdAt": "2020-04-14T10:09:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk5MDYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODAzNTM4Ng==", "url": "https://github.com/infinispan/infinispan/pull/8191#discussion_r408035386", "bodyText": "@anistor deprecation would be a method in the cache that overrides a wrapper after the cache is created, and since ProtobufValueWrapper is not part of core, it'd be more difficult to associated it with a cache at creation time rather than in the RemoteQuery server lifecycle methods, but Dan has a proposal for it", "author": "gustavonalle", "createdAt": "2020-04-14T10:34:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk5MDYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjc4OTIxNQ==", "url": "https://github.com/infinispan/infinispan/pull/8191#discussion_r412789215", "bodyText": "@gustavonalle I have updated the PR to just move overrideWrapper() from DataConversion to a component named ConversionManager for now. I got a bit carried away and made a lot more changes to the initialization of the cache wrappers, so the PR is much bigger now.\n@anistor the javadoc in ProtobufValueWrapper says just\nThe Descriptor of the message (if it's a Message and not a primitive value, or null otherwise). Transient field!\nAFAICT WrappedMessageTagHandler reads a WRAPPED_DESCRIPTOR_FULL_NAME field from the payload and computes the descriptor based on that, so I was thinking maybe ProtobufValueWrapperFieldBridge could also use a WrappedMessageTagHandler to compute the descriptor on demand.", "author": "danberindei", "createdAt": "2020-04-22T08:41:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk5MDYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTc2OTcyOA==", "url": "https://github.com/infinispan/infinispan/pull/8191#discussion_r415769728", "bodyText": "@danberindei I'm glad the very informative javadoc of ProtobufValueWrapper.messageDescriptor field piqued your interest. But you may want to read also the javadoc of the setter of this field or even follow the (unfortunately) half-broken link from that description, or alternatively read the code :).\nmessageDescriptor field is set by WrappedMessageTagHandler once, to (possibly) be accessed many times and avoid the penalty of being recomputed on demand many times. That field must exist to cache this expensive thing.\nTwo places where it is used are ProtobufValueWrapperAnalyzerDiscriminator and ProtobufValueWrapperIndexingInterceptor.\nProtobufValueWrapperFieldBridge is cache-scoped, not entry-scoped. So it must store that descriptor somewhereelse ....\nI do not understand yet what and why you need to change ProtobufValueWrapper and his many ugly friends @danberindei", "author": "anistor", "createdAt": "2020-04-27T12:28:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk5MDYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTk0MzAwNg==", "url": "https://github.com/infinispan/infinispan/pull/8191#discussion_r415943006", "bodyText": "@anistor I do not intend to change ProtobufValueWrapper, but I am curious about why it is needed, so I asked \"Is there a description somewhere of why we need messageDescriptor as a field in ProtobufValueWrapper instead of lazily computing it from the first few bytes of the payload when needed?\"\nSo far I haven't seen an explanation in the javadoc or here of why computing the messageDescriptor lazily is so expensive that it's worth keeping the extra field in the heap at all times. I was imagining that the parsing of the message descriptor would be just reading a few bytes at a known offset in the value byte[], is it much more than that?", "author": "danberindei", "createdAt": "2020-04-27T16:03:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk5MDYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjAzNzE3NQ==", "url": "https://github.com/infinispan/infinispan/pull/8191#discussion_r416037175", "bodyText": "The primordial need for ProtobufValueWrapper is rooted in hibernate-search 5. It needs to discriminate on the class of an object (plus eventually configured class bridges) to be able to index it. But in 6 this changes a lot. I'd keep this ProtobufValueWrapper undisturbed until we have 6 merged, then we can try to re-analyse its worthiness.", "author": "anistor", "createdAt": "2020-04-27T18:09:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk5MDYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjEwNDM0NQ==", "url": "https://github.com/infinispan/infinispan/pull/8191#discussion_r416104345", "bodyText": "Ok, fair enough", "author": "danberindei", "createdAt": "2020-04-27T19:54:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk5MDYxMg=="}], "type": "inlineReview"}, {"oid": "802b74bcac748eff4ab688fb7e286c5a501b6de2", "url": "https://github.com/infinispan/infinispan/commit/802b74bcac748eff4ab688fb7e286c5a501b6de2", "message": "ISPN-11629 Deprecate DataConversion static instances", "committedDate": "2020-04-16T09:20:13Z", "type": "forcePushed"}, {"oid": "e3d1ae8f05eca3b372cc75ca1dd7939398a4e9fd", "url": "https://github.com/infinispan/infinispan/commit/e3d1ae8f05eca3b372cc75ca1dd7939398a4e9fd", "message": "ISPN-11629 Move conversion details out of CacheImpl and SimpleCacheImpl\n\n* Only the EncoderCache wrapper knows the request media type\n  or the encoder.\n* A new component, ConversionManager, knows the storage media type\n  and the default wrapper.\n* Inject the EncoderCache in CacheImpl until ISPN-11584 is fixed.", "committedDate": "2020-04-22T07:22:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY2NzA2OA==", "url": "https://github.com/infinispan/infinispan/pull/8191#discussion_r415667068", "bodyText": "14.0? Is this 2 years from now?  :)", "author": "gustavonalle", "createdAt": "2020-04-27T09:44:13Z", "path": "core/src/main/java/org/infinispan/encoding/DataConversion.java", "diffHunk": "@@ -43,152 +38,155 @@\n @Scope(Scopes.NONE)\n public final class DataConversion {\n \n+   /**\n+    * @deprecated Since 11.0. To be removed in 14.0, with no replacement.", "originalCommit": "e3d1ae8f05eca3b372cc75ca1dd7939398a4e9fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcwMjQ2Nw==", "url": "https://github.com/infinispan/infinispan/pull/8191#discussion_r415702467", "bodyText": "I hope it's going to be sooner than 2 years, but it's the example Tristan gave in the removal policy discussion.", "author": "danberindei", "createdAt": "2020-04-27T10:38:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY2NzA2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3MDk5NA==", "url": "https://github.com/infinispan/infinispan/pull/8191#discussion_r415670994", "bodyText": "Not sure about this name, this class is not doing conversion, but providing info about the storage type which does not change for all decorations a cache may have at runtime.", "author": "gustavonalle", "createdAt": "2020-04-27T09:50:02Z", "path": "core/src/main/java/org/infinispan/encoding/impl/ConversionManager.java", "diffHunk": "@@ -0,0 +1,107 @@\n+package org.infinispan.encoding.impl;\n+\n+import org.infinispan.commons.dataconversion.ByteArrayWrapper;\n+import org.infinispan.commons.dataconversion.MediaType;\n+import org.infinispan.commons.dataconversion.Wrapper;\n+import org.infinispan.commons.marshall.Marshaller;\n+import org.infinispan.configuration.cache.Configuration;\n+import org.infinispan.configuration.cache.Configurations;\n+import org.infinispan.configuration.cache.ContentTypeConfiguration;\n+import org.infinispan.configuration.cache.EncodingConfiguration;\n+import org.infinispan.configuration.cache.StorageType;\n+import org.infinispan.configuration.global.GlobalConfiguration;\n+import org.infinispan.factories.KnownComponentNames;\n+import org.infinispan.factories.annotations.ComponentName;\n+import org.infinispan.factories.annotations.Inject;\n+import org.infinispan.factories.scopes.Scope;\n+import org.infinispan.factories.scopes.Scopes;\n+import org.infinispan.marshall.core.EncoderRegistry;\n+import org.infinispan.marshall.persistence.PersistenceMarshaller;\n+import org.infinispan.registry.InternalCacheRegistry;\n+\n+/**\n+ * Key/value conversion information.\n+ *\n+ * @author Dan Berindei\n+ * @since 11\n+ */\n+@Scope(Scopes.NAMED_CACHE)\n+public class ConversionManager {", "originalCommit": "e3d1ae8f05eca3b372cc75ca1dd7939398a4e9fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTcwMzYwOA==", "url": "https://github.com/infinispan/infinispan/pull/8191#discussion_r415703608", "bodyText": "I wasn't sure about the name either, WDYT about StorageManager or StorageHelper @gustavonalle ?", "author": "danberindei", "createdAt": "2020-04-27T10:40:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3MDk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ5MjkyNA==", "url": "https://github.com/infinispan/infinispan/pull/8191#discussion_r416492924", "bodyText": "StorageConfigurationManager ?", "author": "gustavonalle", "createdAt": "2020-04-28T10:08:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3MDk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA0Mjg2NQ==", "url": "https://github.com/infinispan/infinispan/pull/8191#discussion_r418042865", "bodyText": "Sounds good, updated @gustavonalle", "author": "danberindei", "createdAt": "2020-04-30T14:15:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3MDk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3MjUyOA==", "url": "https://github.com/infinispan/infinispan/pull/8191#discussion_r415672528", "bodyText": "I just updated #8196", "author": "gustavonalle", "createdAt": "2020-04-27T09:52:18Z", "path": "core/src/main/java/org/infinispan/encoding/DataConversion.java", "diffHunk": "@@ -43,152 +38,155 @@\n @Scope(Scopes.NONE)\n public final class DataConversion {\n \n+   /**\n+    * @deprecated Since 11.0. To be removed in 14.0, with no replacement.\n+    */\n+   @Deprecated\n    public static final DataConversion DEFAULT_KEY = new DataConversion(IdentityEncoder.INSTANCE, ByteArrayWrapper.INSTANCE, true);\n+   /**\n+    * @deprecated Since 11.0. To be removed in 14.0, with no replacement.\n+    */\n+   @Deprecated\n    public static final DataConversion DEFAULT_VALUE = new DataConversion(IdentityEncoder.INSTANCE, ByteArrayWrapper.INSTANCE, false);\n+   /**\n+    * @deprecated Since 11.0. To be removed in 14.0. For internal use only.\n+    */\n+   @Deprecated\n    public static final DataConversion IDENTITY_KEY = new DataConversion(IdentityEncoder.INSTANCE, IdentityWrapper.INSTANCE, true);\n+   /**\n+    * @deprecated Since 11.0. To be removed in 14.0. For internal use only.\n+    */\n+   @Deprecated\n    public static final DataConversion IDENTITY_VALUE = new DataConversion(IdentityEncoder.INSTANCE, IdentityWrapper.INSTANCE, false);\n \n    // On the origin node the conversion is initialized with the encoder/wrapper classes, on remote nodes with the ids\n-   private Class<? extends Encoder> encoderClass;\n-   private Class<? extends Wrapper> wrapperClass;\n-   private short encoderId;\n-   private byte wrapperId;\n-   private MediaType requestMediaType;\n-   private MediaType storageMediaType;\n-   private boolean isKey;\n-\n+   private final transient Class<? extends Encoder> encoderClass;\n+   // TODO Make final after removing overrideWrapper()\n+   private transient Class<? extends Wrapper> wrapperClass;\n+   private final short encoderId;\n+   private final byte wrapperId;\n+   private final MediaType requestMediaType;\n+   private final boolean isKey;\n+\n+   private transient MediaType storageMediaType;\n    private transient Encoder encoder;\n-   private transient Wrapper wrapper;\n+   private transient Wrapper customWrapper;\n    private transient Transcoder transcoder;\n    private transient EncoderRegistry encoderRegistry;\n+   private transient ConversionManager conversionManager;\n \n    private DataConversion(Class<? extends Encoder> encoderClass, Class<? extends Wrapper> wrapperClass,\n-                          MediaType requestMediaType, MediaType storageMediaType, boolean isKey) {\n+                          MediaType requestMediaType, boolean isKey) {\n       this.encoderClass = encoderClass;\n       this.wrapperClass = wrapperClass;\n       this.requestMediaType = requestMediaType;\n-      this.storageMediaType = storageMediaType;\n       this.isKey = isKey;\n+      this.encoderId = EncoderIds.NO_ENCODER;\n+      this.wrapperId = WrapperIds.NO_WRAPPER;\n    }\n \n    /**\n     * Used for de-serialization\n     */\n-   private DataConversion(Short encoderId, Byte wrapperId, MediaType requestMediaType, MediaType storageMediaType,\n-                          boolean isKey) {\n+   private DataConversion(Short encoderId, Byte wrapperId, MediaType requestMediaType, boolean isKey) {\n       this.encoderId = encoderId;\n       this.wrapperId = wrapperId;\n       this.requestMediaType = requestMediaType;\n-      this.storageMediaType = storageMediaType;\n       this.isKey = isKey;\n+      this.encoderClass = null;\n+      this.wrapperClass = null;\n    }\n \n    private DataConversion(Encoder encoder, Wrapper wrapper, boolean isKey) {\n       this.encoder = encoder;\n-      this.wrapper = wrapper;\n+      this.customWrapper = wrapper;\n       this.encoderClass = encoder.getClass();\n       this.wrapperClass = wrapper.getClass();\n       this.isKey = isKey;\n       this.storageMediaType = MediaType.APPLICATION_OBJECT;\n       this.requestMediaType = MediaType.APPLICATION_OBJECT;\n+      encoderId = EncoderIds.NO_ENCODER;\n+      wrapperId = WrapperIds.NO_WRAPPER;\n    }\n \n    public DataConversion withRequestMediaType(MediaType requestMediaType) {\n       if (Objects.equals(this.requestMediaType, requestMediaType)) return this;\n-      return new DataConversion(null, this.wrapperClass, requestMediaType, this.storageMediaType,\n-            this.isKey);\n+      return new DataConversion(this.encoderClass, this.wrapperClass, requestMediaType, this.isKey);\n    }\n \n    public DataConversion withEncoding(Class<? extends Encoder> encoderClass) {\n       if (Objects.equals(this.encoderClass, encoderClass)) return this;\n-      return new DataConversion(encoderClass, this.wrapperClass, this.requestMediaType, this.storageMediaType,\n-            this.isKey);\n+      return new DataConversion(encoderClass, this.wrapperClass, this.requestMediaType, this.isKey);\n    }\n \n+   /**\n+    * @deprecated Since 11.0. To be removed in 14.0, with no replacement.\n+    */\n+   @Deprecated\n    public DataConversion withWrapping(Class<? extends Wrapper> wrapperClass) {\n       if (Objects.equals(this.wrapperClass, wrapperClass)) return this;\n-      return new DataConversion(this.encoderClass, wrapperClass, this.requestMediaType, this.storageMediaType,\n-            this.isKey);\n+      return new DataConversion(this.encoderClass, wrapperClass, this.requestMediaType, this.isKey);\n    }\n \n+   /**\n+    * @deprecated Since 11.0, will be removed with no replacement\n+    */\n+   @Deprecated\n    public void overrideWrapper(Class<? extends Wrapper> newWrapper, ComponentRegistry cr) {\n-      this.wrapper = null;\n+      this.customWrapper = null;\n       this.wrapperClass = newWrapper;\n       cr.wireDependencies(this);\n    }\n \n    /**\n-    * Obtain the configured {@link MediaType} for this instance, or assume sensible defaults.\n+    * @deprecated Since 11.0. To be removed in 14.0, with no replacement.\n     */\n-   private MediaType getStorageMediaType(Configuration configuration, boolean embeddedMode, boolean internalCache, PersistenceMarshaller persistenceMarshaller) {\n-      EncodingConfiguration encodingConfiguration = configuration.encoding();\n-      ContentTypeConfiguration contentTypeConfiguration = isKey ? encodingConfiguration.keyDataType() : encodingConfiguration.valueDataType();\n-      Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n-      MediaType mediaType = userMarshaller.mediaType();\n-      boolean heap = configuration.memory().storageType() == StorageType.OBJECT;\n-      // If explicitly configured, use the value provided\n-      if (contentTypeConfiguration.isMediaTypeChanged()) {\n-         return contentTypeConfiguration.mediaType();\n-      }\n-      // Indexed caches started by the server will assume application/protostream as storage media type\n-      if (!embeddedMode && configuration.indexing().enabled() && contentTypeConfiguration.mediaType() == null) {\n-         return MediaType.APPLICATION_PROTOSTREAM;\n-      }\n-      if (internalCache) return MediaType.APPLICATION_OBJECT;\n-\n-      if (embeddedMode) {\n-         return heap ? MediaType.APPLICATION_OBJECT : mediaType;\n-      }\n-\n-      return MediaType.APPLICATION_UNKNOWN;\n-   }\n-\n+   @Deprecated\n    public boolean isConversionSupported(MediaType mediaType) {", "originalCommit": "e3d1ae8f05eca3b372cc75ca1dd7939398a4e9fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTY3MjkxOQ==", "url": "https://github.com/infinispan/infinispan/pull/8191#discussion_r415672919", "bodyText": "I just updated #8196, could you handle it first, since you are including that commit in this PR?", "author": "gustavonalle", "createdAt": "2020-04-27T09:52:55Z", "path": "core/src/main/java/org/infinispan/encoding/DataConversion.java", "diffHunk": "@@ -43,152 +38,155 @@\n @Scope(Scopes.NONE)\n public final class DataConversion {\n \n+   /**\n+    * @deprecated Since 11.0. To be removed in 14.0, with no replacement.\n+    */\n+   @Deprecated\n    public static final DataConversion DEFAULT_KEY = new DataConversion(IdentityEncoder.INSTANCE, ByteArrayWrapper.INSTANCE, true);\n+   /**\n+    * @deprecated Since 11.0. To be removed in 14.0, with no replacement.\n+    */\n+   @Deprecated\n    public static final DataConversion DEFAULT_VALUE = new DataConversion(IdentityEncoder.INSTANCE, ByteArrayWrapper.INSTANCE, false);\n+   /**\n+    * @deprecated Since 11.0. To be removed in 14.0. For internal use only.\n+    */\n+   @Deprecated\n    public static final DataConversion IDENTITY_KEY = new DataConversion(IdentityEncoder.INSTANCE, IdentityWrapper.INSTANCE, true);\n+   /**\n+    * @deprecated Since 11.0. To be removed in 14.0. For internal use only.\n+    */\n+   @Deprecated\n    public static final DataConversion IDENTITY_VALUE = new DataConversion(IdentityEncoder.INSTANCE, IdentityWrapper.INSTANCE, false);\n \n    // On the origin node the conversion is initialized with the encoder/wrapper classes, on remote nodes with the ids\n-   private Class<? extends Encoder> encoderClass;\n-   private Class<? extends Wrapper> wrapperClass;\n-   private short encoderId;\n-   private byte wrapperId;\n-   private MediaType requestMediaType;\n-   private MediaType storageMediaType;\n-   private boolean isKey;\n-\n+   private final transient Class<? extends Encoder> encoderClass;\n+   // TODO Make final after removing overrideWrapper()\n+   private transient Class<? extends Wrapper> wrapperClass;\n+   private final short encoderId;\n+   private final byte wrapperId;\n+   private final MediaType requestMediaType;\n+   private final boolean isKey;\n+\n+   private transient MediaType storageMediaType;\n    private transient Encoder encoder;\n-   private transient Wrapper wrapper;\n+   private transient Wrapper customWrapper;\n    private transient Transcoder transcoder;\n    private transient EncoderRegistry encoderRegistry;\n+   private transient ConversionManager conversionManager;\n \n    private DataConversion(Class<? extends Encoder> encoderClass, Class<? extends Wrapper> wrapperClass,\n-                          MediaType requestMediaType, MediaType storageMediaType, boolean isKey) {\n+                          MediaType requestMediaType, boolean isKey) {\n       this.encoderClass = encoderClass;\n       this.wrapperClass = wrapperClass;\n       this.requestMediaType = requestMediaType;\n-      this.storageMediaType = storageMediaType;\n       this.isKey = isKey;\n+      this.encoderId = EncoderIds.NO_ENCODER;\n+      this.wrapperId = WrapperIds.NO_WRAPPER;\n    }\n \n    /**\n     * Used for de-serialization\n     */\n-   private DataConversion(Short encoderId, Byte wrapperId, MediaType requestMediaType, MediaType storageMediaType,\n-                          boolean isKey) {\n+   private DataConversion(Short encoderId, Byte wrapperId, MediaType requestMediaType, boolean isKey) {\n       this.encoderId = encoderId;\n       this.wrapperId = wrapperId;\n       this.requestMediaType = requestMediaType;\n-      this.storageMediaType = storageMediaType;\n       this.isKey = isKey;\n+      this.encoderClass = null;\n+      this.wrapperClass = null;\n    }\n \n    private DataConversion(Encoder encoder, Wrapper wrapper, boolean isKey) {\n       this.encoder = encoder;\n-      this.wrapper = wrapper;\n+      this.customWrapper = wrapper;\n       this.encoderClass = encoder.getClass();\n       this.wrapperClass = wrapper.getClass();\n       this.isKey = isKey;\n       this.storageMediaType = MediaType.APPLICATION_OBJECT;\n       this.requestMediaType = MediaType.APPLICATION_OBJECT;\n+      encoderId = EncoderIds.NO_ENCODER;\n+      wrapperId = WrapperIds.NO_WRAPPER;\n    }\n \n    public DataConversion withRequestMediaType(MediaType requestMediaType) {\n       if (Objects.equals(this.requestMediaType, requestMediaType)) return this;\n-      return new DataConversion(null, this.wrapperClass, requestMediaType, this.storageMediaType,\n-            this.isKey);\n+      return new DataConversion(this.encoderClass, this.wrapperClass, requestMediaType, this.isKey);\n    }\n \n    public DataConversion withEncoding(Class<? extends Encoder> encoderClass) {\n       if (Objects.equals(this.encoderClass, encoderClass)) return this;\n-      return new DataConversion(encoderClass, this.wrapperClass, this.requestMediaType, this.storageMediaType,\n-            this.isKey);\n+      return new DataConversion(encoderClass, this.wrapperClass, this.requestMediaType, this.isKey);\n    }\n \n+   /**\n+    * @deprecated Since 11.0. To be removed in 14.0, with no replacement.\n+    */\n+   @Deprecated\n    public DataConversion withWrapping(Class<? extends Wrapper> wrapperClass) {\n       if (Objects.equals(this.wrapperClass, wrapperClass)) return this;\n-      return new DataConversion(this.encoderClass, wrapperClass, this.requestMediaType, this.storageMediaType,\n-            this.isKey);\n+      return new DataConversion(this.encoderClass, wrapperClass, this.requestMediaType, this.isKey);\n    }\n \n+   /**\n+    * @deprecated Since 11.0, will be removed with no replacement\n+    */\n+   @Deprecated\n    public void overrideWrapper(Class<? extends Wrapper> newWrapper, ComponentRegistry cr) {\n-      this.wrapper = null;\n+      this.customWrapper = null;\n       this.wrapperClass = newWrapper;\n       cr.wireDependencies(this);\n    }\n \n    /**\n-    * Obtain the configured {@link MediaType} for this instance, or assume sensible defaults.\n+    * @deprecated Since 11.0. To be removed in 14.0, with no replacement.\n     */\n-   private MediaType getStorageMediaType(Configuration configuration, boolean embeddedMode, boolean internalCache, PersistenceMarshaller persistenceMarshaller) {\n-      EncodingConfiguration encodingConfiguration = configuration.encoding();\n-      ContentTypeConfiguration contentTypeConfiguration = isKey ? encodingConfiguration.keyDataType() : encodingConfiguration.valueDataType();\n-      Marshaller userMarshaller = persistenceMarshaller.getUserMarshaller();\n-      MediaType mediaType = userMarshaller.mediaType();\n-      boolean heap = configuration.memory().storageType() == StorageType.OBJECT;\n-      // If explicitly configured, use the value provided\n-      if (contentTypeConfiguration.isMediaTypeChanged()) {\n-         return contentTypeConfiguration.mediaType();\n-      }\n-      // Indexed caches started by the server will assume application/protostream as storage media type\n-      if (!embeddedMode && configuration.indexing().enabled() && contentTypeConfiguration.mediaType() == null) {\n-         return MediaType.APPLICATION_PROTOSTREAM;\n-      }\n-      if (internalCache) return MediaType.APPLICATION_OBJECT;\n-\n-      if (embeddedMode) {\n-         return heap ? MediaType.APPLICATION_OBJECT : mediaType;\n-      }\n-\n-      return MediaType.APPLICATION_UNKNOWN;\n-   }\n-\n+   @Deprecated\n    public boolean isConversionSupported(MediaType mediaType) {\n-      return storageMediaType == null || encoderRegistry.isConversionSupported(storageMediaType, mediaType);\n+      if (encoderRegistry == null) return false;\n+      return encoderRegistry.isConversionSupported(storageMediaType, mediaType);\n    }\n \n+   /**\n+    * @deprecated Since 11.0. To be removed in 14.0, with no replacement.\n+    */\n+   @Deprecated\n    public Object convert(Object o, MediaType from, MediaType to) {\n-      if (o == null) return null;\n-      if (encoderRegistry == null) return o;\n-      Transcoder transcoder = encoderRegistry.getTranscoder(from, to);\n-      return transcoder.transcode(o, from, to);\n+      return encoderRegistry.convert(o, from, to);\n    }\n \n+   /**\n+    * @deprecated Since 11.0. To be removed in 14.0, with no replacement.\n+    */\n+   @Deprecated", "originalCommit": "e3d1ae8f05eca3b372cc75ca1dd7939398a4e9fd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5dfbc3a9b911790d61387f738e0060f68e3bec31", "url": "https://github.com/infinispan/infinispan/commit/5dfbc3a9b911790d61387f738e0060f68e3bec31", "message": "ISPN-11629 Move conversion details out of CacheImpl and SimpleCacheImpl\n\n* Only the EncoderCache wrapper knows the request media type\n  or the encoder.\n* A new component, ConversionManager, knows the storage media type\n  and the default wrapper.\n* Inject the EncoderCache in CacheImpl until ISPN-11584 is fixed.", "committedDate": "2020-04-27T16:05:05Z", "type": "forcePushed"}, {"oid": "c4a9331f0502b89f9603b0dcbb1b52a048386ade", "url": "https://github.com/infinispan/infinispan/commit/c4a9331f0502b89f9603b0dcbb1b52a048386ade", "message": "ISPN-11629 Move conversion details out of CacheImpl and SimpleCacheImpl\n\n* Only the EncoderCache wrapper knows the request media type\n  or the encoder.\n* A new component, StorageConfigurationManager, knows the storage\n  media type and the default wrapper.\n* Inject the EncoderCache in CacheImpl until ISPN-11584 is fixed.", "committedDate": "2020-04-30T14:14:41Z", "type": "forcePushed"}, {"oid": "be827cbf82ad8d5215fb796398008061ced5f406", "url": "https://github.com/infinispan/infinispan/commit/be827cbf82ad8d5215fb796398008061ced5f406", "message": "ISPN-11629 Move conversion details out of CacheImpl and SimpleCacheImpl\n\n* Only the EncoderCache wrapper knows the request media type\n  or the encoder.\n* A new component, StorageConfigurationManager, knows the storage\n  media type and the default wrapper.\n* Inject the EncoderCache in CacheImpl until ISPN-11584 is fixed.", "committedDate": "2020-05-07T13:51:13Z", "type": "forcePushed"}, {"oid": "4ee8477959a27e483ee4c25fc6df2248d98e2eaa", "url": "https://github.com/infinispan/infinispan/commit/4ee8477959a27e483ee4c25fc6df2248d98e2eaa", "message": "ISPN-11689 Remove AdvancedCache methods deprecated in 9.4", "committedDate": "2020-05-20T08:51:12Z", "type": "commit"}, {"oid": "c62825158cb70a5f5189a0f9a10d13039bef4230", "url": "https://github.com/infinispan/infinispan/commit/c62825158cb70a5f5189a0f9a10d13039bef4230", "message": "ISPN-11629 Deprecate AdvancedCache.withWrapping", "committedDate": "2020-05-20T08:51:12Z", "type": "commit"}, {"oid": "d54a4f3eb188b44daa40c5fc2ae87a8ea253d922", "url": "https://github.com/infinispan/infinispan/commit/d54a4f3eb188b44daa40c5fc2ae87a8ea253d922", "message": "ISPN-11629 Initialize DataConversion storage media type only once", "committedDate": "2020-05-20T08:51:12Z", "type": "commit"}, {"oid": "a483749e87ff503cd7b6c381c1ccf8f2350765e8", "url": "https://github.com/infinispan/infinispan/commit/a483749e87ff503cd7b6c381c1ccf8f2350765e8", "message": "ISPN-11629 Deprecate DataConversion static instances", "committedDate": "2020-05-20T08:51:12Z", "type": "commit"}, {"oid": "db8d37fd6fc472a29e42142f2ff0e972d87742dc", "url": "https://github.com/infinispan/infinispan/commit/db8d37fd6fc472a29e42142f2ff0e972d87742dc", "message": "ISPN-11629 Set component registry in EncoderCache constructor\n\n* Remove AdvancedCacheWrapper interface\n* InternalCacheFactory.buildEncodingCache happens too early,\n  so injection is also needed.", "committedDate": "2020-05-20T08:51:13Z", "type": "commit"}, {"oid": "99b66e76656f239529351d7e21e6cd599b4412bf", "url": "https://github.com/infinispan/infinispan/commit/99b66e76656f239529351d7e21e6cd599b4412bf", "message": "ISPN-11629 Move conversion details out of CacheImpl and SimpleCacheImpl\n\n* Only the EncoderCache wrapper knows the request media type\n  or the encoder.\n* A new component, StorageConfigurationManager, knows the storage\n  media type and the default wrapper.\n* Inject the EncoderCache in CacheImpl until ISPN-11584 is fixed.", "committedDate": "2020-05-20T08:51:13Z", "type": "commit"}, {"oid": "99b66e76656f239529351d7e21e6cd599b4412bf", "url": "https://github.com/infinispan/infinispan/commit/99b66e76656f239529351d7e21e6cd599b4412bf", "message": "ISPN-11629 Move conversion details out of CacheImpl and SimpleCacheImpl\n\n* Only the EncoderCache wrapper knows the request media type\n  or the encoder.\n* A new component, StorageConfigurationManager, knows the storage\n  media type and the default wrapper.\n* Inject the EncoderCache in CacheImpl until ISPN-11584 is fixed.", "committedDate": "2020-05-20T08:51:13Z", "type": "forcePushed"}]}