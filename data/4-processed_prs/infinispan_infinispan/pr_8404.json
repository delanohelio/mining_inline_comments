{"pr_number": 8404, "pr_title": "ISPN-11925 updating docs for non-blocking", "pr_createdAt": "2020-05-28T16:43:56Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8404", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk3ODk0OQ==", "url": "https://github.com/infinispan/infinispan/pull/8404#discussion_r431978949", "bodyText": "@wburns hi, does this sound correct? tbh it's not entirely clear to me but I know we want more non-blocking behaviour so I have some doubts. thx.", "author": "oraNod", "createdAt": "2020-05-28T16:46:44Z", "path": "documentation/src/main/asciidoc/topics/con_write_behind.adoc", "diffHunk": "@@ -1,15 +1,14 @@\n [id='write_behind']\n = Write-Behind\n-Write-Behind is an cache writing mode where writes to memory are synchronous\n-and writes to cache stores are asynchronous. When a client application\n-updates a cache entry, {brandname} adds the update to a modification queue and\n-then modifies the cache store in a different thread than the client thread.\n-\n-You can configure the number of threads that consume the modification queue and\n-apply updates to the underlying cache store. The modification queue fills up if\n-there are not enough threads to handle the updates or if the underlying cache\n-store becomes unavailable. When this occurs, {brandname} uses Write-Through\n-mode until the modification queue can accept new entries.\n+Write-Behind is a cache writing mode where writes to memory are synchronous\n+and writes to cache stores are asynchronous. When client applications\n+update entries, {brandname} modifies cache stores in different threads to the\n+client threads.\n+\n+When clients send write requests, {brandname} adds those operations to a\n+modification queue until each previous write operation completes. If the \n+modification queue becomes full, subsequent write operations block the calling\n+threads.", "originalCommit": "ffebc45b429dde2e8fe56c45b7e7341079d60a9a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3eeee4c3281f183c241defd98e611bd13090f025", "url": "https://github.com/infinispan/infinispan/commit/3eeee4c3281f183c241defd98e611bd13090f025", "message": "ISPN-11925 updating docs for non-blocking", "committedDate": "2020-06-02T11:27:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA3OTU3Mw==", "url": "https://github.com/infinispan/infinispan/pull/8404#discussion_r434079573", "bodyText": "It doesn't really align anymore since our SPI is non blocking and theirs is blocking. However we will always have an adapter that bridges that by using the blocking thread pool.", "author": "wburns", "createdAt": "2020-06-02T18:12:51Z", "path": "documentation/src/main/asciidoc/topics/con_persistence_spi.adoc", "diffHunk": "@@ -1,12 +1,14 @@\n-[id='persistence_spi']\n-:context: spi\n-= {brandname} Persistence SPIs\n-{brandname} Service Provider Interfaces (SPI) enable read and write operations\n-to external storage and provide the following features:\n+[id='persistent_spi']\n+= {brandname} Persistence SPI\n+The {brandname} Service Provider Interface (SPI) enables read and write\n+operations to external storage through the `NonBlockingStore` interface and has\n+the following features:\n+\n+Non-Blocking::\n \n Portability across JCache-compliant vendors::\n-The {brandname} `CacheWriter` and `CacheLoader` interfaces align with the\n-`JSR-107` JCache specification.\n+The {brandname} `NonBlockingStore` interface aligns with the `JSR-107` JCache", "originalCommit": "3eeee4c3281f183c241defd98e611bd13090f025", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0ODE3Ng==", "url": "https://github.com/infinispan/infinispan/pull/8404#discussion_r434448176", "bodyText": "@wburns I wasn't sure about this one. Should we just remove it or better to say something like:\n\"Infinispan maintains compatibility between the NonBlockingStore interface and the JCache specification by using an adapter for handling blocking code.\"", "author": "oraNod", "createdAt": "2020-06-03T09:53:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA3OTU3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMzNDI5Ng==", "url": "https://github.com/infinispan/infinispan/pull/8404#discussion_r435334296", "bodyText": "Sure.", "author": "wburns", "createdAt": "2020-06-04T15:10:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA3OTU3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA4Nzc5Mw==", "url": "https://github.com/infinispan/infinispan/pull/8404#discussion_r434087793", "bodyText": "We don't use different threads. That is up to the store implementation if it needs to use another thread.", "author": "wburns", "createdAt": "2020-06-02T18:22:03Z", "path": "documentation/src/main/asciidoc/topics/con_write_behind.adoc", "diffHunk": "@@ -1,15 +1,14 @@\n [id='write_behind']\n = Write-Behind\n-Write-Behind is an cache writing mode where writes to memory are synchronous\n-and writes to cache stores are asynchronous. When a client application\n-updates a cache entry, {brandname} adds the update to a modification queue and\n-then modifies the cache store in a different thread than the client thread.\n-\n-You can configure the number of threads that consume the modification queue and\n-apply updates to the underlying cache store. The modification queue fills up if\n-there are not enough threads to handle the updates or if the underlying cache\n-store becomes unavailable. When this occurs, {brandname} uses Write-Through\n-mode until the modification queue can accept new entries.\n+Write-Behind is a cache writing mode where writes to memory are synchronous\n+and writes to cache stores are asynchronous. When client applications\n+update entries, {brandname} modifies cache stores in different threads to the", "originalCommit": "3eeee4c3281f183c241defd98e611bd13090f025", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEwMjE2Nw==", "url": "https://github.com/infinispan/infinispan/pull/8404#discussion_r434102167", "bodyText": "We will never block the calling thread, that is the new advantage of the SPI is it allows you to do to this and must. The way write behind works is there is a queue of modifications (which can be empty) and there may be a pending batch of operations being currently applied. The way it works is a write operation is added to the queue and if there is no pending batch it is submitted to be processed. The caller is never blocked during this and the operation completes immediately. If the pending batch is still running, the queue may fill up in the interim, when it does fill additional write operations are also enqueued but we do not allow the operation to complete immediately. Instead it will complete when the pending batch completes. We do this in a non blocking way, so the invoking thread is never blocked though.", "author": "wburns", "createdAt": "2020-06-02T18:46:29Z", "path": "documentation/src/main/asciidoc/topics/con_write_behind.adoc", "diffHunk": "@@ -1,15 +1,14 @@\n [id='write_behind']\n = Write-Behind\n-Write-Behind is an cache writing mode where writes to memory are synchronous\n-and writes to cache stores are asynchronous. When a client application\n-updates a cache entry, {brandname} adds the update to a modification queue and\n-then modifies the cache store in a different thread than the client thread.\n-\n-You can configure the number of threads that consume the modification queue and\n-apply updates to the underlying cache store. The modification queue fills up if\n-there are not enough threads to handle the updates or if the underlying cache\n-store becomes unavailable. When this occurs, {brandname} uses Write-Through\n-mode until the modification queue can accept new entries.\n+Write-Behind is a cache writing mode where writes to memory are synchronous\n+and writes to cache stores are asynchronous. When client applications\n+update entries, {brandname} modifies cache stores in different threads to the\n+client threads.\n+\n+When clients send write requests, {brandname} adds those operations to a\n+modification queue until each previous write operation completes. If the \n+modification queue becomes full, subsequent write operations block the calling", "originalCommit": "3eeee4c3281f183c241defd98e611bd13090f025", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2NjY0Nw==", "url": "https://github.com/infinispan/infinispan/pull/8404#discussion_r434466647", "bodyText": "@wburns argh. I thought I left a question on this one because I thought the same about the non-blocking SPI and probably got mixed up in a chat. I guess I didn't properly save the question in the review. I blame github. anyway, thx for the detailed explanation. hopefully it's better now.", "author": "oraNod", "createdAt": "2020-06-03T10:26:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEwMjE2Nw=="}], "type": "inlineReview"}, {"oid": "08c862c83d3c3bf2627a57461ff2eefbe308a702", "url": "https://github.com/infinispan/infinispan/commit/08c862c83d3c3bf2627a57461ff2eefbe308a702", "message": "ISPN-11925 updating docs for non-blocking", "committedDate": "2020-06-03T10:27:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTM0NjAwMA==", "url": "https://github.com/infinispan/infinispan/pull/8404#discussion_r435346000", "bodyText": "This paragraph still needs work I think.\nMaybe something along the lines that if the queue grows to be larger than the modification queue size any additional writes will be enqueued but the operation will not complete until part of the queue has been processed.\nThe problematic part is trying to differentiate between the write operation completing and the fact that that the store will not block the calling thread. For example Cache.putAsync will return immediately and the returned Stage will just complete later than normal, however a Cache.put will actually still block the invoking thread.", "author": "wburns", "createdAt": "2020-06-04T15:26:06Z", "path": "documentation/src/main/asciidoc/topics/con_write_behind.adoc", "diffHunk": "@@ -1,15 +1,15 @@\n [id='write_behind']\n = Write-Behind\n-Write-Behind is an cache writing mode where writes to memory are synchronous\n-and writes to cache stores are asynchronous. When a client application\n-updates a cache entry, {brandname} adds the update to a modification queue and\n-then modifies the cache store in a different thread than the client thread.\n-\n-You can configure the number of threads that consume the modification queue and\n-apply updates to the underlying cache store. The modification queue fills up if\n-there are not enough threads to handle the updates or if the underlying cache\n-store becomes unavailable. When this occurs, {brandname} uses Write-Through\n-mode until the modification queue can accept new entries.\n+Write-Behind is a cache writing mode where writes to memory are synchronous\n+and writes to cache stores are asynchronous.\n+\n+When clients send write requests, {brandname} adds those operations to a\n+modification queue. {brandname} processes operations as they join the queue so\n+that the calling thread is not blocked and the operation completes immediately.\n+\n+In the case where there is a batch of write operations (bulk writes),", "originalCommit": "08c862c83d3c3bf2627a57461ff2eefbe308a702", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b9f84dc0549860f6ccb40ec8e4330e1b931057a1", "url": "https://github.com/infinispan/infinispan/commit/b9f84dc0549860f6ccb40ec8e4330e1b931057a1", "message": "ISPN-11925 updating docs for non-blocking", "committedDate": "2020-06-04T17:10:38Z", "type": "forcePushed"}, {"oid": "41352fa43f089de8a5f6d7c39a570703d23ccf19", "url": "https://github.com/infinispan/infinispan/commit/41352fa43f089de8a5f6d7c39a570703d23ccf19", "message": "ISPN-11925 updating docs for non-blocking", "committedDate": "2020-06-08T11:31:49Z", "type": "commit"}, {"oid": "41352fa43f089de8a5f6d7c39a570703d23ccf19", "url": "https://github.com/infinispan/infinispan/commit/41352fa43f089de8a5f6d7c39a570703d23ccf19", "message": "ISPN-11925 updating docs for non-blocking", "committedDate": "2020-06-08T11:31:49Z", "type": "forcePushed"}]}