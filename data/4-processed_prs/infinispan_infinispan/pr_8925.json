{"pr_number": 8925, "pr_title": "ISPN-12566 Simplify CLI command logic", "pr_createdAt": "2020-12-10T08:59:21Z", "pr_url": "https://github.com/infinispan/infinispan/pull/8925", "timeline": [{"oid": "d35bb71f3e1fbc02b052714fc0a3f9a48834b9f7", "url": "https://github.com/infinispan/infinispan/commit/d35bb71f3e1fbc02b052714fc0a3f9a48834b9f7", "message": "ISPN-12566 Simplify CLI command logic", "committedDate": "2020-12-10T09:08:51Z", "type": "forcePushed"}, {"oid": "3bf7d2613702f5440abd9d9835f4f2f9dfcdadf0", "url": "https://github.com/infinispan/infinispan/commit/3bf7d2613702f5440abd9d9835f4f2f9dfcdadf0", "message": "ISPN-12566 Simplify CLI command logic", "committedDate": "2020-12-10T12:26:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIxMTA5OQ==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540211099", "bodyText": "Just 2 notes before starting to review this:\n\n\nWouldn't be better/simpler just to add an abstract method to CliCommand? like abstract CompletionStage<RestResponse> invokeInServer(RestClient client, Resource resource);\n\n\nAlso, I would remove the execute overload and use Resource as parameter since there is no difference between execute implementations.", "author": "pruivo", "createdAt": "2020-12-10T14:27:10Z", "path": "cli/src/main/java/org/infinispan/cli/Context.java", "diffHunk": "@@ -72,12 +78,20 @@\n     */\n    void disconnect();\n \n-   CommandResult execute(Shell shell, List<CommandInputLine> commands);\n+   CommandResult execute(Shell shell, Function<RestClient, CompletionStage<RestResponse>> op, Connection.ResponseMode responseMode);\n+\n+   CommandResult execute(Shell shell, BiFunction<RestClient, Resource, CompletionStage<RestResponse>> op, Connection.ResponseMode responseMode);", "originalCommit": "3bf7d2613702f5440abd9d9835f4f2f9dfcdadf0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk2MTc1Mw==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540961753", "bodyText": "I've done that. I've moved the commands around a bit too", "author": "tristantarrant", "createdAt": "2020-12-11T13:52:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIxMTA5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIyODg5MA==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540228890", "bodyText": "the container can be found in Resource class. It would be clear to get it from there (you can create method in the interface to return the container name) instead of some alternative path.\nofftopic:\n\nI see you removed the public static final String from other commands. Are you planning to remove from all commands?\ncan help \"option\" be in 'CliCommand`?\nALL_RESOURCE_TYPES can be removed.", "author": "pruivo", "createdAt": "2020-12-10T14:49:32Z", "path": "cli/src/main/java/org/infinispan/cli/commands/Backup.java", "diffHunk": "@@ -76,11 +78,9 @@ public CommandResult exec(ContextAwareCommandInvocation invocation) {\n \n       @Override\n       protected CommandResult exec(ContextAwareCommandInvocation invocation) {\n-         return invocation.execute(\n-               new CommandInputLine(Backup.CMD)\n-                     .arg(TYPE, CMD)\n-                     .arg(NAME, name)\n-         );\n+         String container = invocation.getContext().getConnection().getActiveContainer().getName();\n+         invocation.printf(\"Deleting backup %s%n\", name);\n+         return invocation.call(c -> c.cacheManager(container).deleteBackup(this.name));", "originalCommit": "3bf7d2613702f5440abd9d9835f4f2f9dfcdadf0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc1NjIzMA==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540756230", "bodyText": "Are you planning to remove from all commands?\nYes\n\n\ncan help \"option\" be in 'CliCommand`?\nI wish. It was done to workaround a problem with GraalVM's native-image which didn't recognize parent fields.", "author": "tristantarrant", "createdAt": "2020-12-11T07:58:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIyODg5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDIyOTAzNQ==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540229035", "bodyText": "unused", "author": "pruivo", "createdAt": "2020-12-10T14:49:41Z", "path": "cli/src/main/java/org/infinispan/cli/commands/Backup.java", "diffHunk": "@@ -155,19 +154,34 @@ protected void additionalArgs(CommandInputLine cmd) {\n       @Option(shortName = 'u', description = \"Indicates that the path is a local file which must be uploaded to the server\", hasValue = false, name = UPLOAD_BACKUP)\n       boolean upload;\n \n-      public Restore() {\n-         super(CMD);\n-      }\n-\n       @Override\n-      protected void additionalArgs(CommandInputLine cmd) {\n-         if (!upload && !((FileResource) path).getFile().isAbsolute())\n-            throw Messages.MSG.backupAbsolutePathRequired();\n+      protected CommandResult exec(ContextAwareCommandInvocation invocation) throws CommandException {\n+         Map<String, List<String>> resources = createResourceMap();\n+         // If the restore name has not been specified generate one based upon the Infinispan version and timestamp\n+         String restoreName = name != null ? name : String.format(\"%s-%tY%2$tm%2$td%2$tH%2$tM%2$tS\", Version.getBrandName(), LocalDateTime.now());\n+         String container = invocation.getContext().getConnection().getActiveContainer().getName();\n+         RestResponse response;", "originalCommit": "3bf7d2613702f5440abd9d9835f4f2f9dfcdadf0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI0MjIyMw==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540242223", "bodyText": "unused", "author": "pruivo", "createdAt": "2020-12-10T15:05:29Z", "path": "cli/src/main/java/org/infinispan/cli/commands/CliCommand.java", "diffHunk": "@@ -13,13 +13,10 @@\n  **/\n public abstract class CliCommand implements Command<ContextAwareCommandInvocation> {\n    public static final String CACHE = \"cache\";", "originalCommit": "3bf7d2613702f5440abd9d9835f4f2f9dfcdadf0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI1MDMzMQ==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540250331", "bodyText": "I've seen this pattern 3 times (counter, container and cache command). You can create a method in Context to do the resource change:\n   public void changeResource(Class<? extends Resource> resourceClass, String childType, String childName) throws IOException {\n      connection.setActiveResource(connection.getActiveResource().findAncestor(resourceClass).getChild(childType, childName));\n      refreshPrompt();\n   }\n\nand the command would be invocation.getContext().changeResource(ContainerResource.class, CountersResource.NAME, name);", "author": "pruivo", "createdAt": "2020-12-10T15:15:17Z", "path": "cli/src/main/java/org/infinispan/cli/commands/Counter.java", "diffHunk": "@@ -32,9 +36,14 @@ public boolean isHelp() {\n    }\n \n    @Override\n-   public CommandResult exec(ContextAwareCommandInvocation invocation) {\n-      CommandInputLine cmd = new CommandInputLine(CMD)\n-            .arg(NAME, name);\n-      return invocation.execute(cmd);\n+   public CommandResult exec(ContextAwareCommandInvocation invocation) throws CommandException {\n+      Connection connection = invocation.getContext().getConnection();\n+      try {\n+         connection.setActiveResource(connection.getActiveResource().findAncestor(ContainerResource.class).getChild(CountersResource.NAME, name));", "originalCommit": "3bf7d2613702f5440abd9d9835f4f2f9dfcdadf0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI3NTQ3OQ==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540275479", "bodyText": "unused constants:\n   public static final String ENCODING = \"encoding\";\n   public static final String TTL = \"ttl\";\n   public static final String MAX_IDLE = \"max-idle\";\n   public static final String IF_ABSENT = \"if-absent\";", "author": "pruivo", "createdAt": "2020-12-10T15:45:17Z", "path": "cli/src/main/java/org/infinispan/cli/commands/Put.java", "diffHunk": "@@ -65,15 +70,15 @@ public CommandResult exec(ContextAwareCommandInvocation invocation) {\n       } else if ((file == null) && (args.size() != 2)) {\n          throw Messages.MSG.illegalCommandArguments();\n       }\n-      CommandInputLine cmd = new CommandInputLine(CMD)\n-            .arg(KEY, args.get(0))\n-            .optionalArg(VALUE, args.size() > 1 ? args.get(1) : null)\n-            .option(FILE, file != null ? file.getAbsolutePath() : null)\n-            .option(ENCODING, encoding)\n-            .option(CACHE, cache)\n-            .option(TTL, ttl)\n-            .option(MAX_IDLE, maxIdle)\n-            .option(IF_ABSENT, ifAbsent);\n-      return invocation.execute(cmd);\n+      return invocation.call((c, r) -> {", "originalCommit": "3bf7d2613702f5440abd9d9835f4f2f9dfcdadf0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI3Njk2OQ==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540276969", "bodyText": "offtopic:\nwouldn't be better to have an argument for key and value like below?\n   @Arguments(required = true)\n   String key;\n   \n   @Arguments\n   String value;", "author": "pruivo", "createdAt": "2020-12-10T15:47:02Z", "path": "cli/src/main/java/org/infinispan/cli/commands/Put.java", "diffHunk": "@@ -65,15 +70,15 @@ public CommandResult exec(ContextAwareCommandInvocation invocation) {\n       } else if ((file == null) && (args.size() != 2)) {", "originalCommit": "3bf7d2613702f5440abd9d9835f4f2f9dfcdadf0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI4NjY2Mw==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540286663", "bodyText": "nit.\nMaybe add a method to Resource to compute the cache name?\npublic String getCacheName(String name) {\n      return name == null ? findAncestor(CacheResource.class).getName() : name;\n   }", "author": "pruivo", "createdAt": "2020-12-10T15:59:02Z", "path": "cli/src/main/java/org/infinispan/cli/commands/Remove.java", "diffHunk": "@@ -34,7 +35,6 @@ public boolean isHelp() {\n \n    @Override\n    public CommandResult exec(ContextAwareCommandInvocation invocation) {\n-      CommandInputLine cmd = new CommandInputLine(CMD).arg(\"key\", key).optionalArg(\"cache\", cache);\n-      return invocation.execute(cmd);\n+      return invocation.call((c, r) -> c.cache(cache != null ? cache : r.findAncestor(CacheResource.class).getName()).remove(key));", "originalCommit": "3bf7d2613702f5440abd9d9835f4f2f9dfcdadf0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI4OTIxMg==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540289212", "bodyText": "or some static method in CliCommand. we can have a method for Counter as well.\n   public static RestCacheClient getCache(RestClient client, Resource resource, String cacheName) {\n      return client.cache(cacheName == null ? resouce.findAncestor(CacheResource.class).getName() : cacheName);\n   }", "author": "pruivo", "createdAt": "2020-12-10T16:02:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI4NjY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk2MTQ0Mw==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540961443", "bodyText": "Done", "author": "tristantarrant", "createdAt": "2020-12-11T13:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI4NjY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI5MTk5OQ==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540291999", "bodyText": "same as put, wouldn't be better to have an argument for the schema name and another for the content?\nis there a case where a file isn't used? I doubt people will write the schema on hand inside the cli prompt.", "author": "pruivo", "createdAt": "2020-12-10T16:05:47Z", "path": "cli/src/main/java/org/infinispan/cli/commands/Schema.java", "diffHunk": "@@ -43,10 +45,6 @@ public CommandResult exec(ContextAwareCommandInvocation invocation) {\n       } else if ((upload == null) && (args.size() != 2)) {\n          throw Messages.MSG.illegalCommandArguments();\n       }\n-      CommandInputLine cmd = new CommandInputLine(Schema.CMD)\n-            .arg(KEY, args.get(0))\n-            .optionalArg(VALUE, args.size() > 1 ? args.get(1) : null)\n-            .optionalArg(FILE, upload != null ? upload.getAbsolutePath() : null);\n-      return invocation.execute(cmd);\n+      return invocation.call(c -> upload == null ? c.schemas().put(args.get(0), args.get(1)) : c.schemas().put(args.get(0), RestEntity.create(MediaType.TEXT_PLAIN, new File(upload.getAbsolutePath()))));", "originalCommit": "3bf7d2613702f5440abd9d9835f4f2f9dfcdadf0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk0OTkzOA==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540949938", "bodyText": "This PR is not about changing the commands :)", "author": "tristantarrant", "createdAt": "2020-12-11T13:34:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI5MTk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI5NDY0Ng==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540294646", "bodyText": "it needs a null check (and include the description from Wolf's PR so I can close it eh eh: #8911)\n[pedro-desktop-21448@cluster//containers]> shutdown server\nnull", "author": "pruivo", "createdAt": "2020-12-10T16:09:12Z", "path": "cli/src/main/java/org/infinispan/cli/commands/Shutdown.java", "diffHunk": "@@ -55,19 +52,12 @@ public boolean isHelp() {\n \n       @Override\n       public CommandResult exec(ContextAwareCommandInvocation invocation) {\n-         if (help) {\n-            invocation.println(invocation.getHelpInfo());\n-         }\n-         CommandInputLine cmd = new CommandInputLine(Shutdown.CMD)\n-               .arg(TYPE, Shutdown.Server.CMD)\n-               .arg(SERVERS, servers);\n-         return invocation.execute(cmd);\n+         return invocation.call(c -> servers.isEmpty() ? c.server().stop() : c.cluster().stop(servers));", "originalCommit": "3bf7d2613702f5440abd9d9835f4f2f9dfcdadf0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk1MTM3Ng==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540951376", "bodyText": "Done", "author": "tristantarrant", "createdAt": "2020-12-11T13:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI5NDY0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI5NzY5MQ==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540297691", "bodyText": "in both subcommands, the taskName should be marked as required.", "author": "pruivo", "createdAt": "2020-12-10T16:13:07Z", "path": "cli/src/main/java/org/infinispan/cli/commands/Task.java", "diffHunk": "@@ -41,11 +42,8 @@ public CommandResult exec(ContextAwareCommandInvocation invocation) {\n       return CommandResult.FAILURE;\n    }\n \n-   @CommandDefinition(name = Task.Exec.CMD, description = \"Executes a server-side task\", activator = ConnectionActivator.class)\n+   @CommandDefinition(name = \"exec\", description = \"Executes a server-side task\", activator = ConnectionActivator.class)\n    public static class Exec extends CliCommand {\n-      public static final String CMD = \"exec\";\n-      public static final String PARAMETERS = \"parameters\";\n-\n       @Argument(completer = TaskCompleter.class)", "originalCommit": "3bf7d2613702f5440abd9d9835f4f2f9dfcdadf0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMwMTk3Mw==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540301973", "bodyText": "with response code 204, is is null and it will throw an NPE. You probably want better handling :)", "author": "pruivo", "createdAt": "2020-12-10T16:18:08Z", "path": "cli/src/main/java/org/infinispan/cli/connection/rest/RestConnection.java", "diffHunk": "@@ -216,499 +167,72 @@ private RestResponse handleResponseStatus(RestResponse response) throws IOExcept\n       }\n    }\n \n-   private Resource pathToResource(String path) throws IOException {\n-      if (Resource.THIS.equals(path)) {\n-         return activeResource;\n-      } else if (Resource.PARENT.equals(path)) {\n-         return activeResource.getParent();\n-      } else {\n-         String[] parts = path.split(\"/\");\n-         if (parts.length == 0) {\n-            return activeResource.findAncestor(RootResource.class);\n-         } else {\n-            Resource resource = activeResource;\n-            for (String part : parts) {\n-               if (part.isEmpty()) {\n-                  resource = resource.findAncestor(RootResource.class);\n-               } else {\n-                  resource = resource.getChild(part);\n-               }\n-            }\n-            return resource;\n-         }\n-      }\n+   @Override\n+   public MediaType getEncoding() {\n+      return encoding;\n+   }\n+\n+   @Override\n+   public void setEncoding(MediaType encoding) {\n+      this.encoding = encoding;\n    }\n \n    @Override\n-   public String execute(List<CommandInputLine> commands) throws IOException {\n+   public String execute(Function<RestClient, CompletionStage<RestResponse>> op, ResponseMode responseMode) throws IOException {\n+      RestResponse r = fetch(op.apply(client));\n+      return executeInternal(responseMode, r);\n+   }\n+\n+   @Override\n+   public String execute(BiFunction<RestClient, Resource, CompletionStage<RestResponse>> op, ResponseMode responseMode) throws IOException {\n+      RestResponse r = fetch(op.apply(client, activeResource));\n+      return executeInternal(responseMode, r);\n+   }\n+\n+   private String executeInternal(ResponseMode responseMode, RestResponse r) throws IOException {\n       StringBuilder sb = new StringBuilder();\n-      ResponseMode responseMode = ResponseMode.BODY;\n-      for (CommandInputLine command : commands) {\n-         CompletionStage<RestResponse> response = null;\n-         switch (command.name()) {\n-            case Add.CMD: {\n-               RestCounterClient counter;\n-               if (command.hasArg(Add.COUNTER)) {\n-                  counter = client.counter(command.arg(Add.COUNTER));\n-               } else {\n-                  counter = client.counter(activeResource.findAncestor(CounterResource.class).getName());\n-               }\n-               response = counter.add(command.longOption(Add.DELTA));\n-               if (command.boolOption(CliCommand.QUIET)) {\n-                  responseMode = ResponseMode.QUIET;\n-               }\n-               break;\n-            }\n-            case Backup.CMD: {\n-               String container = getActiveContainer().getName();\n-               RestCacheManagerClient manager = this.client.cacheManager(container);\n-               responseMode = ResponseMode.BODY;\n-               String backupName;\n-               switch (command.arg(CliCommand.TYPE)) {\n-                  case Backup.Create.CMD:\n-                     backupName = command.optionOrDefault(Backup.NAME, () -> {\n-                        // If the backup name has not been specified generate one based upon the Infinispan version and timestamp\n-                        LocalDateTime now = LocalDateTime.now();\n-                        return String.format(\"%s-%tY%2$tm%2$td%2$tH%2$tM%2$tS%n\", Version.getBrandName(), now);\n-                     });\n-\n-                     sb.append(\"Creating backup '\").append(backupName).append(\"'\");\n-                     String directory = command.option(Backup.Create.DIR);\n-                     response = manager.createBackup(backupName, directory, Backup.createResourceMap(command));\n-                     break;\n-                  case Backup.Delete.CMD:\n-                     backupName = command.arg(Backup.NAME);\n-                     sb.append(\"Deleting backup '\").append(backupName).append(\"'\");\n-                     response = manager.deleteBackup(backupName);\n-                     break;\n-                  case Backup.Get.CMD:\n-                     boolean skipBody = command.boolOption(Backup.Get.NO_CONTENT);\n-                     responseMode = skipBody ? ResponseMode.QUIET : ResponseMode.FILE;\n-                     backupName = command.arg(Backup.NAME);\n-                     sb.append(\"Downloading backup '\").append(backupName).append(\"'\\n\");\n-                     // Poll the backup's availability every 500 milliseconds with a maximum of 100 attempts\n-                     response = Flowable.timer(500, TimeUnit.MILLISECONDS, Schedulers.trampoline())\n-                           .repeat(100)\n-                           .flatMapSingle(Void -> Single.fromCompletionStage(manager.getBackup(backupName, skipBody)))\n-                           .takeUntil(rsp -> rsp.getStatus() != 202)\n-                           .lastOrErrorStage();\n-                     break;\n-                  case Backup.ListBackups.CMD:\n-                     sb.append(String.join(\"\\n\", getBackupNames(container)));\n-                     break;\n-                  case Backup.Restore.CMD:\n-                     Map<String, List<String>> resources = Backup.createResourceMap(command);\n-                     Boolean upload = command.argAs(Backup.Restore.UPLOAD_BACKUP);\n-                     FileResource resource = command.argAs(Backup.Restore.PATH);\n-                     String restoreName = command.optionOrDefault(Backup.NAME, () -> {\n-                        // If the restore name has not been specified generate one based upon the Infinispan version and timestamp\n-                        LocalDateTime now = LocalDateTime.now();\n-                        return String.format(\"%s-%tY%2$tm%2$td%2$tH%2$tM%2$tS%n\", Version.getBrandName(), now);\n-                     });\n-                     if (upload != null && upload) {\n-                        File file = resource.getFile();\n-                        sb.append(\"Uploading backup '\").append(file.getName()).append(\"' and restoring\");\n-                        response = manager.restore(restoreName, file, resources);\n-                     } else {\n-                        String path = resource.getAbsolutePath();\n-                        sb.append(\"Restoring from backup '\").append(path).append(\"'\");\n-                        response = manager.restore(restoreName, path, resources);\n-                     }\n-\n-                     response = response.thenCompose(rsp -> {\n-                              if (rsp.getStatus() != 202) {\n-                                 return CompletableFuture.completedFuture(rsp);\n-                              }\n-                              // Poll the restore progress every 500 milliseconds with a maximum of 100 attempts\n-                              return Flowable.timer(500, TimeUnit.MILLISECONDS, Schedulers.trampoline())\n-                                    .repeat(100)\n-                                    .flatMapSingle(Void -> Single.fromCompletionStage(manager.getRestore(restoreName)))\n-                                    .takeUntil(r -> r.getStatus() != 202)\n-                                    .lastOrErrorStage();\n-                           }\n-                     );\n-                     break;\n-               }\n-               break;\n-            }\n-            case Cache.CMD:\n-               activeResource = activeResource\n-                     .findAncestor(ContainerResource.class)\n-                     .getChild(CachesResource.NAME, command.arg(CliCommand.NAME));\n-               break;\n-            case Cas.CMD: {\n-               RestCounterClient counter;\n-               if (command.hasArg(Cas.COUNTER)) {\n-                  counter = client.counter(command.arg(Cas.COUNTER));\n-               } else {\n-                  counter = client.counter(activeResource.findAncestor(CounterResource.class).getName());\n-               }\n-               if (command.boolOption(CliCommand.QUIET)) {\n-                  response = counter.compareAndSet(command.longOption(Cas.EXPECT), command.longOption(Cas.VALUE));\n-               } else {\n-                  response = counter.compareAndSwap(command.longOption(Cas.EXPECT), command.longOption(Cas.VALUE));\n-               }\n-               break;\n-            }\n-            case Cd.CMD:\n-               String path = command.arg(CliCommand.PATH);\n-               Resource rPath = pathToResource(path);\n-               if (!(rPath instanceof CacheKeyResource)) {\n-                  activeResource = rPath;\n-               }\n-               break;\n-            case ClearCache.CMD: {\n-               if (command.hasArg(CliCommand.NAME)) {\n-                  activeResource\n-                        .findAncestor(ContainerResource.class)\n-                        .getChild(CachesResource.NAME)\n-                        .getChild(command.arg(CliCommand.NAME));\n-                  response = client.cache(command.arg(CliCommand.NAME)).clear();\n-               } else {\n-                  CacheResource resource = activeResource.findAncestor(CacheResource.class);\n-                  if (resource != null) {\n-                     response = client.cache(resource.getName()).clear();\n-                  }\n-               }\n-               break;\n-            }\n-            case Container.CMD: {\n-               activeResource = activeResource\n-                     .findAncestor(RootResource.class)\n-                     .getChild(ContainersResource.NAME, command.arg(CliCommand.NAME));\n-               break;\n-            }\n-            case Counter.CMD: {\n-               activeResource = activeResource\n-                     .findAncestor(ContainerResource.class)\n-                     .getChild(CountersResource.NAME, command.arg(CliCommand.NAME));\n-               break;\n-            }\n-            case Create.CMD: {\n-               switch (command.arg(Create.TYPE)) {\n-                  case Create.Cache.CMD: {\n-                     RestCacheClient cache = client.cache(command.arg(Create.NAME));\n-                     boolean vltl = command.boolOption(Create.Cache.VOLATILE);\n-                     AdminFlag flags[] = vltl ? new AdminFlag[]{AdminFlag.VOLATILE} : new AdminFlag[]{};\n-                     if (command.hasArg(Create.Cache.TEMPLATE)) {\n-                        response = cache.createWithTemplate(command.arg(Create.Cache.TEMPLATE), flags);\n-                     } else {\n-                        RestEntity entity = entityFromFile(new File(command.arg(Create.Cache.FILE)));\n-                        response = cache.createWithConfiguration(entity, flags);\n-                     }\n-                     break;\n-                  }\n-                  case Create.Counter.CMD: {\n-                     Json counterBody = Json.object()\n-                           .set(Create.Counter.INITIAL_VALUE, command.longOption(Create.Counter.INITIAL_VALUE))\n-                           .set(Create.Counter.CONCURRENCY_LEVEL, command.intOption(Create.Counter.CONCURRENCY_LEVEL))\n-                           .set(Create.Counter.STORAGE, command.option(Create.Counter.STORAGE));\n-                     if (command.hasOption(Create.Counter.UPPER_BOUND)) {\n-                        counterBody.set(Create.Counter.UPPER_BOUND, command.longOption(Create.Counter.UPPER_BOUND));\n-                     }\n-                     if (command.hasOption(Create.Counter.LOWER_BOUND)) {\n-                        counterBody.set(Create.Counter.LOWER_BOUND, command.longOption(Create.Counter.LOWER_BOUND));\n-                     }\n-                     Json counter = Json.object().set(command.option(Create.Counter.COUNTER_TYPE) + \"-counter\", counterBody);\n-                     response = client.counter(command.arg(CliCommand.NAME)).create(RestEntity.create(MediaType.APPLICATION_JSON, counter.toString()));\n-                     break;\n-                  }\n-               }\n-               break;\n-            }\n-            case Describe.CMD: {\n-               Resource resource = activeResource;\n-               if (command.hasArg(CliCommand.NAME)) {\n-                  resource = pathToResource(command.arg(CliCommand.NAME));\n-               }\n-               return resource.describe();\n-            }\n-            case Drop.CMD: {\n-               switch (command.arg(CliCommand.TYPE)) {\n-                  case Drop.Cache.CMD:\n-                     response = client.cache(command.arg(CliCommand.NAME)).delete();\n-                     break;\n-                  case Drop.Counter.CMD:\n-                     response = client.counter(command.arg(CliCommand.NAME)).delete();\n-                     break;\n-               }\n-               break;\n-            }\n-            case Encoding.CMD: {\n-               if (command.hasArg(CliCommand.TYPE)) {\n-                  encoding = MediaType.fromString(command.arg(CliCommand.TYPE));\n-               } else {\n-                  sb.append(encoding);\n-               }\n-               break;\n-            }\n-            case Get.CMD: {\n-               RestCacheClient cache = getRestCacheClient(command.arg(CliCommand.CACHE));\n-               response = cache.get(command.arg(CliCommand.KEY));\n-               break;\n-            }\n-            case Ls.CMD: {\n-               refreshServerInfo();\n-               Resource resource = activeResource;\n-               if (command.hasArg(CliCommand.PATH)) {\n-                  resource = pathToResource(command.arg(CliCommand.PATH));\n-               }\n-               StringJoiner j = new StringJoiner(\"\\n\");\n-               for (String item : resource.getChildrenNames()) {\n-                  j.add(item);\n-               }\n-               return j.toString();\n+      switch (responseMode) {\n+         case BODY:\n+            String body = parseBody(r, String.class);\n+            if (body != null) {\n+               sb.append(body);\n             }\n-            case Query.CMD: {\n-               RestCacheClient cache = getRestCacheClient(command.arg(CliCommand.CACHE));\n-               response = cache.query(\n-                     command.arg(Query.QUERY),\n-                     command.intOption(Query.MAX_RESULTS),\n-                     command.intOption(Query.OFFSET),\n-                     RestQueryMode.valueOf(command.option(Query.QUERY_MODE))\n-               );\n-               break;\n-            }\n-            case Put.CMD: {\n-               RestCacheClient cache = getRestCacheClient(command.option(CliCommand.CACHE));\n-               RestEntity value;\n-               MediaType putEncoding = command.hasOption(Put.ENCODING) ? MediaType.fromString(command.option(Put.ENCODING)) : encoding;\n-               if (command.hasOption(CliCommand.FILE)) {\n-                  value = RestEntity.create(putEncoding, new File(command.option(CliCommand.FILE)));\n-               } else {\n-                  value = RestEntity.create(putEncoding, command.arg(CliCommand.VALUE));\n-               }\n-               if (command.boolOption(Put.IF_ABSENT)) {\n-                  response = cache.post(command.arg(CliCommand.KEY), value, command.longOption(Put.TTL), command.longOption(Put.MAX_IDLE));\n-               } else {\n-                  response = cache.put(command.arg(CliCommand.KEY), value, command.longOption(Put.TTL), command.longOption(Put.MAX_IDLE));\n-               }\n-               break;\n-            }\n-            case Remove.CMD: {\n-               RestCacheClient cache = getRestCacheClient(command.arg(CliCommand.CACHE));\n-               response = cache.remove(command.arg(CliCommand.KEY));\n-               break;\n-            }\n-            case Reset.CMD: {\n-               RestCounterClient counter;\n-               if (command.hasArg(Reset.COUNTER)) {\n-                  counter = client.counter(command.arg(Reset.COUNTER));\n-               } else {\n-                  counter = client.counter(activeResource.findAncestor(CounterResource.class).getName());\n-               }\n-               response = counter.reset();\n-               break;\n-            }\n-            case Schema.CMD: {\n-               RestCacheClient cache = client.cache(PROTOBUF_METADATA_CACHE_NAME);\n-               if (command.hasArg(CliCommand.FILE)) {\n-                  RestEntity value = RestEntity.create(MediaType.TEXT_PLAIN, new File(command.arg(CliCommand.FILE)));\n-                  response = cache.put(command.arg(CliCommand.KEY), value);\n-               } else {\n-                  response = cache.get(command.arg(CliCommand.KEY));\n-               }\n-               break;\n-            }\n-            case Shutdown.CMD: {\n-               switch (command.arg(Shutdown.TYPE)) {\n-                  case Shutdown.Server.CMD: {\n-                     if (command.hasArg(Shutdown.SERVERS)) {\n-                        response = client.cluster().stop(command.argAs(Shutdown.SERVERS));\n-                     } else {\n-                        response = client.server().stop();\n-                     }\n-                     break;\n-                  }\n-                  case Shutdown.Cluster.CMD: {\n-                     response = client.cluster().stop();\n-                     break;\n-                  }\n-               }\n-               break;\n-            }\n-            case Site.CMD: {\n-               RestCacheClient cache = client.cache(command.arg(Site.CACHE));\n-               switch (command.arg(Site.OP)) {\n-                  case Site.STATUS: {\n-                     if (command.hasArg(Site.SITE_NAME)) {\n-                        response = cache.backupStatus(command.arg(Site.SITE_NAME));\n-                     } else {\n-                        response = cache.xsiteBackups();\n-                     }\n-                     break;\n-                  }\n-                  case Site.BRING_ONLINE: {\n-                     response = cache.bringSiteOnline(command.arg(Site.SITE_NAME));\n-                     break;\n-                  }\n-                  case Site.TAKE_OFFLINE: {\n-                     response = cache.takeSiteOffline(command.arg(Site.SITE_NAME));\n-                     break;\n-                  }\n-                  case Site.PUSH_SITE_STATE: {\n-                     response = cache.pushSiteState(command.arg(Site.SITE_NAME));\n-                     break;\n-                  }\n-                  case Site.CANCEL_PUSH_STATE: {\n-                     response = cache.cancelPushState(command.arg(Site.SITE_NAME));\n-                     break;\n-                  }\n-                  case Site.CANCEL_RECEIVE_STATE: {\n-                     response = cache.cancelReceiveState(command.arg(Site.SITE_NAME));\n-                     break;\n-                  }\n-                  case Site.PUSH_SITE_STATUS: {\n-                     response = cache.pushStateStatus();\n-                     break;\n-                  }\n-                  case Site.CLEAR_PUSH_STATE_STATUS: {\n-                     response = cache.clearPushStateStatus();\n-                     break;\n-                  }\n-               }\n-               break;\n-            }\n-            case Task.CMD: {\n-               switch (command.arg(Task.TYPE)) {\n-                  case Task.Exec.CMD: {\n-                     response = client.tasks().exec(command.arg(Task.Exec.NAME), command.argAs(Task.Exec.PARAMETERS));\n-                     break;\n-                  }\n-                  case Task.Upload.CMD: {\n-                     RestEntity value = RestEntity.create(MediaType.TEXT_PLAIN, new File(command.option(CliCommand.FILE)));\n-                     response = client.tasks().uploadScript(command.arg(Task.Exec.NAME), value);\n-                     break;\n-                  }\n-               }\n-               break;\n-            }\n-            case Stats.CMD: {\n-               Resource resource = activeResource;\n-               if (command.hasArg(CliCommand.NAME)) {\n-                  resource = pathToResource(command.arg(CliCommand.NAME));\n-               }\n-               if (resource instanceof CacheResource) {\n-                  response = client.cache(resource.getName()).stats();\n-               } else if (resource instanceof ContainerResource) {\n-                  response = client.cacheManager(resource.getName()).stats();\n-               } else {\n-                  String name = resource.getName();\n-                  throw MSG.invalidResource(name.isEmpty() ? \"/\" : name);\n-               }\n-               break;\n-            }\n-            case Logging.CMD: {\n-               switch (command.arg(Logging.TYPE)) {\n-                  case Logging.Loggers.CMD: {\n-                     response = client.server().logging().listLoggers();\n-                     break;\n-                  }\n-                  case Logging.Appenders.CMD: {\n-                     response = client.server().logging().listAppenders();\n-                     break;\n-                  }\n-                  case Logging.Set.CMD: {\n-                     if (command.hasArg(Logging.Set.APPENDERS)) {\n-                        List<String> appenders = command.argAs(Logging.Set.APPENDERS);\n-                        response = client.server().logging().setLogger(command.arg(Logging.NAME), command.option(Logging.Set.LEVEL), appenders.toArray(new String[0]));\n-                     } else {\n-                        response = client.server().logging().setLogger(command.arg(Logging.NAME), command.option(Logging.Set.LEVEL));\n-                     }\n-                     break;\n-                  }\n-                  case Logging.Remove.CMD: {\n-                     response = client.server().logging().removeLogger(command.arg(Logging.NAME));\n-                     break;\n-                  }\n-               }\n-               break;\n-            }\n-            case Server.CMD: {\n-               switch (command.arg(Logging.TYPE)) {\n-                  case Server.Report.CMD: {\n-                     responseMode = ResponseMode.FILE;\n-                     response = client.server().report();\n-                  }\n-                  break;\n+            break;\n+         case FILE:\n+            String contentDisposition = parseHeaders(r).get(\"Content-Disposition\").get(0);\n+            String filename = contentDisposition.split(\"filename=\")[1];\n+            Path file = workingDir.resolve(filename);\n+\n+            try (OutputStream os = Files.newOutputStream(file); InputStream is = parseBody(r, InputStream.class)) {\n+               byte[] buffer = new byte[8 * 1024];\n+               int bytesRead;\n+               while ((bytesRead = is.read(buffer)) != -1) {", "originalCommit": "3bf7d2613702f5440abd9d9835f4f2f9dfcdadf0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk1NTQ5MA==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540955490", "bodyText": "We don't have resources which return a FILE which also set the status to 204.", "author": "tristantarrant", "createdAt": "2020-12-11T13:43:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMwMTk3Mw=="}], "type": "inlineReview"}, {"oid": "b75cde90bce2c0c2994ac42ba18db30175b0aa2e", "url": "https://github.com/infinispan/infinispan/commit/b75cde90bce2c0c2994ac42ba18db30175b0aa2e", "message": "ISPN-12566 Simplify CLI command logic", "committedDate": "2020-12-11T12:33:43Z", "type": "forcePushed"}, {"oid": "c9dd2dd9bb98f994ffb04a063f7a1e13d9487368", "url": "https://github.com/infinispan/infinispan/commit/c9dd2dd9bb98f994ffb04a063f7a1e13d9487368", "message": "ISPN-12566 Simplify CLI command logic", "committedDate": "2020-12-11T13:35:15Z", "type": "forcePushed"}, {"oid": "fafd212d202938ac5d214a2c36b0113f72b57fde", "url": "https://github.com/infinispan/infinispan/commit/fafd212d202938ac5d214a2c36b0113f72b57fde", "message": "ISPN-12566 Simplify CLI command logic", "committedDate": "2020-12-11T13:36:27Z", "type": "forcePushed"}, {"oid": "5c3bf2a56cca7bdb0900d23557596bec9640a9c5", "url": "https://github.com/infinispan/infinispan/commit/5c3bf2a56cca7bdb0900d23557596bec9640a9c5", "message": "ISPN-12566 Simplify CLI command logic", "committedDate": "2020-12-11T13:52:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk3OTMxNA==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540979314", "bodyText": "Abort is not used anywhere (at least, I can't find it). Remove it?", "author": "pruivo", "createdAt": "2020-12-11T14:19:08Z", "path": "cli/src/main/java/org/infinispan/cli/commands/rest/Abort.java", "diffHunk": "@@ -14,7 +19,7 @@\n  **/\n @MetaInfServices(Command.class)\n @CommandDefinition(name = Abort.CMD, description = \"Aborts a batch\", activator = DisabledActivator.class)\n-public class Abort extends CliCommand {\n+public class Abort extends RestCliCommand {", "originalCommit": "5c3bf2a56cca7bdb0900d23557596bec9640a9c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk4MjA0NQ==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540982045", "bodyText": "begin isn't a rest command.\ncan it be removed?", "author": "pruivo", "createdAt": "2020-12-11T14:23:09Z", "path": "cli/src/main/java/org/infinispan/cli/commands/rest/Begin.java", "diffHunk": "@@ -1,10 +1,11 @@\n-package org.infinispan.cli.commands;\n+package org.infinispan.cli.commands.rest;", "originalCommit": "5c3bf2a56cca7bdb0900d23557596bec9640a9c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk4Mjk3Nw==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540982977", "bodyText": "same as Begin&Abort comments.", "author": "pruivo", "createdAt": "2020-12-11T14:24:32Z", "path": "cli/src/main/java/org/infinispan/cli/commands/rest/Commit.java", "diffHunk": "@@ -1,10 +1,11 @@\n-package org.infinispan.cli.commands;\n+package org.infinispan.cli.commands.rest;", "originalCommit": "5c3bf2a56cca7bdb0900d23557596bec9640a9c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk4NDE5MA==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540984190", "bodyText": "same as commit,abort,etc...", "author": "pruivo", "createdAt": "2020-12-11T14:26:16Z", "path": "cli/src/main/java/org/infinispan/cli/commands/rest/End.java", "diffHunk": "@@ -1,10 +1,11 @@\n-package org.infinispan.cli.commands;\n+package org.infinispan.cli.commands.rest;", "originalCommit": "5c3bf2a56cca7bdb0900d23557596bec9640a9c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk4NzEyOA==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540987128", "bodyText": "are these commands (evict, abort, end, revoke, replace etc) to be implemented in the future?", "author": "pruivo", "createdAt": "2020-12-11T14:29:27Z", "path": "cli/src/main/java/org/infinispan/cli/commands/rest/Grant.java", "diffHunk": "@@ -1,10 +1,11 @@\n-package org.infinispan.cli.commands;\n+package org.infinispan.cli.commands.rest;", "originalCommit": "5c3bf2a56cca7bdb0900d23557596bec9640a9c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTAxNjE1NA==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r541016154", "bodyText": "They are placeholders I created for features we had in the legacy cli. We do need to add them back", "author": "tristantarrant", "createdAt": "2020-12-11T15:11:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk4NzEyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTU0NDIwMA==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r541544200", "bodyText": "I've removed them", "author": "tristantarrant", "createdAt": "2020-12-12T09:52:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk4NzEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk5NjUwMw==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r540996503", "bodyText": "nit, remove extra new lines.", "author": "pruivo", "createdAt": "2020-12-11T14:43:33Z", "path": "cli/src/main/java/org/infinispan/cli/resources/Resource.java", "diffHunk": "@@ -47,6 +47,8 @@\n     */\n    boolean isLeaf();\n \n+\n+", "originalCommit": "5c3bf2a56cca7bdb0900d23557596bec9640a9c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MTA1MDE5OA==", "url": "https://github.com/infinispan/infinispan/pull/8925#discussion_r541050198", "bodyText": "Done", "author": "tristantarrant", "createdAt": "2020-12-11T15:59:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDk5NjUwMw=="}], "type": "inlineReview"}, {"oid": "cc72ac36daae4fd80d9bdf1b6a5b73c098b3c367", "url": "https://github.com/infinispan/infinispan/commit/cc72ac36daae4fd80d9bdf1b6a5b73c098b3c367", "message": "ISPN-12566 Simplify CLI command logic", "committedDate": "2020-12-11T15:59:07Z", "type": "forcePushed"}, {"oid": "66c93b0e75bbf8fc99dac237cc231be8b6ecda39", "url": "https://github.com/infinispan/infinispan/commit/66c93b0e75bbf8fc99dac237cc231be8b6ecda39", "message": "ISPN-12566 Simplify CLI command logic", "committedDate": "2020-12-12T09:51:50Z", "type": "forcePushed"}, {"oid": "bcaa9d145715f1ef61ad3f4791ef0c59deac28b9", "url": "https://github.com/infinispan/infinispan/commit/bcaa9d145715f1ef61ad3f4791ef0c59deac28b9", "message": "ISPN-12566 Simplify CLI command logic", "committedDate": "2020-12-12T10:03:05Z", "type": "commit"}, {"oid": "bcaa9d145715f1ef61ad3f4791ef0c59deac28b9", "url": "https://github.com/infinispan/infinispan/commit/bcaa9d145715f1ef61ad3f4791ef0c59deac28b9", "message": "ISPN-12566 Simplify CLI command logic", "committedDate": "2020-12-12T10:03:05Z", "type": "forcePushed"}]}