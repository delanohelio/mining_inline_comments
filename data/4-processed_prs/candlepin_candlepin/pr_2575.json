{"pr_number": 2575, "pr_title": "Lookup annotations on concrete resource implementations", "pr_createdAt": "2020-01-17T20:05:43Z", "pr_url": "https://github.com/candlepin/candlepin/pull/2575", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODExNTgwNw==", "url": "https://github.com/candlepin/candlepin/pull/2575#discussion_r368115807", "bodyText": "Is there any chance this can be called multiple times by multiple threads for a given instance? If so, we should probably have the method be synchronized so we don't run the (minute?) risk of two simultaneous calls getting around the lock. If not, disregard this comment.", "author": "Ceiu", "createdAt": "2020-01-17T20:09:27Z", "path": "server/src/main/java/org/candlepin/resteasy/AnnotationLocator.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ *  Copyright (c) 2009 - ${YEAR} Red Hat, Inc.\n+ *\n+ *  This software is licensed to you under the GNU General Public License,\n+ *  version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ *  implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ *  FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ *  along with this software; if not, see\n+ *  http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ *  Red Hat trademarks are not licensed under GPLv2. No permission is\n+ *  granted to use or replicate Red Hat trademarks that are incorporated\n+ *  in this software or its documentation.\n+ */\n+package org.candlepin.resteasy;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.inject.Binding;\n+import com.google.inject.Injector;\n+\n+import org.jboss.resteasy.spi.metadata.ResourceBuilder;\n+import org.jboss.resteasy.spi.metadata.ResourceClass;\n+import org.jboss.resteasy.spi.metadata.ResourceLocator;\n+import org.jboss.resteasy.spi.metadata.ResourceMethod;\n+import org.jboss.resteasy.util.GetRestful;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+/**\n+ * Holds a mapping of interface methods to concrete methods.\n+ *\n+ * Inspired by ResourceLocatorMap.\n+ *\n+ * This map is populated during servlet initialization and then locked. Various filters can use utility\n+ * methods to get annotations on the implementations as well as the interfaces, so that we can use\n+ * SecurityHole and other annotations on generated resource implementations.\n+ */\n+public class AnnotationLocator {\n+    private static final Logger log = LoggerFactory.getLogger(AnnotationLocator.class);\n+\n+    private Map<Method, Method> internalMap;\n+    private boolean hasBeenInitialized = false;\n+\n+    private Injector injector;\n+\n+    @Inject\n+    public AnnotationLocator(Injector injector) {\n+        // Maintain the insertion order for nice output in debug statement\n+        internalMap = new LinkedHashMap<>();\n+        this.injector = injector;\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    public void init() {", "originalCommit": "f32bc6e9101e163153ea243e357d3c5f52c10973", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODcyNzcxNw==", "url": "https://github.com/candlepin/candlepin/pull/2575#discussion_r368727717", "bodyText": "I will move to synchronized from lock to init; that seems better overall. Another quirk copied from ResourceLocatorMap.", "author": "kahowell", "createdAt": "2020-01-20T21:14:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODExNTgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODExNjgyOA==", "url": "https://github.com/candlepin/candlepin/pull/2575#discussion_r368116828", "bodyText": "Why are these all final? Is there a lambda I'm overlooking or some such?", "author": "Ceiu", "createdAt": "2020-01-17T20:12:20Z", "path": "server/src/main/java/org/candlepin/resteasy/AnnotationLocator.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ *  Copyright (c) 2009 - ${YEAR} Red Hat, Inc.\n+ *\n+ *  This software is licensed to you under the GNU General Public License,\n+ *  version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ *  implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ *  FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ *  along with this software; if not, see\n+ *  http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ *  Red Hat trademarks are not licensed under GPLv2. No permission is\n+ *  granted to use or replicate Red Hat trademarks that are incorporated\n+ *  in this software or its documentation.\n+ */\n+package org.candlepin.resteasy;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.inject.Binding;\n+import com.google.inject.Injector;\n+\n+import org.jboss.resteasy.spi.metadata.ResourceBuilder;\n+import org.jboss.resteasy.spi.metadata.ResourceClass;\n+import org.jboss.resteasy.spi.metadata.ResourceLocator;\n+import org.jboss.resteasy.spi.metadata.ResourceMethod;\n+import org.jboss.resteasy.util.GetRestful;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+/**\n+ * Holds a mapping of interface methods to concrete methods.\n+ *\n+ * Inspired by ResourceLocatorMap.\n+ *\n+ * This map is populated during servlet initialization and then locked. Various filters can use utility\n+ * methods to get annotations on the implementations as well as the interfaces, so that we can use\n+ * SecurityHole and other annotations on generated resource implementations.\n+ */\n+public class AnnotationLocator {\n+    private static final Logger log = LoggerFactory.getLogger(AnnotationLocator.class);\n+\n+    private Map<Method, Method> internalMap;\n+    private boolean hasBeenInitialized = false;\n+\n+    private Injector injector;\n+\n+    @Inject\n+    public AnnotationLocator(Injector injector) {\n+        // Maintain the insertion order for nice output in debug statement\n+        internalMap = new LinkedHashMap<>();\n+        this.injector = injector;\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    public void init() {\n+        if (hasBeenInitialized) {\n+            throw new IllegalStateException(\"This map has already been initialized.\");\n+        }\n+\n+        List<Binding<?>> rootResourceBindings = new ArrayList<>();\n+        for (final Binding<?> binding : injector.getBindings().values()) {\n+            final Type type = binding.getKey().getTypeLiteral().getType();\n+            if (type instanceof Class) {\n+                final Class<?> beanClass = (Class) type;", "originalCommit": "f32bc6e9101e163153ea243e357d3c5f52c10973", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODcyNzQ2OA==", "url": "https://github.com/candlepin/candlepin/pull/2575#discussion_r368727468", "bodyText": "This was just copy-paste from ResourceLocatorMap. Will remove, because it's really not providing value there.", "author": "kahowell", "createdAt": "2020-01-20T21:13:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODExNjgyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEyMTczNA==", "url": "https://github.com/candlepin/candlepin/pull/2575#discussion_r368121734", "bodyText": "I imagine the synchronized keyword is going to move up to init and then this will become private. Is there any situation where we want this to be locked externally?", "author": "Ceiu", "createdAt": "2020-01-17T20:25:49Z", "path": "server/src/main/java/org/candlepin/resteasy/AnnotationLocator.java", "diffHunk": "@@ -0,0 +1,141 @@\n+/*\n+ *  Copyright (c) 2009 - ${YEAR} Red Hat, Inc.\n+ *\n+ *  This software is licensed to you under the GNU General Public License,\n+ *  version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ *  implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ *  FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ *  along with this software; if not, see\n+ *  http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ *  Red Hat trademarks are not licensed under GPLv2. No permission is\n+ *  granted to use or replicate Red Hat trademarks that are incorporated\n+ *  in this software or its documentation.\n+ */\n+package org.candlepin.resteasy;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.inject.Binding;\n+import com.google.inject.Injector;\n+\n+import org.jboss.resteasy.spi.metadata.ResourceBuilder;\n+import org.jboss.resteasy.spi.metadata.ResourceClass;\n+import org.jboss.resteasy.spi.metadata.ResourceLocator;\n+import org.jboss.resteasy.spi.metadata.ResourceMethod;\n+import org.jboss.resteasy.util.GetRestful;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+/**\n+ * Holds a mapping of interface methods to concrete methods.\n+ *\n+ * Inspired by ResourceLocatorMap.\n+ *\n+ * This map is populated during servlet initialization and then locked. Various filters can use utility\n+ * methods to get annotations on the implementations as well as the interfaces, so that we can use\n+ * SecurityHole and other annotations on generated resource implementations.\n+ */\n+public class AnnotationLocator {\n+    private static final Logger log = LoggerFactory.getLogger(AnnotationLocator.class);\n+\n+    private Map<Method, Method> internalMap;\n+    private boolean hasBeenInitialized = false;\n+\n+    private Injector injector;\n+\n+    @Inject\n+    public AnnotationLocator(Injector injector) {\n+        // Maintain the insertion order for nice output in debug statement\n+        internalMap = new LinkedHashMap<>();\n+        this.injector = injector;\n+    }\n+\n+    @SuppressWarnings(\"rawtypes\")\n+    public void init() {\n+        if (hasBeenInitialized) {\n+            throw new IllegalStateException(\"This map has already been initialized.\");\n+        }\n+\n+        List<Binding<?>> rootResourceBindings = new ArrayList<>();\n+        for (final Binding<?> binding : injector.getBindings().values()) {\n+            final Type type = binding.getKey().getTypeLiteral().getType();\n+            if (type instanceof Class) {\n+                final Class<?> beanClass = (Class) type;\n+                if (GetRestful.isRootResource(beanClass)) {\n+                    rootResourceBindings.add(binding);\n+                }\n+            }\n+        }\n+        for (Binding<?> binding : rootResourceBindings) {\n+            Class<?> clazz = (Class) binding.getKey().getTypeLiteral().getType();\n+            if (Proxy.isProxyClass(clazz)) {\n+                for (Class<?> intf : clazz.getInterfaces()) {\n+                    ResourceClass resourceClass = ResourceBuilder.rootResourceFromAnnotations(intf);\n+                    registerConcreteMethods(resourceClass, clazz);\n+                }\n+            }\n+            else {\n+                ResourceClass resourceClass = ResourceBuilder.rootResourceFromAnnotations(clazz);\n+                registerConcreteMethods(resourceClass, clazz);\n+            }\n+        }\n+        lock();\n+    }\n+\n+    private void registerConcreteMethods(ResourceClass resourceClass, Class<?> concreteClass) {\n+        for (ResourceMethod resourceMethod : resourceClass.getResourceMethods()) {\n+            registerConcreteMethod(resourceMethod.getMethod(), concreteClass);\n+        }\n+        for (ResourceLocator resourceMethod : resourceClass.getResourceLocators()) {\n+            registerConcreteMethod(resourceMethod.getMethod(), concreteClass);\n+        }\n+    }\n+\n+    private void registerConcreteMethod(Method method, Class<?> concreteClass) {\n+        try {\n+            for (Class<?> iface : concreteClass.getInterfaces()){\n+                Method ifaceMethod = iface.getMethod(method.getName(), method.getParameterTypes());\n+                internalMap.put(ifaceMethod, method);\n+            }\n+        }\n+        catch (NoSuchMethodException e) {\n+            log.error(\"Can't find concrete method for method {}!\", method);\n+        }\n+    }\n+\n+    /**\n+     * Looks up annotation for a resource from the concrete implementation.\n+     *\n+     * Falls back to any instance of that annotation on the method itself if no concrete implementation is\n+     * registered.\n+     *\n+     * @param method method to get annotation for\n+     * @param annotationClass which annotation to try to get\n+     */\n+    public <T extends Annotation> T getAnnotation(Method method, Class<T> annotationClass) {\n+        Method concreteMethod = internalMap.get(method);\n+        if (concreteMethod != null) {\n+            T annotation = concreteMethod.getAnnotation(annotationClass);\n+            if (annotation != null) {\n+                return annotation;\n+            }\n+        }\n+        return method.getAnnotation(annotationClass);\n+    }\n+\n+    public synchronized void lock() {", "originalCommit": "f32bc6e9101e163153ea243e357d3c5f52c10973", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODcyNzgzMQ==", "url": "https://github.com/candlepin/candlepin/pull/2575#discussion_r368727831", "bodyText": "Nope, I'll push an update shortly.", "author": "kahowell", "createdAt": "2020-01-20T21:14:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEyMTczNA=="}], "type": "inlineReview"}, {"oid": "18e9868316f91805d9792850fe73520cd01712b8", "url": "https://github.com/candlepin/candlepin/commit/18e9868316f91805d9792850fe73520cd01712b8", "message": "Lookup annotations on concrete resource implementations", "committedDate": "2020-01-20T21:15:23Z", "type": "commit"}, {"oid": "18e9868316f91805d9792850fe73520cd01712b8", "url": "https://github.com/candlepin/candlepin/commit/18e9868316f91805d9792850fe73520cd01712b8", "message": "Lookup annotations on concrete resource implementations", "committedDate": "2020-01-20T21:15:23Z", "type": "forcePushed"}]}