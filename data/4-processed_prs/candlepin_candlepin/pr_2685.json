{"pr_number": 2685, "pr_title": "[F] Product + Content Refresh Refactor (ENT-2207)", "pr_createdAt": "2020-04-23T03:54:21Z", "pr_url": "https://github.com/candlepin/candlepin/pull/2685", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM2NTQ2Mw==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r419365463", "bodyText": "Not something for this PR/task, but we should add a card in the epic to add a documentation page on candlepinproject.org on how the algorithm works", "author": "nikosmoum", "createdAt": "2020-05-04T11:18:52Z", "path": "server/src/main/java/org/candlepin/controller/refresher/RefreshWorker.java", "diffHunk": "@@ -0,0 +1,417 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.controller.refresher;\n+\n+import org.candlepin.controller.refresher.builders.ContentNodeBuilder;\n+import org.candlepin.controller.refresher.builders.NodeFactory;\n+import org.candlepin.controller.refresher.builders.ProductNodeBuilder;\n+import org.candlepin.controller.refresher.mappers.ContentMapper;\n+import org.candlepin.controller.refresher.mappers.NodeMapper;\n+import org.candlepin.controller.refresher.mappers.PoolMapper;\n+import org.candlepin.controller.refresher.mappers.ProductMapper;\n+import org.candlepin.controller.refresher.visitors.ContentNodeVisitor;\n+import org.candlepin.controller.refresher.visitors.NodeProcessor;\n+import org.candlepin.controller.refresher.visitors.ProductNodeVisitor;\n+import org.candlepin.model.Content;\n+import org.candlepin.model.ContentCurator;\n+import org.candlepin.model.Owner;\n+import org.candlepin.model.OwnerContentCurator;\n+import org.candlepin.model.OwnerProductCurator;\n+import org.candlepin.model.Product;\n+import org.candlepin.model.ProductCurator;\n+import org.candlepin.service.model.ContentInfo;\n+import org.candlepin.service.model.ProductContentInfo;\n+import org.candlepin.service.model.ProductInfo;\n+import org.candlepin.service.model.SubscriptionInfo;\n+\n+import com.google.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+\n+\n+/**\n+ * The RefreshWorker gathers upstream objects to refresh, and then performs the actual work to\n+ * update their local representations.", "originalCommit": "fa6bcf39095dc9f0a633fb2cc79f0c471bcee758", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE0MDc3MA==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420140770", "bodyText": "The overall algorithm for merging doesn't change, just how we're doing the work. I'm not entirely opposed to documenting how/why this works, but from an outsider's perspective, nothing (should have) changed here.", "author": "Ceiu", "createdAt": "2020-05-05T14:12:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM2NTQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1OTExMg==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420159112", "bodyText": "I'm thinking more as a resource for developers than outsiders", "author": "nikosmoum", "createdAt": "2020-05-05T14:36:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTM2NTQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk3ODg0Mw==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r419978843", "bodyText": "This mentions one of the two effects of this method (that it returns the node), but we should also mention the other, maybe even more important effect: that the node is added to the NodeMapper (which is the whole point of NodeFactory, to build up a NodeMapper data structure so that we can then process it)", "author": "nikosmoum", "createdAt": "2020-05-05T09:30:55Z", "path": "server/src/main/java/org/candlepin/controller/refresher/builders/NodeFactory.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.controller.refresher.builders;\n+\n+import org.candlepin.controller.refresher.mappers.NodeMapper;\n+import org.candlepin.controller.refresher.nodes.EntityNode;\n+import org.candlepin.model.AbstractHibernateObject;\n+import org.candlepin.model.Owner;\n+import org.candlepin.service.model.ServiceAdapterModel;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\n+\n+/**\n+ * The NodeFactory is responsible for orchestrating the complete creation and mapping of a node and\n+ * any children nodes it may create.\n+ * <p></p>\n+ * The tasks that make up the creation and mapping of a node may be performed by other objects, but\n+ * those objects must be provided before a node creation request is made.\n+ */\n+public class NodeFactory {\n+\n+    private NodeMapper mapper;\n+    private Map<Class, NodeBuilder> builders;\n+\n+    /**\n+     * Creates a new NodeFactory without any mappers or builders\n+     */\n+    public NodeFactory() {\n+        this.builders = new HashMap<>();\n+    }\n+\n+    /**\n+     * Adds a builder to this factory. The builder will be used to create nodes for the class\n+     * returned by the builder's <tt>getEntityClass</tt> method.\n+     *\n+     * @param builder\n+     *  the builder to add to this factory\n+     *\n+     * @throws IllegalArgumentException\n+     *  if the provided builder is null\n+     *\n+     * @return\n+     *  a reference to this node factory\n+     */\n+    public NodeFactory addBuilder(NodeBuilder builder) {\n+        if (builder == null) {\n+            throw new IllegalArgumentException(\"builder is null\");\n+        }\n+\n+        this.builders.put(builder.getEntityClass(), builder);\n+        return this;\n+    }\n+\n+    /**\n+     * Sets the mapper to use for mapping nodes created by this factory.\n+     *\n+     * @param mapper\n+     *  the mapper to use for mapping nodes\n+     *\n+     * @throws IllegalArgumentException\n+     *  if the provided mapper is null\n+     *\n+     * @return\n+     *  a reference to this node factory\n+     */\n+    public NodeFactory setNodeMapper(NodeMapper mapper) {\n+        if (mapper == null) {\n+            throw new IllegalArgumentException(\"mapper is null\");\n+        }\n+\n+        this.mapper = mapper;\n+        return this;\n+    }\n+\n+    /**\n+     * Returns an entity node for the given entity class and ID, creating it as necessary.", "originalCommit": "fa6bcf39095dc9f0a633fb2cc79f0c471bcee758", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE0MTE5NQ==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420141195", "bodyText": "Added an extra bit to the end of that sentence. Now reads \"creating and mapping it as necessary\". Will show up in the next commit.", "author": "Ceiu", "createdAt": "2020-05-05T14:12:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTk3ODg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA2NTAxMA==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420065010", "bodyText": "The ProductManager did flush when saving the core products, then again when saving the owner-products. Here it seems we're deferring flushing for when? Shouldn't we flush before CandlepinPoolManager starts processing the pools? (same question applies for ContentNodeVisitor.complete)", "author": "nikosmoum", "createdAt": "2020-05-05T12:19:45Z", "path": "server/src/main/java/org/candlepin/controller/refresher/visitors/ProductNodeVisitor.java", "diffHunk": "@@ -0,0 +1,340 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.controller.refresher.visitors;\n+\n+import org.candlepin.controller.ProductManager;\n+import org.candlepin.controller.refresher.RefreshResult;\n+import org.candlepin.controller.refresher.mappers.NodeMapper;\n+import org.candlepin.controller.refresher.nodes.EntityNode;\n+import org.candlepin.model.Branding;\n+import org.candlepin.model.Content;\n+import org.candlepin.model.Owner;\n+import org.candlepin.model.OwnerProduct;\n+import org.candlepin.model.OwnerProductCurator;\n+import org.candlepin.model.Product;\n+import org.candlepin.model.ProductCurator;\n+import org.candlepin.service.model.BrandingInfo;\n+import org.candlepin.service.model.ContentInfo;\n+import org.candlepin.service.model.ProductContentInfo;\n+import org.candlepin.service.model.ProductInfo;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\n+\n+/**\n+ * A NodeVisitor implementation that supports product entity nodes\n+ */\n+public class ProductNodeVisitor implements NodeVisitor<Product, ProductInfo> {\n+    private final ProductCurator productCurator;\n+    private final OwnerProductCurator ownerProductCurator;\n+\n+    private Set<OwnerProduct> ownerProductEntities;\n+    private Map<Owner, Map<String, String>> ownerProductUuidMap;\n+\n+    /**\n+     * Creates a new ProductNodeVisitor that uses the provided curators for performing database\n+     * operations.\n+     *\n+     * @param productCurator\n+     *  the ProductCurator to use for product database operations\n+     *\n+     * @param ownerProductCurator\n+     *  the OwnerProductCurator to use for owner-product database operations\n+     *\n+     * @throws IllegalArgumentException\n+     *  if any of the provided curators are null\n+     */\n+    public ProductNodeVisitor(ProductCurator productCurator, OwnerProductCurator ownerProductCurator) {\n+        if (productCurator == null) {\n+            throw new IllegalArgumentException(\"productCurator is null\");\n+        }\n+\n+        if (ownerProductCurator == null) {\n+            throw new IllegalArgumentException(\"ownerProductCurator is null\");\n+        }\n+\n+        this.productCurator = productCurator;\n+        this.ownerProductCurator = ownerProductCurator;\n+\n+        this.ownerProductEntities = new HashSet<>();\n+        this.ownerProductUuidMap = new HashMap<>();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public Class<Product> getEntityClass() {\n+        return Product.class;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void processNode(NodeProcessor processor, NodeMapper mapper,\n+        EntityNode<Product, ProductInfo> node) {\n+\n+        boolean childrenUpdated = false;\n+        boolean nodeChanged = false;\n+\n+        if (node.visited()) {\n+            return;\n+        }\n+\n+        // Process children nodes first (depth-first), so we can update references and avoid\n+        // rework; also check if we need to make reference updates on this entity.\n+        for (EntityNode child : (Set<EntityNode>) node.getChildrenNodes()) {\n+            processor.processNode(child);\n+            childrenUpdated |= child.changed();\n+        }\n+\n+        Product existingEntity = node.getExistingEntity();\n+        ProductInfo importedEntity = node.getImportedEntity();\n+\n+        if (existingEntity != null) {\n+            if (importedEntity != null) {\n+                nodeChanged = ProductManager.isChangedBy(existingEntity, importedEntity);\n+            }\n+\n+            if (nodeChanged || childrenUpdated) {\n+                Product updatedEntity = this.createEntity(mapper, node);\n+                node.setUpdatedEntity(updatedEntity);\n+\n+                // Store the mapping to be updated later\n+                Map<String, String> productUuidMap = this.ownerProductUuidMap.get(node.getOwner());\n+                if (productUuidMap == null) {\n+                    productUuidMap = new HashMap<>();\n+                    this.ownerProductUuidMap.put(node.getOwner(), productUuidMap);\n+                }\n+                productUuidMap.put(existingEntity.getUuid(), updatedEntity.getUuid());\n+\n+                node.markChanged();\n+            }\n+        }\n+        else {\n+            // Node is new\n+            Product updatedEntity = this.createEntity(mapper, node);\n+            node.setUpdatedEntity(updatedEntity);\n+\n+            // Create a new owner-product mapping for this entity. This will get persisted\n+            // later during completion\n+            this.ownerProductEntities.add(new OwnerProduct(node.getOwner(), updatedEntity));\n+\n+            node.markChanged();\n+        }\n+\n+        node.markVisited();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public void complete() {\n+        this.ownerProductCurator.saveAll(this.ownerProductEntities, false, true);", "originalCommit": "fa6bcf39095dc9f0a633fb2cc79f0c471bcee758", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE0MDE4Mg==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420140182", "bodyText": "Oversight on my part a bit. We need to flush before we start doing direct SQL queries for the owner remapping or bad things will happen; but we shouldn't need to flush between each in a given visitor. Just a single flush should be good.\nAs an interesting side note: evict without flush on the saveAll and updateAll methods does nothing. Debating leaving it as-is to show intent, but also reverting it to false, false since it doesn't do anything for us.", "author": "Ceiu", "createdAt": "2020-05-05T14:11:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA2NTAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1ODQxNw==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420158417", "bodyText": "yes, evict to false would be more clear", "author": "nikosmoum", "createdAt": "2020-05-05T14:35:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA2NTAxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE2MTAyNA==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420161024", "bodyText": "Done.", "author": "Ceiu", "createdAt": "2020-05-05T14:38:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA2NTAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY2Mjk4Ng==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420662986", "bodyText": "What kind of file is that? Where does it come/get generated from? It might be useful to add this info to the 'usage/help' output", "author": "nikosmoum", "createdAt": "2020-05-06T09:37:27Z", "path": "server/bin/upstream_subscription_injector.rb", "diffHunk": "@@ -0,0 +1,214 @@\n+#!/usr/bin/env ruby\n+# Candlepin consumer generator\n+# Generates consumers and entitlements for a Candlepin database\n+\n+require 'optparse'\n+require 'set'\n+require 'thread'\n+\n+require_relative \"../client/ruby/candlepin_api\"\n+\n+\n+\n+class ThreadPool\n+  def initialize(size)\n+    @size = size\n+    @jobs = Queue.new\n+    @pool = Array.new(@size) do |i|\n+      Thread.new do\n+        Thread.current[:id] = i\n+        catch(:exit) do\n+          loop do\n+            job, args = @jobs.pop\n+            job.call(*args)\n+          end\n+        end\n+      end\n+    end\n+  end\n+\n+  def schedule(*args, &block)\n+    @jobs << [block, args]\n+  end\n+\n+  def shutdown\n+    @size.times do\n+      schedule { throw :exit }\n+    end\n+\n+    @pool.map(&:join)\n+  end\n+end\n+\n+@options = {}\n+\n+def log(level, message)\n+  puts \"#{level}: #{message}\" unless @options[:silent]\n+end\n+\n+def terminate(message)\n+  puts \"ERROR: #{message}\"\n+  exit\n+end\n+\n+def is_hosted(candlepin)\n+  return !candlepin.get_status()['standalone']\n+end\n+\n+def clear_upstream_data(candlepin)\n+  candlepin.delete('/hostedtest', {}, nil, true)\n+end\n+\n+def create_upstream_subscription(candlepin, subscription_id, owner_key, params = {})\n+  start_date = params.delete(:start_date) || Date.today\n+  end_date = params.delete(:end_date) || start_date + 365\n+\n+  # Define subscription with defaults & specified params\n+  subscription = {\n+    'startDate' => start_date,\n+    'endDate'   => end_date,\n+    'quantity'  => 1\n+  }\n+\n+  # Do not copy these with the rest of the merged keys\n+  filter = ['id', 'owner', 'ownerId']\n+\n+  params.each do |key, value|\n+    # Convert the key to snake case so we can support whatever is thrown at us\n+    key = key.to_s.gsub(/_(\\w)/){$1.upcase}\n+\n+    if !filter.include?(key)\n+      subscription[key] = value\n+    end\n+  end\n+\n+  # Forcefully set critical identifiers\n+  subscription['id'] = subscription_id\n+  subscription['owner'] = { :key => owner_key }\n+\n+  return candlepin.post('hostedtest/subscriptions', {}, subscription)\n+end\n+\n+\n+# Set up the options\n+optparse = OptionParser.new do |opts|\n+  file = File.basename(__FILE__)\n+  opts.banner = \"Usage: #{file} [options] org file\\n\\nOptions:\"\n+\n+  @options[:user] = 'admin'\n+  opts.on('--username [USER]', 'Username to connect as; defaults to \"admin\".') do |opt|\n+    @options[:user] = opt\n+  end\n+\n+  @options[:password] = 'admin'\n+  opts.on('--password [PASSWORD]', 'Password to authenticate the user as; defaults to \"admin\".') do |opt|\n+    @options[:password] = opt\n+  end\n+\n+  @options[:server] = 'localhost'\n+  opts.on('--server [SERVERNAME]', String, 'Server name FQDN; defaults to \"localhost\"') do |opt|\n+    @options[:server] = opt\n+  end\n+\n+  @options[:port] = 8443\n+  opts.on('--port [PORTNUM]', 'Port number for the Candlepin server; defaults to 8443') do |opt|\n+    @options[:port] = opt.to_i\n+  end\n+\n+  @options[:context] = 'candlepin'\n+  opts.on('--context [CONTEXT]', 'Context to use; defaults to \"candlepin\"') do |opt|\n+    @options[:context] = opt\n+  end\n+\n+  @options[:uuid] = nil\n+  opts.on('--uuid [UUID]', 'UUID to use; defaults to nil') do |opt|\n+    @options[:uuid] = opt\n+  end\n+\n+  @options[:ssl] = true\n+  opts.on('--nossl', 'Do not use SSL; defaults to false') do\n+    @options[:ssl] = false\n+  end\n+\n+  @options[:clean] = false\n+  opts.on('--clean', 'Cleans the upstream subscription data before injecting the new data') do\n+    @options[:clean] = true\n+  end\n+\n+  @options[:silent] = false\n+  opts.on( '--silent', 'Disable output while generating consumers' ) do\n+    @options[:silent] = true\n+  end\n+\n+  opts.on('-?', '--help', 'Displays command and option information') do\n+    puts opts\n+    exit\n+  end\n+end\n+\n+optparse.parse!\n+\n+####################################################################################################\n+\n+# At present we do not have any required parameters\n+\n+candlepin = Candlepin.new(\n+    @options[:user], @options[:password], nil, nil, @options[:server], @options[:port], nil,\n+    @options[:uuid], @options[:trused_user], @options[:context], @options[:ssl]\n+)\n+\n+# Check that the targeted CP is running in hosted mode\n+terminate(\"Targeted Candlepin deployment is not running in hosted mode\") if !is_hosted(candlepin)\n+\n+# Fetch known orgs...\n+owners = []\n+candlepin.list_owners().each do |owner|\n+  owners << owner['key']\n+end\n+\n+# Ensure an owner was specified and exists\n+terminate(\"An owner to receive the subscription data must be specified\") if ARGV.empty?\n+\n+owner_key = ARGV.shift\n+\n+if owners.empty? || !owners.include?(owner_key)\n+  log(\"INFO\", \"Owner \\\"#{owner_key}\\\" does not exist; creating it\")\n+  candlepin.create_owner(owner_key)\n+end\n+\n+# Ensure that the subscription data file was specified and exists\n+terminate(\"A subscription data file must be specified\") if ARGV.empty?", "originalCommit": "1c129f9da237d4a0fd00d6dc61bd46bd438cb010", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU0MDM0Mw==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r421540343", "bodyText": "Fixed", "author": "Ceiu", "createdAt": "2020-05-07T14:18:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY2Mjk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcwMzc1MQ==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420703751", "bodyText": "All the commented out code in this class should be removed, since it looks like it has already been replaced by the mockRefresh call", "author": "nikosmoum", "createdAt": "2020-05-06T10:56:43Z", "path": "server/src/test/java/org/candlepin/controller/PoolManagerTest.java", "diffHunk": "@@ -545,75 +556,98 @@ private void mockProducts(Owner owner, Product... products) {\n         this.mockProducts(owner, productMap);\n     }\n \n-    private void mockProductImport(Owner owner, final Map<String, Product> products) {\n-        when(mockProductManager.importProducts(eq(owner), any(Map.class), any(Map.class)))\n-            .thenAnswer(new Answer<ImportResult<Product>>() {\n-                @Override\n-                public ImportResult<Product> answer(InvocationOnMock invocation) throws Throwable {\n-                    Object[] args = invocation.getArguments();\n-                    Map<String, ProductData> productData = (Map<String, ProductData>) args[1];\n-                    ImportResult<Product> importResult = new ImportResult<>();\n-                    Map<String, Product> output = importResult.getCreatedEntities();\n-\n-                    if (productData != null) {\n-                        for (String pid : productData.keySet()) {\n-                            Product product = products.get(pid);\n+    private void mockRefresh(Owner owner, Collection<Product> products, Collection<Content> contents) {\n+        doAnswer(new Answer<RefreshResult>() {\n+            @Override\n+            public RefreshResult answer(InvocationOnMock iom) throws Throwable {\n+                RefreshResult output = new RefreshResult();\n \n-                            if (product != null) {\n-                                output.put(product.getId(), product);\n-                            }\n-                        }\n+                if (products != null) {\n+                    for (Product product : products) {\n+                        output.addCreatedProduct(product);\n                     }\n-\n-                    return importResult;\n                 }\n-            });\n-    }\n-\n-    private void mockProductImport(Owner owner, Product... products) {\n-        Map<String, Product> productMap = new HashMap<>();\n \n-        for (Product product : products) {\n-            productMap.put(product.getId(), product);\n-        }\n-\n-        this.mockProductImport(owner, productMap);\n-    }\n-\n-    private void mockContentImport(Owner owner, final Map<String, Content> contents) {\n-        when(mockContentManager.importContent(eq(owner), any(Map.class), any(Set.class)))\n-            .thenAnswer(new Answer<ImportResult<Content>>() {\n-                @Override\n-                public ImportResult<Content> answer(InvocationOnMock invocation) throws Throwable {\n-                    Object[] args = invocation.getArguments();\n-                    Map<String, ContentData> contentData = (Map<String, ContentData>) args[1];\n-                    ImportResult<Content> importResult = new ImportResult<>();\n-                    Map<String, Content> output = importResult.getCreatedEntities();\n-\n-                    if (contentData != null) {\n-                        for (String pid : contentData.keySet()) {\n-                            Content content = contents.get(pid);\n-\n-                            if (content != null) {\n-                                output.put(content.getId(), content);\n-                            }\n-                        }\n+                if (contents != null) {\n+                    for (Content content : contents) {\n+                        output.addCreatedContent(content);\n                     }\n-\n-                    return importResult;\n                 }\n-            });\n-    }\n \n-    private void mockContentImport(Owner owner, Content... contents) {\n-        Map<String, Content> contentMap = new HashMap<>();\n-\n-        for (Content content : contents) {\n-            contentMap.put(content.getId(), content);\n-        }\n-\n-        this.mockContentImport(owner, contentMap);\n-    }\n+                return output;\n+            }})\n+        .when(this.refreshWorker).execute(eq(owner));\n+    }\n+\n+    // private void mockProductImport(Owner owner, final Map<String, Product> products) {", "originalCommit": "1c129f9da237d4a0fd00d6dc61bd46bd438cb010", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzMDgzOQ==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420930839", "bodyText": "Yeah. Once I finish with the refresh testing, I'm going to go back and remove the commented out code which is no longer required, and fix up the bits that are.", "author": "Ceiu", "createdAt": "2020-05-06T16:35:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcwMzc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcwNjA1Mw==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420706053", "bodyText": "irrelevant comment for the test", "author": "nikosmoum", "createdAt": "2020-05-06T11:01:19Z", "path": "server/src/test/java/org/candlepin/controller/refresher/builders/ContentNodeBuilderTest.java", "diffHunk": "@@ -0,0 +1,403 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.controller.refresher.builders;\n+\n+import org.candlepin.controller.refresher.mappers.ContentMapper;\n+import org.candlepin.controller.refresher.nodes.EntityNode;\n+import org.candlepin.model.Content;\n+import org.candlepin.model.Owner;\n+import org.candlepin.service.model.ContentInfo;\n+import org.candlepin.test.TestUtil;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.junit.jupiter.MockitoSettings;\n+import org.mockito.quality.Strictness;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+\n+\n+/**\n+ * Test suite for the ContentNodeBuilder class\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@MockitoSettings(strictness = Strictness.LENIENT)\n+public class ContentNodeBuilderTest {\n+\n+    private NodeFactory mockNodeFactory;\n+    private ContentMapper contentMapper;\n+\n+    @BeforeEach\n+    public void init() throws Exception {\n+        this.mockNodeFactory = mock(NodeFactory.class);\n+        this.contentMapper = new ContentMapper();\n+    }\n+\n+    private ContentNodeBuilder buildNodeBuilder() {\n+        return new ContentNodeBuilder(this.contentMapper);\n+    }\n+\n+    private Set<Content> createCandidateEntitiesSet(String id) {\n+        Set<Content> candidates = new HashSet<>();\n+\n+        for (int i = 0; i < 3; ++i) {\n+            Content candidate = TestUtil.createContent(id, TestUtil.randomString());\n+            candidates.add(candidate);\n+        }\n+\n+        return candidates;\n+    }\n+\n+    private void addDummyCandidateEntitiesToMap(Map<String, Set<Content>> candidateEntitiesMap) {\n+        for (int i = 0; i < 5; ++i) {\n+            String id = TestUtil.randomString();\n+            candidateEntitiesMap.put(id, this.createCandidateEntitiesSet(id));\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testGetEntityClass() {\n+        ContentNodeBuilder builder = this.buildNodeBuilder();\n+\n+        Class output = builder.getEntityClass();\n+\n+        assertNotNull(output);\n+        assertEquals(Content.class, output);\n+    }\n+\n+\n+    /**\n+     * Builds a new entity node owned by the given owner, using the specified entity ID. The\n+     * provided node factory should be used when performing construction of children nodes to ensure\n+     * proper mapping and avoiding code duplication.\n+     *\n+     * @param factory\n+     *  the node factory to use for performing construction of children nodes\n+     *\n+     * @param owner\n+     *  the organization that will own the entity represented by the new entity node\n+     *\n+     * @param id\n+     *  the ID of the entity represented by the new entity node\n+     *\n+     * @throws IllegalStateException\n+     *  if an entity node representing the given ID cannot be created\n+     *\n+     * @return\n+     *  a new EntityNode instance representing the entity with the provided ID\n+     */\n+    // EntityNode<E, I> buildNode(NodeFactory factory, Owner owner, String id);\n+", "originalCommit": "1c129f9da237d4a0fd00d6dc61bd46bd438cb010", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzMTk1Mw==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420931953", "bodyText": "Oh, whoops. Something I copied in so I didn't have to keep switching tabs. Removed.", "author": "Ceiu", "createdAt": "2020-05-06T16:37:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcwNjA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDcwODAzNw==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r420708037", "bodyText": "out of place comment", "author": "nikosmoum", "createdAt": "2020-05-06T11:05:23Z", "path": "server/src/test/java/org/candlepin/controller/refresher/builders/ProductNodeBuilderTest.java", "diffHunk": "@@ -0,0 +1,836 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.controller.refresher.builders;\n+\n+import org.candlepin.controller.refresher.mappers.ProductMapper;\n+import org.candlepin.controller.refresher.nodes.EntityNode;\n+import org.candlepin.model.AbstractHibernateObject;\n+import org.candlepin.model.Content;\n+import org.candlepin.model.Owner;\n+import org.candlepin.model.Product;\n+import org.candlepin.service.model.ProductInfo;\n+import org.candlepin.service.model.ServiceAdapterModel;\n+import org.candlepin.test.TestUtil;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.junit.jupiter.MockitoSettings;\n+import org.mockito.quality.Strictness;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.Mockito.*;\n+\n+\n+\n+/**\n+ * Test suite for the ProductNodeBuilder class\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@MockitoSettings(strictness = Strictness.LENIENT)\n+public class ProductNodeBuilderTest {\n+\n+    private NodeFactory mockNodeFactory;\n+    private ProductMapper productMapper;\n+\n+    @BeforeEach\n+    public void init() throws Exception {\n+        this.mockNodeFactory = mock(NodeFactory.class);\n+        this.productMapper = new ProductMapper();\n+    }\n+\n+    private ProductNodeBuilder buildNodeBuilder() {\n+        return new ProductNodeBuilder(this.productMapper);\n+    }\n+\n+    private Set<Product> createCandidateEntitiesSet(String id) {\n+        Set<Product> candidates = new HashSet<>();\n+\n+        for (int i = 0; i < 3; ++i) {\n+            Product candidate = TestUtil.createProduct(id, TestUtil.randomString());\n+            candidates.add(candidate);\n+        }\n+\n+        return candidates;\n+    }\n+\n+    private void addDummyCandidateEntitiesToMap(Map<String, Set<Product>> candidateEntitiesMap) {\n+        for (int i = 0; i < 5; ++i) {\n+            String id = TestUtil.randomString();\n+            candidateEntitiesMap.put(id, this.createCandidateEntitiesSet(id));\n+        }\n+    }\n+\n+    private EntityNode mockEntityNode(Owner owner, Class cls, String id,\n+        AbstractHibernateObject existingEntity, ServiceAdapterModel importedEntity) {\n+\n+        EntityNode node = mock(EntityNode.class);\n+\n+        doReturn(owner).when(node).getOwner();\n+        doReturn(cls).when(node).getEntityClass();\n+        doReturn(id).when(node).getEntityId();\n+\n+        doReturn(existingEntity).when(node).getExistingEntity();\n+        doReturn(importedEntity).when(node).getImportedEntity();\n+\n+        doReturn(node).when(this.mockNodeFactory).buildNode(eq(owner), eq(cls), eq(id));\n+\n+        return node;\n+    }\n+\n+    @Test\n+    public void testGetEntityClass() {\n+        ProductNodeBuilder builder = this.buildNodeBuilder();\n+\n+        Class output = builder.getEntityClass();\n+\n+        assertNotNull(output);\n+        assertEquals(Product.class, output);\n+    }\n+\n+\n+    /**\n+     * Builds a new entity node owned by the given owner, using the specified entity ID. The\n+     * provided node factory should be used when performing construction of children nodes to ensure\n+     * proper mapping and avoiding code duplication.\n+     *\n+     * @param factory\n+     *  the node factory to use for performing construction of children nodes\n+     *\n+     * @param owner\n+     *  the organization that will own the entity represented by the new entity node\n+     *\n+     * @param id\n+     *  the ID of the entity represented by the new entity node\n+     *\n+     * @throws IllegalStateException\n+     *  if an entity node representing the given ID cannot be created\n+     *\n+     * @return\n+     *  a new EntityNode instance representing the entity with the provided ID\n+     */\n+    // EntityNode<E, I> buildNode(NodeFactory factory, Owner owner, String id);\n+", "originalCommit": "1c129f9da237d4a0fd00d6dc61bd46bd438cb010", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4MDE0MQ==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r421380141", "bodyText": "\ud83d\udc4d Recursing on the NodeProcessor directly is much clearer than going through the visitors", "author": "nikosmoum", "createdAt": "2020-05-07T09:49:02Z", "path": "server/src/main/java/org/candlepin/controller/refresher/visitors/NodeProcessor.java", "diffHunk": "@@ -110,38 +111,26 @@ public void processNodes() {\n         }\n     }\n \n-    /**\n-     * Processes the specified node. If a node mapper has not yet been set, or a visitor has not\n-     * been provided for the node, or one or more of its children, this method throws an exception.\n-     * If the provided node is null, this method will silently return.\n-     *\n-     * @param node\n-     *  the entity node to process\n-     *\n-     * @throws IllegalStateException\n-     *  if a node mapper has not been set, or a visitor has not been provided for the class of\n-     *  node provided, or one or more of its children.\n-     */\n-    public void processNode(EntityNode node) {\n-        if (this.mapper == null) {\n-            throw new IllegalStateException(\"node mapper has not been set\");\n-        }\n-\n-        this.processNodeImpl(node);\n-    }\n-\n     /**\n      * Internal implementation that avoids repeating unnecessary input and state validation\n      */\n     private void processNodeImpl(EntityNode node) {\n         if (node != null) {\n-            NodeVisitor visitor = this.visitors.get(node.getEntityClass());\n+            // Process children nodes first (depth-first), so we can update references and avoid\n+            // rework\n+            for (EntityNode childNode : (Collection<EntityNode>) node.getChildrenNodes()) {\n+                this.processNodeImpl(childNode);", "originalCommit": "7321546e0abbeeaec7f79c47aa4eca3b1dd75dbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4Njk2MQ==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r421386961", "bodyText": "It doesn't look like this one line is needed (the validator isn't used thereafter)", "author": "nikosmoum", "createdAt": "2020-05-07T10:00:26Z", "path": "server/src/test/java/org/candlepin/controller/refresher/visitors/ContentNodeVisitorTest.java", "diffHunk": "@@ -332,8 +277,10 @@ public void testProcessNodeForUnchangedEntity(String key, Object base, Object up\n         Owner owner = TestUtil.createOwner();\n         String id = TestUtil.randomString(\"test_id\");\n \n-        Content existing = this.createPopulatedEntity(id, key, base);\n-        ContentInfo imported = this.createPopulatedEntity(id, key, base);\n+        Content existing = this.createPopulatedExistingEntity(id, key, base);\n+        ContentInfo imported = this.createPopulatedImportedEntity(id, key, base);\n+\n+        MergeValidator<ContentInfo> validator = this.validators.get(key);", "originalCommit": "7321546e0abbeeaec7f79c47aa4eca3b1dd75dbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUzNTUyNw==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r421535527", "bodyText": "Fixed", "author": "Ceiu", "createdAt": "2020-05-07T14:11:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4Njk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4OTAxMg==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r421389012", "bodyText": "\ud83d\udc4d", "author": "nikosmoum", "createdAt": "2020-05-07T10:04:03Z", "path": "server/src/test/java/org/candlepin/controller/refresher/visitors/ContentNodeVisitorTest.java", "diffHunk": "@@ -60,79 +55,9 @@\n @MockitoSettings(strictness = Strictness.LENIENT)\n public class ContentNodeVisitorTest {\n \n-    @FunctionalInterface\n-    private static interface Mutator {\n-\n-        void mutate(Content content, Object value);\n-\n-    }\n-\n-    @FunctionalInterface\n-    private static interface Validator {\n-        default void validate(ContentInfo existing, ContentInfo imported, ContentInfo merged) {\n-            if (this.access(merged) != null) {\n-                if (imported != null && this.access(imported) != null) {\n-                    assertEquals(this.access(imported), this.access(merged));\n-                }\n-                else {\n-                    assertNotNull(existing);\n-                    assertEquals(this.access(existing), this.access(merged));\n-                }\n-            }\n-            else {\n-                if (imported != null) {\n-                    assertNull(this.access(imported));\n-                }\n-\n-                if (existing != null) {\n-                    assertNull(this.access(existing));\n-                }\n-            }\n-        }\n-\n-        Object access(ContentInfo content);\n-    }\n-\n-    @FunctionalInterface\n-    private static interface CollectionValidator extends Validator {\n-        @Override\n-        default void validate(ContentInfo existing, ContentInfo imported, ContentInfo merged) {\n-            if (this.access(merged) != null) {\n-                Collection<Object> actual = this.access(merged);\n-                Collection<Object> expected = null;\n-\n-                if (imported != null && this.access(imported) != null) {\n-                    expected = this.access(imported);\n-                }\n-                else {\n-                    assertNotNull(existing);\n-                    expected = this.access(existing);\n-                }\n-\n-                assertNotNull(expected);\n-                assertEquals(expected.size(), actual.size());\n-\n-                for (Object item : expected) {\n-                    assertThat(actual, hasItem(item));\n-                }\n-            }\n-            else {\n-                if (imported != null) {\n-                    assertNull(this.access(imported));\n-                }\n-\n-                if (existing != null) {\n-                    assertNull(this.access(existing));\n-                }\n-            }\n-        }\n-\n-        @Override\n-        Collection access(ContentInfo content);\n-    }\n-\n-    private Map<String, Mutator> mutators;\n-    private Map<String, Validator> validators;\n+    private Map<String, Mutator<Content>> contentMutators;\n+    private Map<String, Mutator<ContentInfo>> cinfoMutators;", "originalCommit": "7321546e0abbeeaec7f79c47aa4eca3b1dd75dbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4OTY0MA==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r421389640", "bodyText": "Same here, validator not used after retrieving here", "author": "nikosmoum", "createdAt": "2020-05-07T10:05:07Z", "path": "server/src/test/java/org/candlepin/controller/refresher/visitors/ProductNodeVisitorTest.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.controller.refresher.visitors;\n+\n+import org.candlepin.controller.refresher.mappers.NodeMapper;\n+import org.candlepin.controller.refresher.nodes.EntityNode;\n+import org.candlepin.controller.refresher.nodes.ProductNode;\n+import org.candlepin.model.Owner;\n+import org.candlepin.model.OwnerProduct;\n+import org.candlepin.model.OwnerProductCurator;\n+import org.candlepin.model.Product;\n+import org.candlepin.model.ProductCurator;\n+import org.candlepin.service.model.ProductInfo;\n+import org.candlepin.test.TestUtil;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.Mockito;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.junit.jupiter.MockitoSettings;\n+import org.mockito.quality.Strictness;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.jupiter.api.Assertions.*;\n+import static org.mockito.AdditionalAnswers.returnsFirstArg;\n+import static org.mockito.Mockito.*;\n+\n+\n+\n+/**\n+ * Test suite for the ProductNodeVisitor class\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@MockitoSettings(strictness = Strictness.LENIENT)\n+public class ProductNodeVisitorTest {\n+\n+    private Map<String, Mutator<Product>> productMutators;\n+    private Map<String, Mutator<ProductInfo>> pinfoMutators;\n+    private Map<String, MergeValidator<ProductInfo>> validators;\n+\n+    private ProductCurator mockProductCurator;\n+    private OwnerProductCurator mockOwnerProductCurator;\n+    private NodeProcessor mockNodeProcessor;\n+    private NodeMapper mockNodeMapper;\n+\n+    @BeforeEach\n+    public void init() {\n+        this.productMutators = new HashMap<>();\n+        this.productMutators.put(\"name\", (c, v) -> c.setName((String) v));\n+        this.productMutators.put(\"multiplier\", (c, v) -> c.setMultiplier((Long) v));\n+        this.productMutators.put(\"dependent_product_ids\", (c, v) -> c.setDependentProductIds((Collection) v));\n+        this.productMutators.put(\"attributes\", (c, v) -> c.setAttributes((Map) v));\n+        this.productMutators.put(\"product_content\", (c, v) -> c.setProductContent((Collection) v));\n+        this.productMutators.put(\"branding\", (c, v) -> c.setBranding((Collection) v));\n+        this.productMutators.put(\"provided_products\", (c, v) -> c.setProvidedProducts((Collection) v));\n+\n+        this.pinfoMutators = new HashMap<>();\n+        this.pinfoMutators.put(\"name\", (c, v) -> doReturn(v).when(c).getName());\n+        this.pinfoMutators.put(\"multiplier\", (c, v) -> doReturn(v).when(c).getMultiplier());\n+        this.pinfoMutators.put(\"dependent_product_ids\",\n+            (c, v) -> doReturn(v).when(c).getDependentProductIds());\n+        this.pinfoMutators.put(\"attributes\", (c, v) -> doReturn(v).when(c).getAttributes());\n+        this.pinfoMutators.put(\"product_content\", (c, v) -> doReturn(v).when(c).getProductContent());\n+        this.pinfoMutators.put(\"branding\", (c, v) -> doReturn(v).when(c).getBranding());\n+        this.pinfoMutators.put(\"provided_products\", (c, v) -> doReturn(v).when(c).getProvidedProducts());\n+\n+        this.validators = new HashMap<>();\n+        this.validators.put(\"name\", c -> c.getName());\n+        this.validators.put(\"multiplier\", c -> c.getMultiplier());\n+        this.validators.put(\"dependent_product_ids\", (CollectionMergeValidator<ProductInfo>)\n+            c -> c.getDependentProductIds());\n+        this.validators.put(\"attributes\", (MapMergeValidator<ProductInfo>) c -> c.getAttributes());\n+\n+\n+        this.mockProductCurator = mock(ProductCurator.class);\n+        this.mockOwnerProductCurator = mock(OwnerProductCurator.class);\n+        this.mockNodeProcessor = mock(NodeProcessor.class);\n+        this.mockNodeMapper = mock(NodeMapper.class);\n+\n+        doAnswer(returnsFirstArg())\n+            .when(this.mockProductCurator)\n+            .saveOrUpdate(Mockito.any(Product.class));\n+\n+        doAnswer(returnsFirstArg())\n+            .when(this.mockOwnerProductCurator)\n+            .saveOrUpdate(Mockito.any(OwnerProduct.class));\n+    }\n+\n+    public static List<Arguments> productDataProvider() {\n+        Map<String, String> baseAttribs = new HashMap<>();\n+        baseAttribs.put(\"A\", \"1\");\n+        baseAttribs.put(\"B\", \"2\");\n+        baseAttribs.put(\"C\", \"3\");\n+\n+        Map<String, String> updatedAttribs = new HashMap<>();\n+        baseAttribs.put(\"C\", \"3\");\n+        baseAttribs.put(\"D\", \"4\");\n+        baseAttribs.put(\"E\", \"5\");\n+\n+        return Arrays.asList(\n+            Arguments.of(\"name\", \"base_name\", \"updated_name\"),\n+            Arguments.of(\"multiplier\", 12345L, 67890L),\n+            Arguments.of(\"dependent_product_ids\", Arrays.asList(\"1\", \"2\", \"3\"), Arrays.asList(\"A\", \"B\", \"C\")),\n+            Arguments.of(\"attributes\", baseAttribs, updatedAttribs));\n+    }\n+\n+    private ProductNodeVisitor buildProductNodeVisitor() {\n+        return new ProductNodeVisitor(this.mockProductCurator, this.mockOwnerProductCurator);\n+    }\n+\n+    private Product createPopulatedExistingEntity(String id, String key, Object value) {\n+        Product entity = new Product();\n+        entity.setId(id);\n+\n+        Mutator mutator = this.productMutators.get(key);\n+        if (mutator == null) {\n+            throw new IllegalStateException(\"No mutator for key: \" + key);\n+        }\n+\n+        mutator.mutate(entity, value);\n+\n+        return entity;\n+    }\n+\n+    private ProductInfo createPopulatedImportedEntity(String id, String key, Object value) {\n+        ProductInfo entity = mock(ProductInfo.class);\n+        doReturn(id).when(entity).getId();\n+\n+        // Impl note:\n+        // This is necessary, since the default behavior for mocked methods that return primitive\n+        // containers is to return a wrapped default primitive value, *NOT* null as one might\n+        // expect.\n+        doReturn(null).when(entity).getMultiplier();\n+\n+        Mutator mutator = this.pinfoMutators.get(key);\n+        if (mutator == null) {\n+            throw new IllegalStateException(\"No mutator for key: \" + key);\n+        }\n+\n+        mutator.mutate(entity, value);\n+\n+        return entity;\n+    }\n+\n+    private void validateMergedEntity(Product existing, ProductInfo imported, Product merged) {\n+        // Assert that we actually have a merged entity\n+        assertNotNull(merged);\n+\n+        // Ensure the ID is set properly\n+        assertNotNull(merged.getId());\n+\n+        if (existing != null) {\n+            assertNotNull(existing.getId());\n+            assertEquals(existing.getId(), merged.getId());\n+        }\n+\n+        if (imported != null) {\n+            assertNotNull(imported.getId());\n+            assertEquals(imported.getId(), merged.getId());\n+        }\n+\n+        // Check that the product is locked properly\n+        if (existing != null) {\n+            assertEquals(existing.isLocked(), merged.isLocked());\n+        }\n+        else {\n+            assertNotNull(imported);\n+            assertTrue(merged.isLocked());\n+        }\n+\n+        // Check other attributes\n+        for (MergeValidator validator : this.validators.values()) {\n+            validator.validate(existing, imported, merged);\n+        }\n+    }\n+\n+\n+    @Test\n+    public void testGetEntityClass() {\n+        ProductNodeVisitor visitor = this.buildProductNodeVisitor();\n+\n+        assertEquals(Product.class, visitor.getEntityClass());\n+    }\n+\n+    @ParameterizedTest(name = \"{displayName} {index}: {0}\")\n+    @MethodSource(\"productDataProvider\")\n+    public void testProcessNodeForSkippedEntity(String key, Object base, Object update) {\n+        Owner owner = TestUtil.createOwner();\n+        String id = TestUtil.randomString(\"test_id\");\n+\n+        Product existing = this.createPopulatedExistingEntity(id, key, base);\n+\n+        EntityNode<Product, ProductInfo> node = new ProductNode(owner, id)\n+            .setExistingEntity(existing);\n+\n+        ProductNodeVisitor visitor = this.buildProductNodeVisitor();\n+\n+        // Ensure initial node state\n+        assertFalse(node.visited());\n+        assertFalse(node.changed());\n+        assertNull(node.getMergedEntity());\n+\n+        // Visit/process the node\n+        visitor.processNode(this.mockNodeProcessor, this.mockNodeMapper, node);\n+        visitor.complete();\n+\n+        // Validate \"processed\" state\n+        assertTrue(node.visited());\n+        assertFalse(node.changed());\n+        assertNull(node.getMergedEntity());\n+    }\n+\n+    @ParameterizedTest(name = \"{displayName} {index}: {0}\")\n+    @MethodSource(\"productDataProvider\")\n+    public void testProcessNodeForUnmodifiedEntity(String key, Object base, Object update) {\n+        Owner owner = TestUtil.createOwner();\n+        String id = TestUtil.randomString(\"test_id\");\n+\n+        Product existing = this.createPopulatedExistingEntity(id, key, base);\n+        ProductInfo imported = this.createPopulatedImportedEntity(id, key, null);\n+\n+        EntityNode<Product, ProductInfo> node = new ProductNode(owner, id)\n+            .setExistingEntity(existing)\n+            .setImportedEntity(imported);\n+\n+        ProductNodeVisitor visitor = this.buildProductNodeVisitor();\n+\n+        // Ensure initial node state\n+        assertFalse(node.visited());\n+        assertFalse(node.changed());\n+        assertNull(node.getMergedEntity());\n+\n+        // Visit/process the node\n+        visitor.processNode(this.mockNodeProcessor, this.mockNodeMapper, node);\n+        visitor.complete();\n+\n+        // Validate \"processed\" state\n+        assertTrue(node.visited());\n+        assertFalse(node.changed());\n+        assertNull(node.getMergedEntity());\n+    }\n+\n+    @ParameterizedTest(name = \"{displayName} {index}: {0}\")\n+    @MethodSource(\"productDataProvider\")\n+    public void testProcessNodeForUnchangedEntity(String key, Object base, Object update) {\n+        Owner owner = TestUtil.createOwner();\n+        String id = TestUtil.randomString(\"test_id\");\n+\n+        Product existing = this.createPopulatedExistingEntity(id, key, base);\n+        ProductInfo imported = this.createPopulatedImportedEntity(id, key, base);\n+\n+        MergeValidator<ProductInfo> validator = this.validators.get(key);", "originalCommit": "7321546e0abbeeaec7f79c47aa4eca3b1dd75dbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUzNTYzNg==", "url": "https://github.com/candlepin/candlepin/pull/2685#discussion_r421535636", "bodyText": "Fixed", "author": "Ceiu", "createdAt": "2020-05-07T14:11:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM4OTY0MA=="}], "type": "inlineReview"}, {"oid": "3006213a170f9e614fb0554698a88f5354ec2750", "url": "https://github.com/candlepin/candlepin/commit/3006213a170f9e614fb0554698a88f5354ec2750", "message": "(SQUASH ME) Added tests for the RefreshResult and RefreshWorker classes", "committedDate": "2020-05-11T20:52:10Z", "type": "forcePushed"}, {"oid": "0fdb8357fbbbc3a83de7b57d691808b9cc682078", "url": "https://github.com/candlepin/candlepin/commit/0fdb8357fbbbc3a83de7b57d691808b9cc682078", "message": "Added the RefreshWorker framework and refactored the refresh process\n\n- Added the RefreshWorker and the org.candlepin.controller.refresher.*\n  package containing the new framework for performing refresh\n- Updated the CandlepinPoolManager to use the new refresh framework\n- Added the upstream_subscription_injector tool for setting up a\n  Candlepin instance for repeatable upstream testing\n- Fixed the test data setup in the tests for OwnerProductResource\n- Fixed a NPE bug in Subscription when calling isStacked without\n  a product\n- Added additional validation to the hosted-test subscription\n  adapter to ensure subscriptions cannot be created without a\n  product\n- Improved several API methods in the hosted test spec resources\n- Fixed refresh spec tests broken by changes to the hosted test APIs", "committedDate": "2020-05-11T20:56:28Z", "type": "commit"}, {"oid": "0fdb8357fbbbc3a83de7b57d691808b9cc682078", "url": "https://github.com/candlepin/candlepin/commit/0fdb8357fbbbc3a83de7b57d691808b9cc682078", "message": "Added the RefreshWorker framework and refactored the refresh process\n\n- Added the RefreshWorker and the org.candlepin.controller.refresher.*\n  package containing the new framework for performing refresh\n- Updated the CandlepinPoolManager to use the new refresh framework\n- Added the upstream_subscription_injector tool for setting up a\n  Candlepin instance for repeatable upstream testing\n- Fixed the test data setup in the tests for OwnerProductResource\n- Fixed a NPE bug in Subscription when calling isStacked without\n  a product\n- Added additional validation to the hosted-test subscription\n  adapter to ensure subscriptions cannot be created without a\n  product\n- Improved several API methods in the hosted test spec resources\n- Fixed refresh spec tests broken by changes to the hosted test APIs", "committedDate": "2020-05-11T20:56:28Z", "type": "forcePushed"}]}