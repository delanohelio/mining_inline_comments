{"pr_number": 2767, "pr_title": "[M] Fixed a race condition with messaging session committal in the job system (ENT-2679)", "pr_createdAt": "2020-07-28T21:26:45Z", "pr_url": "https://github.com/candlepin/candlepin/pull/2767", "timeline": [{"oid": "55ca72efa1f9f04eeede24b917cf14446efde481", "url": "https://github.com/candlepin/candlepin/commit/55ca72efa1f9f04eeede24b917cf14446efde481", "message": "Fixed a race condition with messaging session committal in the job system\n\n- Fixed a race condition with messaging session committal that could\n  occur if two threads queue a job at the same time: the first thread\n  to complete its database transaction would commit the messaging\n  session shared by both, causing both job messages to be sent and\n  potentially picked up before the second thread's database session\n  had finished persisting the job status", "committedDate": "2020-07-28T21:29:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1NjQwOA==", "url": "https://github.com/candlepin/candlepin/pull/2767#discussion_r462256408", "bodyText": "Redundant try-catch", "author": "Januson", "createdAt": "2020-07-29T12:21:52Z", "path": "server/src/test/java/org/candlepin/async/JobMessageDispatcherTest.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+package org.candlepin.async;\n+\n+import static org.mockito.Mockito.any;\n+import static org.mockito.Mockito.anyBoolean;\n+import static org.mockito.Mockito.anyString;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+import org.candlepin.common.config.Configuration;\n+import org.candlepin.config.CandlepinCommonTestConfig;\n+import org.candlepin.messaging.CPMMessage;\n+import org.candlepin.messaging.CPMProducer;\n+import org.candlepin.messaging.CPMProducerConfig;\n+import org.candlepin.messaging.CPMSession;\n+import org.candlepin.messaging.CPMSessionConfig;\n+import org.candlepin.messaging.CPMSessionFactory;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+import org.mockito.junit.jupiter.MockitoSettings;\n+import org.mockito.quality.Strictness;\n+\n+\n+\n+/**\n+ * Test suite for the JobMessageDispatcher class\n+ */\n+@ExtendWith(MockitoExtension.class)\n+@MockitoSettings(strictness = Strictness.LENIENT)\n+public class JobMessageDispatcherTest {\n+\n+    /**\n+     * Functional interface that lets us pass exceptions back through to the test\n+     */\n+    @FunctionalInterface\n+    private interface NoisyRunnable {\n+        void run() throws Exception;\n+    }\n+\n+    /**\n+     * Utility class to allow async scheduling of tasks in a targetable thread\n+     */\n+    private static class TaskExecutor extends Thread {\n+        private boolean shutdown;\n+        private NoisyRunnable runnable;\n+\n+        public TaskExecutor() {\n+            this.shutdown = false;\n+            this.runnable = null;\n+\n+            this.setDaemon(true);\n+            this.start();\n+\n+            try {\n+                synchronized (this) {\n+                    this.wait(1000);\n+                }\n+            }\n+            catch (InterruptedException e) {\n+                // Hrmm...\n+            }\n+        }\n+\n+        public synchronized void run() {\n+            while (!this.shutdown) {\n+                try {\n+                    this.notifyAll();\n+                    this.wait();\n+\n+                    if (this.runnable != null) {\n+                        this.runnable.run();\n+                    }\n+                }\n+                catch (InterruptedException e) {\n+                    // Wake up\n+                }\n+                catch (Exception e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        }\n+\n+        public synchronized TaskExecutor execute(NoisyRunnable runnable) throws InterruptedException {\n+            this.runnable = runnable;\n+\n+            this.notifyAll();\n+            this.wait();\n+\n+            return this;\n+        }\n+\n+        public synchronized TaskExecutor shutdown() throws InterruptedException {\n+            this.shutdown = true;\n+            this.runnable = null;\n+\n+            this.notifyAll();\n+            this.join();\n+\n+            return this;\n+        }\n+    }\n+\n+\n+    private Configuration config;\n+    private ObjectMapper mapper;\n+\n+    private CPMSessionFactory sessionFactory;\n+    private CPMSessionConfig sessionConfig;\n+    private CPMProducerConfig producerConfig;\n+\n+\n+    @BeforeEach\n+    public void init() {\n+        this.config = new CandlepinCommonTestConfig();\n+        this.mapper = new ObjectMapper();\n+\n+        this.sessionFactory = mock(CPMSessionFactory.class);\n+        this.sessionConfig = spy(new CPMSessionConfig());\n+        this.producerConfig = spy(new CPMProducerConfig());\n+\n+        doReturn(this.sessionConfig).when(this.sessionFactory).createSessionConfig();\n+    }\n+\n+    private JobMessageDispatcher buildJobMessageDispatcher() {\n+        return new JobMessageDispatcher(this.config, this.sessionFactory, this.mapper);\n+    }\n+\n+    private CPMSession mockCPMSession() throws Exception {\n+        CPMSession session = mock(CPMSession.class);\n+        CPMMessage message = this.mockCPMMessage();\n+\n+        doReturn(this.producerConfig).when(session).createProducerConfig();\n+        doReturn(false).when(session).isClosed();\n+        doReturn(message).when(session).createMessage();\n+\n+        return session;\n+    }\n+\n+    private CPMMessage mockCPMMessage() throws Exception {\n+        CPMMessage message = mock(CPMMessage.class);\n+\n+        doReturn(message).when(message).setDurable(anyBoolean());\n+        doReturn(message).when(message).setBody(anyString());\n+        doReturn(message).when(message).setProperty(anyString(), anyString());\n+\n+        return message;\n+    }\n+\n+    @Test\n+    public void testThreadsReuseSessions() throws Exception {\n+        JobMessageDispatcher dispatcher = this.buildJobMessageDispatcher();\n+\n+        CPMSession session = this.mockCPMSession();\n+        CPMProducer producer = mock(CPMProducer.class);\n+\n+        doReturn(session).when(this.sessionFactory).createSession(any(CPMSessionConfig.class));\n+        doReturn(producer).when(session).createProducer(any(CPMProducerConfig.class));\n+\n+        dispatcher.postJobMessage(new JobMessage(\"job_id-1\", \"job_key-1\"));\n+        dispatcher.commit();\n+\n+        dispatcher.postJobMessage(new JobMessage(\"job_id-2\", \"job_key-2\"));\n+        dispatcher.rollback();\n+\n+        verify(this.sessionFactory, times(1)).createSession(any(CPMSessionConfig.class));\n+        verify(session, times(1)).createProducer(any(CPMProducerConfig.class));\n+\n+        verify(producer, times(2)).send(anyString(), any(CPMMessage.class));\n+        verify(session, times(1)).commit();\n+        verify(session, times(1)).rollback();\n+    }\n+\n+    @Test\n+    public void testThreadsDontShareSessions() throws Exception {\n+        JobMessageDispatcher dispatcher = this.buildJobMessageDispatcher();\n+\n+        CPMSession session1 = this.mockCPMSession();\n+        CPMSession session2 = this.mockCPMSession();\n+        CPMProducer producer1 = mock(CPMProducer.class);\n+        CPMProducer producer2 = mock(CPMProducer.class);\n+\n+        doReturn(producer1).when(session1).createProducer(any(CPMProducerConfig.class));\n+        doReturn(producer2).when(session2).createProducer(any(CPMProducerConfig.class));\n+\n+        doReturn(session1, session2).when(this.sessionFactory).createSession(any(CPMSessionConfig.class));\n+\n+        TaskExecutor executor1 = new TaskExecutor();\n+        TaskExecutor executor2 = new TaskExecutor();\n+\n+        executor1.execute(() -> dispatcher.postJobMessage(new JobMessage(\"job_id-1\", \"job_key-1\")));\n+        executor2.execute(() -> dispatcher.postJobMessage(new JobMessage(\"job_id-2\", \"job_key-2\")));\n+        executor1.execute(() -> dispatcher.commit());\n+        executor2.execute(() -> dispatcher.commit());\n+\n+        executor1.shutdown();\n+        executor2.shutdown();\n+\n+        verify(this.sessionFactory, times(2)).createSession(any(CPMSessionConfig.class));\n+\n+        verify(session1, times(1)).createProducer(any(CPMProducerConfig.class));\n+        verify(session2, times(1)).createProducer(any(CPMProducerConfig.class));\n+        verify(producer1, times(1)).send(anyString(), any(CPMMessage.class));\n+        verify(producer2, times(1)).send(anyString(), any(CPMMessage.class));\n+        verify(session1, times(1)).commit();\n+        verify(session2, times(1)).commit();\n+    }\n+\n+    @Test\n+    public void testAbandonedSessionsAreClosed() throws Exception {\n+        JobMessageDispatcher dispatcher = this.buildJobMessageDispatcher();\n+\n+        CPMSession session = this.mockCPMSession();\n+        CPMProducer producer = mock(CPMProducer.class);\n+\n+        doReturn(session).when(this.sessionFactory).createSession(any(CPMSessionConfig.class));\n+        doReturn(producer).when(session).createProducer(any(CPMProducerConfig.class));\n+\n+        TaskExecutor executor = new TaskExecutor();\n+\n+        try {", "originalCommit": "55ca72efa1f9f04eeede24b917cf14446efde481", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI5MDc1Mg==", "url": "https://github.com/candlepin/candlepin/pull/2767#discussion_r462290752", "bodyText": "Fixed", "author": "Ceiu", "createdAt": "2020-07-29T13:18:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI1NjQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2MDAwMw==", "url": "https://github.com/candlepin/candlepin/pull/2767#discussion_r462260003", "bodyText": "Not a part of your changes but there is an unused dependency.", "author": "Januson", "createdAt": "2020-07-29T12:28:31Z", "path": "server/src/main/java/org/candlepin/async/JobMessageDispatcher.java", "diffHunk": "@@ -44,12 +49,158 @@\n     private static final String JOB_KEY_MESSAGE_PROPERTY = \"job_key\";\n     private static final String JOB_MESSAGE_ADDRESS = \"job\";\n \n+    /**\n+     * The ThreadSessionStore is used to store session information per thread.\n+     */\n+    private static final class ThreadSessionStore {\n+        private final CPMSessionFactory sessionFactory;\n+\n+        private CPMSession session;\n+        private CPMProducer producer;\n+\n+        /**\n+         * Creates a new ThreadSessionStore which will use the given session factory to create new\n+         * sessions as necessary.\n+         *\n+         * @param sessionFactory\n+         *  the CPMSessionFactory instance to use to create new sessions\n+         *\n+         * @throws IllegalArgumentException\n+         *  if sessionFactory is null\n+         */\n+        public ThreadSessionStore(CPMSessionFactory sessionFactory) {\n+            if (sessionFactory == null) {\n+                throw new IllegalArgumentException(\"sessionFactory is null\");\n+            }\n+\n+            this.sessionFactory = sessionFactory;\n+        }\n+\n+        /**\n+         * Fetches the current CPM session, creating a new one if necessary.\n+         *\n+         * @return\n+         *  a CPMSession instance\n+         */\n+        public CPMSession getSession() throws CPMException {\n+            if (this.session == null || this.session.isClosed()) {\n+                log.debug(\"Creating new CPM session for job message dispatch for thread {}\",\n+                    Thread.currentThread());\n+\n+                CPMSessionConfig config = this.sessionFactory.createSessionConfig()\n+                    .setTransactional(true);\n+\n+                // Add any other job-system-specific session configuration here\n+\n+                this.session = this.sessionFactory.createSession(config);\n+                this.session.start();\n+\n+                log.debug(\"Created new CPM session: {}\", this.session);\n+            }\n+\n+            return this.session;\n+        }\n+\n+        /**\n+         * Fetches the current CPM producer, creating a new one if necessary.\n+         *\n+         * @return\n+         *  a CPMProducer instance\n+         */\n+        public CPMProducer getProducer() throws CPMException {\n+            if (this.producer == null || this.producer.isClosed()) {\n+                log.debug(\"Creating new CPM producer for job message dispatch for thread {}\",\n+                    Thread.currentThread());\n+\n+                CPMSession session = this.getSession();\n+                CPMProducerConfig config = session.createProducerConfig();\n+\n+                // Add any other job-system-specific producer configuration here\n+\n+                this.producer = session.createProducer(config);\n+\n+                log.debug(\"Created new CPM producer: {}\", this.producer);\n+            }\n+\n+            return this.producer;\n+        }\n+\n+        /**\n+         * Closes any session resources this session store may have open\n+         */\n+        private void close() throws CPMException {\n+            if (this.producer != null) {\n+                this.producer.close();\n+                this.producer = null;\n+            }\n+\n+            if (this.session != null) {\n+                this.session.close();\n+                this.session = null;\n+            }\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public String toString() {\n+            return String.format(\"ThreadSessionStore [session: %s, producer: %s]\",\n+                this.session, this.producer);\n+        }\n+    }\n+\n+    /**\n+     * The ThreadReference class is a WeakReference implementation with stable equals and hashCode\n+     * methods, allowing it to be used as a key in maps and in sets.\n+     */\n+    private class ThreadReference extends WeakReference<Thread> {\n+        private final int hashCode;\n+\n+        public ThreadReference(Thread thread, ReferenceQueue<? super Thread> queue) {\n+            super(thread, queue);\n+\n+            this.hashCode = thread != null ? thread.hashCode() : 0;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean equals(Object cmp) {\n+            if (cmp == this) {\n+                return true;\n+            }\n+\n+            if (cmp instanceof ThreadReference) {\n+                Thread lhs = this.get();\n+                Thread rhs = ((ThreadReference) cmp).get();\n+\n+                return lhs != null ?\n+                    lhs.equals(rhs) :\n+                    rhs == null && this.hashCode() == ((ThreadReference) cmp).hashCode();\n+            }\n+\n+            return false;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public int hashCode() {\n+            return this.hashCode;\n+        }\n+    }\n+\n+\n+\n     private final Configuration config;", "originalCommit": "55ca72efa1f9f04eeede24b917cf14446efde481", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI5MDc3OA==", "url": "https://github.com/candlepin/candlepin/pull/2767#discussion_r462290778", "bodyText": "Fixed", "author": "Ceiu", "createdAt": "2020-07-29T13:18:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2MDAwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2MDE4OA==", "url": "https://github.com/candlepin/candlepin/pull/2767#discussion_r462260188", "bodyText": "Redundant cast", "author": "Januson", "createdAt": "2020-07-29T12:28:51Z", "path": "server/src/main/java/org/candlepin/async/JobMessageDispatcher.java", "diffHunk": "@@ -44,12 +49,158 @@\n     private static final String JOB_KEY_MESSAGE_PROPERTY = \"job_key\";\n     private static final String JOB_MESSAGE_ADDRESS = \"job\";\n \n+    /**\n+     * The ThreadSessionStore is used to store session information per thread.\n+     */\n+    private static final class ThreadSessionStore {\n+        private final CPMSessionFactory sessionFactory;\n+\n+        private CPMSession session;\n+        private CPMProducer producer;\n+\n+        /**\n+         * Creates a new ThreadSessionStore which will use the given session factory to create new\n+         * sessions as necessary.\n+         *\n+         * @param sessionFactory\n+         *  the CPMSessionFactory instance to use to create new sessions\n+         *\n+         * @throws IllegalArgumentException\n+         *  if sessionFactory is null\n+         */\n+        public ThreadSessionStore(CPMSessionFactory sessionFactory) {\n+            if (sessionFactory == null) {\n+                throw new IllegalArgumentException(\"sessionFactory is null\");\n+            }\n+\n+            this.sessionFactory = sessionFactory;\n+        }\n+\n+        /**\n+         * Fetches the current CPM session, creating a new one if necessary.\n+         *\n+         * @return\n+         *  a CPMSession instance\n+         */\n+        public CPMSession getSession() throws CPMException {\n+            if (this.session == null || this.session.isClosed()) {\n+                log.debug(\"Creating new CPM session for job message dispatch for thread {}\",\n+                    Thread.currentThread());\n+\n+                CPMSessionConfig config = this.sessionFactory.createSessionConfig()\n+                    .setTransactional(true);\n+\n+                // Add any other job-system-specific session configuration here\n+\n+                this.session = this.sessionFactory.createSession(config);\n+                this.session.start();\n+\n+                log.debug(\"Created new CPM session: {}\", this.session);\n+            }\n+\n+            return this.session;\n+        }\n+\n+        /**\n+         * Fetches the current CPM producer, creating a new one if necessary.\n+         *\n+         * @return\n+         *  a CPMProducer instance\n+         */\n+        public CPMProducer getProducer() throws CPMException {\n+            if (this.producer == null || this.producer.isClosed()) {\n+                log.debug(\"Creating new CPM producer for job message dispatch for thread {}\",\n+                    Thread.currentThread());\n+\n+                CPMSession session = this.getSession();\n+                CPMProducerConfig config = session.createProducerConfig();\n+\n+                // Add any other job-system-specific producer configuration here\n+\n+                this.producer = session.createProducer(config);\n+\n+                log.debug(\"Created new CPM producer: {}\", this.producer);\n+            }\n+\n+            return this.producer;\n+        }\n+\n+        /**\n+         * Closes any session resources this session store may have open\n+         */\n+        private void close() throws CPMException {\n+            if (this.producer != null) {\n+                this.producer.close();\n+                this.producer = null;\n+            }\n+\n+            if (this.session != null) {\n+                this.session.close();\n+                this.session = null;\n+            }\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public String toString() {\n+            return String.format(\"ThreadSessionStore [session: %s, producer: %s]\",\n+                this.session, this.producer);\n+        }\n+    }\n+\n+    /**\n+     * The ThreadReference class is a WeakReference implementation with stable equals and hashCode\n+     * methods, allowing it to be used as a key in maps and in sets.\n+     */\n+    private class ThreadReference extends WeakReference<Thread> {\n+        private final int hashCode;\n+\n+        public ThreadReference(Thread thread, ReferenceQueue<? super Thread> queue) {\n+            super(thread, queue);\n+\n+            this.hashCode = thread != null ? thread.hashCode() : 0;\n+        }\n+\n+        /**\n+         * {@inheritDoc}\n+         */\n+        @Override\n+        public boolean equals(Object cmp) {\n+            if (cmp == this) {\n+                return true;\n+            }\n+\n+            if (cmp instanceof ThreadReference) {\n+                Thread lhs = this.get();\n+                Thread rhs = ((ThreadReference) cmp).get();\n+\n+                return lhs != null ?\n+                    lhs.equals(rhs) :\n+                    rhs == null && this.hashCode() == ((ThreadReference) cmp).hashCode();", "originalCommit": "55ca72efa1f9f04eeede24b917cf14446efde481", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI5MDc5OA==", "url": "https://github.com/candlepin/candlepin/pull/2767#discussion_r462290798", "bodyText": "Fixed", "author": "Ceiu", "createdAt": "2020-07-29T13:18:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI2MDE4OA=="}], "type": "inlineReview"}, {"oid": "b858aa603aa695dddaea814003b8e697633221bc", "url": "https://github.com/candlepin/candlepin/commit/b858aa603aa695dddaea814003b8e697633221bc", "message": "Fixed a race condition with messaging session committal in the job system\n\n- Fixed a race condition with messaging session committal that could\n  occur if two threads queue a job at the same time: the first thread\n  to complete its database transaction would commit the messaging\n  session shared by both, causing both job messages to be sent and\n  potentially picked up before the second thread's database session\n  had finished persisting the job status", "committedDate": "2020-07-29T13:21:12Z", "type": "commit"}, {"oid": "b858aa603aa695dddaea814003b8e697633221bc", "url": "https://github.com/candlepin/candlepin/commit/b858aa603aa695dddaea814003b8e697633221bc", "message": "Fixed a race condition with messaging session committal in the job system\n\n- Fixed a race condition with messaging session committal that could\n  occur if two threads queue a job at the same time: the first thread\n  to complete its database transaction would commit the messaging\n  session shared by both, causing both job messages to be sent and\n  potentially picked up before the second thread's database session\n  had finished persisting the job status", "committedDate": "2020-07-29T13:21:12Z", "type": "forcePushed"}]}