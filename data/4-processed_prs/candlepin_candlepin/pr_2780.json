{"pr_number": 2780, "pr_title": "1868383: Default repositories are not enabled, after registering a client with an Activation Key, to an org with Simple Content Access Mode in Red Hat Satellite 6 (ENT - 2742)", "pr_createdAt": "2020-08-24T05:41:18Z", "pr_url": "https://github.com/candlepin/candlepin/pull/2780", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyODk3MA==", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r476428970", "bodyText": "If we're adding content with the same ID to a given product twice, it will overwrite the previous instance with the new one. I would expect that this results in the enabled flag being set to whatever comes in last, rather than both existing on the product.\nAside from that, I don't understand the intent behind adding it as a disabled content if it's already present. In this case, the resultant behavior we want is for the content to be available if something has enabled it. Adding a disabled version of the content as well will only serve as a stumbling block for any processing that occurs after this step.\nIn the event we have an organization that has multiple sources of a given content with mixed enablement, I would expect the \"enabled\" version to win out. We could even fetch that set of content pretty easily with a new query that only fetches enabled content for a given owner.", "author": "Ceiu", "createdAt": "2020-08-25T12:59:46Z", "path": "server/src/main/java/org/candlepin/controller/ContentAccessManager.java", "diffHunk": "@@ -525,8 +524,19 @@ private String createDN(Consumer consumer, Owner owner) {\n         containerSet.add(container);\n         container.setId(\"content_access\");\n         container.setName(\" Content Access\");\n-        for (Content c : ownerContent) {\n-            container.addContent(c, false);\n+        Set<String> contentUuids = new HashSet<>();\n+\n+        for (Product product : ownerProduct) {\n+            for (ProductContent pc : product.getProductContent()) {\n+                if (contentUuids.contains(pc.getContent().getUuid())) {", "originalCommit": "564c4d608e24e8461a2f838e2aaeea5170692344", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA1NDM0Nw==", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r477054347", "bodyText": "I was not sure what should be the expected behavior with mix content enablement, I have already asked PM's about it\nand waiting for a reply. Modified the code to make sure that the \"enabled\" version win out.\nI noticed that content can exist without product, when we query owner-content we get unwanted content, so decided to go via owner-product (and ideally it should be content of product with active pool, there was some work in that area with ENT-2352, not sure if it is there in master branch)", "author": "wolfdale", "createdAt": "2020-08-26T06:05:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyODk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIzODcxMQ==", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r477238711", "bodyText": "In non-SCA mode, we simply return duplicates (or more) of the same content that might be enabled or disabled, but that's because they come from different entitlement certs. I wonder what happens on the client side in that case (the client tools guys can help here). Do we actually end up with duplicate entries in redhat.repo?", "author": "nikosmoum", "createdAt": "2020-08-26T11:47:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyODk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU1OTMwNg==", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r477559306", "bodyText": "@cnsnyder @jirihnidek ^^\nI think I recall seeing discussion that it ends up being that if duplicates exist, then the first found is what is used; which is probably not desired overall (undefined behavior is bad behavior). If that's the case, then I think we should get some PMs involved, figure out what they expect, and then determine where the new behavior should be. I expect that it'll mostly fall to CP to generate something a tad more sane, since subman is already implementing a contingency plan, even if that implementation isn't optimal or deterministic.", "author": "Ceiu", "createdAt": "2020-08-26T20:08:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyODk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzU2MDM5Nw==", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r477560397", "bodyText": "Also, regardless, this branch is a bit special, since everything is being added to a single product. That in itself is causing deduplication work done elsewhere to keep the last update received (Product.addContent -> Product.addProductContent).\nSo really, the ask here is what PMs expect in the case of multiple entitlements providing a given content in different states of enablement.", "author": "Ceiu", "createdAt": "2020-08-26T20:10:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQyODk3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI4MTUwOA==", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r476281508", "bodyText": "we should not use the .should statement because it's deprecated. let's use expect().to/to_not eq()\nSame thing for the few places further down that .should is used", "author": "nikosmoum", "createdAt": "2020-08-25T08:44:32Z", "path": "server/spec/content_access_spec.rb", "diffHunk": "@@ -558,4 +558,94 @@ def read_json_file(filename)\n     expect(content['vendor']).to eq(@content.vendor)\n     expect(content['path']).to eq(@content.contentUrl)\n   end\n+\n+  it 'should honour the content defaults for owner in SCA mode' do\n+    product = create_product('test-product-p1', 'some product-p1')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c1['id'], true)\n+\n+    # Content enabled = false\n+    content_c2 = @cp.create_content(\n+        @owner['key'], \"cname-c2\", 'test-content-c2', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c2['id'], false)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1", "originalCommit": "564c4d608e24e8461a2f838e2aaeea5170692344", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA1Mjc4OQ==", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r477052789", "bodyText": "Fixed.", "author": "wolfdale", "createdAt": "2020-08-26T06:00:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI4MTUwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM2NDcwOA==", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r476364708", "bodyText": "Let's add a length check here in addition to this loop, that will make sure there's 3 contents, because this test might silently pass if (for whatever reason) the 2 contents you created explicitly are not present in the certificate", "author": "nikosmoum", "createdAt": "2020-08-25T11:07:24Z", "path": "server/spec/content_access_spec.rb", "diffHunk": "@@ -558,4 +558,94 @@ def read_json_file(filename)\n     expect(content['vendor']).to eq(@content.vendor)\n     expect(content['path']).to eq(@content.contentUrl)\n   end\n+\n+  it 'should honour the content defaults for owner in SCA mode' do\n+    product = create_product('test-product-p1', 'some product-p1')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c1['id'], true)\n+\n+    # Content enabled = false\n+    content_c2 = @cp.create_content(\n+        @owner['key'], \"cname-c2\", 'test-content-c2', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c2['id'], false)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1\n+    cert = certs[0]['cert']\n+    json_body = extract_payload(cert)\n+    # Check content status\n+    json_body['products'][0]['content'].each do |content|", "originalCommit": "564c4d608e24e8461a2f838e2aaeea5170692344", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA1MjgwOQ==", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r477052809", "bodyText": "Right. Added length check.", "author": "wolfdale", "createdAt": "2020-08-26T06:00:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM2NDcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM5MTk3OQ==", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r476391979", "bodyText": "Is that an actual use case?? Can't imagine why we would want to do that.", "author": "nikosmoum", "createdAt": "2020-08-25T11:57:29Z", "path": "server/spec/content_access_spec.rb", "diffHunk": "@@ -558,4 +558,94 @@ def read_json_file(filename)\n     expect(content['vendor']).to eq(@content.vendor)\n     expect(content['path']).to eq(@content.contentUrl)\n   end\n+\n+  it 'should honour the content defaults for owner in SCA mode' do\n+    product = create_product('test-product-p1', 'some product-p1')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c1['id'], true)\n+\n+    # Content enabled = false\n+    content_c2 = @cp.create_content(\n+        @owner['key'], \"cname-c2\", 'test-content-c2', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c2['id'], false)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1\n+    cert = certs[0]['cert']\n+    json_body = extract_payload(cert)\n+    # Check content status\n+    json_body['products'][0]['content'].each do |content|\n+      if content.id == content_c1.id\n+        expect(content.enabled).to be_nil\n+      end\n+      if content.id == content_c2.id\n+        expect(content.enabled).to eq(false)\n+      end\n+    end\n+  end\n+\n+  it 'filter out content not promoted to environment when owner is in SCA mode' do\n+    @env = @org_admin.create_environment(@owner['key'], 'testenv1', \"My Test Env 1\", \"For test systems only.\")\n+    consumer = @org_admin.register(random_string('testsystem'), :system, nil,\n+      {'system.certificate_version' => '3.1'}, nil, nil, [], [], @env['id'])\n+    consumer['environment'].should_not be_nil\n+    consumer_cp = Candlepin.new(nil, nil, consumer['idCert']['cert'], consumer['idCert']['key'])\n+\n+    product = create_product\n+    content = create_content # promoted\n+    content2 = create_content # not promoted\n+    # content enabled = true\n+    @cp.add_content_to_product(@owner['key'], product['id'], content['id'], true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content2['id'], true)\n+\n+    # Promote content with enabled false\n+    job = @org_admin.promote_content(@env['id'],\n+    [{\n+      :contentId => content['id'],\n+      :enabled => false ,\n+     }])\n+    wait_for_job(job['id'], 15)\n+\n+    pool = create_pool_and_subscription(@owner['key'], product['id'], 10)\n+    ent = consumer_cp.consume_pool(pool['id'], {:quantity => 1})[0]\n+    value = extension_from_cert(ent['certificates'][0]['cert'], \"1.3.6.1.4.1.2312.9.6\")\n+    value.should == \"3.4\"\n+    json_body = extract_payload(ent['certificates'][0]['cert'])\n+\n+    json_body['products'][0]['content'].size.should == 1\n+    json_body['products'][0]['content'][0]['id'].should == content['id']\n+    json_body['products'][0]['content'][0]['enabled'].should == false\n+  end\n+\n+  it 'should disable content for owner in SCA when associated with multiple products' do", "originalCommit": "564c4d608e24e8461a2f838e2aaeea5170692344", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA1NzU5OA==", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r477057598", "bodyText": "This was suppose to be a test for mixed content enablement. I have made some modification to make sure in such cases enabled content wins out even if its disabled in rest of the associated products.", "author": "wolfdale", "createdAt": "2020-08-26T06:14:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjM5MTk3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwMjAyMw==", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r476402023", "bodyText": "Same here, we should check there's at least 2 contents", "author": "nikosmoum", "createdAt": "2020-08-25T12:16:31Z", "path": "server/spec/content_access_spec.rb", "diffHunk": "@@ -558,4 +558,94 @@ def read_json_file(filename)\n     expect(content['vendor']).to eq(@content.vendor)\n     expect(content['path']).to eq(@content.contentUrl)\n   end\n+\n+  it 'should honour the content defaults for owner in SCA mode' do\n+    product = create_product('test-product-p1', 'some product-p1')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c1['id'], true)\n+\n+    # Content enabled = false\n+    content_c2 = @cp.create_content(\n+        @owner['key'], \"cname-c2\", 'test-content-c2', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c2['id'], false)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1\n+    cert = certs[0]['cert']\n+    json_body = extract_payload(cert)\n+    # Check content status\n+    json_body['products'][0]['content'].each do |content|\n+      if content.id == content_c1.id\n+        expect(content.enabled).to be_nil\n+      end\n+      if content.id == content_c2.id\n+        expect(content.enabled).to eq(false)\n+      end\n+    end\n+  end\n+\n+  it 'filter out content not promoted to environment when owner is in SCA mode' do\n+    @env = @org_admin.create_environment(@owner['key'], 'testenv1', \"My Test Env 1\", \"For test systems only.\")\n+    consumer = @org_admin.register(random_string('testsystem'), :system, nil,\n+      {'system.certificate_version' => '3.1'}, nil, nil, [], [], @env['id'])\n+    consumer['environment'].should_not be_nil\n+    consumer_cp = Candlepin.new(nil, nil, consumer['idCert']['cert'], consumer['idCert']['key'])\n+\n+    product = create_product\n+    content = create_content # promoted\n+    content2 = create_content # not promoted\n+    # content enabled = true\n+    @cp.add_content_to_product(@owner['key'], product['id'], content['id'], true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content2['id'], true)\n+\n+    # Promote content with enabled false\n+    job = @org_admin.promote_content(@env['id'],\n+    [{\n+      :contentId => content['id'],\n+      :enabled => false ,\n+     }])\n+    wait_for_job(job['id'], 15)\n+\n+    pool = create_pool_and_subscription(@owner['key'], product['id'], 10)\n+    ent = consumer_cp.consume_pool(pool['id'], {:quantity => 1})[0]\n+    value = extension_from_cert(ent['certificates'][0]['cert'], \"1.3.6.1.4.1.2312.9.6\")\n+    value.should == \"3.4\"\n+    json_body = extract_payload(ent['certificates'][0]['cert'])\n+\n+    json_body['products'][0]['content'].size.should == 1\n+    json_body['products'][0]['content'][0]['id'].should == content['id']\n+    json_body['products'][0]['content'][0]['enabled'].should == false\n+  end\n+\n+  it 'should disable content for owner in SCA when associated with multiple products' do\n+    product_1 = create_product('test-product-p1', 'some product-p1')\n+    product_2 = create_product('test-product-p2', 'some product-p2')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+\n+    @cp.add_content_to_product(@owner['key'], product_1['id'], content_c1['id'], true)\n+    @cp.add_content_to_product(@owner['key'], product_2['id'], content_c1['id'], true)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1\n+    cert = certs[0]['cert']\n+    json_body = extract_payload(cert)\n+\n+    json_body['products'][0]['content'].each do |content|", "originalCommit": "564c4d608e24e8461a2f838e2aaeea5170692344", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzA1MjgyNw==", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r477052827", "bodyText": "Added.", "author": "wolfdale", "createdAt": "2020-08-26T06:00:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQwMjAyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjQzNTAwOQ==", "url": "https://github.com/candlepin/candlepin/pull/2780#discussion_r476435009", "bodyText": "This is weird. If a content is enabled, we should expect true here, not false, but it doesn't look like this is caused by your changes. I'll look more into this", "author": "nikosmoum", "createdAt": "2020-08-25T13:09:28Z", "path": "server/spec/content_access_spec.rb", "diffHunk": "@@ -558,4 +558,94 @@ def read_json_file(filename)\n     expect(content['vendor']).to eq(@content.vendor)\n     expect(content['path']).to eq(@content.contentUrl)\n   end\n+\n+  it 'should honour the content defaults for owner in SCA mode' do\n+    product = create_product('test-product-p1', 'some product-p1')\n+\n+    # Content enabled = true\n+    content_c1 = @cp.create_content(\n+        @owner['key'], \"cname-c1\", 'test-content-c1', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c1['id'], true)\n+\n+    # Content enabled = false\n+    content_c2 = @cp.create_content(\n+        @owner['key'], \"cname-c2\", 'test-content-c2', random_string(\"clabel\"), \"ctype\", \"cvendor\",\n+        {:content_url=> '/this/is/the/path',  :modified_products => [@modified_product[\"id\"]]}, true)\n+    @cp.add_content_to_product(@owner['key'], product['id'], content_c2['id'], false)\n+\n+    @consumer = consumer_client(@user, @consumername, type=:system, username=nil, facts= {'system.certificate_version' => '3.3'})\n+    certs = @consumer.list_certificates\n+    certs.length.should == 1\n+    cert = certs[0]['cert']\n+    json_body = extract_payload(cert)\n+    # Check content status\n+    json_body['products'][0]['content'].each do |content|\n+      if content.id == content_c1.id\n+        expect(content.enabled).to be_nil", "originalCommit": "564c4d608e24e8461a2f838e2aaeea5170692344", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "aebc6f66daf3698b3172185155d848fda61d1319", "url": "https://github.com/candlepin/candlepin/commit/aebc6f66daf3698b3172185155d848fda61d1319", "message": "1868383: Honour content default for owner in SCA mode (ENT-2742)", "committedDate": "2020-08-26T05:55:09Z", "type": "forcePushed"}, {"oid": "65c692aa826c69d13c45d2d3feae9dda915c2676", "url": "https://github.com/candlepin/candlepin/commit/65c692aa826c69d13c45d2d3feae9dda915c2676", "message": "1868383: Honour content default for owner in SCA mode (ENT-2742)", "committedDate": "2020-08-26T06:34:41Z", "type": "forcePushed"}, {"oid": "88a3cc06c703fe5ced03597edc47a582cb6dc1a4", "url": "https://github.com/candlepin/candlepin/commit/88a3cc06c703fe5ced03597edc47a582cb6dc1a4", "message": "1868383: Honour content default for owner in SCA mode (ENT-2742)\n  - When more than one product provides the same content with different\n    enablement values,deduplicate them by keeping the enabled content only.", "committedDate": "2020-08-27T13:33:09Z", "type": "commit"}, {"oid": "88a3cc06c703fe5ced03597edc47a582cb6dc1a4", "url": "https://github.com/candlepin/candlepin/commit/88a3cc06c703fe5ced03597edc47a582cb6dc1a4", "message": "1868383: Honour content default for owner in SCA mode (ENT-2742)\n  - When more than one product provides the same content with different\n    enablement values,deduplicate them by keeping the enabled content only.", "committedDate": "2020-08-27T13:33:09Z", "type": "forcePushed"}]}