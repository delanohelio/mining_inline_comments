{"pr_number": 2697, "pr_title": "ENT-2316: Introduce Swatch Profile Timestamp", "pr_createdAt": "2020-05-12T11:31:04Z", "pr_url": "https://github.com/candlepin/candlepin/pull/2697", "timeline": [{"oid": "950e9830fc9cb7af7c24793bfa810171b93c8a8c", "url": "https://github.com/candlepin/candlepin/commit/950e9830fc9cb7af7c24793bfa810171b93c8a8c", "message": "ENT-2316: Introduce Swatch Profile Timestamp\n - Added \"rh_cloud_profile_modified\" column in consumer\n - Updated the ConsumerResource, HypervisorResource and HypervisorUpdateAction\n   to add modified timestamp on certain conditions\n - Added Enum for specific facts\n - Test suites added for the respective changes", "committedDate": "2020-05-12T11:54:21Z", "type": "forcePushed"}, {"oid": "bee0454164575e86997042c1cfefeac8526d007a", "url": "https://github.com/candlepin/candlepin/commit/bee0454164575e86997042c1cfefeac8526d007a", "message": "ENT-2316: Introduce Swatch Profile Timestamp\n - Added \"rh_cloud_profile_modified\" column in consumer\n - Updated Consumer entity mutators to set the current timestamp\n - Added Enum for specific facts\n - Test suites added for the respective changes", "committedDate": "2020-05-15T12:53:00Z", "type": "forcePushed"}, {"oid": "18ca9128d2caee6774b068a9ce039028c6c27b4a", "url": "https://github.com/candlepin/candlepin/commit/18ca9128d2caee6774b068a9ce039028c6c27b4a", "message": "ENT-2316: Introduce Swatch Profile Timestamp\n - Added \"rh_cloud_profile_modified\" column in consumer\n - Updated Consumer entity mutators to set the current timestamp\n - Added Enum for specific facts\n - Test suites added for the respective changes", "committedDate": "2020-05-15T13:26:10Z", "type": "forcePushed"}, {"oid": "f96b994e4413f3e97d078bda8d26b07b067484c7", "url": "https://github.com/candlepin/candlepin/commit/f96b994e4413f3e97d078bda8d26b07b067484c7", "message": "ENT-2316: Introduce Swatch Profile Timestamp\n - Added \"rh_cloud_profile_modified\" column in consumer\n - Updated Consumer entity mutators to set the current timestamp\n - Added Enum for specific facts\n - Test suites added for the respective changes", "committedDate": "2020-05-18T10:54:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU1ODk1MA==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r426558950", "bodyText": "Please add class description here.", "author": "wolfdale", "createdAt": "2020-05-18T11:32:01Z", "path": "server/src/test/java/org/candlepin/resource/HypervisorCloudProfileTest.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package org.candlepin.resource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+import org.candlepin.auth.UserPrincipal;\n+import org.candlepin.auth.permissions.Permission;\n+import org.candlepin.auth.permissions.PermissionFactory;\n+import org.candlepin.dto.StandardTranslator;\n+import org.candlepin.dto.api.v1.GuestIdDTO;\n+import org.candlepin.dto.api.v1.HypervisorConsumerDTO;\n+import org.candlepin.dto.api.v1.HypervisorUpdateResultDTO;\n+import org.candlepin.model.Consumer;\n+import org.candlepin.model.ConsumerCurator;\n+import org.candlepin.model.ConsumerType;\n+import org.candlepin.model.ConsumerTypeCurator;\n+import org.candlepin.model.EnvironmentCurator;\n+import org.candlepin.model.GuestId;\n+import org.candlepin.model.HypervisorId;\n+import org.candlepin.model.Owner;\n+import org.candlepin.model.OwnerCurator;\n+import org.candlepin.model.Role;\n+import org.candlepin.model.User;\n+import org.candlepin.test.DatabaseTestFixture;\n+import org.candlepin.test.TestUtil;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+", "originalCommit": "f96b994e4413f3e97d078bda8d26b07b067484c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3MTIxOQ==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r426571219", "bodyText": "Added.", "author": "sonalidhome", "createdAt": "2020-05-18T11:56:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU1ODk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU1OTA4NQ==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r426559085", "bodyText": "Please add description here.", "author": "wolfdale", "createdAt": "2020-05-18T11:32:18Z", "path": "server/src/main/java/org/candlepin/model/CloudProfileFacts.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package org.candlepin.model;\n+", "originalCommit": "f96b994e4413f3e97d078bda8d26b07b067484c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU3MTI4MA==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r426571280", "bodyText": "Added.", "author": "sonalidhome", "createdAt": "2020-05-18T11:56:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjU1OTA4NQ=="}], "type": "inlineReview"}, {"oid": "dbaffe06406c70d161a3658e1c332b490f063493", "url": "https://github.com/candlepin/candlepin/commit/dbaffe06406c70d161a3658e1c332b490f063493", "message": "ENT-2316: Introduce Swatch Profile Timestamp\n - Added \"rh_cloud_profile_modified\" column in consumer\n - Updated Consumer entity mutators to set the current timestamp\n - Added Enum for specific facts\n - Test suites added for the respective changes", "committedDate": "2020-05-18T11:54:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE2NjUyNA==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r427166524", "bodyText": "It is better to avoid this syntax because it creates an anonymous class every time it is called. instantiating a map and then calling fact.put(name, value); should be fine", "author": "nikosmoum", "createdAt": "2020-05-19T09:37:01Z", "path": "server/src/main/java/org/candlepin/model/Consumer.java", "diffHunk": "@@ -519,9 +526,15 @@ else if (!myVal.equals(otherVal)) {\n      * @param value to set\n      */\n     public void setFact(String name, String value) {\n-        if (facts == null) {\n-            facts = new HashMap<>();\n+        if (this.facts == null) {\n+            this.facts = new HashMap<>();\n+        }\n+\n+        HashMap<String, String> fact = new HashMap<String, String>() {{ put(name, value); }};", "originalCommit": "dbaffe06406c70d161a3658e1c332b490f063493", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0ODkxMA==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r427848910", "bodyText": "Gotcha! Updated.", "author": "sonalidhome", "createdAt": "2020-05-20T08:55:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE2NjUyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE2OTAxMA==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r427169010", "bodyText": "We should also update the timestamp when an addon is removed", "author": "nikosmoum", "createdAt": "2020-05-19T09:41:03Z", "path": "server/src/main/java/org/candlepin/model/Consumer.java", "diffHunk": "@@ -893,13 +915,45 @@ public void setContentAccessMode(String contentAccessMode) {\n \n     public void setAddOns(Set<String> addOns) {\n         this.addOns = addOns;\n+        this.setRHCloudProfileModified(new Date());\n     }\n \n     public void addAddOn(String addOn) {\n         this.addOns.add(addOn);\n+        this.setRHCloudProfileModified(new Date());\n     }\n \n     public void removeAddOn(String addOn) {\n         this.addOns.remove(addOn);", "originalCommit": "dbaffe06406c70d161a3658e1c332b490f063493", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0ODU4Ng==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r427848586", "bodyText": "Added.", "author": "sonalidhome", "createdAt": "2020-05-20T08:54:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE2OTAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3MDY2Mg==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r427170662", "bodyText": "Since every single usage of this method is to pass in new Date(), maybe it would be clearer to just change it to not accept any arguments, make it set this.rhCloudProfileModified = new Date;, and rename it to updateRHCloudProfileModified?", "author": "nikosmoum", "createdAt": "2020-05-19T09:43:46Z", "path": "server/src/main/java/org/candlepin/model/Consumer.java", "diffHunk": "@@ -893,13 +915,45 @@ public void setContentAccessMode(String contentAccessMode) {\n \n     public void setAddOns(Set<String> addOns) {\n         this.addOns = addOns;\n+        this.setRHCloudProfileModified(new Date());\n     }\n \n     public void addAddOn(String addOn) {\n         this.addOns.add(addOn);\n+        this.setRHCloudProfileModified(new Date());\n     }\n \n     public void removeAddOn(String addOn) {\n         this.addOns.remove(addOn);\n     }\n+\n+    public void setRHCloudProfileModified(Date rhCloudProfileModified) {", "originalCommit": "dbaffe06406c70d161a3658e1c332b490f063493", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg0OTQyMA==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r427849420", "bodyText": "Agreed, updated.", "author": "sonalidhome", "createdAt": "2020-05-20T08:55:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3MDY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3MjYyOA==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r427172628", "bodyText": "Why update the profile timestamp here? This isn't one of the required fields?\nAnd regardless, it is redundant, because this is recalculated and set if any of the syspurpose attributes change anyway", "author": "nikosmoum", "createdAt": "2020-05-19T09:47:00Z", "path": "server/src/main/java/org/candlepin/model/Consumer.java", "diffHunk": "@@ -712,6 +732,7 @@ public String getSystemPurposeStatus() {\n \n     public void setSystemPurposeStatus(String systemPurposeStatus) {\n         this.systemPurposeStatus = systemPurposeStatus;\n+        this.setRHCloudProfileModified(new Date());", "originalCommit": "dbaffe06406c70d161a3658e1c332b490f063493", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg1MDQxNg==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r427850416", "bodyText": "This is not needed here, It got added mistakenly by the name system purpose. Now removed it.", "author": "sonalidhome", "createdAt": "2020-05-20T08:57:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE3MjYyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5ODEzMQ==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r427198131", "bodyText": "In both instances of using the method, it's accepting this as the existing consumer. Maybe it would be better to remove that argument and have the method implicitly operate on the current consumer instance.", "author": "nikosmoum", "createdAt": "2020-05-19T10:30:45Z", "path": "server/src/main/java/org/candlepin/model/Consumer.java", "diffHunk": "@@ -893,13 +915,45 @@ public void setContentAccessMode(String contentAccessMode) {\n \n     public void setAddOns(Set<String> addOns) {\n         this.addOns = addOns;\n+        this.setRHCloudProfileModified(new Date());\n     }\n \n     public void addAddOn(String addOn) {\n         this.addOns.add(addOn);\n+        this.setRHCloudProfileModified(new Date());\n     }\n \n     public void removeAddOn(String addOn) {\n         this.addOns.remove(addOn);\n     }\n+\n+    public void setRHCloudProfileModified(Date rhCloudProfileModified) {\n+        this.rhCloudProfileModified = rhCloudProfileModified;\n+    }\n+\n+    public Date getRHCloudProfileModified() {\n+        return this.rhCloudProfileModified;\n+    }\n+\n+    /**\n+     * Check if the consumers facts have changed and contains the cloud profile facts.\n+     * It returns true if incoming facts are cloud profile facts\n+     *\n+     * @param existing existing consumer\n+     * @param incomingFacts incoming facts\n+     * @return a boolean\n+     */\n+    public boolean checkForCloudProfileFacts(Consumer existing, Map<String, String> incomingFacts) {", "originalCommit": "dbaffe06406c70d161a3658e1c332b490f063493", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg1MDgwOQ==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r427850809", "bodyText": "Agreed, removed the Consumer parameter.", "author": "sonalidhome", "createdAt": "2020-05-20T08:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzE5ODEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIyMzEwMA==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r427223100", "bodyText": "This is not really working as expected. It will return true even when non-cloud facts have changed for at least a couple of reasons:\n\nIt first checks if facts are unequal (which means at least one fact is not and that could even be a non-cloud fact) , and then returns true if any of the incoming facts are profile facts. For example, this unit test will fail, and it shouldn't, because the method should return false, because the cloud fact we care about (\"dmi.bios.vendor\") did not change:\n\n    @Test\n    public void testCloudProfileFactDidNotChange() {\n        Consumer consumer = new Consumer();\n        consumer.setFact(\"dmi.bios.vendor\", \"vendorA\");\n        consumer.setFact(\"lscpu.model\", \"78\");\n\n        Map<String, String> newFacts = new HashMap<>();\n        newFacts.put(\"dmi.bios.vendor\", \"vendorA\");\n        newFacts.put(\"lscpu.model\", \"100\");\n\n        // this should return false because the only cloud fact  the consumer has did not change\n        assertFalse(consumer.checkForCloudProfileFacts(consumer, newFacts));\n    }\n\n\nAnother test case that would fail for a different reason is due to the fact that factsAreEqual first compares the size of the incoming map to the one the consumer already has. In the case of setFact(String, String) where you always pass in a single fact wrapped in a map, this method will almost always assume that the facts changed, because you compare a map of size 1 with a map of size ~207 or whatever is the usual number of facts a consumer has:\n\n    @Test\n    public void testCloudProfileFactDidNotChangeWhenPassingSingleFact() {\n        Consumer consumer = new Consumer();\n        consumer.setFact(\"dmi.bios.vendor\", \"vendorA\");\n        consumer.setFact(\"lscpu.model\", \"78\");\n\n        Map<String, String> newFacts = new HashMap<>();\n        newFacts.put(\"dmi.bios.vendor\", \"vendorA\");\n\n        assertFalse(consumer.checkForCloudProfileFacts(consumer, newFacts));\n    }\n\nWhat we want when setting facts (with either setFacts or setFact), is to check:\n\nFor each of the incoming facts:\n\nIf It is a cloud profile fact AND the consumer already has it:\nreturn true if the value is different than the one on the consumer\nIf it is a cloud profile fact AND the consumer does not already have it: return true\n\n\nOtherwise, return false\n\nAlso, we should avoid using the factsAreEqual method because it is not useful at all in this use case.", "author": "nikosmoum", "createdAt": "2020-05-19T11:17:27Z", "path": "server/src/main/java/org/candlepin/model/Consumer.java", "diffHunk": "@@ -893,13 +915,45 @@ public void setContentAccessMode(String contentAccessMode) {\n \n     public void setAddOns(Set<String> addOns) {\n         this.addOns = addOns;\n+        this.setRHCloudProfileModified(new Date());\n     }\n \n     public void addAddOn(String addOn) {\n         this.addOns.add(addOn);\n+        this.setRHCloudProfileModified(new Date());\n     }\n \n     public void removeAddOn(String addOn) {\n         this.addOns.remove(addOn);\n     }\n+\n+    public void setRHCloudProfileModified(Date rhCloudProfileModified) {\n+        this.rhCloudProfileModified = rhCloudProfileModified;\n+    }\n+\n+    public Date getRHCloudProfileModified() {\n+        return this.rhCloudProfileModified;\n+    }\n+\n+    /**\n+     * Check if the consumers facts have changed and contains the cloud profile facts.\n+     * It returns true if incoming facts are cloud profile facts\n+     *\n+     * @param existing existing consumer\n+     * @param incomingFacts incoming facts\n+     * @return a boolean\n+     */\n+    public boolean checkForCloudProfileFacts(Consumer existing, Map<String, String> incomingFacts) {\n+        if (incomingFacts == null) {\n+            return false;\n+        }\n+        else if (!existing.factsAreEqual(incomingFacts)) {\n+            for (String fact : incomingFacts.keySet()) {\n+                if (CloudProfileFacts.containsFact(fact)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;", "originalCommit": "dbaffe06406c70d161a3658e1c332b490f063493", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg1MTY2Nw==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r427851667", "bodyText": "Thanks for noticing this.\nI have now revised the method as per the suggestion. Also, added few more tests to validate this method.", "author": "sonalidhome", "createdAt": "2020-05-20T08:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIyMzEwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIyNzYzOQ==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r427227639", "bodyText": "Looking at other examples of using variables, it looks like in order for the the ${timestamp.type} variable to be resolved you need to add the definitions file as such:\n    <!-- Include definitions for cert.type, timestamp.type, etc. -->\n    <include file=\"db/changelog/datatypes.xml\"/>\n\nI am not sure if liquibase is smart enough to figure this out on it's own, but we should add that here above the <changeSet just to be sure", "author": "nikosmoum", "createdAt": "2020-05-19T11:26:27Z", "path": "server/src/main/resources/db/changelog/20200430172317-add-column-rh-cloud-profile-modified.xml", "diffHunk": "@@ -0,0 +1,18 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+\n+<databaseChangeLog\n+        xmlns=\"http://www.liquibase.org/xml/ns/dbchangelog\"\n+        xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+        xsi:schemaLocation=\"http://www.liquibase.org/xml/ns/dbchangelog\n+        http://www.liquibase.org/xml/ns/dbchangelog/dbchangelog-3.1.xsd\">\n+\n+    <changeSet id=\"20200430172317-1\" author=\"sdhome\">\n+        <comment>Adding column rh_cloud_profile_modified for Swatch Profile Timestamp feature.\n+        </comment>\n+\n+        <addColumn tableName=\"cp_consumer\">\n+            <column name=\"rh_cloud_profile_modified\" type=\"${timestamp.type}\"/>", "originalCommit": "dbaffe06406c70d161a3658e1c332b490f063493", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg1MzQyNA==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r427853424", "bodyText": "Somehow this worked in a development environment. But, it's good to have it added before any consequences.", "author": "sonalidhome", "createdAt": "2020-05-20T09:02:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzIyNzYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI1NTA5Mw==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r427255093", "bodyText": "It would probably be good to include tests in this class for at least a couple of the fields that are not supposed to update the timestamp, and verify that the timestamp stays the same after the update. Also, same for a couple of facts that are not cloud-profile related", "author": "nikosmoum", "createdAt": "2020-05-19T12:16:17Z", "path": "server/src/test/java/org/candlepin/resource/ConsumerResourceIntegrationTest.java", "diffHunk": "@@ -686,4 +690,87 @@ public void testContentAccessExpireRegen() {\n         assertThat(updated, instanceOf(CertificateDTO.class));\n         assertNotEquals(original.getSerial().getId(), updated.getSerial().getId());\n     }\n+\n+    @Test\n+    public void testCloudProfileUpdatedOnConsumerSysRoleUpdate() {\n+        ConsumerDTO consumer = createConsumerDTO(\"random-consumer\", null, null, standardSystemTypeDTO);\n+        consumer = consumerResource.create(consumer, principal, null, null, null, true);\n+\n+        consumer.setRole(\"test-role\");\n+        consumerResource.updateConsumer(consumer.getUuid(), consumer, principal);\n+        Date profileModified = consumerCurator.get(consumer.getId()).getRHCloudProfileModified();\n+\n+        assertNotNull(consumerCurator.get(consumer.getId()).getRHCloudProfileModified());\n+\n+        consumer.setRole(\"update-role\");\n+        consumerResource.updateConsumer(consumer.getUuid(), consumer, principal);\n+        Date updatedProfileModified = consumerCurator.get(consumer.getId()).getRHCloudProfileModified();\n+\n+        assertNotNull(consumerCurator.get(consumer.getId()).getRHCloudProfileModified());\n+        assertNotEquals(profileModified, updatedProfileModified);\n+    }\n+\n+    @Test\n+    public void testCloudProfileUpdatedOnInstalledProductsUpdate() {\n+        ConsumerDTO consumer = createConsumerDTO(\"random-consumer\", null, null, standardSystemTypeDTO);\n+        consumer = consumerResource.create(consumer, principal, null, null, null, true);\n+\n+        Date beforeUpdateTimestamp = consumerCurator.findByUuid(consumer.getUuid())\n+            .getRHCloudProfileModified();\n+\n+        Product prod = TestUtil.createProduct(\"Product One\");\n+        ConsumerInstalledProductDTO updatedInstalledProduct =\n+            new ConsumerInstalledProductDTO(prod.getId(), prod.getName());\n+        consumer.addInstalledProduct(updatedInstalledProduct);\n+        consumerResource.updateConsumer(consumer.getUuid(), consumer, principal);\n+\n+        Date afterUpdateTimestamp = consumerCurator.findByUuid(consumer.getUuid())\n+            .getRHCloudProfileModified();\n+\n+        assertNotNull(afterUpdateTimestamp);\n+        assertNotEquals(beforeUpdateTimestamp, afterUpdateTimestamp);\n+    }\n+\n+    @Test\n+    public void testCloudProfileUpdatedOnHypervisorUpdate() {\n+        ConsumerDTO consumer = createConsumerDTO(\"random-consumer\", null, null, standardSystemTypeDTO);\n+        consumer = consumerResource.create(consumer, principal, null, null, null, true);\n+\n+        Date beforeUpdateTimestamp = consumerCurator.findByUuid(consumer.getUuid())\n+            .getRHCloudProfileModified();\n+\n+        HypervisorIdDTO updatedHypervisorId = new HypervisorIdDTO();\n+        consumer.setHypervisorId(updatedHypervisorId);\n+        consumerResource.updateConsumer(consumer.getUuid(), consumer, principal);\n+\n+        Date afterUpdateTimestamp = consumerCurator.findByUuid(consumer.getUuid())\n+            .getRHCloudProfileModified();\n+\n+        assertNotNull(afterUpdateTimestamp);\n+        assertNotEquals(beforeUpdateTimestamp, afterUpdateTimestamp);\n+    }\n+\n+    @Test\n+    public void testCloudProfileUpdatedOnSpecificConsumerFactsUpdate() {\n+        ConsumerDTO consumer = createConsumerDTO(\"random-consumer\", null, null, standardSystemTypeDTO);\n+        consumer = consumerResource.create(consumer, principal, null, null, null, true);\n+        Date modifiedDateOnCreate = consumerCurator.get(consumer.getId()).getRHCloudProfileModified();\n+\n+        ConsumerDTO updatedConsumerDTO = new ConsumerDTO();\n+        updatedConsumerDTO.setFact(\"FACT\", \"FACT_VALUE\");\n+        consumerResource.updateConsumer(consumer.getUuid(), updatedConsumerDTO, principal);\n+        Date modifiedTSOnUnnecessaryFactUpdate = consumerCurator.get(consumer.getId())\n+            .getRHCloudProfileModified();\n+\n+        assertEquals(modifiedDateOnCreate, modifiedTSOnUnnecessaryFactUpdate);\n+\n+        updatedConsumerDTO = new ConsumerDTO();\n+        updatedConsumerDTO.setFact(CloudProfileFacts.CPU_CORES_PERSOCKET.getFact(), \"1\");\n+        consumerResource.updateConsumer(consumer.getUuid(), updatedConsumerDTO, principal);\n+        Date modifiedTSOnNecessaryFactUpdate = consumerCurator.get(consumer.getId())\n+            .getRHCloudProfileModified();\n+\n+        assertNotNull(consumerCurator.get(consumer.getId()).getRHCloudProfileModified());\n+        assertNotEquals(modifiedTSOnUnnecessaryFactUpdate, modifiedTSOnNecessaryFactUpdate);\n+    }", "originalCommit": "dbaffe06406c70d161a3658e1c332b490f063493", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg1MzYwMQ==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r427853601", "bodyText": "Added.", "author": "sonalidhome", "createdAt": "2020-05-20T09:02:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI1NTA5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI1NjczNw==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r427256737", "bodyText": "Same for this class, a couple tests for each of HypervisorResource and GuestIdResource where we verify the profile timestamp is not updated because it is a field we don't care about", "author": "nikosmoum", "createdAt": "2020-05-19T12:19:07Z", "path": "server/src/test/java/org/candlepin/resource/HypervisorCloudProfileTest.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/**\n+ * Copyright (c) 2009 - 2020 Red Hat, Inc.\n+ *\n+ * This software is licensed to you under the GNU General Public License,\n+ * version 2 (GPLv2). There is NO WARRANTY for this software, express or\n+ * implied, including the implied warranties of MERCHANTABILITY or FITNESS\n+ * FOR A PARTICULAR PURPOSE. You should have received a copy of GPLv2\n+ * along with this software; if not, see\n+ * http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt.\n+ *\n+ * Red Hat trademarks are not licensed under GPLv2. No permission is\n+ * granted to use or replicate Red Hat trademarks that are incorporated\n+ * in this software or its documentation.\n+ */\n+\n+package org.candlepin.resource;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+\n+import org.candlepin.auth.UserPrincipal;\n+import org.candlepin.auth.permissions.Permission;\n+import org.candlepin.auth.permissions.PermissionFactory;\n+import org.candlepin.dto.StandardTranslator;\n+import org.candlepin.dto.api.v1.GuestIdDTO;\n+import org.candlepin.dto.api.v1.HypervisorConsumerDTO;\n+import org.candlepin.dto.api.v1.HypervisorUpdateResultDTO;\n+import org.candlepin.model.Consumer;\n+import org.candlepin.model.ConsumerCurator;\n+import org.candlepin.model.ConsumerType;\n+import org.candlepin.model.ConsumerTypeCurator;\n+import org.candlepin.model.EnvironmentCurator;\n+import org.candlepin.model.GuestId;\n+import org.candlepin.model.HypervisorId;\n+import org.candlepin.model.Owner;\n+import org.candlepin.model.OwnerCurator;\n+import org.candlepin.model.Role;\n+import org.candlepin.model.User;\n+import org.candlepin.test.DatabaseTestFixture;\n+import org.candlepin.test.TestUtil;\n+\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.inject.Inject;\n+\n+/**\n+ * Test suite for the HypervisorResource and\n+ * GuestIdResource update methods. This validates the\n+ * Subscription profile time-stamp updates\n+ */\n+public class HypervisorCloudProfileTest  extends DatabaseTestFixture {\n+\n+    private static final String USER_NAME = \"testing user\";\n+\n+    @Inject private ConsumerCurator consumerCurator;\n+    @Inject private ConsumerTypeCurator consumerTypeCurator;\n+    @Inject private GuestIdResource guestIdResource;\n+    @Inject private OwnerCurator ownerCurator;\n+    @Inject private EnvironmentCurator environmentCurator;\n+    @Inject private PermissionFactory permFactory;\n+    @Inject private HypervisorResource hypervisorResource;\n+\n+    private ConsumerType hypervisorType;\n+\n+    private UserPrincipal principal;\n+    private Consumer consumer;\n+    private Owner owner;\n+    private Role ownerAdminRole;\n+    private User someuser;\n+\n+    @BeforeEach\n+    public void setUp() {\n+\n+        this.modelTranslator = new StandardTranslator(this.consumerTypeCurator, this.environmentCurator,\n+            this.ownerCurator);\n+\n+        owner = ownerCurator.create(new Owner(\"test-owner\"));\n+\n+        someuser = userCurator.create(new User(USER_NAME, \"dontcare\"));\n+        ownerAdminRole = createAdminRole(owner);\n+        ownerAdminRole.addUser(someuser);\n+        roleCurator.create(ownerAdminRole);\n+\n+        Collection<Permission> perms = permFactory.createPermissions(someuser,\n+            ownerAdminRole.getPermissions());\n+\n+        principal = new UserPrincipal(USER_NAME, perms, false);\n+        setupPrincipal(principal);\n+\n+        hypervisorType = consumerTypeCurator.getByLabel(ConsumerType.ConsumerTypeEnum.HYPERVISOR.getLabel());\n+\n+        consumer = TestUtil.createConsumer(hypervisorType, owner);\n+        consumer = consumerCurator.create(consumer);\n+    }\n+\n+    @Test\n+    public void testCloudProfileUpdatedOnGuestIdsForHostConsumerUpdates() {\n+        Map<String, List<GuestIdDTO>> hostGuestMap = new HashMap<>();\n+        String hypervisorId = \"test-host\";\n+        hostGuestMap.put(hypervisorId, new ArrayList(Collections\n+            .singletonList(TestUtil.createGuestIdDTO(\"GUEST_B\"))));\n+\n+        HypervisorUpdateResultDTO result = hypervisorResource.hypervisorUpdate(\n+            hostGuestMap, principal, owner.getKey(), true);\n+\n+        List<HypervisorConsumerDTO> created = new ArrayList<>(result.getCreated());\n+\n+        assertEquals(1, created.size());\n+        assertNotNull(consumerCurator.findByUuid(created.get(0).getUuid()).getRHCloudProfileModified());\n+\n+        hostGuestMap.put(hypervisorId, new ArrayList(Collections\n+            .singletonList(TestUtil.createGuestIdDTO(\"GUEST_C\"))));\n+\n+        result = hypervisorResource.hypervisorUpdate(\n+            hostGuestMap, principal, owner.getKey(), true);\n+\n+        List<HypervisorConsumerDTO> updated = new ArrayList<>(result.getUpdated());\n+\n+        assertEquals(1, updated.size());\n+        assertNotNull(consumerCurator.findByUuid(updated.get(0).getUuid()).getRHCloudProfileModified());\n+    }\n+\n+    @Test\n+    public void testCloudProfileUpdatedOnConsumerTypeUpdates() {\n+        ConsumerType system = new ConsumerType(ConsumerType.ConsumerTypeEnum.SYSTEM);\n+        consumerTypeCurator.create(system);\n+\n+        String hypervisorid = \"test-host\";\n+        Consumer testConsumer = new Consumer(hypervisorid, someuser.getUsername(), owner, system);\n+        HypervisorId hypervisorId = new HypervisorId(hypervisorid);\n+        hypervisorId.setOwner(owner);\n+        testConsumer.setHypervisorId(hypervisorId);\n+        testConsumer = consumerCurator.create(testConsumer);\n+\n+        Map<String, List<GuestIdDTO>> hostGuestMap = new HashMap<>();\n+        hostGuestMap.put(testConsumer.getName(), new ArrayList<>());\n+\n+        HypervisorUpdateResultDTO result = hypervisorResource.hypervisorUpdate(\n+            hostGuestMap, principal, owner.getKey(), true);\n+\n+        List<HypervisorConsumerDTO> updated = new ArrayList<>(result.getUpdated());\n+\n+        assertEquals(1, updated.size());\n+        assertNotNull(consumerCurator.findByUuid(updated.get(0).getUuid()).getRHCloudProfileModified());\n+    }\n+\n+    @Test\n+    public void testCloudProfileUpdatedOnGuestUpdate() {\n+        Consumer testConsumer = new Consumer(\"test_consumer\", someuser.getUsername(), owner, hypervisorType);\n+        testConsumer = consumerCurator.create(testConsumer);\n+\n+        GuestIdDTO guest = TestUtil.createGuestIdDTO(\"some_guest\");\n+        GuestId guestEnt = new GuestId();\n+        guestEnt.setId(\"some_id\");\n+\n+        Date beforeUpdateTimestamp = consumerCurator.findByUuid(testConsumer.getUuid())\n+            .getRHCloudProfileModified();\n+\n+        guestIdResource.updateGuest(testConsumer.getUuid(), guest.getGuestId(), guest);\n+        Date afterUpdateTimestamp = consumerCurator.findByUuid(testConsumer.getUuid())\n+            .getRHCloudProfileModified();\n+\n+        assertNotNull(afterUpdateTimestamp);\n+        assertNotEquals(beforeUpdateTimestamp, afterUpdateTimestamp);\n+    }\n+\n+    @Test\n+    public void testCloudProfileUpdatedOnMultipleGuestUpdate() {\n+        List<GuestIdDTO> guestIds = new LinkedList<>();\n+        guestIds.add(TestUtil.createGuestIdDTO(\"1\"));\n+\n+        Date beforeUpdateTimestamp = consumerCurator.findByUuid(consumer.getUuid())\n+            .getRHCloudProfileModified();\n+\n+        guestIdResource.updateGuests(consumer.getUuid(), guestIds);\n+        Date afterUpdateTimestamp = consumerCurator.findByUuid(consumer.getUuid())\n+            .getRHCloudProfileModified();\n+\n+        assertNotNull(afterUpdateTimestamp);\n+        assertNotEquals(beforeUpdateTimestamp, afterUpdateTimestamp);\n+    }\n+", "originalCommit": "dbaffe06406c70d161a3658e1c332b490f063493", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzg1Mzc1Nw==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r427853757", "bodyText": "Added.", "author": "sonalidhome", "createdAt": "2020-05-20T09:02:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzI1NjczNw=="}], "type": "inlineReview"}, {"oid": "5e934078edd6be62589e7081eca0757f311049fc", "url": "https://github.com/candlepin/candlepin/commit/5e934078edd6be62589e7081eca0757f311049fc", "message": "ENT-2316: Introduce Swatch Profile Timestamp\n - Added \"rh_cloud_profile_modified\" column in consumer\n - Updated Consumer entity mutators to set the current timestamp\n - Added Enum for specific facts\n - Test suites added for the respective changes", "committedDate": "2020-05-20T08:50:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkzOTg3OQ==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r427939879", "bodyText": "we already know incomingFacts is not null here, since if it was we would have returned false, so there is no need for this check", "author": "nikosmoum", "createdAt": "2020-05-20T11:36:13Z", "path": "server/src/main/java/org/candlepin/model/Consumer.java", "diffHunk": "@@ -893,13 +915,63 @@ public void setContentAccessMode(String contentAccessMode) {\n \n     public void setAddOns(Set<String> addOns) {\n         this.addOns = addOns;\n+        this.updateRHCloudProfileModified();\n     }\n \n     public void addAddOn(String addOn) {\n         this.addOns.add(addOn);\n+        this.updateRHCloudProfileModified();\n     }\n \n     public void removeAddOn(String addOn) {\n         this.addOns.remove(addOn);\n+        this.updateRHCloudProfileModified();\n+    }\n+\n+    public Date getRHCloudProfileModified() {\n+        return this.rhCloudProfileModified;\n+    }\n+\n+    public void setRHCloudProfileModified(Date rhCloudProfileModified) {\n+        this.rhCloudProfileModified = rhCloudProfileModified;\n+    }\n+\n+    public void updateRHCloudProfileModified() {\n+        this.rhCloudProfileModified = new Date();\n+    }\n+\n+    /**\n+     * Check if the consumers facts have changed and contains the cloud profile facts.\n+     * It returns true if incoming facts are cloud profile facts\n+     *\n+     * @param incomingFacts incoming facts\n+     * @return a boolean\n+     */\n+    public boolean checkForCloudProfileFacts(Map<String, String> incomingFacts) {\n+\n+        if (incomingFacts == null) {\n+            return false;\n+        }\n+\n+        if (this.facts != null && incomingFacts != null && this.facts.equals(incomingFacts)) {", "originalCommit": "5e934078edd6be62589e7081eca0757f311049fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUzMjg3MQ==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r428532871", "bodyText": "done.", "author": "sonalidhome", "createdAt": "2020-05-21T09:01:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkzOTg3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0Mjc2NA==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r427942764", "bodyText": "This will work, but it will have to iterate over all of the incoming facts (which usually are 200+) and check for each of them if it is a cloud-profile fact. A more performant loop would be to loop over the CloudProfileFacts.values() (which right now are only 11), then check if each of them is included in the incoming facts (since HashMap lookup is constant) and then continue the rest of the checks", "author": "nikosmoum", "createdAt": "2020-05-20T11:42:06Z", "path": "server/src/main/java/org/candlepin/model/Consumer.java", "diffHunk": "@@ -893,13 +915,63 @@ public void setContentAccessMode(String contentAccessMode) {\n \n     public void setAddOns(Set<String> addOns) {\n         this.addOns = addOns;\n+        this.updateRHCloudProfileModified();\n     }\n \n     public void addAddOn(String addOn) {\n         this.addOns.add(addOn);\n+        this.updateRHCloudProfileModified();\n     }\n \n     public void removeAddOn(String addOn) {\n         this.addOns.remove(addOn);\n+        this.updateRHCloudProfileModified();\n+    }\n+\n+    public Date getRHCloudProfileModified() {\n+        return this.rhCloudProfileModified;\n+    }\n+\n+    public void setRHCloudProfileModified(Date rhCloudProfileModified) {\n+        this.rhCloudProfileModified = rhCloudProfileModified;\n+    }\n+\n+    public void updateRHCloudProfileModified() {\n+        this.rhCloudProfileModified = new Date();\n+    }\n+\n+    /**\n+     * Check if the consumers facts have changed and contains the cloud profile facts.\n+     * It returns true if incoming facts are cloud profile facts\n+     *\n+     * @param incomingFacts incoming facts\n+     * @return a boolean\n+     */\n+    public boolean checkForCloudProfileFacts(Map<String, String> incomingFacts) {\n+\n+        if (incomingFacts == null) {\n+            return false;\n+        }\n+\n+        if (this.facts != null && incomingFacts != null && this.facts.equals(incomingFacts)) {\n+            return false;\n+        }\n+\n+        for (Entry<String, String> entry : incomingFacts.entrySet()) {\n+            if (CloudProfileFacts.containsFact(entry.getKey())) {", "originalCommit": "5e934078edd6be62589e7081eca0757f311049fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUzMjgyMQ==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r428532821", "bodyText": "Loop is now revised as suggested.", "author": "sonalidhome", "createdAt": "2020-05-21T09:01:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0Mjc2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0NjA0NQ==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r427946045", "bodyText": "This, and the 4 following tests which don't call into ConsumerResource, should probably moved into the ConsumerTest.java file, since that seems more relevant there", "author": "nikosmoum", "createdAt": "2020-05-20T11:48:38Z", "path": "server/src/test/java/org/candlepin/resource/ConsumerResourceIntegrationTest.java", "diffHunk": "@@ -686,4 +694,179 @@ public void testContentAccessExpireRegen() {\n         assertThat(updated, instanceOf(CertificateDTO.class));\n         assertNotEquals(original.getSerial().getId(), updated.getSerial().getId());\n     }\n+\n+    @Test\n+    public void testCloudProfileUpdatedOnConsumerSysRoleUpdate() {\n+        ConsumerDTO consumer = createConsumerDTO(\"random-consumer\", null, null, standardSystemTypeDTO);\n+        consumer = consumerResource.create(consumer, principal, null, null, null, true);\n+\n+        consumer.setRole(\"test-role\");\n+        consumerResource.updateConsumer(consumer.getUuid(), consumer, principal);\n+        Date profileModified = consumerCurator.get(consumer.getId()).getRHCloudProfileModified();\n+\n+        assertNotNull(consumerCurator.get(consumer.getId()).getRHCloudProfileModified());\n+\n+        consumer.setRole(\"update-role\");\n+        consumerResource.updateConsumer(consumer.getUuid(), consumer, principal);\n+        Date updatedProfileModified = consumerCurator.get(consumer.getId()).getRHCloudProfileModified();\n+\n+        assertNotNull(consumerCurator.get(consumer.getId()).getRHCloudProfileModified());\n+        assertNotEquals(profileModified, updatedProfileModified);\n+    }\n+\n+    @Test\n+    public void testCloudProfileUpdatedOnInstalledProductsUpdate() {\n+        ConsumerDTO consumer = createConsumerDTO(\"random-consumer\", null, null, standardSystemTypeDTO);\n+        consumer = consumerResource.create(consumer, principal, null, null, null, true);\n+\n+        Date beforeUpdateTimestamp = consumerCurator.findByUuid(consumer.getUuid())\n+            .getRHCloudProfileModified();\n+\n+        Product prod = TestUtil.createProduct(\"Product One\");\n+        ConsumerInstalledProductDTO updatedInstalledProduct =\n+            new ConsumerInstalledProductDTO(prod.getId(), prod.getName());\n+        consumer.addInstalledProduct(updatedInstalledProduct);\n+        consumerResource.updateConsumer(consumer.getUuid(), consumer, principal);\n+\n+        Date afterUpdateTimestamp = consumerCurator.findByUuid(consumer.getUuid())\n+            .getRHCloudProfileModified();\n+\n+        assertNotNull(afterUpdateTimestamp);\n+        assertNotEquals(beforeUpdateTimestamp, afterUpdateTimestamp);\n+    }\n+\n+    @Test\n+    public void testCloudProfileUpdatedOnHypervisorUpdate() {\n+        ConsumerDTO consumer = createConsumerDTO(\"random-consumer\", null, null, standardSystemTypeDTO);\n+        consumer = consumerResource.create(consumer, principal, null, null, null, true);\n+\n+        Date beforeUpdateTimestamp = consumerCurator.findByUuid(consumer.getUuid())\n+            .getRHCloudProfileModified();\n+\n+        HypervisorIdDTO updatedHypervisorId = new HypervisorIdDTO();\n+        consumer.setHypervisorId(updatedHypervisorId);\n+        consumerResource.updateConsumer(consumer.getUuid(), consumer, principal);\n+\n+        Date afterUpdateTimestamp = consumerCurator.findByUuid(consumer.getUuid())\n+            .getRHCloudProfileModified();\n+\n+        assertNotNull(afterUpdateTimestamp);\n+        assertNotEquals(beforeUpdateTimestamp, afterUpdateTimestamp);\n+    }\n+\n+    @Test\n+    public void testCloudProfileUpdatedOnSpecificConsumerFactsUpdate() {\n+        ConsumerDTO consumer = createConsumerDTO(\"random-consumer\", null, null, standardSystemTypeDTO);\n+        consumer = consumerResource.create(consumer, principal, null, null, null, true);\n+        Date modifiedDateOnCreate = consumerCurator.get(consumer.getId()).getRHCloudProfileModified();\n+\n+        ConsumerDTO updatedConsumerDTO = new ConsumerDTO();\n+        updatedConsumerDTO.setFact(\"FACT\", \"FACT_VALUE\");\n+        consumerResource.updateConsumer(consumer.getUuid(), updatedConsumerDTO, principal);\n+        Date modifiedTSOnUnnecessaryFactUpdate = consumerCurator.get(consumer.getId())\n+            .getRHCloudProfileModified();\n+\n+        assertEquals(modifiedDateOnCreate, modifiedTSOnUnnecessaryFactUpdate);\n+\n+        updatedConsumerDTO = new ConsumerDTO();\n+        updatedConsumerDTO.setFact(CloudProfileFacts.CPU_CORES_PERSOCKET.getFact(), \"1\");\n+        consumerResource.updateConsumer(consumer.getUuid(), updatedConsumerDTO, principal);\n+        Date modifiedTSOnNecessaryFactUpdate = consumerCurator.get(consumer.getId())\n+            .getRHCloudProfileModified();\n+\n+        assertNotNull(consumerCurator.get(consumer.getId()).getRHCloudProfileModified());\n+        assertNotEquals(modifiedTSOnUnnecessaryFactUpdate, modifiedTSOnNecessaryFactUpdate);\n+    }\n+\n+    @Test\n+    public void testCloudProfileFactDidNotChange() {", "originalCommit": "5e934078edd6be62589e7081eca0757f311049fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODUzMjQwNA==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r428532404", "bodyText": "Agreed, Moved these tests to ConsmerTest.java.", "author": "sonalidhome", "createdAt": "2020-05-21T09:00:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzk0NjA0NQ=="}], "type": "inlineReview"}, {"oid": "b0f45fb29812f0e2ce7100843f843d8d25c98751", "url": "https://github.com/candlepin/candlepin/commit/b0f45fb29812f0e2ce7100843f843d8d25c98751", "message": "ENT-2316: Introduce Swatch Profile Timestamp\n - Added \"rh_cloud_profile_modified\" column in consumer\n - Updated Consumer entity mutators to set the current timestamp\n - Added Enum for specific facts\n - Test suites added for the respective changes", "committedDate": "2020-05-21T08:59:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwODg0NQ==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r428608845", "bodyText": "I'm not sure why either the filtering (which will still do a 200+ iterations loop) or this second loop is needed?  At this point we already know the key we are interested is a cloud-profile fact and is contained in the incoming facts, and only need to check the Consumer's side.\nAlso, the whole purpose of using a HashMap (or HashSet), is that you get O(1) retrieval time, so you only need to call containsKey to check if a key is there, or .get('key') to retrieve the value. Looping over a HashMap is almost never needed.\nThus, this whole method could be simplified to this:\n    public boolean checkForCloudProfileFacts(Map<String, String> incomingFacts) {\n        if (incomingFacts == null) {\n            return false;\n        }\n\n        if (this.facts != null && this.facts.equals(incomingFacts)) {\n            return false;\n        }\n\n        for (CloudProfileFacts profileFact : CloudProfileFacts.values()) {\n            if (incomingFacts.containsKey(profileFact.getFact())) {\n                if (this.facts == null ||\n                    !this.facts.containsKey(profileFact.getFact()) ||\n                    !this.facts.get(profileFact.getFact()).equals(incomingFacts.get(profileFact.getFact()))) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }", "author": "nikosmoum", "createdAt": "2020-05-21T11:59:26Z", "path": "server/src/main/java/org/candlepin/model/Consumer.java", "diffHunk": "@@ -893,13 +915,71 @@ public void setContentAccessMode(String contentAccessMode) {\n \n     public void setAddOns(Set<String> addOns) {\n         this.addOns = addOns;\n+        this.updateRHCloudProfileModified();\n     }\n \n     public void addAddOn(String addOn) {\n         this.addOns.add(addOn);\n+        this.updateRHCloudProfileModified();\n     }\n \n     public void removeAddOn(String addOn) {\n         this.addOns.remove(addOn);\n+        this.updateRHCloudProfileModified();\n+    }\n+\n+    public Date getRHCloudProfileModified() {\n+        return this.rhCloudProfileModified;\n+    }\n+\n+    public void setRHCloudProfileModified(Date rhCloudProfileModified) {\n+        this.rhCloudProfileModified = rhCloudProfileModified;\n+    }\n+\n+    public void updateRHCloudProfileModified() {\n+        this.rhCloudProfileModified = new Date();\n+    }\n+\n+    /**\n+     * Check if the consumers facts have changed and contains the cloud profile facts.\n+     * It returns true if incoming facts are cloud profile facts\n+     *\n+     * @param incomingFacts incoming facts\n+     * @return a boolean\n+     */\n+    public boolean checkForCloudProfileFacts(Map<String, String> incomingFacts) {\n+\n+        if (incomingFacts == null) {\n+            return false;\n+        }\n+\n+        if (this.facts != null && this.facts.equals(incomingFacts)) {\n+            return false;\n+        }\n+\n+        for (CloudProfileFacts profileFact : CloudProfileFacts.values()) {\n+\n+            if (incomingFacts.containsKey(profileFact.getFact())) {\n+\n+                Map<String, String> filteredIncomingFact = incomingFacts.entrySet().stream()\n+                    .filter(key -> key.getKey().equals(profileFact.getFact()))\n+                    .collect(HashMap::new, (m, v)->m.put(v.getKey(), v.getValue()), HashMap::putAll);\n+\n+                for (Entry<String, String> entry : filteredIncomingFact.entrySet()) {", "originalCommit": "b0f45fb29812f0e2ce7100843f843d8d25c98751", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA4NTg0OA==", "url": "https://github.com/candlepin/candlepin/pull/2697#discussion_r429085848", "bodyText": "I misunderstood the behavior of incoming facts. Thanks for explaining.\nI have corrected it as suggested.", "author": "sonalidhome", "createdAt": "2020-05-22T07:26:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODYwODg0NQ=="}], "type": "inlineReview"}, {"oid": "edb145bb7540fec2a2892ed9ae18a841efdddb3b", "url": "https://github.com/candlepin/candlepin/commit/edb145bb7540fec2a2892ed9ae18a841efdddb3b", "message": "ENT-2316: Introduce Swatch Profile Timestamp\n - Added \"rh_cloud_profile_modified\" column in consumer\n - Updated Consumer entity mutators to set the current timestamp\n - Added Enum for specific facts\n - Test suites added for the respective changes", "committedDate": "2020-05-22T07:23:15Z", "type": "commit"}, {"oid": "edb145bb7540fec2a2892ed9ae18a841efdddb3b", "url": "https://github.com/candlepin/candlepin/commit/edb145bb7540fec2a2892ed9ae18a841efdddb3b", "message": "ENT-2316: Introduce Swatch Profile Timestamp\n - Added \"rh_cloud_profile_modified\" column in consumer\n - Updated Consumer entity mutators to set the current timestamp\n - Added Enum for specific facts\n - Test suites added for the respective changes", "committedDate": "2020-05-22T07:23:15Z", "type": "forcePushed"}]}