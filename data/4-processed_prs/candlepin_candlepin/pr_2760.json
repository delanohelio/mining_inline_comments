{"pr_number": 2760, "pr_title": "[M] 1854221: Added additional job cleanup to JobManager and JobCleaner (ENT-2632, ENT-2630, ENT-2586)", "pr_createdAt": "2020-07-22T21:56:56Z", "pr_url": "https://github.com/candlepin/candlepin/pull/2760", "timeline": [{"oid": "15464457fd029a8703ac7623f2efbe18e617ec85", "url": "https://github.com/candlepin/candlepin/commit/15464457fd029a8703ac7623f2efbe18e617ec85", "message": "1854221: Added additional job cleanup to JobManager and JobCleaner\n\n- JobCleaner will now abort non-terminal, non-running jobs older\n  than three days (by default; configurable)\n- JobManager will now attempt to \"rewind\" the job state for\n  abandoned jobs during startup, where an \"abandoned\" job is\n  defined as one in the RUNNING state with the same executor\n  as the node which is performing the check", "committedDate": "2020-07-22T22:01:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxNjUzMg==", "url": "https://github.com/candlepin/candlepin/pull/2760#discussion_r459516532", "bodyText": "This could be a performance hit. Why do we need to fetch the actual objects before changing their state?\nIf the only reason is to utilize the transition validation the setJobState does, then maybe we should be doing that validation without fetching the job objects into memory (we have the collection of JobState, we can just validate against JobState.ABORTED).", "author": "nikosmoum", "createdAt": "2020-07-23T15:00:45Z", "path": "server/src/main/java/org/candlepin/async/JobManager.java", "diffHunk": "@@ -1717,11 +1746,59 @@ public int cleanupJobs(AsyncJobStatusQueryBuilder queryBuilder) {\n \n         queryBuilder.setJobStates(states);\n \n-        // TODO: any other sanity restrictions deemed necessary\n+        // Add any other sanity restrictions deemed necessary here\n \n         return this.jobCurator.deleteJobs(queryBuilder);\n     }\n \n+    /**\n+     * Aborts all non-terminal jobs matching the query parameters provided. If the query does not\n+     * specify any states, this method defaults to all non-terminal, non-running states. If any\n+     * terminal or running states are provided, they will be ignored.\n+     *\n+     * @param queryBuilder\n+     *  an AsyncJobStatusQueryBuilder instance containing the various arguments or filters to use\n+     *  to select jobs to abort\n+     *\n+     * @return\n+     *  the number of jobs aborted as a result of this operation\n+     */\n+    @Transactional\n+    public int abortNonTerminalJobs(AsyncJobStatusQueryBuilder queryBuilder) {\n+        // Prepare for the defaults...\n+        if (queryBuilder == null) {\n+            queryBuilder = new AsyncJobStatusQueryBuilder();\n+        }\n+\n+        Collection<JobState> states = queryBuilder.getJobStates();\n+        if (states != null && !states.isEmpty()) {\n+            // Make sure we don't attempt to abort some jobs that are already in terminal states\n+            states = states.stream()\n+                .filter(state -> state != null && !state.isTerminal() && state != JobState.RUNNING)\n+                .collect(Collectors.toSet());\n+        }\n+        else {\n+            // Set the default: all terminal states\n+            states = Arrays.stream(JobState.values())\n+                .filter(state -> state != null && !state.isTerminal() && state != JobState.RUNNING)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        queryBuilder.setJobStates(states);\n+\n+        // Add any other sanity restrictions deemed necessary here\n+\n+        List<AsyncJobStatus> jobs = this.jobCurator.findJobs(queryBuilder);\n+\n+        // Step through each job and update the job state\n+        for (AsyncJobStatus job : jobs) {\n+            this.setJobState(job, JobState.ABORTED);\n+            this.jobCurator.merge(job);\n+        }", "originalCommit": "15464457fd029a8703ac7623f2efbe18e617ec85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU1NTg0Nw==", "url": "https://github.com/candlepin/candlepin/pull/2760#discussion_r459555847", "bodyText": "The original intent was:\n\nValidate the state transition (since this is a public utility method that may get exposed via endpoint soon)\nUpdate the job result with some kind of abort message\nThe number of jobs we're terminating this way should never be large\n\nI ended up not doing the second one there, but I don't remember if I made a decision not to for some reason, or just plain forgot to do it. But, an update query would not prevent this behavior anyway.\nAn update query would, without question, be faster and more efficient here, but at the expense of the transition validation.", "author": "Ceiu", "createdAt": "2020-07-23T15:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxNjUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU1NjA1Mw==", "url": "https://github.com/candlepin/candlepin/pull/2760#discussion_r459556053", "bodyText": "I trailed off a bit, but what are you thoughts there?", "author": "Ceiu", "createdAt": "2020-07-23T15:56:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxNjUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk3MTQ4Mw==", "url": "https://github.com/candlepin/candlepin/pull/2760#discussion_r459971483", "bodyText": "I agree that the number of jobs this will target should never be large, but with the current situation in Hosted, I'd expect this to be fetching a large amount at least the first couple of times, and I think it's good to be on the safe side. Also, I don't think the transition validation would be an expense. We can still do that without fetching the jobs, since we already have the static list of states we're fetching for, and if the validation passes for all states, then we do the update query.", "author": "nikosmoum", "createdAt": "2020-07-24T10:23:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxNjUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA1NjYwMw==", "url": "https://github.com/candlepin/candlepin/pull/2760#discussion_r460056603", "bodyText": "Oof... I hadn't even consider that. I had myself stuck in the idea that every job needed state transition validation individually. I'll work on a query for bulk updating a job's state.", "author": "Ceiu", "createdAt": "2020-07-24T13:37:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxNjUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk1MzY2NA==", "url": "https://github.com/candlepin/candlepin/pull/2760#discussion_r460953664", "bodyText": "Query added", "author": "Ceiu", "createdAt": "2020-07-27T14:57:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUxNjUzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUyMTkxNw==", "url": "https://github.com/candlepin/candlepin/pull/2760#discussion_r459521917", "bodyText": "Same question here: why fetch job objects into memory? we don't even do transition validation here, so an update query would be much faster", "author": "nikosmoum", "createdAt": "2020-07-23T15:08:10Z", "path": "server/src/main/java/org/candlepin/async/JobManager.java", "diffHunk": "@@ -495,6 +500,30 @@ public synchronized void initialize() throws StateManagementException {\n         }\n     }\n \n+    /**\n+     * Attempts to recover all jobs that were abandoned by this node if it shutdown abnormally\n+     * while executing jobs. Any jobs in the RUNNING state with an executor set to this node\n+     * will have their state forcefully rewound to QUEUED in an attempt to allow the task to be\n+     * rerun.\n+     */\n+    private void recoverAbandonedJobs() {\n+        AsyncJobStatusQueryBuilder queryBuilder = new AsyncJobStatusQueryBuilder()\n+            .setJobStates(Collections.singleton(JobState.RUNNING))\n+            .setExecutors(Collections.singleton(Util.getHostname()));\n+\n+        // Impl note: this violates normal state transitions, but we're trying to recover from an\n+        // ungraceful shutdown in which our process was terminated while a job was running. We'll\n+        // set the job's state to QUEUED, which will allow us to pick up the job and run it again\n+        // next time the message is received. If the message has been lost, then the job cleaner\n+        // will eventually nuke this job as part of its non-terminal job aborting step.\n+        for (AsyncJobStatus job : this.jobCurator.findJobs(queryBuilder)) {\n+            log.warn(\"Recovering abandoned job: {}\", job);\n+\n+            job.setState(JobState.QUEUED);\n+            this.jobCurator.merge(job);", "originalCommit": "15464457fd029a8703ac7623f2efbe18e617ec85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU1MjM3OA==", "url": "https://github.com/candlepin/candlepin/pull/2760#discussion_r459552378", "bodyText": "The number here should be no more than the number of job executor threads configured (default is 10), so it shouldn't be a huge hit compared to a raw query. The important thing I want here, though, is the logging.", "author": "Ceiu", "createdAt": "2020-07-23T15:51:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUyMTkxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2ODA2Ng==", "url": "https://github.com/candlepin/candlepin/pull/2760#discussion_r459968066", "bodyText": "You're right. 10 jobs should be negligible", "author": "nikosmoum", "createdAt": "2020-07-24T10:15:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUyMTkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzMDI5Nw==", "url": "https://github.com/candlepin/candlepin/pull/2760#discussion_r459530297", "bodyText": "This logging doesn't work. When the JobCleaner runs the logs print the literal string Removed %d terminal jobs older than %2$tF %2$tT%2$tz. The intellij tooltip says \"More arguments provided (2) than placeholders specified (0)\"", "author": "nikosmoum", "createdAt": "2020-07-23T15:19:26Z", "path": "server/src/main/java/org/candlepin/async/tasks/JobCleaner.java", "diffHunk": "@@ -63,36 +66,66 @@ public JobCleaner(Configuration config, JobManager jobManager) {\n \n     @Override\n     public void execute(JobExecutionContext context) throws JobExecutionException {\n-        String cfgName = ConfigProperties.jobConfig(JOB_KEY, CFG_MAX_JOB_AGE);\n-        int maxAgeInMinutes = this.config.getInt(cfgName, CFG_DEFAULT_MAX_JOB_AGE);\n+        String termCfgName = ConfigProperties.jobConfig(JOB_KEY, CFG_MAX_TERMINAL_JOB_AGE);\n+        Date termCutoff = this.parseMaxJobAgeConfig(termCfgName, CFG_DEFAULT_MAX_TERMINAL_JOB_AGE);\n+\n+        String nontermCfgName = ConfigProperties.jobConfig(JOB_KEY, CFG_MAX_NONTERMINAL_JOB_AGE);\n+        Date nontermCutoff = this.parseMaxJobAgeConfig(nontermCfgName, CFG_DEFAULT_MAX_NONTERMINAL_JOB_AGE);\n+\n+        int removed = this.cleanupTerminalJobs(termCutoff);\n+        int aborted = this.abortNonTerminalJobs(nontermCutoff);\n+\n+        context.setJobResult(String.format(\n+            \"Removed %1$d terminal jobs older than %2$tF %2$tT%2$tz\\n\" +\n+            \"Aborted %3$d non-running jobs older than %4$tF %4$tT%4$tz\",\n+            removed, termCutoff, aborted, nontermCutoff));\n+    }\n \n-        if (maxAgeInMinutes < 1) {\n-            String errmsg = String.format(\"Invalid value for max age, must be a positive integer: %s\",\n-                maxAgeInMinutes);\n+    private Date parseMaxJobAgeConfig(String cfgName, int defaultValue) throws JobExecutionException {\n+        int value = this.config.getInt(cfgName, defaultValue);\n+\n+        if (value < 1) {\n+            String errmsg = String.format(\"Invalid value for %s, must be a positive integer: %s\",\n+                cfgName, value);\n \n             log.error(errmsg);\n             throw new JobExecutionException(errmsg, true);\n         }\n \n-        // Set cutoff (end) date to now - max age in minutes\n-        Date cutoff = Util.addMinutesToDt(maxAgeInMinutes * -1);\n+        return Util.addMinutesToDt(value * -1);\n+    }\n \n+    private int cleanupTerminalJobs(Date cutoff) {\n         // We're targeting every terminal job\n         Set<JobState> jobStates = Arrays.stream(JobState.values())\n-            .filter(state -> state.isTerminal())\n+            .filter(JobState::isTerminal)\n             .collect(Collectors.toSet());\n \n         // Build the query builder with our config\n         AsyncJobStatusQueryBuilder queryBuilder = new AsyncJobStatusQueryBuilder()\n             .setJobStates(jobStates)\n             .setEndDate(cutoff);\n \n-        int deleted = this.jobManager.cleanupJobs(queryBuilder);\n+        int removed = this.jobManager.cleanupJobs(queryBuilder);\n+        log.info(\"Removed %d terminal jobs older than %2$tF %2$tT%2$tz\", removed, cutoff);", "originalCommit": "15464457fd029a8703ac7623f2efbe18e617ec85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTU1MjYxMQ==", "url": "https://github.com/candlepin/candlepin/pull/2760#discussion_r459552611", "bodyText": "Oh, whoops. That's a copy/paste mistake on my part.", "author": "Ceiu", "createdAt": "2020-07-23T15:51:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzMDI5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwMzQ5MA==", "url": "https://github.com/candlepin/candlepin/pull/2760#discussion_r459703490", "bodyText": "Fixed", "author": "Ceiu", "createdAt": "2020-07-23T20:17:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzMDI5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzMDQ2Nw==", "url": "https://github.com/candlepin/candlepin/pull/2760#discussion_r459530467", "bodyText": "Same here, logging doesn't work", "author": "nikosmoum", "createdAt": "2020-07-23T15:19:42Z", "path": "server/src/main/java/org/candlepin/async/tasks/JobCleaner.java", "diffHunk": "@@ -63,36 +66,66 @@ public JobCleaner(Configuration config, JobManager jobManager) {\n \n     @Override\n     public void execute(JobExecutionContext context) throws JobExecutionException {\n-        String cfgName = ConfigProperties.jobConfig(JOB_KEY, CFG_MAX_JOB_AGE);\n-        int maxAgeInMinutes = this.config.getInt(cfgName, CFG_DEFAULT_MAX_JOB_AGE);\n+        String termCfgName = ConfigProperties.jobConfig(JOB_KEY, CFG_MAX_TERMINAL_JOB_AGE);\n+        Date termCutoff = this.parseMaxJobAgeConfig(termCfgName, CFG_DEFAULT_MAX_TERMINAL_JOB_AGE);\n+\n+        String nontermCfgName = ConfigProperties.jobConfig(JOB_KEY, CFG_MAX_NONTERMINAL_JOB_AGE);\n+        Date nontermCutoff = this.parseMaxJobAgeConfig(nontermCfgName, CFG_DEFAULT_MAX_NONTERMINAL_JOB_AGE);\n+\n+        int removed = this.cleanupTerminalJobs(termCutoff);\n+        int aborted = this.abortNonTerminalJobs(nontermCutoff);\n+\n+        context.setJobResult(String.format(\n+            \"Removed %1$d terminal jobs older than %2$tF %2$tT%2$tz\\n\" +\n+            \"Aborted %3$d non-running jobs older than %4$tF %4$tT%4$tz\",\n+            removed, termCutoff, aborted, nontermCutoff));\n+    }\n \n-        if (maxAgeInMinutes < 1) {\n-            String errmsg = String.format(\"Invalid value for max age, must be a positive integer: %s\",\n-                maxAgeInMinutes);\n+    private Date parseMaxJobAgeConfig(String cfgName, int defaultValue) throws JobExecutionException {\n+        int value = this.config.getInt(cfgName, defaultValue);\n+\n+        if (value < 1) {\n+            String errmsg = String.format(\"Invalid value for %s, must be a positive integer: %s\",\n+                cfgName, value);\n \n             log.error(errmsg);\n             throw new JobExecutionException(errmsg, true);\n         }\n \n-        // Set cutoff (end) date to now - max age in minutes\n-        Date cutoff = Util.addMinutesToDt(maxAgeInMinutes * -1);\n+        return Util.addMinutesToDt(value * -1);\n+    }\n \n+    private int cleanupTerminalJobs(Date cutoff) {\n         // We're targeting every terminal job\n         Set<JobState> jobStates = Arrays.stream(JobState.values())\n-            .filter(state -> state.isTerminal())\n+            .filter(JobState::isTerminal)\n             .collect(Collectors.toSet());\n \n         // Build the query builder with our config\n         AsyncJobStatusQueryBuilder queryBuilder = new AsyncJobStatusQueryBuilder()\n             .setJobStates(jobStates)\n             .setEndDate(cutoff);\n \n-        int deleted = this.jobManager.cleanupJobs(queryBuilder);\n+        int removed = this.jobManager.cleanupJobs(queryBuilder);\n+        log.info(\"Removed %d terminal jobs older than %2$tF %2$tT%2$tz\", removed, cutoff);\n+\n+        return removed;\n+    }\n+\n+    private int abortNonTerminalJobs(Date cutoff) {\n+        // We're targeting every non-terminal, non-running job\n+        Set<JobState> jobStates = Arrays.stream(JobState.values())\n+            .filter(state -> !state.isTerminal() && state != JobState.RUNNING)\n+            .collect(Collectors.toSet());\n+\n+        // Build the query builder with our config\n+        AsyncJobStatusQueryBuilder queryBuilder = new AsyncJobStatusQueryBuilder()\n+            .setJobStates(jobStates)\n+            .setEndDate(cutoff);\n \n-        String result = String.format(\"Removed %d terminal jobs older than %2$tF %2$tT%2$tz\",\n-            deleted, cutoff);\n+        int aborted = this.jobManager.abortNonTerminalJobs(queryBuilder);\n+        log.info(\"Aborted %d non-running jobs older than %2$tF %2$tT%2$tz\", aborted, cutoff);", "originalCommit": "15464457fd029a8703ac7623f2efbe18e617ec85", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTcwMzQ1MQ==", "url": "https://github.com/candlepin/candlepin/pull/2760#discussion_r459703451", "bodyText": "Fixed", "author": "Ceiu", "createdAt": "2020-07-23T20:17:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTUzMDQ2Nw=="}], "type": "inlineReview"}, {"oid": "6d996dff247e4375c8cff66ed7d58da5a5f301f8", "url": "https://github.com/candlepin/candlepin/commit/6d996dff247e4375c8cff66ed7d58da5a5f301f8", "message": "1854221: Added additional job cleanup to JobManager and JobCleaner\n\n- JobCleaner will now abort non-terminal, non-running jobs older\n  than three days (by default; configurable)\n- JobManager will now attempt to \"rewind\" the job state for\n  abandoned jobs during startup, where an \"abandoned\" job is\n  defined as one in the RUNNING state with the same executor\n  as the node which is performing the check", "committedDate": "2020-07-23T20:17:18Z", "type": "forcePushed"}, {"oid": "1760d14380c64b4114076886ef3fce4bee23fdc6", "url": "https://github.com/candlepin/candlepin/commit/1760d14380c64b4114076886ef3fce4bee23fdc6", "message": "1854221: Added additional job cleanup to JobManager and JobCleaner\n\n- JobCleaner will now abort non-terminal, non-running jobs older\n  than three days (by default; configurable)\n- JobCleaner will now abort running jobs older than two days\n  (by default; configurable)\n- JobManager will now attempt to \"rewind\" the job state for\n  abandoned jobs during startup, where an \"abandoned\" job is\n  defined as one in the RUNNING state with the same executor\n  as the node which is performing the check", "committedDate": "2020-07-27T14:56:45Z", "type": "commit"}, {"oid": "1760d14380c64b4114076886ef3fce4bee23fdc6", "url": "https://github.com/candlepin/candlepin/commit/1760d14380c64b4114076886ef3fce4bee23fdc6", "message": "1854221: Added additional job cleanup to JobManager and JobCleaner\n\n- JobCleaner will now abort non-terminal, non-running jobs older\n  than three days (by default; configurable)\n- JobCleaner will now abort running jobs older than two days\n  (by default; configurable)\n- JobManager will now attempt to \"rewind\" the job state for\n  abandoned jobs during startup, where an \"abandoned\" job is\n  defined as one in the RUNNING state with the same executor\n  as the node which is performing the check", "committedDate": "2020-07-27T14:56:45Z", "type": "forcePushed"}]}