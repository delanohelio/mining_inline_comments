{"pr_number": 1247, "pr_title": "dump entries that could not be deserialized into files", "pr_createdAt": "2020-06-30T15:23:20Z", "pr_url": "https://github.com/bakdata/conquery/pull/1247", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3Mjc1NA==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r448972754", "bodyText": "kannst du das im constructor reingeben?", "author": "awildturtok", "createdAt": "2020-07-02T12:43:01Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -94,6 +115,22 @@ public SerializingStore(XodusStore store, Validator validator, IStoreInfo storeI\n \t\tkeyReader = Jackson.BINARY_MAPPER\n \t\t\t\t\t\t\t.readerFor(storeInfo.getKeyType())\n \t\t\t\t\t\t\t.withView(InternalOnly.class);\n+\t\t\n+\t\tremoveUnreadablesFromUnderlyingStore = ConqueryConfig.getInstance().getStorage().isRemoveUnreadablesFromStore();\n+\t\t\n+\t\t// Prepare dump directory if there is one set in the config\n+\t\tOptional<File> dumpUnreadable = ConqueryConfig.getInstance().getStorage().getUnreadbleDataDumpDirectory();", "originalCommit": "6de402e728ed3f6bdd6f793503248bf5ce8517de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3MzY0Ng==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r448973646", "bodyText": "das kannst du als lokale variablen umsetzen", "author": "awildturtok", "createdAt": "2020-07-02T12:44:35Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -71,6 +81,17 @@\n \t */\n \tprivate final IStoreInfo storeInfo;\n \n+\tprivate int totalProcessed = 0;", "originalCommit": "6de402e728ed3f6bdd6f793503248bf5ce8517de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgxMjcyNQ==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r455812725", "bodyText": "Hab ich gemacht, war auch gut f\u00fcr den test", "author": "thoniTUB", "createdAt": "2020-07-16T14:06:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3MzY0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3NDc2MQ==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r448974761", "bodyText": "kann mir vorstellen, dass das ganz sch\u00f6n lange logs werden. w\u00fcrde das glaube ich eher pro element einzeln loggen dann habeben wir nicht eine ewig lange zeile", "author": "awildturtok", "createdAt": "2020-07-02T12:46:29Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -115,22 +152,65 @@ public void add(KEY key, VALUE value) throws JSONException {\n \n \t@Override\n \tpublic VALUE get(KEY key) {\n-\t\treturn readValue(store.get(writeKey(key)));\n+\t\tByteIterable binValue = store.get(writeKey(key));\n+\t\ttry {\n+\t\t\treturn readValue(binValue);\t\t\t\n+\t\t} catch (Exception e) {\n+\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\tdumpToFile(binValue, key.toString(), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t}\n+\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\tremove(key);\n+\t\t\t\t// Null seems to be an acceptable return value in this case\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tThrowables.throwIfUnchecked(e);\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n \t}\n \n \t@Override\n \tpublic void forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\t\ttotalProcessed = 0;\n+\t\tfailedKeys = 0;\n+\t\tfailedValues = 0;\n+\t\tArrayList<ByteIterable> unreadables = new ArrayList<>();\n \t\tstore.forEach((k, v) -> {\n+\t\t\ttotalProcessed++;\n \t\t\ttry {\n \t\t\t\ttry {\n \t\t\t\t\tconsumer.accept(readKey(k), readValue(v), v.getLength());\n \t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tlog.warn(\"Could not parse value for key \" + readKey(k), e);\n+\t\t\t\t\tif(unreadableValuesDumpDir != null) {\t\t\t\t\t\t\n+\t\t\t\t\t\tdumpToFile(v, Jackson.BINARY_MAPPER.readerFor(String.class).readValue(k.getBytesUnsafe()), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tlog.warn(\"Could not parse value for key \" + readKey(k), e);\t\t\t\t\t\t\n+\t\t\t\t\t}\n+\t\t\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\t\t\tunreadables.add(k);\n+\t\t\t\t\t}\n+\t\t\t\t\tfailedValues++;\n \t\t\t\t}\n \t\t\t} catch (Exception e) {\n \t\t\t\tlog.warn(\"Could not parse key \" + k, e);\n+\t\t\t\tfailedKeys++;\n \t\t\t}\n \t\t});\n+\t\t// Print some statistics\n+\t\tlog.info(String.format(\"While processing store %s:\\n\\tEntries processed:\\t%d\\n\\tKey read failure:\\t%d (%.2f%%)\\n\\tValue read failure:\\t%d (%.2f%%)\",\n+\t\t\tthis.storeInfo.getXodusName(),\n+\t\t\ttotalProcessed, failedKeys,\n+\t\t\t(float) failedKeys/totalProcessed*100,\n+\t\t\tfailedValues,\n+\t\t\t(float) failedValues/totalProcessed*100));\n+\t\t\n+\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\tlog.info(\"Removing the following unreadable elements from the store {}: {}\", storeInfo.getXodusName(), unreadables.stream()\n+\t\t\t\t.map(ByteIterable::getBytesUnsafe)\n+\t\t\t\t.map(String::new)\n+\t\t\t\t.collect(Collectors.toList()));", "originalCommit": "6de402e728ed3f6bdd6f793503248bf5ce8517de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgxMDQ2Ng==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r455810466", "bodyText": "Ich hab das  log gek\u00fcrzt", "author": "thoniTUB", "createdAt": "2020-07-16T14:02:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3NDc2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3NTE2NA==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r448975164", "bodyText": "Namen sanitizen f\u00fcr filename", "author": "awildturtok", "createdAt": "2020-07-02T12:47:11Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -209,6 +290,36 @@ private ByteIterable write(Object obj, ObjectWriter writer) {\n \t\t}\n \t}\n \n+\t/**\n+\t * Dumps the content of an unreadable value to a file as a json (it tries to parse it as an object and than tries to dump it as a json).\n+\t * @param obj The object to dump.\n+\t * @param keyOfDump The key under which the unreadable value is accessible. It is used for the file name.\n+\t * @param unreadableDumpDir The director to dump to. The method assumes that the directory exists and is okay to write to.\n+\t * @param storeName The name of the store which is also used in the dump file name.\n+\t */\n+\tprivate static void dumpToFile(@NonNull ByteIterable obj, @NonNull String keyOfDump, @NonNull File unreadableDumpDir, @NonNull String storeName) {\n+\t\t// Create dump filehandle\n+\t\tFile dumpfile = new File(Path.of(unreadableDumpDir.getAbsolutePath(), String.format(\"%s-%s-%s.json\",\n+\t\t\t\tDateTimeFormatter.BASIC_ISO_DATE.format(LocalDateTime.now()),\n+\t\t\t\tstoreName,\n+\t\t\t\tkeyOfDump", "originalCommit": "6de402e728ed3f6bdd6f793503248bf5ce8517de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3NTg4NA==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r448975884", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tlog.warn(\"Unable to dump unreadable value of key \" + keyOfDump + \" to file \" + dumpfile +\".\", e);\n          \n          \n            \n            \t\t\tlog.error(\"Unable to dump unreadable value of key `{}` to file `{}`\",keyOfDump, dumpfile, e);", "author": "awildturtok", "createdAt": "2020-07-02T12:48:26Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -209,6 +290,36 @@ private ByteIterable write(Object obj, ObjectWriter writer) {\n \t\t}\n \t}\n \n+\t/**\n+\t * Dumps the content of an unreadable value to a file as a json (it tries to parse it as an object and than tries to dump it as a json).\n+\t * @param obj The object to dump.\n+\t * @param keyOfDump The key under which the unreadable value is accessible. It is used for the file name.\n+\t * @param unreadableDumpDir The director to dump to. The method assumes that the directory exists and is okay to write to.\n+\t * @param storeName The name of the store which is also used in the dump file name.\n+\t */\n+\tprivate static void dumpToFile(@NonNull ByteIterable obj, @NonNull String keyOfDump, @NonNull File unreadableDumpDir, @NonNull String storeName) {\n+\t\t// Create dump filehandle\n+\t\tFile dumpfile = new File(Path.of(unreadableDumpDir.getAbsolutePath(), String.format(\"%s-%s-%s.json\",\n+\t\t\t\tDateTimeFormatter.BASIC_ISO_DATE.format(LocalDateTime.now()),\n+\t\t\t\tstoreName,\n+\t\t\t\tkeyOfDump\n+\t\t\t\t)\n+\t\t\t).toString());\n+\t\tif(dumpfile.exists()) {\n+\t\t\tlog.warn(\"Abort dumping of file {} because it already exists.\",dumpfile);\n+\t\t\treturn;\n+\t\t}\n+\t\t// Write dump\n+\t\ttry {\n+\t\t\tlog.info(\"Dumping value of key {} to {} (because it cannot be deserialized anymore).\", keyOfDump, dumpfile.getCanonicalPath());\n+\t\t\tJsonNode dump = Jackson.BINARY_MAPPER.readerFor(JsonNode.class).readValue(obj.getBytesUnsafe(), 0, obj.getLength());\n+\t\t\tJackson.MAPPER.writer().writeValue(dumpfile, dump);\n+\t\t}\n+\t\tcatch (IOException e) {\n+\t\t\tlog.warn(\"Unable to dump unreadable value of key \" + keyOfDump + \" to file \" + dumpfile +\".\", e);", "originalCommit": "6de402e728ed3f6bdd6f793503248bf5ce8517de", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3NjE2MQ==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r448976161", "bodyText": "reicht null nicht?", "author": "awildturtok", "createdAt": "2020-07-02T12:48:58Z", "path": "backend/src/main/java/com/bakdata/conquery/models/config/StorageConfig.java", "diffHunk": "@@ -21,4 +23,14 @@\n \tprivate boolean useWeakDictionaryCaching = true;\n \t@NotNull\n \tprivate Duration weakCacheDuration = Duration.hours(48);\n+\t\n+\t/**\n+\t * Flag for the {@link SerializingStore} whether to delete values from the underlying store, that cannot be mapped to an object anymore.\n+\t */\n+\tprivate boolean removeUnreadablesFromStore = false;\n+\t\n+\t/**\n+\t * When set, all values that could not be deserialized from the persistent store, are dump into individual files.\n+\t */\n+\tprivate Optional<File> unreadbleDataDumpDirectory = Optional.empty();", "originalCommit": "6de402e728ed3f6bdd6f793503248bf5ce8517de", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTgxMjQwNw==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r455812407", "bodyText": "Ich fand den guava anspruch ganz gut, dass man kein null ausgibt, damit man sich dar\u00fcber Gedanken macht wenn mal etwas nicht gesetzt ist.\nIn einer Klasse intern kann man weiterhin null nutzen, aber da Konfigurationen genau dazu ausgelegt sind, dass sie andere Sachen konfigurieren finde ich optional hier besser", "author": "thoniTUB", "createdAt": "2020-07-16T14:05:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3NjE2MQ=="}], "type": "inlineReview"}, {"oid": "43afcddbc171830970c89db36b82547a6490d416", "url": "https://github.com/bakdata/conquery/commit/43afcddbc171830970c89db36b82547a6490d416", "message": "dump entries that could not be deserialized to file", "committedDate": "2020-07-16T14:34:50Z", "type": "commit"}, {"oid": "ece07c940c95fc63a8ce55b162968fbb45ce4709", "url": "https://github.com/bakdata/conquery/commit/ece07c940c95fc63a8ce55b162968fbb45ce4709", "message": "set config parameter default value", "committedDate": "2020-07-16T14:35:41Z", "type": "commit"}, {"oid": "40905fb3fed450d1c5a9c5793af5493002281a1b", "url": "https://github.com/bakdata/conquery/commit/40905fb3fed450d1c5a9c5793af5493002281a1b", "message": "add comment", "committedDate": "2020-07-16T14:35:41Z", "type": "commit"}, {"oid": "12b3c2109d7d3526cebfa77566afe106d53fac3c", "url": "https://github.com/bakdata/conquery/commit/12b3c2109d7d3526cebfa77566afe106d53fac3c", "message": "adds option to delete unreadble values from store", "committedDate": "2020-07-16T14:35:43Z", "type": "commit"}, {"oid": "a276e50cfd6c15213e11059e30b106ee67da36a1", "url": "https://github.com/bakdata/conquery/commit/a276e50cfd6c15213e11059e30b106ee67da36a1", "message": "automatic update to docs", "committedDate": "2020-07-16T14:36:02Z", "type": "commit"}, {"oid": "df87eb6e40d1f7b100e7419258fb88ff7cf30158", "url": "https://github.com/bakdata/conquery/commit/df87eb6e40d1f7b100e7419258fb88ff7cf30158", "message": "adds null return value when getting an deleted value", "committedDate": "2020-07-16T14:36:04Z", "type": "commit"}, {"oid": "89d7b80b5f67e9a5c79f4e9817edda390f2bbcd4", "url": "https://github.com/bakdata/conquery/commit/89d7b80b5f67e9a5c79f4e9817edda390f2bbcd4", "message": "makes dump funtion static", "committedDate": "2020-07-16T14:36:05Z", "type": "commit"}, {"oid": "868b20ed31eae8800b26586f3cf616eb9dd34b74", "url": "https://github.com/bakdata/conquery/commit/868b20ed31eae8800b26586f3cf616eb9dd34b74", "message": "adds missings method signature changes", "committedDate": "2020-07-16T14:36:05Z", "type": "commit"}, {"oid": "ee05c2c24879aed79ef67f07a04eb2ef0e02031f", "url": "https://github.com/bakdata/conquery/commit/ee05c2c24879aed79ef67f07a04eb2ef0e02031f", "message": "Update backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n\nCo-authored-by: awildturtok <1553491+awildturtok@users.noreply.github.com>", "committedDate": "2020-07-16T14:36:06Z", "type": "commit"}, {"oid": "78debfebc49298e281d3992f67c1de6a6dff1fed", "url": "https://github.com/bakdata/conquery/commit/78debfebc49298e281d3992f67c1de6a6dff1fed", "message": "sanitize dumpfilename", "committedDate": "2020-07-16T14:36:06Z", "type": "commit"}, {"oid": "bdedb2404d02057fb2f10d8095c233a2058b2a30", "url": "https://github.com/bakdata/conquery/commit/bdedb2404d02057fb2f10d8095c233a2058b2a30", "message": "removes unnecessary function parameter", "committedDate": "2020-07-16T14:36:26Z", "type": "commit"}, {"oid": "c766fa9777e9468f229ebebcc10028156c72f086", "url": "https://github.com/bakdata/conquery/commit/c766fa9777e9468f229ebebcc10028156c72f086", "message": "adds test for corrupted values", "committedDate": "2020-07-16T14:36:26Z", "type": "commit"}, {"oid": "32216f71c9c06ffcc0a88264571a90d596503915", "url": "https://github.com/bakdata/conquery/commit/32216f71c9c06ffcc0a88264571a90d596503915", "message": "applies split phase to for-each and adds test for corrupt keys.", "committedDate": "2020-07-16T14:36:27Z", "type": "commit"}, {"oid": "90f99b2f34f811cad1695feb4eb525a4217506ed", "url": "https://github.com/bakdata/conquery/commit/90f99b2f34f811cad1695feb4eb525a4217506ed", "message": "adds test test for removal of corrupt entries", "committedDate": "2020-07-16T14:36:27Z", "type": "commit"}, {"oid": "86253b586f4da9f26fe2c4c31c62dbac4a44a90d", "url": "https://github.com/bakdata/conquery/commit/86253b586f4da9f26fe2c4c31c62dbac4a44a90d", "message": "tests removal of key and value corrupted entries", "committedDate": "2020-07-16T14:36:28Z", "type": "commit"}, {"oid": "c04d1d5efb376ca2f494e9b90fc25ab684bbf800", "url": "https://github.com/bakdata/conquery/commit/c04d1d5efb376ca2f494e9b90fc25ab684bbf800", "message": "clean up the test", "committedDate": "2020-07-16T14:36:29Z", "type": "commit"}, {"oid": "840e9eee470f82fb9211f4ca3edf0cf5adf2f5ac", "url": "https://github.com/bakdata/conquery/commit/840e9eee470f82fb9211f4ca3edf0cf5adf2f5ac", "message": "also test the content auf the dumpfile to be correct", "committedDate": "2020-07-16T14:36:30Z", "type": "commit"}, {"oid": "9ba11eb793a38464c1a4c4cb1bcb66f75aec516d", "url": "https://github.com/bakdata/conquery/commit/9ba11eb793a38464c1a4c4cb1bcb66f75aec516d", "message": "shortens log info", "committedDate": "2020-07-16T14:36:30Z", "type": "commit"}, {"oid": "5aeb8e2e48dcefeb9a663cebd59bfc470382ecba", "url": "https://github.com/bakdata/conquery/commit/5aeb8e2e48dcefeb9a663cebd59bfc470382ecba", "message": "bubble storage config up to not use the global singleton", "committedDate": "2020-07-16T14:36:31Z", "type": "commit"}, {"oid": "5aeb8e2e48dcefeb9a663cebd59bfc470382ecba", "url": "https://github.com/bakdata/conquery/commit/5aeb8e2e48dcefeb9a663cebd59bfc470382ecba", "message": "bubble storage config up to not use the global singleton", "committedDate": "2020-07-16T14:36:31Z", "type": "forcePushed"}, {"oid": "2568b35229fe379fae7276de8fe3035b09a52360", "url": "https://github.com/bakdata/conquery/commit/2568b35229fe379fae7276de8fe3035b09a52360", "message": "Merge 5aeb8e2e48dcefeb9a663cebd59bfc470382ecba into 1a6db33c8864ca4c173045d6dd32b0bcbfab4780", "committedDate": "2020-07-16T14:37:31Z", "type": "commit"}, {"oid": "3da3ca60bc214ce77a1e1d0d6d74a2aad55dd4b9", "url": "https://github.com/bakdata/conquery/commit/3da3ca60bc214ce77a1e1d0d6d74a2aad55dd4b9", "message": "automatic update to docs", "committedDate": "2020-07-16T14:39:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwODI4Ng==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456308286", "bodyText": "Finde ich in get fragw\u00fcrdig weil du dann theoretisch immer IO im hauptpfad hast", "author": "awildturtok", "createdAt": "2020-07-17T08:47:36Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -115,22 +151,90 @@ public void add(KEY key, VALUE value) throws JSONException {\n \n \t@Override\n \tpublic VALUE get(KEY key) {\n-\t\treturn readValue(store.get(writeKey(key)));\n+\t\tByteIterable binValue = store.get(writeKey(key));\n+\t\ttry {\n+\t\t\treturn readValue(binValue);\t\t\t\n+\t\t} catch (Exception e) {\n+\t\t\tif(unreadableValuesDumpDir != null) {", "originalCommit": "3da3ca60bc214ce77a1e1d0d6d74a2aad55dd4b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM5MTEyNQ==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456391125", "bodyText": "Aber der ganze store ist doch IO", "author": "thoniTUB", "createdAt": "2020-07-17T11:45:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwODI4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM5MTc3Nw==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456391777", "bodyText": "Lol, Fair!", "author": "awildturtok", "createdAt": "2020-07-17T11:47:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwODI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwODg4NQ==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456308885", "bodyText": "Das du da den BinaryMaper verwendest sieht mir falsch aus. reicht es nicht die Daten einfach zu dumpen?", "author": "awildturtok", "createdAt": "2020-07-17T08:48:42Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -115,22 +151,90 @@ public void add(KEY key, VALUE value) throws JSONException {\n \n \t@Override\n \tpublic VALUE get(KEY key) {\n-\t\treturn readValue(store.get(writeKey(key)));\n+\t\tByteIterable binValue = store.get(writeKey(key));\n+\t\ttry {\n+\t\t\treturn readValue(binValue);\t\t\t\n+\t\t} catch (Exception e) {\n+\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\tdumpToFile(binValue, key.toString(), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t}\n+\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\tremove(key);\n+\t\t\t\t// Null seems to be an acceptable return value in this case\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tThrowables.throwIfUnchecked(e);\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n \t}\n \n \t@Override\n-\tpublic void forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\tpublic IterationResult forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\t\tIterationResult result = new IterationResult();\n+\t\tArrayList<ByteIterable> unreadables = new ArrayList<>();\n \t\tstore.forEach((k, v) -> {\n+\t\t\tresult.incrTotalProcessed();\n+\t\t\t// Try to read the key first\n+\t\t\tKEY key = null;\n \t\t\ttry {\n-\t\t\t\ttry {\n-\t\t\t\t\tconsumer.accept(readKey(k), readValue(v), v.getLength());\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tlog.warn(\"Could not parse value for key \" + readKey(k), e);\n+\t\t\t\tkey = readKey(k);\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tdumpToFile(v, Jackson.BINARY_MAPPER.readerFor(String.class).readValue(k.getBytesUnsafe()), unreadableValuesDumpDir, storeInfo.getXodusName());", "originalCommit": "3da3ca60bc214ce77a1e1d0d6d74a2aad55dd4b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM3OTA4Mw==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456379083", "bodyText": "Ich m\u00f6chte aber schon einen sinnigen Dateinamen haben. Da dachte ich dass der Key eines Objektes ganz gut ist", "author": "thoniTUB", "createdAt": "2020-07-17T11:15:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwODg4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQyMzIzOQ==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456423239", "bodyText": "Ich nehme jetzt die unsafe bytes zu einem String und lasse dar\u00fcber den savefilename regex laufen.", "author": "thoniTUB", "createdAt": "2020-07-17T12:54:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwODg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwOTU3Ng==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456309576", "bodyText": "Refactor mal den ganzen Try-Catch Block in eine Funtion die eine Deserialisierende Funktion bekommt und einen Wert rausgibt, dann sparst du dir redundanz und aufgebl\u00e4hten code", "author": "awildturtok", "createdAt": "2020-07-17T08:49:57Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -115,22 +151,90 @@ public void add(KEY key, VALUE value) throws JSONException {\n \n \t@Override\n \tpublic VALUE get(KEY key) {\n-\t\treturn readValue(store.get(writeKey(key)));\n+\t\tByteIterable binValue = store.get(writeKey(key));\n+\t\ttry {\n+\t\t\treturn readValue(binValue);\t\t\t\n+\t\t} catch (Exception e) {\n+\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\tdumpToFile(binValue, key.toString(), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t}\n+\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\tremove(key);\n+\t\t\t\t// Null seems to be an acceptable return value in this case\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tThrowables.throwIfUnchecked(e);\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n \t}\n \n \t@Override\n-\tpublic void forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\tpublic IterationResult forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\t\tIterationResult result = new IterationResult();\n+\t\tArrayList<ByteIterable> unreadables = new ArrayList<>();\n \t\tstore.forEach((k, v) -> {\n+\t\t\tresult.incrTotalProcessed();\n+\t\t\t// Try to read the key first\n+\t\t\tKEY key = null;\n \t\t\ttry {\n-\t\t\t\ttry {\n-\t\t\t\t\tconsumer.accept(readKey(k), readValue(v), v.getLength());\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tlog.warn(\"Could not parse value for key \" + readKey(k), e);\n+\t\t\t\tkey = readKey(k);", "originalCommit": "3da3ca60bc214ce77a1e1d0d6d74a2aad55dd4b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQyMzY0OA==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456423648", "bodyText": "hab die Funktion ausgelagert", "author": "thoniTUB", "createdAt": "2020-07-17T12:54:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwOTU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwOTk1OQ==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456309959", "bodyText": "das if kannst du dir hier sparen weil du hier ja nur collectest", "author": "awildturtok", "createdAt": "2020-07-17T08:50:40Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -115,22 +151,90 @@ public void add(KEY key, VALUE value) throws JSONException {\n \n \t@Override\n \tpublic VALUE get(KEY key) {\n-\t\treturn readValue(store.get(writeKey(key)));\n+\t\tByteIterable binValue = store.get(writeKey(key));\n+\t\ttry {\n+\t\t\treturn readValue(binValue);\t\t\t\n+\t\t} catch (Exception e) {\n+\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\tdumpToFile(binValue, key.toString(), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t}\n+\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\tremove(key);\n+\t\t\t\t// Null seems to be an acceptable return value in this case\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tThrowables.throwIfUnchecked(e);\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n \t}\n \n \t@Override\n-\tpublic void forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\tpublic IterationResult forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\t\tIterationResult result = new IterationResult();\n+\t\tArrayList<ByteIterable> unreadables = new ArrayList<>();\n \t\tstore.forEach((k, v) -> {\n+\t\t\tresult.incrTotalProcessed();\n+\t\t\t// Try to read the key first\n+\t\t\tKEY key = null;\n \t\t\ttry {\n-\t\t\t\ttry {\n-\t\t\t\t\tconsumer.accept(readKey(k), readValue(v), v.getLength());\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tlog.warn(\"Could not parse value for key \" + readKey(k), e);\n+\t\t\t\tkey = readKey(k);\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tdumpToFile(v, Jackson.BINARY_MAPPER.readerFor(String.class).readValue(k.getBytesUnsafe()), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (IOException e1) {\n+\t\t\t\t\t\tlog.warn(\"Cannot dump value for key (Bytes {}) to file because the key could not be parsed to in to a String\", k.toString());\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tlog.warn(\"Could not parse key \" + k, e);\n \t\t\t\t}\n+\t\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\t\tunreadables.add(k);\n+\t\t\t\t}\n+\t\t\t\tresult.incrFailedKeys();\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\t\n+\t\t\t// Try to read the value\n+\t\t\tVALUE value = null;\n+\t\t\ttry {\n+\t\t\t\tvalue = readValue(v);\n \t\t\t} catch (Exception e) {\n-\t\t\t\tlog.warn(\"Could not parse key \" + k, e);\n+\t\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\t\tdumpToFile(v, key.toString(), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t\t} else {\n+\t\t\t\t\tlog.warn(\"Could not parse value for key \" + key, e);\t\t\t\t\t\t\n+\t\t\t\t}\n+\t\t\t\tif(removeUnreadablesFromUnderlyingStore) {", "originalCommit": "3da3ca60bc214ce77a1e1d0d6d74a2aad55dd4b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxMDEzMA==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456310130", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tlog.info(\"Removing {} unreadable elements from the store {}.\", unreadables.size(), storeInfo.getXodusName());\n          \n          \n            \n            \t\t\tlog.warn(\"Removing {} unreadable elements from the store {}.\", unreadables.size(), storeInfo.getXodusName());", "author": "awildturtok", "createdAt": "2020-07-17T08:50:56Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -115,22 +151,90 @@ public void add(KEY key, VALUE value) throws JSONException {\n \n \t@Override\n \tpublic VALUE get(KEY key) {\n-\t\treturn readValue(store.get(writeKey(key)));\n+\t\tByteIterable binValue = store.get(writeKey(key));\n+\t\ttry {\n+\t\t\treturn readValue(binValue);\t\t\t\n+\t\t} catch (Exception e) {\n+\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\tdumpToFile(binValue, key.toString(), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t}\n+\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\tremove(key);\n+\t\t\t\t// Null seems to be an acceptable return value in this case\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tThrowables.throwIfUnchecked(e);\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n \t}\n \n \t@Override\n-\tpublic void forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\tpublic IterationResult forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\t\tIterationResult result = new IterationResult();\n+\t\tArrayList<ByteIterable> unreadables = new ArrayList<>();\n \t\tstore.forEach((k, v) -> {\n+\t\t\tresult.incrTotalProcessed();\n+\t\t\t// Try to read the key first\n+\t\t\tKEY key = null;\n \t\t\ttry {\n-\t\t\t\ttry {\n-\t\t\t\t\tconsumer.accept(readKey(k), readValue(v), v.getLength());\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tlog.warn(\"Could not parse value for key \" + readKey(k), e);\n+\t\t\t\tkey = readKey(k);\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\t\ttry {\n+\t\t\t\t\t\tdumpToFile(v, Jackson.BINARY_MAPPER.readerFor(String.class).readValue(k.getBytesUnsafe()), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t\t\t}\n+\t\t\t\t\tcatch (IOException e1) {\n+\t\t\t\t\t\tlog.warn(\"Cannot dump value for key (Bytes {}) to file because the key could not be parsed to in to a String\", k.toString());\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tlog.warn(\"Could not parse key \" + k, e);\n \t\t\t\t}\n+\t\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\t\tunreadables.add(k);\n+\t\t\t\t}\n+\t\t\t\tresult.incrFailedKeys();\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\t\n+\t\t\t// Try to read the value\n+\t\t\tVALUE value = null;\n+\t\t\ttry {\n+\t\t\t\tvalue = readValue(v);\n \t\t\t} catch (Exception e) {\n-\t\t\t\tlog.warn(\"Could not parse key \" + k, e);\n+\t\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\t\tdumpToFile(v, key.toString(), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t\t} else {\n+\t\t\t\t\tlog.warn(\"Could not parse value for key \" + key, e);\t\t\t\t\t\t\n+\t\t\t\t}\n+\t\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\t\tunreadables.add(k);\n+\t\t\t\t}\n+\t\t\t\tresult.incrFailedValues();\n+\t\t\t\treturn;\n \t\t\t}\n+\t\t\t\n+\t\t\t// Apply the conusmer to key and value\n+\t\t\ttry {\n+\t\t\t\tconsumer.accept(key, value, v.getLength());\n+\t\t\t} catch (Exception e) {\n+\t\t\t\tlog.warn(\"Unable to apply for-each consumer on key[{}]\", key, e);\n+\t\t\t}\n+\n \t\t});\n+\t\t// Print some statistics\n+\t\tlog.info(String.format(\"While processing store %s:\\n\\tEntries processed:\\t%d\\n\\tKey read failure:\\t%d (%.2f%%)\\n\\tValue read failure:\\t%d (%.2f%%)\",\n+\t\t\tthis.storeInfo.getXodusName(),\n+\t\t\tresult.getTotalProcessed(), result.getFailedKeys(),\n+\t\t\t(float) result.getFailedKeys()/result.getTotalProcessed()*100,\n+\t\t\tresult.getFailedValues(),\n+\t\t\t(float) result.getFailedValues()/result.getTotalProcessed()*100));\n+\t\t\n+\t\t// Remove corrupted entries from the store if configured so\n+\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\tlog.info(\"Removing {} unreadable elements from the store {}.\", unreadables.size(), storeInfo.getXodusName());", "originalCommit": "3da3ca60bc214ce77a1e1d0d6d74a2aad55dd4b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxMDMzNw==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456310337", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tlog.trace(\"Removing value to key {} from store\", key, storeInfo.getXodusName());\n          \n          \n            \n            \t\tlog.trace(\"Removing value to key {} from Store[{}]\", key, storeInfo.getXodusName());", "author": "awildturtok", "createdAt": "2020-07-17T08:51:22Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -148,6 +252,7 @@ public void update(KEY key, VALUE value) throws JSONException {\n \n \t@Override\n \tpublic void remove(KEY key) {\n+\t\tlog.trace(\"Removing value to key {} from store\", key, storeInfo.getXodusName());", "originalCommit": "3da3ca60bc214ce77a1e1d0d6d74a2aad55dd4b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxMDc5NA==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456310794", "bodyText": "W\u00e4re glaube ich auch Sinnvoller alles in eine Datei zu schreiben/appenden, dann sparst du dir IO und File Handles.", "author": "awildturtok", "createdAt": "2020-07-17T08:52:13Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -209,6 +314,44 @@ private ByteIterable write(Object obj, ObjectWriter writer) {\n \t\t}\n \t}\n \n+\t/**\n+\t * Dumps the content of an unreadable value to a file as a json (it tries to parse it as an object and than tries to dump it as a json).\n+\t * @param obj The object to dump.\n+\t * @param keyOfDump The key under which the unreadable value is accessible. It is used for the file name.\n+\t * @param unreadableDumpDir The director to dump to. The method assumes that the directory exists and is okay to write to.\n+\t * @param storeName The name of the store which is also used in the dump file name.\n+\t */\n+\tprivate static void dumpToFile(@NonNull ByteIterable obj, @NonNull String keyOfDump, @NonNull File unreadableDumpDir, @NonNull String storeName) {", "originalCommit": "3da3ca60bc214ce77a1e1d0d6d74a2aad55dd4b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM5NDA1Ng==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456394056", "bodyText": "Da die dumps momentan leichter mit find und grep zu sichten sind lasse ich es erstmal so", "author": "thoniTUB", "createdAt": "2020-07-17T11:52:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxMDc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMxMTc2NA==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456311764", "bodyText": "https://stackoverflow.com/a/15075907/409761", "author": "awildturtok", "createdAt": "2020-07-17T08:54:07Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -209,6 +314,44 @@ private ByteIterable write(Object obj, ObjectWriter writer) {\n \t\t}\n \t}\n \n+\t/**\n+\t * Dumps the content of an unreadable value to a file as a json (it tries to parse it as an object and than tries to dump it as a json).\n+\t * @param obj The object to dump.\n+\t * @param keyOfDump The key under which the unreadable value is accessible. It is used for the file name.\n+\t * @param unreadableDumpDir The director to dump to. The method assumes that the directory exists and is okay to write to.\n+\t * @param storeName The name of the store which is also used in the dump file name.\n+\t */\n+\tprivate static void dumpToFile(@NonNull ByteIterable obj, @NonNull String keyOfDump, @NonNull File unreadableDumpDir, @NonNull String storeName) {\n+\t\t// Create dump filehandle\n+\t\tFile dumpfile = new File(unreadableDumpDir, makeDumpfileName(keyOfDump, storeName));\n+\t\tif(dumpfile.exists()) {\n+\t\t\tlog.warn(\"Abort dumping of file {} because it already exists.\",dumpfile);\n+\t\t\treturn;\n+\t\t}\n+\t\t// Write dump\n+\t\ttry {\n+\t\t\tlog.info(\"Dumping value of key {} to {} (because it cannot be deserialized anymore).\", keyOfDump, dumpfile.getCanonicalPath());\n+\t\t\tJsonNode dump = Jackson.BINARY_MAPPER.readerFor(JsonNode.class).readValue(obj.getBytesUnsafe(), 0, obj.getLength());\n+\t\t\tJackson.MAPPER.writer().writeValue(dumpfile, dump);\n+\t\t}\n+\t\tcatch (IOException e) {\n+\t\t\tlog.error(\"Unable to dump unreadable value of key `{}` to file `{}`\",keyOfDump, dumpfile, e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Generates a valid file name from the key of the dump object, the store and the current time.\n+\t * However, it does not ensure that there is no file with such a name.\n+\t */\n+\tprivate static String makeDumpfileName(String keyOfDump, String storeName) {\n+\t\treturn String.format(\"%s-%s-%s.%s\",\n+\t\t\tDateTimeFormatter.BASIC_ISO_DATE.format(LocalDateTime.now()),\n+\t\t\tstoreName,\n+\t\t\tkeyOfDump,\n+\t\t\tDUMP_FILE_EXTENTION\n+\t\t\t).replaceAll(\"[\\\\\\\\/:*?\\\"<>|]\", \"\");", "originalCommit": "3da3ca60bc214ce77a1e1d0d6d74a2aad55dd4b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fb2e9c601db55683af7525e398623c6a6fe1bb9d", "url": "https://github.com/bakdata/conquery/commit/fb2e9c601db55683af7525e398623c6a6fe1bb9d", "message": "Update backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n\nCo-authored-by: awildturtok <1553491+awildturtok@users.noreply.github.com>", "committedDate": "2020-07-17T11:15:00Z", "type": "commit"}, {"oid": "fe8a96fa5955a909533e70bdd9ada4917ca3fb38", "url": "https://github.com/bakdata/conquery/commit/fe8a96fa5955a909533e70bdd9ada4917ca3fb38", "message": "Update backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java\n\nCo-authored-by: awildturtok <1553491+awildturtok@users.noreply.github.com>", "committedDate": "2020-07-17T11:15:32Z", "type": "commit"}, {"oid": "bd14e7d178e972736ca317e157228eea46e180b2", "url": "https://github.com/bakdata/conquery/commit/bd14e7d178e972736ca317e157228eea46e180b2", "message": "change sanitizer statement", "committedDate": "2020-07-17T11:51:06Z", "type": "commit"}, {"oid": "68f76b37a2e4b681d5bb946efbb720e2e924a0cf", "url": "https://github.com/bakdata/conquery/commit/68f76b37a2e4b681d5bb946efbb720e2e924a0cf", "message": "remove unnecessary ifs for collection", "committedDate": "2020-07-17T11:54:34Z", "type": "commit"}, {"oid": "7f8b309ea8b932a096105b227ddd48b257a7c19e", "url": "https://github.com/bakdata/conquery/commit/7f8b309ea8b932a096105b227ddd48b257a7c19e", "message": "extracts method for deserialization", "committedDate": "2020-07-17T12:26:51Z", "type": "commit"}, {"oid": "82ec48ee07b0259ec924c2c89db610446bdc6b3a", "url": "https://github.com/bakdata/conquery/commit/82ec48ee07b0259ec924c2c89db610446bdc6b3a", "message": "extracts dumping into deserialization method", "committedDate": "2020-07-17T12:44:13Z", "type": "commit"}, {"oid": "b069cbdfd6f691d4fde2d997189d3304c83a5620", "url": "https://github.com/bakdata/conquery/commit/b069cbdfd6f691d4fde2d997189d3304c83a5620", "message": "compiles the regex once", "committedDate": "2020-07-17T12:52:58Z", "type": "commit"}, {"oid": "0b97152388bee6773ae9b50f23a0271cc3d1b520", "url": "https://github.com/bakdata/conquery/commit/0b97152388bee6773ae9b50f23a0271cc3d1b520", "message": "Merge branch 'develop' into feature/dump-entries-that-could-not-be-deserialized", "committedDate": "2020-07-17T12:55:28Z", "type": "commit"}, {"oid": "2dca2869f2c11f75d194d10b66a5be08706a494e", "url": "https://github.com/bakdata/conquery/commit/2dca2869f2c11f75d194d10b66a5be08706a494e", "message": "surpress NaN output", "committedDate": "2020-07-17T13:10:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzMjcxNA==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456432714", "bodyText": "Ist das nicht sogar komplett statisch?", "author": "awildturtok", "createdAt": "2020-07-17T13:12:24Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -115,22 +155,100 @@ public void add(KEY key, VALUE value) throws JSONException {\n \n \t@Override\n \tpublic VALUE get(KEY key) {\n-\t\treturn readValue(store.get(writeKey(key)));\n+\t\tByteIterable binValue = store.get(writeKey(key));\n+\t\ttry {\n+\t\t\treturn readValue(binValue);\t\t\t\n+\t\t} catch (Exception e) {\n+\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\tdumpToFile(binValue, key.toString(), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t}\n+\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\tremove(key);\n+\t\t\t\t// Null seems to be an acceptable return value in this case\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tThrowables.throwIfUnchecked(e);\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n \t}\n \n+\t/**\n+\t * Iterates a given consumer over the entries of this store.\n+\t * Depending on the {@link StorageConfig} corrupt entries may be dump to a file and/or removed from the store.\n+\t * These entries are not submitted to the consumer.\n+\t */\n \t@Override\n-\tpublic void forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\tpublic IterationStatistic forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\t\tIterationStatistic result = new IterationStatistic();\n+\t\tArrayList<ByteIterable> unreadables = new ArrayList<>();\n \t\tstore.forEach((k, v) -> {\n+\t\t\tresult.incrTotalProcessed();\n+\n+\t\t\t// Try to read the key first\n+\t\t\tKEY key = getDeserializedAndDumpFailed(\n+\t\t\t\tk,\n+\t\t\t\tthis::readKey,\n+\t\t\t\t() -> new String(k.getBytesUnsafe()),\n+\t\t\t\tv,\n+\t\t\t\t\"Could not parse key [{}]\");\n+\t\t\tif (key == null) {\n+\t\t\t\tunreadables.add(k);\n+\t\t\t\tresult.incrFailedKeys();\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\t// Try to read the value\n+\t\t\tVALUE value = getDeserializedAndDumpFailed(\n+\t\t\t\tv, \n+\t\t\t\tthis::readValue, \n+\t\t\t\t() -> key.toString(),\n+\t\t\t\tv, \n+\t\t\t\t\"Could not parse value for key [{}]\");\n+\t\t\tif (value == null) {\n+\t\t\t\tunreadables.add(k);\n+\t\t\t\tresult.incrFailedValues();\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\t// Apply the conusmer to key and value\n \t\t\ttry {\n-\t\t\t\ttry {\n-\t\t\t\t\tconsumer.accept(readKey(k), readValue(v), v.getLength());\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tlog.warn(\"Could not parse value for key \" + readKey(k), e);\n-\t\t\t\t}\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tlog.warn(\"Could not parse key \" + k, e);\n+\t\t\t\tconsumer.accept(key, value, v.getLength());\n+\t\t\t}\n+\t\t\tcatch (Exception e) {\n+\t\t\t\tlog.warn(\"Unable to apply for-each consumer on key[{}]\", key, e);\n \t\t\t}\n+\n \t\t});\n+\t\t// Print some statistics\n+\t\tlog.info(\n+\t\t\tString.format(\n+\t\t\t\t\"While processing store %s:\\n\\tEntries processed:\\t%d\\n\\tKey read failure:\\t%d (%.2f%%)\\n\\tValue read failure:\\t%d (%.2f%%)\",\n+\t\t\t\tthis.storeInfo.getXodusName(),\n+\t\t\t\tresult.getTotalProcessed(),\n+\t\t\t\tresult.getFailedKeys(),\n+\t\t\t\t(float) result.getFailedKeys() / result.getTotalProcessed() * 100,\n+\t\t\t\tresult.getFailedValues(),\n+\t\t\t\t(float) result.getFailedValues() / result.getTotalProcessed() * 100));\n+\n+\t\t// Remove corrupted entries from the store if configured so\n+\t\tif (removeUnreadablesFromUnderlyingStore) {\n+\t\t\tlog.warn(\"Removing {} unreadable elements from the store {}.\", unreadables.size(), storeInfo.getXodusName());\n+\t\t\tunreadables.forEach(store::remove);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\t\n+\tprivate <TYPE> TYPE getDeserializedAndDumpFailed(ByteIterable serial, Function<ByteIterable, TYPE> deserializer, Supplier<String> onFailKeyStringSupplier, ByteIterable onFailOrigValue, String onFailWarnMsgFmt ){", "originalCommit": "0b97152388bee6773ae9b50f23a0271cc3d1b520", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ1OTYzMw==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456459633", "bodyText": "Ja das kann man machen, dann m\u00fcssten die Config parameter noch reingereicht werden, aber dann ist die Parameterliste super lang.\nDa die Methode privat ist w\u00fcrde ich es so lassen", "author": "thoniTUB", "createdAt": "2020-07-17T13:58:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzMjcxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNDAwMg==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456434002", "bodyText": "Sollte das nicht immer warnen?", "author": "awildturtok", "createdAt": "2020-07-17T13:14:42Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -115,22 +155,100 @@ public void add(KEY key, VALUE value) throws JSONException {\n \n \t@Override\n \tpublic VALUE get(KEY key) {\n-\t\treturn readValue(store.get(writeKey(key)));\n+\t\tByteIterable binValue = store.get(writeKey(key));\n+\t\ttry {\n+\t\t\treturn readValue(binValue);\t\t\t\n+\t\t} catch (Exception e) {\n+\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\tdumpToFile(binValue, key.toString(), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t}\n+\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\tremove(key);\n+\t\t\t\t// Null seems to be an acceptable return value in this case\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tThrowables.throwIfUnchecked(e);\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n \t}\n \n+\t/**\n+\t * Iterates a given consumer over the entries of this store.\n+\t * Depending on the {@link StorageConfig} corrupt entries may be dump to a file and/or removed from the store.\n+\t * These entries are not submitted to the consumer.\n+\t */\n \t@Override\n-\tpublic void forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\tpublic IterationStatistic forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\t\tIterationStatistic result = new IterationStatistic();\n+\t\tArrayList<ByteIterable> unreadables = new ArrayList<>();\n \t\tstore.forEach((k, v) -> {\n+\t\t\tresult.incrTotalProcessed();\n+\n+\t\t\t// Try to read the key first\n+\t\t\tKEY key = getDeserializedAndDumpFailed(\n+\t\t\t\tk,\n+\t\t\t\tthis::readKey,\n+\t\t\t\t() -> new String(k.getBytesUnsafe()),\n+\t\t\t\tv,\n+\t\t\t\t\"Could not parse key [{}]\");\n+\t\t\tif (key == null) {\n+\t\t\t\tunreadables.add(k);\n+\t\t\t\tresult.incrFailedKeys();\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\t// Try to read the value\n+\t\t\tVALUE value = getDeserializedAndDumpFailed(\n+\t\t\t\tv, \n+\t\t\t\tthis::readValue, \n+\t\t\t\t() -> key.toString(),\n+\t\t\t\tv, \n+\t\t\t\t\"Could not parse value for key [{}]\");\n+\t\t\tif (value == null) {\n+\t\t\t\tunreadables.add(k);\n+\t\t\t\tresult.incrFailedValues();\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\t// Apply the conusmer to key and value\n \t\t\ttry {\n-\t\t\t\ttry {\n-\t\t\t\t\tconsumer.accept(readKey(k), readValue(v), v.getLength());\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tlog.warn(\"Could not parse value for key \" + readKey(k), e);\n-\t\t\t\t}\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tlog.warn(\"Could not parse key \" + k, e);\n+\t\t\t\tconsumer.accept(key, value, v.getLength());\n+\t\t\t}\n+\t\t\tcatch (Exception e) {\n+\t\t\t\tlog.warn(\"Unable to apply for-each consumer on key[{}]\", key, e);\n \t\t\t}\n+\n \t\t});\n+\t\t// Print some statistics\n+\t\tlog.info(\n+\t\t\tString.format(\n+\t\t\t\t\"While processing store %s:\\n\\tEntries processed:\\t%d\\n\\tKey read failure:\\t%d (%.2f%%)\\n\\tValue read failure:\\t%d (%.2f%%)\",\n+\t\t\t\tthis.storeInfo.getXodusName(),\n+\t\t\t\tresult.getTotalProcessed(),\n+\t\t\t\tresult.getFailedKeys(),\n+\t\t\t\t(float) result.getFailedKeys() / result.getTotalProcessed() * 100,\n+\t\t\t\tresult.getFailedValues(),\n+\t\t\t\t(float) result.getFailedValues() / result.getTotalProcessed() * 100));\n+\n+\t\t// Remove corrupted entries from the store if configured so\n+\t\tif (removeUnreadablesFromUnderlyingStore) {\n+\t\t\tlog.warn(\"Removing {} unreadable elements from the store {}.\", unreadables.size(), storeInfo.getXodusName());\n+\t\t\tunreadables.forEach(store::remove);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\t\n+\tprivate <TYPE> TYPE getDeserializedAndDumpFailed(ByteIterable serial, Function<ByteIterable, TYPE> deserializer, Supplier<String> onFailKeyStringSupplier, ByteIterable onFailOrigValue, String onFailWarnMsgFmt ){\n+\t\ttry {\n+\t\t\treturn deserializer.apply(serial);\t\t\t\n+\t\t} catch (Exception e) {\n+\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\tdumpToFile(onFailOrigValue, onFailKeyStringSupplier.get(), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t} else {\n+\t\t\t\tlog.warn(onFailWarnMsgFmt, onFailKeyStringSupplier.get(), e);", "originalCommit": "0b97152388bee6773ae9b50f23a0271cc3d1b520", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNDE0Ng==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456434146", "bodyText": "Sonst wei\u00dft du ja gar nicht sicher, dass es was gedumpt hat?", "author": "awildturtok", "createdAt": "2020-07-17T13:14:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNDAwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQ2MTk3Mw==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456461973", "bodyText": "ich habs etwas umge\u00e4ndert damit der stacktrace nur geworfen wird, wenn TRACE aktiviert wird", "author": "thoniTUB", "createdAt": "2020-07-17T14:01:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNDAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNDQ0Ng==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456434446", "bodyText": "hier fehlt etwas doku aber brauchst es nicht \u00fcbertreiben intention reicht", "author": "awildturtok", "createdAt": "2020-07-17T13:15:28Z", "path": "backend/src/main/java/com/bakdata/conquery/io/xodus/stores/SerializingStore.java", "diffHunk": "@@ -115,22 +155,100 @@ public void add(KEY key, VALUE value) throws JSONException {\n \n \t@Override\n \tpublic VALUE get(KEY key) {\n-\t\treturn readValue(store.get(writeKey(key)));\n+\t\tByteIterable binValue = store.get(writeKey(key));\n+\t\ttry {\n+\t\t\treturn readValue(binValue);\t\t\t\n+\t\t} catch (Exception e) {\n+\t\t\tif(unreadableValuesDumpDir != null) {\n+\t\t\t\tdumpToFile(binValue, key.toString(), unreadableValuesDumpDir, storeInfo.getXodusName());\n+\t\t\t}\n+\t\t\tif(removeUnreadablesFromUnderlyingStore) {\n+\t\t\t\tremove(key);\n+\t\t\t\t// Null seems to be an acceptable return value in this case\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tThrowables.throwIfUnchecked(e);\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n \t}\n \n+\t/**\n+\t * Iterates a given consumer over the entries of this store.\n+\t * Depending on the {@link StorageConfig} corrupt entries may be dump to a file and/or removed from the store.\n+\t * These entries are not submitted to the consumer.\n+\t */\n \t@Override\n-\tpublic void forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\tpublic IterationStatistic forEach(StoreEntryConsumer<KEY, VALUE> consumer) {\n+\t\tIterationStatistic result = new IterationStatistic();\n+\t\tArrayList<ByteIterable> unreadables = new ArrayList<>();\n \t\tstore.forEach((k, v) -> {\n+\t\t\tresult.incrTotalProcessed();\n+\n+\t\t\t// Try to read the key first\n+\t\t\tKEY key = getDeserializedAndDumpFailed(\n+\t\t\t\tk,\n+\t\t\t\tthis::readKey,\n+\t\t\t\t() -> new String(k.getBytesUnsafe()),\n+\t\t\t\tv,\n+\t\t\t\t\"Could not parse key [{}]\");\n+\t\t\tif (key == null) {\n+\t\t\t\tunreadables.add(k);\n+\t\t\t\tresult.incrFailedKeys();\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\t// Try to read the value\n+\t\t\tVALUE value = getDeserializedAndDumpFailed(\n+\t\t\t\tv, \n+\t\t\t\tthis::readValue, \n+\t\t\t\t() -> key.toString(),\n+\t\t\t\tv, \n+\t\t\t\t\"Could not parse value for key [{}]\");\n+\t\t\tif (value == null) {\n+\t\t\t\tunreadables.add(k);\n+\t\t\t\tresult.incrFailedValues();\n+\t\t\t\treturn;\n+\t\t\t}\n+\n+\t\t\t// Apply the conusmer to key and value\n \t\t\ttry {\n-\t\t\t\ttry {\n-\t\t\t\t\tconsumer.accept(readKey(k), readValue(v), v.getLength());\n-\t\t\t\t} catch (Exception e) {\n-\t\t\t\t\tlog.warn(\"Could not parse value for key \" + readKey(k), e);\n-\t\t\t\t}\n-\t\t\t} catch (Exception e) {\n-\t\t\t\tlog.warn(\"Could not parse key \" + k, e);\n+\t\t\t\tconsumer.accept(key, value, v.getLength());\n+\t\t\t}\n+\t\t\tcatch (Exception e) {\n+\t\t\t\tlog.warn(\"Unable to apply for-each consumer on key[{}]\", key, e);\n \t\t\t}\n+\n \t\t});\n+\t\t// Print some statistics\n+\t\tlog.info(\n+\t\t\tString.format(\n+\t\t\t\t\"While processing store %s:\\n\\tEntries processed:\\t%d\\n\\tKey read failure:\\t%d (%.2f%%)\\n\\tValue read failure:\\t%d (%.2f%%)\",\n+\t\t\t\tthis.storeInfo.getXodusName(),\n+\t\t\t\tresult.getTotalProcessed(),\n+\t\t\t\tresult.getFailedKeys(),\n+\t\t\t\t(float) result.getFailedKeys() / result.getTotalProcessed() * 100,\n+\t\t\t\tresult.getFailedValues(),\n+\t\t\t\t(float) result.getFailedValues() / result.getTotalProcessed() * 100));\n+\n+\t\t// Remove corrupted entries from the store if configured so\n+\t\tif (removeUnreadablesFromUnderlyingStore) {\n+\t\t\tlog.warn(\"Removing {} unreadable elements from the store {}.\", unreadables.size(), storeInfo.getXodusName());\n+\t\t\tunreadables.forEach(store::remove);\n+\t\t}\n+\t\treturn result;\n+\t}\n+\t\n+\tprivate <TYPE> TYPE getDeserializedAndDumpFailed(ByteIterable serial, Function<ByteIterable, TYPE> deserializer, Supplier<String> onFailKeyStringSupplier, ByteIterable onFailOrigValue, String onFailWarnMsgFmt ){", "originalCommit": "0b97152388bee6773ae9b50f23a0271cc3d1b520", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNjg5MA==", "url": "https://github.com/bakdata/conquery/pull/1247#discussion_r456436890", "bodyText": "Das nimmt auch ein Lambda wie in PreprocessorCommand: listFiles(((dir, name) -> name.endsWith(ConqueryConstants.EXTENSION_DESCRIPTION)));", "author": "awildturtok", "createdAt": "2020-07-17T13:20:04Z", "path": "backend/src/test/java/com/bakdata/conquery/io/xodus/stores/SerializingStoreDumpTest.java", "diffHunk": "@@ -0,0 +1,216 @@\n+package com.bakdata.conquery.io.xodus.stores;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.io.File;\n+import java.io.FileFilter;\n+import java.io.IOException;\n+import java.util.Optional;\n+import java.util.UUID;\n+\n+import javax.validation.Validator;\n+\n+import com.bakdata.conquery.apiv1.QueryDescription;\n+import com.bakdata.conquery.io.jackson.Jackson;\n+import com.bakdata.conquery.io.xodus.StoreInfo;\n+import com.bakdata.conquery.io.xodus.stores.SerializingStore.IterationStatistic;\n+import com.bakdata.conquery.models.auth.entities.User;\n+import com.bakdata.conquery.models.config.StorageConfig;\n+import com.bakdata.conquery.models.exceptions.JSONException;\n+import com.bakdata.conquery.models.identifiable.ids.specific.DatasetId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.ManagedExecutionId;\n+import com.bakdata.conquery.models.identifiable.ids.specific.UserId;\n+import com.bakdata.conquery.models.query.concept.ConceptQuery;\n+import com.bakdata.conquery.models.query.concept.specific.CQReusedQuery;\n+import com.google.common.io.Files;\n+import io.dropwizard.jersey.validation.Validators;\n+import jetbrains.exodus.env.Environment;\n+import jetbrains.exodus.env.Environments;\n+import lombok.Getter;\n+import lombok.RequiredArgsConstructor;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FileUtils;\n+import org.assertj.core.api.Condition;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+@Slf4j\n+public class SerializingStoreDumpTest {\n+\n+\tprivate File tmpDir;\n+\tprivate Environment env;\n+\tprivate StorageConfig config;\n+\t\n+\t// Test data\n+\tprivate final ConceptQuery cQuery = new ConceptQuery(new CQReusedQuery(new ManagedExecutionId(new DatasetId(\"testD\"), UUID.randomUUID())));\n+\tprivate final User user = new User(\"username\",\"userlabel\");\n+\t\n+\t@BeforeEach\n+\tpublic void init() {\n+\t\ttmpDir = Files.createTempDir();\n+\t\tenv = Environments.newInstance(tmpDir);\n+\t\tconfig = new StorageConfig();\n+\t}\n+\t\n+\t@AfterEach\n+\tpublic void destroy() throws IOException {\n+\t\tenv.close();\n+\t\tFileUtils.deleteDirectory(tmpDir);\n+\t}\n+\t\n+\tprivate <KEY, VALUE> SerializingStore<KEY, VALUE> createSerializedStore(StorageConfig config, Environment environment, Validator validator, IStoreInfo storeId) {\n+\t\treturn new SerializingStore<>(config, new XodusStore(environment, storeId), validator, storeId);\n+\t}\n+\t\n+\t/**\n+\t * Tests if entries with corrupted values are dumped.\n+\t */\n+\t@Test\n+\tpublic void testCorruptValueDump() throws JSONException, IOException {\n+\t\t// Set dump directory to this tests temp-dir\n+\t\tconfig.setUnreadbleDataDumpDirectory(Optional.of(tmpDir));\n+\t\t\n+\t\t// Open a store and insert a valid key-value pair (UserId & User)\n+\t\ttry (SerializingStore<UserId, User> store = createSerializedStore(config, env, Validators.newValidator(), StoreInfo.AUTH_USER)){\n+\t\t\tstore.add(user.getId(), user);\n+\t\t}\n+\t\t\n+\t\t// Open that store again, with a different config to insert a corrupt entry (UserId & ManagedQuery)\t\t\n+\t\ttry (SerializingStore<UserId, QueryDescription> store = createSerializedStore(config, env, Validators.newValidator(), new CorruptableStoreInfo(StoreInfo.AUTH_USER.getXodusName(), UserId.class, QueryDescription.class))){\n+\t\t\tstore.add(new UserId(\"testU2\"), cQuery);\n+\t\t}\n+\t\t\n+\t\t// Reopen the store with the initial value and try to iterate over all entries (this triggers the dump or removal of invalid entries)\n+\t\ttry (SerializingStore<UserId, User> store = createSerializedStore(config, env, Validators.newValidator(), StoreInfo.AUTH_USER)){\n+\t\t\tIterationStatistic expectedResult = new IterationStatistic();\n+\t\t\texpectedResult.setTotalProcessed(2);\n+\t\t\texpectedResult.setFailedKeys(0);\n+\t\t\texpectedResult.setFailedValues(1);\n+\t\t\t\n+\t\t\t// Iterate (do nothing with the entries themselves)\n+\t\t\tIterationStatistic result = store.forEach((k,v,s) -> {});\n+\t\t\tassertThat(result).isEqualTo(expectedResult);\n+\t\t}\n+\t\t\n+\t\t// Test if the correct number of dumpfiles was generated\n+\t\tCondition<File> dumpFileCond = new Condition<>(f -> f.getName().endsWith(SerializingStore.DUMP_FILE_EXTENTION) , \"dump file\");\n+\t\tassertThat(tmpDir.listFiles()).areExactly(1, dumpFileCond);\n+\t\t\n+\t\t// Test if the dump is correct\n+\t\tFile dumpFile = getDumpFile(dumpFileCond);\n+\n+\t\tassertThat((QueryDescription) Jackson.MAPPER.readerFor(QueryDescription.class).readValue(dumpFile)).isEqualTo(cQuery);\n+\t}\n+\n+\tprivate File getDumpFile(Condition<File> dumpFileCond) {\n+\t\tFile dumpFile = tmpDir.listFiles(new FileFilter() {\n+\n+\t\t\t@Override\n+\t\t\tpublic boolean accept(File pathname) {\n+\t\t\t\treturn dumpFileCond.matches(pathname);", "originalCommit": "0b97152388bee6773ae9b50f23a0271cc3d1b520", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "168d1a20947aee5b371327ff8b0ad3873f32d7b9", "url": "https://github.com/bakdata/conquery/commit/168d1a20947aee5b371327ff8b0ad3873f32d7b9", "message": "review changes", "committedDate": "2020-07-17T14:12:20Z", "type": "commit"}, {"oid": "6d4dae536c80426410ba821a49c29499c42545ca", "url": "https://github.com/bakdata/conquery/commit/6d4dae536c80426410ba821a49c29499c42545ca", "message": "Merge branch 'develop' into feature/dump-entries-that-could-not-be-deserialized", "committedDate": "2020-07-17T14:20:33Z", "type": "commit"}, {"oid": "c48d2a030120bf92d1eb7f5aeb3dded2acbdf7b1", "url": "https://github.com/bakdata/conquery/commit/c48d2a030120bf92d1eb7f5aeb3dded2acbdf7b1", "message": "Merge branch 'develop' into feature/dump-entries-that-could-not-be-deserialized", "committedDate": "2020-07-17T15:08:09Z", "type": "commit"}, {"oid": "84cb5c53e28c3819f95bed1bb018fae1886e8b80", "url": "https://github.com/bakdata/conquery/commit/84cb5c53e28c3819f95bed1bb018fae1886e8b80", "message": "Merge branch 'develop' into feature/dump-entries-that-could-not-be-deserialized", "committedDate": "2020-07-20T06:33:33Z", "type": "commit"}]}