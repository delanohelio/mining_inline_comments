{"pr_number": 2255, "pr_title": "HBASE-24877 Add option to avoid aborting RS process upon uncaught exc\u2026", "pr_createdAt": "2020-08-13T11:34:06Z", "pr_url": "https://github.com/apache/hbase/pull/2255", "timeline": [{"oid": "5a0adaf203d7a7b270a615882aadf4b365bde07b", "url": "https://github.com/apache/hbase/commit/5a0adaf203d7a7b270a615882aadf4b365bde07b", "message": "HBASE-24877 Add option to avoid aborting RS process upon uncaught exceptions happen on replication source", "committedDate": "2020-08-13T11:32:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg5MTgwMA==", "url": "https://github.com/apache/hbase/pull/2255#discussion_r469891800", "bodyText": "nit: redundant", "author": "virajjasani", "createdAt": "2020-08-13T11:46:19Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java", "diffHunk": "@@ -35,6 +35,8 @@\n import java.util.concurrent.PriorityBlockingQueue;\n import java.util.concurrent.TimeUnit;\n import java.util.concurrent.TimeoutException;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicInteger;", "originalCommit": "5a0adaf203d7a7b270a615882aadf4b365bde07b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTg5MjEyNw==", "url": "https://github.com/apache/hbase/pull/2255#discussion_r469892127", "bodyText": "nit: final for both?", "author": "virajjasani", "createdAt": "2020-08-13T11:46:58Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java", "diffHunk": "@@ -120,6 +122,13 @@\n   // ReplicationEndpoint which will handle the actual replication\n   private volatile ReplicationEndpoint replicationEndpoint;\n \n+  private AtomicBoolean retryStartup = new AtomicBoolean(false);\n+\n+  private AtomicBoolean startupOngoing = new AtomicBoolean(false);", "originalCommit": "5a0adaf203d7a7b270a615882aadf4b365bde07b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkwNDA4MQ==", "url": "https://github.com/apache/hbase/pull/2255#discussion_r469904081", "bodyText": "I hope if we encounter uncaughtException here, we want to retry the loop again.\nIf so, shall we also add startupOngoing.set(true); here explicitely? Just in case if it is set to false in initialize()?", "author": "virajjasani", "createdAt": "2020-08-13T12:10:30Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java", "diffHunk": "@@ -583,16 +614,27 @@ private void initialize() {\n       PriorityBlockingQueue<Path> queue = entry.getValue();\n       tryStartNewShipper(walGroupId, queue);\n     }\n+    this.startupOngoing.set(false);\n   }\n \n   @Override\n   public void startup() {\n     // mark we are running now\n     this.sourceRunning = true;\n-    initThread = new Thread(this::initialize);\n-    Threads.setDaemonThreadRunning(initThread,\n-      Thread.currentThread().getName() + \".replicationSource,\" + this.queueId,\n-      this::uncaughtException);\n+    this.retryStartup.set(true);\n+    do {\n+      if(retryStartup.get()) {\n+        retryStartup.set(false);\n+        startupOngoing.set(true);\n+        initThread = new Thread(this::initialize);\n+        Threads.setDaemonThreadRunning(initThread,\n+          Thread.currentThread().getName() + \".replicationSource,\" + this.queueId,\n+          (t,e) -> {\n+          uncaughtException(t, e);\n+          retryStartup.set(true);", "originalCommit": "5a0adaf203d7a7b270a615882aadf4b365bde07b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ3NzgwNQ==", "url": "https://github.com/apache/hbase/pull/2255#discussion_r470477805", "bodyText": "I hope if we encounter uncaughtException here, we want to retry the loop again.\n\nYes, we want to keep trying until we succeed.\n\nIf so, shall we also add startupOngoing.set(true); here explicitely? Just in case if it is set to false in initialize()?\n\nThe only cases startupOngoing would had been set to false in  initialize is if it completes fine without any uncaught exception, so adding it here would be redundant.", "author": "wchevreuil", "createdAt": "2020-08-14T08:14:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkwNDA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQ4NTcwNg==", "url": "https://github.com/apache/hbase/pull/2255#discussion_r470485706", "bodyText": "Yeah right, it is not set to false if it completes successfully, anyone touching the same code in future should realize this.\nAlthough not a strong point but If you don't mind, maybe we can comment here indicating startupOngoing is expected to be true when we are here handling Exception.", "author": "virajjasani", "createdAt": "2020-08-14T08:31:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkwNDA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczNDkxNg==", "url": "https://github.com/apache/hbase/pull/2255#discussion_r470734916", "bodyText": "Addressed the nits and added some comments to the two flags.", "author": "wchevreuil", "createdAt": "2020-08-14T16:41:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTkwNDA4MQ=="}], "type": "inlineReview"}, {"oid": "3fb4dce7b7f52839ee3b142c621d50e7acb38052", "url": "https://github.com/apache/hbase/commit/3fb4dce7b7f52839ee3b142c621d50e7acb38052", "message": "Addressing Viraj comments", "committedDate": "2020-08-14T16:34:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYzNDgzNA==", "url": "https://github.com/apache/hbase/pull/2255#discussion_r472634834", "bodyText": "So here it is for wal reader. I think refreshSources and retry is an acceptable way. Then let's just test the abortOnError flag here? If it is true, we will call uncaughtException, otherwise we will try to refresh the replication source.", "author": "Apache9", "createdAt": "2020-08-19T03:19:04Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java", "diffHunk": "@@ -373,7 +389,21 @@ private void tryStartNewShipper(String walGroupId, PriorityBlockingQueue<Path> q\n         Threads.setDaemonThreadRunning(\n             walReader, Thread.currentThread().getName()\n                 + \".replicationSource.wal-reader.\" + walGroupId + \",\" + queueId,\n-            this::uncaughtException);\n+                (t,e) -> {", "originalCommit": "3fb4dce7b7f52839ee3b142c621d50e7acb38052", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYzNjUzNw==", "url": "https://github.com/apache/hbase/pull/2255#discussion_r472636537", "bodyText": "OK, the code is almost the same... Then I think we could move the logic into uncaughtException method? If abortOnError is true, we about, otherwise we will try to refresh the source.", "author": "Apache9", "createdAt": "2020-08-19T03:21:46Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSourceShipper.java", "diffHunk": "@@ -290,7 +290,22 @@ private boolean updateLogPosition(WALEntryBatch batch) {\n   public void startup(UncaughtExceptionHandler handler) {\n     String name = Thread.currentThread().getName();\n     Threads.setDaemonThreadRunning(this,\n-      name + \".replicationSource.shipper\" + walGroupId + \",\" + source.getQueueId(), handler);\n+      name + \".replicationSource.shipper\" + walGroupId + \",\" + source.getQueueId(),\n+      (t,e) -> {", "originalCommit": "3fb4dce7b7f52839ee3b142c621d50e7acb38052", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU1MTk1Ng==", "url": "https://github.com/apache/hbase/pull/2255#discussion_r475551956", "bodyText": "Moved it to uncaughtException. This is true when handling potential errors on both the reader and shipper threads, but uncaughtException is also used when handling issues from ReplicationSource.initialize method, which might blow before reader/shipper is even started. So needed to add extra check in uncaughtException to decide when to invoke refreshSources.", "author": "wchevreuil", "createdAt": "2020-08-24T12:07:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYzNjUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYzNzMwOA==", "url": "https://github.com/apache/hbase/pull/2255#discussion_r472637308", "bodyText": "This flag is only used in this method? Let's use a local var instead of a class member field?", "author": "Apache9", "createdAt": "2020-08-19T03:22:58Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java", "diffHunk": "@@ -583,16 +617,27 @@ private void initialize() {\n       PriorityBlockingQueue<Path> queue = entry.getValue();\n       tryStartNewShipper(walGroupId, queue);\n     }\n+    this.startupOngoing.set(false);\n   }\n \n   @Override\n   public void startup() {\n     // mark we are running now\n     this.sourceRunning = true;\n-    initThread = new Thread(this::initialize);\n-    Threads.setDaemonThreadRunning(initThread,\n-      Thread.currentThread().getName() + \".replicationSource,\" + this.queueId,\n-      this::uncaughtException);\n+    this.retryStartup.set(true);", "originalCommit": "3fb4dce7b7f52839ee3b142c621d50e7acb38052", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDUzMzUxNA==", "url": "https://github.com/apache/hbase/pull/2255#discussion_r474533514", "bodyText": "Yeah, originally I was also referring it on uncaughtException, but it was not actually needed.", "author": "wchevreuil", "createdAt": "2020-08-21T08:43:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYzNzMwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYzODA4Ng==", "url": "https://github.com/apache/hbase/pull/2255#discussion_r472638086", "bodyText": "So this one is exactly the same with source.isActive? Can we just make use of that flag instead of introducing a new one?", "author": "Apache9", "createdAt": "2020-08-19T03:24:14Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java", "diffHunk": "@@ -583,16 +617,27 @@ private void initialize() {\n       PriorityBlockingQueue<Path> queue = entry.getValue();\n       tryStartNewShipper(walGroupId, queue);\n     }\n+    this.startupOngoing.set(false);\n   }\n \n   @Override\n   public void startup() {\n     // mark we are running now\n     this.sourceRunning = true;\n-    initThread = new Thread(this::initialize);\n-    Threads.setDaemonThreadRunning(initThread,\n-      Thread.currentThread().getName() + \".replicationSource,\" + this.queueId,\n-      this::uncaughtException);\n+    this.retryStartup.set(true);\n+    do {\n+      if(retryStartup.get()) {\n+        retryStartup.set(false);\n+        startupOngoing.set(true);", "originalCommit": "3fb4dce7b7f52839ee3b142c621d50e7acb38052", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDU0NDM1NQ==", "url": "https://github.com/apache/hbase/pull/2255#discussion_r474544355", "bodyText": "Not exactly the same, but we may use the negation of source.isActive to control this retry loop, and change this.sourceRunning value properly along startup and initialize method.", "author": "wchevreuil", "createdAt": "2020-08-21T08:55:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjYzODA4Ng=="}], "type": "inlineReview"}, {"oid": "8af3041eb5ab52b147b72880faf8507ef8a1f4cf", "url": "https://github.com/apache/hbase/commit/8af3041eb5ab52b147b72880faf8507ef8a1f4cf", "message": "Addressing Duo's comments.", "committedDate": "2020-08-24T12:06:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU3MzE5Mg==", "url": "https://github.com/apache/hbase/pull/2255#discussion_r475573192", "bodyText": "nit: indent?", "author": "Apache9", "createdAt": "2020-08-24T12:47:48Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java", "diffHunk": "@@ -119,6 +120,14 @@\n   private int logQueueWarnThreshold;\n   // ReplicationEndpoint which will handle the actual replication\n   private volatile ReplicationEndpoint replicationEndpoint;\n+  //This is needed for the startup loop to identify when there's already\n+  // an initialization happening (but not finished yet),\n+  // so that it doesn't try submit another initialize thread.\n+  // NOTE: this should only be set to false at the end of initialize method, prior to return.\n+//  private final AtomicBoolean startupOngoing = new AtomicBoolean(false);", "originalCommit": "8af3041eb5ab52b147b72880faf8507ef8a1f4cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU3Mzk4OQ==", "url": "https://github.com/apache/hbase/pull/2255#discussion_r475573989", "bodyText": "Need to update the formatter config? Usually it should be 'if (manager != null) {'.", "author": "Apache9", "createdAt": "2020-08-24T12:49:20Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java", "diffHunk": "@@ -450,11 +463,28 @@ WALEntryFilter getWalEntryFilter() {\n     return walEntryFilter;\n   }\n \n-  protected final void uncaughtException(Thread t, Throwable e) {\n+  protected final void uncaughtException(Thread t, Throwable e,\n+      ReplicationSourceManager manager, String peerId) {\n     RSRpcServices.exitIfOOME(e);\n     LOG.error(\"Unexpected exception in {} currentPath={}\",\n       t.getName(), getCurrentPath(), e);\n-    server.abort(\"Unexpected exception in \" + t.getName(), e);\n+    if(abortOnError){\n+      server.abort(\"Unexpected exception in \" + t.getName(), e);\n+    }\n+    if(manager!=null){", "originalCommit": "8af3041eb5ab52b147b72880faf8507ef8a1f4cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU3NTE3Mg==", "url": "https://github.com/apache/hbase/pull/2255#discussion_r475575172", "bodyText": "Why we need a AtomicBoolean here? It is only used locally, so a simple boolean is enough?", "author": "Apache9", "createdAt": "2020-08-24T12:51:25Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java", "diffHunk": "@@ -587,12 +617,25 @@ private void initialize() {\n \n   @Override\n   public void startup() {\n-    // mark we are running now\n-    this.sourceRunning = true;\n-    initThread = new Thread(this::initialize);\n-    Threads.setDaemonThreadRunning(initThread,\n-      Thread.currentThread().getName() + \".replicationSource,\" + this.queueId,\n-      this::uncaughtException);\n+    //Flag that signalizes uncaught error happening while starting up the source\n+    // and a retry should be attempted\n+    AtomicBoolean retryStartup = new AtomicBoolean(false);", "originalCommit": "8af3041eb5ab52b147b72880faf8507ef8a1f4cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY2NTQ4NQ==", "url": "https://github.com/apache/hbase/pull/2255#discussion_r475665485", "bodyText": "It's been modified by the lambda expression on line #635, since lambdas expressions require variables to be final, I can't use a simple, local primitive boolean or wrapper.", "author": "wchevreuil", "createdAt": "2020-08-24T14:45:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU3NTE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY4NTI5Mg==", "url": "https://github.com/apache/hbase/pull/2255#discussion_r475685292", "bodyText": "Then use MutableBoolean? We do not need to use atomic here.", "author": "Apache9", "createdAt": "2020-08-24T15:06:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU3NTE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI3MjMwMQ==", "url": "https://github.com/apache/hbase/pull/2255#discussion_r476272301", "bodyText": "Sure, thanks for suggesting MutableBoolean, am not too familiar with apache commons lib.", "author": "wchevreuil", "createdAt": "2020-08-25T08:29:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU3NTE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTY3MDYxNQ==", "url": "https://github.com/apache/hbase/pull/2255#discussion_r475670615", "bodyText": "I had a second thought on this here, we can't simply re-use this boolean, because in case of failure, we risk reach this point before the exception handler has updated it to false. I'm bringing back the original startupOngoing in the next commit,", "author": "wchevreuil", "createdAt": "2020-08-24T14:52:52Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java", "diffHunk": "@@ -587,12 +617,25 @@ private void initialize() {\n \n   @Override\n   public void startup() {\n-    // mark we are running now\n-    this.sourceRunning = true;\n-    initThread = new Thread(this::initialize);\n-    Threads.setDaemonThreadRunning(initThread,\n-      Thread.currentThread().getName() + \".replicationSource,\" + this.queueId,\n-      this::uncaughtException);\n+    //Flag that signalizes uncaught error happening while starting up the source\n+    // and a retry should be attempted\n+    AtomicBoolean retryStartup = new AtomicBoolean(false);\n+    retryStartup.set(true);\n+    do {\n+      if(retryStartup.get()) {\n+        retryStartup.set(false);\n+        // mark we are running now\n+        this.sourceRunning = true;\n+        initThread = new Thread(this::initialize);\n+        Threads.setDaemonThreadRunning(initThread,\n+          Thread.currentThread().getName() + \".replicationSource,\" + this.queueId,\n+          (t,e) -> {\n+          sourceRunning = false;\n+          uncaughtException(t, e, null, null);\n+          retryStartup.set(true);\n+        });\n+      }\n+    } while (!this.sourceRunning);", "originalCommit": "8af3041eb5ab52b147b72880faf8507ef8a1f4cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "84994f940838f0da8090ed0a47786a100c475b4b", "url": "https://github.com/apache/hbase/commit/84994f940838f0da8090ed0a47786a100c475b4b", "message": "addressing some nits and the loop control", "committedDate": "2020-08-24T15:00:59Z", "type": "commit"}, {"oid": "e716047dddbad655b71dc7fb0729430442f45580", "url": "https://github.com/apache/hbase/commit/e716047dddbad655b71dc7fb0729430442f45580", "message": "Changed to MutableBoolean and addressed latest checkstyles", "committedDate": "2020-08-25T08:27:41Z", "type": "commit"}, {"oid": "2fcf7142739875241ed6255a5df8f52ef4fe737a", "url": "https://github.com/apache/hbase/commit/2fcf7142739875241ed6255a5df8f52ef4fe737a", "message": "switched from banned version", "committedDate": "2020-08-25T09:53:44Z", "type": "commit"}, {"oid": "16db51e8ca4284bc9683070ede29b07e869d2ec2", "url": "https://github.com/apache/hbase/commit/16db51e8ca4284bc9683070ede29b07e869d2ec2", "message": "Additional checks on the loop control, for the tests that are note complete initialization but don't care about it", "committedDate": "2020-09-04T13:22:16Z", "type": "commit"}]}