{"pr_number": 2198, "pr_title": "HBASE-24817 Allow configuring WALEntry filters on ReplicationSource", "pr_createdAt": "2020-08-04T20:57:22Z", "pr_url": "https://github.com/apache/hbase/pull/2198", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc4OTM3Ng==", "url": "https://github.com/apache/hbase/pull/2198#discussion_r465789376", "bodyText": "For system tables we return null Entry. Good to consider return type Optional<Entry> here?\nMaybe as follow up task?", "author": "virajjasani", "createdAt": "2020-08-05T14:56:46Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/WALEntryFilter.java", "diffHunk": "@@ -49,5 +47,5 @@\n    * @return a (possibly modified) Entry to use. Returning null or an entry with no cells will cause\n    *         the entry to be skipped for replication.\n    */\n-  public Entry filter(Entry entry);\n+  Entry filter(Entry entry);", "originalCommit": "bafff990e6a06aff532582ea39f618db67afbbdf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5NTI2Mw==", "url": "https://github.com/apache/hbase/pull/2198#discussion_r465995263", "bodyText": "This is how it works now.... no Optional. Will leave it in this patch. Thanks.", "author": "saintstack", "createdAt": "2020-08-05T20:49:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc4OTM3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5MTk2Ng==", "url": "https://github.com/apache/hbase/pull/2198#discussion_r465791966", "bodyText": "nit: just in case if you like assertSame(e, wef.filter(e))", "author": "virajjasani", "createdAt": "2020-08-05T15:00:15Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/replication/regionserver/TestReplicationSource.java", "diffHunk": "@@ -108,16 +107,100 @@ public static void tearDownAfterClass() throws Exception {\n     TEST_UTIL.shutdownMiniDFSCluster();\n   }\n \n+  /**\n+   * Test the default ReplicationSource skips queuing hbase:meta WAL files.\n+   */\n+  @Test\n+  public void testDefaultSkipsMetaWAL() throws IOException {\n+    ReplicationSource rs = new ReplicationSource();\n+    Configuration conf = new Configuration(TEST_UTIL.getConfiguration());\n+    conf.setInt(\"replication.source.maxretriesmultiplier\", 1);\n+    ReplicationPeer mockPeer = Mockito.mock(ReplicationPeer.class);\n+    Mockito.when(mockPeer.getConfiguration()).thenReturn(conf);\n+    Mockito.when(mockPeer.getPeerBandwidth()).thenReturn(0L);\n+    ReplicationPeerConfig peerConfig = Mockito.mock(ReplicationPeerConfig.class);\n+    Mockito.when(peerConfig.getReplicationEndpointImpl()).\n+      thenReturn(DoNothingReplicationEndpoint.class.getName());\n+    Mockito.when(mockPeer.getPeerConfig()).thenReturn(peerConfig);\n+    ReplicationSourceManager manager = Mockito.mock(ReplicationSourceManager.class);\n+    Mockito.when(manager.getTotalBufferUsed()).thenReturn(new AtomicLong());\n+    String queueId = \"qid\";\n+    RegionServerServices rss =\n+      TEST_UTIL.createMockRegionServerService(ServerName.parseServerName(\"a.b.c,1,1\"));\n+    rs.init(conf, null, manager, null, mockPeer, rss, queueId, null,\n+      p -> OptionalLong.empty(), new MetricsSource(queueId));\n+    try {\n+      rs.startup();\n+      assertTrue(rs.isSourceActive());\n+      assertEquals(0, rs.getSourceMetrics().getSizeOfLogQueue());\n+      rs.enqueueLog(new Path(\"a.1\" + META_WAL_PROVIDER_ID));\n+      assertEquals(0, rs.getSourceMetrics().getSizeOfLogQueue());\n+      rs.enqueueLog(new Path(\"a.1\"));\n+      assertEquals(1, rs.getSourceMetrics().getSizeOfLogQueue());\n+    } finally {\n+      rs.terminate(\"Done\");\n+      rss.stop(\"Done\");\n+    }\n+  }\n+\n+  /**\n+   * Test that we filter out meta edits, etc.\n+   */\n+  @Test\n+  public void testWALEntryFilter() throws IOException {\n+    // To get the fully constructed default WALEntryFilter, need to create a ReplicationSource\n+    // instance and init it.\n+    ReplicationSource rs = new ReplicationSource();\n+    UUID uuid = UUID.randomUUID();\n+    Configuration conf = new Configuration(TEST_UTIL.getConfiguration());\n+    ReplicationPeer mockPeer = Mockito.mock(ReplicationPeer.class);\n+    Mockito.when(mockPeer.getConfiguration()).thenReturn(conf);\n+    Mockito.when(mockPeer.getPeerBandwidth()).thenReturn(0L);\n+    ReplicationPeerConfig peerConfig = Mockito.mock(ReplicationPeerConfig.class);\n+    Mockito.when(peerConfig.getReplicationEndpointImpl()).\n+      thenReturn(DoNothingReplicationEndpoint.class.getName());\n+    Mockito.when(mockPeer.getPeerConfig()).thenReturn(peerConfig);\n+    ReplicationSourceManager manager = Mockito.mock(ReplicationSourceManager.class);\n+    Mockito.when(manager.getTotalBufferUsed()).thenReturn(new AtomicLong());\n+    String queueId = \"qid\";\n+    RegionServerServices rss =\n+      TEST_UTIL.createMockRegionServerService(ServerName.parseServerName(\"a.b.c,1,1\"));\n+    rs.init(conf, null, manager, null, mockPeer, rss, queueId,\n+      uuid, p -> OptionalLong.empty(), new MetricsSource(queueId));\n+    try {\n+      rs.startup();\n+      TEST_UTIL.waitFor(30000, () -> rs.getWalEntryFilter() != null);\n+      WALEntryFilter wef = rs.getWalEntryFilter();\n+      // Test non-system WAL edit.\n+      WAL.Entry e = new WAL.Entry(new WALKeyImpl(HConstants.EMPTY_BYTE_ARRAY,\n+        TableName.valueOf(\"test\"), -1), new WALEdit());\n+      assertTrue(wef.filter(e) == e);", "originalCommit": "bafff990e6a06aff532582ea39f618db67afbbdf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDU4MA==", "url": "https://github.com/apache/hbase/pull/2198#discussion_r465794580", "bodyText": "nit: redundant", "author": "virajjasani", "createdAt": "2020-08-05T15:03:51Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/replication/regionserver/TestReplicationSource.java", "diffHunk": "@@ -295,7 +356,40 @@ protected void stopServiceThreads() {\n     }\n   }\n \n-  // Test HBASE-20497\n+  /**\n+   * Deadend Endpoint. Does nothing.\n+   */\n+  public static class DoNothingReplicationEndpoint extends HBaseInterClusterReplicationEndpoint {\n+    private final UUID uuid = UUID.randomUUID();\n+\n+    @Override public void init(Context context) throws IOException {\n+      this.ctx = context;\n+      return;", "originalCommit": "bafff990e6a06aff532582ea39f618db67afbbdf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5NDc0NA==", "url": "https://github.com/apache/hbase/pull/2198#discussion_r465994744", "bodyText": "Yes. Fixed. Thanks.", "author": "saintstack", "createdAt": "2020-08-05T20:48:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NDU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwNzc1Mg==", "url": "https://github.com/apache/hbase/pull/2198#discussion_r465907752", "bodyText": "Are we changing this config name also in this patch?", "author": "anoopsjohn", "createdAt": "2020-08-05T18:03:01Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java", "diffHunk": "@@ -194,30 +232,34 @@ private void decorateConf() {\n   }\n \n   @Override\n-  public void enqueueLog(Path log) {\n-    String logPrefix = AbstractFSWALProvider.getWALPrefixFromWALName(log.getName());\n+  public void enqueueLog(Path wal) {\n+    if (!this.filterInWALs.test(wal)) {\n+      LOG.trace(\"NOT replicating {}\", wal);\n+      return;\n+    }\n+    String logPrefix = AbstractFSWALProvider.getWALPrefixFromWALName(wal.getName());\n     PriorityBlockingQueue<Path> queue = queues.get(logPrefix);\n     if (queue == null) {\n       queue = new PriorityBlockingQueue<>(queueSizePerGroup, new LogsComparator());\n       queues.put(logPrefix, queue);\n       if (this.isSourceActive() && this.walEntryFilter != null) {\n         // new wal group observed after source startup, start a new worker thread to track it\n-        // notice: it's possible that log enqueued when this.running is set but worker thread\n+        // notice: it's possible that wal enqueued when this.running is set but worker thread\n         // still not launched, so it's necessary to check workerThreads before start the worker\n         tryStartNewShipper(logPrefix, queue);\n       }\n     }\n-    queue.put(log);\n+    queue.put(wal);\n     if (LOG.isTraceEnabled()) {\n-      LOG.trace(\"{} Added log file {} to queue of source {}.\", logPeerId(), logPrefix,\n+      LOG.trace(\"{} Added wal {} to queue of source {}.\", logPeerId(), logPrefix,\n         this.replicationQueueInfo.getQueueId());\n     }\n     this.metrics.incrSizeOfLogQueue();\n-    // This will log a warning for each new log that gets created above the warn threshold\n+    // This will wal a warning for each new wal that gets created above the warn threshold\n     int queueSize = queue.size();\n     if (queueSize > this.logQueueWarnThreshold) {\n       LOG.warn(\"{} WAL group {} queue size: {} exceeds value of \"\n-          + \"replication.source.log.queue.warn: {}\", logPeerId(),\n+          + \"replication.source.wal.queue.warn: {}\", logPeerId(),", "originalCommit": "bafff990e6a06aff532582ea39f618db67afbbdf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTk5NDQ0OQ==", "url": "https://github.com/apache/hbase/pull/2198#discussion_r465994449", "bodyText": "Good catch. Thanks. Let me restore.", "author": "saintstack", "createdAt": "2020-08-05T20:47:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTkwNzc1Mg=="}], "type": "inlineReview"}, {"oid": "b21753f604d33b30d36b1552e6364805580c4d40", "url": "https://github.com/apache/hbase/commit/b21753f604d33b30d36b1552e6364805580c4d40", "message": "HBASE-24817 Allow configuring WALEntry filters on ReplicationSource\nAllow specifying base WALEntry filter on construction of\nReplicationSource. Add means of being able to filter WALs by name.\n\nhbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java\n Add constructor that allows passing a predicate for filtering *in* WALs\n and a list of filters for filtering *out* WALEntries. The latter was\n hardcoded to filter out system-table WALEntries. The former did not\n exist but we'll need it if Replication takes in more than just the\n default Provider.", "committedDate": "2020-08-05T20:50:00Z", "type": "commit"}, {"oid": "b21753f604d33b30d36b1552e6364805580c4d40", "url": "https://github.com/apache/hbase/commit/b21753f604d33b30d36b1552e6364805580c4d40", "message": "HBASE-24817 Allow configuring WALEntry filters on ReplicationSource\nAllow specifying base WALEntry filter on construction of\nReplicationSource. Add means of being able to filter WALs by name.\n\nhbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java\n Add constructor that allows passing a predicate for filtering *in* WALs\n and a list of filters for filtering *out* WALEntries. The latter was\n hardcoded to filter out system-table WALEntries. The former did not\n exist but we'll need it if Replication takes in more than just the\n default Provider.", "committedDate": "2020-08-05T20:50:00Z", "type": "forcePushed"}]}