{"pr_number": 2741, "pr_title": "HBASE-25364 Redo the getMidPoint() in HFileWriterImpl to get rid of t\u2026", "pr_createdAt": "2020-12-06T03:29:35Z", "pr_url": "https://github.com/apache/hbase/pull/2741", "timeline": [{"oid": "436329a60a477db76d21a458a857d20defe2317e", "url": "https://github.com/apache/hbase/commit/436329a60a477db76d21a458a857d20defe2317e", "message": "HBASE-25364 Redo the getMidPoint() in HFileWriterImpl to get rid of the double comparison process", "committedDate": "2020-12-06T03:27:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA0NTYwNA==", "url": "https://github.com/apache/hbase/pull/2741#discussion_r537045604", "bodyText": "The logic here is different from original?", "author": "nyl3532016", "createdAt": "2020-12-06T14:04:47Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java", "diffHunk": "@@ -380,143 +378,146 @@ public static Cell getMidpoint(final CellComparator comparator, final Cell left,\n     if (comparator instanceof MetaCellComparator) {\n       return right;\n     }\n-    int diff = comparator.compareRows(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left row sorts after right row; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n     byte[] midRow;\n     boolean bufferBacked = left instanceof ByteBufferExtendedCell\n         && right instanceof ByteBufferExtendedCell;\n-    if (diff < 0) {\n-      // Left row is < right row.\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getRowByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getRowPosition(), left.getRowLength(),\n-            ((ByteBufferExtendedCell) right).getRowByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getRowPosition(), right.getRowLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getRowArray(), left.getRowOffset(),\n-            left.getRowLength(), right.getRowArray(), right.getRowOffset(), right.getRowLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getRowByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getRowPosition(), left.getRowLength(),\n+        ((ByteBufferExtendedCell) right).getRowByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getRowPosition(), right.getRowLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getRowArray(), left.getRowOffset(), left.getRowLength(),\n+        right.getRowArray(), right.getRowOffset(), right.getRowLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRow(midRow);\n     }\n-    // Rows are same. Compare on families.\n-    diff = comparator.compareFamilies(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left family sorts after right family; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n-    if (diff < 0) {\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getFamilyByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getFamilyPosition(), left.getFamilyLength(),\n-            ((ByteBufferExtendedCell) right).getFamilyByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getFamilyPosition(), right.getFamilyLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getFamilyArray(), left.getFamilyOffset(),\n-            left.getFamilyLength(), right.getFamilyArray(), right.getFamilyOffset(),\n-            right.getFamilyLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n-      // Return new Cell where we use right row and then a mid sort family.\n+    //Rows are same. Compare on families.\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getFamilyByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getFamilyPosition(), left.getFamilyLength(),\n+        ((ByteBufferExtendedCell) right).getFamilyByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getFamilyPosition(), right.getFamilyLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getFamilyArray(), left.getFamilyOffset(),\n+        left.getFamilyLength(), right.getFamilyArray(), right.getFamilyOffset(),\n+        right.getFamilyLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRowFamily(right, midRow, 0, midRow.length);\n     }\n     // Families are same. Compare on qualifiers.\n-    diff = comparator.compareQualifiers(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left qualifier sorts after right qualifier; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n-    if (diff < 0) {\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getQualifierByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getQualifierPosition(), left.getQualifierLength(),\n-            ((ByteBufferExtendedCell) right).getQualifierByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getQualifierPosition(), right.getQualifierLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getQualifierArray(), left.getQualifierOffset(),\n-            left.getQualifierLength(), right.getQualifierArray(), right.getQualifierOffset(),\n-            right.getQualifierLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n-      // Return new Cell where we use right row and family and then a mid sort qualifier.\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getQualifierByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getQualifierPosition(), left.getQualifierLength(),\n+        ((ByteBufferExtendedCell) right).getQualifierByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getQualifierPosition(), right.getQualifierLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getQualifierArray(), left.getQualifierOffset(),\n+        left.getQualifierLength(), right.getQualifierArray(), right.getQualifierOffset(),\n+        right.getQualifierLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRowCol(right, midRow, 0, midRow.length);\n     }\n     // No opportunity for optimization. Just return right key.\n     return right;\n   }\n \n   /**\n+   * Try to get a byte array that falls between left and right as short as possible with\n+   * lexicographical order;\n+   *\n    * @return Return a new array that is between left and right and minimally\n-   *         sized else just return null as indicator that we could not create a\n-   *         mid point.\n+   *         sized else just return null if left == right.\n    */\n   private static byte[] getMinimumMidpointArray(final byte[] leftArray, final int leftOffset,\n       final int leftLength, final byte[] rightArray, final int rightOffset, final int rightLength) {\n-    // rows are different\n     int minLength = leftLength < rightLength ? leftLength : rightLength;\n     int diffIdx = 0;\n-    while (diffIdx < minLength\n-        && leftArray[leftOffset + diffIdx] == rightArray[rightOffset + diffIdx]) {\n-      diffIdx++;\n-    }\n-    byte[] minimumMidpointArray = null;\n-    if (diffIdx >= minLength) {\n-      // leftKey's row is prefix of rightKey's.\n-      minimumMidpointArray = new byte[diffIdx + 1];\n-      System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, diffIdx + 1);\n-    } else {\n-      int diffByte = leftArray[leftOffset + diffIdx];\n-      if ((0xff & diffByte) < 0xff && (diffByte + 1) < (rightArray[rightOffset + diffIdx] & 0xff)) {\n-        minimumMidpointArray = new byte[diffIdx + 1];\n-        System.arraycopy(leftArray, leftOffset, minimumMidpointArray, 0, diffIdx);\n-        minimumMidpointArray[diffIdx] = (byte) (diffByte + 1);\n+    for (; diffIdx < minLength; diffIdx++) {\n+      byte leftByte = leftArray[leftOffset + diffIdx];\n+      byte rightByte = rightArray[rightOffset + diffIdx];\n+      if ((leftByte & 0xff) > (rightByte & 0xff)) {\n+        throw new IllegalArgumentException(\"Left byte array sorts after right row; left=\" + Bytes\n+          .toStringBinary(leftArray, leftOffset, leftLength) + \", right=\" + Bytes\n+          .toStringBinary(rightArray, rightOffset, rightLength));\n+      } else if (leftByte != rightByte) {\n+        break;\n+      }\n+    }\n+    if (diffIdx == minLength) {\n+      if (leftLength > rightLength) {\n+        //right is prefix of left\n+        throw new IllegalArgumentException(\"Left byte array sorts after right row; left=\" + Bytes\n+          .toStringBinary(leftArray, leftOffset, leftLength) + \", right=\" + Bytes\n+          .toStringBinary(rightArray, rightOffset, rightLength));\n+      } else if (leftLength < rightLength) {\n+        //left is prefix of right.\n+        byte[] minimumMidpointArray = new byte[minLength + 1];\n+        System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, minLength + 1);\n+        minimumMidpointArray[minLength] = 0x00;\n+        return minimumMidpointArray;\n       } else {\n-        minimumMidpointArray = new byte[diffIdx + 1];\n-        System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, diffIdx + 1);\n+        //left == right\n+        return null;\n       }\n     }\n+    //Note that left[diffIdx] can never be equal to 0xff since left < right\n+    byte[] minimumMidpointArray = new byte[diffIdx + 1];\n+    System.arraycopy(leftArray, leftOffset, minimumMidpointArray, 0, diffIdx + 1);\n+    minimumMidpointArray[diffIdx] = (byte) (minimumMidpointArray[diffIdx] + 1);\n     return minimumMidpointArray;\n   }\n \n+  /**\n+   * Try to create a new byte array that falls between left and right as short as possible with\n+   * lexicographical order.\n+   *\n+   * @return Return a new array that is between left and right and minimally\n+   *         sized else just return null if left == right.\n+   */\n   private static byte[] getMinimumMidpointArray(ByteBuffer left, int leftOffset, int leftLength,\n       ByteBuffer right, int rightOffset, int rightLength) {\n-    // rows are different\n     int minLength = leftLength < rightLength ? leftLength : rightLength;\n     int diffIdx = 0;\n-    while (diffIdx < minLength && ByteBufferUtils.toByte(left,\n-        leftOffset + diffIdx) == ByteBufferUtils.toByte(right, rightOffset + diffIdx)) {\n-      diffIdx++;\n-    }\n-    byte[] minMidpoint = null;\n-    if (diffIdx >= minLength) {\n-      // leftKey's row is prefix of rightKey's.\n-      minMidpoint = new byte[diffIdx + 1];\n-      ByteBufferUtils.copyFromBufferToArray(minMidpoint, right, rightOffset, 0, diffIdx + 1);\n-    } else {\n-      int diffByte = ByteBufferUtils.toByte(left, leftOffset + diffIdx);\n-      if ((0xff & diffByte) < 0xff\n-          && (diffByte + 1) < (ByteBufferUtils.toByte(right, rightOffset + diffIdx) & 0xff)) {\n-        minMidpoint = new byte[diffIdx + 1];\n-        ByteBufferUtils.copyFromBufferToArray(minMidpoint, left, leftOffset, 0, diffIdx);\n-        minMidpoint[diffIdx] = (byte) (diffByte + 1);\n+    for (; diffIdx < minLength; diffIdx++) {\n+      int leftByte = ByteBufferUtils.toByte(left, leftOffset + diffIdx);\n+      int rightByte = ByteBufferUtils.toByte(right, rightOffset + diffIdx);\n+      if ((leftByte & 0xff) > (rightByte & 0xff)) {\n+        throw new IllegalArgumentException(\n+          \"Left byte array sorts after right row; left=\" + ByteBufferUtils\n+            .toStringBinary(left, leftOffset, leftLength) + \", right=\" + ByteBufferUtils\n+            .toStringBinary(right, rightOffset, rightLength));\n+      } else if (leftByte != rightByte) {\n+        break;\n+      }\n+    }\n+    if (diffIdx == minLength) {\n+      if (leftLength > rightLength) {\n+        //right is prefix of left\n+        throw new IllegalArgumentException(\n+          \"Left byte array sorts after right row; left=\" + ByteBufferUtils\n+            .toStringBinary(left, leftOffset, leftLength) + \", right=\" + ByteBufferUtils\n+            .toStringBinary(right, rightOffset, rightLength));\n+      } else if (leftLength < rightLength) {\n+        //left is prefix of right.\n+        byte[] minimumMidpointArray = new byte[minLength + 1];\n+        ByteBufferUtils\n+          .copyFromBufferToArray(minimumMidpointArray, right, rightOffset, 0, minLength + 1);\n+        minimumMidpointArray[minLength] = 0x00;\n+        return minimumMidpointArray;\n       } else {\n-        minMidpoint = new byte[diffIdx + 1];\n-        ByteBufferUtils.copyFromBufferToArray(minMidpoint, right, rightOffset, 0, diffIdx + 1);\n+        //left == right\n+        return null;\n       }\n     }\n-    return minMidpoint;\n+    //Note that left[diffIdx] can never be equal to 0xff since left < right", "originalCommit": "436329a60a477db76d21a458a857d20defe2317e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA1MTIwNQ==", "url": "https://github.com/apache/hbase/pull/2741#discussion_r537051205", "bodyText": "The logic of composing midPoint is basically the same, with some small differences", "author": "GeorryHuang", "createdAt": "2020-12-06T14:35:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA0NTYwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk5Mzg2Ng==", "url": "https://github.com/apache/hbase/pull/2741#discussion_r542993866", "bodyText": "(diffByte + 1) < (ByteBufferUtils.toByte(right, rightOffset + diffIdx) & 0xff)\nI think this logical branch is lost", "author": "nyl3532016", "createdAt": "2020-12-15T02:18:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA0NTYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA0NjAwMg==", "url": "https://github.com/apache/hbase/pull/2741#discussion_r537046002", "bodyText": "Here is different from original?", "author": "nyl3532016", "createdAt": "2020-12-06T14:07:00Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java", "diffHunk": "@@ -380,143 +378,146 @@ public static Cell getMidpoint(final CellComparator comparator, final Cell left,\n     if (comparator instanceof MetaCellComparator) {\n       return right;\n     }\n-    int diff = comparator.compareRows(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left row sorts after right row; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n     byte[] midRow;\n     boolean bufferBacked = left instanceof ByteBufferExtendedCell\n         && right instanceof ByteBufferExtendedCell;\n-    if (diff < 0) {\n-      // Left row is < right row.\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getRowByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getRowPosition(), left.getRowLength(),\n-            ((ByteBufferExtendedCell) right).getRowByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getRowPosition(), right.getRowLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getRowArray(), left.getRowOffset(),\n-            left.getRowLength(), right.getRowArray(), right.getRowOffset(), right.getRowLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getRowByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getRowPosition(), left.getRowLength(),\n+        ((ByteBufferExtendedCell) right).getRowByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getRowPosition(), right.getRowLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getRowArray(), left.getRowOffset(), left.getRowLength(),\n+        right.getRowArray(), right.getRowOffset(), right.getRowLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRow(midRow);\n     }\n-    // Rows are same. Compare on families.\n-    diff = comparator.compareFamilies(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left family sorts after right family; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n-    if (diff < 0) {\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getFamilyByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getFamilyPosition(), left.getFamilyLength(),\n-            ((ByteBufferExtendedCell) right).getFamilyByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getFamilyPosition(), right.getFamilyLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getFamilyArray(), left.getFamilyOffset(),\n-            left.getFamilyLength(), right.getFamilyArray(), right.getFamilyOffset(),\n-            right.getFamilyLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n-      // Return new Cell where we use right row and then a mid sort family.\n+    //Rows are same. Compare on families.\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getFamilyByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getFamilyPosition(), left.getFamilyLength(),\n+        ((ByteBufferExtendedCell) right).getFamilyByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getFamilyPosition(), right.getFamilyLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getFamilyArray(), left.getFamilyOffset(),\n+        left.getFamilyLength(), right.getFamilyArray(), right.getFamilyOffset(),\n+        right.getFamilyLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRowFamily(right, midRow, 0, midRow.length);\n     }\n     // Families are same. Compare on qualifiers.\n-    diff = comparator.compareQualifiers(left, right);\n-    if (diff > 0) {\n-      throw new IllegalArgumentException(\"Left qualifier sorts after right qualifier; left=\"\n-          + CellUtil.getCellKeyAsString(left) + \", right=\" + CellUtil.getCellKeyAsString(right));\n-    }\n-    if (diff < 0) {\n-      if (bufferBacked) {\n-        midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getQualifierByteBuffer(),\n-            ((ByteBufferExtendedCell) left).getQualifierPosition(), left.getQualifierLength(),\n-            ((ByteBufferExtendedCell) right).getQualifierByteBuffer(),\n-            ((ByteBufferExtendedCell) right).getQualifierPosition(), right.getQualifierLength());\n-      } else {\n-        midRow = getMinimumMidpointArray(left.getQualifierArray(), left.getQualifierOffset(),\n-            left.getQualifierLength(), right.getQualifierArray(), right.getQualifierOffset(),\n-            right.getQualifierLength());\n-      }\n-      // If midRow is null, just return 'right'. Can't do optimization.\n-      if (midRow == null) {\n-        return right;\n-      }\n-      // Return new Cell where we use right row and family and then a mid sort qualifier.\n+    if (bufferBacked) {\n+      midRow = getMinimumMidpointArray(((ByteBufferExtendedCell) left).getQualifierByteBuffer(),\n+        ((ByteBufferExtendedCell) left).getQualifierPosition(), left.getQualifierLength(),\n+        ((ByteBufferExtendedCell) right).getQualifierByteBuffer(),\n+        ((ByteBufferExtendedCell) right).getQualifierPosition(), right.getQualifierLength());\n+    } else {\n+      midRow = getMinimumMidpointArray(left.getQualifierArray(), left.getQualifierOffset(),\n+        left.getQualifierLength(), right.getQualifierArray(), right.getQualifierOffset(),\n+        right.getQualifierLength());\n+    }\n+    if (midRow != null) {\n       return PrivateCellUtil.createFirstOnRowCol(right, midRow, 0, midRow.length);\n     }\n     // No opportunity for optimization. Just return right key.\n     return right;\n   }\n \n   /**\n+   * Try to get a byte array that falls between left and right as short as possible with\n+   * lexicographical order;\n+   *\n    * @return Return a new array that is between left and right and minimally\n-   *         sized else just return null as indicator that we could not create a\n-   *         mid point.\n+   *         sized else just return null if left == right.\n    */\n   private static byte[] getMinimumMidpointArray(final byte[] leftArray, final int leftOffset,\n       final int leftLength, final byte[] rightArray, final int rightOffset, final int rightLength) {\n-    // rows are different\n     int minLength = leftLength < rightLength ? leftLength : rightLength;\n     int diffIdx = 0;\n-    while (diffIdx < minLength\n-        && leftArray[leftOffset + diffIdx] == rightArray[rightOffset + diffIdx]) {\n-      diffIdx++;\n-    }\n-    byte[] minimumMidpointArray = null;\n-    if (diffIdx >= minLength) {\n-      // leftKey's row is prefix of rightKey's.\n-      minimumMidpointArray = new byte[diffIdx + 1];\n-      System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, diffIdx + 1);\n-    } else {\n-      int diffByte = leftArray[leftOffset + diffIdx];\n-      if ((0xff & diffByte) < 0xff && (diffByte + 1) < (rightArray[rightOffset + diffIdx] & 0xff)) {\n-        minimumMidpointArray = new byte[diffIdx + 1];\n-        System.arraycopy(leftArray, leftOffset, minimumMidpointArray, 0, diffIdx);\n-        minimumMidpointArray[diffIdx] = (byte) (diffByte + 1);\n+    for (; diffIdx < minLength; diffIdx++) {\n+      byte leftByte = leftArray[leftOffset + diffIdx];\n+      byte rightByte = rightArray[rightOffset + diffIdx];\n+      if ((leftByte & 0xff) > (rightByte & 0xff)) {\n+        throw new IllegalArgumentException(\"Left byte array sorts after right row; left=\" + Bytes\n+          .toStringBinary(leftArray, leftOffset, leftLength) + \", right=\" + Bytes\n+          .toStringBinary(rightArray, rightOffset, rightLength));\n+      } else if (leftByte != rightByte) {\n+        break;\n+      }\n+    }\n+    if (diffIdx == minLength) {\n+      if (leftLength > rightLength) {\n+        //right is prefix of left\n+        throw new IllegalArgumentException(\"Left byte array sorts after right row; left=\" + Bytes\n+          .toStringBinary(leftArray, leftOffset, leftLength) + \", right=\" + Bytes\n+          .toStringBinary(rightArray, rightOffset, rightLength));\n+      } else if (leftLength < rightLength) {\n+        //left is prefix of right.\n+        byte[] minimumMidpointArray = new byte[minLength + 1];\n+        System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, minLength + 1);\n+        minimumMidpointArray[minLength] = 0x00;\n+        return minimumMidpointArray;\n       } else {\n-        minimumMidpointArray = new byte[diffIdx + 1];\n-        System.arraycopy(rightArray, rightOffset, minimumMidpointArray, 0, diffIdx + 1);\n+        //left == right\n+        return null;\n       }\n     }\n+    //Note that left[diffIdx] can never be equal to 0xff since left < right\n+    byte[] minimumMidpointArray = new byte[diffIdx + 1];\n+    System.arraycopy(leftArray, leftOffset, minimumMidpointArray, 0, diffIdx + 1);\n+    minimumMidpointArray[diffIdx] = (byte) (minimumMidpointArray[diffIdx] + 1);\n     return minimumMidpointArray;\n   }\n \n+  /**\n+   * Try to create a new byte array that falls between left and right as short as possible with\n+   * lexicographical order.\n+   *\n+   * @return Return a new array that is between left and right and minimally\n+   *         sized else just return null if left == right.\n+   */\n   private static byte[] getMinimumMidpointArray(ByteBuffer left, int leftOffset, int leftLength,\n       ByteBuffer right, int rightOffset, int rightLength) {\n-    // rows are different\n     int minLength = leftLength < rightLength ? leftLength : rightLength;\n     int diffIdx = 0;\n-    while (diffIdx < minLength && ByteBufferUtils.toByte(left,\n-        leftOffset + diffIdx) == ByteBufferUtils.toByte(right, rightOffset + diffIdx)) {\n-      diffIdx++;\n-    }\n-    byte[] minMidpoint = null;\n-    if (diffIdx >= minLength) {\n-      // leftKey's row is prefix of rightKey's.\n-      minMidpoint = new byte[diffIdx + 1];\n-      ByteBufferUtils.copyFromBufferToArray(minMidpoint, right, rightOffset, 0, diffIdx + 1);\n-    } else {\n-      int diffByte = ByteBufferUtils.toByte(left, leftOffset + diffIdx);\n-      if ((0xff & diffByte) < 0xff\n-          && (diffByte + 1) < (ByteBufferUtils.toByte(right, rightOffset + diffIdx) & 0xff)) {\n-        minMidpoint = new byte[diffIdx + 1];\n-        ByteBufferUtils.copyFromBufferToArray(minMidpoint, left, leftOffset, 0, diffIdx);\n-        minMidpoint[diffIdx] = (byte) (diffByte + 1);\n+    for (; diffIdx < minLength; diffIdx++) {\n+      int leftByte = ByteBufferUtils.toByte(left, leftOffset + diffIdx);\n+      int rightByte = ByteBufferUtils.toByte(right, rightOffset + diffIdx);\n+      if ((leftByte & 0xff) > (rightByte & 0xff)) {\n+        throw new IllegalArgumentException(\n+          \"Left byte array sorts after right row; left=\" + ByteBufferUtils\n+            .toStringBinary(left, leftOffset, leftLength) + \", right=\" + ByteBufferUtils\n+            .toStringBinary(right, rightOffset, rightLength));\n+      } else if (leftByte != rightByte) {\n+        break;\n+      }\n+    }\n+    if (diffIdx == minLength) {\n+      if (leftLength > rightLength) {\n+        //right is prefix of left\n+        throw new IllegalArgumentException(\n+          \"Left byte array sorts after right row; left=\" + ByteBufferUtils\n+            .toStringBinary(left, leftOffset, leftLength) + \", right=\" + ByteBufferUtils\n+            .toStringBinary(right, rightOffset, rightLength));\n+      } else if (leftLength < rightLength) {\n+        //left is prefix of right.\n+        byte[] minimumMidpointArray = new byte[minLength + 1];\n+        ByteBufferUtils\n+          .copyFromBufferToArray(minimumMidpointArray, right, rightOffset, 0, minLength + 1);\n+        minimumMidpointArray[minLength] = 0x00;", "originalCommit": "436329a60a477db76d21a458a857d20defe2317e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA1MDg5Mg==", "url": "https://github.com/apache/hbase/pull/2741#discussion_r537050892", "bodyText": "Yes, I made some adjustments.", "author": "GeorryHuang", "createdAt": "2020-12-06T14:34:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzA0NjAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0MDcyMg==", "url": "https://github.com/apache/hbase/pull/2741#discussion_r537740722", "bodyText": "From HBASE-10800 ... By our Ramkrishna", "author": "saintstack", "createdAt": "2020-12-07T18:43:47Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/io/hfile/HFileWriterImpl.java", "diffHunk": "@@ -366,8 +366,6 @@ private void finishBlock() throws IOException {\n    */\n   public static Cell getMidpoint(final CellComparator comparator, final Cell left,\n       final Cell right) {\n-    // TODO: Redo so only a single pass over the arrays rather than one to", "originalCommit": "436329a60a477db76d21a458a857d20defe2317e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}