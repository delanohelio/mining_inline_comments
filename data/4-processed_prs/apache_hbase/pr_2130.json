{"pr_number": 2130, "pr_title": "HBASE-24765: Dynamic master discovery", "pr_createdAt": "2020-07-23T19:53:33Z", "pr_url": "https://github.com/apache/hbase/pull/2130", "timeline": [{"oid": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "url": "https://github.com/apache/hbase/commit/36fe586bb715c6e0372d0575ae73c59b0886d3aa", "message": "HBASE-24765: Dynamic master discovery\n\nThis patch adds the ability to discover newly added masters\ndynamically on the master registry side. The trigger for the\nre-fetch is either 5mins or any registry RPC failure.\n\nI didn't add the method to ZK registry interface since there\nis a design discussion going on in splittable meta doc. We can\nadd it later if needed.", "committedDate": "2020-07-23T23:51:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA1OTcxMQ==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r460059711", "bodyText": "We are planning to have a cache with ZKWatcher for backupMasters ZNode right? I believe as of now, we don't subscribe for any event.", "author": "virajjasani", "createdAt": "2020-07-24T13:42:30Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -2931,6 +2935,27 @@ public GetActiveMasterResponse getActiveMaster(RpcController rpcController,\n     return resp.build();\n   }\n \n+  @Override\n+  public GetMastersResponse getMasters(RpcController rpcController, GetMastersRequest request)\n+      throws ServiceException {\n+    GetMastersResponse.Builder resp = GetMastersResponse.newBuilder();\n+    // Active master\n+    Optional<ServerName> serverName = master.getActiveMaster();\n+    serverName.ifPresent(name -> resp.addMasterServers(GetMastersResponseEntry.newBuilder()\n+        .setServerName(ProtobufUtil.toServerName(name)).setIsActive(true).build()));\n+    // Backup masters\n+    try {\n+      // TODO: Cache the backup masters to avoid a ZK RPC for each getMasters() call.", "originalCommit": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDgwMTkwMQ==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464801901", "bodyText": "Right.", "author": "bharathv", "createdAt": "2020-08-04T05:06:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA1OTcxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA3Mzc4OA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r460073788", "bodyText": "Don't want to use SingleThreadExecutor.submit()?", "author": "virajjasani", "createdAt": "2020-07-24T14:05:50Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -115,20 +129,50 @@\n   MasterRegistry(Configuration conf) throws IOException {\n     this.hedgedReadFanOut = Math.max(1, conf.getInt(MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY,\n       MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT));\n-    int rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n+    rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n       conf.getLong(HConstants.HBASE_RPC_TIMEOUT_KEY, HConstants.DEFAULT_HBASE_RPC_TIMEOUT));\n     // XXX: we pass cluster id as null here since we do not have a cluster id yet, we have to fetch\n     // this through the master registry...\n     // This is a problem as we will use the cluster id to determine the authentication method\n     rpcClient = RpcClientFactory.createClient(conf, null);\n     rpcControllerFactory = RpcControllerFactory.instantiate(conf);\n-    Set<ServerName> masterAddrs = parseMasterAddrs(conf);\n+    // Generate the seed list of master stubs. Subsequent RPCs try to keep a live list of masters\n+    // by fetching the end points from this list.\n+    populateMasterStubs(parseMasterAddrs(conf));\n+    Runnable masterEndPointRefresher = () -> {\n+      while (!Thread.interrupted()) {\n+        try {\n+          // Spurious wake ups are okay, worst case we make an extra RPC call to refresh. We won't\n+          // have duplicate refreshes because once the thread is past the wait(), notify()s are\n+          // ignored until the thread is back to the waiting state.\n+          synchronized (refreshMasters) {\n+            refreshMasters.wait(WAIT_TIME_OUT_MS);\n+          }\n+          LOG.debug(\"Attempting to refresh master address end points.\");\n+          Set<ServerName> newMasters = new HashSet<>(getMasters().get());\n+          populateMasterStubs(newMasters);\n+          LOG.debug(\"Finished refreshing master end points. {}\", newMasters);\n+        } catch (InterruptedException e) {\n+          LOG.debug(\"Interrupted during wait, aborting refresh-masters-thread.\", e);\n+          break;\n+        } catch (ExecutionException | IOException e) {\n+          LOG.debug(\"Error populating latest list of masters.\", e);\n+        }\n+      }\n+    };\n+    masterAddrRefresherThread = Threads.newDaemonThreadFactory(\n+        \"MasterRegistry refresh end-points\").newThread(masterEndPointRefresher);\n+    masterAddrRefresherThread.start();", "originalCommit": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczOTU4Nw==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464739587", "bodyText": "Ok switched. I didn't want to have extra layers on top of a simple thread, but I guess a pool is more readable.", "author": "bharathv", "createdAt": "2020-08-04T01:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA3Mzc4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA3NTU0Nw==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r460075547", "bodyText": "Can you please use guava library's ThreadFactoryBuilder? So far the consensus on HBASE-24750 is to get rid of our internally maintained ThreadFactory :)", "author": "virajjasani", "createdAt": "2020-07-24T14:08:46Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -115,20 +129,50 @@\n   MasterRegistry(Configuration conf) throws IOException {\n     this.hedgedReadFanOut = Math.max(1, conf.getInt(MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY,\n       MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT));\n-    int rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n+    rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n       conf.getLong(HConstants.HBASE_RPC_TIMEOUT_KEY, HConstants.DEFAULT_HBASE_RPC_TIMEOUT));\n     // XXX: we pass cluster id as null here since we do not have a cluster id yet, we have to fetch\n     // this through the master registry...\n     // This is a problem as we will use the cluster id to determine the authentication method\n     rpcClient = RpcClientFactory.createClient(conf, null);\n     rpcControllerFactory = RpcControllerFactory.instantiate(conf);\n-    Set<ServerName> masterAddrs = parseMasterAddrs(conf);\n+    // Generate the seed list of master stubs. Subsequent RPCs try to keep a live list of masters\n+    // by fetching the end points from this list.\n+    populateMasterStubs(parseMasterAddrs(conf));\n+    Runnable masterEndPointRefresher = () -> {\n+      while (!Thread.interrupted()) {\n+        try {\n+          // Spurious wake ups are okay, worst case we make an extra RPC call to refresh. We won't\n+          // have duplicate refreshes because once the thread is past the wait(), notify()s are\n+          // ignored until the thread is back to the waiting state.\n+          synchronized (refreshMasters) {\n+            refreshMasters.wait(WAIT_TIME_OUT_MS);\n+          }\n+          LOG.debug(\"Attempting to refresh master address end points.\");\n+          Set<ServerName> newMasters = new HashSet<>(getMasters().get());\n+          populateMasterStubs(newMasters);\n+          LOG.debug(\"Finished refreshing master end points. {}\", newMasters);\n+        } catch (InterruptedException e) {\n+          LOG.debug(\"Interrupted during wait, aborting refresh-masters-thread.\", e);\n+          break;\n+        } catch (ExecutionException | IOException e) {\n+          LOG.debug(\"Error populating latest list of masters.\", e);\n+        }\n+      }\n+    };\n+    masterAddrRefresherThread = Threads.newDaemonThreadFactory(\n+        \"MasterRegistry refresh end-points\").newThread(masterEndPointRefresher);", "originalCommit": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczODk4NA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464738984", "bodyText": "Ok switched. I think we should use our internal one, but fine.", "author": "bharathv", "createdAt": "2020-08-04T00:59:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA3NTU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA5MTA1OA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r460091058", "bodyText": "nit: avoid space in Thread prefix name?", "author": "virajjasani", "createdAt": "2020-07-24T14:33:00Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -115,20 +129,50 @@\n   MasterRegistry(Configuration conf) throws IOException {\n     this.hedgedReadFanOut = Math.max(1, conf.getInt(MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY,\n       MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT));\n-    int rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n+    rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n       conf.getLong(HConstants.HBASE_RPC_TIMEOUT_KEY, HConstants.DEFAULT_HBASE_RPC_TIMEOUT));\n     // XXX: we pass cluster id as null here since we do not have a cluster id yet, we have to fetch\n     // this through the master registry...\n     // This is a problem as we will use the cluster id to determine the authentication method\n     rpcClient = RpcClientFactory.createClient(conf, null);\n     rpcControllerFactory = RpcControllerFactory.instantiate(conf);\n-    Set<ServerName> masterAddrs = parseMasterAddrs(conf);\n+    // Generate the seed list of master stubs. Subsequent RPCs try to keep a live list of masters\n+    // by fetching the end points from this list.\n+    populateMasterStubs(parseMasterAddrs(conf));\n+    Runnable masterEndPointRefresher = () -> {\n+      while (!Thread.interrupted()) {\n+        try {\n+          // Spurious wake ups are okay, worst case we make an extra RPC call to refresh. We won't\n+          // have duplicate refreshes because once the thread is past the wait(), notify()s are\n+          // ignored until the thread is back to the waiting state.\n+          synchronized (refreshMasters) {\n+            refreshMasters.wait(WAIT_TIME_OUT_MS);\n+          }\n+          LOG.debug(\"Attempting to refresh master address end points.\");\n+          Set<ServerName> newMasters = new HashSet<>(getMasters().get());\n+          populateMasterStubs(newMasters);\n+          LOG.debug(\"Finished refreshing master end points. {}\", newMasters);\n+        } catch (InterruptedException e) {\n+          LOG.debug(\"Interrupted during wait, aborting refresh-masters-thread.\", e);\n+          break;\n+        } catch (ExecutionException | IOException e) {\n+          LOG.debug(\"Error populating latest list of masters.\", e);\n+        }\n+      }\n+    };\n+    masterAddrRefresherThread = Threads.newDaemonThreadFactory(\n+        \"MasterRegistry refresh end-points\").newThread(masterEndPointRefresher);", "originalCommit": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczNjE0OA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464736148", "bodyText": "You mean between words?", "author": "bharathv", "createdAt": "2020-08-04T00:47:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA5MTA1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA5MjU3MA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r460092570", "bodyText": "newMasters2.contains(activeMaster.getServerName())", "author": "virajjasani", "createdAt": "2020-07-24T14:35:29Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMasterRegistry.java", "diffHunk": "@@ -126,4 +131,46 @@ public void testRegistryRPCs() throws Exception {\n       }\n     }\n   }\n+\n+  /**\n+   * Tests that the list of masters configured in the MasterRegistry is dynamically refreshed in the\n+   * event of errors.\n+   */\n+  @Test\n+  public void testDynamicMasterConfigurationRefresh() throws Exception {\n+    Configuration conf = new Configuration(TEST_UTIL.getConfiguration());\n+    String currentMasterAddrs = Preconditions.checkNotNull(conf.get(HConstants.MASTER_ADDRS_KEY));\n+    HMaster activeMaster = TEST_UTIL.getHBaseCluster().getMaster();\n+    String clusterId = activeMaster.getClusterId();\n+    // Add a non-working master\n+    ServerName badServer = ServerName.valueOf(\"localhost\", 1234, -1);\n+    conf.set(HConstants.MASTER_ADDRS_KEY, badServer.toShortString() + \",\" + currentMasterAddrs);\n+    // Set the hedging fan out so that all masters are queried.\n+    conf.setInt(MasterRegistry.MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY, 4);\n+    try (MasterRegistry registry = new MasterRegistry(conf)) {\n+      final Set<ServerName> masters = registry.getParsedMasterServers();\n+      assertTrue(masters.contains(badServer));\n+      // Make a registry RPC, this should trigger a refresh since one of the hedged RPC fails.\n+      assertEquals(registry.getClusterId().get(), clusterId);\n+      // Wait for new set of masters to be populated.\n+      TEST_UTIL.waitFor(5000,\n+          (Waiter.Predicate<Exception>) () -> !registry.getParsedMasterServers().equals(masters));\n+      // new set of masters should not include the bad server\n+      final Set<ServerName> newMasters = registry.getParsedMasterServers();\n+      // Bad one should be out.\n+      assertEquals(3, newMasters.size());\n+      assertFalse(newMasters.contains(badServer));\n+      // Kill the active master\n+      activeMaster.stopMaster();\n+      TEST_UTIL.waitFor(10000,\n+        () -> TEST_UTIL.getMiniHBaseCluster().getLiveMasterThreads().size() == 2);\n+      assertEquals(registry.getClusterId().get(), clusterId);\n+      // Make another registry RPC call which should trigger another refresh.\n+      TEST_UTIL.waitFor(100000, (Waiter.Predicate<Exception>) () ->\n+          registry.getParsedMasterServers().size() == 2);\n+      final Set<ServerName> newMasters2 = registry.getParsedMasterServers();\n+      assertEquals(2, newMasters2.size());\n+      assertFalse(newMasters2.contains(activeMaster));", "originalCommit": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA5NDQ1OA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r460094458", "bodyText": "nit: upto you if you want to use ExplainingPredicate to throw Exception with specific message", "author": "virajjasani", "createdAt": "2020-07-24T14:38:37Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMasterRegistry.java", "diffHunk": "@@ -126,4 +131,46 @@ public void testRegistryRPCs() throws Exception {\n       }\n     }\n   }\n+\n+  /**\n+   * Tests that the list of masters configured in the MasterRegistry is dynamically refreshed in the\n+   * event of errors.\n+   */\n+  @Test\n+  public void testDynamicMasterConfigurationRefresh() throws Exception {\n+    Configuration conf = new Configuration(TEST_UTIL.getConfiguration());\n+    String currentMasterAddrs = Preconditions.checkNotNull(conf.get(HConstants.MASTER_ADDRS_KEY));\n+    HMaster activeMaster = TEST_UTIL.getHBaseCluster().getMaster();\n+    String clusterId = activeMaster.getClusterId();\n+    // Add a non-working master\n+    ServerName badServer = ServerName.valueOf(\"localhost\", 1234, -1);\n+    conf.set(HConstants.MASTER_ADDRS_KEY, badServer.toShortString() + \",\" + currentMasterAddrs);\n+    // Set the hedging fan out so that all masters are queried.\n+    conf.setInt(MasterRegistry.MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY, 4);\n+    try (MasterRegistry registry = new MasterRegistry(conf)) {\n+      final Set<ServerName> masters = registry.getParsedMasterServers();\n+      assertTrue(masters.contains(badServer));\n+      // Make a registry RPC, this should trigger a refresh since one of the hedged RPC fails.\n+      assertEquals(registry.getClusterId().get(), clusterId);\n+      // Wait for new set of masters to be populated.\n+      TEST_UTIL.waitFor(5000,\n+          (Waiter.Predicate<Exception>) () -> !registry.getParsedMasterServers().equals(masters));", "originalCommit": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1ODI3Nw==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r465158277", "bodyText": "Skipped it because it bloats up the code, we need to expand the lambda. I think the intent there is pretty clear if the  test fails. Let me know if you feel strongly, I can change it.", "author": "bharathv", "createdAt": "2020-08-04T15:59:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA5NDQ1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MzMzOQ==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r465693339", "bodyText": "Sure no worries, not a strong point.", "author": "virajjasani", "createdAt": "2020-08-05T12:35:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA5NDQ1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDA5NjQwMQ==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r460096401", "bodyText": "After stopping activeMaster, maybe add an extra check to confirm list contains one Active and one Backup?", "author": "virajjasani", "createdAt": "2020-07-24T14:41:53Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/client/TestMasterRegistry.java", "diffHunk": "@@ -126,4 +131,46 @@ public void testRegistryRPCs() throws Exception {\n       }\n     }\n   }\n+\n+  /**\n+   * Tests that the list of masters configured in the MasterRegistry is dynamically refreshed in the\n+   * event of errors.\n+   */\n+  @Test\n+  public void testDynamicMasterConfigurationRefresh() throws Exception {\n+    Configuration conf = new Configuration(TEST_UTIL.getConfiguration());\n+    String currentMasterAddrs = Preconditions.checkNotNull(conf.get(HConstants.MASTER_ADDRS_KEY));\n+    HMaster activeMaster = TEST_UTIL.getHBaseCluster().getMaster();\n+    String clusterId = activeMaster.getClusterId();\n+    // Add a non-working master\n+    ServerName badServer = ServerName.valueOf(\"localhost\", 1234, -1);\n+    conf.set(HConstants.MASTER_ADDRS_KEY, badServer.toShortString() + \",\" + currentMasterAddrs);\n+    // Set the hedging fan out so that all masters are queried.\n+    conf.setInt(MasterRegistry.MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY, 4);\n+    try (MasterRegistry registry = new MasterRegistry(conf)) {\n+      final Set<ServerName> masters = registry.getParsedMasterServers();\n+      assertTrue(masters.contains(badServer));\n+      // Make a registry RPC, this should trigger a refresh since one of the hedged RPC fails.\n+      assertEquals(registry.getClusterId().get(), clusterId);\n+      // Wait for new set of masters to be populated.\n+      TEST_UTIL.waitFor(5000,\n+          (Waiter.Predicate<Exception>) () -> !registry.getParsedMasterServers().equals(masters));\n+      // new set of masters should not include the bad server\n+      final Set<ServerName> newMasters = registry.getParsedMasterServers();\n+      // Bad one should be out.\n+      assertEquals(3, newMasters.size());\n+      assertFalse(newMasters.contains(badServer));\n+      // Kill the active master\n+      activeMaster.stopMaster();\n+      TEST_UTIL.waitFor(10000,\n+        () -> TEST_UTIL.getMiniHBaseCluster().getLiveMasterThreads().size() == 2);\n+      assertEquals(registry.getClusterId().get(), clusterId);\n+      // Make another registry RPC call which should trigger another refresh.\n+      TEST_UTIL.waitFor(100000, (Waiter.Predicate<Exception>) () ->\n+          registry.getParsedMasterServers().size() == 2);\n+      final Set<ServerName> newMasters2 = registry.getParsedMasterServers();\n+      assertEquals(2, newMasters2.size());", "originalCommit": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEwNjc5MQ==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r460106791", "bodyText": "For any generic RPC failure, we want to expedite populating masters with another RPC call.\nLet's say there are some sequence of events:\n\ngetClusterId() RPC call failed\nmaster refresher thread was in waiting state, so we notify it and it will trigger getMasters() call\nthe call fails again and we notify refreshMasters but no one is waiting on it, notify is ignored\nmaster refresher thread again waits for 5 min before populating masters.\n\nDo we really want step 4 to wait for 5 min (assuming no other RPC call happens and masters list is stale)? Maybe we can expedite populating masters with the help of AtomicBoolean check (and also avoid synchronized + wait calls i.e 5 min wait)?\nEven if we have network issue, we don't want to delay populate masters by 5 min right?", "author": "virajjasani", "createdAt": "2020-07-24T14:58:20Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -170,6 +214,11 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     callable.call(controller, stub, resp -> {\n       if (controller.failed()) {\n         future.completeExceptionally(controller.getFailed());\n+        // RPC has failed, trigger a refresh of master end points. We can have some spurious\n+        // refreshes, but that is okay since the RPC is not expensive and not in a hot path.\n+        synchronized (refreshMasters) {\n+          refreshMasters.notify();", "originalCommit": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzMjg1OQ==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r460132859", "bodyText": "Maybe we can expedite populating masters with the help of AtomicBoolean check\n\nNot sure I follow this, mind rephrasing?\n\nassuming no other RPC call happens and masters list is stale\n\nIf not other RPC call happens, it doesn't matter if the list is stale or not?\n\nEven if we have network issue, we don't want to delay populate masters by 5 min right?\n\nNot sure I follow, if we have a network issue, how can we populate?", "author": "bharathv", "createdAt": "2020-07-24T15:40:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEwNjc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1MjM0Mw==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r460552343", "bodyText": "Maybe we can expedite populating masters with the help of AtomicBoolean check\n\nNot sure I follow this, mind rephrasing?\n\nI meant to say if refresh thread misses this notify because it is already done waiting on refreshMasters, for the next loop, it should not again wait 5 min on refreshMasters and rather quickly perform RPC call to populate masters.\n\n\nEven if we have network issue, we don't want to delay populate masters by 5 min right?\n\nNot sure I follow, if we have a network issue, how can we populate?\n\nI meant same as above that even if network issue causes notify to refresh thread when it was already past waiting state, maybe next time the thread better quickly make an RPC call rather than waiting 5 min on refreshMasters. But yes, for network issues, we will keep making RPC calls without any progress.\n\nIf not other RPC call happens, it doesn't matter if the list is stale or not?\n\nHmm that's true.", "author": "virajjasani", "createdAt": "2020-07-26T17:24:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEwNjc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTczNzkxMw==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r461737913", "bodyText": "I meant to say if refresh thread misses this notify because it is already done waiting on refreshMasters, for the next loop, it should not again wait 5 min on refreshMasters and rather quickly perform RPC call to populate masters.\n\nI don't think thats needed. If the thread has just fetched the masters (in cases where it missed the notification), it is very unlikely that something new has been added/removed. Typically this is a very rare event, probably less rare in K8s environment than DC deployments but even then I don't think things usually change for days if not weeks.", "author": "bharathv", "createdAt": "2020-07-28T17:07:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEwNjc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1MjcyNg==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r460552726", "bodyText": "nit: static final here? Anyways, MasterRegistry is singleton right? (if not by design, but by usage)", "author": "virajjasani", "createdAt": "2020-07-26T17:27:43Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -89,11 +97,17 @@\n   private final int hedgedReadFanOut;\n \n   // Configured list of masters to probe the meta information from.\n-  private final ImmutableMap<ServerName, ClientMetaService.Interface> masterAddr2Stub;\n+  private volatile ImmutableMap<ServerName, ClientMetaService.Interface> masterAddr2Stub;\n \n   // RPC client used to talk to the masters.\n   private final RpcClient rpcClient;\n   private final RpcControllerFactory rpcControllerFactory;\n+  private final int rpcTimeoutMs;\n+  // For synchronizing on refreshing the master end-points\n+  private final Object refreshMasters = new Object();", "originalCommit": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczNDcyMA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464734720", "bodyText": "No, it's loosely tied to a single connection (there are some places that create on the fly registries which is something that can be fixed).\nA single application can connect to multiple clusters which means we cannot make it static.", "author": "bharathv", "createdAt": "2020-08-04T00:41:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1MjcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5MTk5Ng==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r465691996", "bodyText": "Oops, yes. This better be just final.", "author": "virajjasani", "createdAt": "2020-08-05T12:32:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU1MjcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4NzcyNQ==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464587725", "bodyText": "Can you say more here? Why is it that the internal RPCs that keep the master list up to date are sufficient to skip a call to \"GetClusterId\"? Can you provide a \"see also\" comment that points the reader off to the counting logic, or at least the counter that this condition protects?", "author": "ndimiduk", "createdAt": "2020-08-03T18:25:57Z", "path": "hbase-client/src/test/java/org/apache/hadoop/hbase/client/TestMasterRegistryHedgedReads.java", "diffHunk": "@@ -121,6 +121,11 @@ public boolean hasCellBlockSupport() {\n     @Override\n     public void callMethod(MethodDescriptor method, RpcController controller, Message request,\n       Message responsePrototype, RpcCallback<Message> done) {\n+      if (!method.getName().equals(\"GetClusterId\")) {\n+        // Master registry internally runs other RPCs to keep the master list up to date. This check", "originalCommit": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc0MTI2Nw==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464741267", "bodyText": "Will add more detail. That is needed because of the way the test is written. This RpcChannel implementation intercepts all the mock RPCs from unit tests and the just counts the getClusterId calls (depending on the index).. With the patch a single GetClusterID() RPC failure can trigger an extra getMasters() call and that is accounted too.", "author": "bharathv", "createdAt": "2020-08-04T01:08:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4NzcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4ODkzNg==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464588936", "bodyText": "You sure that any failure should require refreshing the list? A mechanism wherein RPC failure results in more RPCs has me suspicious...", "author": "ndimiduk", "createdAt": "2020-08-03T18:28:20Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -170,6 +214,11 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     callable.call(controller, stub, resp -> {\n       if (controller.failed()) {\n         future.completeExceptionally(controller.getFailed());\n+        // RPC has failed, trigger a refresh of master end points. We can have some spurious", "originalCommit": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDgwMTQxNw==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464801417", "bodyText": "My thinking was that since the RPC is relatively inexpensive and is not in any hot path, we could refresh it for any exception. One small optimization we could do is to do it only \"connect\" exceptions (timeouts/closed channel etc).\n\nRPC failure results in more RPCs has me suspicious...\n\nHmm. It's only on a best effort basis we try to keep the list up to date. If no master is reachable, I think we will be in a deeper trouble. I see your point though. You think we should have some kind of back-off on this thread if we are in that state where all the RPCs are failing and we have repeated getMasters() lookups?", "author": "bharathv", "createdAt": "2020-08-04T05:05:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4ODkzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAyMTY5MQ==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r466021691", "bodyText": "It seems like something we want to ensure is well-throttled, so that 100's of clients are not overwhelming 3 masters while they're trying to manage cluster recovery. I've recently been investigating an event where we have the rs hosting meta get overwhelmed by client requests, while the master is concurrently trying to process server crash procedures, thus the idea of the stampeding herd is fresh in my mind. Our IPC QoS story isn't great right now, so I want to think carefully about how failure and recovery scenarios play out with ratios of client:server that are on the order of 100:1.", "author": "ndimiduk", "createdAt": "2020-08-05T21:44:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4ODkzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAzOTE0MQ==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r466039141", "bodyText": "Ya, I think thats a valid concern. I was thinking about a similar edge case, hence the exponential back-off proposal. I think we can either implement a back-off or wrap it in a simple rate limiter (ex: no more than 1 getMasters in a 2 min window). WDYT?", "author": "bharathv", "createdAt": "2020-08-05T22:28:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4ODkzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2OTQ5OQ==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r466069499", "bodyText": "Between a throttle and an exponential backoff, i have no preference. I think we won't know what works until someone suffers the the consequences. Having something in place will address my concern.", "author": "ndimiduk", "createdAt": "2020-08-06T00:02:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU4ODkzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5NDE3NQ==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464594175", "bodyText": "Should this interrupt be accompanied by a shutdown of the managing thread pool? Maybe in an attached exception handler. Or it's okay to leave the pool as abandoned, on the assumption that there was only the single thread in the pool and the whole process is being terminated.", "author": "ndimiduk", "createdAt": "2020-08-03T18:39:28Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -115,20 +129,50 @@\n   MasterRegistry(Configuration conf) throws IOException {\n     this.hedgedReadFanOut = Math.max(1, conf.getInt(MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY,\n       MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT));\n-    int rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n+    rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n       conf.getLong(HConstants.HBASE_RPC_TIMEOUT_KEY, HConstants.DEFAULT_HBASE_RPC_TIMEOUT));\n     // XXX: we pass cluster id as null here since we do not have a cluster id yet, we have to fetch\n     // this through the master registry...\n     // This is a problem as we will use the cluster id to determine the authentication method\n     rpcClient = RpcClientFactory.createClient(conf, null);\n     rpcControllerFactory = RpcControllerFactory.instantiate(conf);\n-    Set<ServerName> masterAddrs = parseMasterAddrs(conf);\n+    // Generate the seed list of master stubs. Subsequent RPCs try to keep a live list of masters\n+    // by fetching the end points from this list.\n+    populateMasterStubs(parseMasterAddrs(conf));\n+    Runnable masterEndPointRefresher = () -> {\n+      while (!Thread.interrupted()) {\n+        try {\n+          // Spurious wake ups are okay, worst case we make an extra RPC call to refresh. We won't\n+          // have duplicate refreshes because once the thread is past the wait(), notify()s are\n+          // ignored until the thread is back to the waiting state.\n+          synchronized (refreshMasters) {\n+            refreshMasters.wait(WAIT_TIME_OUT_MS);\n+          }\n+          LOG.debug(\"Attempting to refresh master address end points.\");\n+          Set<ServerName> newMasters = new HashSet<>(getMasters().get());\n+          populateMasterStubs(newMasters);\n+          LOG.debug(\"Finished refreshing master end points. {}\", newMasters);\n+        } catch (InterruptedException e) {\n+          LOG.debug(\"Interrupted during wait, aborting refresh-masters-thread.\", e);", "originalCommit": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5NTY5NA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464595694", "bodyText": "Oh, reading below, there is no thread pool. I +1 Viraj's suggestion of a single thread executor service.", "author": "ndimiduk", "createdAt": "2020-08-03T18:42:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5NDE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczOTgzMg==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464739832", "bodyText": "Done.", "author": "bharathv", "createdAt": "2020-08-04T01:02:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5NDE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDc0MDcwNw==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464740707", "bodyText": "Should this interrupt be accompanied by a shutdown of the managing thread pool?\n\nThis is InterruptedException thrown by wait() call. try-catch seems like the right way to do it? (unless I misunderstood what you are suggesting).", "author": "bharathv", "createdAt": "2020-08-04T01:06:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5NDE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAxOTI5MA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r466019290", "bodyText": "Let me try again, and ask about the application lifecycle of this thread. It looks like a thread we always want running, unless the Connection is being closed. Now that there's a pool, I'm asking about the lifecycle of the pool, when it's shutdown method is called. I'm also asking about the presence of the thread -- is there a reason the thread could be interrupted (and thus terminated) while the connection remains active? There's only one call to submit, and there's nothing that checks for the presence of the thread. So can a connection enter a state where it's still alive with no masterRefreshThread running?", "author": "ndimiduk", "createdAt": "2020-08-05T21:38:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5NDE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAzNjkyNw==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r466036927", "bodyText": "is there a reason the thread could be interrupted (and thus terminated) while the connection remains active\n\nI don't think so. The only interruptor for this thread should be from the shutdown from the registry#close(), which is called during connection clean up.\n\nSo can a connection enter a state where it's still alive with no masterRefreshThread running?\n\nAFAICT that is not possible. The only way it can break the loop is via interruption.", "author": "bharathv", "createdAt": "2020-08-05T22:22:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5NDE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA2OTU3NA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r466069574", "bodyText": "\ud83d\udc4d", "author": "ndimiduk", "createdAt": "2020-08-06T00:02:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5NDE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5NjY3NA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464596674", "bodyText": "Should the thread be started in the constructor? Now I see that ConnectionRegistry defines a close() but not a start() :(", "author": "ndimiduk", "createdAt": "2020-08-03T18:44:49Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -115,20 +129,50 @@\n   MasterRegistry(Configuration conf) throws IOException {\n     this.hedgedReadFanOut = Math.max(1, conf.getInt(MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY,\n       MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT));\n-    int rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n+    rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n       conf.getLong(HConstants.HBASE_RPC_TIMEOUT_KEY, HConstants.DEFAULT_HBASE_RPC_TIMEOUT));\n     // XXX: we pass cluster id as null here since we do not have a cluster id yet, we have to fetch\n     // this through the master registry...\n     // This is a problem as we will use the cluster id to determine the authentication method\n     rpcClient = RpcClientFactory.createClient(conf, null);\n     rpcControllerFactory = RpcControllerFactory.instantiate(conf);\n-    Set<ServerName> masterAddrs = parseMasterAddrs(conf);\n+    // Generate the seed list of master stubs. Subsequent RPCs try to keep a live list of masters\n+    // by fetching the end points from this list.\n+    populateMasterStubs(parseMasterAddrs(conf));\n+    Runnable masterEndPointRefresher = () -> {\n+      while (!Thread.interrupted()) {\n+        try {\n+          // Spurious wake ups are okay, worst case we make an extra RPC call to refresh. We won't\n+          // have duplicate refreshes because once the thread is past the wait(), notify()s are\n+          // ignored until the thread is back to the waiting state.\n+          synchronized (refreshMasters) {\n+            refreshMasters.wait(WAIT_TIME_OUT_MS);\n+          }\n+          LOG.debug(\"Attempting to refresh master address end points.\");\n+          Set<ServerName> newMasters = new HashSet<>(getMasters().get());\n+          populateMasterStubs(newMasters);\n+          LOG.debug(\"Finished refreshing master end points. {}\", newMasters);\n+        } catch (InterruptedException e) {\n+          LOG.debug(\"Interrupted during wait, aborting refresh-masters-thread.\", e);\n+          break;\n+        } catch (ExecutionException | IOException e) {\n+          LOG.debug(\"Error populating latest list of masters.\", e);\n+        }\n+      }\n+    };\n+    masterAddrRefresherThread = Threads.newDaemonThreadFactory(\n+        \"MasterRegistry refresh end-points\").newThread(masterEndPointRefresher);\n+    masterAddrRefresherThread.start();", "originalCommit": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczOTM1OQ==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464739359", "bodyText": "There is a start() in the c'tor? (Its hiding between the long comment chains). Anyway I switched to a single threaded pool per the suggestions. Hopefully its more clear.", "author": "bharathv", "createdAt": "2020-08-04T01:01:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5NjY3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5NzUzMg==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464597532", "bodyText": "Where would I find metrics regarding calls to getMasters()? I suppose either client or server-side would be good.", "author": "ndimiduk", "createdAt": "2020-08-03T18:46:31Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -115,20 +129,50 @@\n   MasterRegistry(Configuration conf) throws IOException {\n     this.hedgedReadFanOut = Math.max(1, conf.getInt(MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY,\n       MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT));\n-    int rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n+    rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n       conf.getLong(HConstants.HBASE_RPC_TIMEOUT_KEY, HConstants.DEFAULT_HBASE_RPC_TIMEOUT));\n     // XXX: we pass cluster id as null here since we do not have a cluster id yet, we have to fetch\n     // this through the master registry...\n     // This is a problem as we will use the cluster id to determine the authentication method\n     rpcClient = RpcClientFactory.createClient(conf, null);\n     rpcControllerFactory = RpcControllerFactory.instantiate(conf);\n-    Set<ServerName> masterAddrs = parseMasterAddrs(conf);\n+    // Generate the seed list of master stubs. Subsequent RPCs try to keep a live list of masters\n+    // by fetching the end points from this list.\n+    populateMasterStubs(parseMasterAddrs(conf));\n+    Runnable masterEndPointRefresher = () -> {\n+      while (!Thread.interrupted()) {\n+        try {\n+          // Spurious wake ups are okay, worst case we make an extra RPC call to refresh. We won't\n+          // have duplicate refreshes because once the thread is past the wait(), notify()s are\n+          // ignored until the thread is back to the waiting state.\n+          synchronized (refreshMasters) {\n+            refreshMasters.wait(WAIT_TIME_OUT_MS);\n+          }\n+          LOG.debug(\"Attempting to refresh master address end points.\");\n+          Set<ServerName> newMasters = new HashSet<>(getMasters().get());", "originalCommit": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDczNTc1NA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r464735754", "bodyText": "I haven't thought about this. Are you talking about this RPC specifically? If so, may I ask why?\nAdding it on the server makes sense to me, like we want some metrics around where most of the time is spent (grouped by RPC) but curious what purpose it serves on client.", "author": "bharathv", "createdAt": "2020-08-04T00:46:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5NzUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAxNzA0NA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r466017044", "bodyText": "Someone who has the HBase client embedded in their application might be interested in observing this behavior, if they notice sudden spikes in RPC traffic not directly correlated with their application's data path.\nOr maybe it's enough to track these calls on the server-side. We'd see the same spikes, though with less granularity.", "author": "ndimiduk", "createdAt": "2020-08-05T21:33:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5NzUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAzNTY4OQ==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r466035689", "bodyText": "Okay. Looks like we have all the plumbing for client metrics already in place via HBASE-12911. I can add metrics for this RPC.", "author": "bharathv", "createdAt": "2020-08-05T22:19:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5NzUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjA3MDMwNw==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r466070307", "bodyText": "Either client-side or server-side is fine with me. Just having something that an operator can expose would be useful.", "author": "ndimiduk", "createdAt": "2020-08-06T00:05:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDU5NzUzMg=="}], "type": "inlineReview"}, {"oid": "f7ae049a724dc132c15f2735c1b670a88604e99a", "url": "https://github.com/apache/hbase/commit/f7ae049a724dc132c15f2735c1b670a88604e99a", "message": "Address review comments", "committedDate": "2020-08-04T16:07:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5NTI5Nw==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r465695297", "bodyText": "nit: MasterRegistry-refresh-end-points-%d or MasterRegistry-refresh-pool-%d ?", "author": "virajjasani", "createdAt": "2020-08-05T12:38:41Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -115,20 +132,49 @@\n   MasterRegistry(Configuration conf) throws IOException {\n     this.hedgedReadFanOut = Math.max(1, conf.getInt(MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY,\n       MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT));\n-    int rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n+    rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n       conf.getLong(HConstants.HBASE_RPC_TIMEOUT_KEY, HConstants.DEFAULT_HBASE_RPC_TIMEOUT));\n     // XXX: we pass cluster id as null here since we do not have a cluster id yet, we have to fetch\n     // this through the master registry...\n     // This is a problem as we will use the cluster id to determine the authentication method\n     rpcClient = RpcClientFactory.createClient(conf, null);\n     rpcControllerFactory = RpcControllerFactory.instantiate(conf);\n-    Set<ServerName> masterAddrs = parseMasterAddrs(conf);\n+    // Generate the seed list of master stubs. Subsequent RPCs try to keep a live list of masters\n+    // by fetching the end points from this list.\n+    populateMasterStubs(parseMasterAddrs(conf));\n+    masterAddrRefresher = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder()\n+        .setNameFormat(\"MasterRegistry refresh end-points\").setDaemon(true).build());", "originalCommit": "f7ae049a724dc132c15f2735c1b670a88604e99a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjAzOTc4NQ==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r466039785", "bodyText": "will do", "author": "bharathv", "createdAt": "2020-08-05T22:30:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5NTI5Nw=="}], "type": "inlineReview"}, {"oid": "fb3465140b1d33cd8638330db90343f859c22a54", "url": "https://github.com/apache/hbase/commit/fb3465140b1d33cd8638330db90343f859c22a54", "message": "HBASE-24765: Dynamic master discovery\n\nThis patch adds the ability to discover newly added masters\ndynamically on the master registry side. The trigger for the\nre-fetch is either periodic (5 mins) or any registry RPC failure.\n\nUpdates the client side connection metrics to maintain a counter\nper RPC type so that clients have visibility into counts grouped\nby RPC method name.\n\nI didn't add the method to ZK registry interface since there\nis a design discussion going on in splittable meta doc. We can\nadd it later if needed.", "committedDate": "2020-08-10T08:04:13Z", "type": "forcePushed"}, {"oid": "14eae44b3e43cd8da9f10841cd56cd21ea9c567b", "url": "https://github.com/apache/hbase/commit/14eae44b3e43cd8da9f10841cd56cd21ea9c567b", "message": "HBASE-24765: Dynamic master discovery\n\nThis patch adds the ability to discover newly added masters\ndynamically on the master registry side. The trigger for the\nre-fetch is either periodic (5 mins) or any registry RPC failure.\n\nUpdates the client side connection metrics to maintain a counter\nper RPC type so that clients have visibility into counts grouped\nby RPC method name.\n\nI didn't add the method to ZK registry interface since there\nis a design discussion going on in splittable meta doc. We can\nadd it later if needed.", "committedDate": "2020-08-10T16:26:27Z", "type": "forcePushed"}, {"oid": "48157bbfec66e850357f9056d48eb7c84041ed91", "url": "https://github.com/apache/hbase/commit/48157bbfec66e850357f9056d48eb7c84041ed91", "message": "HBASE-24765: Dynamic master discovery\n\nThis patch adds the ability to discover newly added masters\ndynamically on the master registry side. The trigger for the\nre-fetch is either periodic (5 mins) or any registry RPC failure.\n\nUpdates the client side connection metrics to maintain a counter\nper RPC type so that clients have visibility into counts grouped\nby RPC method name.\n\nI didn't add the method to ZK registry interface since there\nis a design discussion going on in splittable meta doc. We can\nadd it later if needed.", "committedDate": "2020-08-10T17:56:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI1MjA0MA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r470252040", "bodyText": "Sorry I didn't notice this earlier. Maybe a ScheduledThreadPoolExecutor would simplify your scheduling need?", "author": "ndimiduk", "createdAt": "2020-08-13T21:13:41Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterAddressRefresher.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.util.EnvironmentEdgeManager;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.base.Preconditions;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+import org.apache.hadoop.hbase.shaded.protobuf.generated.MasterProtos.ClientMetaService;\n+\n+/**\n+ * Thread safe utility that keeps master end points used by {@link MasterRegistry} up to date. This\n+ * uses the RPC {@link ClientMetaService#getMasters} to fetch the latest list of registered masters.\n+ * By default the refresh happens periodically (configured via\n+ * {@link #PERIODIC_REFRESH_INTERVAL_SECS}). The refresh can also be triggered on demand via\n+ * {@link #refreshNow()}. To prevent a flood of on-demand refreshes we expect that any attempts two\n+ * should be spaced at least {@link #MIN_SECS_BETWEEN_REFRESHES} seconds apart.\n+ */\n+@InterfaceAudience.Private\n+public class MasterAddressRefresher implements Closeable {\n+  private static final Logger LOG = LoggerFactory.getLogger(MasterAddressRefresher.class);\n+  public static final String PERIODIC_REFRESH_INTERVAL_SECS =\n+      \"hbase.client.master_registry.refresh_interval_secs\";\n+  private static final int PERIODIC_REFRESH_INTERVAL_SECS_DEFAULT = 300;\n+  public static final String MIN_SECS_BETWEEN_REFRESHES =\n+      \"hbase.client.master_registry.min_secs_between_refreshes\";\n+  private static final long MIN_SECS_BETWEEN_REFRESHES_DEFAULT = 60;\n+\n+  private final ExecutorService pool;\n+  private final MasterRegistry registry;\n+  private final long periodicRefreshMs;\n+  private final long timeBetweenRefreshesMs;\n+  private final Object refreshMasters = new Object();\n+\n+  @Override\n+  public void close() {\n+    pool.shutdownNow();\n+  }\n+\n+  /**\n+   * Thread that refreshes the master end points until it is interrupted via {@link #close()}.\n+   * Multiple callers attempting to refresh at the same time synchronize on {@link #refreshMasters}.\n+   */\n+  private class RefreshThread implements Runnable {\n+    @Override\n+    public void run() {\n+      long lastRpcTs = 0;\n+      while (!Thread.interrupted()) {\n+        try {\n+          // Spurious wake ups are okay, worst case we make an extra RPC call to refresh. We won't\n+          // have duplicate refreshes because once the thread is past the wait(), notify()s are\n+          // ignored until the thread is back to the waiting state.\n+          synchronized (refreshMasters) {\n+            refreshMasters.wait(periodicRefreshMs);\n+          }\n+          long currentTs = EnvironmentEdgeManager.currentTime();\n+          if (lastRpcTs != 0 && currentTs - lastRpcTs <= timeBetweenRefreshesMs) {\n+            continue;\n+          }\n+          lastRpcTs = currentTs;\n+          LOG.debug(\"Attempting to refresh master address end points.\");\n+          Set<ServerName> newMasters = new HashSet<>(registry.getMasters().get());\n+          registry.populateMasterStubs(newMasters);\n+          LOG.debug(\"Finished refreshing master end points. {}\", newMasters);\n+        } catch (InterruptedException e) {\n+          LOG.debug(\"Interrupted during wait, aborting refresh-masters-thread.\", e);\n+          break;\n+        } catch (ExecutionException | IOException e) {\n+          LOG.debug(\"Error populating latest list of masters.\", e);\n+        }\n+      }\n+    }\n+  }\n+\n+  MasterAddressRefresher(Configuration conf, MasterRegistry registry) {\n+    pool = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder()", "originalCommit": "48157bbfec66e850357f9056d48eb7c84041ed91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI2ODQwMA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r470268400", "bodyText": "This is a long running thread and wakes up if there is an on-demand refresh (via refreshNow()). If we use a scheduled executor, on demand scheduling logic becomes  a bit tricky, right? (unless there is some easy way of doing it that I missed).", "author": "bharathv", "createdAt": "2020-08-13T21:49:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI1MjA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM2NzkxMg==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r470367912", "bodyText": "I think this could be a follow on issue. Let's get this feature in first as I think it is very useful for a long running service which depends on HBase? I have an idea on making use of the HashedWheelTimeoutTimer to do the refreshing work, will file an improvement issue if I have time.", "author": "Apache9", "createdAt": "2020-08-14T01:53:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI1MjA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQyMTIzMw==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r470421233", "bodyText": "Whats your idea? Just curious.", "author": "bharathv", "createdAt": "2020-08-14T05:42:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI1MjA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY1Njc0NA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r473656744", "bodyText": "Introduce a global HashedWheelTimeoutTimer to be used at client side. Now there is one in AsyncConnectionImpl, but in MasterRegistry we can not depend on AsyncConnection so we should move it to another place.\nAnd schedule a timer task to HashedWheelTimeoutTimer to do the refresh. To avoid blocking the thread, we could make use of async rpc call.", "author": "Apache9", "createdAt": "2020-08-20T06:43:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI1MjA0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1MDMwMg==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r474150302", "bodyText": "Thanks.", "author": "bharathv", "createdAt": "2020-08-20T17:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI1MjA0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNTA2MQ==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r459835061", "bodyText": "Usually a notify without any flag will have strange race problem...\nAt least let's have a 'triggerRefresh' flag to guard redundant notification?", "author": "Apache9", "createdAt": "2020-07-24T03:24:06Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -170,6 +214,11 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     callable.call(controller, stub, resp -> {\n       if (controller.failed()) {\n         future.completeExceptionally(controller.getFailed());\n+        // RPC has failed, trigger a refresh of master end points. We can have some spurious\n+        // refreshes, but that is okay since the RPC is not expensive and not in a hot path.\n+        synchronized (refreshMasters) {", "originalCommit": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNTIwOA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r459835208", "bodyText": "I think we can test the exception type? Only if it is a connect exception, we will refresh the address list?", "author": "Apache9", "createdAt": "2020-07-24T03:24:53Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -170,6 +214,11 @@ public static String getMasterAddr(Configuration conf) throws UnknownHostExcepti\n     callable.call(controller, stub, resp -> {\n       if (controller.failed()) {\n         future.completeExceptionally(controller.getFailed());\n+        // RPC has failed, trigger a refresh of master end points. We can have some spurious", "originalCommit": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQyMTYwOQ==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r470421609", "bodyText": "Ya, that was what I wanted to do originally, but I thought the rpc is cheap and it doesn't hurt to do for any exception and left it this way. Let me add it, I don't have a strong preference.", "author": "bharathv", "createdAt": "2020-08-14T05:44:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNTIwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNTQ0Ng==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r459835446", "bodyText": "I think here we should assign masterAddr2Stub to a local variable before using it?", "author": "Apache9", "createdAt": "2020-07-24T03:26:05Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -226,17 +276,19 @@ private IOException badResponse(String debug) {\n \n   private <T extends Message> CompletableFuture<T> call(Callable<T> callable,\n     Predicate<T> isValidResp, String debug) {\n+    Set<ServerName> masterServers = masterAddr2Stub.keySet();", "originalCommit": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcyNDkyNQ==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r470724925", "bodyText": "Right, done.", "author": "bharathv", "createdAt": "2020-08-14T16:21:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNTQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNTgxMA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r459835810", "bodyText": "Do not need to be public?", "author": "Apache9", "createdAt": "2020-07-24T03:28:15Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -259,17 +311,40 @@ private RegionLocations transformMetaRegionLocations(GetMetaRegionLocationsRespo\n       .thenApply(GetClusterIdResponse::getClusterId);\n   }\n \n-  private ServerName transformServerName(GetActiveMasterResponse resp) {\n-    return ProtobufUtil.toServerName(resp.getServerName());\n+  private static boolean hasActiveMaster(GetMastersResponse resp) {\n+    List<GetMastersResponseEntry> activeMasters =\n+        resp.getMasterServersList().stream().filter(GetMastersResponseEntry::getIsActive).collect(\n+        Collectors.toList());\n+    return activeMasters.size() == 1;\n+  }\n+\n+  private static ServerName filterActiveMaster(GetMastersResponse resp) {\n+    List<GetMastersResponseEntry> activeMasters =\n+        resp.getMasterServersList().stream().filter(GetMastersResponseEntry::getIsActive).collect(\n+            Collectors.toList());\n+    Preconditions.checkState(activeMasters.size() == 1);\n+    return ProtobufUtil.toServerName(activeMasters.get(0).getServerName());\n   }\n \n   @Override\n   public CompletableFuture<ServerName> getActiveMaster() {\n     return this\n-      .<GetActiveMasterResponse> call(\n-        (c, s, d) -> s.getActiveMaster(c, GetActiveMasterRequest.getDefaultInstance(), d),\n-        GetActiveMasterResponse::hasServerName, \"getActiveMaster()\")\n-      .thenApply(this::transformServerName);\n+      .<GetMastersResponse> call(\n+        (c, s, d) -> s.getMasters(c, GetMastersRequest.getDefaultInstance(), d),\n+        MasterRegistry::hasActiveMaster, \"getMasters()\")\n+      .thenApply(MasterRegistry::filterActiveMaster);\n+  }\n+\n+  private static List<ServerName> transformServerNames(GetMastersResponse resp) {\n+    return resp.getMasterServersList().stream().map(s -> ProtobufUtil.toServerName(\n+        s.getServerName())).collect(Collectors.toList());\n+  }\n+\n+  public CompletableFuture<List<ServerName>> getMasters() {", "originalCommit": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcyNTYyMg==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r470725622", "bodyText": "Done.", "author": "bharathv", "createdAt": "2020-08-14T16:22:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNTgxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNjI4Mw==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r459836283", "bodyText": "Do we want to make it configurable?", "author": "Apache9", "createdAt": "2020-07-24T03:31:03Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -89,11 +97,17 @@\n   private final int hedgedReadFanOut;\n \n   // Configured list of masters to probe the meta information from.\n-  private final ImmutableMap<ServerName, ClientMetaService.Interface> masterAddr2Stub;\n+  private volatile ImmutableMap<ServerName, ClientMetaService.Interface> masterAddr2Stub;\n \n   // RPC client used to talk to the masters.\n   private final RpcClient rpcClient;\n   private final RpcControllerFactory rpcControllerFactory;\n+  private final int rpcTimeoutMs;\n+  // For synchronizing on refreshing the master end-points\n+  private final Object refreshMasters = new Object();\n+  // Refreshed every WAIT_TIME_OUT_MS or unless explicitly invoked.\n+  private static final int WAIT_TIME_OUT_MS = 5 * 60 * 1000; // 5 mins", "originalCommit": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNjYxMQ==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r459836611", "bodyText": "I prefer we add a stop flag for the Registry and test it to determine whether we should quit.", "author": "Apache9", "createdAt": "2020-07-24T03:32:43Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -115,20 +129,50 @@\n   MasterRegistry(Configuration conf) throws IOException {\n     this.hedgedReadFanOut = Math.max(1, conf.getInt(MASTER_REGISTRY_HEDGED_REQS_FANOUT_KEY,\n       MASTER_REGISTRY_HEDGED_REQS_FANOUT_DEFAULT));\n-    int rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n+    rpcTimeoutMs = (int) Math.min(Integer.MAX_VALUE,\n       conf.getLong(HConstants.HBASE_RPC_TIMEOUT_KEY, HConstants.DEFAULT_HBASE_RPC_TIMEOUT));\n     // XXX: we pass cluster id as null here since we do not have a cluster id yet, we have to fetch\n     // this through the master registry...\n     // This is a problem as we will use the cluster id to determine the authentication method\n     rpcClient = RpcClientFactory.createClient(conf, null);\n     rpcControllerFactory = RpcControllerFactory.instantiate(conf);\n-    Set<ServerName> masterAddrs = parseMasterAddrs(conf);\n+    // Generate the seed list of master stubs. Subsequent RPCs try to keep a live list of masters\n+    // by fetching the end points from this list.\n+    populateMasterStubs(parseMasterAddrs(conf));\n+    Runnable masterEndPointRefresher = () -> {\n+      while (!Thread.interrupted()) {", "originalCommit": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNjkwMA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r459836900", "bodyText": "This is a behavior change? I do not think we will throw IllegalStateException when there is no active master before this patch?", "author": "Apache9", "createdAt": "2020-07-24T03:34:31Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterRegistry.java", "diffHunk": "@@ -259,17 +311,40 @@ private RegionLocations transformMetaRegionLocations(GetMetaRegionLocationsRespo\n       .thenApply(GetClusterIdResponse::getClusterId);\n   }\n \n-  private ServerName transformServerName(GetActiveMasterResponse resp) {\n-    return ProtobufUtil.toServerName(resp.getServerName());\n+  private static boolean hasActiveMaster(GetMastersResponse resp) {\n+    List<GetMastersResponseEntry> activeMasters =\n+        resp.getMasterServersList().stream().filter(GetMastersResponseEntry::getIsActive).collect(\n+        Collectors.toList());\n+    return activeMasters.size() == 1;\n+  }\n+\n+  private static ServerName filterActiveMaster(GetMastersResponse resp) {\n+    List<GetMastersResponseEntry> activeMasters =\n+        resp.getMasterServersList().stream().filter(GetMastersResponseEntry::getIsActive).collect(\n+            Collectors.toList());\n+    Preconditions.checkState(activeMasters.size() == 1);", "originalCommit": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDcyODMxOQ==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r470728319", "bodyText": "Don't think so. If you see getActiveMaster() call, \"hasActiveMaster\" is applied on the response. If that fails, we throw right away. This is only called on \"thenApply()\" which filters the output. Given the way the code is structured, I had to do it twice (since the call() takes a predicate that returns a boolean).", "author": "bharathv", "createdAt": "2020-08-14T16:27:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNjkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY1OTY3Mw==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r473659673", "bodyText": "But I do not think we will throw IllegalStateException? Usually we will throw IOException here? IllegalStateException is an unchecked exception...", "author": "Apache9", "createdAt": "2020-08-20T06:47:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNjkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDE1Mzk5OA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r474153998", "bodyText": "Its an unchecked exception because if this happens, it is a code bug. This means that someone called filterActiveMaster() without calling hasActiveMaster(). This is impossible to happen because its a private utility and we control the callers. It doesn't seem worth propagating the exceptions for it.", "author": "bharathv", "createdAt": "2020-08-20T17:26:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNjkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNzM2NA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r459837364", "bodyText": "I think this should be done in this patch, as now this method will replace the old getActiveMaster method, which makes it not only be used in our internal refresh but also be used by end users, we should not let users still have the ability to harmmer zookeeper...", "author": "Apache9", "createdAt": "2020-07-24T03:37:04Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/master/MasterRpcServices.java", "diffHunk": "@@ -2931,6 +2935,27 @@ public GetActiveMasterResponse getActiveMaster(RpcController rpcController,\n     return resp.build();\n   }\n \n+  @Override\n+  public GetMastersResponse getMasters(RpcController rpcController, GetMastersRequest request)\n+      throws ServiceException {\n+    GetMastersResponse.Builder resp = GetMastersResponse.newBuilder();\n+    // Active master\n+    Optional<ServerName> serverName = master.getActiveMaster();\n+    serverName.ifPresent(name -> resp.addMasterServers(GetMastersResponseEntry.newBuilder()\n+        .setServerName(ProtobufUtil.toServerName(name)).setIsActive(true).build()));\n+    // Backup masters\n+    try {\n+      // TODO: Cache the backup masters to avoid a ZK RPC for each getMasters() call.", "originalCommit": "36fe586bb715c6e0372d0575ae73c59b0886d3aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDczMjM3NQ==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r470732375", "bodyText": "I have a separate patch for this, didn't want to scope creep this one. Mind if do a separate PR? I will back port them together.", "author": "bharathv", "createdAt": "2020-08-14T16:36:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTgzNzM2NA=="}], "type": "inlineReview"}, {"oid": "e46dfcef4c3b6e70f34d48835d5837e698815a79", "url": "https://github.com/apache/hbase/commit/e46dfcef4c3b6e70f34d48835d5837e698815a79", "message": "HBASE-24765: Dynamic master discovery\n\nThis patch adds the ability to discover newly added masters\ndynamically on the master registry side. The trigger for the\nre-fetch is either periodic (5 mins) or any registry RPC failure.\n\nUpdates the client side connection metrics to maintain a counter\nper RPC type so that clients have visibility into counts grouped\nby RPC method name.\n\nI didn't add the method to ZK registry interface since there\nis a design discussion going on in splittable meta doc. We can\nadd it later if needed.", "committedDate": "2020-08-14T20:35:18Z", "type": "forcePushed"}, {"oid": "6cd028727d93eb34df1f01080e9e01f39ecd3242", "url": "https://github.com/apache/hbase/commit/6cd028727d93eb34df1f01080e9e01f39ecd3242", "message": "Cache backup masters in ActiveMasterManager", "committedDate": "2020-08-17T07:25:37Z", "type": "forcePushed"}, {"oid": "f0c146fe40c4b59d294971b8916aff2f724c6808", "url": "https://github.com/apache/hbase/commit/f0c146fe40c4b59d294971b8916aff2f724c6808", "message": "Cache backup masters in ActiveMasterManager", "committedDate": "2020-08-24T05:04:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2MzQ4OQ==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r471663489", "bodyText": "nit: TimeUnit.SECONDS.toMillis(conf.getLong(,))", "author": "virajjasani", "createdAt": "2020-08-17T17:57:29Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterAddressRefresher.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.util.EnvironmentEdgeManager;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.base.Preconditions;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+import org.apache.hadoop.hbase.shaded.protobuf.generated.MasterProtos.ClientMetaService;\n+\n+/**\n+ * Thread safe utility that keeps master end points used by {@link MasterRegistry} up to date. This\n+ * uses the RPC {@link ClientMetaService#getMasters} to fetch the latest list of registered masters.\n+ * By default the refresh happens periodically (configured via\n+ * {@link #PERIODIC_REFRESH_INTERVAL_SECS}). The refresh can also be triggered on demand via\n+ * {@link #refreshNow()}. To prevent a flood of on-demand refreshes we expect that any attempts two\n+ * should be spaced at least {@link #MIN_SECS_BETWEEN_REFRESHES} seconds apart.\n+ */\n+@InterfaceAudience.Private\n+public class MasterAddressRefresher implements Closeable {\n+  private static final Logger LOG = LoggerFactory.getLogger(MasterAddressRefresher.class);\n+  public static final String PERIODIC_REFRESH_INTERVAL_SECS =\n+      \"hbase.client.master_registry.refresh_interval_secs\";\n+  private static final int PERIODIC_REFRESH_INTERVAL_SECS_DEFAULT = 300;\n+  public static final String MIN_SECS_BETWEEN_REFRESHES =\n+      \"hbase.client.master_registry.min_secs_between_refreshes\";\n+  private static final long MIN_SECS_BETWEEN_REFRESHES_DEFAULT = 60;\n+\n+  private final ExecutorService pool;\n+  private final MasterRegistry registry;\n+  private final long periodicRefreshMs;\n+  private final long timeBetweenRefreshesMs;\n+  private final Object refreshMasters = new Object();\n+\n+  @Override\n+  public void close() {\n+    pool.shutdownNow();\n+  }\n+\n+  /**\n+   * Thread that refreshes the master end points until it is interrupted via {@link #close()}.\n+   * Multiple callers attempting to refresh at the same time synchronize on {@link #refreshMasters}.\n+   */\n+  private class RefreshThread implements Runnable {\n+    @Override\n+    public void run() {\n+      long lastRpcTs = 0;\n+      while (!Thread.interrupted()) {\n+        try {\n+          // Spurious wake ups are okay, worst case we make an extra RPC call to refresh. We won't\n+          // have duplicate refreshes because once the thread is past the wait(), notify()s are\n+          // ignored until the thread is back to the waiting state.\n+          synchronized (refreshMasters) {\n+            refreshMasters.wait(periodicRefreshMs);\n+          }\n+          long currentTs = EnvironmentEdgeManager.currentTime();\n+          if (lastRpcTs != 0 && currentTs - lastRpcTs <= timeBetweenRefreshesMs) {\n+            continue;\n+          }\n+          lastRpcTs = currentTs;\n+          LOG.debug(\"Attempting to refresh master address end points.\");\n+          Set<ServerName> newMasters = new HashSet<>(registry.getMasters().get());\n+          registry.populateMasterStubs(newMasters);\n+          LOG.debug(\"Finished refreshing master end points. {}\", newMasters);\n+        } catch (InterruptedException e) {\n+          LOG.debug(\"Interrupted during wait, aborting refresh-masters-thread.\", e);\n+          break;\n+        } catch (ExecutionException | IOException e) {\n+          LOG.debug(\"Error populating latest list of masters.\", e);\n+        }\n+      }\n+    }\n+  }\n+\n+  MasterAddressRefresher(Configuration conf, MasterRegistry registry) {\n+    pool = Executors.newSingleThreadExecutor(new ThreadFactoryBuilder()\n+        .setNameFormat(\"master-registry-refresh-end-points\").setDaemon(true).build());\n+    periodicRefreshMs = 1000 * conf.getLong(PERIODIC_REFRESH_INTERVAL_SECS,\n+        PERIODIC_REFRESH_INTERVAL_SECS_DEFAULT);\n+    timeBetweenRefreshesMs = 1000 * conf.getLong(MIN_SECS_BETWEEN_REFRESHES,\n+        MIN_SECS_BETWEEN_REFRESHES_DEFAULT);", "originalCommit": "6cd028727d93eb34df1f01080e9e01f39ecd3242", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2NDU0NA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r471664544", "bodyText": "nit: keep this int similar to PERIODIC_REFRESH_INTERVAL_SECS_DEFAULT?", "author": "virajjasani", "createdAt": "2020-08-17T17:59:28Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterAddressRefresher.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.util.EnvironmentEdgeManager;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.base.Preconditions;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+import org.apache.hadoop.hbase.shaded.protobuf.generated.MasterProtos.ClientMetaService;\n+\n+/**\n+ * Thread safe utility that keeps master end points used by {@link MasterRegistry} up to date. This\n+ * uses the RPC {@link ClientMetaService#getMasters} to fetch the latest list of registered masters.\n+ * By default the refresh happens periodically (configured via\n+ * {@link #PERIODIC_REFRESH_INTERVAL_SECS}). The refresh can also be triggered on demand via\n+ * {@link #refreshNow()}. To prevent a flood of on-demand refreshes we expect that any attempts two\n+ * should be spaced at least {@link #MIN_SECS_BETWEEN_REFRESHES} seconds apart.\n+ */\n+@InterfaceAudience.Private\n+public class MasterAddressRefresher implements Closeable {\n+  private static final Logger LOG = LoggerFactory.getLogger(MasterAddressRefresher.class);\n+  public static final String PERIODIC_REFRESH_INTERVAL_SECS =\n+      \"hbase.client.master_registry.refresh_interval_secs\";\n+  private static final int PERIODIC_REFRESH_INTERVAL_SECS_DEFAULT = 300;\n+  public static final String MIN_SECS_BETWEEN_REFRESHES =\n+      \"hbase.client.master_registry.min_secs_between_refreshes\";\n+  private static final long MIN_SECS_BETWEEN_REFRESHES_DEFAULT = 60;", "originalCommit": "6cd028727d93eb34df1f01080e9e01f39ecd3242", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2NzIyMA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r471667220", "bodyText": "We are aborting refresh by breaking out of the loop and basically, we are done refreshing master stubs. Better to log this at ERROR?", "author": "virajjasani", "createdAt": "2020-08-17T18:04:43Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/MasterAddressRefresher.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.hbase.ServerName;\n+import org.apache.hadoop.hbase.util.EnvironmentEdgeManager;\n+import org.apache.yetus.audience.InterfaceAudience;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.apache.hbase.thirdparty.com.google.common.base.Preconditions;\n+import org.apache.hbase.thirdparty.com.google.common.util.concurrent.ThreadFactoryBuilder;\n+\n+import org.apache.hadoop.hbase.shaded.protobuf.generated.MasterProtos.ClientMetaService;\n+\n+/**\n+ * Thread safe utility that keeps master end points used by {@link MasterRegistry} up to date. This\n+ * uses the RPC {@link ClientMetaService#getMasters} to fetch the latest list of registered masters.\n+ * By default the refresh happens periodically (configured via\n+ * {@link #PERIODIC_REFRESH_INTERVAL_SECS}). The refresh can also be triggered on demand via\n+ * {@link #refreshNow()}. To prevent a flood of on-demand refreshes we expect that any attempts two\n+ * should be spaced at least {@link #MIN_SECS_BETWEEN_REFRESHES} seconds apart.\n+ */\n+@InterfaceAudience.Private\n+public class MasterAddressRefresher implements Closeable {\n+  private static final Logger LOG = LoggerFactory.getLogger(MasterAddressRefresher.class);\n+  public static final String PERIODIC_REFRESH_INTERVAL_SECS =\n+      \"hbase.client.master_registry.refresh_interval_secs\";\n+  private static final int PERIODIC_REFRESH_INTERVAL_SECS_DEFAULT = 300;\n+  public static final String MIN_SECS_BETWEEN_REFRESHES =\n+      \"hbase.client.master_registry.min_secs_between_refreshes\";\n+  private static final long MIN_SECS_BETWEEN_REFRESHES_DEFAULT = 60;\n+\n+  private final ExecutorService pool;\n+  private final MasterRegistry registry;\n+  private final long periodicRefreshMs;\n+  private final long timeBetweenRefreshesMs;\n+  private final Object refreshMasters = new Object();\n+\n+  @Override\n+  public void close() {\n+    pool.shutdownNow();\n+  }\n+\n+  /**\n+   * Thread that refreshes the master end points until it is interrupted via {@link #close()}.\n+   * Multiple callers attempting to refresh at the same time synchronize on {@link #refreshMasters}.\n+   */\n+  private class RefreshThread implements Runnable {\n+    @Override\n+    public void run() {\n+      long lastRpcTs = 0;\n+      while (!Thread.interrupted()) {\n+        try {\n+          // Spurious wake ups are okay, worst case we make an extra RPC call to refresh. We won't\n+          // have duplicate refreshes because once the thread is past the wait(), notify()s are\n+          // ignored until the thread is back to the waiting state.\n+          synchronized (refreshMasters) {\n+            refreshMasters.wait(periodicRefreshMs);\n+          }\n+          long currentTs = EnvironmentEdgeManager.currentTime();\n+          if (lastRpcTs != 0 && currentTs - lastRpcTs <= timeBetweenRefreshesMs) {\n+            continue;\n+          }\n+          lastRpcTs = currentTs;\n+          LOG.debug(\"Attempting to refresh master address end points.\");\n+          Set<ServerName> newMasters = new HashSet<>(registry.getMasters().get());\n+          registry.populateMasterStubs(newMasters);\n+          LOG.debug(\"Finished refreshing master end points. {}\", newMasters);\n+        } catch (InterruptedException e) {\n+          LOG.debug(\"Interrupted during wait, aborting refresh-masters-thread.\", e);", "originalCommit": "6cd028727d93eb34df1f01080e9e01f39ecd3242", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTcxMzYzMA==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r475713630", "bodyText": "That also happens during a regular pool shutdown. Added another log later in the method after loop exist for observability.", "author": "bharathv", "createdAt": "2020-08-24T15:48:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTY2NzIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ0NDI0Nw==", "url": "https://github.com/apache/hbase/pull/2130#discussion_r475444247", "bodyText": "nit: return Collections.emptyList();", "author": "virajjasani", "createdAt": "2020-08-24T09:01:20Z", "path": "hbase-zookeeper/src/main/java/org/apache/hadoop/hbase/zookeeper/MasterAddressTracker.java", "diffHunk": "@@ -278,4 +282,59 @@ public static boolean deleteIfEquals(ZKWatcher zkw, final String content) {\n \n     return false;\n   }\n+\n+  public List<ServerName> getBackupMasters() throws InterruptedIOException {\n+    return getBackupMastersAndRenewWatch(watcher);\n+  }\n+\n+  /**\n+   * Retrieves the list of registered backup masters and renews a watch on the znode for children\n+   * updates.\n+   * @param zkw Zookeeper watcher to use\n+   * @return List of backup masters.\n+   * @throws InterruptedIOException\n+   */\n+  public static List<ServerName> getBackupMastersAndRenewWatch(\n+      ZKWatcher zkw) throws InterruptedIOException {\n+    // Build Set of backup masters from ZK nodes\n+    List<String> backupMasterStrings;\n+    try {\n+      backupMasterStrings = ZKUtil.listChildrenAndWatchForNewChildren(zkw,\n+          zkw.getZNodePaths().backupMasterAddressesZNode);\n+    } catch (KeeperException e) {\n+      LOG.warn(zkw.prefix(\"Unable to list backup servers\"), e);\n+      backupMasterStrings = null;", "originalCommit": "f0c146fe40c4b59d294971b8916aff2f724c6808", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "275a38e1533eafa1d4bd1d50c13bcecd9a397ea8", "url": "https://github.com/apache/hbase/commit/275a38e1533eafa1d4bd1d50c13bcecd9a397ea8", "message": "HBASE-24765: Dynamic master discovery\n\nThis patch adds the ability to discover newly added masters\ndynamically on the master registry side. The trigger for the\nre-fetch is either periodic (5 mins) or any registry RPC failure.\nMaster server information is cached in masters to avoid repeated\nZK lookups.\n\nUpdates the client side connection metrics to maintain a counter\nper RPC type so that clients have visibility into counts grouped\nby RPC method name.\n\nI didn't add the method to ZK registry interface since there\nis a design discussion going on in splittable meta doc. We can\nadd it later if needed.\n\nSigned-off-by: Nick Dimiduk <ndimiduk@apache.org>\nSigned-off-by: Viraj Jasani <vjasani@apache.org>\nSigned-off-by: Duo Zhang <zhangduo@apache.org>", "committedDate": "2020-08-25T14:22:11Z", "type": "commit"}, {"oid": "275a38e1533eafa1d4bd1d50c13bcecd9a397ea8", "url": "https://github.com/apache/hbase/commit/275a38e1533eafa1d4bd1d50c13bcecd9a397ea8", "message": "HBASE-24765: Dynamic master discovery\n\nThis patch adds the ability to discover newly added masters\ndynamically on the master registry side. The trigger for the\nre-fetch is either periodic (5 mins) or any registry RPC failure.\nMaster server information is cached in masters to avoid repeated\nZK lookups.\n\nUpdates the client side connection metrics to maintain a counter\nper RPC type so that clients have visibility into counts grouped\nby RPC method name.\n\nI didn't add the method to ZK registry interface since there\nis a design discussion going on in splittable meta doc. We can\nadd it later if needed.\n\nSigned-off-by: Nick Dimiduk <ndimiduk@apache.org>\nSigned-off-by: Viraj Jasani <vjasani@apache.org>\nSigned-off-by: Duo Zhang <zhangduo@apache.org>", "committedDate": "2020-08-25T14:22:11Z", "type": "forcePushed"}]}