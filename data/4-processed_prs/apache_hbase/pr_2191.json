{"pr_number": 2191, "pr_title": "HBASE-24813 ReplicationSource should clear buffer usage on Replicatio\u2026", "pr_createdAt": "2020-08-03T19:25:43Z", "pr_url": "https://github.com/apache/hbase/pull/2191", "timeline": [{"oid": "63b8e15ddc1b34bbbd1b4534c6d2a8ed4800eea5", "url": "https://github.com/apache/hbase/commit/63b8e15ddc1b34bbbd1b4534c6d2a8ed4800eea5", "message": "HBASE-24813 ReplicationSource should clear buffer usage on ReplicationSourceManager upon termination", "committedDate": "2020-08-03T19:23:05Z", "type": "commit"}, {"oid": "02ed4fa1ac87287d4bc1189650973f5b991914e8", "url": "https://github.com/apache/hbase/commit/02ed4fa1ac87287d4bc1189650973f5b991914e8", "message": "addressing checkstyles", "committedDate": "2020-08-04T09:01:43Z", "type": "commit"}, {"oid": "bba267c0bb3dc4e6019fe308ce23e1bb9e164a7e", "url": "https://github.com/apache/hbase/commit/bba267c0bb3dc4e6019fe308ce23e1bb9e164a7e", "message": "addressing TestReplicationSource checkstyle issues", "committedDate": "2020-08-05T14:07:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1MjAwNQ==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r468152005", "bodyText": "nit: we", "author": "joshelser", "createdAt": "2020-08-10T20:07:37Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java", "diffHunk": "@@ -600,6 +600,10 @@ public void terminate(String reason, Exception cause, boolean clearMetrics, bool\n         if (worker.entryReader.isAlive()) {\n           worker.entryReader.interrupt();\n         }\n+      } else {\n+        //If worker is already stopped but there was still entries batched,\n+        //wee need to clear buffer used for non processed entries", "originalCommit": "bba267c0bb3dc4e6019fe308ce23e1bb9e164a7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM5MTU4Mg==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r469391582", "bodyText": "oops...", "author": "wchevreuil", "createdAt": "2020-08-12T16:34:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1MjAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1MzcyMA==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r468153720", "bodyText": "Should this be atomic? Is there anything to prevent two racing threads: one calling this clearWALEntryBatch() method and another trying to normally consume the next WALEntryBatch?\nI think this could lead to a double-decrement.", "author": "joshelser", "createdAt": "2020-08-10T20:11:14Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSourceWALReader.java", "diffHunk": "@@ -309,6 +310,16 @@ public WALEntryBatch poll(long timeout) throws InterruptedException {\n     return entryBatchQueue.poll(timeout, TimeUnit.MILLISECONDS);\n   }\n \n+  public void clearWALEntryBatch() {", "originalCommit": "bba267c0bb3dc4e6019fe308ce23e1bb9e164a7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM4Mjc0Nw==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r469382747", "bodyText": "We are only calling it from ReplicationSource.terminate (see line #606), after we certify that neither the shipper, nor the reader threads are alive anymore, so I don't think it would be an issue. Of course, there's the risk someone inadvertently call this method somewhere else, so maybe we should put a warning comment? I don't think there's any gain of synchronising accesses to totalBufferUsed variable here, concurrent threads could still succeed on the double decrement, if we call clearWALEntryBatch while shipper thread is still running.", "author": "wchevreuil", "createdAt": "2020-08-12T16:20:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1MzcyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM5NDQ4Nw==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r469394487", "bodyText": "We are only calling it from ReplicationSource.terminate (see line #606), after we certify that neither the shipper, nor the reader threads are alive anymore\n\nActually, we could move that check to clearWALEntryBatch method itself, and since shipper has a reference to reader, but not the other way around, we can move it to shipper, instead? Let me give it a try.", "author": "wchevreuil", "createdAt": "2020-08-12T16:39:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1MzcyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM5NTYzOQ==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r469395639", "bodyText": "after we certify that neither the shipper, nor the reader threads are alive anymore, so I don't think it would be an issue. Of course, there's the risk someone inadvertently call this method somewhere else, so maybe we should put a warning comment?\n\nAlso OK to just put a warning if moving this check doesn't make things more clear :). Thanks for clarifying for me.", "author": "joshelser", "createdAt": "2020-08-12T16:41:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1MzcyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1ODQ5NQ==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r468158495", "bodyText": "What about summing the total size to decrement and then making the one call to totalBufferUsed? Guessing that might be micro-optimized faster.", "author": "joshelser", "createdAt": "2020-08-10T20:15:34Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSourceWALReader.java", "diffHunk": "@@ -309,6 +310,16 @@ public WALEntryBatch poll(long timeout) throws InterruptedException {\n     return entryBatchQueue.poll(timeout, TimeUnit.MILLISECONDS);\n   }\n \n+  public void clearWALEntryBatch() {\n+    entryBatchQueue.forEach(w -> {\n+      entryBatchQueue.remove(w);\n+      w.getWalEntries().forEach(e -> {", "originalCommit": "bba267c0bb3dc4e6019fe308ce23e1bb9e164a7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTM5MTc2MA==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r469391760", "bodyText": "Makes sense, coming soon...", "author": "wchevreuil", "createdAt": "2020-08-12T16:35:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE1ODQ5NQ=="}], "type": "inlineReview"}, {"oid": "6aee4d4df689e3c9f739d5bed9a524542aa3aa4b", "url": "https://github.com/apache/hbase/commit/6aee4d4df689e3c9f739d5bed9a524542aa3aa4b", "message": "addressing Josh latest suggestions", "committedDate": "2020-08-12T18:17:35Z", "type": "commit"}, {"oid": "75a872761c558f595a0a437fa6fd353c9effbdf0", "url": "https://github.com/apache/hbase/commit/75a872761c558f595a0a437fa6fd353c9effbdf0", "message": "Merge branch 'master' into HBASE-24813-master", "committedDate": "2020-08-13T09:38:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM3NDI3NQ==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r470374275", "bodyText": "We will not do this for the above condition branch?", "author": "Apache9", "createdAt": "2020-08-14T02:21:41Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java", "diffHunk": "@@ -650,6 +650,10 @@ public void terminate(String reason, Exception cause, boolean clearMetrics, bool\n         if (worker.entryReader.isAlive()) {\n           worker.entryReader.interrupt();\n         }\n+      } else {\n+        //If worker is already stopped but there was still entries batched,\n+        //we need to clear buffer used for non processed entries\n+        worker.clearWALEntryBatch();", "originalCommit": "75a872761c558f595a0a437fa6fd353c9effbdf0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDY4MTU3OQ==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r470681579", "bodyText": "We don't want to clear entry batch if shipper thread is still running, because it may race for the bufferUsage update. However, I realised we need to go through the branch first to interrupt it, got confused by an additional loop calling stopWorker prior to this one. I'm fixing this on a following commit.", "author": "wchevreuil", "createdAt": "2020-08-14T15:04:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM3NDI3NQ=="}], "type": "inlineReview"}, {"oid": "98096163507122c16721afe8e7d9964c8ed936ce", "url": "https://github.com/apache/hbase/commit/98096163507122c16721afe8e7d9964c8ed936ce", "message": "updated comment", "committedDate": "2020-08-14T16:09:10Z", "type": "commit"}, {"oid": "a48376ea943580a9026c3b78515e9165c26d6261", "url": "https://github.com/apache/hbase/commit/a48376ea943580a9026c3b78515e9165c26d6261", "message": "Addressing issue on terminate", "committedDate": "2020-08-14T16:22:40Z", "type": "commit"}, {"oid": "7b865d119dbac6c3929c71a0d108e18b8fa1d0dc", "url": "https://github.com/apache/hbase/commit/7b865d119dbac6c3929c71a0d108e18b8fa1d0dc", "message": "addressing checkstyle", "committedDate": "2020-08-25T10:39:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3NDgwMg==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r483374802", "bodyText": "we don't need the null check still?", "author": "busbey", "createdAt": "2020-09-04T04:11:19Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java", "diffHunk": "@@ -626,14 +626,10 @@ public void terminate(String reason, Exception cause, boolean clearMetrics, bool\n       Threads.shutdown(initThread, this.sleepForRetries);\n     }\n     Collection<ReplicationSourceShipper> workers = workerThreads.values();\n-    for (ReplicationSourceShipper worker : workers) {\n-      worker.stopWorker();\n-      if(worker.entryReader != null) {\n-        worker.entryReader.setReaderRunning(false);\n-      }\n-    }\n \n     for (ReplicationSourceShipper worker : workers) {\n+      worker.stopWorker();\n+      worker.entryReader.setReaderRunning(false);", "originalCommit": "7b865d119dbac6c3929c71a0d108e18b8fa1d0dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM1NDkxNw==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r484354917", "bodyText": "I can't think of a valid scenario when source would be running without setting an entry reader in the shipper, but let me bring back the null check, for safety. I originally removed it because I didn't think the check makes sense, as few lines below we are referring \"worker.entryReader.isAlive()\" directly.", "author": "wchevreuil", "createdAt": "2020-09-07T10:51:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3NDgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3NzE3Mw==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r483377173", "bodyText": "given that clearWALEntryBatch will wait for the worker to not be alive, why are we waiting for it here as well?", "author": "busbey", "createdAt": "2020-09-04T04:21:20Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java", "diffHunk": "@@ -651,6 +647,20 @@ public void terminate(String reason, Exception cause, boolean clearMetrics, bool\n           worker.entryReader.interrupt();\n         }\n       }\n+      //block this thread until worker thread is interrupted\n+      while(worker.isAlive()){\n+        try {\n+          // Wait worker to stop\n+          Thread.sleep(this.sleepForRetries);\n+        } catch (InterruptedException e) {\n+          LOG.info(\"{} Interrupted while waiting {} to stop\", logPeerId(), worker.getName());\n+          Thread.currentThread().interrupt();\n+        }\n+      }\n+      //If worker is already stopped but there was still entries batched,\n+      //we need to clear buffer used for non processed entries\n+      worker.clearWALEntryBatch();", "originalCommit": "7b865d119dbac6c3929c71a0d108e18b8fa1d0dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM2MDM5Mg==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r484360392", "bodyText": "Indeed, removing this block.", "author": "wchevreuil", "createdAt": "2020-09-07T11:02:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3NzE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3NzUyOQ==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r483377529", "bodyText": "should we have a timeout here? or is there a timeout above us that will interrupt if we take too long?", "author": "busbey", "createdAt": "2020-09-04T04:22:48Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSourceShipper.java", "diffHunk": "@@ -324,4 +326,39 @@ void stopWorker() {\n   public boolean isFinished() {\n     return state == WorkerState.FINISHED;\n   }\n+\n+  /**\n+   * Attempts to properly update <code>ReplicationSourceManager.totalBufferUser</code>,\n+   * in case there were unprocessed entries batched by the reader to the shipper,\n+   * but the shipper didn't manage to ship those because the replication source is being terminated.\n+   * In that case, it iterates through the batched entries and decrease the pending\n+   * entries size from <code>ReplicationSourceManager.totalBufferUser</code>\n+   * <p/>\n+   * <b>NOTE</b> This method should be only called upon replication source termination.\n+   * It blocks waiting for both shipper and reader threads termination,\n+   * to make sure no race conditions\n+   * when updating <code>ReplicationSourceManager.totalBufferUser</code>.\n+   */\n+  void clearWALEntryBatch() {\n+    while(this.isAlive() || this.entryReader.isAlive()){\n+      try {\n+        // Wait both shipper and reader threads to stop\n+        Thread.sleep(this.sleepForRetries);\n+      } catch (InterruptedException e) {\n+        LOG.info(\"{} Interrupted while waiting {} to stop on clearWALEntryBatch\",\n+          this.source.getPeerId(), this.getName());\n+        Thread.currentThread().interrupt();\n+      }\n+    }", "originalCommit": "7b865d119dbac6c3929c71a0d108e18b8fa1d0dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM4MzU2MA==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r484383560", "bodyText": "That's a good point, we don't timeout these locks anywhere, AFICS. Let me put one here.", "author": "wchevreuil", "createdAt": "2020-09-07T11:51:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3NzUyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3ODIyOA==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r483378228", "bodyText": "expressly note that both the worker and the entry reader should have already been interrupted because we're not doing it here.", "author": "busbey", "createdAt": "2020-09-04T04:25:41Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSourceShipper.java", "diffHunk": "@@ -324,4 +326,39 @@ void stopWorker() {\n   public boolean isFinished() {\n     return state == WorkerState.FINISHED;\n   }\n+\n+  /**\n+   * Attempts to properly update <code>ReplicationSourceManager.totalBufferUser</code>,\n+   * in case there were unprocessed entries batched by the reader to the shipper,\n+   * but the shipper didn't manage to ship those because the replication source is being terminated.\n+   * In that case, it iterates through the batched entries and decrease the pending\n+   * entries size from <code>ReplicationSourceManager.totalBufferUser</code>\n+   * <p/>\n+   * <b>NOTE</b> This method should be only called upon replication source termination.\n+   * It blocks waiting for both shipper and reader threads termination,\n+   * to make sure no race conditions\n+   * when updating <code>ReplicationSourceManager.totalBufferUser</code>.", "originalCommit": "7b865d119dbac6c3929c71a0d108e18b8fa1d0dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM2Mjg4Mw==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r484362883", "bodyText": "Ack.", "author": "wchevreuil", "createdAt": "2020-09-07T11:07:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3ODIyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3ODYyOA==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r483378628", "bodyText": "is info the right level here? maybe it is? but if we get interrupted that means we could go to do the update below in a racy way with the other threads right?", "author": "busbey", "createdAt": "2020-09-04T04:27:31Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSourceShipper.java", "diffHunk": "@@ -324,4 +326,39 @@ void stopWorker() {\n   public boolean isFinished() {\n     return state == WorkerState.FINISHED;\n   }\n+\n+  /**\n+   * Attempts to properly update <code>ReplicationSourceManager.totalBufferUser</code>,\n+   * in case there were unprocessed entries batched by the reader to the shipper,\n+   * but the shipper didn't manage to ship those because the replication source is being terminated.\n+   * In that case, it iterates through the batched entries and decrease the pending\n+   * entries size from <code>ReplicationSourceManager.totalBufferUser</code>\n+   * <p/>\n+   * <b>NOTE</b> This method should be only called upon replication source termination.\n+   * It blocks waiting for both shipper and reader threads termination,\n+   * to make sure no race conditions\n+   * when updating <code>ReplicationSourceManager.totalBufferUser</code>.\n+   */\n+  void clearWALEntryBatch() {\n+    while(this.isAlive() || this.entryReader.isAlive()){\n+      try {\n+        // Wait both shipper and reader threads to stop\n+        Thread.sleep(this.sleepForRetries);\n+      } catch (InterruptedException e) {\n+        LOG.info(\"{} Interrupted while waiting {} to stop on clearWALEntryBatch\",", "originalCommit": "7b865d119dbac6c3929c71a0d108e18b8fa1d0dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDM3MDg3NQ==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r484370875", "bodyText": "is info the right level here? maybe it is?\n\nWe should probably raise it to a warn here, because that meant the source termination didn't complete properly and we might not have \"cleared\" this source pending entries size from source manager buffer.\n\nbut if we get interrupted that means we could go to do the update below in a racy way with the other threads right?\n\nI don't think it would be the case. We may have multiple shippers for a source, but we access this method in the isolated context of the source thread. On the case we are terminating multiple sources (due to recovered queues or multiple peers), we are still calculating entries size to be decreased in the context of each source thread.", "author": "wchevreuil", "createdAt": "2020-09-07T11:24:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzM3ODYyOA=="}], "type": "inlineReview"}, {"oid": "75c3915f964d1a8f1bde4981354f7924ba92c7c7", "url": "https://github.com/apache/hbase/commit/75c3915f964d1a8f1bde4981354f7924ba92c7c7", "message": "addressing Busbey review comments", "committedDate": "2020-09-07T12:26:20Z", "type": "commit"}, {"oid": "2a61bccffc8dfc4d33701d53f38cb8ba993ff9b3", "url": "https://github.com/apache/hbase/commit/2a61bccffc8dfc4d33701d53f38cb8ba993ff9b3", "message": "addressing checkstyles", "committedDate": "2020-09-09T15:21:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzExMTI1MA==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r487111250", "bodyText": "Semantics of this have changed, but I'm not seeing conversation that indicates that it was intentional.\nBefore: we would stop all workers, then wait for them all to be stopped. Each worker could stop itself concurrently. Now, for each worker, we request a stop and then wait for it to be stopped, then move on to the next worker.\nI don't think this is a big deal, but wanted to call it out.", "author": "joshelser", "createdAt": "2020-09-11T15:11:06Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSource.java", "diffHunk": "@@ -626,14 +626,12 @@ public void terminate(String reason, Exception cause, boolean clearMetrics, bool\n       Threads.shutdown(initThread, this.sleepForRetries);\n     }\n     Collection<ReplicationSourceShipper> workers = workerThreads.values();\n+\n     for (ReplicationSourceShipper worker : workers) {\n       worker.stopWorker();\n-      if(worker.entryReader != null) {\n+      if (worker.entryReader != null) {\n         worker.entryReader.setReaderRunning(false);\n       }\n-    }\n-\n-    for (ReplicationSourceShipper worker : workers) {", "originalCommit": "2a61bccffc8dfc4d33701d53f38cb8ba993ff9b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODUzOTcyNQ==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r488539725", "bodyText": "Sorry for not explaining this before. Yeah, just thought there was not real gains on doing two iterations, as at the end, we would need to make sure all workers were indeed stopped. I can revert it back, if you perfer.", "author": "wchevreuil", "createdAt": "2020-09-15T09:55:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzExMTI1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1NzUwOA==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r493857508", "bodyText": "Nope, all good.", "author": "joshelser", "createdAt": "2020-09-23T19:55:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzExMTI1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzExMjUzMg==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r487112532", "bodyText": "Could just break instead of interrupting this thread.", "author": "joshelser", "createdAt": "2020-09-11T15:13:09Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSourceShipper.java", "diffHunk": "@@ -324,4 +326,51 @@ void stopWorker() {\n   public boolean isFinished() {\n     return state == WorkerState.FINISHED;\n   }\n+\n+  /**\n+   * Attempts to properly update <code>ReplicationSourceManager.totalBufferUser</code>,\n+   * in case there were unprocessed entries batched by the reader to the shipper,\n+   * but the shipper didn't manage to ship those because the replication source is being terminated.\n+   * In that case, it iterates through the batched entries and decrease the pending\n+   * entries size from <code>ReplicationSourceManager.totalBufferUser</code>\n+   * <p/>\n+   * <b>NOTES</b>\n+   * 1) This method should only be called upon replication source termination.\n+   * It blocks waiting for both shipper and reader threads termination,\n+   * to make sure no race conditions\n+   * when updating <code>ReplicationSourceManager.totalBufferUser</code>.\n+   *\n+   * 2) It <b>does not</b> attempt to terminate reader and shipper threads. Those <b>must</b>\n+   * have been triggered interruption/termination prior to calling this method.\n+   */\n+  void clearWALEntryBatch() {\n+    long timeout = System.currentTimeMillis() + this.shipEditsTimeout;\n+    while(this.isAlive() || this.entryReader.isAlive()){\n+      try {\n+        if (System.currentTimeMillis() >= timeout) {\n+          LOG.warn(\"Interrupting source thread for peer {} without cleaning buffer usage \"\n+            + \"because clearWALEntryBatch method timed out whilst waiting reader/shipper \"\n+            + \"thread to stop.\", this.source.getPeerId());\n+          Thread.currentThread().interrupt();", "originalCommit": "2a61bccffc8dfc4d33701d53f38cb8ba993ff9b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODU0MDUyNg==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r488540526", "bodyText": "So, thought about following the exceptional scenarios approach already implemented in ReplicationSource, where the source thread is interrupted.", "author": "wchevreuil", "createdAt": "2020-09-15T09:56:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzExMjUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzg1OTAwMg==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r493859002", "bodyText": "Ah, so propagating the interrupt state is important, outside of this method. If you took my suggestion, we'd just be duplicating the catch block, so this is probably fine as-is.", "author": "joshelser", "createdAt": "2020-09-23T19:57:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzExMjUzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzExMzU5Ng==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r487113596", "bodyText": "Thanks for updating the decrement logic.\nMaybe a TRACE log message to indicate the amount of buffer reclaimed as a part of shutting down. Sounds like that might be helpful in the future. e.g.\nLOG.trace(\"Decrementing totalBufferUsed by {}B while stopping Replication WAL Readers\", totalToDecrement.longValue())", "author": "joshelser", "createdAt": "2020-09-11T15:14:58Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSourceShipper.java", "diffHunk": "@@ -324,4 +326,51 @@ void stopWorker() {\n   public boolean isFinished() {\n     return state == WorkerState.FINISHED;\n   }\n+\n+  /**\n+   * Attempts to properly update <code>ReplicationSourceManager.totalBufferUser</code>,\n+   * in case there were unprocessed entries batched by the reader to the shipper,\n+   * but the shipper didn't manage to ship those because the replication source is being terminated.\n+   * In that case, it iterates through the batched entries and decrease the pending\n+   * entries size from <code>ReplicationSourceManager.totalBufferUser</code>\n+   * <p/>\n+   * <b>NOTES</b>\n+   * 1) This method should only be called upon replication source termination.\n+   * It blocks waiting for both shipper and reader threads termination,\n+   * to make sure no race conditions\n+   * when updating <code>ReplicationSourceManager.totalBufferUser</code>.\n+   *\n+   * 2) It <b>does not</b> attempt to terminate reader and shipper threads. Those <b>must</b>\n+   * have been triggered interruption/termination prior to calling this method.\n+   */\n+  void clearWALEntryBatch() {\n+    long timeout = System.currentTimeMillis() + this.shipEditsTimeout;\n+    while(this.isAlive() || this.entryReader.isAlive()){\n+      try {\n+        if (System.currentTimeMillis() >= timeout) {\n+          LOG.warn(\"Interrupting source thread for peer {} without cleaning buffer usage \"\n+            + \"because clearWALEntryBatch method timed out whilst waiting reader/shipper \"\n+            + \"thread to stop.\", this.source.getPeerId());\n+          Thread.currentThread().interrupt();\n+        } else {\n+          // Wait both shipper and reader threads to stop\n+          Thread.sleep(this.sleepForRetries);\n+        }\n+      } catch (InterruptedException e) {\n+        LOG.warn(\"{} Interrupted while waiting {} to stop on clearWALEntryBatch: {}\",\n+          this.source.getPeerId(), this.getName(), e);\n+        Thread.currentThread().interrupt();\n+      }\n+    }\n+    LongAccumulator totalToDecrement = new LongAccumulator((a,b) -> a + b, 0);\n+    entryReader.entryBatchQueue.forEach(w -> {\n+      entryReader.entryBatchQueue.remove(w);\n+      w.getWalEntries().forEach(e -> {\n+        long entrySizeExcludeBulkLoad = entryReader.getEntrySizeExcludeBulkLoad(e);\n+        totalToDecrement.accumulate(entrySizeExcludeBulkLoad);\n+      });\n+    });\n+\n+    source.getSourceManager().getTotalBufferUsed().addAndGet(-totalToDecrement.longValue());", "originalCommit": "2a61bccffc8dfc4d33701d53f38cb8ba993ff9b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODU0MzA1Mw==", "url": "https://github.com/apache/hbase/pull/2191#discussion_r488543053", "bodyText": "Good idea, added in the last commit.", "author": "wchevreuil", "createdAt": "2020-09-15T10:00:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzExMzU5Ng=="}], "type": "inlineReview"}, {"oid": "8dca0ef06ff5145640754257b720d499eebfde58", "url": "https://github.com/apache/hbase/commit/8dca0ef06ff5145640754257b720d499eebfde58", "message": "adding extra TRACE message", "committedDate": "2020-09-15T09:59:49Z", "type": "commit"}]}