{"pr_number": 1784, "pr_title": "HBASE-24428 : Update compaction priority for recently split daughter \u2026", "pr_createdAt": "2020-05-26T17:17:34Z", "pr_url": "https://github.com/apache/hbase/pull/1784", "timeline": [{"oid": "c98aa8026b2a919b171f1358d17fd3060a619877", "url": "https://github.com/apache/hbase/commit/c98aa8026b2a919b171f1358d17fd3060a619877", "message": "HBASE-24428 : Update compaction priority for recently split daughter regions", "committedDate": "2020-05-26T17:15:13Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxMzEzNA==", "url": "https://github.com/apache/hbase/pull/1784#discussion_r430713134", "bodyText": "Or should we define a new constant for high priority splits that is not quite MIN_VALUE, so someone can still schedule something ahead of us? idk, like MIN_VALUE+1000.", "author": "apurtell", "createdAt": "2020-05-26T21:17:36Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HStore.java", "diffHunk": "@@ -1921,9 +1921,15 @@ public boolean shouldPerformMajorCompaction() throws IOException {\n         // If we're enqueuing a major, clear the force flag.\n         this.forceMajor = this.forceMajor && !request.isMajor();\n \n-        // Set common request properties.\n-        // Set priority, either override value supplied by caller or from store.\n-        request.setPriority((priority != Store.NO_PRIORITY) ? priority : getCompactPriority());\n+        if (request.isAfterSplit()) {\n+          // If the store belongs to recently splitted daughter regions, better we consider\n+          // them with the highest priority in the compaction queue.\n+          request.setPriority(Integer.MIN_VALUE);", "originalCommit": "c98aa8026b2a919b171f1358d17fd3060a619877", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwMDUzNQ==", "url": "https://github.com/apache/hbase/pull/1784#discussion_r430900535", "bodyText": "Yeah, MIN_VALUE+1000 (or 5000) should be able to provide more than enough room for tasks that can emerge as even higher priority than split housekeeping in future.", "author": "virajjasani", "createdAt": "2020-05-27T07:07:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxMzEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNTMyNw==", "url": "https://github.com/apache/hbase/pull/1784#discussion_r430715327", "bodyText": "Hmm. I suppose this is fine. We already have request#isMajor to inform us if we need to schedule a major compaction.\nrequest#isSplit is just as informative as request#isAfterSplit, but no strong opinion there.", "author": "apurtell", "createdAt": "2020-05-26T21:22:11Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HStore.java", "diffHunk": "@@ -1921,9 +1921,15 @@ public boolean shouldPerformMajorCompaction() throws IOException {\n         // If we're enqueuing a major, clear the force flag.\n         this.forceMajor = this.forceMajor && !request.isMajor();\n \n-        // Set common request properties.\n-        // Set priority, either override value supplied by caller or from store.\n-        request.setPriority((priority != Store.NO_PRIORITY) ? priority : getCompactPriority());\n+        if (request.isAfterSplit()) {", "originalCommit": "c98aa8026b2a919b171f1358d17fd3060a619877", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNTkzOQ==", "url": "https://github.com/apache/hbase/pull/1784#discussion_r430715939", "bodyText": "We should log when we are overriding request priority with the reason why, at DEBUG level at least, but INFO makes sense too.", "author": "apurtell", "createdAt": "2020-05-26T21:23:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNTMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxODMwNQ==", "url": "https://github.com/apache/hbase/pull/1784#discussion_r430718305", "bodyText": "Oh, if you accept my above suggestion wrt a constant value for split housekeeping that is not quite MIN_VALUE then we should not override priority if it is already equal to or less than what we need.", "author": "apurtell", "createdAt": "2020-05-26T21:28:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNTMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5OTQ3OA==", "url": "https://github.com/apache/hbase/pull/1784#discussion_r430899478", "bodyText": "Agree, we should override priority only if it is higher than constant (MIN_VALUE + 1000).", "author": "virajjasani", "createdAt": "2020-05-27T07:05:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNTMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAyNzg5Ng==", "url": "https://github.com/apache/hbase/pull/1784#discussion_r431027896", "bodyText": "@virajjasani  One Q.\nRather than handling at this layer by checking whether the call is after a split or not,  can we set a higher priority on the compact request, created after the split op?  So then we dont need to set with these split status etc and handle specially at this layer.", "author": "anoopsjohn", "createdAt": "2020-05-27T10:49:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNTMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTA1NDEyNQ==", "url": "https://github.com/apache/hbase/pull/1784#discussion_r431054125", "bodyText": "There are 2 reasons:\n\nisAfterSplit is an additional field which could be useful for maybe some other purpose also (in future).\nWe already have logic to determine priority at this layer only: request.setPriority((priority != Store.NO_PRIORITY) ? priority : getCompactPriority());. Nowhere other than this place, are we using priority setter request.setPriority(int p). So this will provide better alignment and also avoid setting priority in multiple places: SortedCompactionPolicy, StripeCompactionPolicy, HStore.", "author": "virajjasani", "createdAt": "2020-05-27T11:43:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNTMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNjgwNQ==", "url": "https://github.com/apache/hbase/pull/1784#discussion_r430716805", "bodyText": "This pattern is not one I've seen before but we do it above for isOffPeak so (shrug).", "author": "apurtell", "createdAt": "2020-05-26T21:25:20Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/compactions/CompactionRequestImpl.java", "diffHunk": "@@ -149,6 +158,7 @@ public int hashCode() {\n     result = prime * result + ((storeName == null) ? 0 : storeName.hashCode());\n     result = prime * result + (int) (totalSize ^ (totalSize >>> 32));\n     result = prime * result + ((tracker == null) ? 0 : tracker.hashCode());\n+    result = prime * result + (isAfterSplit ? 1231 : 1237);", "originalCommit": "c98aa8026b2a919b171f1358d17fd3060a619877", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDkwMjIzMQ==", "url": "https://github.com/apache/hbase/pull/1784#discussion_r430902231", "bodyText": "Yeah right, I exactly looked for an existing boolean and applied same formula rather than regenerating hashcode() by IDE :)", "author": "virajjasani", "createdAt": "2020-05-27T07:11:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDcxNjgwNQ=="}], "type": "inlineReview"}, {"oid": "799f0074b91c9c7dba2d4f353923bdd90c0150a9", "url": "https://github.com/apache/hbase/commit/799f0074b91c9c7dba2d4f353923bdd90c0150a9", "message": "addressing review comments", "committedDate": "2020-05-27T10:21:30Z", "type": "commit"}, {"oid": "fda8e24f1d1e1cbdb271778fb3325ce39c47317a", "url": "https://github.com/apache/hbase/commit/fda8e24f1d1e1cbdb271778fb3325ce39c47317a", "message": "small comment", "committedDate": "2020-05-27T15:18:20Z", "type": "commit"}]}