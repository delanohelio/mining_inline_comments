{"pr_number": 2665, "pr_title": "HBASE-25291 Document how to enable the meta replica load balance mode\u2026", "pr_createdAt": "2020-11-16T23:16:09Z", "pr_url": "https://github.com/apache/hbase/pull/2665", "timeline": [{"oid": "95b460d79052cbaeb3b5caed6f0e7b96bdfbca19", "url": "https://github.com/apache/hbase/commit/95b460d79052cbaeb3b5caed6f0e7b96bdfbca19", "message": "HBASE-25291 Document how to enable the meta replica load balance mode for the client and clean up around hbase:meta read replicas\n\nhbase-client/src/main/java/org/apache/hadoop/hbase/client/CatalogReplicaLoadBalanceSelector.java\nhbase-client/src/main/java/org/apache/hadoop/hbase/client/CatalogReplicaLoadBalanceSelectorFactory.java\nhbase-client/src/main/java/org/apache/hadoop/hbase/client/CatalogReplicaLoadBalanceSimpleSelector.java\nhbase-client/src/main/java/org/apache/hadoop/hbase/client/CatalogReplicaMode.java\n Make the leading license comment opener align on all these new\n files.... one star rather than two.\n\nhbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/CatalogReplicationSource.java\n Add some comment better situating the catalogreplicationsource\n specialization.\n\nhbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSourceManager.java\n Add comment how this differs from replicationsource factory and why no\n need to keep offset up in zk.\n\nsrc/main/asciidoc/_chapters/architecture.adoc\n Clean up the read replica of META doc. Introduce the new read replica\n liveness on META and the new 'LoadBalance' feature (with warnings).\n General edit.", "committedDate": "2020-11-16T23:52:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc2NTgwMA==", "url": "https://github.com/apache/hbase/pull/2665#discussion_r524765800", "bodyText": "nit: mind adding some line breaks at <100 chars?", "author": "ndimiduk", "createdAt": "2020-11-16T23:46:09Z", "path": "src/main/asciidoc/_chapters/architecture.adoc", "diffHunk": "@@ -2865,26 +2865,51 @@ The first mechanism is store file refresher which is introduced in HBase-1.0+. S\n \n For turning this feature on, you should configure `hbase.regionserver.storefile.refresh.period` to a non-zero value. See Configuration section below.\n \n-==== Asnyc WAL replication\n-The second mechanism for propagation of writes to secondaries is done via \u201cAsync WAL Replication\u201d feature and is only available in HBase-1.1+. This works similarly to HBase\u2019s multi-datacenter replication, but instead the data from a region is replicated to the secondary regions. Each secondary replica always receives and observes the writes in the same order that the primary region committed them. In some sense, this design can be thought of as \u201cin-cluster replication\u201d, where instead of replicating to a different datacenter, the data goes to secondary regions to keep secondary region\u2019s in-memory state up to date. The data files are shared between the primary region and the other replicas, so that there is no extra storage overhead. However, the secondary regions will have recent non-flushed data in their memstores, which increases the memory overhead. The primary region writes flush, compaction, and bulk load events to its WAL as well, which are also replicated through wal replication to secondaries. When they observe the flush/compaction or bulk load event, the secondary regions replay the event to pick up the new files and drop the old ones.\n+[[async.wal.replication]]\n+==== Async WAL replication\n+The second mechanism for propagation of writes to secondaries is done via the \u201cAsync WAL Replication\u201d feature. It is only available in HBase-1.1+. This works similarly to HBase\u2019s multi-datacenter replication, but instead the data from a region is replicated to the secondary regions. Each secondary replica always receives and observes the writes in the same order that the primary region committed them. In some sense, this design can be thought of as \u201cin-cluster replication\u201d, where instead of replicating to a different datacenter, the data goes to secondary regions to keep secondary region\u2019s in-memory state up to date. The data files are shared between the primary region and the other replicas, so that there is no extra storage overhead. However, the secondary regions will have recent non-flushed data in their memstores, which increases the memory overhead. The primary region writes flush, compaction, and bulk load events to its WAL as well, which are also replicated through wal replication to secondaries. When they observe the flush/compaction or bulk load event, the secondary regions replay the event to pick up the new files and drop the old ones.", "originalCommit": "55c9df02fc0c411c99229fbd794ab12d6e08132e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc5NDA1OA==", "url": "https://github.com/apache/hbase/pull/2665#discussion_r524794058", "bodyText": "Added CRs for paragraphs I touched. Makes the patch bigger if that is ok.", "author": "saintstack", "createdAt": "2020-11-17T00:14:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc2NTgwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc2Njc3MQ==", "url": "https://github.com/apache/hbase/pull/2665#discussion_r524766771", "bodyText": "s/createa/create a/", "author": "ndimiduk", "createdAt": "2020-11-16T23:47:01Z", "path": "src/main/asciidoc/_chapters/architecture.adoc", "diffHunk": "@@ -2865,26 +2865,51 @@ The first mechanism is store file refresher which is introduced in HBase-1.0+. S\n \n For turning this feature on, you should configure `hbase.regionserver.storefile.refresh.period` to a non-zero value. See Configuration section below.\n \n-==== Asnyc WAL replication\n-The second mechanism for propagation of writes to secondaries is done via \u201cAsync WAL Replication\u201d feature and is only available in HBase-1.1+. This works similarly to HBase\u2019s multi-datacenter replication, but instead the data from a region is replicated to the secondary regions. Each secondary replica always receives and observes the writes in the same order that the primary region committed them. In some sense, this design can be thought of as \u201cin-cluster replication\u201d, where instead of replicating to a different datacenter, the data goes to secondary regions to keep secondary region\u2019s in-memory state up to date. The data files are shared between the primary region and the other replicas, so that there is no extra storage overhead. However, the secondary regions will have recent non-flushed data in their memstores, which increases the memory overhead. The primary region writes flush, compaction, and bulk load events to its WAL as well, which are also replicated through wal replication to secondaries. When they observe the flush/compaction or bulk load event, the secondary regions replay the event to pick up the new files and drop the old ones.\n+[[async.wal.replication]]\n+==== Async WAL replication\n+The second mechanism for propagation of writes to secondaries is done via the \u201cAsync WAL Replication\u201d feature. It is only available in HBase-1.1+. This works similarly to HBase\u2019s multi-datacenter replication, but instead the data from a region is replicated to the secondary regions. Each secondary replica always receives and observes the writes in the same order that the primary region committed them. In some sense, this design can be thought of as \u201cin-cluster replication\u201d, where instead of replicating to a different datacenter, the data goes to secondary regions to keep secondary region\u2019s in-memory state up to date. The data files are shared between the primary region and the other replicas, so that there is no extra storage overhead. However, the secondary regions will have recent non-flushed data in their memstores, which increases the memory overhead. The primary region writes flush, compaction, and bulk load events to its WAL as well, which are also replicated through wal replication to secondaries. When they observe the flush/compaction or bulk load event, the secondary regions replay the event to pick up the new files and drop the old ones.\n \n Committing writes in the same order as in primary ensures that the secondaries won\u2019t diverge from the primary regions data, but since the log replication is asynchronous, the data might still be stale in secondary regions. Since this feature works as a replication endpoint, the performance and latency characteristics is expected to be similar to inter-cluster replication.\n \n Async WAL Replication is *disabled* by default. You can enable this feature by setting `hbase.region.replica.replication.enabled` to `true`.\n-Asyn WAL Replication feature will add a new replication peer named `region_replica_replication` as a replication peer when you create a table with region replication > 1 for the first time. Once enabled, if you want to disable this feature, you need to do two actions:\n+The Async WAL Replication feature will add a new replication peer named `region_replica_replication` as a replication peer when you createa table with region replication > 1 for the first time. Once enabled, if you want to disable this feature, you need to do two actions:", "originalCommit": "55c9df02fc0c411c99229fbd794ab12d6e08132e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc2NzY1NQ==", "url": "https://github.com/apache/hbase/pull/2665#discussion_r524767655", "bodyText": "These two actions must be performed in the order specified here? or is it okay to perform them in the opposite order?", "author": "ndimiduk", "createdAt": "2020-11-16T23:47:55Z", "path": "src/main/asciidoc/_chapters/architecture.adoc", "diffHunk": "@@ -2865,26 +2865,51 @@ The first mechanism is store file refresher which is introduced in HBase-1.0+. S\n \n For turning this feature on, you should configure `hbase.regionserver.storefile.refresh.period` to a non-zero value. See Configuration section below.\n \n-==== Asnyc WAL replication\n-The second mechanism for propagation of writes to secondaries is done via \u201cAsync WAL Replication\u201d feature and is only available in HBase-1.1+. This works similarly to HBase\u2019s multi-datacenter replication, but instead the data from a region is replicated to the secondary regions. Each secondary replica always receives and observes the writes in the same order that the primary region committed them. In some sense, this design can be thought of as \u201cin-cluster replication\u201d, where instead of replicating to a different datacenter, the data goes to secondary regions to keep secondary region\u2019s in-memory state up to date. The data files are shared between the primary region and the other replicas, so that there is no extra storage overhead. However, the secondary regions will have recent non-flushed data in their memstores, which increases the memory overhead. The primary region writes flush, compaction, and bulk load events to its WAL as well, which are also replicated through wal replication to secondaries. When they observe the flush/compaction or bulk load event, the secondary regions replay the event to pick up the new files and drop the old ones.\n+[[async.wal.replication]]\n+==== Async WAL replication\n+The second mechanism for propagation of writes to secondaries is done via the \u201cAsync WAL Replication\u201d feature. It is only available in HBase-1.1+. This works similarly to HBase\u2019s multi-datacenter replication, but instead the data from a region is replicated to the secondary regions. Each secondary replica always receives and observes the writes in the same order that the primary region committed them. In some sense, this design can be thought of as \u201cin-cluster replication\u201d, where instead of replicating to a different datacenter, the data goes to secondary regions to keep secondary region\u2019s in-memory state up to date. The data files are shared between the primary region and the other replicas, so that there is no extra storage overhead. However, the secondary regions will have recent non-flushed data in their memstores, which increases the memory overhead. The primary region writes flush, compaction, and bulk load events to its WAL as well, which are also replicated through wal replication to secondaries. When they observe the flush/compaction or bulk load event, the secondary regions replay the event to pick up the new files and drop the old ones.\n \n Committing writes in the same order as in primary ensures that the secondaries won\u2019t diverge from the primary regions data, but since the log replication is asynchronous, the data might still be stale in secondary regions. Since this feature works as a replication endpoint, the performance and latency characteristics is expected to be similar to inter-cluster replication.\n \n Async WAL Replication is *disabled* by default. You can enable this feature by setting `hbase.region.replica.replication.enabled` to `true`.\n-Asyn WAL Replication feature will add a new replication peer named `region_replica_replication` as a replication peer when you create a table with region replication > 1 for the first time. Once enabled, if you want to disable this feature, you need to do two actions:\n+The Async WAL Replication feature will add a new replication peer named `region_replica_replication` as a replication peer when you createa table with region replication > 1 for the first time. Once enabled, if you want to disable this feature, you need to do two actions:", "originalCommit": "55c9df02fc0c411c99229fbd794ab12d6e08132e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc5MzUxOA==", "url": "https://github.com/apache/hbase/pull/2665#discussion_r524793518", "bodyText": "I specified the order documented here (before my time).", "author": "saintstack", "createdAt": "2020-11-17T00:13:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc2NzY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc2OTY1MQ==", "url": "https://github.com/apache/hbase/pull/2665#discussion_r524769651", "bodyText": "Instead of going back and forth with instructions for < 2.4.0 and 2.4.0+, please write two sections, one for < 2.4.0 and the other for 2.4.0+. The words might be 80% duplicated, but it makes it crystal clear, what's applicable to which versions.", "author": "ndimiduk", "createdAt": "2020-11-16T23:49:57Z", "path": "src/main/asciidoc/_chapters/architecture.adoc", "diffHunk": "@@ -2865,26 +2865,51 @@ The first mechanism is store file refresher which is introduced in HBase-1.0+. S\n \n For turning this feature on, you should configure `hbase.regionserver.storefile.refresh.period` to a non-zero value. See Configuration section below.\n \n-==== Asnyc WAL replication\n-The second mechanism for propagation of writes to secondaries is done via \u201cAsync WAL Replication\u201d feature and is only available in HBase-1.1+. This works similarly to HBase\u2019s multi-datacenter replication, but instead the data from a region is replicated to the secondary regions. Each secondary replica always receives and observes the writes in the same order that the primary region committed them. In some sense, this design can be thought of as \u201cin-cluster replication\u201d, where instead of replicating to a different datacenter, the data goes to secondary regions to keep secondary region\u2019s in-memory state up to date. The data files are shared between the primary region and the other replicas, so that there is no extra storage overhead. However, the secondary regions will have recent non-flushed data in their memstores, which increases the memory overhead. The primary region writes flush, compaction, and bulk load events to its WAL as well, which are also replicated through wal replication to secondaries. When they observe the flush/compaction or bulk load event, the secondary regions replay the event to pick up the new files and drop the old ones.\n+[[async.wal.replication]]\n+==== Async WAL replication\n+The second mechanism for propagation of writes to secondaries is done via the \u201cAsync WAL Replication\u201d feature. It is only available in HBase-1.1+. This works similarly to HBase\u2019s multi-datacenter replication, but instead the data from a region is replicated to the secondary regions. Each secondary replica always receives and observes the writes in the same order that the primary region committed them. In some sense, this design can be thought of as \u201cin-cluster replication\u201d, where instead of replicating to a different datacenter, the data goes to secondary regions to keep secondary region\u2019s in-memory state up to date. The data files are shared between the primary region and the other replicas, so that there is no extra storage overhead. However, the secondary regions will have recent non-flushed data in their memstores, which increases the memory overhead. The primary region writes flush, compaction, and bulk load events to its WAL as well, which are also replicated through wal replication to secondaries. When they observe the flush/compaction or bulk load event, the secondary regions replay the event to pick up the new files and drop the old ones.\n \n Committing writes in the same order as in primary ensures that the secondaries won\u2019t diverge from the primary regions data, but since the log replication is asynchronous, the data might still be stale in secondary regions. Since this feature works as a replication endpoint, the performance and latency characteristics is expected to be similar to inter-cluster replication.\n \n Async WAL Replication is *disabled* by default. You can enable this feature by setting `hbase.region.replica.replication.enabled` to `true`.\n-Asyn WAL Replication feature will add a new replication peer named `region_replica_replication` as a replication peer when you create a table with region replication > 1 for the first time. Once enabled, if you want to disable this feature, you need to do two actions:\n+The Async WAL Replication feature will add a new replication peer named `region_replica_replication` as a replication peer when you createa table with region replication > 1 for the first time. Once enabled, if you want to disable this feature, you need to do two actions:\n * Set configuration property `hbase.region.replica.replication.enabled` to false in `hbase-site.xml` (see Configuration section below)\n * Disable the replication peer named `region_replica_replication` in the cluster using hbase shell or `Admin` class:\n [source,bourne]\n ----\n \thbase> disable_peer 'region_replica_replication'\n ----\n \n+Async WAL Replication and the `hbase:meta` table is a little more involved and gets its own section below; see <<async.wal.replication.meta>>\n+\n === Store File TTL\n In both of the write propagation approaches mentioned above, store files of the primary will be opened in secondaries independent of the primary region. So for files that the primary compacted away, the secondaries might still be referring to these files for reading. Both features are using HFileLinks to refer to files, but there is no protection (yet) for guaranteeing that the file will not be deleted prematurely. Thus, as a guard, you should set the configuration property `hbase.master.hfilecleaner.ttl` to a larger value, such as 1 hour to guarantee that you will not receive IOExceptions for requests going to replicas.\n \n+[[async.wal.replication.meta]]\n === Region replication for META table\u2019s region\n-Currently, Async WAL Replication is not done for the META table\u2019s WAL. The meta table\u2019s secondary replicas still refreshes themselves from the persistent store files. Hence the `hbase.regionserver.meta.storefile.refresh.period` needs to be set to a certain non-zero value for refreshing the meta store files. Note that this configuration is configured differently than\n-`hbase.regionserver.storefile.refresh.period`.\n+Up until hbase-2.4.0, Async WAL Replication did not work for the META table\u2019s WAL. The meta table\u2019s secondary replicas refreshed themselves from the persistent store files every `hbase.regionserver.meta.storefile.refresh.period`,\n+(a non-zero value). Note how the META replication period is distinct from the user-space `hbase.regionserver.storefile.refresh.period` value.\n+\n+Async WAL replication for META is a new feature in 2.4.0 still under active development. Use with caution.\n+Set `hbase.region.replica.replication.catalog.enabled` to enable async WAL Replication for META region replicas.", "originalCommit": "55c9df02fc0c411c99229fbd794ab12d6e08132e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc5NjkzOQ==", "url": "https://github.com/apache/hbase/pull/2665#discussion_r524796939", "bodyText": "done", "author": "saintstack", "createdAt": "2020-11-17T00:16:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc2OTY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc3MDI0MA==", "url": "https://github.com/apache/hbase/pull/2665#discussion_r524770240", "bodyText": "nit: s/Regards the META replicas count/Regarding the META replicas count/", "author": "ndimiduk", "createdAt": "2020-11-16T23:50:29Z", "path": "src/main/asciidoc/_chapters/architecture.adoc", "diffHunk": "@@ -2865,26 +2865,51 @@ The first mechanism is store file refresher which is introduced in HBase-1.0+. S\n \n For turning this feature on, you should configure `hbase.regionserver.storefile.refresh.period` to a non-zero value. See Configuration section below.\n \n-==== Asnyc WAL replication\n-The second mechanism for propagation of writes to secondaries is done via \u201cAsync WAL Replication\u201d feature and is only available in HBase-1.1+. This works similarly to HBase\u2019s multi-datacenter replication, but instead the data from a region is replicated to the secondary regions. Each secondary replica always receives and observes the writes in the same order that the primary region committed them. In some sense, this design can be thought of as \u201cin-cluster replication\u201d, where instead of replicating to a different datacenter, the data goes to secondary regions to keep secondary region\u2019s in-memory state up to date. The data files are shared between the primary region and the other replicas, so that there is no extra storage overhead. However, the secondary regions will have recent non-flushed data in their memstores, which increases the memory overhead. The primary region writes flush, compaction, and bulk load events to its WAL as well, which are also replicated through wal replication to secondaries. When they observe the flush/compaction or bulk load event, the secondary regions replay the event to pick up the new files and drop the old ones.\n+[[async.wal.replication]]\n+==== Async WAL replication\n+The second mechanism for propagation of writes to secondaries is done via the \u201cAsync WAL Replication\u201d feature. It is only available in HBase-1.1+. This works similarly to HBase\u2019s multi-datacenter replication, but instead the data from a region is replicated to the secondary regions. Each secondary replica always receives and observes the writes in the same order that the primary region committed them. In some sense, this design can be thought of as \u201cin-cluster replication\u201d, where instead of replicating to a different datacenter, the data goes to secondary regions to keep secondary region\u2019s in-memory state up to date. The data files are shared between the primary region and the other replicas, so that there is no extra storage overhead. However, the secondary regions will have recent non-flushed data in their memstores, which increases the memory overhead. The primary region writes flush, compaction, and bulk load events to its WAL as well, which are also replicated through wal replication to secondaries. When they observe the flush/compaction or bulk load event, the secondary regions replay the event to pick up the new files and drop the old ones.\n \n Committing writes in the same order as in primary ensures that the secondaries won\u2019t diverge from the primary regions data, but since the log replication is asynchronous, the data might still be stale in secondary regions. Since this feature works as a replication endpoint, the performance and latency characteristics is expected to be similar to inter-cluster replication.\n \n Async WAL Replication is *disabled* by default. You can enable this feature by setting `hbase.region.replica.replication.enabled` to `true`.\n-Asyn WAL Replication feature will add a new replication peer named `region_replica_replication` as a replication peer when you create a table with region replication > 1 for the first time. Once enabled, if you want to disable this feature, you need to do two actions:\n+The Async WAL Replication feature will add a new replication peer named `region_replica_replication` as a replication peer when you createa table with region replication > 1 for the first time. Once enabled, if you want to disable this feature, you need to do two actions:\n * Set configuration property `hbase.region.replica.replication.enabled` to false in `hbase-site.xml` (see Configuration section below)\n * Disable the replication peer named `region_replica_replication` in the cluster using hbase shell or `Admin` class:\n [source,bourne]\n ----\n \thbase> disable_peer 'region_replica_replication'\n ----\n \n+Async WAL Replication and the `hbase:meta` table is a little more involved and gets its own section below; see <<async.wal.replication.meta>>\n+\n === Store File TTL\n In both of the write propagation approaches mentioned above, store files of the primary will be opened in secondaries independent of the primary region. So for files that the primary compacted away, the secondaries might still be referring to these files for reading. Both features are using HFileLinks to refer to files, but there is no protection (yet) for guaranteeing that the file will not be deleted prematurely. Thus, as a guard, you should set the configuration property `hbase.master.hfilecleaner.ttl` to a larger value, such as 1 hour to guarantee that you will not receive IOExceptions for requests going to replicas.\n \n+[[async.wal.replication.meta]]\n === Region replication for META table\u2019s region\n-Currently, Async WAL Replication is not done for the META table\u2019s WAL. The meta table\u2019s secondary replicas still refreshes themselves from the persistent store files. Hence the `hbase.regionserver.meta.storefile.refresh.period` needs to be set to a certain non-zero value for refreshing the meta store files. Note that this configuration is configured differently than\n-`hbase.regionserver.storefile.refresh.period`.\n+Up until hbase-2.4.0, Async WAL Replication did not work for the META table\u2019s WAL. The meta table\u2019s secondary replicas refreshed themselves from the persistent store files every `hbase.regionserver.meta.storefile.refresh.period`,\n+(a non-zero value). Note how the META replication period is distinct from the user-space `hbase.regionserver.storefile.refresh.period` value.\n+\n+Async WAL replication for META is a new feature in 2.4.0 still under active development. Use with caution.\n+Set `hbase.region.replica.replication.catalog.enabled` to enable async WAL Replication for META region replicas.\n+Its off by default.\n+\n+Regards the META replicas count, up to hbase-2.4.0, you would set the special property 'hbase.meta.replica.count'.", "originalCommit": "55c9df02fc0c411c99229fbd794ab12d6e08132e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc5NzczMw==", "url": "https://github.com/apache/hbase/pull/2665#discussion_r524797733", "bodyText": "Thanks.", "author": "saintstack", "createdAt": "2020-11-17T00:17:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc3MDI0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc3MjA4Mg==", "url": "https://github.com/apache/hbase/pull/2665#discussion_r524772082", "bodyText": "You give a name to AND describe the old behavior, but you only give a name to the new behavior. Would be a kindness to describe and name both, OR just name them and link off to the documentation on this enum in code.", "author": "ndimiduk", "createdAt": "2020-11-16T23:52:19Z", "path": "src/main/asciidoc/_chapters/architecture.adoc", "diffHunk": "@@ -2865,26 +2865,51 @@ The first mechanism is store file refresher which is introduced in HBase-1.0+. S\n \n For turning this feature on, you should configure `hbase.regionserver.storefile.refresh.period` to a non-zero value. See Configuration section below.\n \n-==== Asnyc WAL replication\n-The second mechanism for propagation of writes to secondaries is done via \u201cAsync WAL Replication\u201d feature and is only available in HBase-1.1+. This works similarly to HBase\u2019s multi-datacenter replication, but instead the data from a region is replicated to the secondary regions. Each secondary replica always receives and observes the writes in the same order that the primary region committed them. In some sense, this design can be thought of as \u201cin-cluster replication\u201d, where instead of replicating to a different datacenter, the data goes to secondary regions to keep secondary region\u2019s in-memory state up to date. The data files are shared between the primary region and the other replicas, so that there is no extra storage overhead. However, the secondary regions will have recent non-flushed data in their memstores, which increases the memory overhead. The primary region writes flush, compaction, and bulk load events to its WAL as well, which are also replicated through wal replication to secondaries. When they observe the flush/compaction or bulk load event, the secondary regions replay the event to pick up the new files and drop the old ones.\n+[[async.wal.replication]]\n+==== Async WAL replication\n+The second mechanism for propagation of writes to secondaries is done via the \u201cAsync WAL Replication\u201d feature. It is only available in HBase-1.1+. This works similarly to HBase\u2019s multi-datacenter replication, but instead the data from a region is replicated to the secondary regions. Each secondary replica always receives and observes the writes in the same order that the primary region committed them. In some sense, this design can be thought of as \u201cin-cluster replication\u201d, where instead of replicating to a different datacenter, the data goes to secondary regions to keep secondary region\u2019s in-memory state up to date. The data files are shared between the primary region and the other replicas, so that there is no extra storage overhead. However, the secondary regions will have recent non-flushed data in their memstores, which increases the memory overhead. The primary region writes flush, compaction, and bulk load events to its WAL as well, which are also replicated through wal replication to secondaries. When they observe the flush/compaction or bulk load event, the secondary regions replay the event to pick up the new files and drop the old ones.\n \n Committing writes in the same order as in primary ensures that the secondaries won\u2019t diverge from the primary regions data, but since the log replication is asynchronous, the data might still be stale in secondary regions. Since this feature works as a replication endpoint, the performance and latency characteristics is expected to be similar to inter-cluster replication.\n \n Async WAL Replication is *disabled* by default. You can enable this feature by setting `hbase.region.replica.replication.enabled` to `true`.\n-Asyn WAL Replication feature will add a new replication peer named `region_replica_replication` as a replication peer when you create a table with region replication > 1 for the first time. Once enabled, if you want to disable this feature, you need to do two actions:\n+The Async WAL Replication feature will add a new replication peer named `region_replica_replication` as a replication peer when you createa table with region replication > 1 for the first time. Once enabled, if you want to disable this feature, you need to do two actions:\n * Set configuration property `hbase.region.replica.replication.enabled` to false in `hbase-site.xml` (see Configuration section below)\n * Disable the replication peer named `region_replica_replication` in the cluster using hbase shell or `Admin` class:\n [source,bourne]\n ----\n \thbase> disable_peer 'region_replica_replication'\n ----\n \n+Async WAL Replication and the `hbase:meta` table is a little more involved and gets its own section below; see <<async.wal.replication.meta>>\n+\n === Store File TTL\n In both of the write propagation approaches mentioned above, store files of the primary will be opened in secondaries independent of the primary region. So for files that the primary compacted away, the secondaries might still be referring to these files for reading. Both features are using HFileLinks to refer to files, but there is no protection (yet) for guaranteeing that the file will not be deleted prematurely. Thus, as a guard, you should set the configuration property `hbase.master.hfilecleaner.ttl` to a larger value, such as 1 hour to guarantee that you will not receive IOExceptions for requests going to replicas.\n \n+[[async.wal.replication.meta]]\n === Region replication for META table\u2019s region\n-Currently, Async WAL Replication is not done for the META table\u2019s WAL. The meta table\u2019s secondary replicas still refreshes themselves from the persistent store files. Hence the `hbase.regionserver.meta.storefile.refresh.period` needs to be set to a certain non-zero value for refreshing the meta store files. Note that this configuration is configured differently than\n-`hbase.regionserver.storefile.refresh.period`.\n+Up until hbase-2.4.0, Async WAL Replication did not work for the META table\u2019s WAL. The meta table\u2019s secondary replicas refreshed themselves from the persistent store files every `hbase.regionserver.meta.storefile.refresh.period`,\n+(a non-zero value). Note how the META replication period is distinct from the user-space `hbase.regionserver.storefile.refresh.period` value.\n+\n+Async WAL replication for META is a new feature in 2.4.0 still under active development. Use with caution.\n+Set `hbase.region.replica.replication.catalog.enabled` to enable async WAL Replication for META region replicas.\n+Its off by default.\n+\n+Regards the META replicas count, up to hbase-2.4.0, you would set the special property 'hbase.meta.replica.count'.\n+Now you can alter the META table as you would a user-space table (if `hbase.meta.replica.count` is set, it\n+will take precedent over what is set for replica count in the META table updating META replica count to\n+match).\n+\n+==== Load Balancing META table load ====\n+\n+hbase-2.4.0 adds a new client-side `LoadBalance` mode. When enabled client-side, clients will try to read META replicas first before falling back on the primary. Before this,\n+the lookup mode -- now named `HedgedRead` -- had clients read the primary and if no response after a configurable amount of time had elapsed, it would start up reads against the replicas.\n+The new 'LoadBalance' mode helps alleviate hotspotting on the META table distributing the META read load.", "originalCommit": "55c9df02fc0c411c99229fbd794ab12d6e08132e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgwNjkwMg==", "url": "https://github.com/apache/hbase/pull/2665#discussion_r524806902", "bodyText": "Oh. Yes. Let me fix.", "author": "saintstack", "createdAt": "2020-11-17T00:31:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc3MjA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc3MzY2OA==", "url": "https://github.com/apache/hbase/pull/2665#discussion_r524773668", "bodyText": "\"please do not\" is this language strong enough? What happens if i ship out this configuration accidentally? How badly will we muck up meta? Should the the system proactively defend against this configuration?", "author": "ndimiduk", "createdAt": "2020-11-16T23:53:55Z", "path": "src/main/asciidoc/_chapters/architecture.adoc", "diffHunk": "@@ -2865,26 +2865,51 @@ The first mechanism is store file refresher which is introduced in HBase-1.0+. S\n \n For turning this feature on, you should configure `hbase.regionserver.storefile.refresh.period` to a non-zero value. See Configuration section below.\n \n-==== Asnyc WAL replication\n-The second mechanism for propagation of writes to secondaries is done via \u201cAsync WAL Replication\u201d feature and is only available in HBase-1.1+. This works similarly to HBase\u2019s multi-datacenter replication, but instead the data from a region is replicated to the secondary regions. Each secondary replica always receives and observes the writes in the same order that the primary region committed them. In some sense, this design can be thought of as \u201cin-cluster replication\u201d, where instead of replicating to a different datacenter, the data goes to secondary regions to keep secondary region\u2019s in-memory state up to date. The data files are shared between the primary region and the other replicas, so that there is no extra storage overhead. However, the secondary regions will have recent non-flushed data in their memstores, which increases the memory overhead. The primary region writes flush, compaction, and bulk load events to its WAL as well, which are also replicated through wal replication to secondaries. When they observe the flush/compaction or bulk load event, the secondary regions replay the event to pick up the new files and drop the old ones.\n+[[async.wal.replication]]\n+==== Async WAL replication\n+The second mechanism for propagation of writes to secondaries is done via the \u201cAsync WAL Replication\u201d feature. It is only available in HBase-1.1+. This works similarly to HBase\u2019s multi-datacenter replication, but instead the data from a region is replicated to the secondary regions. Each secondary replica always receives and observes the writes in the same order that the primary region committed them. In some sense, this design can be thought of as \u201cin-cluster replication\u201d, where instead of replicating to a different datacenter, the data goes to secondary regions to keep secondary region\u2019s in-memory state up to date. The data files are shared between the primary region and the other replicas, so that there is no extra storage overhead. However, the secondary regions will have recent non-flushed data in their memstores, which increases the memory overhead. The primary region writes flush, compaction, and bulk load events to its WAL as well, which are also replicated through wal replication to secondaries. When they observe the flush/compaction or bulk load event, the secondary regions replay the event to pick up the new files and drop the old ones.\n \n Committing writes in the same order as in primary ensures that the secondaries won\u2019t diverge from the primary regions data, but since the log replication is asynchronous, the data might still be stale in secondary regions. Since this feature works as a replication endpoint, the performance and latency characteristics is expected to be similar to inter-cluster replication.\n \n Async WAL Replication is *disabled* by default. You can enable this feature by setting `hbase.region.replica.replication.enabled` to `true`.\n-Asyn WAL Replication feature will add a new replication peer named `region_replica_replication` as a replication peer when you create a table with region replication > 1 for the first time. Once enabled, if you want to disable this feature, you need to do two actions:\n+The Async WAL Replication feature will add a new replication peer named `region_replica_replication` as a replication peer when you createa table with region replication > 1 for the first time. Once enabled, if you want to disable this feature, you need to do two actions:\n * Set configuration property `hbase.region.replica.replication.enabled` to false in `hbase-site.xml` (see Configuration section below)\n * Disable the replication peer named `region_replica_replication` in the cluster using hbase shell or `Admin` class:\n [source,bourne]\n ----\n \thbase> disable_peer 'region_replica_replication'\n ----\n \n+Async WAL Replication and the `hbase:meta` table is a little more involved and gets its own section below; see <<async.wal.replication.meta>>\n+\n === Store File TTL\n In both of the write propagation approaches mentioned above, store files of the primary will be opened in secondaries independent of the primary region. So for files that the primary compacted away, the secondaries might still be referring to these files for reading. Both features are using HFileLinks to refer to files, but there is no protection (yet) for guaranteeing that the file will not be deleted prematurely. Thus, as a guard, you should set the configuration property `hbase.master.hfilecleaner.ttl` to a larger value, such as 1 hour to guarantee that you will not receive IOExceptions for requests going to replicas.\n \n+[[async.wal.replication.meta]]\n === Region replication for META table\u2019s region\n-Currently, Async WAL Replication is not done for the META table\u2019s WAL. The meta table\u2019s secondary replicas still refreshes themselves from the persistent store files. Hence the `hbase.regionserver.meta.storefile.refresh.period` needs to be set to a certain non-zero value for refreshing the meta store files. Note that this configuration is configured differently than\n-`hbase.regionserver.storefile.refresh.period`.\n+Up until hbase-2.4.0, Async WAL Replication did not work for the META table\u2019s WAL. The meta table\u2019s secondary replicas refreshed themselves from the persistent store files every `hbase.regionserver.meta.storefile.refresh.period`,\n+(a non-zero value). Note how the META replication period is distinct from the user-space `hbase.regionserver.storefile.refresh.period` value.\n+\n+Async WAL replication for META is a new feature in 2.4.0 still under active development. Use with caution.\n+Set `hbase.region.replica.replication.catalog.enabled` to enable async WAL Replication for META region replicas.\n+Its off by default.\n+\n+Regards the META replicas count, up to hbase-2.4.0, you would set the special property 'hbase.meta.replica.count'.\n+Now you can alter the META table as you would a user-space table (if `hbase.meta.replica.count` is set, it\n+will take precedent over what is set for replica count in the META table updating META replica count to\n+match).\n+\n+==== Load Balancing META table load ====\n+\n+hbase-2.4.0 adds a new client-side `LoadBalance` mode. When enabled client-side, clients will try to read META replicas first before falling back on the primary. Before this,\n+the lookup mode -- now named `HedgedRead` -- had clients read the primary and if no response after a configurable amount of time had elapsed, it would start up reads against the replicas.\n+The new 'LoadBalance' mode helps alleviate hotspotting on the META table distributing the META read load.\n+\n+To enable the meta replica locator's load balance mode, please set the following configuration at on the client-side (only): set 'hbase.locator.meta.replicas.mode' to \"LoadBalance\".\n+Valid options for this configuration are `None`, `HedgedRead`, and `LoadBalance`. Option parse is case insensitive.\n+The default mode is `None` (which falls through to `HedgedRead`, the current default).  Please do not put this configuration in any hbase server's configuration, master or region server.", "originalCommit": "95b460d79052cbaeb3b5caed6f0e7b96bdfbca19", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc5ODk2Ng==", "url": "https://github.com/apache/hbase/pull/2665#discussion_r524798966", "bodyText": "Change it to DO NOT. A follow-on will add code to defend against this being set server side.", "author": "saintstack", "createdAt": "2020-11-17T00:18:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc3MzY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgwNjc5OA==", "url": "https://github.com/apache/hbase/pull/2665#discussion_r524806798", "bodyText": "Added HBASE-25294 to add code defense against the LoadBalance option being enabled for the Master-hosted client.", "author": "saintstack", "createdAt": "2020-11-17T00:31:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDc3MzY2OA=="}], "type": "inlineReview"}, {"oid": "ceebc6488d53fb40048fb4a37b2ff3ef473b802b", "url": "https://github.com/apache/hbase/commit/ceebc6488d53fb40048fb4a37b2ff3ef473b802b", "message": "HBASE-25291 Document how to enable the meta replica load balance mode for the client and clean up around hbase:meta read replicas\n\nhbase-client/src/main/java/org/apache/hadoop/hbase/client/CatalogReplicaLoadBalanceSelector.java\nhbase-client/src/main/java/org/apache/hadoop/hbase/client/CatalogReplicaLoadBalanceSelectorFactory.java\nhbase-client/src/main/java/org/apache/hadoop/hbase/client/CatalogReplicaLoadBalanceSimpleSelector.java\nhbase-client/src/main/java/org/apache/hadoop/hbase/client/CatalogReplicaMode.java\n Make the leading license comment opener align on all these new\n files.... one star rather than two.\n\nhbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/CatalogReplicationSource.java\n Add some comment better situating the catalogreplicationsource\n specialization.\n\nhbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSourceManager.java\n Add comment how this differs from replicationsource factory and why no\n need to keep offset up in zk.\n\nsrc/main/asciidoc/_chapters/architecture.adoc\n Clean up the read replica of META doc. Introduce the new read replica\n liveness on META and the new 'LoadBalance' feature (with warnings).\n General edit.", "committedDate": "2020-11-17T00:40:54Z", "type": "commit"}, {"oid": "ceebc6488d53fb40048fb4a37b2ff3ef473b802b", "url": "https://github.com/apache/hbase/commit/ceebc6488d53fb40048fb4a37b2ff3ef473b802b", "message": "HBASE-25291 Document how to enable the meta replica load balance mode for the client and clean up around hbase:meta read replicas\n\nhbase-client/src/main/java/org/apache/hadoop/hbase/client/CatalogReplicaLoadBalanceSelector.java\nhbase-client/src/main/java/org/apache/hadoop/hbase/client/CatalogReplicaLoadBalanceSelectorFactory.java\nhbase-client/src/main/java/org/apache/hadoop/hbase/client/CatalogReplicaLoadBalanceSimpleSelector.java\nhbase-client/src/main/java/org/apache/hadoop/hbase/client/CatalogReplicaMode.java\n Make the leading license comment opener align on all these new\n files.... one star rather than two.\n\nhbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/CatalogReplicationSource.java\n Add some comment better situating the catalogreplicationsource\n specialization.\n\nhbase-server/src/main/java/org/apache/hadoop/hbase/replication/regionserver/ReplicationSourceManager.java\n Add comment how this differs from replicationsource factory and why no\n need to keep offset up in zk.\n\nsrc/main/asciidoc/_chapters/architecture.adoc\n Clean up the read replica of META doc. Introduce the new read replica\n liveness on META and the new 'LoadBalance' feature (with warnings).\n General edit.", "committedDate": "2020-11-17T00:40:54Z", "type": "forcePushed"}]}