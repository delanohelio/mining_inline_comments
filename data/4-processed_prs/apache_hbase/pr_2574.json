{"pr_number": 2574, "pr_title": "HBASE-25212 Optionally abort requests in progress after deciding a region should close", "pr_createdAt": "2020-10-22T01:13:23Z", "pr_url": "https://github.com/apache/hbase/pull/2574", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0MDYzNw==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r509840637", "bodyText": "Better make it return an exception and make here 'throw throwOnInterrupt(e)' so the compiler will know that this is an exit point.", "author": "Apache9", "createdAt": "2020-10-22T02:22:23Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -1174,7 +1178,7 @@ public HStore call() throws IOException {\n           LOG.info(\"Setting FlushNonSloppyStoresFirstPolicy for the region=\" + this);\n         }\n       } catch (InterruptedException e) {\n-        throw (InterruptedIOException)new InterruptedIOException().initCause(e);\n+        throwOnInterrupt(e);", "originalCommit": "57ef804122a4ad7242489337a4c1e643ea27ed0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDMxNjY0Mw==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r510316643", "bodyText": "Ok", "author": "apurtell", "createdAt": "2020-10-22T16:56:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0MDYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0MTY2Mg==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r509841662", "bodyText": "Pity we need to repeat this call many times in the same method...", "author": "Apache9", "createdAt": "2020-10-22T02:26:23Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -4550,6 +4619,10 @@ private void doMiniBatchMutate(BatchOperation<?> batchOp) throws IOException {\n     /** Keep track of the locks we hold so we can release them in finally clause */\n     List<RowLock> acquiredRowLocks = Lists.newArrayListWithCapacity(batchOp.size());\n     try {\n+      // Check for thread interrupt status in case we have been signaled from\n+      // #interruptRegionOperation.\n+      checkInterrupt();", "originalCommit": "57ef804122a4ad7242489337a4c1e643ea27ed0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDMxNzI5OQ==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r510317299", "bodyText": "Yes, but on the other hand we are basically checking interrupt status manually, as one has to do in Java, so can check and exit early at only what we think are safe points, which is nice.", "author": "apurtell", "createdAt": "2020-10-22T16:57:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0MTY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0MTkyMQ==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r509841921", "bodyText": "Here the interrupt may come from the checkInterrupt call, not acquire lock?", "author": "Apache9", "createdAt": "2020-10-22T02:27:11Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -6588,8 +6677,10 @@ protected RowLock getRowLockInternal(byte[] row, boolean readLock, final RowLock\n       success = true;\n       return result;\n     } catch (InterruptedException ie) {\n-      LOG.warn(\"Thread interrupted waiting for lock on row: {}, in region {}\", rowKey,\n-        getRegionInfo().getRegionNameAsString());\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Thread interrupted waiting for lock on row: {}, in region {}\", rowKey,", "originalCommit": "57ef804122a4ad7242489337a4c1e643ea27ed0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDMxOTQ2Mg==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r510319462", "bodyText": "This was an existing case where the client would get back an IIOE. I didn't change it so the current semantics are preserved. It can be changed to use throwOnInterrupt", "author": "apurtell", "createdAt": "2020-10-22T17:01:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0MTkyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDIxNDk3NQ==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r514214975", "bodyText": "I mean the log message. Waiting on row lock is not the only case now?", "author": "Apache9", "createdAt": "2020-10-29T12:20:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0MTkyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQwMDk0Mg==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r515400942", "bodyText": "No the interrupt won't come from the checkInterrupt here", "author": "apurtell", "createdAt": "2020-10-30T21:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0MTkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0MzA0NQ==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r509843045", "bodyText": "Maybe we could just use Collections.newSetFromMap(new ConcurrentHashMap<>()) here?", "author": "Apache9", "createdAt": "2020-10-22T02:31:22Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -8748,6 +8863,11 @@ public void startRegionOperation(Operation op) throws IOException {\n       throw new NotServingRegionException(getRegionInfo().getRegionNameAsString() + \" is closing\");\n     }\n     lock(lock.readLock());\n+    // Update regionLockHolders ONLY for any startRegionOperation call that is invoked from an RPC handler\n+    Thread thisThread = Thread.currentThread();\n+    if (isInterruptableOp) {\n+      regionLockHolders.put(thisThread.hashCode(), thisThread);", "originalCommit": "57ef804122a4ad7242489337a4c1e643ea27ed0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg2NDA2OQ==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r509864069", "bodyText": "+1", "author": "bharathv", "createdAt": "2020-10-22T03:52:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0MzA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDMxNzUzOA==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r510317538", "bodyText": "Ok", "author": "apurtell", "createdAt": "2020-10-22T16:58:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0MzA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0Mzg0Mg==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r509843842", "bodyText": "Usually we do not add this to a single test as we have a test timeout for the whole test file.", "author": "Apache9", "createdAt": "2020-10-22T02:34:27Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java", "diffHunk": "@@ -7364,4 +7367,154 @@ protected HStoreForTesting(final HRegion region,\n       return super.doCompaction(cr, filesToCompact, user, compactionStartTime, newFiles);\n     }\n   }\n+\n+  @Test(timeout=20000)", "originalCommit": "57ef804122a4ad7242489337a4c1e643ea27ed0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDMyMDMzOQ==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r510320339", "bodyText": "Ok", "author": "apurtell", "createdAt": "2020-10-22T17:02:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0Mzg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0NDE5MQ==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r509844191", "bodyText": "Use the config from the HBTU? Maybe new Configuration(TEST_UTIL.getConfiguration())", "author": "Apache9", "createdAt": "2020-10-22T02:35:46Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java", "diffHunk": "@@ -7364,4 +7367,154 @@ protected HStoreForTesting(final HRegion region,\n       return super.doCompaction(cr, filesToCompact, user, compactionStartTime, newFiles);\n     }\n   }\n+\n+  @Test(timeout=20000)\n+  public void testCloseNoInterrupt() throws Exception {\n+    byte[] cf1 = Bytes.toBytes(\"CF1\");\n+    byte[][] families = { cf1 };\n+\n+    Configuration conf = HBaseConfiguration.create();", "originalCommit": "57ef804122a4ad7242489337a4c1e643ea27ed0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDMyMDQxMQ==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r510320411", "bodyText": "Ok", "author": "apurtell", "createdAt": "2020-10-22T17:02:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0NDE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0NDM3NA==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r509844374", "bodyText": "Just use TableNameTestRule.", "author": "Apache9", "createdAt": "2020-10-22T02:36:26Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRegionInterrupt.java", "diffHunk": "@@ -0,0 +1,357 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.regionserver;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.HBaseClassTestRule;\n+import org.apache.hadoop.hbase.HBaseTestingUtility;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.NotServingRegionException;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.Waiter;\n+import org.apache.hadoop.hbase.client.Admin;\n+import org.apache.hadoop.hbase.client.Append;\n+import org.apache.hadoop.hbase.client.BufferedMutator;\n+import org.apache.hadoop.hbase.client.ColumnFamilyDescriptorBuilder;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Durability;\n+import org.apache.hadoop.hbase.client.Increment;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.client.ResultScanner;\n+import org.apache.hadoop.hbase.client.RetriesExhaustedWithDetailsException;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.client.Table;\n+import org.apache.hadoop.hbase.client.TableDescriptor;\n+import org.apache.hadoop.hbase.client.TableDescriptorBuilder;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.RegionCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.coprocessor.RegionObserver;\n+import org.apache.hadoop.hbase.exceptions.DeserializationException;\n+import org.apache.hadoop.hbase.filter.FilterBase;\n+import org.apache.hadoop.hbase.testclassification.LargeTests;\n+import org.apache.hadoop.hbase.testclassification.RegionServerTests;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALEdit;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.junit.rules.TestName;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Category({RegionServerTests.class, LargeTests.class})\n+public class TestRegionInterrupt {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule CLASS_RULE =\n+    HBaseClassTestRule.forClass(TestRegionInterrupt.class);\n+\n+  private static HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();\n+  private static final Logger LOG = LoggerFactory.getLogger(TestRegionInterrupt.class);\n+\n+  static final int SLEEP_TIME = 10 * 1000;\n+  static final byte[] FAMILY = Bytes.toBytes(\"info\");\n+\n+  @Rule\n+  public TestName name = new TestName();", "originalCommit": "57ef804122a4ad7242489337a4c1e643ea27ed0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDMyMDY0Mg==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r510320642", "bodyText": "Did not know about this, ok", "author": "apurtell", "createdAt": "2020-10-22T17:03:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTg0NDM3NA=="}], "type": "inlineReview"}, {"oid": "b5b6a9032e145daaf3aa3fc7ae2d0cd0a47e1c9f", "url": "https://github.com/apache/hbase/commit/b5b6a9032e145daaf3aa3fc7ae2d0cd0a47e1c9f", "message": "Address review feedback\n\n- Address review feedback\n- Fix spotbugs warnings\n- Fix checkstyle nit\n- Fix new unit tests, missed a needed HTU change for master branch\n- Fix more unit tests after HTU change\n- Reduce chance of race conditions in new TestHRegion units by joining on lock holder", "committedDate": "2020-10-22T19:23:31Z", "type": "forcePushed"}, {"oid": "9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a", "url": "https://github.com/apache/hbase/commit/9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a", "message": "Set HRegion#DEFAULT_CLOSE_WAIT_ABORT to true", "committedDate": "2020-10-23T17:35:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5OTQ4OQ==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r511999489", "bodyText": "nit: Instead of using holderInterrupted, maybe we can throw AssertionError with message that holder should not have been interrupted?", "author": "virajjasani", "createdAt": "2020-10-26T14:24:52Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java", "diffHunk": "@@ -7364,4 +7366,157 @@ protected HStoreForTesting(final HRegion region,\n       return super.doCompaction(cr, filesToCompact, user, compactionStartTime, newFiles);\n     }\n   }\n+\n+  @Test\n+  public void testCloseNoInterrupt() throws Exception {\n+    byte[] cf1 = Bytes.toBytes(\"CF1\");\n+    byte[][] families = { cf1 };\n+\n+    Configuration conf = new Configuration(CONF);\n+    // Disable close thread interrupt and server abort behavior\n+    conf.setBoolean(HRegion.CLOSE_WAIT_ABORT, false);\n+    region = initHRegion(tableName, method, conf, families);\n+\n+    final CountDownLatch latch = new CountDownLatch(1);\n+    final AtomicBoolean holderInterrupted = new AtomicBoolean();\n+    Thread holder = new Thread(new Runnable() {\n+      @Override\n+      public void run() {\n+        try {\n+          LOG.info(\"Starting region operation holder\");\n+          region.startRegionOperation(Operation.SCAN);\n+          latch.countDown();\n+          try {\n+            Thread.sleep(10*1000);\n+          } catch (InterruptedException e) {\n+            LOG.info(\"Interrupted\");\n+            holderInterrupted.set(true);", "originalCommit": "9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4MzYwNA==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512083604", "bodyText": "If you throw an assertion inside a Thread runnable it won't unwind to the JUnit test method that forked the thread, it will be caught by Thread.UncaughtExceptionHandler, which is not what I think we want. So I set the boolean and then test it in the unit test method where an assertion will propagate the way I want. Maybe JUnit installs its own UEH, didn't test, but the way I have done it makes more sense to me.", "author": "apurtell", "createdAt": "2020-10-26T16:11:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5OTQ4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE3NDE5Ng==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512174196", "bodyText": "Oh yes, nvm, current approach is better.", "author": "virajjasani", "createdAt": "2020-10-26T18:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk5OTQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwNjYwOA==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512006608", "bodyText": "nit: if the only usage is to find diff b/ end and start, directly using System.currentTimeMillis() might be preferred option?", "author": "virajjasani", "createdAt": "2020-10-26T14:33:42Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java", "diffHunk": "@@ -7364,4 +7366,157 @@ protected HStoreForTesting(final HRegion region,\n       return super.doCompaction(cr, filesToCompact, user, compactionStartTime, newFiles);\n     }\n   }\n+\n+  @Test\n+  public void testCloseNoInterrupt() throws Exception {\n+    byte[] cf1 = Bytes.toBytes(\"CF1\");\n+    byte[][] families = { cf1 };\n+\n+    Configuration conf = new Configuration(CONF);\n+    // Disable close thread interrupt and server abort behavior\n+    conf.setBoolean(HRegion.CLOSE_WAIT_ABORT, false);\n+    region = initHRegion(tableName, method, conf, families);\n+\n+    final CountDownLatch latch = new CountDownLatch(1);\n+    final AtomicBoolean holderInterrupted = new AtomicBoolean();\n+    Thread holder = new Thread(new Runnable() {\n+      @Override\n+      public void run() {\n+        try {\n+          LOG.info(\"Starting region operation holder\");\n+          region.startRegionOperation(Operation.SCAN);\n+          latch.countDown();\n+          try {\n+            Thread.sleep(10*1000);\n+          } catch (InterruptedException e) {\n+            LOG.info(\"Interrupted\");\n+            holderInterrupted.set(true);\n+          }\n+        } catch (Exception e) {\n+          throw new RuntimeException(e);\n+        } finally {\n+          try {\n+            region.closeRegionOperation();\n+          } catch (IOException e) {\n+          }\n+          LOG.info(\"Stopped region operation holder\");\n+        }\n+      }\n+    });\n+\n+    holder.start();\n+    latch.await();\n+    region.close();\n+    holder.join();\n+    region = null;\n+\n+    assertFalse(\"Region lock holder should not have been interrupted\", holderInterrupted.get());\n+  }\n+\n+  @Test\n+  public void testCloseInterrupt() throws Exception {\n+    byte[] cf1 = Bytes.toBytes(\"CF1\");\n+    byte[][] families = { cf1 };\n+\n+    Configuration conf = new Configuration(CONF);\n+    // Enable close thread interrupt and server abort behavior\n+    conf.setBoolean(HRegion.CLOSE_WAIT_ABORT, true);\n+    region = initHRegion(tableName, method, conf, families);\n+\n+    final CountDownLatch latch = new CountDownLatch(1);\n+    final AtomicBoolean holderInterrupted = new AtomicBoolean();\n+    Thread holder = new Thread(new Runnable() {\n+      @Override\n+      public void run() {\n+        try {\n+          LOG.info(\"Starting region operation holder\");\n+          region.startRegionOperation(Operation.SCAN);\n+          latch.countDown();\n+          try {\n+            Thread.sleep(10*1000);\n+          } catch (InterruptedException e) {\n+            LOG.info(\"Interrupted\");\n+            holderInterrupted.set(true);\n+          }\n+        } catch (Exception e) {\n+          throw new RuntimeException(e);\n+        } finally {\n+          try {\n+            region.closeRegionOperation();\n+          } catch (IOException e) {\n+          }\n+          LOG.info(\"Stopped region operation holder\");\n+        }\n+      }\n+    });\n+\n+    holder.start();\n+    latch.await();\n+    region.close();\n+    holder.join();\n+    region = null;\n+\n+    assertTrue(\"Region lock holder was not interrupted\", holderInterrupted.get());\n+  }\n+\n+  @Test\n+  public void testCloseAbort() throws Exception {\n+    byte[] cf1 = Bytes.toBytes(\"CF1\");\n+    byte[][] families = { cf1 };\n+\n+    Configuration conf = new Configuration(CONF);\n+    // Enable close thread interrupt and server abort behavior\n+    // Set the close lock acquisition wait time to 5 seconds\n+    conf.setBoolean(HRegion.CLOSE_WAIT_ABORT, true);\n+    conf.setInt(HRegion.CLOSE_WAIT_TIME, 5*1000);\n+    region = initHRegion(tableName, method, conf, families);\n+    RegionServerServices rsServices = mock(RegionServerServices.class);\n+    region.rsServices = rsServices;\n+\n+    final CountDownLatch latch = new CountDownLatch(1);\n+    Thread holder = new Thread(new Runnable() {\n+      @Override\n+      public void run() {\n+        try {\n+          LOG.info(\"Starting region operation holder\");\n+          region.startRegionOperation(Operation.SCAN);\n+          latch.countDown();\n+          // Hold the lock for 10 seconds no matter how many times we are interrupted\n+          int timeRemaining = 10 * 1000;\n+          while (timeRemaining > 0) {\n+            long start = EnvironmentEdgeManager.currentTime();", "originalCommit": "9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4NDUyMw==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512084523", "bodyText": "We always use EnvironmentEdgeManager, especially in tests, per our coding conventions.", "author": "apurtell", "createdAt": "2020-10-26T16:12:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAwNjYwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxODU0MA==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512018540", "bodyText": "Although this is not an atomic operation on volatile, but we are just converting it's own value in sec to ms, hence we should be good here.", "author": "virajjasani", "createdAt": "2020-10-26T14:48:32Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -1679,22 +1688,82 @@ public void setTimeoutForWriteLock(long timeoutForWriteLock) {\n       }\n     }\n \n-    if (timeoutForWriteLock == null\n-        || timeoutForWriteLock == Long.MAX_VALUE) {\n-      // block waiting for the lock for closing\n-      lock.writeLock().lock(); // FindBugs: Complains UL_UNRELEASED_LOCK_EXCEPTION_PATH but seems fine\n+    // Set the closing flag\n+    // From this point new arrivals at the region lock will get NSRE.\n+\n+    this.closing.set(true);\n+    LOG.info(\"Closing region {}\", this);\n+\n+    // Acquire the close lock\n+\n+    // The configuration parameter CLOSE_WAIT_ABORT is overloaded to enable both\n+    // the new regionserver abort condition and interrupts for running requests.\n+    // If CLOSE_WAIT_ABORT is not enabled there is no change from earlier behavior,\n+    // we will not attempt to interrupt threads servicing requests nor crash out\n+    // the regionserver if something remains stubborn.\n+\n+    boolean canAbort = conf.getBoolean(CLOSE_WAIT_ABORT, DEFAULT_CLOSE_WAIT_ABORT);\n+    boolean useTimedWait = false;\n+    if (timeoutForWriteLock == null || timeoutForWriteLock == Long.MAX_VALUE) {\n+      if (canAbort) {\n+        timeoutForWriteLock = conf.getLong(CLOSE_WAIT_TIME, DEFAULT_CLOSE_WAIT_TIME);\n+        useTimedWait = true;\n+      }\n     } else {\n+      // convert legacy use of timeoutForWriteLock in seconds to new use in millis\n+      timeoutForWriteLock = TimeUnit.SECONDS.toMillis(timeoutForWriteLock);", "originalCommit": "9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4NDc5OQ==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512084799", "bodyText": "Ok", "author": "apurtell", "createdAt": "2020-10-26T16:12:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAxODU0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzMzYxNQ==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512033615", "bodyText": "nit: we can remove NSRE here", "author": "virajjasani", "createdAt": "2020-10-26T15:07:11Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -8793,7 +8921,7 @@ public void closeRegionOperation(Operation operation) throws IOException {\n    * @throws InterruptedIOException if interrupted while waiting for a lock\n    */\n   private void startBulkRegionOperation(boolean writeLockNeeded)\n-      throws NotServingRegionException, RegionTooBusyException, InterruptedIOException {\n+      throws NotServingRegionException, IOException {", "originalCommit": "9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4NzAxMw==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512087013", "bodyText": "Ok", "author": "apurtell", "createdAt": "2020-10-26T16:15:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzMzYxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzNTUxOA==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512035518", "bodyText": "maybe Waiting can be replaced with Waiting without time limit ?", "author": "virajjasani", "createdAt": "2020-10-26T15:09:38Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -1679,22 +1688,82 @@ public void setTimeoutForWriteLock(long timeoutForWriteLock) {\n       }\n     }\n \n-    if (timeoutForWriteLock == null\n-        || timeoutForWriteLock == Long.MAX_VALUE) {\n-      // block waiting for the lock for closing\n-      lock.writeLock().lock(); // FindBugs: Complains UL_UNRELEASED_LOCK_EXCEPTION_PATH but seems fine\n+    // Set the closing flag\n+    // From this point new arrivals at the region lock will get NSRE.\n+\n+    this.closing.set(true);\n+    LOG.info(\"Closing region {}\", this);\n+\n+    // Acquire the close lock\n+\n+    // The configuration parameter CLOSE_WAIT_ABORT is overloaded to enable both\n+    // the new regionserver abort condition and interrupts for running requests.\n+    // If CLOSE_WAIT_ABORT is not enabled there is no change from earlier behavior,\n+    // we will not attempt to interrupt threads servicing requests nor crash out\n+    // the regionserver if something remains stubborn.\n+\n+    boolean canAbort = conf.getBoolean(CLOSE_WAIT_ABORT, DEFAULT_CLOSE_WAIT_ABORT);\n+    boolean useTimedWait = false;\n+    if (timeoutForWriteLock == null || timeoutForWriteLock == Long.MAX_VALUE) {\n+      if (canAbort) {\n+        timeoutForWriteLock = conf.getLong(CLOSE_WAIT_TIME, DEFAULT_CLOSE_WAIT_TIME);\n+        useTimedWait = true;\n+      }\n     } else {\n+      // convert legacy use of timeoutForWriteLock in seconds to new use in millis\n+      timeoutForWriteLock = TimeUnit.SECONDS.toMillis(timeoutForWriteLock);\n+      useTimedWait = true;\n+    }\n+    if (LOG.isDebugEnabled()) {\n+      LOG.debug((useTimedWait ? \"Time limited wait\" : \"Waiting\") + \" for close lock on \" + this);", "originalCommit": "9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2NTQ2NA==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512165464", "bodyText": "Ok", "author": "apurtell", "createdAt": "2020-10-26T18:05:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzNTUxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0MTc5NQ==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512041795", "bodyText": "nit: put these lines by mistake? :)", "author": "virajjasani", "createdAt": "2020-10-26T15:17:37Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -9000,6 +9129,49 @@ public long getReadPoint() {\n     return getReadPoint(IsolationLevel.READ_COMMITTED);\n   }\n \n+  /**\n+   * Interrupt any region options that have acquired the region lock via\n+   * {@link #startRegionOperation(org.apache.hadoop.hbase.regionserver.Region.Operation)},\n+   * or {@link #startBulkRegionOperation(boolean)}.\n+   */\n+  private void interruptRegionOperations() {\n+    for (Thread t: regionLockHolders) {\n+      t.interrupt();\n+    }\n+  }\n+\n+  /**\n+   * Check thread interrupt status and throw an exception if interrupted.\n+   * @throws NotServingRegionException if region is closing\n+   * @throws InterruptedIOException if interrupted but region is not closing\n+   */\n+  // Package scope for tests\n+  void checkInterrupt() throws NotServingRegionException, InterruptedIOException {\n+    if (Thread.interrupted()) {\n+      if (this.closing.get()) {\n+        throw new NotServingRegionException(\n+          getRegionInfo().getRegionNameAsString() + \" is closing\");\n+      }\n+      throw new InterruptedIOException();\n+    }\n+  }\n+\n+  /**\n+   * Throw the correct exception upon interrupt\n+   * @param t cause\n+   * @throws NotServingRegionException if region is closing\n+   * @throws InterruptedIOException in all cases except if region is closing", "originalCommit": "9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4NzQwNw==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512087407", "bodyText": "Old stuff, will update", "author": "apurtell", "createdAt": "2020-10-26T16:16:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0MTc5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0NjI2Nw==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512046267", "bodyText": "Similar to how we passed conf all the way from HBaseTestingUtility methods to actual HRegion instance, we can also pass rsServices instance in same methods and we won't have to worry about changing this to non-final, but not a strong opinion if this means too many args in testing utility methods so it's upto you.", "author": "virajjasani", "createdAt": "2020-10-26T15:23:15Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -688,14 +688,17 @@ void sawNoSuchFamily() {\n   // Last flush time for each Store. Useful when we are flushing for each column\n   private final ConcurrentMap<HStore, Long> lastStoreFlushTimeMap = new ConcurrentHashMap<>();\n \n-  final RegionServerServices rsServices;\n+  protected RegionServerServices rsServices;", "originalCommit": "9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA4OTU3Nw==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512089577", "bodyText": "In the HRegion tests I mock RSS with mockito, to test if the HRegion code calls RSS#abort as it should. We don't need to make a real cluster test that aborts a server (and adds a lot of time to the unit test suite) just to confirm this. So, it needs to be nonfinal for mocking, but it does not need to be exposed as a settable thing, because nowhere else in the code is there a use for that.", "author": "apurtell", "createdAt": "2020-10-26T16:19:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA0NjI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MDcwOQ==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512050709", "bodyText": "Test category LargeTests will take care of timeouts so we can remove all timeout from individual tests.", "author": "virajjasani", "createdAt": "2020-10-26T15:28:39Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRegionInterrupt.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.regionserver;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.HBaseClassTestRule;\n+import org.apache.hadoop.hbase.HBaseTestingUtility;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.NotServingRegionException;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.TableNameTestRule;\n+import org.apache.hadoop.hbase.Waiter;\n+import org.apache.hadoop.hbase.client.Admin;\n+import org.apache.hadoop.hbase.client.Append;\n+import org.apache.hadoop.hbase.client.BufferedMutator;\n+import org.apache.hadoop.hbase.client.ColumnFamilyDescriptorBuilder;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Durability;\n+import org.apache.hadoop.hbase.client.Increment;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.client.ResultScanner;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.client.Table;\n+import org.apache.hadoop.hbase.client.TableDescriptor;\n+import org.apache.hadoop.hbase.client.TableDescriptorBuilder;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.RegionCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.coprocessor.RegionObserver;\n+import org.apache.hadoop.hbase.exceptions.DeserializationException;\n+import org.apache.hadoop.hbase.filter.FilterBase;\n+import org.apache.hadoop.hbase.testclassification.LargeTests;\n+import org.apache.hadoop.hbase.testclassification.RegionServerTests;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALEdit;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Category({RegionServerTests.class, LargeTests.class})\n+public class TestRegionInterrupt {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule CLASS_RULE =\n+    HBaseClassTestRule.forClass(TestRegionInterrupt.class);\n+\n+  private static HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();\n+  private static final Logger LOG = LoggerFactory.getLogger(TestRegionInterrupt.class);\n+\n+  static final int SLEEP_TIME = 10 * 1000;\n+  static final byte[] FAMILY = Bytes.toBytes(\"info\");\n+\n+  @Rule\n+  public TableNameTestRule name = new TableNameTestRule();\n+\n+  @BeforeClass\n+  public static void setUpBeforeClass() throws Exception {\n+    Configuration conf = TEST_UTIL.getConfiguration();\n+    conf.setClass(HConstants.REGION_IMPL, InterruptInterceptingHRegion.class, Region.class);\n+    conf.setBoolean(HRegion.CLOSE_WAIT_ABORT, true);\n+    conf.setInt(HConstants.HBASE_CLIENT_RETRIES_NUMBER, 1);\n+  }\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    TEST_UTIL.startMiniCluster();\n+  }\n+\n+  @After\n+  public void tearDown() throws Exception {\n+    TEST_UTIL.shutdownMiniCluster();\n+  }\n+\n+  @Test(timeout=120000)", "originalCommit": "9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE2ODM4OA==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512168388", "bodyText": "Ok", "author": "apurtell", "createdAt": "2020-10-26T18:09:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MDcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1NDgzNQ==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512054835", "bodyText": "We don't want to restrict 5 min of wait time by updating CLOSE_WAIT_TIME ?", "author": "virajjasani", "createdAt": "2020-10-26T15:33:52Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestRegionInterrupt.java", "diffHunk": "@@ -0,0 +1,356 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.regionserver;\n+\n+import static org.junit.Assert.assertTrue;\n+\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hbase.Cell;\n+import org.apache.hadoop.hbase.HBaseClassTestRule;\n+import org.apache.hadoop.hbase.HBaseTestingUtility;\n+import org.apache.hadoop.hbase.HConstants;\n+import org.apache.hadoop.hbase.NotServingRegionException;\n+import org.apache.hadoop.hbase.TableName;\n+import org.apache.hadoop.hbase.TableNameTestRule;\n+import org.apache.hadoop.hbase.Waiter;\n+import org.apache.hadoop.hbase.client.Admin;\n+import org.apache.hadoop.hbase.client.Append;\n+import org.apache.hadoop.hbase.client.BufferedMutator;\n+import org.apache.hadoop.hbase.client.ColumnFamilyDescriptorBuilder;\n+import org.apache.hadoop.hbase.client.Delete;\n+import org.apache.hadoop.hbase.client.Durability;\n+import org.apache.hadoop.hbase.client.Increment;\n+import org.apache.hadoop.hbase.client.Put;\n+import org.apache.hadoop.hbase.client.RegionInfo;\n+import org.apache.hadoop.hbase.client.Result;\n+import org.apache.hadoop.hbase.client.ResultScanner;\n+import org.apache.hadoop.hbase.client.Scan;\n+import org.apache.hadoop.hbase.client.Table;\n+import org.apache.hadoop.hbase.client.TableDescriptor;\n+import org.apache.hadoop.hbase.client.TableDescriptorBuilder;\n+import org.apache.hadoop.hbase.coprocessor.ObserverContext;\n+import org.apache.hadoop.hbase.coprocessor.RegionCoprocessor;\n+import org.apache.hadoop.hbase.coprocessor.RegionCoprocessorEnvironment;\n+import org.apache.hadoop.hbase.coprocessor.RegionObserver;\n+import org.apache.hadoop.hbase.exceptions.DeserializationException;\n+import org.apache.hadoop.hbase.filter.FilterBase;\n+import org.apache.hadoop.hbase.testclassification.LargeTests;\n+import org.apache.hadoop.hbase.testclassification.RegionServerTests;\n+import org.apache.hadoop.hbase.util.Bytes;\n+import org.apache.hadoop.hbase.wal.WAL;\n+import org.apache.hadoop.hbase.wal.WALEdit;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.experimental.categories.Category;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Category({RegionServerTests.class, LargeTests.class})\n+public class TestRegionInterrupt {\n+\n+  @ClassRule\n+  public static final HBaseClassTestRule CLASS_RULE =\n+    HBaseClassTestRule.forClass(TestRegionInterrupt.class);\n+\n+  private static HBaseTestingUtility TEST_UTIL = new HBaseTestingUtility();\n+  private static final Logger LOG = LoggerFactory.getLogger(TestRegionInterrupt.class);\n+\n+  static final int SLEEP_TIME = 10 * 1000;\n+  static final byte[] FAMILY = Bytes.toBytes(\"info\");\n+\n+  @Rule\n+  public TableNameTestRule name = new TableNameTestRule();\n+\n+  @BeforeClass\n+  public static void setUpBeforeClass() throws Exception {\n+    Configuration conf = TEST_UTIL.getConfiguration();\n+    conf.setClass(HConstants.REGION_IMPL, InterruptInterceptingHRegion.class, Region.class);\n+    conf.setBoolean(HRegion.CLOSE_WAIT_ABORT, true);", "originalCommit": "9f1c0546380f1b28d5c37fea1fbcff7bfd4f028a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA5MDk1OA==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512090958", "bodyText": "Let me restate this as what I think you were getting at: \"Can we set a shorter abort interval so this test will not run for a long time if interrupts do not work as expected?\"\nSure, ok.", "author": "apurtell", "createdAt": "2020-10-26T16:21:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1NDgzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjE3NjY1Ng==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512176656", "bodyText": "Done", "author": "apurtell", "createdAt": "2020-10-26T18:23:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1NDgzNQ=="}], "type": "inlineReview"}, {"oid": "c08de396bcb508eb2272af20a4bd103d9e9734a8", "url": "https://github.com/apache/hbase/commit/c08de396bcb508eb2272af20a4bd103d9e9734a8", "message": "- Use a smaller interval than the close wait limit when attempting to acquire\n  the region close lock. Wait for one lock acquisition attempt before interrupting\n  region opeations. Repeat interrupts at this interval until the lock is acquired\n  or the maximum close wait time has been reached. If we interrupt too soon we are\n  too aggressive. Allowing some time for operations in flight to complete is\n  reasonable. This has added benefit of retrying the interrupt attempt in the\n  event that one or more handlers were not interrupted because third party code\n  swallowed the interrupt.\n\n- Use a less conservative default close wait limit of 1 minute (60000 ms).\n\n- Address more review feedback.\n\n- Fix a race problem with TestHRegion#testCloseAbort where we may need to\n  return a valid ServerName from the mock RegionServerServices.", "committedDate": "2020-10-26T20:24:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQwNDkzMg==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512404932", "bodyText": "Could we only call checkInterrupt() once before or after WAL synced, instead of a check after every step.\nPersonally I incline to check after WAL synced.\nIt also makes sense to call before WAL synced if considering the sync issue which occasionally happen.", "author": "Reidddddd", "createdAt": "2020-10-27T04:07:56Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -4569,13 +4665,29 @@ private void doMiniBatchMutate(BatchOperation<?> batchOp) throws IOException {\n       // We should record the timestamp only after we have acquired the rowLock,\n       // otherwise, newer puts/deletes/increment/append are not guaranteed to have a newer\n       // timestamp\n+\n+      // Check for thread interrupt status in case we have been signaled from\n+      // #interruptRegionOperation.\n+      checkInterrupt();\n+\n       long now = EnvironmentEdgeManager.currentTime();\n       batchOp.prepareMiniBatchOperations(miniBatchOp, now, acquiredRowLocks);\n \n       // STEP 3. Build WAL edit\n+\n+      // Check for thread interrupt status in case we have been signaled from\n+      // #interruptRegionOperation.\n+      checkInterrupt();\n+\n       List<Pair<NonceKey, WALEdit>> walEdits = batchOp.buildWALEdits(miniBatchOp);\n \n       // STEP 4. Append the WALEdits to WAL and sync.\n+\n+      // Check for thread interrupt status in case we have been signaled from\n+      // #interruptRegionOperation. This is the last place we can do it \"safely\" before\n+      // WAL appends.\n+      checkInterrupt();\n+", "originalCommit": "c08de396bcb508eb2272af20a4bd103d9e9734a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkzNzY4OA==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512937688", "bodyText": "The steps here are each loops, so there's a chance that a fair amount of time elapses between each step, which is why I thought checking after each step offered value beyond just checking once.", "author": "apurtell", "createdAt": "2020-10-27T18:36:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQwNDkzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk1NzM2NQ==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512957365", "bodyText": "@Reidddddd I would agree checking beyond WAL sync would be useful if and only if we decide to protect WAL syncs from interrupts. Otherwise the sync will be interrupted and we will break out of the RPC processing with an IOException with cause InterruptedException (from the WAL sync future).", "author": "apurtell", "createdAt": "2020-10-27T19:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQwNDkzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2NTcwMw==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r512965703", "bodyText": "Since we are on the topic of WAL syncs....\nWe could protect against interrupting a sync using a couple of different approaches. The simplest in the context of this proposed change would be to remove the current handler thread from the regionLockHolders set whenever we decide interrupting it is no longer the best choice, like a point of no return on the mutation code path.\nstartRegionOperation(Operation.PUT); // add thread to the set so it is interruptible\ntry {\n    ...\n    startWALOperation(); // remove thread from the set so it will not be interrupted\n    try {\n        ...\n    } finally {\n        endWALOperation(); // add thread to the set so it is eligible to be interrupted again\n    }\n    ...\n} finally {\n    endRegionOperation();  // remove thread from the set as it is no longer actively handling RPC\n}\n\nHowever we already have issues with sync timeouts or regionserver aborts during sync such that we are not introducing anything new here. In other words, if it is problematic that a WAL sync can be aborted before it completes, this already happens for other reasons, like timeouts (presumably because HDFS is slow), or HDFS level  pipeline recovery failure, or server shutdown.\nThinking about this though makes me think of the English expression \"opening a can of worms\". I don't know of a Chinese equivalent. I'm going to implement the proposal above out of an abundance of caution and we can decide upon further review if it makes sense.", "author": "apurtell", "createdAt": "2020-10-27T19:23:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQwNDkzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1NDEyMA==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r513154120", "bodyText": "the new commit LGTM, let's wait QA.", "author": "Reidddddd", "createdAt": "2020-10-28T03:12:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQwNDkzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDIyMjQ2Mg==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r514222462", "bodyText": "After reading this discussion several times, I think the reason we do not want to niterrupte a WAL sync is that it may lead to a region server abort?\nI would say this is not the case here. I checked the code again, the actual sync is done in the disruptor thread, in the rpc thread we just block on a SyncFuture(as Andrew mentioned above), the interruption on the rpc thread will just lead to an IOException tp client, the actual sync operation will not be interrupted so we are safe.\nSo I do not think we need to disable interrupts here?", "author": "Apache9", "createdAt": "2020-10-29T12:33:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQwNDkzMg=="}], "type": "inlineReview"}, {"oid": "3f0bc125cdb864af04895c86990cfcebe6eed6da", "url": "https://github.com/apache/hbase/commit/3f0bc125cdb864af04895c86990cfcebe6eed6da", "message": "- Protect WAL append and memstore update from interrupts when processing mutations\n\n- New unit test", "committedDate": "2020-10-28T01:33:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMzk1MA==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r513623950", "bodyText": "nit: Amend the comment to add what this boolean means?", "author": "bharathv", "createdAt": "2020-10-28T17:17:59Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -688,14 +689,17 @@ void sawNoSuchFamily() {\n   // Last flush time for each Store. Useful when we are flushing for each column\n   private final ConcurrentMap<HStore, Long> lastStoreFlushTimeMap = new ConcurrentHashMap<>();\n \n-  final RegionServerServices rsServices;\n+  protected RegionServerServices rsServices;\n   private RegionServerAccounting rsAccounting;\n   private long flushCheckInterval;\n   // flushPerChanges is to prevent too many changes in memstore\n   private long flushPerChanges;\n   private long blockingMemStoreSize;\n   // Used to guard closes\n   final ReentrantReadWriteLock lock;\n+  // Used to track interruptible holders of the region lock\n+  // Currently that is only RPC handler threads\n+  final ConcurrentHashMap<Thread, Boolean> regionLockHolders;", "originalCommit": "3f0bc125cdb864af04895c86990cfcebe6eed6da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYzMTAwNA==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r513631004", "bodyText": "Ok", "author": "apurtell", "createdAt": "2020-10-28T17:27:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYyMzk1MA=="}], "type": "inlineReview"}, {"oid": "7254af38791750d4b6c584959c5aa66c66cf75a0", "url": "https://github.com/apache/hbase/commit/7254af38791750d4b6c584959c5aa66c66cf75a0", "message": "Update comment in HRegion to address review feedback", "committedDate": "2020-10-28T22:11:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg5NzkzNw==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r513897937", "bodyText": "Only one q left, read operations are interruptible, but i couldn't find new interruption handling in read path. Do we just leave it as it is? (just for confirmation)", "author": "Reidddddd", "createdAt": "2020-10-29T02:49:04Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -8730,12 +8868,22 @@ public void startRegionOperation() throws IOException {\n \n   @Override\n   public void startRegionOperation(Operation op) throws IOException {\n+    boolean isInterruptableOp = false;\n     switch (op) {\n-      case GET:  // read operations\n+      case GET:  // interruptible read operations\n       case SCAN:\n+        isInterruptableOp = true;", "originalCommit": "7254af38791750d4b6c584959c5aa66c66cf75a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDMzNzE5Mg==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r514337192", "bodyText": "There are some checkInterrupts placed inside the scanner inner loops. Get, Exist, and Scan operations all share this path. I did not put checkInterrupt into the checkAndXXX operations because these are point ops that will complete quickly, but could if you feel this represents missing coverage. @Reidddddd\nOn the write path there are checkInterrupts placed at points in doMiniBatchMutation to catch the cases where we are likely to run a long time, and the row mutation processor also checks for interrupts. Again not every operation has a check, like Increment or Append, where the unit of work is small, but we could add them there too if you feel this represents missing coverage.\nMy opinion is the long running cases are where the check is definitely worth it -- scanners on the read side, batch mutations on the write side -- and others are marginal (and therefore not included).", "author": "apurtell", "createdAt": "2020-10-29T15:12:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg5NzkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE2MDU4NA==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r514160584", "bodyText": "nit: entry.getValue() is enough", "author": "virajjasani", "createdAt": "2020-10-29T10:39:18Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -9000,6 +9173,51 @@ public long getReadPoint() {\n     return getReadPoint(IsolationLevel.READ_COMMITTED);\n   }\n \n+  /**\n+   * Interrupt any region options that have acquired the region lock via\n+   * {@link #startRegionOperation(org.apache.hadoop.hbase.regionserver.Region.Operation)},\n+   * or {@link #startBulkRegionOperation(boolean)}.\n+   */\n+  private void interruptRegionOperations() {\n+    for (Map.Entry<Thread, Boolean> entry: regionLockHolders.entrySet()) {\n+      // An entry in this map will have a boolean value indicating if it is currently\n+      // eligible for interrupt; if so, we should interrupt it.\n+      if (entry.getValue().booleanValue()) {", "originalCommit": "7254af38791750d4b6c584959c5aa66c66cf75a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQwMDk1MA==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r514400950", "bodyText": "The generated code will be the same. I opted for this to be pedantic in the code. It should be fine, right?", "author": "apurtell", "createdAt": "2020-10-29T16:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE2MDU4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDIxNzUzMA==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r514217530", "bodyText": "Why remove these comments? They are not the cases for now?", "author": "Apache9", "createdAt": "2020-10-29T12:24:52Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -8777,23 +8936,36 @@ public void closeRegionOperation(Operation operation) throws IOException {\n     if (operation == Operation.SNAPSHOT) {\n       stores.values().forEach(HStore::postSnapshotOperation);\n     }\n+    regionLockHolders.remove(Thread.currentThread());\n     lock.readLock().unlock();\n     if (coprocessorHost != null) {\n       coprocessorHost.postCloseRegionOperation(operation);\n     }\n   }\n \n+  /**\n+   * If a handler thread is eligible for interrupt, make it ineligible. Should be paired\n+   * with {{@link #enableInterrupts()}.\n+   */\n+  protected void disableInterrupts() {\n+    regionLockHolders.computeIfPresent(Thread.currentThread(), (t,b) -> false);\n+  }\n+\n+  /**\n+   * If a handler thread was made ineligible for interrupt via {{@link #disableInterrupts()},\n+   * make it eligible again. No-op if interrupts are already enabled.\n+   */\n+  protected void enableInterrupts() {\n+    regionLockHolders.computeIfPresent(Thread.currentThread(), (t,b) -> true);\n+  }\n+\n   /**\n    * This method needs to be called before any public call that reads or\n    * modifies stores in bulk. It has to be called just before a try.\n    * #closeBulkRegionOperation needs to be called in the try's finally block\n    * Acquires a writelock and checks if the region is closing or closed.\n-   * @throws NotServingRegionException when the region is closing or closed", "originalCommit": "7254af38791750d4b6c584959c5aa66c66cf75a0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQwMDQ4OQ==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r514400489", "bodyText": "I can put them back but I believe this was done in response to feedback from another reviewer", "author": "apurtell", "createdAt": "2020-10-29T16:33:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDIxNzUzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQwMTQzNA==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r515401434", "bodyText": "Fixed this, put the javadoc back", "author": "apurtell", "createdAt": "2020-10-30T22:00:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDIxNzUzMA=="}], "type": "inlineReview"}, {"oid": "2baafa4b5cdff6c49bbb3f45aef4f12e7ae1e8a7", "url": "https://github.com/apache/hbase/commit/2baafa4b5cdff6c49bbb3f45aef4f12e7ae1e8a7", "message": "Remove some checkInterrupt calls to address review feedback", "committedDate": "2020-10-30T17:10:32Z", "type": "forcePushed"}, {"oid": "cc294feae5ddffaf0779bde22866ca0f29a49c60", "url": "https://github.com/apache/hbase/commit/cc294feae5ddffaf0779bde22866ca0f29a49c60", "message": "Protect WAL append and memstore update from interrupts when processing mutations", "committedDate": "2020-10-30T21:33:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk5MDU2NQ==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r515990565", "bodyText": "I think here we could have a checkInterrupt? And for me, I think before STEP 4, we could always interrupt the handler but I wonder whether it worth. The prepare mini batch and build WAL are all in memory operations so they should be fast. So I suggest that, we call checkInterrupt here, if we pass, then remove the handler from the Map.", "author": "Apache9", "createdAt": "2020-11-02T14:01:53Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -4565,17 +4663,23 @@ private void doMiniBatchMutate(BatchOperation<?> batchOp) throws IOException {\n       lock(this.updatesLock.readLock(), miniBatchOp.getReadyToWriteCount());\n       locked = true;\n \n+      // From this point until memstore update this operation should not be interrupted.\n+      disableInterrupts();", "originalCommit": "e5a714d32e88ef6543d2d7f575c7ae6ad18b5484", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2NjkwMg==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r516166902", "bodyText": "Yes, here I can put a checkInterrupt. Let me do that.\nIf we remove the handler from the map at this point, no other mini batch will be eligible for interrupt.\nbatchMutate does this:\nwhile (!batchOp.isDone()) {\n    ...\n    doMiniBatchMutate(batchOp);\n    ...\n  }", "author": "apurtell", "createdAt": "2020-11-02T18:15:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk5MDU2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjM1NzE0OQ==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r516357149", "bodyText": "Oh, you are right, I recall that we have a loop and will only acquire row locks as many as possible in each loop. Then this should be fine.", "author": "Apache9", "createdAt": "2020-11-03T00:22:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk5MDU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk5MTg5Mg==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r515991892", "bodyText": "I wonder whether it is possible to return what we have to client instead of throwing an exception to client. Anyway, Can be a follow on issue, not a blocker here.", "author": "Apache9", "createdAt": "2020-11-02T14:03:53Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -7623,6 +7740,9 @@ protected boolean nextRow(ScannerContext scannerContext, Cell curRowCell) throws\n       Cell next;\n       while ((next = this.storeHeap.peek()) != null &&\n              CellUtil.matchingRows(next, curRowCell)) {\n+        // Check for thread interrupt status in case we have been signaled from\n+        // #interruptRegionOperation.\n+        checkInterrupt();", "originalCommit": "e5a714d32e88ef6543d2d7f575c7ae6ad18b5484", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2Nzg4Mg==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r516167882", "bodyText": "Good point. Agreed it would be a good follow up.", "author": "apurtell", "createdAt": "2020-11-02T18:16:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk5MTg5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk5MjI1OA==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r515992258", "bodyText": "Same with the doMiniBatchMutation above.", "author": "Apache9", "createdAt": "2020-11-02T14:04:28Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -8303,9 +8428,14 @@ public void processRowsWithLocks(RowProcessor<?,?> processor, long timeout,\n             prevRowLock = rowLock;\n           }\n         }\n+\n         // STEP 3. Region lock\n         lock(this.updatesLock.readLock(), acquiredRowLocks.isEmpty() ? 1 : acquiredRowLocks.size());\n         locked = true;\n+\n+        // From this point until memstore update this operation should not be interrupted.\n+        disableInterrupts();", "originalCommit": "e5a714d32e88ef6543d2d7f575c7ae6ad18b5484", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE2NzY2Nw==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r516167667", "bodyText": "Will add a checkInterrupt here too.", "author": "apurtell", "createdAt": "2020-11-02T18:16:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk5MjI1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjE3MTAzMg==", "url": "https://github.com/apache/hbase/pull/2574#discussion_r516171032", "bodyText": "This code is not executed in a loop so removing the thread from the map would be fine. However the reason why I also do disable/enable interrupt is as follows: We already have to do this for doMiniBatchMutation. (The disable/enable pair in doMiniBatchMutation protects WAL update and memstore insert from interrupt and makes them \"atomic\" in this sense, and disable/enable makes sense there because doMiniBatchMutation is inside a loop.) The disable/enable interrupt pair is a new code discipline. This section of the code also has the same requirements. Apply the new code discipline here too for consistency.", "author": "apurtell", "createdAt": "2020-11-02T18:22:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk5MjI1OA=="}], "type": "inlineReview"}, {"oid": "ebd92f644f3bc1b33be8e63ba47f69bc580f0b0e", "url": "https://github.com/apache/hbase/commit/ebd92f644f3bc1b33be8e63ba47f69bc580f0b0e", "message": "HBASE-25212 Optionally abort requests in progress after deciding a region should close\n\nIf hbase.regionserver.close.wait.abort is set to true, interrupt RPC\nhandler threads holding the region close lock.\n\nUntil requests in progress can be aborted, wait on the region close lock\nfor a configurable interval (specified by hbase.regionserver.close.wait.time,\nin ms). If we have failed to acquire the close lock after this interval\nelapses, if allowed (also specified by hbase.regionserver.close.wait.abort),\nabort the regionserver.\n\nDefine a subset of region operations as interruptable. Track threads holding\nthe close lock transiting those operations. Set the thread interrupt status\nof tracked threads when trying to close the region. Use the thread interrupt\nstatus where safe to break out of request processing.", "committedDate": "2020-11-03T19:30:50Z", "type": "commit"}, {"oid": "3464d3cb7f4bed20dee2c17780c7b57b8a85e280", "url": "https://github.com/apache/hbase/commit/3464d3cb7f4bed20dee2c17780c7b57b8a85e280", "message": "Address review feedback\n\n- Address review feedback\n- Fix spotbugs warnings\n- Fix checkstyle nit\n- Fix new unit tests, missed a needed HTU change for master branch\n- Fix more unit tests after HTU change\n- Reduce chance of race conditions in new TestHRegion units by joining on lock holder", "committedDate": "2020-11-03T19:30:50Z", "type": "commit"}, {"oid": "b3ddf8a7c6ba91ee9566293ac56ec0b17a9111c2", "url": "https://github.com/apache/hbase/commit/b3ddf8a7c6ba91ee9566293ac56ec0b17a9111c2", "message": "Fix more checkstyle nits", "committedDate": "2020-11-03T19:30:50Z", "type": "commit"}, {"oid": "75f9bd82a1b0ceaecfcc7921be825beb7fc33811", "url": "https://github.com/apache/hbase/commit/75f9bd82a1b0ceaecfcc7921be825beb7fc33811", "message": "Set HRegion#DEFAULT_CLOSE_WAIT_ABORT to true", "committedDate": "2020-11-03T19:30:50Z", "type": "commit"}, {"oid": "9ea937c9fb054b85da0b780e8d446eaf51128ebf", "url": "https://github.com/apache/hbase/commit/9ea937c9fb054b85da0b780e8d446eaf51128ebf", "message": "- Use a smaller interval than the close wait limit when attempting to acquire\n  the region close lock. Wait for one lock acquisition attempt before interrupting\n  region opeations. Repeat interrupts at this interval until the lock is acquired\n  or the maximum close wait time has been reached. If we interrupt too soon we are\n  too aggressive. Allowing some time for operations in flight to complete is\n  reasonable. This has added benefit of retrying the interrupt attempt in the\n  event that one or more handlers were not interrupted because third party code\n  swallowed the interrupt.\n\n- Use a less conservative default close wait limit of 1 minute (60000 ms).\n\n- Address more review feedback.\n\n- Fix a race problem with TestHRegion#testCloseAbort where we may need to\n  return a valid ServerName from the mock RegionServerServices.", "committedDate": "2020-11-03T19:30:50Z", "type": "commit"}, {"oid": "de723a08458fb15cbd897dcf01f7cf146d550702", "url": "https://github.com/apache/hbase/commit/de723a08458fb15cbd897dcf01f7cf146d550702", "message": "Remove some checkInterrupt calls to address review feedback", "committedDate": "2020-11-03T19:30:50Z", "type": "commit"}, {"oid": "3159bafa664ed70399e2c02b41b4f58c1f271593", "url": "https://github.com/apache/hbase/commit/3159bafa664ed70399e2c02b41b4f58c1f271593", "message": "Protect WAL append and memstore update from interrupts when processing mutations", "committedDate": "2020-11-03T19:30:50Z", "type": "commit"}, {"oid": "b6eccdf7b94a5c573509618c0f3c9d194d5c354b", "url": "https://github.com/apache/hbase/commit/b6eccdf7b94a5c573509618c0f3c9d194d5c354b", "message": "Put back accidentally removed javadoc", "committedDate": "2020-11-03T19:30:50Z", "type": "commit"}, {"oid": "bedb3cf6dfb5ebbe16314d0f5f33fafce3e5ae2b", "url": "https://github.com/apache/hbase/commit/bedb3cf6dfb5ebbe16314d0f5f33fafce3e5ae2b", "message": "Call checkInterrupt before disableInterrupt to address review feedback.", "committedDate": "2020-11-03T20:04:37Z", "type": "commit"}, {"oid": "bedb3cf6dfb5ebbe16314d0f5f33fafce3e5ae2b", "url": "https://github.com/apache/hbase/commit/bedb3cf6dfb5ebbe16314d0f5f33fafce3e5ae2b", "message": "Call checkInterrupt before disableInterrupt to address review feedback.", "committedDate": "2020-11-03T20:04:37Z", "type": "forcePushed"}]}