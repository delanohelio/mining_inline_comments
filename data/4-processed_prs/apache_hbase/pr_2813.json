{"pr_number": 2813, "pr_title": "HBASE-23898 Add trace support for simple apis in async client", "pr_createdAt": "2020-12-24T16:26:14Z", "pr_url": "https://github.com/apache/hbase/pull/2813", "timeline": [{"oid": "83d054828320b501ad27c25b9e1e421c2f3ab622", "url": "https://github.com/apache/hbase/commit/83d054828320b501ad27c25b9e1e421c2f3ab622", "message": "HBASE-23898 Add trace support for simple apis in async client", "committedDate": "2020-12-25T00:52:30Z", "type": "forcePushed"}, {"oid": "6377c0fffb8019705f72e59b2edfc4344179d15f", "url": "https://github.com/apache/hbase/commit/6377c0fffb8019705f72e59b2edfc4344179d15f", "message": "HBASE-23898 Add trace support for simple apis in async client", "committedDate": "2020-12-25T16:12:40Z", "type": "forcePushed"}, {"oid": "e3e926521855a85c6ae18dfdf9155396f5e73843", "url": "https://github.com/apache/hbase/commit/e3e926521855a85c6ae18dfdf9155396f5e73843", "message": "HBASE-23898 Add trace support for simple apis in async client", "committedDate": "2020-12-26T06:19:26Z", "type": "forcePushed"}, {"oid": "a9a3fb231bb8f957ecce6112622930f8452cfe0e", "url": "https://github.com/apache/hbase/commit/a9a3fb231bb8f957ecce6112622930f8452cfe0e", "message": "HBASE-23898 Add trace support for simple apis in async client", "committedDate": "2020-12-26T15:50:03Z", "type": "forcePushed"}, {"oid": "c714daa3d0410c86761c46edc8f5fbe1d6ea3a95", "url": "https://github.com/apache/hbase/commit/c714daa3d0410c86761c46edc8f5fbe1d6ea3a95", "message": "HBASE-23898 Add trace support for simple apis in async client", "committedDate": "2020-12-27T14:44:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE5MjIxMg==", "url": "https://github.com/apache/hbase/pull/2813#discussion_r549192212", "bodyText": "Do we need to trace getName or getConfiguration methods? These methods should not cost too much time.", "author": "infraio", "createdAt": "2020-12-28T02:14:26Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncTableImpl.java", "diffHunk": "@@ -49,85 +51,103 @@\n   private final ExecutorService pool;\n \n   AsyncTableImpl(AsyncConnectionImpl conn, AsyncTable<AdvancedScanResultConsumer> rawTable,\n-      ExecutorService pool) {\n+    ExecutorService pool) {\n     this.rawTable = rawTable;\n     this.pool = pool;\n   }\n \n+  @WithSpan(\"AsyncTableImpl.getName\")\n   @Override\n   public TableName getName() {", "originalCommit": "c714daa3d0410c86761c46edc8f5fbe1d6ea3a95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI3MjcwOQ==", "url": "https://github.com/apache/hbase/pull/2813#discussion_r549272709", "bodyText": "OK, let's remove.", "author": "Apache9", "createdAt": "2020-12-28T09:11:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE5MjIxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE5MzE4OA==", "url": "https://github.com/apache/hbase/pull/2813#discussion_r549193188", "bodyText": "For AsyncTable, its get() method is implemented by RawAsyncTable's get() method. So here will trace two times? But AsyncTable's get() method's cost time should be very close with RawAsyncTable's get() method. Do we need to trace them both? And I thought the \"trace tool\" may be more useful for RPC call. For local call stacktrace, profiler tool is more useful?", "author": "infraio", "createdAt": "2020-12-28T02:21:15Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/RawAsyncTableImpl.java", "diffHunk": "@@ -218,50 +222,62 @@ private static Result toResult(HBaseRpcController controller, MutateResponse res\n \n   @Override\n   public CompletableFuture<Result> get(Get get) {\n-    return timelineConsistentRead(conn.getLocator(), tableName, get, get.getRow(),\n-      RegionLocateType.CURRENT, replicaId -> get(get, replicaId), readRpcTimeoutNs,\n-      conn.connConf.getPrimaryCallTimeoutNs(), retryTimer, conn.getConnectionMetrics());\n+    return tracedFuture(", "originalCommit": "c714daa3d0410c86761c46edc8f5fbe1d6ea3a95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI3MjQ2Mw==", "url": "https://github.com/apache/hbase/pull/2813#discussion_r549272463", "bodyText": "So you mean we just do not need to add trace support for methods declared in AsyncTable interface, as finally they will call other methods which should already been traced?", "author": "Apache9", "createdAt": "2020-12-28T09:11:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE5MzE4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ3NDg5NA==", "url": "https://github.com/apache/hbase/pull/2813#discussion_r549474894", "bodyText": "Good to keep the trace macro at first.... entrance and exit, yeah. Simple. Later, when demand, can add trace across internal 'systems'... is the time being taken adding to memstore or appending WAL -- that kinda thing.\nSo, yeah, entrance/exit on AsyncTable Interface methods would be good place to start I'd think.", "author": "saintstack", "createdAt": "2020-12-28T20:17:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTE5MzE4OA=="}], "type": "inlineReview"}, {"oid": "6b408f011e2998de4b6ec9eccfd66ca735ceaa50", "url": "https://github.com/apache/hbase/commit/6b408f011e2998de4b6ec9eccfd66ca735ceaa50", "message": "HBASE-23898 Add trace support for simple apis in async client", "committedDate": "2020-12-28T14:59:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ2ODYzOQ==", "url": "https://github.com/apache/hbase/pull/2813#discussion_r549468639", "bodyText": "Why this refactor? I noticed that closeQuietly has been deprecated over in commons-io for a long time (https://issues.apache.org/jira/browse/IO-504) suggesting try/with-resources instead and that closeQuietly is never done right.\nYou thinking the AssertionError never happens? Or if it does, it is game over?", "author": "saintstack", "createdAt": "2020-12-28T19:53:33Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncConnectionImpl.java", "diffHunk": "@@ -203,26 +204,36 @@ public boolean isClosed() {\n     return closed.get();\n   }\n \n+  private void closeQuietly(Closeable c) {", "originalCommit": "6b408f011e2998de4b6ec9eccfd66ca735ceaa50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ3MDAyOQ==", "url": "https://github.com/apache/hbase/pull/2813#discussion_r549470029", "bodyText": "Looks like this is a change in behavior. The default IOUtils seems to have suppressed the IOE... https://github.com/apache/commons-io/blob/18b80a32fc9979dbd23cc971093ac308e5fd77cc/src/main/java/org/apache/commons/io/IOUtils.java#L485 (I didn't go back to look at old impls).", "author": "saintstack", "createdAt": "2020-12-28T19:58:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ2ODYzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUzOTcwMg==", "url": "https://github.com/apache/hbase/pull/2813#discussion_r549539702", "bodyText": "The old implementation just suppress the exception without logging. For guava Closeables, it will never throw IOException if threw is false.\nSo the suggestion is to upgrade the commons-io and uses the new methods?\nCan revert here as it is not a big deal for the PR here.", "author": "Apache9", "createdAt": "2020-12-29T01:49:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ2ODYzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQ3MDg1NQ==", "url": "https://github.com/apache/hbase/pull/2813#discussion_r549470855", "bodyText": "I like this clean insertion of trace future listener", "author": "saintstack", "createdAt": "2020-12-28T20:01:55Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/AsyncRegionLocator.java", "diffHunk": "@@ -84,64 +96,101 @@ private boolean isMeta(TableName tableName) {\n     return TableName.isMetaTableName(tableName);\n   }\n \n+  private <T> CompletableFuture<T> tracedLocationFuture(Supplier<CompletableFuture<T>> action,\n+    Function<T, List<String>> getRegionNames, TableName tableName, String methodName) {\n+    Span span = createTableSpan(getClass().getSimpleName() + \".\" + methodName, tableName);\n+    try (Scope scope = span.makeCurrent()) {\n+      CompletableFuture<T> future = action.get();\n+      FutureUtils.addListener(future, (resp, error) -> {\n+        if (error != null) {\n+          span.recordException(error);\n+          span.setStatus(StatusCode.ERROR);\n+        } else {\n+          List<String> regionNames = getRegionNames.apply(resp);\n+          if (!regionNames.isEmpty()) {\n+            span.setAttribute(REGION_NAMES_KEY, regionNames);\n+          }\n+          span.setStatus(StatusCode.OK);\n+        }\n+        span.end();\n+      });\n+      return future;\n+    }\n+  }\n+\n+  private List<String> getRegionName(RegionLocations locs) {\n+    List<String> names = new ArrayList<>();\n+    for (HRegionLocation loc : locs.getRegionLocations()) {\n+      if (loc != null) {\n+        names.add(loc.getRegion().getRegionNameAsString());\n+      }\n+    }\n+    return names;\n+  }\n+\n   CompletableFuture<RegionLocations> getRegionLocations(TableName tableName, byte[] row,\n-      RegionLocateType type, boolean reload, long timeoutNs) {\n-    CompletableFuture<RegionLocations> future = isMeta(tableName)\n-      ? metaRegionLocator.getRegionLocations(RegionReplicaUtil.DEFAULT_REPLICA_ID, reload)\n-      : nonMetaRegionLocator.getRegionLocations(tableName, row,\n-        RegionReplicaUtil.DEFAULT_REPLICA_ID, type, reload);\n-    return withTimeout(future, timeoutNs,\n-      () -> \"Timeout(\" + TimeUnit.NANOSECONDS.toMillis(timeoutNs) +\n-        \"ms) waiting for region locations for \" + tableName + \", row='\" +\n-        Bytes.toStringBinary(row) + \"'\");\n+    RegionLocateType type, boolean reload, long timeoutNs) {\n+    return tracedLocationFuture(() -> {\n+      CompletableFuture<RegionLocations> future = isMeta(tableName) ?\n+        metaRegionLocator.getRegionLocations(RegionReplicaUtil.DEFAULT_REPLICA_ID, reload) :\n+        nonMetaRegionLocator.getRegionLocations(tableName, row,\n+          RegionReplicaUtil.DEFAULT_REPLICA_ID, type, reload);\n+      return withTimeout(future, timeoutNs,\n+        () -> \"Timeout(\" + TimeUnit.NANOSECONDS.toMillis(timeoutNs) +\n+          \"ms) waiting for region locations for \" + tableName + \", row='\" +\n+          Bytes.toStringBinary(row) + \"'\");\n+    }, this::getRegionName, tableName, \"getRegionLocations\");\n   }\n \n   CompletableFuture<HRegionLocation> getRegionLocation(TableName tableName, byte[] row,\n-      int replicaId, RegionLocateType type, boolean reload, long timeoutNs) {\n-    // meta region can not be split right now so we always call the same method.\n-    // Change it later if the meta table can have more than one regions.\n-    CompletableFuture<HRegionLocation> future = new CompletableFuture<>();\n-    CompletableFuture<RegionLocations> locsFuture =\n-      isMeta(tableName) ? metaRegionLocator.getRegionLocations(replicaId, reload)\n-        : nonMetaRegionLocator.getRegionLocations(tableName, row, replicaId, type, reload);\n-    addListener(locsFuture, (locs, error) -> {\n-      if (error != null) {\n-        future.completeExceptionally(error);\n-        return;\n-      }\n-      HRegionLocation loc = locs.getRegionLocation(replicaId);\n-      if (loc == null) {\n-        future.completeExceptionally(\n-          new RegionOfflineException(\"No location for \" + tableName + \", row='\" +\n-            Bytes.toStringBinary(row) + \"', locateType=\" + type + \", replicaId=\" + replicaId));\n-      } else if (loc.getServerName() == null) {\n-        future.completeExceptionally(\n-          new RegionOfflineException(\"No server address listed for region '\" +\n-            loc.getRegion().getRegionNameAsString() + \", row='\" + Bytes.toStringBinary(row) +\n-            \"', locateType=\" + type + \", replicaId=\" + replicaId));\n-      } else {\n-        future.complete(loc);\n-      }\n-    });\n-    return withTimeout(future, timeoutNs,\n-      () -> \"Timeout(\" + TimeUnit.NANOSECONDS.toMillis(timeoutNs) +\n-        \"ms) waiting for region location for \" + tableName + \", row='\" + Bytes.toStringBinary(row) +\n-        \"', replicaId=\" + replicaId);\n+    int replicaId, RegionLocateType type, boolean reload, long timeoutNs) {\n+    return tracedLocationFuture(() -> {\n+      // meta region can not be split right now so we always call the same method.\n+      // Change it later if the meta table can have more than one regions.\n+      CompletableFuture<HRegionLocation> future = new CompletableFuture<>();\n+      CompletableFuture<RegionLocations> locsFuture =\n+        isMeta(tableName) ? metaRegionLocator.getRegionLocations(replicaId, reload) :\n+          nonMetaRegionLocator.getRegionLocations(tableName, row, replicaId, type, reload);\n+      addListener(locsFuture, (locs, error) -> {\n+        if (error != null) {\n+          future.completeExceptionally(error);\n+          return;\n+        }\n+        HRegionLocation loc = locs.getRegionLocation(replicaId);\n+        if (loc == null) {\n+          future.completeExceptionally(\n+            new RegionOfflineException(\"No location for \" + tableName + \", row='\" +\n+              Bytes.toStringBinary(row) + \"', locateType=\" + type + \", replicaId=\" + replicaId));\n+        } else if (loc.getServerName() == null) {\n+          future.completeExceptionally(\n+            new RegionOfflineException(\"No server address listed for region '\" +\n+              loc.getRegion().getRegionNameAsString() + \", row='\" + Bytes.toStringBinary(row) +\n+              \"', locateType=\" + type + \", replicaId=\" + replicaId));\n+        } else {\n+          future.complete(loc);\n+        }\n+      });\n+      return withTimeout(future, timeoutNs,\n+        () -> \"Timeout(\" + TimeUnit.NANOSECONDS.toMillis(timeoutNs) +\n+          \"ms) waiting for region location for \" + tableName + \", row='\" +\n+          Bytes.toStringBinary(row) + \"', replicaId=\" + replicaId);\n+    }, loc -> Arrays.asList(loc.getRegion().getRegionNameAsString()), tableName,\n+      \"getRegionLocation\");", "originalCommit": "6b408f011e2998de4b6ec9eccfd66ca735ceaa50", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b4d24235061e6c8e2ea8111eedd2a721b47d5c64", "url": "https://github.com/apache/hbase/commit/b4d24235061e6c8e2ea8111eedd2a721b47d5c64", "message": "HBASE-23898 Add trace support for simple apis in async client", "committedDate": "2020-12-29T06:22:22Z", "type": "commit"}, {"oid": "b4d24235061e6c8e2ea8111eedd2a721b47d5c64", "url": "https://github.com/apache/hbase/commit/b4d24235061e6c8e2ea8111eedd2a721b47d5c64", "message": "HBASE-23898 Add trace support for simple apis in async client", "committedDate": "2020-12-29T06:22:22Z", "type": "forcePushed"}, {"oid": "0b0c3d01568070bcf86a9f28409e2687481eafa5", "url": "https://github.com/apache/hbase/commit/0b0c3d01568070bcf86a9f28409e2687481eafa5", "message": "fix checkstyle issue", "committedDate": "2020-12-29T08:06:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTk1MzA1Mg==", "url": "https://github.com/apache/hbase/pull/2813#discussion_r549953052", "bodyText": "Typo: getSpanName not used anymore as you use AsyncTable.xxx directly.\nLGTM overall.", "author": "infraio", "createdAt": "2020-12-30T06:43:53Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/RawAsyncTableImpl.java", "diffHunk": "@@ -218,50 +220,62 @@ private static Result toResult(HBaseRpcController controller, MutateResponse res\n \n   @Override\n   public CompletableFuture<Result> get(Get get) {\n-    return timelineConsistentRead(conn.getLocator(), tableName, get, get.getRow(),\n-      RegionLocateType.CURRENT, replicaId -> get(get, replicaId), readRpcTimeoutNs,\n-      conn.connConf.getPrimaryCallTimeoutNs(), retryTimer, conn.getConnectionMetrics());\n+    return tracedFuture(\n+      () -> timelineConsistentRead(conn.getLocator(), tableName, get, get.getRow(),\n+        RegionLocateType.CURRENT, replicaId -> get(get, replicaId), readRpcTimeoutNs,\n+        conn.connConf.getPrimaryCallTimeoutNs(), retryTimer, conn.getConnectionMetrics()),\n+      \"AsyncTable.get\", tableName);\n+  }\n+\n+  private String getSpanName(String methodName) {", "originalCommit": "0b0c3d01568070bcf86a9f28409e2687481eafa5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c8a51ec0147d0b3a47980d68bc0a73ad0dc7283a", "url": "https://github.com/apache/hbase/commit/c8a51ec0147d0b3a47980d68bc0a73ad0dc7283a", "message": "remove unused method", "committedDate": "2020-12-30T06:56:54Z", "type": "commit"}]}