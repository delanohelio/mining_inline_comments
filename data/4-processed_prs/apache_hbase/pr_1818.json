{"pr_number": 1818, "pr_title": "HBASE-24456 : Create ImmutableScan and use it for CustomizedScanInfoBuilder", "pr_createdAt": "2020-05-31T12:09:33Z", "pr_url": "https://github.com/apache/hbase/pull/1818", "timeline": [{"oid": "d95ec8a260b3c4c2f5de68d235ee4170b58d0dc4", "url": "https://github.com/apache/hbase/commit/d95ec8a260b3c4c2f5de68d235ee4170b58d0dc4", "message": "HBASE-24456 : Create ImmutableScan and use it for CustomizedScanInfoBuilder", "committedDate": "2020-05-31T12:04:52Z", "type": "commit"}, {"oid": "bb27ee6b2874f9048c66ae943e05b54080ac9fbb", "url": "https://github.com/apache/hbase/commit/bb27ee6b2874f9048c66ae943e05b54080ac9fbb", "message": "minor change", "committedDate": "2020-05-31T16:37:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMTM0Ng==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433111346", "bodyText": "Do we really want this to be public?", "author": "Apache9", "createdAt": "2020-06-01T08:40:17Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ImmutableScan.java", "diffHunk": "@@ -0,0 +1,477 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import org.apache.hadoop.hbase.filter.Filter;\n+import org.apache.hadoop.hbase.io.TimeRange;\n+import org.apache.hadoop.hbase.security.access.Permission;\n+import org.apache.hadoop.hbase.security.visibility.Authorizations;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * Immutable version of Scan\n+ */\n+@InterfaceAudience.Public", "originalCommit": "bb27ee6b2874f9048c66ae943e05b54080ac9fbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExOTk0Mw==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433119943", "bodyText": "Hmm, not really, I thought maybe downstreamers can use it but I don't have strong opinion here, let me make it Private? or LimitedPrivate?", "author": "virajjasani", "createdAt": "2020-06-01T08:59:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMTM0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzNTA5OA==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433135098", "bodyText": "My opinion is to only expose Scan to users, just like Collections.unmodifiableCollection will still return a Collection. For now, the only usecase is in CustomizedScanInfoBuilder, I prefer we do not expose too much, unless in the future we find other usages.", "author": "Apache9", "createdAt": "2020-06-01T09:34:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMTM0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEzODkyNw==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433138927", "bodyText": "Sure, will keep it Private then.", "author": "virajjasani", "createdAt": "2020-06-01T09:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMTM0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMTk1NA==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433111954", "bodyText": "Is it necessary to return a ImmutableScan for this method?", "author": "Apache9", "createdAt": "2020-06-01T08:41:39Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ImmutableScan.java", "diffHunk": "@@ -0,0 +1,477 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import org.apache.hadoop.hbase.filter.Filter;\n+import org.apache.hadoop.hbase.io.TimeRange;\n+import org.apache.hadoop.hbase.security.access.Permission;\n+import org.apache.hadoop.hbase.security.visibility.Authorizations;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * Immutable version of Scan\n+ */\n+@InterfaceAudience.Public\n+public final class ImmutableScan extends Scan {\n+\n+  /**\n+   * Create Immutable instance of Scan from given Scan object\n+   *\n+   * @param scan Copy all values from Scan\n+   * @throws IOException From parent constructor\n+   */\n+  public ImmutableScan(Scan scan) throws IOException {\n+    super(scan);\n+    super.setIsolationLevel(scan.getIsolationLevel());\n+    Map<byte[], NavigableSet<byte[]>> familyMap = scan.getFamilyMap();\n+    for (Map.Entry<byte[], NavigableSet<byte[]>> entry : familyMap.entrySet()) {\n+      byte[] family = entry.getKey();\n+      NavigableSet<byte[]> cols = entry.getValue();\n+      if (cols != null && cols.size() > 0) {\n+        for (byte[] col : cols) {\n+          super.addColumn(family, col);\n+        }\n+      } else {\n+        super.addFamily(family);\n+      }\n+    }\n+    for (Map.Entry<String, byte[]> attr : scan.getAttributesMap().entrySet()) {\n+      super.setAttribute(attr.getKey(), attr.getValue());\n+    }\n+    for (Map.Entry<byte[], TimeRange> entry : scan.getColumnFamilyTimeRange().entrySet()) {\n+      TimeRange tr = entry.getValue();\n+      super.setColumnFamilyTimeRange(entry.getKey(), tr.getMin(), tr.getMax());\n+    }\n+    super.setPriority(scan.getPriority());\n+  }\n+\n+  /**\n+   * Create Immutable instance of Scan from given Get object\n+   *\n+   * @param get Get to model Scan after\n+   */\n+  public ImmutableScan(Get get) {\n+    super(get);\n+    super.setIsolationLevel(get.getIsolationLevel());\n+    for (Map.Entry<String, byte[]> attr : get.getAttributesMap().entrySet()) {\n+      super.setAttribute(attr.getKey(), attr.getValue());\n+    }\n+    for (Map.Entry<byte[], TimeRange> entry : get.getColumnFamilyTimeRange().entrySet()) {\n+      TimeRange tr = entry.getValue();\n+      super.setColumnFamilyTimeRange(entry.getKey(), tr.getMin(), tr.getMax());\n+    }\n+    super.setPriority(get.getPriority());\n+  }\n+\n+  /**\n+   * Create a new Scan with a cursor. It only set the position information like start row key.\n+   * The others (like cfs, stop row, limit) should still be filled in by the user.\n+   * {@link Result#isCursor()}\n+   * {@link Result#getCursor()}\n+   * {@link Cursor}\n+   */\n+  public static Scan createScanFromCursor(Cursor cursor) {", "originalCommit": "bb27ee6b2874f9048c66ae943e05b54080ac9fbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyMTY3MA==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433121670", "bodyText": "I believe so, well we don't have any usecase yet, but given a cursor, what if user really want to get ImmutableScan similar to Scan. Hence, similar to Scan.createScanFromCursor(), client can use ImmutableScan.createScanFromCursor(). Sounds good?", "author": "virajjasani", "createdAt": "2020-06-01T09:02:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMTk1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIyMTMyOA==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433221328", "bodyText": "This ImmutableScan is not exposed and will not be exposed in future also. This is a way for us to make sure the CPs wont try set any thing on the passed Scan object.  So why we need this createScanFromCursor() method at all?   Because of this u have this isObjInit based code in many places. Keep it simple I would say. Just get rid of all these.", "author": "anoopsjohn", "createdAt": "2020-06-01T13:04:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMTk1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI0MzkwOQ==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433243909", "bodyText": "@anoopsjohn isObjInit is for different purpose. When we call parent Scan constructors, they call few setter methods. And ImmutableScan is not supposed to support setter methods, but this time object is getting initialized and hence, we need to allow it.\ne.g.\n  public Scan addFamily(byte[] family) {\n    if (!isObjInit) {\n      return super.addFamily(family);\n    }\n    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to addFamily\");\n  }\n\nHere, addFamily is being called by Scan constructor which is called by ImmutableScan as part of super call. However, when Scan constructor calls addFamily, the control goes to the implementation provided in child class ImmutableScan. Now, ImmutableScan will throw UnsupportedOperationException saying we don't allow setter calls. Hence, I had to introduce isObjInit which is set to true only after super constructor calls, which means setter methods will call corresponding parent setter methods if object is being initialized, and once it is initialized, all setters will throw UnsupportedOperationException.\nPlease check my recent commit: a075e17\nYou will get the idea of what kind of hack I had to do in parent class to avoid calling child class methods :)", "author": "virajjasani", "createdAt": "2020-06-01T13:47:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMTk1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4NzUyMA==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433387520", "bodyText": "can we try making ImmutableScan as a wrapper over actual Scan object.  The setters in the ImmutableScan can throw Exception and getter can just delegate to original Scan object", "author": "anoopsjohn", "createdAt": "2020-06-01T17:42:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMTk1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQxMDQwNg==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433410406", "bodyText": "We can have wrapper but providing Scan object (which is Immutable by nature) to coprocessor hooks sounds better. Even though we provide Scan object to store scanner coproc hooks, it is Immutable as per the use-case and that is something HBase can take care of.\nMoreover, dev adding new method to Scan are more likely to override it in ImmutableScan class because all methods are overridden(they can get IDE hints) but they are less likely to realize usage of each method in some wrapper class and add the method in wrapper.\nHowever, if we have better pros of using wrapper, I am fine with that also.\nThoughts?", "author": "virajjasani", "createdAt": "2020-06-01T18:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMTk1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQzMTgxMQ==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433431811", "bodyText": "It is not just wrapper.  ImmutableScan will have both is-a and has-a relationship.  So what we will pass to CPs will be Scan type only. In reality that will be a wrapper.", "author": "anoopsjohn", "createdAt": "2020-06-01T19:07:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMTk1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg3NTQ2NQ==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433875465", "bodyText": "@anoopsjohn changes are done. Please take a look.", "author": "virajjasani", "createdAt": "2020-06-02T13:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMTk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMjA3Mg==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433112072", "bodyText": "UnsupportedOperationException or IllegalStateException?", "author": "Apache9", "createdAt": "2020-06-01T08:41:56Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ImmutableScan.java", "diffHunk": "@@ -0,0 +1,477 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import org.apache.hadoop.hbase.filter.Filter;\n+import org.apache.hadoop.hbase.io.TimeRange;\n+import org.apache.hadoop.hbase.security.access.Permission;\n+import org.apache.hadoop.hbase.security.visibility.Authorizations;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * Immutable version of Scan\n+ */\n+@InterfaceAudience.Public\n+public final class ImmutableScan extends Scan {\n+\n+  /**\n+   * Create Immutable instance of Scan from given Scan object\n+   *\n+   * @param scan Copy all values from Scan\n+   * @throws IOException From parent constructor\n+   */\n+  public ImmutableScan(Scan scan) throws IOException {\n+    super(scan);\n+    super.setIsolationLevel(scan.getIsolationLevel());\n+    Map<byte[], NavigableSet<byte[]>> familyMap = scan.getFamilyMap();\n+    for (Map.Entry<byte[], NavigableSet<byte[]>> entry : familyMap.entrySet()) {\n+      byte[] family = entry.getKey();\n+      NavigableSet<byte[]> cols = entry.getValue();\n+      if (cols != null && cols.size() > 0) {\n+        for (byte[] col : cols) {\n+          super.addColumn(family, col);\n+        }\n+      } else {\n+        super.addFamily(family);\n+      }\n+    }\n+    for (Map.Entry<String, byte[]> attr : scan.getAttributesMap().entrySet()) {\n+      super.setAttribute(attr.getKey(), attr.getValue());\n+    }\n+    for (Map.Entry<byte[], TimeRange> entry : scan.getColumnFamilyTimeRange().entrySet()) {\n+      TimeRange tr = entry.getValue();\n+      super.setColumnFamilyTimeRange(entry.getKey(), tr.getMin(), tr.getMax());\n+    }\n+    super.setPriority(scan.getPriority());\n+  }\n+\n+  /**\n+   * Create Immutable instance of Scan from given Get object\n+   *\n+   * @param get Get to model Scan after\n+   */\n+  public ImmutableScan(Get get) {\n+    super(get);\n+    super.setIsolationLevel(get.getIsolationLevel());\n+    for (Map.Entry<String, byte[]> attr : get.getAttributesMap().entrySet()) {\n+      super.setAttribute(attr.getKey(), attr.getValue());\n+    }\n+    for (Map.Entry<byte[], TimeRange> entry : get.getColumnFamilyTimeRange().entrySet()) {\n+      TimeRange tr = entry.getValue();\n+      super.setColumnFamilyTimeRange(entry.getKey(), tr.getMin(), tr.getMax());\n+    }\n+    super.setPriority(get.getPriority());\n+  }\n+\n+  /**\n+   * Create a new Scan with a cursor. It only set the position information like start row key.\n+   * The others (like cfs, stop row, limit) should still be filled in by the user.\n+   * {@link Result#isCursor()}\n+   * {@link Result#getCursor()}\n+   * {@link Cursor}\n+   */\n+  public static Scan createScanFromCursor(Cursor cursor) {\n+    Scan scan = new Scan().withStartRow(cursor.getRow());\n+    try {\n+      return new ImmutableScan(scan);\n+    } catch (IOException e) {\n+      throw new RuntimeException(\"Scan should not throw IOException\", e);\n+    }\n+  }\n+\n+  @Override\n+  public Scan addFamily(byte[] family) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to addFamily\");", "originalCommit": "bb27ee6b2874f9048c66ae943e05b54080ac9fbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyMTg1OQ==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433121859", "bodyText": "Oh, UnsupportedOperationException is better. will update.", "author": "virajjasani", "createdAt": "2020-06-01T09:03:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMjA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMjI4NQ==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433112285", "bodyText": "Do not need to implement these methods?", "author": "Apache9", "createdAt": "2020-06-01T08:42:25Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ImmutableScan.java", "diffHunk": "@@ -0,0 +1,477 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import org.apache.hadoop.hbase.filter.Filter;\n+import org.apache.hadoop.hbase.io.TimeRange;\n+import org.apache.hadoop.hbase.security.access.Permission;\n+import org.apache.hadoop.hbase.security.visibility.Authorizations;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * Immutable version of Scan\n+ */\n+@InterfaceAudience.Public\n+public final class ImmutableScan extends Scan {\n+\n+  /**\n+   * Create Immutable instance of Scan from given Scan object\n+   *\n+   * @param scan Copy all values from Scan\n+   * @throws IOException From parent constructor\n+   */\n+  public ImmutableScan(Scan scan) throws IOException {\n+    super(scan);\n+    super.setIsolationLevel(scan.getIsolationLevel());\n+    Map<byte[], NavigableSet<byte[]>> familyMap = scan.getFamilyMap();\n+    for (Map.Entry<byte[], NavigableSet<byte[]>> entry : familyMap.entrySet()) {\n+      byte[] family = entry.getKey();\n+      NavigableSet<byte[]> cols = entry.getValue();\n+      if (cols != null && cols.size() > 0) {\n+        for (byte[] col : cols) {\n+          super.addColumn(family, col);\n+        }\n+      } else {\n+        super.addFamily(family);\n+      }\n+    }\n+    for (Map.Entry<String, byte[]> attr : scan.getAttributesMap().entrySet()) {\n+      super.setAttribute(attr.getKey(), attr.getValue());\n+    }\n+    for (Map.Entry<byte[], TimeRange> entry : scan.getColumnFamilyTimeRange().entrySet()) {\n+      TimeRange tr = entry.getValue();\n+      super.setColumnFamilyTimeRange(entry.getKey(), tr.getMin(), tr.getMax());\n+    }\n+    super.setPriority(scan.getPriority());\n+  }\n+\n+  /**\n+   * Create Immutable instance of Scan from given Get object\n+   *\n+   * @param get Get to model Scan after\n+   */\n+  public ImmutableScan(Get get) {\n+    super(get);\n+    super.setIsolationLevel(get.getIsolationLevel());\n+    for (Map.Entry<String, byte[]> attr : get.getAttributesMap().entrySet()) {\n+      super.setAttribute(attr.getKey(), attr.getValue());\n+    }\n+    for (Map.Entry<byte[], TimeRange> entry : get.getColumnFamilyTimeRange().entrySet()) {\n+      TimeRange tr = entry.getValue();\n+      super.setColumnFamilyTimeRange(entry.getKey(), tr.getMin(), tr.getMax());\n+    }\n+    super.setPriority(get.getPriority());\n+  }\n+\n+  /**\n+   * Create a new Scan with a cursor. It only set the position information like start row key.\n+   * The others (like cfs, stop row, limit) should still be filled in by the user.\n+   * {@link Result#isCursor()}\n+   * {@link Result#getCursor()}\n+   * {@link Cursor}\n+   */\n+  public static Scan createScanFromCursor(Cursor cursor) {\n+    Scan scan = new Scan().withStartRow(cursor.getRow());\n+    try {\n+      return new ImmutableScan(scan);\n+    } catch (IOException e) {\n+      throw new RuntimeException(\"Scan should not throw IOException\", e);\n+    }\n+  }\n+\n+  @Override\n+  public Scan addFamily(byte[] family) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to addFamily\");\n+  }\n+\n+  @Override\n+  public Scan addColumn(byte[] family, byte[] qualifier) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to addColumn\");\n+  }\n+\n+  @Override\n+  public Scan setTimeRange(long minStamp, long maxStamp) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setTimeRange\");\n+  }\n+\n+  @Deprecated\n+  @Override\n+  public Scan setTimeStamp(long timestamp) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setTimeStamp\");\n+  }\n+\n+  @Override\n+  public Scan setTimestamp(long timestamp) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setTimestamp\");\n+  }\n+\n+  @Override\n+  public Scan setColumnFamilyTimeRange(byte[] cf, long minStamp, long maxStamp) {\n+    throw new IllegalStateException(\n+      \"ImmutableScan does not allow access to setColumnFamilyTimeRange\");\n+  }\n+\n+  @Override\n+  public Scan withStartRow(byte[] startRow) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to withStartRow\");\n+  }\n+\n+  @Override\n+  public Scan withStartRow(byte[] startRow, boolean inclusive) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to withStartRow\");\n+  }\n+\n+  @Override\n+  public Scan withStopRow(byte[] stopRow) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to withStopRow\");\n+  }\n+\n+  @Override\n+  public Scan withStopRow(byte[] stopRow, boolean inclusive) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to withStopRow\");\n+  }\n+\n+  @Override\n+  public Scan setRowPrefixFilter(byte[] rowPrefix) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setRowPrefixFilter\");\n+  }\n+\n+  @Override\n+  public Scan readAllVersions() {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to readAllVersions\");\n+  }\n+\n+  @Override\n+  public Scan readVersions(int versions) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to readVersions\");\n+  }\n+\n+  @Override\n+  public Scan setBatch(int batch) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setBatch\");\n+  }\n+\n+  @Override\n+  public Scan setMaxResultsPerColumnFamily(int limit) {\n+    throw new IllegalStateException(\n+      \"ImmutableScan does not allow access to setMaxResultsPerColumnFamily\");\n+  }\n+\n+  @Override\n+  public Scan setRowOffsetPerColumnFamily(int offset) {\n+    throw new IllegalStateException(\n+      \"ImmutableScan does not allow access to setRowOffsetPerColumnFamily\");\n+  }\n+\n+  @Override\n+  public Scan setCaching(int caching) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setCaching\");\n+  }\n+\n+  @Override\n+  public Scan setMaxResultSize(long maxResultSize) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setMaxResultSize\");\n+  }\n+\n+  @Override\n+  public Scan setFilter(Filter filter) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setFilter\");\n+  }\n+\n+  @Override\n+  public Scan setFamilyMap(Map<byte[], NavigableSet<byte[]>> familyMap) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setFamilyMap\");\n+  }\n+\n+  @Override\n+  public Scan setCacheBlocks(boolean cacheBlocks) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setCacheBlocks\");\n+  }\n+\n+  @Override\n+  public Scan setReversed(boolean reversed) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setReversed\");\n+  }\n+\n+  @Override\n+  public Scan setAllowPartialResults(final boolean allowPartialResults) {\n+    throw new IllegalStateException(\n+      \"ImmutableScan does not allow access to setAllowPartialResults\");\n+  }\n+\n+  @Override\n+  public Scan setLoadColumnFamiliesOnDemand(boolean value) {\n+    throw new IllegalStateException(\n+      \"ImmutableScan does not allow access to setLoadColumnFamiliesOnDemand\");\n+  }\n+\n+  @Override\n+  public Scan setRaw(boolean raw) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setRaw\");\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public Scan setSmall(boolean small) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setSmall\");\n+  }\n+\n+  @Override\n+  public Scan setAttribute(String name, byte[] value) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setAttribute\");\n+  }\n+\n+  @Override\n+  public Scan setId(String id) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setId\");\n+  }\n+\n+  @Override\n+  public Scan setAuthorizations(Authorizations authorizations) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setAuthorizations\");\n+  }\n+\n+  @Override\n+  public Scan setACL(Map<String, Permission> perms) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setACL\");\n+  }\n+\n+  @Override\n+  public Scan setACL(String user, Permission perms) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setACL\");\n+  }\n+\n+  @Override\n+  public Scan setConsistency(Consistency consistency) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setConsistency\");\n+  }\n+\n+  @Override\n+  public Scan setReplicaId(int Id) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setReplicaId\");\n+  }\n+\n+  @Override\n+  public Scan setIsolationLevel(IsolationLevel level) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setIsolationLevel\");\n+  }\n+\n+  @Override\n+  public Scan setPriority(int priority) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setPriority\");\n+  }\n+\n+  @Override\n+  public Scan setScanMetricsEnabled(final boolean enabled) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setScanMetricsEnabled\");\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public Scan setAsyncPrefetch(boolean asyncPrefetch) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setAsyncPrefetch\");\n+  }\n+\n+  @Override\n+  public Scan setLimit(int limit) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setLimit\");\n+  }\n+\n+  @Override\n+  public Scan setOneRowLimit() {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setOneRowLimit\");\n+  }\n+\n+  @Override\n+  public Scan setReadType(ReadType readType) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setReadType\");\n+  }\n+\n+  @Override\n+  Scan setMvccReadPoint(long mvccReadPoint) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setMvccReadPoint\");\n+  }\n+\n+  @Override\n+  Scan resetMvccReadPoint() {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to resetMvccReadPoint\");\n+  }\n+\n+  @Override\n+  public Scan setNeedCursorResult(boolean needCursorResult) {\n+    throw new IllegalStateException(\"ImmutableScan does not allow access to setNeedCursorResult\");\n+  }\n+\n+  @Override\n+  public long getMaxResultSize() {\n+    return super.getMaxResultSize();", "originalCommit": "bb27ee6b2874f9048c66ae943e05b54080ac9fbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyMjQ5NQ==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433122495", "bodyText": "Yes, not all are required but the reason why I prefer to keep them is because when any dev introduces new public/protected method in Scan, they can realize (with IDE's help) that all other methods are overridden in ImmutableScan and if the return value is Collection or something worth converting to Unmodifiable, they can do it, and always maintain a practice of overriding it in at least ImmutableScan.", "author": "virajjasani", "createdAt": "2020-06-01T09:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMjI4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMjQ1Mw==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433112453", "bodyText": "Why?", "author": "Apache9", "createdAt": "2020-06-01T08:42:49Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/Query.java", "diffHunk": "@@ -164,7 +164,11 @@ public int getReplicaId() {\n    * @param level IsolationLevel for this query\n    */\n   public Query setIsolationLevel(IsolationLevel level) {\n-    setAttribute(ISOLATION_LEVEL, level.toBytes());\n+    if (this instanceof ImmutableScan) {", "originalCommit": "bb27ee6b2874f9048c66ae943e05b54080ac9fbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyMzMyMA==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433123320", "bodyText": "Because while constructing ImmutableScan(Scan), it calls parent Scan(Scan), which calls super.setIsolationLevel() and here, it calls setAttribute() which is overridden by ImmutableScan and hence, it will fail. I know this is not good check, but we do need to directly call super.setAttribute(), this.setAttribute() goes to ImmutableScan's setAttribute().", "author": "virajjasani", "createdAt": "2020-06-01T09:06:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMjQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMzIyMg==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433113222", "bodyText": "This is not a good practise... Cna we avoid this instanceof for testing a sub class in the parent class?", "author": "Apache9", "createdAt": "2020-06-01T08:44:24Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/Scan.java", "diffHunk": "@@ -200,35 +200,37 @@ public Scan(Scan scan) throws IOException {\n     filter = scan.getFilter(); // clone?\n     loadColumnFamiliesOnDemand = scan.getLoadColumnFamiliesOnDemandValue();\n     consistency = scan.getConsistency();\n-    this.setIsolationLevel(scan.getIsolationLevel());\n     reversed = scan.isReversed();\n     asyncPrefetch = scan.isAsyncPrefetch();\n     small = scan.isSmall();\n     allowPartialResults = scan.getAllowPartialResults();\n     tr = scan.getTimeRange(); // TimeRange is immutable\n-    Map<byte[], NavigableSet<byte[]>> fams = scan.getFamilyMap();\n-    for (Map.Entry<byte[],NavigableSet<byte[]>> entry : fams.entrySet()) {\n-      byte [] fam = entry.getKey();\n-      NavigableSet<byte[]> cols = entry.getValue();\n-      if (cols != null && cols.size() > 0) {\n-        for (byte[] col : cols) {\n-          addColumn(fam, col);\n+    if (!(this instanceof ImmutableScan)) {", "originalCommit": "bb27ee6b2874f9048c66ae943e05b54080ac9fbb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzEyMzk4OQ==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433123989", "bodyText": "I really tried for this but didn't find better solution. For any Immutable child class, it will have to call super constructor, and here in Scan constructor, it calls setter methods, so the control will go to child class's overridden setter methods, which will fail :(", "author": "virajjasani", "createdAt": "2020-06-01T09:08:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExMzIyMg=="}], "type": "inlineReview"}, {"oid": "a178112456d4b0df504a1491b187fb606994727c", "url": "https://github.com/apache/hbase/commit/a178112456d4b0df504a1491b187fb606994727c", "message": "addressing review", "committedDate": "2020-06-01T09:51:27Z", "type": "commit"}, {"oid": "a075e17f2dcf128e11d05de2630249fc3048de49", "url": "https://github.com/apache/hbase/commit/a075e17f2dcf128e11d05de2630249fc3048de49", "message": "setter unsupported if object is initialized", "committedDate": "2020-06-01T12:32:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIxOTMzNg==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433219336", "bodyText": "This is used by tests only ?\nDo u want to create ImmutableScan over a new Scan()?  Or direct new ImmutableScan is enough?", "author": "anoopsjohn", "createdAt": "2020-06-01T13:00:39Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/CustomizedScanInfoBuilder.java", "diffHunk": "@@ -42,13 +43,18 @@\n \n   public CustomizedScanInfoBuilder(ScanInfo scanInfo) {\n     this.scanInfo = scanInfo;\n-    this.scan = new Scan();\n+    try {\n+      this.scan = new ImmutableScan(new Scan());", "originalCommit": "a075e17f2dcf128e11d05de2630249fc3048de49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIzNzcxOA==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r433237718", "bodyText": "I just provided 2 constructors to ImmutableScan:\n\nImmutableScan(Scan scan)\nImmutableScan(Get get)\n\nI believe, given that this is Immutable subclass, providing default constructor might not be much useful. Even if we give, it will internally use this(new Scan()). Hence, I thought of not providing default constructor at all. Because ultimately, we want Immutable class to construct everything during initialization only and after init, no setters should be accessible. Thought?", "author": "virajjasani", "createdAt": "2020-06-01T13:36:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIxOTMzNg=="}], "type": "inlineReview"}, {"oid": "410fcff425f20786400cfd833a56af11eea6855d", "url": "https://github.com/apache/hbase/commit/410fcff425f20786400cfd833a56af11eea6855d", "message": "removing createScanFromCursor", "committedDate": "2020-06-01T13:57:38Z", "type": "commit"}, {"oid": "93613b91b896d17dd16245e75a26e0a655e5aa99", "url": "https://github.com/apache/hbase/commit/93613b91b896d17dd16245e75a26e0a655e5aa99", "message": "review comment - add delegate Scan", "committedDate": "2020-06-02T10:32:01Z", "type": "commit"}, {"oid": "1a1503b0435cb3a2675f0f85f51a721e7b18d0b2", "url": "https://github.com/apache/hbase/commit/1a1503b0435cb3a2675f0f85f51a721e7b18d0b2", "message": "testUnmodifiableSetters", "committedDate": "2020-06-02T10:38:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0MTA2Nw==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r434041067", "bodyText": "When it is delegate model, better get the delegate via constructor arg always. Let the creator pass a new Scan() to this explicitly. Pls avoid this constructor.", "author": "anoopsjohn", "createdAt": "2020-06-02T17:15:13Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ImmutableScan.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import org.apache.hadoop.hbase.exceptions.DeserializationException;\n+import org.apache.hadoop.hbase.filter.Filter;\n+import org.apache.hadoop.hbase.io.TimeRange;\n+import org.apache.hadoop.hbase.security.access.Permission;\n+import org.apache.hadoop.hbase.security.visibility.Authorizations;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * Immutable version of Scan\n+ */\n+@InterfaceAudience.Private\n+public final class ImmutableScan extends Scan {\n+\n+  private final Scan delegateScan;\n+\n+  /**\n+   * Create Immutable instance of Scan\n+   */\n+  public ImmutableScan() {", "originalCommit": "1a1503b0435cb3a2675f0f85f51a721e7b18d0b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0MjE2MQ==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r434042161", "bodyText": "Sure, let me handle this.", "author": "virajjasani", "createdAt": "2020-06-02T17:17:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0MTA2Nw=="}], "type": "inlineReview"}, {"oid": "f62b017dcb20d750eff56272d2d8d64a1253261b", "url": "https://github.com/apache/hbase/commit/f62b017dcb20d750eff56272d2d8d64a1253261b", "message": "addressing review", "committedDate": "2020-06-02T17:36:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0MTY5NQ==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r434041695", "bodyText": "As we are not exposing the original Scan directly, why to create a new Scan again here? No need", "author": "anoopsjohn", "createdAt": "2020-06-02T17:16:15Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ImmutableScan.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import org.apache.hadoop.hbase.exceptions.DeserializationException;\n+import org.apache.hadoop.hbase.filter.Filter;\n+import org.apache.hadoop.hbase.io.TimeRange;\n+import org.apache.hadoop.hbase.security.access.Permission;\n+import org.apache.hadoop.hbase.security.visibility.Authorizations;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * Immutable version of Scan\n+ */\n+@InterfaceAudience.Private\n+public final class ImmutableScan extends Scan {\n+\n+  private final Scan delegateScan;\n+\n+  /**\n+   * Create Immutable instance of Scan\n+   */\n+  public ImmutableScan() {\n+    this.delegateScan = new Scan();\n+  }\n+\n+  /**\n+   * Create Immutable instance of Scan from given Scan object\n+   *\n+   * @param scan Copy all values from Scan\n+   * @throws IOException From parent constructor\n+   */\n+  public ImmutableScan(Scan scan) throws IOException {\n+    this.delegateScan = new Scan(scan);", "originalCommit": "1a1503b0435cb3a2675f0f85f51a721e7b18d0b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA0MjM2MA==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r434042360", "bodyText": "As of now we dont have this constructor req right? If not better not add now. When there is a need, we can add. At the place where we create this ImmutableScan, already the Get would have been converted to scan", "author": "anoopsjohn", "createdAt": "2020-06-02T17:17:22Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ImmutableScan.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import org.apache.hadoop.hbase.exceptions.DeserializationException;\n+import org.apache.hadoop.hbase.filter.Filter;\n+import org.apache.hadoop.hbase.io.TimeRange;\n+import org.apache.hadoop.hbase.security.access.Permission;\n+import org.apache.hadoop.hbase.security.visibility.Authorizations;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * Immutable version of Scan\n+ */\n+@InterfaceAudience.Private\n+public final class ImmutableScan extends Scan {\n+\n+  private final Scan delegateScan;\n+\n+  /**\n+   * Create Immutable instance of Scan\n+   */\n+  public ImmutableScan() {\n+    this.delegateScan = new Scan();\n+  }\n+\n+  /**\n+   * Create Immutable instance of Scan from given Scan object\n+   *\n+   * @param scan Copy all values from Scan\n+   * @throws IOException From parent constructor\n+   */\n+  public ImmutableScan(Scan scan) throws IOException {\n+    this.delegateScan = new Scan(scan);\n+  }\n+\n+  /**\n+   * Create Immutable instance of Scan from given Get object\n+   *\n+   * @param get Get to model Scan after\n+   */\n+  public ImmutableScan(Get get) {", "originalCommit": "1a1503b0435cb3a2675f0f85f51a721e7b18d0b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1NDAzOA==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r434054038", "bodyText": "Just thinking whether we should be cloning this byte[]? Using this getter it is possible to really set a new start row for the scan (by direct changing byte(s) in this byte[]).", "author": "anoopsjohn", "createdAt": "2020-06-02T17:36:23Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ImmutableScan.java", "diffHunk": "@@ -0,0 +1,549 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import org.apache.hadoop.hbase.exceptions.DeserializationException;\n+import org.apache.hadoop.hbase.filter.Filter;\n+import org.apache.hadoop.hbase.io.TimeRange;\n+import org.apache.hadoop.hbase.security.access.Permission;\n+import org.apache.hadoop.hbase.security.visibility.Authorizations;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * Immutable version of Scan\n+ */\n+@InterfaceAudience.Private\n+public final class ImmutableScan extends Scan {\n+\n+  private final Scan delegateScan;\n+\n+  /**\n+   * Create Immutable instance of Scan\n+   */\n+  public ImmutableScan() {\n+    this.delegateScan = new Scan();\n+  }\n+\n+  /**\n+   * Create Immutable instance of Scan from given Scan object\n+   *\n+   * @param scan Copy all values from Scan\n+   * @throws IOException From parent constructor\n+   */\n+  public ImmutableScan(Scan scan) throws IOException {\n+    this.delegateScan = new Scan(scan);\n+  }\n+\n+  /**\n+   * Create Immutable instance of Scan from given Get object\n+   *\n+   * @param get Get to model Scan after\n+   */\n+  public ImmutableScan(Get get) {\n+    this.delegateScan = new Scan(get);\n+  }\n+\n+  @Override\n+  public Scan addFamily(byte[] family) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to addFamily\");\n+  }\n+\n+  @Override\n+  public Scan addColumn(byte[] family, byte[] qualifier) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to addColumn\");\n+  }\n+\n+  @Override\n+  public Scan setTimeRange(long minStamp, long maxStamp) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setTimeRange\");\n+  }\n+\n+  @Deprecated\n+  @Override\n+  public Scan setTimeStamp(long timestamp) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setTimeStamp\");\n+  }\n+\n+  @Override\n+  public Scan setTimestamp(long timestamp) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setTimestamp\");\n+  }\n+\n+  @Override\n+  public Scan setColumnFamilyTimeRange(byte[] cf, long minStamp, long maxStamp) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setColumnFamilyTimeRange\");\n+  }\n+\n+  @Override\n+  public Scan withStartRow(byte[] startRow) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to withStartRow\");\n+  }\n+\n+  @Override\n+  public Scan withStartRow(byte[] startRow, boolean inclusive) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to withStartRow\");\n+  }\n+\n+  @Override\n+  public Scan withStopRow(byte[] stopRow) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to withStopRow\");\n+  }\n+\n+  @Override\n+  public Scan withStopRow(byte[] stopRow, boolean inclusive) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to withStopRow\");\n+  }\n+\n+  @Override\n+  public Scan setRowPrefixFilter(byte[] rowPrefix) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setRowPrefixFilter\");\n+  }\n+\n+  @Override\n+  public Scan readAllVersions() {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to readAllVersions\");\n+  }\n+\n+  @Override\n+  public Scan readVersions(int versions) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to readVersions\");\n+  }\n+\n+  @Override\n+  public Scan setBatch(int batch) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setBatch\");\n+  }\n+\n+  @Override\n+  public Scan setMaxResultsPerColumnFamily(int limit) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setMaxResultsPerColumnFamily\");\n+  }\n+\n+  @Override\n+  public Scan setRowOffsetPerColumnFamily(int offset) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setRowOffsetPerColumnFamily\");\n+  }\n+\n+  @Override\n+  public Scan setCaching(int caching) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setCaching\");\n+  }\n+\n+  @Override\n+  public Scan setMaxResultSize(long maxResultSize) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setMaxResultSize\");\n+  }\n+\n+  @Override\n+  public Scan setFilter(Filter filter) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setFilter\");\n+  }\n+\n+  @Override\n+  public Scan setFamilyMap(Map<byte[], NavigableSet<byte[]>> familyMap) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setFamilyMap\");\n+  }\n+\n+  @Override\n+  public Scan setCacheBlocks(boolean cacheBlocks) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setCacheBlocks\");\n+  }\n+\n+  @Override\n+  public Scan setReversed(boolean reversed) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setReversed\");\n+  }\n+\n+  @Override\n+  public Scan setAllowPartialResults(final boolean allowPartialResults) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setAllowPartialResults\");\n+  }\n+\n+  @Override\n+  public Scan setLoadColumnFamiliesOnDemand(boolean value) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setLoadColumnFamiliesOnDemand\");\n+  }\n+\n+  @Override\n+  public Scan setRaw(boolean raw) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setRaw\");\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public Scan setSmall(boolean small) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setSmall\");\n+  }\n+\n+  @Override\n+  public Scan setAttribute(String name, byte[] value) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setAttribute\");\n+  }\n+\n+  @Override\n+  public Scan setId(String id) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setId\");\n+  }\n+\n+  @Override\n+  public Scan setAuthorizations(Authorizations authorizations) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setAuthorizations\");\n+  }\n+\n+  @Override\n+  public Scan setACL(Map<String, Permission> perms) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setACL\");\n+  }\n+\n+  @Override\n+  public Scan setACL(String user, Permission perms) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setACL\");\n+  }\n+\n+  @Override\n+  public Scan setConsistency(Consistency consistency) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setConsistency\");\n+  }\n+\n+  @Override\n+  public Scan setReplicaId(int id) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setReplicaId\");\n+  }\n+\n+  @Override\n+  public Scan setIsolationLevel(IsolationLevel level) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setIsolationLevel\");\n+  }\n+\n+  @Override\n+  public Scan setPriority(int priority) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setPriority\");\n+  }\n+\n+  @Override\n+  public Scan setScanMetricsEnabled(final boolean enabled) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setScanMetricsEnabled\");\n+  }\n+\n+  @Override\n+  @Deprecated\n+  public Scan setAsyncPrefetch(boolean asyncPrefetch) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setAsyncPrefetch\");\n+  }\n+\n+  @Override\n+  public Scan setLimit(int limit) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setLimit\");\n+  }\n+\n+  @Override\n+  public Scan setOneRowLimit() {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setOneRowLimit\");\n+  }\n+\n+  @Override\n+  public Scan setReadType(ReadType readType) {\n+    throw new UnsupportedOperationException(\"ImmutableScan does not allow access to setReadType\");\n+  }\n+\n+  @Override\n+  Scan setMvccReadPoint(long mvccReadPoint) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setMvccReadPoint\");\n+  }\n+\n+  @Override\n+  Scan resetMvccReadPoint() {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to resetMvccReadPoint\");\n+  }\n+\n+  @Override\n+  public Scan setNeedCursorResult(boolean needCursorResult) {\n+    throw new UnsupportedOperationException(\n+      \"ImmutableScan does not allow access to setNeedCursorResult\");\n+  }\n+\n+  @Override\n+  public long getMaxResultSize() {\n+    return this.delegateScan.getMaxResultSize();\n+  }\n+\n+  @Override\n+  public Map<byte[], NavigableSet<byte[]>> getFamilyMap() {\n+    return Collections.unmodifiableMap(this.delegateScan.getFamilyMap());\n+  }\n+\n+  @Override\n+  public int numFamilies() {\n+    return this.delegateScan.numFamilies();\n+  }\n+\n+  @Override\n+  public boolean hasFamilies() {\n+    return this.delegateScan.hasFamilies();\n+  }\n+\n+  @Override\n+  public byte[][] getFamilies() {\n+    return this.delegateScan.getFamilies();\n+  }\n+\n+  @Override\n+  public byte[] getStartRow() {", "originalCommit": "1a1503b0435cb3a2675f0f85f51a721e7b18d0b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDEyMDEwNA==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r434120104", "bodyText": "Yeah, makes sense. Done", "author": "virajjasani", "createdAt": "2020-06-02T19:17:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA1NDAzOA=="}], "type": "inlineReview"}, {"oid": "a45dc146ad10be412b3274c8958326215b0fcd1a", "url": "https://github.com/apache/hbase/commit/a45dc146ad10be412b3274c8958326215b0fcd1a", "message": "review", "committedDate": "2020-06-02T19:16:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc1MDI4NA==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r434750284", "bodyText": "Now we dont have to keep this throws IOE at this constructor.  So below catch stuff in CustomizedScanInfoBuilder also can be avoided.", "author": "anoopsjohn", "createdAt": "2020-06-03T17:53:29Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/client/ImmutableScan.java", "diffHunk": "@@ -0,0 +1,543 @@\n+/*\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.hbase.client;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.NavigableSet;\n+import org.apache.hadoop.hbase.exceptions.DeserializationException;\n+import org.apache.hadoop.hbase.filter.Filter;\n+import org.apache.hadoop.hbase.io.TimeRange;\n+import org.apache.hadoop.hbase.security.access.Permission;\n+import org.apache.hadoop.hbase.security.visibility.Authorizations;\n+import org.apache.yetus.audience.InterfaceAudience;\n+\n+/**\n+ * Immutable version of Scan\n+ */\n+@InterfaceAudience.Private\n+public final class ImmutableScan extends Scan {\n+\n+  private final Scan delegateScan;\n+\n+  /**\n+   * Create Immutable instance of Scan from given Scan object\n+   *\n+   * @param scan Copy all values from Scan\n+   * @throws IOException From parent constructor\n+   */\n+  public ImmutableScan(Scan scan) throws IOException {", "originalCommit": "a45dc146ad10be412b3274c8958326215b0fcd1a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc1ODQyMQ==", "url": "https://github.com/apache/hbase/pull/1818#discussion_r434758421", "bodyText": "Ohh, what a miss :(", "author": "virajjasani", "createdAt": "2020-06-03T18:07:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDc1MDI4NA=="}], "type": "inlineReview"}, {"oid": "ed78982d1c7be3388a13fbd9c0d8e0b22d55857e", "url": "https://github.com/apache/hbase/commit/ed78982d1c7be3388a13fbd9c0d8e0b22d55857e", "message": "review - Bytes.copy and remove IOE", "committedDate": "2020-06-03T18:14:18Z", "type": "commit"}]}