{"pr_number": 2058, "pr_title": "HBASE-24722 Address hbase-shell commands with unintentional return values", "pr_createdAt": "2020-07-13T15:35:26Z", "pr_url": "https://github.com/apache/hbase/pull/2058", "timeline": [{"oid": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9", "url": "https://github.com/apache/hbase/commit/58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9", "message": "HBASE-24722 Update commands with unintentional return values\n\n- Prior to this commit, there were 13 commands that unintentionally return the\n  number of lines they print (usually one). This commit ensures that they\n  return the value documented by the help text, or nil if there is not a simple\n  logical value to return.\n- Fixes 6 hbase-shell commands that return String rather than TrueClass or\n  FalseClass\n- Use double-bang to cast truthy values to TrueClass and FalseClass so that\n  ruby's to_s can reliably print true or false without using ternary operators\n- Updates tests for is_disabled, is_enabled, disable_rpc_throttle,\n  enable_rpc_throttle, disable_exceed_throttle_quota,\n  enable_exceed_throttle_quota, clear_deadservers, snapshot_cleanup_switch,\n  snapshot_cleanup_enabled, and balancer to check return values\n- Adds new tests for balance_switch, balancer_enabled, normalizer_switch,\n  normalizer_enabled, catalog_janitor_switch, catalogjanitor_enabled,\n  cleaner_chore_switch, cleaner_chore_enabled, splitormerge_switch, and\n  splitormerge_enabled", "committedDate": "2020-07-13T15:19:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc1NTIxNg==", "url": "https://github.com/apache/hbase/pull/2058#discussion_r453755216", "bodyText": "Does it make sense to put this pattern in a method?", "author": "madrob", "createdAt": "2020-07-13T15:56:36Z", "path": "hbase-shell/src/main/ruby/shell/commands/balancer.rb", "diffHunk": "@@ -44,7 +44,9 @@ def command(force = nil)\n         elsif !force.nil?\n           raise ArgumentError, \"Invalid argument #{force}.\"\n         end\n-        formatter.row([admin.balancer(force_balancer) ? 'true' : 'false'])\n+        did_balancer_run = !!admin.balancer(force_balancer)\n+        formatter.row([did_balancer_run.to_s])\n+        did_balancer_run", "originalCommit": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ2NzUyMQ==", "url": "https://github.com/apache/hbase/pull/2058#discussion_r454467521", "bodyText": "I think the simple implementation to encapsulate this pattern would be strange. I would rather leave this as is, and revisit the formatter more holistically as a separate ticket.", "author": "bitoffdev", "createdAt": "2020-07-14T16:02:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc1NTIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ3Mzc2Mg==", "url": "https://github.com/apache/hbase/pull/2058#discussion_r454473762", "bodyText": "Makes sense, can you create the follow-on issue and leave a short description?", "author": "madrob", "createdAt": "2020-07-14T16:12:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc1NTIxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDQ3NDU4Mg==", "url": "https://github.com/apache/hbase/pull/2058#discussion_r454474582", "bodyText": "Will do! \ud83d\ude04", "author": "bitoffdev", "createdAt": "2020-07-14T16:13:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc1NTIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxMDU2NA==", "url": "https://github.com/apache/hbase/pull/2058#discussion_r456610564", "bodyText": "Nice idiom convertion (java to ruby)", "author": "saintstack", "createdAt": "2020-07-17T18:36:13Z", "path": "hbase-shell/src/main/ruby/shell/commands/balance_switch.rb", "diffHunk": "@@ -31,7 +31,7 @@ def help\n       end\n \n       def command(enableDisable)\n-        prev_state = admin.balance_switch(enableDisable) ? 'true' : 'false'\n+        prev_state = !!admin.balance_switch(enableDisable)", "originalCommit": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxMTI1Mg==", "url": "https://github.com/apache/hbase/pull/2058#discussion_r456611252", "bodyText": "formatter.row returns void? Different to nil?", "author": "saintstack", "createdAt": "2020-07-17T18:37:43Z", "path": "hbase-shell/src/main/ruby/shell/commands/clear_block_cache.rb", "diffHunk": "@@ -33,6 +33,7 @@ def help\n \n       def command(table_name)\n         formatter.row([admin.clear_block_cache(table_name)])\n+        nil", "originalCommit": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxNzUyMg==", "url": "https://github.com/apache/hbase/pull/2058#discussion_r456617522", "bodyText": "formatter.row returns the running total number of rows printed (@row_count) since the last call to formatter.header", "author": "bitoffdev", "createdAt": "2020-07-17T18:51:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxMTI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxMTYzMg==", "url": "https://github.com/apache/hbase/pull/2058#discussion_r456611632", "bodyText": "Bug fix?", "author": "saintstack", "createdAt": "2020-07-17T18:38:31Z", "path": "hbase-shell/src/main/ruby/shell/commands/clear_deadservers.rb", "diffHunk": "@@ -35,18 +37,20 @@ def help\n       end\n \n       # rubocop:disable Metrics/AbcSize\n-      # rubocop:disable Metrics/MethodLength\n       def command(*dead_servers)\n         servers = admin.clear_deadservers(dead_servers)\n         if servers.size <= 0\n           formatter.row(['true'])\n+          []\n         else\n           formatter.row(['Some dead server clear failed'])\n           formatter.row(['SERVERNAME'])\n-          servers.each do |server|\n-            formatter.row([server.toString])\n+          server_names = servers.map { |server| server.toString }", "originalCommit": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxODIxNw==", "url": "https://github.com/apache/hbase/pull/2058#discussion_r456618217", "bodyText": "This is just a change to collect all the server names as an array so that we can both print and return the list of servers that could not be cleared", "author": "bitoffdev", "createdAt": "2020-07-17T18:52:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxMTYzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjYxNDA1Ng==", "url": "https://github.com/apache/hbase/pull/2058#discussion_r456614056", "bodyText": "Sweet", "author": "saintstack", "createdAt": "2020-07-17T18:43:43Z", "path": "hbase-shell/src/test/ruby/hbase/admin_test.rb", "diffHunk": "@@ -212,13 +215,182 @@ def teardown\n     #-------------------------------------------------------------------------------\n \n     define_test 'snapshot auto cleanup should work' do\n-      command(:snapshot_cleanup_switch, true)\n-      output = capture_stdout { command(:snapshot_cleanup_enabled) }\n+      result = nil\n+      command(:snapshot_cleanup_switch, false)\n+\n+      # enable snapshot cleanup and check that the previous state is returned\n+      output = capture_stdout { result = command(:snapshot_cleanup_switch, true) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      # check that snapshot_cleanup_enabled returns the current state\n+      output = capture_stdout { result = command(:snapshot_cleanup_enabled) }\n       assert(output.include?('true'))\n+      assert(result == true)\n \n-      command(:snapshot_cleanup_switch, false)\n-      output = capture_stdout { command(:snapshot_cleanup_enabled) }\n+      # disable snapshot cleanup and check that the previous state is returned\n+      output = capture_stdout { result = command(:snapshot_cleanup_switch, false) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # check that snapshot_cleanup_enabled returns the current state\n+      output = capture_stdout { result = command(:snapshot_cleanup_enabled) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+    end\n+\n+    #-------------------------------------------------------------------------------\n+\n+    define_test 'balancer switch should work' do\n+      result = nil\n+      command(:balance_switch, false)\n+\n+      # enable balancer and check that the previous state is returned\n+      output = capture_stdout { result = command(:balance_switch, true) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      # check that balancer_enabled returns the current state\n+      output = capture_stdout { result = command(:balancer_enabled) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # disable balancer and check that the previous state is returned\n+      output = capture_stdout { result = command(:balance_switch, false) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # check that balancer_enabled returns the current state\n+      output = capture_stdout { result = command(:balancer_enabled) }\n       assert(output.include?('false'))\n+      assert(result == false)\n+    end\n+\n+    #-------------------------------------------------------------------------------\n+\n+    define_test 'normalizer switch should work' do\n+      result = nil\n+      command(:normalizer_switch, false)\n+\n+      # enable normalizer and check that the previous state is returned\n+      output = capture_stdout { result = command(:normalizer_switch, true) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      # check that normalizer_enabled returns the current state\n+      output = capture_stdout { result = command(:normalizer_enabled) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # disable normalizer and check that the previous state is returned\n+      output = capture_stdout { result = command(:normalizer_switch, false) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # check that normalizer_enabled returns the current state\n+      output = capture_stdout { result = command(:normalizer_enabled) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+    end\n+\n+    #-------------------------------------------------------------------------------\n+\n+    define_test 'catalogjanitor switch should work' do\n+      result = nil\n+      command(:catalogjanitor_switch, false)\n+\n+      # enable catalogjanitor and check that the previous state is returned\n+      output = capture_stdout { result = command(:catalogjanitor_switch, true) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      # check that catalogjanitor_enabled returns the current state\n+      output = capture_stdout { result = command(:catalogjanitor_enabled) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # disable catalogjanitor and check that the previous state is returned\n+      output = capture_stdout { result = command(:catalogjanitor_switch, false) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # check that catalogjanitor_enabled returns the current state\n+      output = capture_stdout { result = command(:catalogjanitor_enabled) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+    end\n+\n+    #-------------------------------------------------------------------------------\n+\n+    define_test 'cleaner_chore switch should work' do\n+      result = nil\n+      command(:cleaner_chore_switch, false)\n+\n+      # enable cleaner_chore and check that the previous state is returned\n+      output = capture_stdout { result = command(:cleaner_chore_switch, true) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      # check that cleaner_chore_enabled returns the current state\n+      output = capture_stdout { result = command(:cleaner_chore_enabled) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # disable cleaner_chore and check that the previous state is returned\n+      output = capture_stdout { result = command(:cleaner_chore_switch, false) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # check that cleaner_chore_enabled returns the current state\n+      output = capture_stdout { result = command(:cleaner_chore_enabled) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+    end\n+\n+    #-------------------------------------------------------------------------------\n+\n+    define_test 'splitormerge switch should work' do\n+      # Author's note: All the other feature switches in hbase-shell only toggle one feature. This command operates on\n+      # both the \"SPLIT\" and \"MERGE\", so you will note that both code paths need coverage.\n+      result = nil\n+      command(:splitormerge_switch, 'SPLIT', false)\n+      command(:splitormerge_switch, 'MERGE', true)\n+\n+      # flip switch and check that the previous state is returned\n+      output = capture_stdout { result = command(:splitormerge_switch, 'SPLIT', true) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      output = capture_stdout { result = command(:splitormerge_switch, 'MERGE', false) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      # check that splitormerge_enabled returns the current state\n+      output = capture_stdout { result = command(:splitormerge_enabled, 'SPLIT') }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      output = capture_stdout { result = command(:splitormerge_enabled, 'MERGE') }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      # flip switch and check that the previous state is returned\n+      output = capture_stdout { result = command(:splitormerge_switch, 'SPLIT', false) }\n+      assert(output.include?('true'))\n+      assert(result == true)\n+\n+      output = capture_stdout { result = command(:splitormerge_switch, 'MERGE', true) }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      # check that splitormerge_enabled returns the current state\n+      output = capture_stdout { result = command(:splitormerge_enabled, 'SPLIT') }\n+      assert(output.include?('false'))\n+      assert(result == false)\n+\n+      output = capture_stdout { result = command(:splitormerge_enabled, 'MERGE') }\n+      assert(output.include?('true'))\n+      assert(result == true)", "originalCommit": "58d30e09c0ceb6f1bacdc544f169f8f125b4a1b9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}