{"pr_number": 2094, "pr_title": "HBASE-24680 Refactor the checkAndMutate code on the server side", "pr_createdAt": "2020-07-18T09:39:47Z", "pr_url": "https://github.com/apache/hbase/pull/2094", "timeline": [{"oid": "09825282d8c4f0058ce0e87dec1935867bce8385", "url": "https://github.com/apache/hbase/commit/09825282d8c4f0058ce0e87dec1935867bce8385", "message": "HBASE-24680 Refactor the checkAndMutate code on the server side", "committedDate": "2020-07-18T18:55:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk0NDMyNw==", "url": "https://github.com/apache/hbase/pull/2094#discussion_r458944327", "bodyText": "nit: Mutation m = mutations.get(0) and then use m for the rest of this block.", "author": "joshelser", "createdAt": "2020-07-22T16:59:49Z", "path": "hbase-client/src/main/java/org/apache/hadoop/hbase/shaded/protobuf/ProtobufUtil.java", "diffHunk": "@@ -3543,4 +3546,72 @@ public static RSGroupInfo toGroupInfo(RSGroupProtos.RSGroupInfo proto) {\n     return RSGroupProtos.RSGroupInfo.newBuilder().setName(pojo.getName()).addAllServers(hostports)\n         .addAllTables(tables).addAllConfiguration(configuration).build();\n   }\n+\n+  public static CheckAndMutate toCheckAndMutate(ClientProtos.Condition condition,\n+    MutationProto mutation, CellScanner cellScanner) throws IOException {\n+    byte[] row = condition.getRow().toByteArray();\n+    CheckAndMutate.Builder builder = CheckAndMutate.newBuilder(row);\n+    Filter filter = condition.hasFilter() ? ProtobufUtil.toFilter(condition.getFilter()) : null;\n+    if (filter != null) {\n+      builder.ifMatches(filter);\n+    } else {\n+      builder.ifMatches(condition.getFamily().toByteArray(),\n+        condition.getQualifier().toByteArray(),\n+        CompareOperator.valueOf(condition.getCompareType().name()),\n+        ProtobufUtil.toComparator(condition.getComparator()).getValue());\n+    }\n+    TimeRange timeRange = condition.hasTimeRange() ?\n+      ProtobufUtil.toTimeRange(condition.getTimeRange()) : TimeRange.allTime();\n+    builder.timeRange(timeRange);\n+\n+    try {\n+      MutationType type = mutation.getMutateType();\n+      switch (type) {\n+        case PUT:\n+          return builder.build(ProtobufUtil.toPut(mutation, cellScanner));\n+        case DELETE:\n+          return builder.build(ProtobufUtil.toDelete(mutation, cellScanner));\n+        default:\n+          throw new DoNotRetryIOException(\"Unsupported mutate type: \" + type.name());\n+      }\n+    } catch (IllegalArgumentException e) {\n+      throw new DoNotRetryIOException(e.getMessage());\n+    }\n+  }\n+\n+  public static CheckAndMutate toCheckAndMutate(ClientProtos.Condition condition,\n+    List<Mutation> mutations) throws IOException {\n+    assert mutations.size() > 0;\n+    byte[] row = condition.getRow().toByteArray();\n+    CheckAndMutate.Builder builder = CheckAndMutate.newBuilder(row);\n+    Filter filter = condition.hasFilter() ? ProtobufUtil.toFilter(condition.getFilter()) : null;\n+    if (filter != null) {\n+      builder.ifMatches(filter);\n+    } else {\n+      builder.ifMatches(condition.getFamily().toByteArray(),\n+        condition.getQualifier().toByteArray(),\n+        CompareOperator.valueOf(condition.getCompareType().name()),\n+        ProtobufUtil.toComparator(condition.getComparator()).getValue());\n+    }\n+    TimeRange timeRange = condition.hasTimeRange() ?\n+      ProtobufUtil.toTimeRange(condition.getTimeRange()) : TimeRange.allTime();\n+    builder.timeRange(timeRange);\n+\n+    try {\n+      if (mutations.size() == 1) {\n+        if (mutations.get(0) instanceof Put) {", "originalCommit": "09825282d8c4f0058ce0e87dec1935867bce8385", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk1MjUwMA==", "url": "https://github.com/apache/hbase/pull/2094#discussion_r458952500", "bodyText": "Every time I see this, I want to suggest you use a visitor pattern to reduce the boilerplate, but that would require putting more logic on Put/Delete which not worth it. \ud83e\udd37", "author": "joshelser", "createdAt": "2020-07-22T17:13:35Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/RegionObserver.java", "diffHunk": "@@ -759,12 +810,150 @@ default boolean postCheckAndDelete(ObserverContext<RegionCoprocessorEnvironment>\n    * @param delete delete to commit if check succeeds\n    * @param result from the CheckAndDelete\n    * @return the possibly transformed returned value to return to client\n+   *\n+   * @deprecated since 3.0.0 and will be removed in 4.0.0. Use\n+   *   {@link #postCheckAndMutate(ObserverContext, CheckAndMutate, CheckAndMutateResult)} instead.\n    */\n+  @Deprecated\n   default boolean postCheckAndDelete(ObserverContext<RegionCoprocessorEnvironment> c, byte[] row,\n     Filter filter, Delete delete, boolean result) throws IOException {\n     return result;\n   }\n \n+  /**\n+   * Called before checkAndMutate\n+   * <p>\n+   * Call CoprocessorEnvironment#bypass to skip default actions.\n+   * If 'bypass' is set, we skip out on calling any subsequent chained coprocessors.\n+   * <p>\n+   * Note: Do not retain references to any Cells in actions beyond the life of this invocation.\n+   * If need a Cell reference for later use, copy the cell and use that.\n+   * @param c the environment provided by the region server\n+   * @param checkAndMutate the CheckAndMutate object\n+   * @param result the default value of the result\n+   * @return the return value to return to client if bypassing default processing\n+   * @throws IOException if an error occurred on the coprocessor\n+   */\n+  default CheckAndMutateResult preCheckAndMutate(ObserverContext<RegionCoprocessorEnvironment> c,\n+    CheckAndMutate checkAndMutate, CheckAndMutateResult result) throws IOException {\n+    if (checkAndMutate.getAction() instanceof Put) {", "originalCommit": "09825282d8c4f0058ce0e87dec1935867bce8385", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3MjU3MQ==", "url": "https://github.com/apache/hbase/pull/2094#discussion_r459472571", "bodyText": "Put/Delete is public so let's not do this...", "author": "Apache9", "createdAt": "2020-07-23T14:01:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk1MjUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk4ODgxOA==", "url": "https://github.com/apache/hbase/pull/2094#discussion_r458988818", "bodyText": "Probably don't need to mark deprecated tests in the future, but this is fine to leave, IMO.", "author": "joshelser", "createdAt": "2020-07-22T18:13:22Z", "path": "hbase-server/src/test/java/org/apache/hadoop/hbase/regionserver/TestHRegion.java", "diffHunk": "@@ -1770,6 +1772,7 @@ private long prepareRegionForBachPut(final Put[] puts, final MetricsWALSource so\n   // checkAndMutate tests\n   // ////////////////////////////////////////////////////////////////////////////\n   @Test\n+  @Deprecated", "originalCommit": "09825282d8c4f0058ce0e87dec1935867bce8385", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3783a29d07c484145faf5bd24d2a06daafbf32a9", "url": "https://github.com/apache/hbase/commit/3783a29d07c484145faf5bd24d2a06daafbf32a9", "message": "HBASE-24680 Refactor the checkAndMutate code on the server side", "committedDate": "2020-07-23T13:17:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3MTkxOQ==", "url": "https://github.com/apache/hbase/pull/2094#discussion_r459471919", "bodyText": "After this change, do we still have checkAndPut and checkAndDelete?", "author": "Apache9", "createdAt": "2020-07-23T14:00:50Z", "path": "hbase-hadoop-compat/src/main/java/org/apache/hadoop/hbase/regionserver/MetricsRegionServerSource.java", "diffHunk": "@@ -86,6 +86,12 @@\n    */\n   void updateCheckAndPut(long t);\n \n+  /**\n+   * Update checkAndMutate histogram\n+   * @param t time it took\n+   */\n+  void updateCheckAndMutate(long t);", "originalCommit": "3783a29d07c484145faf5bd24d2a06daafbf32a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1NDM5Nw==", "url": "https://github.com/apache/hbase/pull/2094#discussion_r459954397", "bodyText": "Yes. This change keeps the existing metrics for checkAndPut and checkAndDelete for backward compatibility. This change doesn't break the existing tests for the metrics for checkAndPut and checkAndDelete.", "author": "brfrn169", "createdAt": "2020-07-24T09:43:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3MTkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3MzQyMg==", "url": "https://github.com/apache/hbase/pull/2094#discussion_r459473422", "bodyText": "Where do we throw this exception out? Catching a RuntimeException seems strange to me.", "author": "Apache9", "createdAt": "2020-07-23T14:02:55Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -4272,43 +4275,96 @@ protected Durability getEffectiveDurability(Durability d) {\n   }\n \n   @Override\n+  @Deprecated\n   public boolean checkAndMutate(byte[] row, byte[] family, byte[] qualifier, CompareOperator op,\n     ByteArrayComparable comparator, TimeRange timeRange, Mutation mutation) throws IOException {\n-    return doCheckAndRowMutate(row, family, qualifier, op, comparator, null, timeRange, null,\n-      mutation);\n+    CheckAndMutate.Builder builder = CheckAndMutate.newBuilder(row)\n+      .ifMatches(family, qualifier, op, comparator.getValue()).timeRange(timeRange);\n+    try {\n+      if (mutation instanceof Put) {\n+        return checkAndMutate(builder.build((Put) mutation)).isSuccess();\n+      } else if (mutation instanceof Delete) {\n+        return checkAndMutate(builder.build((Delete) mutation)).isSuccess();\n+      } else {\n+        throw new DoNotRetryIOException(\n+          \"Unsupported mutate type: \" + mutation.getClass().getSimpleName().toUpperCase());\n+      }\n+    } catch (IllegalArgumentException e) {", "originalCommit": "3783a29d07c484145faf5bd24d2a06daafbf32a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk1NzE0Mw==", "url": "https://github.com/apache/hbase/pull/2094#discussion_r459957143", "bodyText": "CheckAndMutate.Builder.build() calls preCheck() internally and it can throw IllegalArgumentException if the parameters are invalid:\n\n  \n    \n      hbase/hbase-client/src/main/java/org/apache/hadoop/hbase/client/CheckAndMutate.java\n    \n    \n        Lines 141 to 151\n      in\n      09e7ccd\n    \n    \n    \n    \n\n        \n          \n           private void preCheck(Row action) { \n        \n\n        \n          \n             Preconditions.checkNotNull(action, \"action (Put/Delete/RowMutations) is null\"); \n        \n\n        \n          \n             if (!Bytes.equals(row, action.getRow())) { \n        \n\n        \n          \n               throw new IllegalArgumentException(\"The row of the action (Put/Delete/RowMutations) <\" + \n        \n\n        \n          \n                 Bytes.toStringBinary(action.getRow()) + \"> doesn't match the original one <\" + \n        \n\n        \n          \n                 Bytes.toStringBinary(this.row) + \">\"); \n        \n\n        \n          \n             } \n        \n\n        \n          \n             Preconditions.checkState(op != null || filter != null, \"condition is null. You need to\" \n        \n\n        \n          \n               + \" specify the condition by calling ifNotExists/ifEquals/ifMatches before building a\" \n        \n\n        \n          \n               + \" CheckAndMutate object\"); \n        \n\n        \n          \n           }", "author": "brfrn169", "createdAt": "2020-07-24T09:49:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3MzQyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ0NDQ5OA==", "url": "https://github.com/apache/hbase/pull/2094#discussion_r463444498", "bodyText": "Then we'd better let the try catch for IllegalArgumentException only wrap the builder.build? And then we call checkAndMutate, without catching the IllegalArgumentException. I think this will be better to let others know why we may hit IllegalArgumentException.", "author": "Apache9", "createdAt": "2020-07-31T07:15:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3MzQyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzQ2Njg0OQ==", "url": "https://github.com/apache/hbase/pull/2094#discussion_r463466849", "bodyText": "Sure, thanks. Will do that as your review.", "author": "brfrn169", "createdAt": "2020-07-31T08:08:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3MzQyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3MzUxOQ==", "url": "https://github.com/apache/hbase/pull/2094#discussion_r459473519", "bodyText": "Ditto.", "author": "Apache9", "createdAt": "2020-07-23T14:03:03Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -4272,43 +4275,96 @@ protected Durability getEffectiveDurability(Durability d) {\n   }\n \n   @Override\n+  @Deprecated\n   public boolean checkAndMutate(byte[] row, byte[] family, byte[] qualifier, CompareOperator op,\n     ByteArrayComparable comparator, TimeRange timeRange, Mutation mutation) throws IOException {\n-    return doCheckAndRowMutate(row, family, qualifier, op, comparator, null, timeRange, null,\n-      mutation);\n+    CheckAndMutate.Builder builder = CheckAndMutate.newBuilder(row)\n+      .ifMatches(family, qualifier, op, comparator.getValue()).timeRange(timeRange);\n+    try {\n+      if (mutation instanceof Put) {\n+        return checkAndMutate(builder.build((Put) mutation)).isSuccess();\n+      } else if (mutation instanceof Delete) {\n+        return checkAndMutate(builder.build((Delete) mutation)).isSuccess();\n+      } else {\n+        throw new DoNotRetryIOException(\n+          \"Unsupported mutate type: \" + mutation.getClass().getSimpleName().toUpperCase());\n+      }\n+    } catch (IllegalArgumentException e) {\n+      throw new DoNotRetryIOException(e.getMessage());\n+    }\n   }\n \n   @Override\n+  @Deprecated\n   public boolean checkAndMutate(byte[] row, Filter filter, TimeRange timeRange, Mutation mutation)\n     throws IOException {\n-    return doCheckAndRowMutate(row, null, null, null, null, filter, timeRange, null, mutation);\n+    CheckAndMutate.Builder builder = CheckAndMutate.newBuilder(row).ifMatches(filter)\n+      .timeRange(timeRange);\n+    try {\n+      if (mutation instanceof Put) {\n+        return checkAndMutate(builder.build((Put) mutation)).isSuccess();\n+      } else if (mutation instanceof Delete) {\n+        return checkAndMutate(builder.build((Delete) mutation)).isSuccess();\n+      } else {\n+        throw new DoNotRetryIOException(\"Unsupported mutate type: \" +\n+          mutation.getClass().getSimpleName().toUpperCase());\n+      }\n+    } catch (IllegalArgumentException e) {", "originalCommit": "3783a29d07c484145faf5bd24d2a06daafbf32a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3NTUyMw==", "url": "https://github.com/apache/hbase/pull/2094#discussion_r459475523", "bodyText": "So the old coprocessor methods will not be called any more?", "author": "Apache9", "createdAt": "2020-07-23T14:05:46Z", "path": "hbase-server/src/main/java/org/apache/hadoop/hbase/regionserver/HRegion.java", "diffHunk": "@@ -4335,32 +4391,14 @@ private boolean doCheckAndRowMutate(byte[] row, byte[] family, byte[] qualifier,\n       checkRow(row, \"doCheckAndRowMutate\");\n       RowLock rowLock = getRowLockInternal(get.getRow(), false, null);\n       try {\n-        if (mutation != null && this.getCoprocessorHost() != null) {\n-          // Call coprocessor.\n-          Boolean processed = null;\n-          if (mutation instanceof Put) {\n-            if (filter != null) {\n-              processed = this.getCoprocessorHost()", "originalCommit": "3783a29d07c484145faf5bd24d2a06daafbf32a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTk2MjMwOA==", "url": "https://github.com/apache/hbase/pull/2094#discussion_r459962308", "bodyText": "The old coprocessor methods will be called after this change because the default implementations of the new coprocessor methods call the old methods for backward compatibility:\nRegionObserver#preCheckAndMutate:\nhttps://github.com/brfrn169/hbase/blob/HBASE-24680/hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/RegionObserver.java#L837-L865\nRegionObserver#preCheckAndMutateAfterRowLock:\nhttps://github.com/brfrn169/hbase/blob/HBASE-24680/hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/RegionObserver.java#L885-L914\nRegionObserver#postCheckAndMutate:\nhttps://github.com/brfrn169/hbase/blob/HBASE-24680/hbase-server/src/main/java/org/apache/hadoop/hbase/coprocessor/RegionObserver.java#L927-L955\nThis change doesn't break the existing tests for the old coprocessor methods.", "author": "brfrn169", "createdAt": "2020-07-24T10:01:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTQ3NTUyMw=="}], "type": "inlineReview"}, {"oid": "e3dfe5c95e75f269216f51bbd874e76110ce71fb", "url": "https://github.com/apache/hbase/commit/e3dfe5c95e75f269216f51bbd874e76110ce71fb", "message": "HBASE-24680 Refactor the checkAndMutate code on the server side", "committedDate": "2020-08-01T02:04:04Z", "type": "commit"}, {"oid": "e3dfe5c95e75f269216f51bbd874e76110ce71fb", "url": "https://github.com/apache/hbase/commit/e3dfe5c95e75f269216f51bbd874e76110ce71fb", "message": "HBASE-24680 Refactor the checkAndMutate code on the server side", "committedDate": "2020-08-01T02:04:04Z", "type": "forcePushed"}]}