{"pr_number": 3246, "pr_title": "ARTEMIS-2886 optimize security auth", "pr_createdAt": "2020-08-25T23:47:22Z", "pr_url": "https://github.com/apache/activemq-artemis/pull/3246", "timeline": [{"oid": "4baa5d57b18211669d29e44cd6c72d953a33c90a", "url": "https://github.com/apache/activemq-artemis/commit/4baa5d57b18211669d29e44cd6c72d953a33c90a", "message": "ARTEMIS-2886 optimize security auth\n\nBoth authentication and authorization will hit the underlying security\nrepository (e.g. files, LDAP, etc.). For example, creating a JMS\nconnection and a consumer will result in 2 hits with the *same*\nauthentication request. This can cause unwanted (and unnecessary)\nresource utilization, especially in the case of networked configuration\nlike LDAP.\n\nThere is already a rudimentary cache for authorization, but it is\ncleared *totally* every 10 seconds by default (controlled via the\nsecurity-invalidation-interval setting), and it must be populated\ninitially which still results in duplicate auth requests.\n\nThis commit optimizes authentication and authorization via the following\nchanges:\n\n - Replace our home-grown cache with Google Guava's cache. This provides\nsimple caching with both time-based and size-based LRU eviction. See more\nat https://github.com/google/guava/wiki/CachesExplained. I also thought\nabout using Caffeine, but we already have a dependency on Guava and the\ncache implementions look to be negligibly different for this use-case.\n - Add caching for authentication. Both successful and unsuccessful\nauthentication attempts will be cached to spare the underlying security\nrepository as much as possible. Authenticated Subjects will be cached\nand re-used whenever possible.\n - Authorization will used Subjects cached during authentication. If the\nrequired Subject is not in the cache it will be fetched from the\nunderlying security repo.\n - Caching can be disabled by setting the security-invalidation-interval\nto 0.", "committedDate": "2020-08-26T00:25:51Z", "type": "forcePushed"}, {"oid": "8db16f826050ed186304fbaf0408dc918692898e", "url": "https://github.com/apache/activemq-artemis/commit/8db16f826050ed186304fbaf0408dc918692898e", "message": "ARTEMIS-2886 optimize security auth\n\nBoth authentication and authorization will hit the underlying security\nrepository (e.g. files, LDAP, etc.). For example, creating a JMS\nconnection and a consumer will result in 2 hits with the *same*\nauthentication request. This can cause unwanted (and unnecessary)\nresource utilization, especially in the case of networked configuration\nlike LDAP.\n\nThere is already a rudimentary cache for authorization, but it is\ncleared *totally* every 10 seconds by default (controlled via the\nsecurity-invalidation-interval setting), and it must be populated\ninitially which still results in duplicate auth requests.\n\nThis commit optimizes authentication and authorization via the following\nchanges:\n\n - Replace our home-grown cache with Google Guava's cache. This provides\nsimple caching with both time-based and size-based LRU eviction. See more\nat https://github.com/google/guava/wiki/CachesExplained. I also thought\nabout using Caffeine, but we already have a dependency on Guava and the\ncache implementions look to be negligibly different for this use-case.\n - Add caching for authentication. Both successful and unsuccessful\nauthentication attempts will be cached to spare the underlying security\nrepository as much as possible. Authenticated Subjects will be cached\nand re-used whenever possible.\n - Authorization will used Subjects cached during authentication. If the\nrequired Subject is not in the cache it will be fetched from the\nunderlying security repo.\n - Caching can be disabled by setting the security-invalidation-interval\nto 0.", "committedDate": "2020-08-26T01:19:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3MDkwMg==", "url": "https://github.com/apache/activemq-artemis/pull/3246#discussion_r477270902", "bodyText": "I don't understand this...\nWhy can't we just use the previous operation on clearing the cache.\nI don't think this is a valid test change. The test was written to validate the cache cleared.\nif caching becomes a valid option now, we should rather just remove the test.", "author": "clebertsuconic", "createdAt": "2020-08-26T12:44:43Z", "path": "tests/integration-tests/src/test/java/org/apache/activemq/artemis/tests/integration/security/SecurityTest.java", "diffHunk": "@@ -1412,12 +1413,26 @@ public void testSendMessageUpdateRoleCached() throws Exception {\n \n       securityManager.getConfiguration().addRole(\"auser\", \"receiver\");\n \n-      session.createConsumer(SecurityTest.queueA);\n+      Wait.assertTrue(() -> {\n+         try {\n+            session.createConsumer(SecurityTest.queueA);\n+            return true;\n+         } catch (Exception e) {\n+            return false;\n+         }\n+      }, 2000, 100);\n \n       // Removing the Role... the check should be cached, so the next createConsumer shouldn't fail\n       securityManager.getConfiguration().removeRole(\"auser\", \"receiver\");", "originalCommit": "8db16f826050ed186304fbaf0408dc918692898e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM5NTkyMw==", "url": "https://github.com/apache/activemq-artemis/pull/3246#discussion_r477395923", "bodyText": "That test was meant to (among other things) exercise the authorization cache. However, with the introduction of the authentication cache the semantics changed a bit. I've updated the test to make this more clear. Thanks for the review.", "author": "jbertram", "createdAt": "2020-08-26T15:36:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI3MDkwMg=="}], "type": "inlineReview"}, {"oid": "0017d8d0245a2ac0ae2885c69b4e6089a6cce9fc", "url": "https://github.com/apache/activemq-artemis/commit/0017d8d0245a2ac0ae2885c69b4e6089a6cce9fc", "message": "ARTEMIS-2886 optimize security auth\n\nBoth authentication and authorization will hit the underlying security\nrepository (e.g. files, LDAP, etc.). For example, creating a JMS\nconnection and a consumer will result in 2 hits with the *same*\nauthentication request. This can cause unwanted (and unnecessary)\nresource utilization, especially in the case of networked configuration\nlike LDAP.\n\nThere is already a rudimentary cache for authorization, but it is\ncleared *totally* every 10 seconds by default (controlled via the\nsecurity-invalidation-interval setting), and it must be populated\ninitially which still results in duplicate auth requests.\n\nThis commit optimizes authentication and authorization via the following\nchanges:\n\n - Replace our home-grown cache with Google Guava's cache. This provides\nsimple caching with both time-based and size-based LRU eviction. See more\nat https://github.com/google/guava/wiki/CachesExplained. I also thought\nabout using Caffeine, but we already have a dependency on Guava and the\ncache implementions look to be negligibly different for this use-case.\n - Add caching for authentication. Both successful and unsuccessful\nauthentication attempts will be cached to spare the underlying security\nrepository as much as possible. Authenticated Subjects will be cached\nand re-used whenever possible.\n - Authorization will used Subjects cached during authentication. If the\nrequired Subject is not in the cache it will be fetched from the\nunderlying security repo.\n - Caching can be disabled by setting the security-invalidation-interval\nto 0.", "committedDate": "2020-08-26T15:27:35Z", "type": "forcePushed"}, {"oid": "763a8f62802df7bb31a2ffeda2c466cb4f67a3b9", "url": "https://github.com/apache/activemq-artemis/commit/763a8f62802df7bb31a2ffeda2c466cb4f67a3b9", "message": "ARTEMIS-2886 optimize security auth\n\nBoth authentication and authorization will hit the underlying security\nrepository (e.g. files, LDAP, etc.). For example, creating a JMS\nconnection and a consumer will result in 2 hits with the *same*\nauthentication request. This can cause unwanted (and unnecessary)\nresource utilization, especially in the case of networked configuration\nlike LDAP.\n\nThere is already a rudimentary cache for authorization, but it is\ncleared *totally* every 10 seconds by default (controlled via the\nsecurity-invalidation-interval setting), and it must be populated\ninitially which still results in duplicate auth requests.\n\nThis commit optimizes authentication and authorization via the following\nchanges:\n\n - Replace our home-grown cache with Google Guava's cache. This provides\nsimple caching with both time-based and size-based LRU eviction. See more\nat https://github.com/google/guava/wiki/CachesExplained. I also thought\nabout using Caffeine, but we already have a dependency on Guava and the\ncache implementions look to be negligibly different for this use-case.\n - Add caching for authentication. Both successful and unsuccessful\nauthentication attempts will be cached to spare the underlying security\nrepository as much as possible. Authenticated Subjects will be cached\nand re-used whenever possible.\n - Authorization will used Subjects cached during authentication. If the\nrequired Subject is not in the cache it will be fetched from the\nunderlying security repo.\n - Caching can be disabled by setting the security-invalidation-interval\nto 0.\n - Cache sizes are configurable.\n - Management operations exist to inspect cache sizes at runtime.", "committedDate": "2020-08-26T15:34:49Z", "type": "forcePushed"}, {"oid": "1ed159e4166ee2c69e03cbd89eb695b667705284", "url": "https://github.com/apache/activemq-artemis/commit/1ed159e4166ee2c69e03cbd89eb695b667705284", "message": "ARTEMIS-2886 optimize security auth\n\nBoth authentication and authorization will hit the underlying security\nrepository (e.g. files, LDAP, etc.). For example, creating a JMS\nconnection and a consumer will result in 2 hits with the *same*\nauthentication request. This can cause unwanted (and unnecessary)\nresource utilization, especially in the case of networked configuration\nlike LDAP.\n\nThere is already a rudimentary cache for authorization, but it is\ncleared *totally* every 10 seconds by default (controlled via the\nsecurity-invalidation-interval setting), and it must be populated\ninitially which still results in duplicate auth requests.\n\nThis commit optimizes authentication and authorization via the following\nchanges:\n\n - Replace our home-grown cache with Google Guava's cache. This provides\nsimple caching with both time-based and size-based LRU eviction. See more\nat https://github.com/google/guava/wiki/CachesExplained. I also thought\nabout using Caffeine, but we already have a dependency on Guava and the\ncache implementions look to be negligibly different for this use-case.\n - Add caching for authentication. Both successful and unsuccessful\nauthentication attempts will be cached to spare the underlying security\nrepository as much as possible. Authenticated Subjects will be cached\nand re-used whenever possible.\n - Authorization will used Subjects cached during authentication. If the\nrequired Subject is not in the cache it will be fetched from the\nunderlying security repo.\n - Caching can be disabled by setting the security-invalidation-interval\nto 0.\n - Cache sizes are configurable.\n - Management operations exist to inspect cache sizes at runtime.", "committedDate": "2020-08-26T15:47:52Z", "type": "forcePushed"}, {"oid": "240b63690eb6aa39552950b68bb461f1d4fcbab4", "url": "https://github.com/apache/activemq-artemis/commit/240b63690eb6aa39552950b68bb461f1d4fcbab4", "message": "ARTEMIS-2886 optimize security auth\n\nBoth authentication and authorization will hit the underlying security\nrepository (e.g. files, LDAP, etc.). For example, creating a JMS\nconnection and a consumer will result in 2 hits with the *same*\nauthentication request. This can cause unwanted (and unnecessary)\nresource utilization, especially in the case of networked configuration\nlike LDAP.\n\nThere is already a rudimentary cache for authorization, but it is\ncleared *totally* every 10 seconds by default (controlled via the\nsecurity-invalidation-interval setting), and it must be populated\ninitially which still results in duplicate auth requests.\n\nThis commit optimizes authentication and authorization via the following\nchanges:\n\n - Replace our home-grown cache with Google Guava's cache. This provides\nsimple caching with both time-based and size-based LRU eviction. See more\nat https://github.com/google/guava/wiki/CachesExplained. I also thought\nabout using Caffeine, but we already have a dependency on Guava and the\ncache implementions look to be negligibly different for this use-case.\n - Add caching for authentication. Both successful and unsuccessful\nauthentication attempts will be cached to spare the underlying security\nrepository as much as possible. Authenticated Subjects will be cached\nand re-used whenever possible.\n - Authorization will used Subjects cached during authentication. If the\nrequired Subject is not in the cache it will be fetched from the\nunderlying security repo.\n - Caching can be disabled by setting the security-invalidation-interval\nto 0.\n - Cache sizes are configurable.\n - Management operations exist to inspect cache sizes at runtime.", "committedDate": "2020-08-26T15:56:28Z", "type": "forcePushed"}, {"oid": "dbc3f610e8f7c5d9be997843c13b1a0bcd9ced02", "url": "https://github.com/apache/activemq-artemis/commit/dbc3f610e8f7c5d9be997843c13b1a0bcd9ced02", "message": "ARTEMIS-2886 optimize security auth\n\nBoth authentication and authorization will hit the underlying security\nrepository (e.g. files, LDAP, etc.). For example, creating a JMS\nconnection and a consumer will result in 2 hits with the *same*\nauthentication request. This can cause unwanted (and unnecessary)\nresource utilization, especially in the case of networked configuration\nlike LDAP.\n\nThere is already a rudimentary cache for authorization, but it is\ncleared *totally* every 10 seconds by default (controlled via the\nsecurity-invalidation-interval setting), and it must be populated\ninitially which still results in duplicate auth requests.\n\nThis commit optimizes authentication and authorization via the following\nchanges:\n\n - Replace our home-grown cache with Google Guava's cache. This provides\nsimple caching with both time-based and size-based LRU eviction. See more\nat https://github.com/google/guava/wiki/CachesExplained. I also thought\nabout using Caffeine, but we already have a dependency on Guava and the\ncache implementions look to be negligibly different for this use-case.\n - Add caching for authentication. Both successful and unsuccessful\nauthentication attempts will be cached to spare the underlying security\nrepository as much as possible. Authenticated Subjects will be cached\nand re-used whenever possible.\n - Authorization will used Subjects cached during authentication. If the\nrequired Subject is not in the cache it will be fetched from the\nunderlying security repo.\n - Caching can be disabled by setting the security-invalidation-interval\nto 0.\n - Cache sizes are configurable.\n - Management operations exist to inspect cache sizes at runtime.", "committedDate": "2020-08-26T17:22:09Z", "type": "forcePushed"}, {"oid": "b8e38d352a71f512a5d461170ad78c6406f55b46", "url": "https://github.com/apache/activemq-artemis/commit/b8e38d352a71f512a5d461170ad78c6406f55b46", "message": "ARTEMIS-2886 optimize security auth\n\nBoth authentication and authorization will hit the underlying security\nrepository (e.g. files, LDAP, etc.). For example, creating a JMS\nconnection and a consumer will result in 2 hits with the *same*\nauthentication request. This can cause unwanted (and unnecessary)\nresource utilization, especially in the case of networked configuration\nlike LDAP.\n\nThere is already a rudimentary cache for authorization, but it is\ncleared *totally* every 10 seconds by default (controlled via the\nsecurity-invalidation-interval setting), and it must be populated\ninitially which still results in duplicate auth requests.\n\nThis commit optimizes authentication and authorization via the following\nchanges:\n\n - Replace our home-grown cache with Google Guava's cache. This provides\nsimple caching with both time-based and size-based LRU eviction. See more\nat https://github.com/google/guava/wiki/CachesExplained. I also thought\nabout using Caffeine, but we already have a dependency on Guava and the\ncache implementions look to be negligibly different for this use-case.\n - Add caching for authentication. Both successful and unsuccessful\nauthentication attempts will be cached to spare the underlying security\nrepository as much as possible. Authenticated Subjects will be cached\nand re-used whenever possible.\n - Authorization will used Subjects cached during authentication. If the\nrequired Subject is not in the cache it will be fetched from the\nunderlying security repo.\n - Caching can be disabled by setting the security-invalidation-interval\nto 0.\n - Cache sizes are configurable.\n - Management operations exist to inspect cache sizes at runtime.", "committedDate": "2020-08-26T17:45:31Z", "type": "forcePushed"}, {"oid": "8c45feead9729559ab6cddba1cc2d7a894e51eba", "url": "https://github.com/apache/activemq-artemis/commit/8c45feead9729559ab6cddba1cc2d7a894e51eba", "message": "ARTEMIS-2886 optimize security auth\n\nBoth authentication and authorization will hit the underlying security\nrepository (e.g. files, LDAP, etc.). For example, creating a JMS\nconnection and a consumer will result in 2 hits with the *same*\nauthentication request. This can cause unwanted (and unnecessary)\nresource utilization, especially in the case of networked configuration\nlike LDAP.\n\nThere is already a rudimentary cache for authorization, but it is\ncleared *totally* every 10 seconds by default (controlled via the\nsecurity-invalidation-interval setting), and it must be populated\ninitially which still results in duplicate auth requests.\n\nThis commit optimizes authentication and authorization via the following\nchanges:\n\n - Replace our home-grown cache with Google Guava's cache. This provides\nsimple caching with both time-based and size-based LRU eviction. See more\nat https://github.com/google/guava/wiki/CachesExplained. I also thought\nabout using Caffeine, but we already have a dependency on Guava and the\ncache implementions look to be negligibly different for this use-case.\n - Add caching for authentication. Both successful and unsuccessful\nauthentication attempts will be cached to spare the underlying security\nrepository as much as possible. Authenticated Subjects will be cached\nand re-used whenever possible.\n - Authorization will used Subjects cached during authentication. If the\nrequired Subject is not in the cache it will be fetched from the\nunderlying security repo.\n - Caching can be disabled by setting the security-invalidation-interval\nto 0.\n - Cache sizes are configurable.\n - Management operations exist to inspect cache sizes at runtime.", "committedDate": "2020-08-26T18:19:00Z", "type": "forcePushed"}, {"oid": "90853409a04bed9f64787447528defe869213b52", "url": "https://github.com/apache/activemq-artemis/commit/90853409a04bed9f64787447528defe869213b52", "message": "ARTEMIS-2886 optimize security auth\n\nBoth authentication and authorization will hit the underlying security\nrepository (e.g. files, LDAP, etc.). For example, creating a JMS\nconnection and a consumer will result in 2 hits with the *same*\nauthentication request. This can cause unwanted (and unnecessary)\nresource utilization, especially in the case of networked configuration\nlike LDAP.\n\nThere is already a rudimentary cache for authorization, but it is\ncleared *totally* every 10 seconds by default (controlled via the\nsecurity-invalidation-interval setting), and it must be populated\ninitially which still results in duplicate auth requests.\n\nThis commit optimizes authentication and authorization via the following\nchanges:\n\n - Replace our home-grown cache with Google Guava's cache. This provides\nsimple caching with both time-based and size-based LRU eviction. See more\nat https://github.com/google/guava/wiki/CachesExplained. I also thought\nabout using Caffeine, but we already have a dependency on Guava and the\ncache implementions look to be negligibly different for this use-case.\n - Add caching for authentication. Both successful and unsuccessful\nauthentication attempts will be cached to spare the underlying security\nrepository as much as possible. Authenticated Subjects will be cached\nand re-used whenever possible.\n - Authorization will used Subjects cached during authentication. If the\nrequired Subject is not in the cache it will be fetched from the\nunderlying security repo.\n - Caching can be disabled by setting the security-invalidation-interval\nto 0.\n - Cache sizes are configurable.\n - Management operations exist to inspect cache sizes at runtime.", "committedDate": "2020-08-26T18:36:24Z", "type": "commit"}, {"oid": "90853409a04bed9f64787447528defe869213b52", "url": "https://github.com/apache/activemq-artemis/commit/90853409a04bed9f64787447528defe869213b52", "message": "ARTEMIS-2886 optimize security auth\n\nBoth authentication and authorization will hit the underlying security\nrepository (e.g. files, LDAP, etc.). For example, creating a JMS\nconnection and a consumer will result in 2 hits with the *same*\nauthentication request. This can cause unwanted (and unnecessary)\nresource utilization, especially in the case of networked configuration\nlike LDAP.\n\nThere is already a rudimentary cache for authorization, but it is\ncleared *totally* every 10 seconds by default (controlled via the\nsecurity-invalidation-interval setting), and it must be populated\ninitially which still results in duplicate auth requests.\n\nThis commit optimizes authentication and authorization via the following\nchanges:\n\n - Replace our home-grown cache with Google Guava's cache. This provides\nsimple caching with both time-based and size-based LRU eviction. See more\nat https://github.com/google/guava/wiki/CachesExplained. I also thought\nabout using Caffeine, but we already have a dependency on Guava and the\ncache implementions look to be negligibly different for this use-case.\n - Add caching for authentication. Both successful and unsuccessful\nauthentication attempts will be cached to spare the underlying security\nrepository as much as possible. Authenticated Subjects will be cached\nand re-used whenever possible.\n - Authorization will used Subjects cached during authentication. If the\nrequired Subject is not in the cache it will be fetched from the\nunderlying security repo.\n - Caching can be disabled by setting the security-invalidation-interval\nto 0.\n - Cache sizes are configurable.\n - Management operations exist to inspect cache sizes at runtime.", "committedDate": "2020-08-26T18:36:24Z", "type": "forcePushed"}]}