{"pr_number": 3316, "pr_title": "ARTEMIS-2937 Broker Connections", "pr_createdAt": "2020-10-28T00:28:37Z", "pr_url": "https://github.com/apache/activemq-artemis/pull/3316", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE0NDk4OA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513144988", "bodyText": "The comment says it will create a \"sender\" and the \"name\" of the amqp-connection is \"sender\", but a receiver is actually configured here.", "author": "jbertram", "createdAt": "2020-10-28T02:39:07Z", "path": "examples/features/broker-connection/amqp-receiving-messages/src/main/resources/activemq/server0/broker.xml", "diffHunk": "@@ -0,0 +1,117 @@\n+<?xml version='1.0'?>\n+<!--\n+Licensed to the Apache Software Foundation (ASF) under one\n+or more contributor license agreements.  See the NOTICE file\n+distributed with this work for additional information\n+regarding copyright ownership.  The ASF licenses this file\n+to you under the Apache License, Version 2.0 (the\n+\"License\"); you may not use this file except in compliance\n+with the License.  You may obtain a copy of the License at\n+\n+  http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing,\n+software distributed under the License is distributed on an\n+\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+KIND, either express or implied.  See the License for the\n+specific language governing permissions and limitations\n+under the License.\n+-->\n+\n+<configuration xmlns=\"urn:activemq\"\n+               xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+               xmlns:xi=\"http://www.w3.org/2001/XInclude\"\n+               xsi:schemaLocation=\"urn:activemq /schema/artemis-configuration.xsd\">\n+\n+   <core xmlns=\"urn:activemq:core\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"urn:activemq:core \">\n+\n+      <name>0.0.0.0</name>\n+\n+\n+      <persistence-enabled>false</persistence-enabled>\n+\n+      <journal-type>NIO</journal-type>\n+\n+      <!-- should the broker detect dead locks and other issues -->\n+      <critical-analyzer>true</critical-analyzer>\n+\n+      <critical-analyzer-timeout>120000</critical-analyzer-timeout>\n+\n+      <critical-analyzer-check-period>60000</critical-analyzer-check-period>\n+\n+      <critical-analyzer-policy>HALT</critical-analyzer-policy>\n+\n+\n+      <page-sync-timeout>44000</page-sync-timeout>\n+\n+      <acceptors>\n+         <!-- Acceptor for every supported protocol -->\n+         <acceptor name=\"artemis\">tcp://0.0.0.0:5671?tcpSendBufferSize=1048576;tcpReceiveBufferSize=1048576;amqpMinLargeMessageSize=102400;protocols=CORE,AMQP,STOMP,HORNETQ,MQTT,OPENWIRE;useEpoll=true;amqpCredits=1000;amqpLowCredits=300;amqpDuplicateDetection=true</acceptor>\n+\n+      </acceptors>\n+\n+      <broker-connections>\n+         <amqp-connection uri=\"tcp://localhost:5672\" name=\"sender\" retry-interval=\"100\">\n+            <!-- This will create one sender for every queue matching this address expression -->\n+            <receiver match=\"#\"/>", "originalCommit": "fb0056948d967928e2a79b1b191e5e2b5ab8d588", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5OTA2OA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513499068", "bodyText": "thanks a lot... fixed it", "author": "clebertsuconic", "createdAt": "2020-10-28T14:40:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE0NDk4OA=="}], "type": "inlineReview"}, {"oid": "7691c0a04ab3f955c1feac1e0578da88575551df", "url": "https://github.com/apache/activemq-artemis/commit/7691c0a04ab3f955c1feac1e0578da88575551df", "message": "ARTEMIS-2937 DOCS & Examples on AMQP Broker Connection", "committedDate": "2020-10-28T14:38:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MDI3Ng==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513480276", "bodyText": "I don't think this 'important' is necessary, it is true of all features all of the time.", "author": "gtully", "createdAt": "2020-10-28T14:18:10Z", "path": "docs/user-manual/en/amqp-broker-connections.md", "diffHunk": "@@ -0,0 +1,238 @@\n+# Broker Connections\n+\n+Instead of waiting for clients to connect, a broker can initiate a connection to another endpoint on a specific protocol.\n+\n+Currently, this feature supports only the AMQP protocol. However, in the future, it might be expanded to other protocols.\n+\n+You configure broker connections using a `<broker-connections>` element in the `broker.xml` configuration file.\n+\n+*Important*: This is a new feature. That means test your usecases well and report eventual issues through users@activemq.apache.org, as the community is actively working to resolve any issues around Broker Connections.", "originalCommit": "fb0056948d967928e2a79b1b191e5e2b5ab8d588", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwMjM3NQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513502375", "bodyText": "I thought I had removed that already.. thanks!", "author": "clebertsuconic", "createdAt": "2020-10-28T14:44:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MDI3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MzYwNA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513483604", "bodyText": "replace: initiate to other endpoints\nwith: initiate connections", "author": "gtully", "createdAt": "2020-10-28T14:22:19Z", "path": "docs/user-manual/en/amqp-broker-connections.md", "diffHunk": "@@ -0,0 +1,238 @@\n+# Broker Connections\n+\n+Instead of waiting for clients to connect, a broker can initiate a connection to another endpoint on a specific protocol.\n+\n+Currently, this feature supports only the AMQP protocol. However, in the future, it might be expanded to other protocols.\n+\n+You configure broker connections using a `<broker-connections>` element in the `broker.xml` configuration file.\n+\n+*Important*: This is a new feature. That means test your usecases well and report eventual issues through users@activemq.apache.org, as the community is actively working to resolve any issues around Broker Connections.\n+\n+```xml\n+<broker-connections>\n+    ...\n+</broker-connections>\n+```\n+\n+# AMQP Server Connections\n+\n+An ActiveMQ Artemis broker can initiate to other endpoints using the AMQP protocol. This means that the broker can connect to another AMQP server (not necessarily ActiveMQ Artemis) and create elements on that connection.", "originalCommit": "fb0056948d967928e2a79b1b191e5e2b5ab8d588", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4NDY0Ng==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513484646", "bodyText": "if auto-start is false, when will the connection start?", "author": "gtully", "createdAt": "2020-10-28T14:23:36Z", "path": "docs/user-manual/en/amqp-broker-connections.md", "diffHunk": "@@ -0,0 +1,238 @@\n+# Broker Connections\n+\n+Instead of waiting for clients to connect, a broker can initiate a connection to another endpoint on a specific protocol.\n+\n+Currently, this feature supports only the AMQP protocol. However, in the future, it might be expanded to other protocols.\n+\n+You configure broker connections using a `<broker-connections>` element in the `broker.xml` configuration file.\n+\n+*Important*: This is a new feature. That means test your usecases well and report eventual issues through users@activemq.apache.org, as the community is actively working to resolve any issues around Broker Connections.\n+\n+```xml\n+<broker-connections>\n+    ...\n+</broker-connections>\n+```\n+\n+# AMQP Server Connections\n+\n+An ActiveMQ Artemis broker can initiate to other endpoints using the AMQP protocol. This means that the broker can connect to another AMQP server (not necessarily ActiveMQ Artemis) and create elements on that connection.\n+\n+To define an AMQP broker connection, add an `<amqp-connection>` element within the `<broker-connections` element in the `broker.xml` configuration file. For example:\n+\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\" retry-interval=\"100\" reconnect-attempts=\"-1\" user=\"john\" password=\"doe\">\n+         ...\n+    </amqp-connection>\n+</broker-connections>\n+```\n+\n+- `uri`: tcp://host:myport (this is a required argument)\n+- `name`: Name of the connection used for management purposes\n+- `user`: User name with which to connect to the endpoint (this is an optional argument)\n+- `password`: Password with which to connect to the endpoint (this is an optional argument)\n+- `retry-interval`: Time, in milliseconds to wait before retrying a connection after an error. The default value is `5000`.\n+- `reconnect-attempts`: default is -1 meaning infinite\n+- `auto-start` : Should the broker connection start automatically with the broker. Default is `true`.", "originalCommit": "fb0056948d967928e2a79b1b191e5e2b5ab8d588", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5MzE0Nw==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513493147", "bodyText": "Are match and queue-name common to all elements?\nif so, maybe point that out up front, as in all elements operate on queues via a single instance or a match.\nbtw: why not have match=x where x can be a wildcard. when it is a simple name then it is the same as queue-name. as in, I don't see the need for two attributes. what did I miss?", "author": "gtully", "createdAt": "2020-10-28T14:33:43Z", "path": "docs/user-manual/en/amqp-broker-connections.md", "diffHunk": "@@ -0,0 +1,238 @@\n+# Broker Connections\n+\n+Instead of waiting for clients to connect, a broker can initiate a connection to another endpoint on a specific protocol.\n+\n+Currently, this feature supports only the AMQP protocol. However, in the future, it might be expanded to other protocols.\n+\n+You configure broker connections using a `<broker-connections>` element in the `broker.xml` configuration file.\n+\n+*Important*: This is a new feature. That means test your usecases well and report eventual issues through users@activemq.apache.org, as the community is actively working to resolve any issues around Broker Connections.\n+\n+```xml\n+<broker-connections>\n+    ...\n+</broker-connections>\n+```\n+\n+# AMQP Server Connections\n+\n+An ActiveMQ Artemis broker can initiate to other endpoints using the AMQP protocol. This means that the broker can connect to another AMQP server (not necessarily ActiveMQ Artemis) and create elements on that connection.\n+\n+To define an AMQP broker connection, add an `<amqp-connection>` element within the `<broker-connections` element in the `broker.xml` configuration file. For example:\n+\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\" retry-interval=\"100\" reconnect-attempts=\"-1\" user=\"john\" password=\"doe\">\n+         ...\n+    </amqp-connection>\n+</broker-connections>\n+```\n+\n+- `uri`: tcp://host:myport (this is a required argument)\n+- `name`: Name of the connection used for management purposes\n+- `user`: User name with which to connect to the endpoint (this is an optional argument)\n+- `password`: Password with which to connect to the endpoint (this is an optional argument)\n+- `retry-interval`: Time, in milliseconds to wait before retrying a connection after an error. The default value is `5000`.\n+- `reconnect-attempts`: default is -1 meaning infinite\n+- `auto-start` : Should the broker connection start automatically with the broker. Default is `true`.\n+\n+*Important*: The target endpoint needs permission for all operations that you configure. Therefore, If you are using a security manager, ensure that you perform the configured operations as a user with sufficient permissions.\n+\n+# AMQP Server Connection elements\n+The following types of elements are supported on a AMQP server connection:\n+\n+* Senders\n+    * Messages received on specific queues are transferred to another endpoint\n+* Receivers\n+    * The broker pulls messages from another endpoint\n+* Peers\n+    * The broker creates both senders and receivers on another endpoint that knows how to handle them. Currently, this is implemented by Apache Qpid Dispatch.\n+* Mirrors\n+    * The broker uses an AMQP connection to another broker and duplicate messages and sends acknowledgements over the wire.\n+\n+## Senders and Receivers\n+It is possible to connect an ActiveMQ Artemis broker to another AMQP endpoint simply by creating a sender or receiver broker connection element.\n+\n+For a `sender`, the broker creates a message consumer on a queue that sends messages to another AMQP endpoint.\n+\n+For a `receiver`, the broker creates a message producer on an address that receives messages from another AMQP endpoint.\n+\n+Both elements work like a message bridge. However, there is no additional overhead required to process messages. Senders and receivers behave just like any other consumer or producer in ActiveMQ Artemis.\n+\n+You can configure senders or receivers for specific queues. You can also match senders and receivers to specific addresses or _sets_ of addresses, using wildcard expressions. When configuring a sender or receiver, you can set the following properties:\n+\n+- `match`: Match the sender or receiver to a specific address or __set__ of addresses, using a wildcard expression\n+- `queue-name`: Configure the sender or receiver for a specific queue", "originalCommit": "fb0056948d967928e2a79b1b191e5e2b5ab8d588", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwNDkzOQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513504939", "bodyText": "match is not available on mirror ATM. but it's available on the others.\nI had plans to implement it on mirror, but had some difficulties at the moment.", "author": "clebertsuconic", "createdAt": "2020-10-28T14:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5MzE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5NDIyNA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513494224", "bodyText": "'send' should be 'sent'", "author": "gtully", "createdAt": "2020-10-28T14:35:00Z", "path": "docs/user-manual/en/amqp-broker-connections.md", "diffHunk": "@@ -0,0 +1,238 @@\n+# Broker Connections\n+\n+Instead of waiting for clients to connect, a broker can initiate a connection to another endpoint on a specific protocol.\n+\n+Currently, this feature supports only the AMQP protocol. However, in the future, it might be expanded to other protocols.\n+\n+You configure broker connections using a `<broker-connections>` element in the `broker.xml` configuration file.\n+\n+*Important*: This is a new feature. That means test your usecases well and report eventual issues through users@activemq.apache.org, as the community is actively working to resolve any issues around Broker Connections.\n+\n+```xml\n+<broker-connections>\n+    ...\n+</broker-connections>\n+```\n+\n+# AMQP Server Connections\n+\n+An ActiveMQ Artemis broker can initiate to other endpoints using the AMQP protocol. This means that the broker can connect to another AMQP server (not necessarily ActiveMQ Artemis) and create elements on that connection.\n+\n+To define an AMQP broker connection, add an `<amqp-connection>` element within the `<broker-connections` element in the `broker.xml` configuration file. For example:\n+\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\" retry-interval=\"100\" reconnect-attempts=\"-1\" user=\"john\" password=\"doe\">\n+         ...\n+    </amqp-connection>\n+</broker-connections>\n+```\n+\n+- `uri`: tcp://host:myport (this is a required argument)\n+- `name`: Name of the connection used for management purposes\n+- `user`: User name with which to connect to the endpoint (this is an optional argument)\n+- `password`: Password with which to connect to the endpoint (this is an optional argument)\n+- `retry-interval`: Time, in milliseconds to wait before retrying a connection after an error. The default value is `5000`.\n+- `reconnect-attempts`: default is -1 meaning infinite\n+- `auto-start` : Should the broker connection start automatically with the broker. Default is `true`.\n+\n+*Important*: The target endpoint needs permission for all operations that you configure. Therefore, If you are using a security manager, ensure that you perform the configured operations as a user with sufficient permissions.\n+\n+# AMQP Server Connection elements\n+The following types of elements are supported on a AMQP server connection:\n+\n+* Senders\n+    * Messages received on specific queues are transferred to another endpoint\n+* Receivers\n+    * The broker pulls messages from another endpoint\n+* Peers\n+    * The broker creates both senders and receivers on another endpoint that knows how to handle them. Currently, this is implemented by Apache Qpid Dispatch.\n+* Mirrors\n+    * The broker uses an AMQP connection to another broker and duplicate messages and sends acknowledgements over the wire.\n+\n+## Senders and Receivers\n+It is possible to connect an ActiveMQ Artemis broker to another AMQP endpoint simply by creating a sender or receiver broker connection element.\n+\n+For a `sender`, the broker creates a message consumer on a queue that sends messages to another AMQP endpoint.\n+\n+For a `receiver`, the broker creates a message producer on an address that receives messages from another AMQP endpoint.\n+\n+Both elements work like a message bridge. However, there is no additional overhead required to process messages. Senders and receivers behave just like any other consumer or producer in ActiveMQ Artemis.\n+\n+You can configure senders or receivers for specific queues. You can also match senders and receivers to specific addresses or _sets_ of addresses, using wildcard expressions. When configuring a sender or receiver, you can set the following properties:\n+\n+- `match`: Match the sender or receiver to a specific address or __set__ of addresses, using a wildcard expression\n+- `queue-name`: Configure the sender or receiver for a specific queue\n+\n+\n+Some examples are shown below.\n+\n+Using address expressions:\n+```xml\n+<broker-connections>\n+        <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\">\n+                <sender match=\"queues.#\"/>\n+                <!-- notice the local queues for remotequeues.# need to be created on this broker -->\n+                <receiver match=\"remotequeues.#\"/>\n+        </amqp-connection>\n+</broker-connections>\n+\n+<addresses>\n+        <address name=\"remotequeues.A\">\n+                <anycast>\n+                        <queue name=\"remoteQueueA\"/>\n+                </anycast>\n+        </address>\n+        <address name=\"queues.B\">\n+                 <anycast>\n+                        <queue name=\"localQueueB\"/>\n+                </anycast>\n+        </address>\n+</addresses>\n+```\n+\n+Using queue names:\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\">\n+        <receiver queue-name=\"remoteQueueA\"/>\n+        <sender queue-name=\"localQueueB\"/>\n+    </amqp-connection>\n+</broker-connections>\n+\n+<addresses>\n+     <address name=\"remotequeues.A\">\n+        <anycast>\n+           <queue name=\"remoteQueueA\"/>\n+        </anycast>\n+     </address>\n+     <address name=\"queues.B\">\n+        <anycast>\n+           <queue name=\"localQueueB\"/>\n+        </anycast>\n+     </address>\n+</addresses>\n+\n+```\n+*Important*: You can match a receiver only to a local queue that already exists. Therefore, if you are using receivers, make sure that you pre-create the queue locally. Otherwise, the broker cannot match the remote queues and addresses.\n+\n+*Important*: Do not create a sender and a receiver to the same destination. This creates an infinite loop of sends and receives.\n+\n+\n+# Peers\n+A peer broker connection element is a combination of sender and receivers. The ActiveMQ Artemis broker creates both a sender and a receiver for a peer element, and the endpoint knows how to deal with the pair without creating an infinite loop of sending and receiving messages.\n+\n+Currently, [Apache Qpid Dispatch Router](https://qpid.apache.org/components/dispatch-router/index.html) is a peer. ActiveMQ Artemis creates the pair of receivers and sender for each matching destination. These senders and receivers have special configuration to let Qpid Dispatch Router know to collaborate with ActiveMQ Artemis.\n+\n+You can experiment with advanced networking scenarios with Qpid Dispatch Router and get a lot of benefit from the AMQP protocol and its ecosystem.\n+\n+WWith a peer, you have the same properties that you have on a sender and receiver. For example:\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\">\n+       <peer match=\"queues.#\"/>\n+    </amqp-connection>\n+</broker-connections>\n+\n+<addresses>\n+     <address name=\"queues.A\">\n+        <anycast>\n+           <queue name=\"localQueueA\"/>\n+        </anycast>\n+     </address>\n+     <address name=\"queues.B\">\n+     <anycast>\n+        <queue name=\"localQueueB\"/>\n+     </anycast>\n+    </address>\n+</addresses>\n+```\n+\n+*Important:* Do not use this feature to connect to another broker, otherwise any message send will be immediately ready to consume creating an infinite echo of sends and receives.", "originalCommit": "fb0056948d967928e2a79b1b191e5e2b5ab8d588", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "10de26f79f309f699f53012dacb1fe9fdc2b22c7", "url": "https://github.com/apache/activemq-artemis/commit/10de26f79f309f699f53012dacb1fe9fdc2b22c7", "message": "ARTEMIS-2937 DOC updates", "committedDate": "2020-10-28T14:59:46Z", "type": "forcePushed"}, {"oid": "8499eac76c2044bfa52a65b9ada15581cd2efb7a", "url": "https://github.com/apache/activemq-artemis/commit/8499eac76c2044bfa52a65b9ada15581cd2efb7a", "message": "ARTEMIS-2937 Server Side AMQP Connectivity with options to transfer queues or replicate data", "committedDate": "2020-10-28T15:37:25Z", "type": "commit"}, {"oid": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "url": "https://github.com/apache/activemq-artemis/commit/12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "message": "ARTEMIS-2937 DOCS & Examples on AMQP Broker Connection", "committedDate": "2020-10-28T15:37:25Z", "type": "commit"}, {"oid": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "url": "https://github.com/apache/activemq-artemis/commit/12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "message": "ARTEMIS-2937 DOCS & Examples on AMQP Broker Connection", "committedDate": "2020-10-28T15:37:25Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM5MzYyNA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513393624", "bodyText": "Since there appears to be a fixed 'head' node that always exists, and doesnt seem to ever be in the nodeMap, what does it mean if node.prev is null here?\nI ask as it seems odd that removal with id could return a value as in this case, but appear not to do anything at all to update the main list structure? When can that happen? (I may be missing something obvious here..)", "author": "gemmellr", "createdAt": "2020-10-28T12:12:22Z", "path": "artemis-commons/src/main/java/org/apache/activemq/artemis/utils/collections/LinkedListImpl.java", "diffHunk": "@@ -72,9 +115,43 @@ public void addHead(E e) {\n          node.next.prev = node;\n       }\n \n+      itemAdded(node, e);\n+\n       size++;\n    }\n \n+   @Override\n+   public E removeWithID(long id) {\n+      if (nodeMap == null) {\n+         return null;\n+      }\n+\n+      Node<E> node = nodeMap.get(id);\n+      if (node == null) {\n+         return null;\n+      }\n+\n+      if (node.prev != null) {\n+         removeAfter(node.prev);\n+      }", "originalCommit": "fb0056948d967928e2a79b1b191e5e2b5ab8d588", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwNTg4NA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513605884", "bodyText": "if node != null, not.prev will always be != null...\nWe are adding the nodes to a separate list... the head will also be on the nodeList.\nthe != null is actually my OCD being extra careful. if you are strong opinioned about it I can take it out.", "author": "clebertsuconic", "createdAt": "2020-10-28T16:53:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM5MzYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDEzMTY3NA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r514131674", "bodyText": "Its more confusion and concern that it has modified the 'side area' map at this point but could return without removing anything from the the actual main list structure. If this is something to be careful about it seems more like it should be throwing an IllegalStateException or somthing rather than silently skipping, since the list must be broken for the check to have any effect.", "author": "gemmellr", "createdAt": "2020-10-29T09:51:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM5MzYyNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDIwNTI2NA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r514205264", "bodyText": "I removed the check..", "author": "clebertsuconic", "createdAt": "2020-10-29T12:02:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM5MzYyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM5OTM2MA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513399360", "bodyText": "This isnt used, tested, or similarly included on the PriorityLinkedList.\nShould it just be removed for now, or added to the PriorityLinkedList and tested?", "author": "gemmellr", "createdAt": "2020-10-28T12:22:36Z", "path": "artemis-commons/src/main/java/org/apache/activemq/artemis/utils/collections/LinkedListImpl.java", "diffHunk": "@@ -20,39 +20,82 @@\n import java.util.Comparator;\n import java.util.NoSuchElementException;\n import java.util.Objects;\n+import java.util.function.ToLongFunction;\n+\n+import io.netty.util.collection.LongObjectHashMap;\n \n /**\n  * A linked list implementation which allows multiple iterators to exist at the same time on the queue, and which see any\n  * elements added or removed from the queue either directly or via iterators.\n- *\n+ * <p>\n  * This class is not thread safe.\n  */\n public class LinkedListImpl<E> implements LinkedList<E> {\n \n    private static final int INITIAL_ITERATOR_ARRAY_SIZE = 10;\n \n    private final Node<E> head = new NodeHolder<>(null);\n-\n+   private final Comparator<E> comparator;\n+   LongObjectHashMap<Node<E>> nodeMap;\n    private Node<E> tail = null;\n-\n    private int size;\n-\n    // We store in an array rather than a Map for the best performance\n    private volatile Iterator[] iters;\n-\n    private int numIters;\n-\n    private int nextIndex;\n-\n-   private final Comparator<E> comparator;\n+   private ToLongFunction<E> idSupplier;\n \n    public LinkedListImpl() {\n-      this(null);\n+      this(null, null);\n    }\n \n    public LinkedListImpl(Comparator<E> comparator) {\n+      this(comparator, null);\n+   }\n+\n+   public LinkedListImpl(Comparator<E> comparator, ToLongFunction<E> supplier) {\n       iters = createIteratorArray(INITIAL_ITERATOR_ARRAY_SIZE);\n       this.comparator = comparator;\n+      this.idSupplier = supplier;\n+      if (idSupplier != null) {\n+         this.nodeMap = newLongHashMap();\n+      } else {\n+         this.nodeMap = null;\n+      }\n+   }\n+\n+   @Override\n+   public void clearID() {\n+      idSupplier = null;\n+      if (nodeMap != null) {\n+         nodeMap.clear();\n+         nodeMap = null;\n+      }\n+   }", "originalCommit": "fb0056948d967928e2a79b1b191e5e2b5ab8d588", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2MTExMQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513461111", "bodyText": "Debug stacktrace left over", "author": "gemmellr", "createdAt": "2020-10-28T13:53:58Z", "path": "artemis-server/src/main/java/org/apache/activemq/artemis/core/server/impl/MessageReferenceImpl.java", "diffHunk": "@@ -362,6 +362,7 @@ public PagingStore getOwner() {\n \n    @Override\n    public void setOwner(PagingStore owner) {\n+      new Exception(\"Setting owner as \" + owner.getStoreName()).printStackTrace();", "originalCommit": "fb0056948d967928e2a79b1b191e5e2b5ab8d588", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2ODE0Mg==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513468142", "bodyText": "Would read better if the \"// Fixed-address producer\" bit was outside the inner if, where it was originally, to balance with the comment in the other leg ( // Anonymous-relay producer, message must carry a To value)", "author": "gemmellr", "createdAt": "2020-10-28T14:02:50Z", "path": "artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/broker/AMQPSessionCallback.java", "diffHunk": "@@ -466,8 +466,10 @@ public void serverSend(ProtonServerReceiverContext context,\n \n       RoutingType routingType = null;\n       if (address != null) {\n-         // Fixed-address producer\n-         message.setAddress(address);\n+         if (!address.toString().equals(message.getAddress())) {\n+            // set Fixed-address producer if the message.properties.to address differs from the producer\n+            message.setAddress(address);\n+         }", "originalCommit": "fb0056948d967928e2a79b1b191e5e2b5ab8d588", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2ODgzNg==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513468836", "bodyText": "typo in AMQPConenctionBridge\nEDIT: Actually, the comment may be in the wrong place? This is a provate method so it cant directly be used by AMQPConnectionBridge", "author": "gemmellr", "createdAt": "2020-10-28T14:03:48Z", "path": "artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/broker/ProtonProtocolManager.java", "diffHunk": "@@ -173,8 +177,35 @@ public ProtonProtocolManager setDirectDeliver(boolean directDeliver) {\n       return this;\n    }\n \n+   /** for outgoing */\n+   public ProtonClientProtocolManager createClientManager() {\n+      ProtonClientProtocolManager clientOutgoing = new ProtonClientProtocolManager(factory, server);\n+      return clientOutgoing;\n+   }\n+\n    @Override\n    public ConnectionEntry createConnectionEntry(Acceptor acceptorUsed, Connection remotingConnection) {\n+      return internalConnectionEntry(remotingConnection, false, null);\n+   }\n+\n+   /** This method is not part of the ProtocolManager interface because it only makes sense on AMQP.\n+    *  More specifically on AMQP Bridges */\n+   public ConnectionEntry createOutgoingConnectionEntry(Connection remotingConnection) {\n+      return internalConnectionEntry(remotingConnection, true, null);\n+   }\n+\n+   public ConnectionEntry createOutgoingConnectionEntry(Connection remotingConnection, ClientSASLFactory saslFactory) {\n+      return internalConnectionEntry(remotingConnection, true, saslFactory);\n+   }\n+\n+   /**\n+    * AMQP is an agnostic protocol, client and server.\n+    * This method is used also by the AMQPConenctionBridge where there is no acceptor in place.", "originalCommit": "fb0056948d967928e2a79b1b191e5e2b5ab8d588", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwNzQ5NQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513607495", "bodyText": "I removed the comment.", "author": "clebertsuconic", "createdAt": "2020-10-28T16:55:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2ODgzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4NDU0MQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513484541", "bodyText": "This section appears like it probably isnt thread safe in its use of proton-j.\nThe initial connection open and a flush is offloaded to the connection thread...then this thread proceeds to create a session object on the connection, though then offloads its open and flush and open call back to the connection thread. The next bit where it starts creating senders and recievers on this thread (if not more, depends whether the Stream returned was sequential or not) is probably safe as those bits offload to the connection thread I believe.", "author": "gemmellr", "createdAt": "2020-10-28T14:23:28Z", "path": "artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/connect/AMQPBrokerConnection.java", "diffHunk": "@@ -0,0 +1,556 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.activemq.artemis.protocol.amqp.connect;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Stream;\n+\n+import org.apache.activemq.artemis.api.core.ActiveMQException;\n+import org.apache.activemq.artemis.api.core.QueueConfiguration;\n+import org.apache.activemq.artemis.api.core.RoutingType;\n+import org.apache.activemq.artemis.api.core.SimpleString;\n+import org.apache.activemq.artemis.api.core.TransportConfiguration;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectConfiguration;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectionAddressType;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectionElement;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPMirrorBrokerConnectionElement;\n+import org.apache.activemq.artemis.core.postoffice.Binding;\n+import org.apache.activemq.artemis.core.postoffice.QueueBinding;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.NettyConnection;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.NettyConnector;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.TransportConstants;\n+import org.apache.activemq.artemis.core.server.ActiveMQComponent;\n+import org.apache.activemq.artemis.core.server.ActiveMQServer;\n+import org.apache.activemq.artemis.core.server.BrokerConnection;\n+import org.apache.activemq.artemis.core.server.Consumer;\n+import org.apache.activemq.artemis.core.server.Queue;\n+import org.apache.activemq.artemis.core.server.impl.AddressInfo;\n+import org.apache.activemq.artemis.core.server.mirror.MirrorController;\n+import org.apache.activemq.artemis.core.server.plugin.ActiveMQServerQueuePlugin;\n+import org.apache.activemq.artemis.protocol.amqp.broker.AMQPSessionCallback;\n+import org.apache.activemq.artemis.protocol.amqp.broker.ActiveMQProtonRemotingConnection;\n+import org.apache.activemq.artemis.protocol.amqp.broker.ProtonProtocolManager;\n+import org.apache.activemq.artemis.protocol.amqp.connect.mirror.AMQPMirrorControllerAggregation;\n+import org.apache.activemq.artemis.protocol.amqp.connect.mirror.AMQPMirrorControllerSource;\n+import org.apache.activemq.artemis.protocol.amqp.logger.ActiveMQAMQPProtocolLogger;\n+import org.apache.activemq.artemis.protocol.amqp.proton.AMQPSessionContext;\n+import org.apache.activemq.artemis.protocol.amqp.proton.ProtonServerSenderContext;\n+import org.apache.activemq.artemis.protocol.amqp.proton.SenderController;\n+import org.apache.activemq.artemis.protocol.amqp.sasl.ClientSASL;\n+import org.apache.activemq.artemis.protocol.amqp.sasl.ClientSASLFactory;\n+import org.apache.activemq.artemis.spi.core.protocol.ConnectionEntry;\n+import org.apache.activemq.artemis.spi.core.remoting.ClientConnectionLifeCycleListener;\n+import org.apache.activemq.artemis.spi.core.remoting.ClientProtocolManager;\n+import org.apache.activemq.artemis.spi.core.remoting.Connection;\n+import org.apache.activemq.artemis.utils.ConfigurationHelper;\n+import org.apache.activemq.artemis.utils.UUIDGenerator;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.Source;\n+import org.apache.qpid.proton.amqp.messaging.Target;\n+import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;\n+import org.apache.qpid.proton.amqp.transport.SenderSettleMode;\n+import org.apache.qpid.proton.engine.Receiver;\n+import org.apache.qpid.proton.engine.Sender;\n+import org.apache.qpid.proton.engine.Session;\n+import org.jboss.logging.Logger;\n+\n+public class AMQPBrokerConnection implements ClientConnectionLifeCycleListener, ActiveMQServerQueuePlugin, BrokerConnection {\n+\n+   private static final Logger logger = Logger.getLogger(AMQPBrokerConnection.class);\n+\n+   private final AMQPBrokerConnectConfiguration brokerConnectConfiguration;\n+   private final ProtonProtocolManager protonProtocolManager;\n+   private final ActiveMQServer server;\n+   private final NettyConnector bridgesConnector;\n+   private NettyConnection connection;\n+   private Session session;\n+   private AMQPSessionContext sessionContext;\n+   private ActiveMQProtonRemotingConnection protonRemotingConnection;\n+   private volatile boolean started = false;\n+   private final AMQPBrokerConnectionManager bridgeManager;\n+   private int retryCounter = 0;\n+   private volatile ScheduledFuture reconnectFuture;\n+   private Set<Queue> senders = new HashSet<>();\n+   private Set<Queue> receivers = new HashSet<>();\n+\n+   final Executor connectExecutor;\n+   final ScheduledExecutorService scheduledExecutorService;\n+\n+   /** This is just for logging.\n+    *  the actual connection will come from the amqpConnection configuration*/\n+   String host;\n+\n+   /** This is just for logging.\n+    *  the actual connection will come from the amqpConnection configuration*/\n+   int port;\n+\n+   public AMQPBrokerConnection(AMQPBrokerConnectionManager bridgeManager, AMQPBrokerConnectConfiguration brokerConnectConfiguration,\n+                               ProtonProtocolManager protonProtocolManager,\n+                               ActiveMQServer server,\n+                               NettyConnector bridgesConnector) {\n+      this.bridgeManager = bridgeManager;\n+      this.brokerConnectConfiguration = brokerConnectConfiguration;\n+      this.protonProtocolManager = protonProtocolManager;\n+      this.server = server;\n+      this.bridgesConnector = bridgesConnector;\n+      connectExecutor = server.getExecutorFactory().getExecutor();\n+      scheduledExecutorService = server.getScheduledPool();\n+   }\n+\n+   @Override\n+   public String getName() {\n+      return brokerConnectConfiguration.getName();\n+   }\n+\n+   @Override\n+   public String getProtocol() {\n+      return \"AMQP\";\n+   }\n+\n+   @Override\n+   public boolean isStarted() {\n+      return started;\n+   }\n+\n+   @Override\n+   public void stop() {\n+      if (connection != null) {\n+         connection.close();\n+      }\n+      ScheduledFuture scheduledFuture = reconnectFuture;\n+      reconnectFuture = null;\n+      if (scheduledFuture != null) {\n+         scheduledFuture.cancel(true);\n+      }\n+      started = false;\n+   }\n+\n+   @Override\n+   public void start() throws Exception {\n+      started = true;\n+      server.getConfiguration().registerBrokerPlugin(this);\n+      try {\n+\n+         for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+            if (connectionElement.getType() == AMQPBrokerConnectionAddressType.MIRROR) {\n+               installMirrorController((AMQPMirrorBrokerConnectionElement)connectionElement, server);\n+            }\n+         }\n+      } catch (Throwable e) {\n+         logger.warn(e.getMessage(), e);\n+         return;\n+      }\n+      connectExecutor.execute(() -> doConnect());\n+   }\n+\n+   public NettyConnection getConnection() {\n+      return connection;\n+   }\n+\n+   @Override\n+   public void afterCreateQueue(Queue queue) {\n+      connectExecutor.execute(() -> {\n+         for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+            validateMatching(queue, connectionElement);\n+         }\n+      });\n+   }\n+\n+   public void validateMatching(Queue queue, AMQPBrokerConnectionElement connectionElement) {\n+      if (connectionElement.getType() != AMQPBrokerConnectionAddressType.MIRROR) {\n+         if (connectionElement.getQueueName() != null) {\n+            if (queue.getName().equals(connectionElement.getQueueName())) {\n+               createLink(queue, connectionElement);\n+            }\n+         } else if (connectionElement.match(queue.getAddress(), server.getConfiguration().getWildcardConfiguration())) {\n+            createLink(queue, connectionElement);\n+         }\n+      }\n+   }\n+\n+   public void createLink(Queue queue, AMQPBrokerConnectionElement connectionElement) {\n+      if (connectionElement.getType() == AMQPBrokerConnectionAddressType.PEER) {\n+         connectSender(queue, queue.getAddress().toString(), Symbol.valueOf(\"qd.waypoint\"));\n+         connectReceiver(protonRemotingConnection, session, sessionContext, queue, Symbol.valueOf(\"qd.waypoint\"));\n+      } else {\n+         if (connectionElement.getType() == AMQPBrokerConnectionAddressType.SENDER) {\n+            connectSender(queue, queue.getAddress().toString());\n+         }\n+         if (connectionElement.getType() == AMQPBrokerConnectionAddressType.RECEIVER) {\n+            connectReceiver(protonRemotingConnection, session, sessionContext, queue);\n+         }\n+      }\n+   }\n+\n+   private void doConnect() {\n+      try {\n+         List<TransportConfiguration> configurationList = brokerConnectConfiguration.getTransportConfigurations();\n+\n+         TransportConfiguration tpConfig = configurationList.get(0);\n+\n+         String hostOnParameter = ConfigurationHelper.getStringProperty(TransportConstants.HOST_PROP_NAME, TransportConstants.DEFAULT_HOST, tpConfig.getParams());\n+         int portOnParameter = ConfigurationHelper.getIntProperty(TransportConstants.PORT_PROP_NAME, TransportConstants.DEFAULT_PORT, tpConfig.getParams());\n+         this.host = hostOnParameter;\n+         this.port = portOnParameter;\n+         connection = bridgesConnector.createConnection(null, hostOnParameter, portOnParameter);\n+\n+         if (connection == null) {\n+            retryConnection();\n+            return;\n+         }\n+\n+         reconnectFuture = null;\n+         retryCounter = 0;\n+\n+         // before we retry the connection we need to remove any previous links\n+         // as they will need to be recreated\n+         senders.clear();\n+         receivers.clear();\n+\n+         ClientSASLFactory saslFactory = null;\n+\n+         if (brokerConnectConfiguration.getUser() != null && brokerConnectConfiguration.getPassword() != null) {\n+            saslFactory = availableMechanims -> {\n+               if (availableMechanims != null && Arrays.asList(availableMechanims).contains(\"PLAIN\")) {\n+                  return new PlainSASLMechanism(brokerConnectConfiguration.getUser(), brokerConnectConfiguration.getPassword());\n+               } else {\n+                  return null;\n+               }\n+            };\n+         }\n+\n+         ConnectionEntry entry = protonProtocolManager.createOutgoingConnectionEntry(connection, saslFactory);\n+         protonRemotingConnection = (ActiveMQProtonRemotingConnection) entry.connection;\n+         connection.getChannel().pipeline().addLast(new AMQPBrokerConnectionChannelHandler(bridgesConnector.getChannelGroup(), protonRemotingConnection.getAmqpConnection().getHandler()));\n+\n+         protonRemotingConnection.getAmqpConnection().runLater(() -> {\n+            protonRemotingConnection.getAmqpConnection().open();\n+            protonRemotingConnection.getAmqpConnection().flush();\n+         });\n+\n+         session = protonRemotingConnection.getAmqpConnection().getHandler().getConnection().session();\n+         sessionContext = protonRemotingConnection.getAmqpConnection().getSessionExtension(session);\n+         protonRemotingConnection.getAmqpConnection().runLater(() -> {\n+            session.open();\n+            protonRemotingConnection.getAmqpConnection().flush();\n+         });\n+\n+         if (brokerConnectConfiguration.getConnectionElements() != null) {\n+            Stream<Binding> bindingStream = server.getPostOffice().getAllBindings();\n+\n+            bindingStream.forEach(binding -> {\n+               if (binding instanceof QueueBinding) {\n+                  Queue queue = ((QueueBinding) binding).getQueue();\n+                  for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+                     validateMatching(queue, connectionElement);\n+                  }\n+               }\n+            });\n+\n+            for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+               if (connectionElement.getType() == AMQPBrokerConnectionAddressType.MIRROR) {\n+                  AMQPMirrorBrokerConnectionElement replica = (AMQPMirrorBrokerConnectionElement)connectionElement;\n+                  Queue queue = server.locateQueue(replica.getSourceMirrorAddress());\n+\n+                  connectSender(queue, ProtonProtocolManager.MIRROR_ADDRESS);\n+               }\n+            }\n+         }\n+\n+         protonRemotingConnection.getAmqpConnection().flush();", "originalCommit": "fb0056948d967928e2a79b1b191e5e2b5ab8d588", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5MTMzNQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513491335", "bodyText": "If you stop a connection with mirror config that doesnt specify a source mirror address, what happens to the generated mirror queue and its contents?", "author": "gemmellr", "createdAt": "2020-10-28T14:31:27Z", "path": "artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/connect/AMQPBrokerConnection.java", "diffHunk": "@@ -0,0 +1,556 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.activemq.artemis.protocol.amqp.connect;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Stream;\n+\n+import org.apache.activemq.artemis.api.core.ActiveMQException;\n+import org.apache.activemq.artemis.api.core.QueueConfiguration;\n+import org.apache.activemq.artemis.api.core.RoutingType;\n+import org.apache.activemq.artemis.api.core.SimpleString;\n+import org.apache.activemq.artemis.api.core.TransportConfiguration;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectConfiguration;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectionAddressType;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectionElement;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPMirrorBrokerConnectionElement;\n+import org.apache.activemq.artemis.core.postoffice.Binding;\n+import org.apache.activemq.artemis.core.postoffice.QueueBinding;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.NettyConnection;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.NettyConnector;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.TransportConstants;\n+import org.apache.activemq.artemis.core.server.ActiveMQComponent;\n+import org.apache.activemq.artemis.core.server.ActiveMQServer;\n+import org.apache.activemq.artemis.core.server.BrokerConnection;\n+import org.apache.activemq.artemis.core.server.Consumer;\n+import org.apache.activemq.artemis.core.server.Queue;\n+import org.apache.activemq.artemis.core.server.impl.AddressInfo;\n+import org.apache.activemq.artemis.core.server.mirror.MirrorController;\n+import org.apache.activemq.artemis.core.server.plugin.ActiveMQServerQueuePlugin;\n+import org.apache.activemq.artemis.protocol.amqp.broker.AMQPSessionCallback;\n+import org.apache.activemq.artemis.protocol.amqp.broker.ActiveMQProtonRemotingConnection;\n+import org.apache.activemq.artemis.protocol.amqp.broker.ProtonProtocolManager;\n+import org.apache.activemq.artemis.protocol.amqp.connect.mirror.AMQPMirrorControllerAggregation;\n+import org.apache.activemq.artemis.protocol.amqp.connect.mirror.AMQPMirrorControllerSource;\n+import org.apache.activemq.artemis.protocol.amqp.logger.ActiveMQAMQPProtocolLogger;\n+import org.apache.activemq.artemis.protocol.amqp.proton.AMQPSessionContext;\n+import org.apache.activemq.artemis.protocol.amqp.proton.ProtonServerSenderContext;\n+import org.apache.activemq.artemis.protocol.amqp.proton.SenderController;\n+import org.apache.activemq.artemis.protocol.amqp.sasl.ClientSASL;\n+import org.apache.activemq.artemis.protocol.amqp.sasl.ClientSASLFactory;\n+import org.apache.activemq.artemis.spi.core.protocol.ConnectionEntry;\n+import org.apache.activemq.artemis.spi.core.remoting.ClientConnectionLifeCycleListener;\n+import org.apache.activemq.artemis.spi.core.remoting.ClientProtocolManager;\n+import org.apache.activemq.artemis.spi.core.remoting.Connection;\n+import org.apache.activemq.artemis.utils.ConfigurationHelper;\n+import org.apache.activemq.artemis.utils.UUIDGenerator;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.Source;\n+import org.apache.qpid.proton.amqp.messaging.Target;\n+import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;\n+import org.apache.qpid.proton.amqp.transport.SenderSettleMode;\n+import org.apache.qpid.proton.engine.Receiver;\n+import org.apache.qpid.proton.engine.Sender;\n+import org.apache.qpid.proton.engine.Session;\n+import org.jboss.logging.Logger;\n+\n+public class AMQPBrokerConnection implements ClientConnectionLifeCycleListener, ActiveMQServerQueuePlugin, BrokerConnection {\n+\n+   private static final Logger logger = Logger.getLogger(AMQPBrokerConnection.class);\n+\n+   private final AMQPBrokerConnectConfiguration brokerConnectConfiguration;\n+   private final ProtonProtocolManager protonProtocolManager;\n+   private final ActiveMQServer server;\n+   private final NettyConnector bridgesConnector;\n+   private NettyConnection connection;\n+   private Session session;\n+   private AMQPSessionContext sessionContext;\n+   private ActiveMQProtonRemotingConnection protonRemotingConnection;\n+   private volatile boolean started = false;\n+   private final AMQPBrokerConnectionManager bridgeManager;\n+   private int retryCounter = 0;\n+   private volatile ScheduledFuture reconnectFuture;\n+   private Set<Queue> senders = new HashSet<>();\n+   private Set<Queue> receivers = new HashSet<>();\n+\n+   final Executor connectExecutor;\n+   final ScheduledExecutorService scheduledExecutorService;\n+\n+   /** This is just for logging.\n+    *  the actual connection will come from the amqpConnection configuration*/\n+   String host;\n+\n+   /** This is just for logging.\n+    *  the actual connection will come from the amqpConnection configuration*/\n+   int port;\n+\n+   public AMQPBrokerConnection(AMQPBrokerConnectionManager bridgeManager, AMQPBrokerConnectConfiguration brokerConnectConfiguration,\n+                               ProtonProtocolManager protonProtocolManager,\n+                               ActiveMQServer server,\n+                               NettyConnector bridgesConnector) {\n+      this.bridgeManager = bridgeManager;\n+      this.brokerConnectConfiguration = brokerConnectConfiguration;\n+      this.protonProtocolManager = protonProtocolManager;\n+      this.server = server;\n+      this.bridgesConnector = bridgesConnector;\n+      connectExecutor = server.getExecutorFactory().getExecutor();\n+      scheduledExecutorService = server.getScheduledPool();\n+   }\n+\n+   @Override\n+   public String getName() {\n+      return brokerConnectConfiguration.getName();\n+   }\n+\n+   @Override\n+   public String getProtocol() {\n+      return \"AMQP\";\n+   }\n+\n+   @Override\n+   public boolean isStarted() {\n+      return started;\n+   }\n+\n+   @Override\n+   public void stop() {\n+      if (connection != null) {\n+         connection.close();\n+      }", "originalCommit": "fb0056948d967928e2a79b1b191e5e2b5ab8d588", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwODQxNw==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513608417", "bodyText": "They would stay in, unless someone removed the queue.\nThe mirror will also stay in generating values.. just the connection would be stopped.", "author": "clebertsuconic", "createdAt": "2020-10-28T16:56:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5MTMzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1ODgzNA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513658834", "bodyText": "I will document this. We can change behavior in a future release. and I will create a JIRA for this.", "author": "clebertsuconic", "createdAt": "2020-10-28T18:07:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5MTMzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2MDQxMQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513660411", "bodyText": "https://issues.apache.org/jira/browse/ARTEMIS-2965", "author": "clebertsuconic", "createdAt": "2020-10-28T18:10:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5MTMzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE5MzQwMQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r514193401", "bodyText": "Ok, so it still exists, and it accumulates ongoing activity...then you can restart it and theyll be mirrored? That seems fine.\nIn which case maybe the JIRA would jsut be be more 'allow deleting connections (and related mirror queues?)'", "author": "gemmellr", "createdAt": "2020-10-29T11:39:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5MTMzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDIwNTYyOQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r514205629", "bodyText": "that's correct", "author": "clebertsuconic", "createdAt": "2020-10-29T12:02:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ5MTMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwMzYwOA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513503608", "bodyText": "Starts with Capital while all the others are camelCase", "author": "gemmellr", "createdAt": "2020-10-28T14:46:11Z", "path": "artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/connect/mirror/AMQPMirrorControllerSource.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq.artemis.protocol.amqp.connect.mirror;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.activemq.artemis.api.core.Message;\n+import org.apache.activemq.artemis.api.core.QueueConfiguration;\n+import org.apache.activemq.artemis.api.core.SimpleString;\n+import org.apache.activemq.artemis.core.paging.PagingStore;\n+import org.apache.activemq.artemis.core.server.ActiveMQComponent;\n+import org.apache.activemq.artemis.core.server.ActiveMQServer;\n+import org.apache.activemq.artemis.core.server.MessageReference;\n+import org.apache.activemq.artemis.core.server.Queue;\n+import org.apache.activemq.artemis.core.server.RoutingContext;\n+import org.apache.activemq.artemis.core.server.impl.AckReason;\n+import org.apache.activemq.artemis.core.server.impl.AddressInfo;\n+import org.apache.activemq.artemis.core.server.impl.RoutingContextImpl;\n+import org.apache.activemq.artemis.core.server.mirror.MirrorController;\n+import org.apache.activemq.artemis.core.transaction.Transaction;\n+import org.apache.activemq.artemis.protocol.amqp.broker.AMQPMessage;\n+import org.apache.activemq.artemis.protocol.amqp.broker.AMQPMessageBrokerAccessor;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.DeliveryAnnotations;\n+import org.apache.qpid.proton.amqp.messaging.Properties;\n+import org.jboss.logging.Logger;\n+\n+public class AMQPMirrorControllerSource implements MirrorController, ActiveMQComponent {\n+\n+   private static final Logger logger = Logger.getLogger(AMQPMirrorControllerSource.class);\n+\n+   public static final Symbol EVENT_TYPE = Symbol.getSymbol(\"x-opt-amq-mr-ev-type\");\n+   public static final Symbol ADDRESS = Symbol.getSymbol(\"x-opt-amq-mr-adr\");\n+   public static final Symbol QUEUE = Symbol.getSymbol(\"x-opt-amq-mr-qu\");\n+\n+   // Events:\n+   public static final Symbol ADD_ADDRESS = Symbol.getSymbol(\"addAddress\");\n+   public static final Symbol DELETE_ADDRESS = Symbol.getSymbol(\"deleteAddress\");\n+   public static final Symbol CREATE_QUEUE = Symbol.getSymbol(\"createQueue\");\n+   public static final Symbol DELETE_QUEUE = Symbol.getSymbol(\"deleteQueue\");\n+   public static final Symbol ADDRESS_SCAN_START = Symbol.getSymbol(\"AddressCanStart\");\n+   public static final Symbol ADDRESS_SCAN_END = Symbol.getSymbol(\"AddressScanEnd\");", "originalCommit": "7691c0a04ab3f955c1feac1e0578da88575551df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwNTg4Ng==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513505886", "bodyText": "\"daMap\" might be more descriptive, help readability", "author": "gemmellr", "createdAt": "2020-10-28T14:48:47Z", "path": "artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/connect/mirror/AMQPMirrorControllerSource.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq.artemis.protocol.amqp.connect.mirror;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.activemq.artemis.api.core.Message;\n+import org.apache.activemq.artemis.api.core.QueueConfiguration;\n+import org.apache.activemq.artemis.api.core.SimpleString;\n+import org.apache.activemq.artemis.core.paging.PagingStore;\n+import org.apache.activemq.artemis.core.server.ActiveMQComponent;\n+import org.apache.activemq.artemis.core.server.ActiveMQServer;\n+import org.apache.activemq.artemis.core.server.MessageReference;\n+import org.apache.activemq.artemis.core.server.Queue;\n+import org.apache.activemq.artemis.core.server.RoutingContext;\n+import org.apache.activemq.artemis.core.server.impl.AckReason;\n+import org.apache.activemq.artemis.core.server.impl.AddressInfo;\n+import org.apache.activemq.artemis.core.server.impl.RoutingContextImpl;\n+import org.apache.activemq.artemis.core.server.mirror.MirrorController;\n+import org.apache.activemq.artemis.core.transaction.Transaction;\n+import org.apache.activemq.artemis.protocol.amqp.broker.AMQPMessage;\n+import org.apache.activemq.artemis.protocol.amqp.broker.AMQPMessageBrokerAccessor;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.DeliveryAnnotations;\n+import org.apache.qpid.proton.amqp.messaging.Properties;\n+import org.jboss.logging.Logger;\n+\n+public class AMQPMirrorControllerSource implements MirrorController, ActiveMQComponent {\n+\n+   private static final Logger logger = Logger.getLogger(AMQPMirrorControllerSource.class);\n+\n+   public static final Symbol EVENT_TYPE = Symbol.getSymbol(\"x-opt-amq-mr-ev-type\");\n+   public static final Symbol ADDRESS = Symbol.getSymbol(\"x-opt-amq-mr-adr\");\n+   public static final Symbol QUEUE = Symbol.getSymbol(\"x-opt-amq-mr-qu\");\n+\n+   // Events:\n+   public static final Symbol ADD_ADDRESS = Symbol.getSymbol(\"addAddress\");\n+   public static final Symbol DELETE_ADDRESS = Symbol.getSymbol(\"deleteAddress\");\n+   public static final Symbol CREATE_QUEUE = Symbol.getSymbol(\"createQueue\");\n+   public static final Symbol DELETE_QUEUE = Symbol.getSymbol(\"deleteQueue\");\n+   public static final Symbol ADDRESS_SCAN_START = Symbol.getSymbol(\"AddressCanStart\");\n+   public static final Symbol ADDRESS_SCAN_END = Symbol.getSymbol(\"AddressScanEnd\");\n+   public static final Symbol POST_ACK = Symbol.getSymbol(\"postAck\");\n+\n+   // Delivery annotation property used on mirror control routing and Ack\n+   public static final Symbol INTERNAL_ID = Symbol.getSymbol(\"x-opt-amq-mr-id\");\n+   public static final Symbol INTERNAL_DESTINATION = Symbol.getSymbol(\"x-opt-amq-mr-dst\");\n+\n+   private static final ThreadLocal<MirrorControlRouting> mirrorControlRouting = ThreadLocal.withInitial(() -> new MirrorControlRouting(null));\n+\n+   final Queue snfQueue;\n+   final ActiveMQServer server;\n+   final boolean acks;\n+\n+   boolean started;\n+\n+   @Override\n+   public void start() throws Exception {\n+   }\n+\n+   @Override\n+   public void stop() throws Exception {\n+   }\n+\n+   @Override\n+   public boolean isStarted() {\n+      return started;\n+   }\n+\n+   public AMQPMirrorControllerSource(Queue snfQueue, ActiveMQServer server, boolean acks) {\n+      this.snfQueue = snfQueue;\n+      this.server = server;\n+      this.acks = acks;\n+   }\n+\n+   @Override\n+   public void startAddressScan() throws Exception {\n+      Message message = createMessage(null, null, ADDRESS_SCAN_START, null);\n+      route(server, message);\n+   }\n+\n+   @Override\n+   public void endAddressScan() throws Exception {\n+      Message message = createMessage(null, null, ADDRESS_SCAN_END, null);\n+      route(server, message);\n+   }\n+\n+   @Override\n+   public void addAddress(AddressInfo addressInfo) throws Exception {\n+      Message message = createMessage(addressInfo.getName(), null, ADD_ADDRESS, addressInfo.toJSON());\n+      route(server, message);\n+   }\n+\n+   @Override\n+   public void deleteAddress(AddressInfo addressInfo) throws Exception {\n+      Message message = createMessage(addressInfo.getName(), null, DELETE_ADDRESS, addressInfo.toJSON());\n+      route(server, message);\n+   }\n+\n+   @Override\n+   public void createQueue(QueueConfiguration queueConfiguration) throws Exception {\n+      Message message = createMessage(queueConfiguration.getAddress(), queueConfiguration.getName(), CREATE_QUEUE, queueConfiguration.toJSON());\n+      route(server, message);\n+   }\n+\n+   @Override\n+   public void deleteQueue(SimpleString address, SimpleString queue) throws Exception {\n+      Message message = createMessage(address, queue, DELETE_QUEUE, queue.toString());\n+      route(server, message);\n+   }\n+\n+   @Override\n+   public void sendMessage(Message message, RoutingContext context, List<MessageReference> refs) {\n+\n+      try {\n+         context.setReusable(false);\n+         PagingStore storeOwner = null;\n+         if (refs.size() > 0) {\n+            storeOwner = refs.get(0).getOwner();\n+         }\n+         if (storeOwner != null && !storeOwner.getAddress().equals(message.getAddressSimpleString())) {\n+            storeOwner = server.getPagingManager().getPageStore(message.getAddressSimpleString());\n+         }\n+         MessageReference ref = MessageReference.Factory.createReference(message, snfQueue, storeOwner);\n+\n+         snfQueue.refUp(ref);\n+\n+         Map<Symbol, Object> symbolObjectMap = new HashMap<>();", "originalCommit": "7691c0a04ab3f955c1feac1e0578da88575551df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyMTY1MA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513521650", "bodyText": "The arg modified is called \"isServer\", and this says it may now change depending on whether saslClientFactory is null - yet the new bridge code allows it to be both null or not, depending on whether a user/pass is given. This seems strange.", "author": "gemmellr", "createdAt": "2020-10-28T15:07:19Z", "path": "artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/proton/AMQPConnectionContext.java", "diffHunk": "@@ -129,7 +156,7 @@ public AMQPConnectionContext(ProtonProtocolManager protocolManager,\n       } else {\n          nettyExecutor = new ExecutorNettyAdapter(protocolManager.getServer().getExecutorFactory().getExecutor());\n       }\n-      this.handler = new ProtonHandler(nettyExecutor, protocolManager.getServer().getExecutorFactory().getExecutor(), isIncomingConnection);\n+      this.handler = new ProtonHandler(nettyExecutor, protocolManager.getServer().getExecutorFactory().getExecutor(), isIncomingConnection && saslClientFactory == null);", "originalCommit": "7691c0a04ab3f955c1feac1e0578da88575551df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY1ODAyNg==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513658026", "bodyText": "this is not actually part of my change. This was this way before since \"ARTEMIS-1454: Support SASL in outgoing AMQP\" on commit cc8a0cb", "author": "clebertsuconic", "createdAt": "2020-10-28T18:06:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyMTY1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE0OTE1Mg==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r514149152", "bodyText": "The bit im talking about is part of your change, its the diff being commented on. The change makes the value passed for ''isServer' also dependent on whether or not saslClientFactory is null or not. The usage of these bits it in the overall changes mean it can be both null and non-null values, for outgoing 'client' connections. I dont see why the value passed for 'isServer' would change depending on this.", "author": "gemmellr", "createdAt": "2020-10-29T10:19:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyMTY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUzMjEzOQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513532139", "bodyText": "Why the asymmetry that you can 'match' on addresses, but only specify exact queues? Why arent they both for addresses, or both for queues?\nIts also unclear from the doc here - is the sender created then sending from the queue(s) matched by the address 'match', or is it sending from the address matched to the config? (Distinction being important if address and queue names differ, like in the examples shown later)", "author": "gemmellr", "createdAt": "2020-10-28T15:20:25Z", "path": "docs/user-manual/en/amqp-broker-connections.md", "diffHunk": "@@ -0,0 +1,238 @@\n+# Broker Connections\n+\n+Instead of waiting for clients to connect, a broker can initiate a connection to another endpoint on a specific protocol.\n+\n+Currently, this feature supports only the AMQP protocol. However, in the future, it might be expanded to other protocols.\n+\n+You configure broker connections using a `<broker-connections>` XML element in the `broker.xml` configuration file.\n+\n+```xml\n+<broker-connections>\n+    ...\n+</broker-connections>\n+```\n+\n+# AMQP Server Connections\n+\n+An ActiveMQ Artemis broker can initiate connections using the AMQP protocol. This means that the broker can connect to another AMQP server (not necessarily ActiveMQ Artemis) and create elements on that connection.\n+\n+To define an AMQP broker connection, add an `<amqp-connection>` element within the `<broker-connections` element in the `broker.xml` configuration file. For example:\n+\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\" retry-interval=\"100\" reconnect-attempts=\"-1\" user=\"john\" password=\"doe\">\n+         ...\n+    </amqp-connection>\n+</broker-connections>\n+```\n+\n+- `uri`: tcp://host:myport (this is a required argument)\n+- `name`: Name of the connection used for management purposes\n+- `user`: User name with which to connect to the endpoint (this is an optional argument)\n+- `password`: Password with which to connect to the endpoint (this is an optional argument)\n+- `retry-interval`: Time, in milliseconds to wait before retrying a connection after an error. The default value is `5000`.\n+- `reconnect-attempts`: default is -1 meaning infinite\n+- `auto-start` : Should the broker connection start automatically with the broker. Default is `true`. If false you need to call a management operation to start it.\n+\n+*Notice*: If you disable auto-start on the broker connection, the start of the broker connection will only happen after the management method `startBrokerConnection(connectionName)` is called on the ServerController.\n+\n+*Important*: The target endpoint needs permission for all operations that you configure. Therefore, If you are using a security manager, ensure that you perform the configured operations as a user with sufficient permissions.\n+\n+# AMQP Server Connection Operations\n+The following types of operations are supported on a AMQP server connection:\n+\n+* Senders\n+    * Messages received on specific queues are transferred to another endpoint\n+* Receivers\n+    * The broker pulls messages from another endpoint\n+* Peers\n+    * The broker creates both senders and receivers on another endpoint that knows how to handle them. Currently, this is implemented by Apache Qpid Dispatch.\n+* Mirrors\n+    * The broker uses an AMQP connection to another broker and duplicate messages and sends acknowledgements over the wire.\n+\n+## Senders and Receivers\n+It is possible to connect an ActiveMQ Artemis broker to another AMQP endpoint simply by creating a sender or receiver broker connection element.\n+\n+For a `sender`, the broker creates a message consumer on a queue that sends messages to another AMQP endpoint.\n+\n+For a `receiver`, the broker creates a message producer on an address that receives messages from another AMQP endpoint.\n+\n+Both elements work like a message bridge. However, there is no additional overhead required to process messages. Senders and receivers behave just like any other consumer or producer in ActiveMQ Artemis.\n+\n+You can configure senders or receivers for specific queues. You can also match senders and receivers to specific addresses or _sets_ of addresses, using wildcard expressions. When configuring a sender or receiver, you can set the following properties:", "originalCommit": "10de26f79f309f699f53012dacb1fe9fdc2b22c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYwOTM1NQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513609355", "bodyText": "the broker currently does not define matching for queues.. just for addresses. I\"m keeping it consistent with everything else.", "author": "clebertsuconic", "createdAt": "2020-10-28T16:57:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUzMjEzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE1OTAxNg==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r514159016", "bodyText": "Ok. I think its rather inconsistent with itself though. Why not 'match' and 'address' for example rather than 'match' and 'queue'?\nContinuing the second bit of my earlier comment, I actually think this has confused me on what these features as a whole even actually do exactly. I've been reviewing it for a week and I'm still unclear on the expected behaviours, even after its now been merged. Which is why I keep banging on about the examples and docs clearly outlining what the expected behaviour is.  I'm actually starting to think some of it may be doing the wrong thing. But im still not sure.", "author": "gemmellr", "createdAt": "2020-10-29T10:36:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUzMjEzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUzNjQxOA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513536418", "bodyText": "Differing indentation levels. See also comment about clarifying what actually ends up happening, the important note below still doesnt really cover it. Maybe some diagrams / ascii art might.\nA simplified example using the same queue and address names might be a better start.", "author": "gemmellr", "createdAt": "2020-10-28T15:25:44Z", "path": "docs/user-manual/en/amqp-broker-connections.md", "diffHunk": "@@ -0,0 +1,238 @@\n+# Broker Connections\n+\n+Instead of waiting for clients to connect, a broker can initiate a connection to another endpoint on a specific protocol.\n+\n+Currently, this feature supports only the AMQP protocol. However, in the future, it might be expanded to other protocols.\n+\n+You configure broker connections using a `<broker-connections>` XML element in the `broker.xml` configuration file.\n+\n+```xml\n+<broker-connections>\n+    ...\n+</broker-connections>\n+```\n+\n+# AMQP Server Connections\n+\n+An ActiveMQ Artemis broker can initiate connections using the AMQP protocol. This means that the broker can connect to another AMQP server (not necessarily ActiveMQ Artemis) and create elements on that connection.\n+\n+To define an AMQP broker connection, add an `<amqp-connection>` element within the `<broker-connections` element in the `broker.xml` configuration file. For example:\n+\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\" retry-interval=\"100\" reconnect-attempts=\"-1\" user=\"john\" password=\"doe\">\n+         ...\n+    </amqp-connection>\n+</broker-connections>\n+```\n+\n+- `uri`: tcp://host:myport (this is a required argument)\n+- `name`: Name of the connection used for management purposes\n+- `user`: User name with which to connect to the endpoint (this is an optional argument)\n+- `password`: Password with which to connect to the endpoint (this is an optional argument)\n+- `retry-interval`: Time, in milliseconds to wait before retrying a connection after an error. The default value is `5000`.\n+- `reconnect-attempts`: default is -1 meaning infinite\n+- `auto-start` : Should the broker connection start automatically with the broker. Default is `true`. If false you need to call a management operation to start it.\n+\n+*Notice*: If you disable auto-start on the broker connection, the start of the broker connection will only happen after the management method `startBrokerConnection(connectionName)` is called on the ServerController.\n+\n+*Important*: The target endpoint needs permission for all operations that you configure. Therefore, If you are using a security manager, ensure that you perform the configured operations as a user with sufficient permissions.\n+\n+# AMQP Server Connection Operations\n+The following types of operations are supported on a AMQP server connection:\n+\n+* Senders\n+    * Messages received on specific queues are transferred to another endpoint\n+* Receivers\n+    * The broker pulls messages from another endpoint\n+* Peers\n+    * The broker creates both senders and receivers on another endpoint that knows how to handle them. Currently, this is implemented by Apache Qpid Dispatch.\n+* Mirrors\n+    * The broker uses an AMQP connection to another broker and duplicate messages and sends acknowledgements over the wire.\n+\n+## Senders and Receivers\n+It is possible to connect an ActiveMQ Artemis broker to another AMQP endpoint simply by creating a sender or receiver broker connection element.\n+\n+For a `sender`, the broker creates a message consumer on a queue that sends messages to another AMQP endpoint.\n+\n+For a `receiver`, the broker creates a message producer on an address that receives messages from another AMQP endpoint.\n+\n+Both elements work like a message bridge. However, there is no additional overhead required to process messages. Senders and receivers behave just like any other consumer or producer in ActiveMQ Artemis.\n+\n+You can configure senders or receivers for specific queues. You can also match senders and receivers to specific addresses or _sets_ of addresses, using wildcard expressions. When configuring a sender or receiver, you can set the following properties:\n+\n+- `match`: Match the sender or receiver to a specific address or __set__ of addresses, using a wildcard expression\n+- `queue-name`: Configure the sender or receiver for a specific queue\n+\n+\n+Some examples are shown below.\n+\n+Using address expressions:\n+```xml\n+<broker-connections>\n+        <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\">\n+                <sender match=\"queues.#\"/>\n+                <!-- notice the local queues for remotequeues.# need to be created on this broker -->\n+                <receiver match=\"remotequeues.#\"/>\n+        </amqp-connection>\n+</broker-connections>\n+\n+<addresses>\n+        <address name=\"remotequeues.A\">\n+                <anycast>\n+                        <queue name=\"remoteQueueA\"/>\n+                </anycast>\n+        </address>\n+        <address name=\"queues.B\">\n+                 <anycast>\n+                        <queue name=\"localQueueB\"/>\n+                </anycast>\n+        </address>\n+</addresses>\n+```\n+\n+Using queue names:\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\">\n+        <receiver queue-name=\"remoteQueueA\"/>\n+        <sender queue-name=\"localQueueB\"/>\n+    </amqp-connection>\n+</broker-connections>\n+\n+<addresses>\n+     <address name=\"remotequeues.A\">\n+        <anycast>\n+           <queue name=\"remoteQueueA\"/>\n+        </anycast>\n+     </address>\n+     <address name=\"queues.B\">\n+        <anycast>\n+           <queue name=\"localQueueB\"/>\n+        </anycast>\n+     </address>\n+</addresses>", "originalCommit": "10de26f79f309f699f53012dacb1fe9fdc2b22c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxNTI2Mg==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513615262", "bodyText": "this can be a follow up change on the docs.", "author": "clebertsuconic", "createdAt": "2020-10-28T17:05:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUzNjQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU0NTQ2Nw==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513545467", "bodyText": "Not unless you tell the router to, which this section doesnt currently clarify in any way. Its not clear from this what the feature even does. I dont think anyone reading this without fairly deep implementation knoweldge would be able to make this feature work using the information currently here.\nThis section should mention that it configures the broker to connect to the router and make itself available for storing messsages on a waypoint address, such that the messages sent to the router on the address are message-rotued to/from the broker. There needs to be an example of the address configuration required for Dispatch to treat addresse as a waypoint.", "author": "gemmellr", "createdAt": "2020-10-28T15:36:56Z", "path": "docs/user-manual/en/amqp-broker-connections.md", "diffHunk": "@@ -0,0 +1,238 @@\n+# Broker Connections\n+\n+Instead of waiting for clients to connect, a broker can initiate a connection to another endpoint on a specific protocol.\n+\n+Currently, this feature supports only the AMQP protocol. However, in the future, it might be expanded to other protocols.\n+\n+You configure broker connections using a `<broker-connections>` XML element in the `broker.xml` configuration file.\n+\n+```xml\n+<broker-connections>\n+    ...\n+</broker-connections>\n+```\n+\n+# AMQP Server Connections\n+\n+An ActiveMQ Artemis broker can initiate connections using the AMQP protocol. This means that the broker can connect to another AMQP server (not necessarily ActiveMQ Artemis) and create elements on that connection.\n+\n+To define an AMQP broker connection, add an `<amqp-connection>` element within the `<broker-connections` element in the `broker.xml` configuration file. For example:\n+\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\" retry-interval=\"100\" reconnect-attempts=\"-1\" user=\"john\" password=\"doe\">\n+         ...\n+    </amqp-connection>\n+</broker-connections>\n+```\n+\n+- `uri`: tcp://host:myport (this is a required argument)\n+- `name`: Name of the connection used for management purposes\n+- `user`: User name with which to connect to the endpoint (this is an optional argument)\n+- `password`: Password with which to connect to the endpoint (this is an optional argument)\n+- `retry-interval`: Time, in milliseconds to wait before retrying a connection after an error. The default value is `5000`.\n+- `reconnect-attempts`: default is -1 meaning infinite\n+- `auto-start` : Should the broker connection start automatically with the broker. Default is `true`. If false you need to call a management operation to start it.\n+\n+*Notice*: If you disable auto-start on the broker connection, the start of the broker connection will only happen after the management method `startBrokerConnection(connectionName)` is called on the ServerController.\n+\n+*Important*: The target endpoint needs permission for all operations that you configure. Therefore, If you are using a security manager, ensure that you perform the configured operations as a user with sufficient permissions.\n+\n+# AMQP Server Connection Operations\n+The following types of operations are supported on a AMQP server connection:\n+\n+* Senders\n+    * Messages received on specific queues are transferred to another endpoint\n+* Receivers\n+    * The broker pulls messages from another endpoint\n+* Peers\n+    * The broker creates both senders and receivers on another endpoint that knows how to handle them. Currently, this is implemented by Apache Qpid Dispatch.\n+* Mirrors\n+    * The broker uses an AMQP connection to another broker and duplicate messages and sends acknowledgements over the wire.\n+\n+## Senders and Receivers\n+It is possible to connect an ActiveMQ Artemis broker to another AMQP endpoint simply by creating a sender or receiver broker connection element.\n+\n+For a `sender`, the broker creates a message consumer on a queue that sends messages to another AMQP endpoint.\n+\n+For a `receiver`, the broker creates a message producer on an address that receives messages from another AMQP endpoint.\n+\n+Both elements work like a message bridge. However, there is no additional overhead required to process messages. Senders and receivers behave just like any other consumer or producer in ActiveMQ Artemis.\n+\n+You can configure senders or receivers for specific queues. You can also match senders and receivers to specific addresses or _sets_ of addresses, using wildcard expressions. When configuring a sender or receiver, you can set the following properties:\n+\n+- `match`: Match the sender or receiver to a specific address or __set__ of addresses, using a wildcard expression\n+- `queue-name`: Configure the sender or receiver for a specific queue\n+\n+\n+Some examples are shown below.\n+\n+Using address expressions:\n+```xml\n+<broker-connections>\n+        <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\">\n+                <sender match=\"queues.#\"/>\n+                <!-- notice the local queues for remotequeues.# need to be created on this broker -->\n+                <receiver match=\"remotequeues.#\"/>\n+        </amqp-connection>\n+</broker-connections>\n+\n+<addresses>\n+        <address name=\"remotequeues.A\">\n+                <anycast>\n+                        <queue name=\"remoteQueueA\"/>\n+                </anycast>\n+        </address>\n+        <address name=\"queues.B\">\n+                 <anycast>\n+                        <queue name=\"localQueueB\"/>\n+                </anycast>\n+        </address>\n+</addresses>\n+```\n+\n+Using queue names:\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\">\n+        <receiver queue-name=\"remoteQueueA\"/>\n+        <sender queue-name=\"localQueueB\"/>\n+    </amqp-connection>\n+</broker-connections>\n+\n+<addresses>\n+     <address name=\"remotequeues.A\">\n+        <anycast>\n+           <queue name=\"remoteQueueA\"/>\n+        </anycast>\n+     </address>\n+     <address name=\"queues.B\">\n+        <anycast>\n+           <queue name=\"localQueueB\"/>\n+        </anycast>\n+     </address>\n+</addresses>\n+\n+```\n+*Important*: You can match a receiver only to a local queue that already exists. Therefore, if you are using receivers, make sure that you pre-create the queue locally. Otherwise, the broker cannot match the remote queues and addresses.\n+\n+*Important*: Do not create a sender and a receiver to the same destination. This creates an infinite loop of sends and receives.\n+\n+\n+# Peers\n+A peer broker connection element is a combination of sender and receivers. The ActiveMQ Artemis broker creates both a sender and a receiver for a peer element, and the endpoint knows how to deal with the pair without creating an infinite loop of sending and receiving messages.\n+\n+Currently, [Apache Qpid Dispatch Router](https://qpid.apache.org/components/dispatch-router/index.html) is a peer. ActiveMQ Artemis creates the pair of receivers and sender for each matching destination. These senders and receivers have special configuration to let Qpid Dispatch Router know to collaborate with ActiveMQ Artemis.", "originalCommit": "10de26f79f309f699f53012dacb1fe9fdc2b22c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY2NTM1NA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513665354", "bodyText": "There's no way I can document qpid-dispatch on this chapter here. users can refer to qpid dispatch doc for more information.\nIf you have a way to describe that... perhaps you could provide the text?", "author": "clebertsuconic", "createdAt": "2020-10-28T18:18:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU0NTQ2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDE2MDc1OA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r514160758", "bodyText": "I dont believe they can actually refer to the Dispatch docs for more information on this, I think only the router-initiatiated waypointing using router-based autolink configuration is documented there. Even if/once it was mentioned, it wouldnt be immediately obvious to people coming to Artemis and seeing this section of doc, what it is they need to make this Artemis functionality work. It needs to be discussed in the Artemis docs. Essentially the tiny paragraph I described is all it needs.", "author": "gemmellr", "createdAt": "2020-10-29T10:39:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU0NTQ2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU0NjE1Mw==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513546153", "bodyText": "Perhaps \"my-router\" would be a better name?", "author": "gemmellr", "createdAt": "2020-10-28T15:37:47Z", "path": "docs/user-manual/en/amqp-broker-connections.md", "diffHunk": "@@ -0,0 +1,238 @@\n+# Broker Connections\n+\n+Instead of waiting for clients to connect, a broker can initiate a connection to another endpoint on a specific protocol.\n+\n+Currently, this feature supports only the AMQP protocol. However, in the future, it might be expanded to other protocols.\n+\n+You configure broker connections using a `<broker-connections>` XML element in the `broker.xml` configuration file.\n+\n+```xml\n+<broker-connections>\n+    ...\n+</broker-connections>\n+```\n+\n+# AMQP Server Connections\n+\n+An ActiveMQ Artemis broker can initiate connections using the AMQP protocol. This means that the broker can connect to another AMQP server (not necessarily ActiveMQ Artemis) and create elements on that connection.\n+\n+To define an AMQP broker connection, add an `<amqp-connection>` element within the `<broker-connections` element in the `broker.xml` configuration file. For example:\n+\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\" retry-interval=\"100\" reconnect-attempts=\"-1\" user=\"john\" password=\"doe\">\n+         ...\n+    </amqp-connection>\n+</broker-connections>\n+```\n+\n+- `uri`: tcp://host:myport (this is a required argument)\n+- `name`: Name of the connection used for management purposes\n+- `user`: User name with which to connect to the endpoint (this is an optional argument)\n+- `password`: Password with which to connect to the endpoint (this is an optional argument)\n+- `retry-interval`: Time, in milliseconds to wait before retrying a connection after an error. The default value is `5000`.\n+- `reconnect-attempts`: default is -1 meaning infinite\n+- `auto-start` : Should the broker connection start automatically with the broker. Default is `true`. If false you need to call a management operation to start it.\n+\n+*Notice*: If you disable auto-start on the broker connection, the start of the broker connection will only happen after the management method `startBrokerConnection(connectionName)` is called on the ServerController.\n+\n+*Important*: The target endpoint needs permission for all operations that you configure. Therefore, If you are using a security manager, ensure that you perform the configured operations as a user with sufficient permissions.\n+\n+# AMQP Server Connection Operations\n+The following types of operations are supported on a AMQP server connection:\n+\n+* Senders\n+    * Messages received on specific queues are transferred to another endpoint\n+* Receivers\n+    * The broker pulls messages from another endpoint\n+* Peers\n+    * The broker creates both senders and receivers on another endpoint that knows how to handle them. Currently, this is implemented by Apache Qpid Dispatch.\n+* Mirrors\n+    * The broker uses an AMQP connection to another broker and duplicate messages and sends acknowledgements over the wire.\n+\n+## Senders and Receivers\n+It is possible to connect an ActiveMQ Artemis broker to another AMQP endpoint simply by creating a sender or receiver broker connection element.\n+\n+For a `sender`, the broker creates a message consumer on a queue that sends messages to another AMQP endpoint.\n+\n+For a `receiver`, the broker creates a message producer on an address that receives messages from another AMQP endpoint.\n+\n+Both elements work like a message bridge. However, there is no additional overhead required to process messages. Senders and receivers behave just like any other consumer or producer in ActiveMQ Artemis.\n+\n+You can configure senders or receivers for specific queues. You can also match senders and receivers to specific addresses or _sets_ of addresses, using wildcard expressions. When configuring a sender or receiver, you can set the following properties:\n+\n+- `match`: Match the sender or receiver to a specific address or __set__ of addresses, using a wildcard expression\n+- `queue-name`: Configure the sender or receiver for a specific queue\n+\n+\n+Some examples are shown below.\n+\n+Using address expressions:\n+```xml\n+<broker-connections>\n+        <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\">\n+                <sender match=\"queues.#\"/>\n+                <!-- notice the local queues for remotequeues.# need to be created on this broker -->\n+                <receiver match=\"remotequeues.#\"/>\n+        </amqp-connection>\n+</broker-connections>\n+\n+<addresses>\n+        <address name=\"remotequeues.A\">\n+                <anycast>\n+                        <queue name=\"remoteQueueA\"/>\n+                </anycast>\n+        </address>\n+        <address name=\"queues.B\">\n+                 <anycast>\n+                        <queue name=\"localQueueB\"/>\n+                </anycast>\n+        </address>\n+</addresses>\n+```\n+\n+Using queue names:\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\">\n+        <receiver queue-name=\"remoteQueueA\"/>\n+        <sender queue-name=\"localQueueB\"/>\n+    </amqp-connection>\n+</broker-connections>\n+\n+<addresses>\n+     <address name=\"remotequeues.A\">\n+        <anycast>\n+           <queue name=\"remoteQueueA\"/>\n+        </anycast>\n+     </address>\n+     <address name=\"queues.B\">\n+        <anycast>\n+           <queue name=\"localQueueB\"/>\n+        </anycast>\n+     </address>\n+</addresses>\n+\n+```\n+*Important*: You can match a receiver only to a local queue that already exists. Therefore, if you are using receivers, make sure that you pre-create the queue locally. Otherwise, the broker cannot match the remote queues and addresses.\n+\n+*Important*: Do not create a sender and a receiver to the same destination. This creates an infinite loop of sends and receives.\n+\n+\n+# Peers\n+A peer broker connection element is a combination of sender and receivers. The ActiveMQ Artemis broker creates both a sender and a receiver for a peer element, and the endpoint knows how to deal with the pair without creating an infinite loop of sending and receiving messages.\n+\n+Currently, [Apache Qpid Dispatch Router](https://qpid.apache.org/components/dispatch-router/index.html) is a peer. ActiveMQ Artemis creates the pair of receivers and sender for each matching destination. These senders and receivers have special configuration to let Qpid Dispatch Router know to collaborate with ActiveMQ Artemis.\n+\n+You can experiment with advanced networking scenarios with Qpid Dispatch Router and get a lot of benefit from the AMQP protocol and its ecosystem.\n+\n+With a peer, you have the same properties that you have on a sender and receiver. For example:\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\">", "originalCommit": "10de26f79f309f699f53012dacb1fe9fdc2b22c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU0OTcxNQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513549715", "bodyText": "I think a simpler example of matching queue+address names would be a better starting point for most people. Regardless, an example with differing names should outline what its actually expected its going to do. It isnt at all clear here whether the waypointed address used by clients connecting to the router is meant to be the broker address name or the broker queue name.", "author": "gemmellr", "createdAt": "2020-10-28T15:42:10Z", "path": "docs/user-manual/en/amqp-broker-connections.md", "diffHunk": "@@ -0,0 +1,238 @@\n+# Broker Connections\n+\n+Instead of waiting for clients to connect, a broker can initiate a connection to another endpoint on a specific protocol.\n+\n+Currently, this feature supports only the AMQP protocol. However, in the future, it might be expanded to other protocols.\n+\n+You configure broker connections using a `<broker-connections>` XML element in the `broker.xml` configuration file.\n+\n+```xml\n+<broker-connections>\n+    ...\n+</broker-connections>\n+```\n+\n+# AMQP Server Connections\n+\n+An ActiveMQ Artemis broker can initiate connections using the AMQP protocol. This means that the broker can connect to another AMQP server (not necessarily ActiveMQ Artemis) and create elements on that connection.\n+\n+To define an AMQP broker connection, add an `<amqp-connection>` element within the `<broker-connections` element in the `broker.xml` configuration file. For example:\n+\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\" retry-interval=\"100\" reconnect-attempts=\"-1\" user=\"john\" password=\"doe\">\n+         ...\n+    </amqp-connection>\n+</broker-connections>\n+```\n+\n+- `uri`: tcp://host:myport (this is a required argument)\n+- `name`: Name of the connection used for management purposes\n+- `user`: User name with which to connect to the endpoint (this is an optional argument)\n+- `password`: Password with which to connect to the endpoint (this is an optional argument)\n+- `retry-interval`: Time, in milliseconds to wait before retrying a connection after an error. The default value is `5000`.\n+- `reconnect-attempts`: default is -1 meaning infinite\n+- `auto-start` : Should the broker connection start automatically with the broker. Default is `true`. If false you need to call a management operation to start it.\n+\n+*Notice*: If you disable auto-start on the broker connection, the start of the broker connection will only happen after the management method `startBrokerConnection(connectionName)` is called on the ServerController.\n+\n+*Important*: The target endpoint needs permission for all operations that you configure. Therefore, If you are using a security manager, ensure that you perform the configured operations as a user with sufficient permissions.\n+\n+# AMQP Server Connection Operations\n+The following types of operations are supported on a AMQP server connection:\n+\n+* Senders\n+    * Messages received on specific queues are transferred to another endpoint\n+* Receivers\n+    * The broker pulls messages from another endpoint\n+* Peers\n+    * The broker creates both senders and receivers on another endpoint that knows how to handle them. Currently, this is implemented by Apache Qpid Dispatch.\n+* Mirrors\n+    * The broker uses an AMQP connection to another broker and duplicate messages and sends acknowledgements over the wire.\n+\n+## Senders and Receivers\n+It is possible to connect an ActiveMQ Artemis broker to another AMQP endpoint simply by creating a sender or receiver broker connection element.\n+\n+For a `sender`, the broker creates a message consumer on a queue that sends messages to another AMQP endpoint.\n+\n+For a `receiver`, the broker creates a message producer on an address that receives messages from another AMQP endpoint.\n+\n+Both elements work like a message bridge. However, there is no additional overhead required to process messages. Senders and receivers behave just like any other consumer or producer in ActiveMQ Artemis.\n+\n+You can configure senders or receivers for specific queues. You can also match senders and receivers to specific addresses or _sets_ of addresses, using wildcard expressions. When configuring a sender or receiver, you can set the following properties:\n+\n+- `match`: Match the sender or receiver to a specific address or __set__ of addresses, using a wildcard expression\n+- `queue-name`: Configure the sender or receiver for a specific queue\n+\n+\n+Some examples are shown below.\n+\n+Using address expressions:\n+```xml\n+<broker-connections>\n+        <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\">\n+                <sender match=\"queues.#\"/>\n+                <!-- notice the local queues for remotequeues.# need to be created on this broker -->\n+                <receiver match=\"remotequeues.#\"/>\n+        </amqp-connection>\n+</broker-connections>\n+\n+<addresses>\n+        <address name=\"remotequeues.A\">\n+                <anycast>\n+                        <queue name=\"remoteQueueA\"/>\n+                </anycast>\n+        </address>\n+        <address name=\"queues.B\">\n+                 <anycast>\n+                        <queue name=\"localQueueB\"/>\n+                </anycast>\n+        </address>\n+</addresses>\n+```\n+\n+Using queue names:\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\">\n+        <receiver queue-name=\"remoteQueueA\"/>\n+        <sender queue-name=\"localQueueB\"/>\n+    </amqp-connection>\n+</broker-connections>\n+\n+<addresses>\n+     <address name=\"remotequeues.A\">\n+        <anycast>\n+           <queue name=\"remoteQueueA\"/>\n+        </anycast>\n+     </address>\n+     <address name=\"queues.B\">\n+        <anycast>\n+           <queue name=\"localQueueB\"/>\n+        </anycast>\n+     </address>\n+</addresses>\n+\n+```\n+*Important*: You can match a receiver only to a local queue that already exists. Therefore, if you are using receivers, make sure that you pre-create the queue locally. Otherwise, the broker cannot match the remote queues and addresses.\n+\n+*Important*: Do not create a sender and a receiver to the same destination. This creates an infinite loop of sends and receives.\n+\n+\n+# Peers\n+A peer broker connection element is a combination of sender and receivers. The ActiveMQ Artemis broker creates both a sender and a receiver for a peer element, and the endpoint knows how to deal with the pair without creating an infinite loop of sending and receiving messages.\n+\n+Currently, [Apache Qpid Dispatch Router](https://qpid.apache.org/components/dispatch-router/index.html) is a peer. ActiveMQ Artemis creates the pair of receivers and sender for each matching destination. These senders and receivers have special configuration to let Qpid Dispatch Router know to collaborate with ActiveMQ Artemis.\n+\n+You can experiment with advanced networking scenarios with Qpid Dispatch Router and get a lot of benefit from the AMQP protocol and its ecosystem.\n+\n+With a peer, you have the same properties that you have on a sender and receiver. For example:\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\">\n+       <peer match=\"queues.#\"/>\n+    </amqp-connection>\n+</broker-connections>\n+\n+<addresses>\n+     <address name=\"queues.A\">\n+        <anycast>\n+           <queue name=\"localQueueA\"/>\n+        </anycast>\n+     </address>\n+     <address name=\"queues.B\">\n+     <anycast>\n+        <queue name=\"localQueueB\"/>\n+     </anycast>\n+    </address>\n+</addresses>", "originalCommit": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1MzExOQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513553119", "bodyText": "Think this could be clarified, im not sure what it means by 'natural catchup'. Is it saying, only events occuring and messages arriving on a server after the mirror is started, will be be mirrored? That is, existing messages on a queue, present before a mirror is configured, will not be mirrored?", "author": "gemmellr", "createdAt": "2020-10-28T15:46:25Z", "path": "docs/user-manual/en/amqp-broker-connections.md", "diffHunk": "@@ -0,0 +1,238 @@\n+# Broker Connections\n+\n+Instead of waiting for clients to connect, a broker can initiate a connection to another endpoint on a specific protocol.\n+\n+Currently, this feature supports only the AMQP protocol. However, in the future, it might be expanded to other protocols.\n+\n+You configure broker connections using a `<broker-connections>` XML element in the `broker.xml` configuration file.\n+\n+```xml\n+<broker-connections>\n+    ...\n+</broker-connections>\n+```\n+\n+# AMQP Server Connections\n+\n+An ActiveMQ Artemis broker can initiate connections using the AMQP protocol. This means that the broker can connect to another AMQP server (not necessarily ActiveMQ Artemis) and create elements on that connection.\n+\n+To define an AMQP broker connection, add an `<amqp-connection>` element within the `<broker-connections` element in the `broker.xml` configuration file. For example:\n+\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\" retry-interval=\"100\" reconnect-attempts=\"-1\" user=\"john\" password=\"doe\">\n+         ...\n+    </amqp-connection>\n+</broker-connections>\n+```\n+\n+- `uri`: tcp://host:myport (this is a required argument)\n+- `name`: Name of the connection used for management purposes\n+- `user`: User name with which to connect to the endpoint (this is an optional argument)\n+- `password`: Password with which to connect to the endpoint (this is an optional argument)\n+- `retry-interval`: Time, in milliseconds to wait before retrying a connection after an error. The default value is `5000`.\n+- `reconnect-attempts`: default is -1 meaning infinite\n+- `auto-start` : Should the broker connection start automatically with the broker. Default is `true`. If false you need to call a management operation to start it.\n+\n+*Notice*: If you disable auto-start on the broker connection, the start of the broker connection will only happen after the management method `startBrokerConnection(connectionName)` is called on the ServerController.\n+\n+*Important*: The target endpoint needs permission for all operations that you configure. Therefore, If you are using a security manager, ensure that you perform the configured operations as a user with sufficient permissions.\n+\n+# AMQP Server Connection Operations\n+The following types of operations are supported on a AMQP server connection:\n+\n+* Senders\n+    * Messages received on specific queues are transferred to another endpoint\n+* Receivers\n+    * The broker pulls messages from another endpoint\n+* Peers\n+    * The broker creates both senders and receivers on another endpoint that knows how to handle them. Currently, this is implemented by Apache Qpid Dispatch.\n+* Mirrors\n+    * The broker uses an AMQP connection to another broker and duplicate messages and sends acknowledgements over the wire.\n+\n+## Senders and Receivers\n+It is possible to connect an ActiveMQ Artemis broker to another AMQP endpoint simply by creating a sender or receiver broker connection element.\n+\n+For a `sender`, the broker creates a message consumer on a queue that sends messages to another AMQP endpoint.\n+\n+For a `receiver`, the broker creates a message producer on an address that receives messages from another AMQP endpoint.\n+\n+Both elements work like a message bridge. However, there is no additional overhead required to process messages. Senders and receivers behave just like any other consumer or producer in ActiveMQ Artemis.\n+\n+You can configure senders or receivers for specific queues. You can also match senders and receivers to specific addresses or _sets_ of addresses, using wildcard expressions. When configuring a sender or receiver, you can set the following properties:\n+\n+- `match`: Match the sender or receiver to a specific address or __set__ of addresses, using a wildcard expression\n+- `queue-name`: Configure the sender or receiver for a specific queue\n+\n+\n+Some examples are shown below.\n+\n+Using address expressions:\n+```xml\n+<broker-connections>\n+        <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\">\n+                <sender match=\"queues.#\"/>\n+                <!-- notice the local queues for remotequeues.# need to be created on this broker -->\n+                <receiver match=\"remotequeues.#\"/>\n+        </amqp-connection>\n+</broker-connections>\n+\n+<addresses>\n+        <address name=\"remotequeues.A\">\n+                <anycast>\n+                        <queue name=\"remoteQueueA\"/>\n+                </anycast>\n+        </address>\n+        <address name=\"queues.B\">\n+                 <anycast>\n+                        <queue name=\"localQueueB\"/>\n+                </anycast>\n+        </address>\n+</addresses>\n+```\n+\n+Using queue names:\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\">\n+        <receiver queue-name=\"remoteQueueA\"/>\n+        <sender queue-name=\"localQueueB\"/>\n+    </amqp-connection>\n+</broker-connections>\n+\n+<addresses>\n+     <address name=\"remotequeues.A\">\n+        <anycast>\n+           <queue name=\"remoteQueueA\"/>\n+        </anycast>\n+     </address>\n+     <address name=\"queues.B\">\n+        <anycast>\n+           <queue name=\"localQueueB\"/>\n+        </anycast>\n+     </address>\n+</addresses>\n+\n+```\n+*Important*: You can match a receiver only to a local queue that already exists. Therefore, if you are using receivers, make sure that you pre-create the queue locally. Otherwise, the broker cannot match the remote queues and addresses.\n+\n+*Important*: Do not create a sender and a receiver to the same destination. This creates an infinite loop of sends and receives.\n+\n+\n+# Peers\n+A peer broker connection element is a combination of sender and receivers. The ActiveMQ Artemis broker creates both a sender and a receiver for a peer element, and the endpoint knows how to deal with the pair without creating an infinite loop of sending and receiving messages.\n+\n+Currently, [Apache Qpid Dispatch Router](https://qpid.apache.org/components/dispatch-router/index.html) is a peer. ActiveMQ Artemis creates the pair of receivers and sender for each matching destination. These senders and receivers have special configuration to let Qpid Dispatch Router know to collaborate with ActiveMQ Artemis.\n+\n+You can experiment with advanced networking scenarios with Qpid Dispatch Router and get a lot of benefit from the AMQP protocol and its ecosystem.\n+\n+With a peer, you have the same properties that you have on a sender and receiver. For example:\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\">\n+       <peer match=\"queues.#\"/>\n+    </amqp-connection>\n+</broker-connections>\n+\n+<addresses>\n+     <address name=\"queues.A\">\n+        <anycast>\n+           <queue name=\"localQueueA\"/>\n+        </anycast>\n+     </address>\n+     <address name=\"queues.B\">\n+     <anycast>\n+        <queue name=\"localQueueB\"/>\n+     </anycast>\n+    </address>\n+</addresses>\n+```\n+\n+*Important:* Do not use this feature to connect to another broker, otherwise any message sent will be immediately ready to consume creating an infinite echo of sends and receives.\n+\n+# Mirror \n+The mirror option on the broker connection can capture events from the broker and pass them over the wire to another broker. This enables you to capture multiple asynchronous replicas. The following types of events are captured:\n+\n+* Message routing\n+* Message acknowledgement\n+* Queue and address creation\n+* queue and address deletion\n+\n+When you configure a mirror, these events are captured from the broker, stored on a local queue, and later forwarded to a target destination on another ActiveMQ Artemis broker.\n+\n+To configure a mirror, you add a `<mirror>` element within the `<amqp-connection>` element.\n+\n+The local queue is called `source-mirror-address`\n+\n+You can specify the following optional arguments.\n+\n+* `queue-removal`: Specifies whether a queue- or address-removal event is sent. The default value is `true`.\n+* `message-acknowledgements`: Specifies whether message acknowledgements are sent. The default value is `true`.\n+* `queue-creation`: Specifies whether a queue- or address-creation event is sent. The default value is `true`.\n+* `source-mirror-address`: By default, the mirror creates a non-durable temporary queue to store messages before they are sent to the other broker. If you define a name value for this property, an ANYCAST durable queue and address is created with the specified name.\n+\n+An example of a mirror configuration is shown below:\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\">\n+            <mirror  queue-removal=\"true\" queue-creation=\"true\" message-acknowledgements=\"true\" source-mirror-address=\"myLocalSNFMirrorQueue\"/>\n+    </amqp-connection>\n+</broker-connections>\n+```\n+\n+## Catch up on Mirror\n+The broker will not send past events over the mirror. As the broker sends and receives messages, only a natural catch up would eventually happen.", "originalCommit": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1Njc0MA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513556740", "bodyText": "It occurred to me while looking this over again, that a given broker cant be the target of mirrors for more than 1 broker, since the message ID's passed back and forth between them (for the acking) are likely to clash. May be worth stating something around this in the docs?", "author": "gemmellr", "createdAt": "2020-10-28T15:50:50Z", "path": "docs/user-manual/en/amqp-broker-connections.md", "diffHunk": "@@ -0,0 +1,238 @@\n+# Broker Connections\n+\n+Instead of waiting for clients to connect, a broker can initiate a connection to another endpoint on a specific protocol.\n+\n+Currently, this feature supports only the AMQP protocol. However, in the future, it might be expanded to other protocols.\n+\n+You configure broker connections using a `<broker-connections>` XML element in the `broker.xml` configuration file.\n+\n+```xml\n+<broker-connections>\n+    ...\n+</broker-connections>\n+```\n+\n+# AMQP Server Connections\n+\n+An ActiveMQ Artemis broker can initiate connections using the AMQP protocol. This means that the broker can connect to another AMQP server (not necessarily ActiveMQ Artemis) and create elements on that connection.\n+\n+To define an AMQP broker connection, add an `<amqp-connection>` element within the `<broker-connections` element in the `broker.xml` configuration file. For example:\n+\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\" retry-interval=\"100\" reconnect-attempts=\"-1\" user=\"john\" password=\"doe\">\n+         ...\n+    </amqp-connection>\n+</broker-connections>\n+```\n+\n+- `uri`: tcp://host:myport (this is a required argument)\n+- `name`: Name of the connection used for management purposes\n+- `user`: User name with which to connect to the endpoint (this is an optional argument)\n+- `password`: Password with which to connect to the endpoint (this is an optional argument)\n+- `retry-interval`: Time, in milliseconds to wait before retrying a connection after an error. The default value is `5000`.\n+- `reconnect-attempts`: default is -1 meaning infinite\n+- `auto-start` : Should the broker connection start automatically with the broker. Default is `true`. If false you need to call a management operation to start it.\n+\n+*Notice*: If you disable auto-start on the broker connection, the start of the broker connection will only happen after the management method `startBrokerConnection(connectionName)` is called on the ServerController.\n+\n+*Important*: The target endpoint needs permission for all operations that you configure. Therefore, If you are using a security manager, ensure that you perform the configured operations as a user with sufficient permissions.\n+\n+# AMQP Server Connection Operations\n+The following types of operations are supported on a AMQP server connection:\n+\n+* Senders\n+    * Messages received on specific queues are transferred to another endpoint\n+* Receivers\n+    * The broker pulls messages from another endpoint\n+* Peers\n+    * The broker creates both senders and receivers on another endpoint that knows how to handle them. Currently, this is implemented by Apache Qpid Dispatch.\n+* Mirrors\n+    * The broker uses an AMQP connection to another broker and duplicate messages and sends acknowledgements over the wire.\n+\n+## Senders and Receivers\n+It is possible to connect an ActiveMQ Artemis broker to another AMQP endpoint simply by creating a sender or receiver broker connection element.\n+\n+For a `sender`, the broker creates a message consumer on a queue that sends messages to another AMQP endpoint.\n+\n+For a `receiver`, the broker creates a message producer on an address that receives messages from another AMQP endpoint.\n+\n+Both elements work like a message bridge. However, there is no additional overhead required to process messages. Senders and receivers behave just like any other consumer or producer in ActiveMQ Artemis.\n+\n+You can configure senders or receivers for specific queues. You can also match senders and receivers to specific addresses or _sets_ of addresses, using wildcard expressions. When configuring a sender or receiver, you can set the following properties:\n+\n+- `match`: Match the sender or receiver to a specific address or __set__ of addresses, using a wildcard expression\n+- `queue-name`: Configure the sender or receiver for a specific queue\n+\n+\n+Some examples are shown below.\n+\n+Using address expressions:\n+```xml\n+<broker-connections>\n+        <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\">\n+                <sender match=\"queues.#\"/>\n+                <!-- notice the local queues for remotequeues.# need to be created on this broker -->\n+                <receiver match=\"remotequeues.#\"/>\n+        </amqp-connection>\n+</broker-connections>\n+\n+<addresses>\n+        <address name=\"remotequeues.A\">\n+                <anycast>\n+                        <queue name=\"remoteQueueA\"/>\n+                </anycast>\n+        </address>\n+        <address name=\"queues.B\">\n+                 <anycast>\n+                        <queue name=\"localQueueB\"/>\n+                </anycast>\n+        </address>\n+</addresses>\n+```\n+\n+Using queue names:\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\">\n+        <receiver queue-name=\"remoteQueueA\"/>\n+        <sender queue-name=\"localQueueB\"/>\n+    </amqp-connection>\n+</broker-connections>\n+\n+<addresses>\n+     <address name=\"remotequeues.A\">\n+        <anycast>\n+           <queue name=\"remoteQueueA\"/>\n+        </anycast>\n+     </address>\n+     <address name=\"queues.B\">\n+        <anycast>\n+           <queue name=\"localQueueB\"/>\n+        </anycast>\n+     </address>\n+</addresses>\n+\n+```\n+*Important*: You can match a receiver only to a local queue that already exists. Therefore, if you are using receivers, make sure that you pre-create the queue locally. Otherwise, the broker cannot match the remote queues and addresses.\n+\n+*Important*: Do not create a sender and a receiver to the same destination. This creates an infinite loop of sends and receives.\n+\n+\n+# Peers\n+A peer broker connection element is a combination of sender and receivers. The ActiveMQ Artemis broker creates both a sender and a receiver for a peer element, and the endpoint knows how to deal with the pair without creating an infinite loop of sending and receiving messages.\n+\n+Currently, [Apache Qpid Dispatch Router](https://qpid.apache.org/components/dispatch-router/index.html) is a peer. ActiveMQ Artemis creates the pair of receivers and sender for each matching destination. These senders and receivers have special configuration to let Qpid Dispatch Router know to collaborate with ActiveMQ Artemis.\n+\n+You can experiment with advanced networking scenarios with Qpid Dispatch Router and get a lot of benefit from the AMQP protocol and its ecosystem.\n+\n+With a peer, you have the same properties that you have on a sender and receiver. For example:\n+```xml\n+<broker-connections>\n+    <amqp-connection uri=\"tcp://MY_HOST:MY_PORT\" name=\"my-broker\">\n+       <peer match=\"queues.#\"/>\n+    </amqp-connection>\n+</broker-connections>\n+\n+<addresses>\n+     <address name=\"queues.A\">\n+        <anycast>\n+           <queue name=\"localQueueA\"/>\n+        </anycast>\n+     </address>\n+     <address name=\"queues.B\">\n+     <anycast>\n+        <queue name=\"localQueueB\"/>\n+     </anycast>\n+    </address>\n+</addresses>\n+```\n+\n+*Important:* Do not use this feature to connect to another broker, otherwise any message sent will be immediately ready to consume creating an infinite echo of sends and receives.\n+\n+# Mirror ", "originalCommit": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1NzY2OA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513557668", "bodyText": "Name needs updating", "author": "gemmellr", "createdAt": "2020-10-28T15:51:56Z", "path": "examples/features/broker-connection/amqp-receiving-messages/pom.xml", "diffHunk": "@@ -0,0 +1,165 @@\n+<?xml version='1.0'?>\n+<!--\n+Licensed to the Apache Software Foundation (ASF) under one\n+or more contributor license agreements.  See the NOTICE file\n+distributed with this work for additional information\n+regarding copyright ownership.  The ASF licenses this file\n+to you under the Apache License, Version 2.0 (the\n+\"License\"); you may not use this file except in compliance\n+with the License.  You may obtain a copy of the License at\n+\n+  http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing,\n+software distributed under the License is distributed on an\n+\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+KIND, either express or implied.  See the License for the\n+specific language governing permissions and limitations\n+under the License.\n+-->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+   <modelVersion>4.0.0</modelVersion>\n+\n+   <parent>\n+      <groupId>org.apache.activemq.examples.broker-connection</groupId>\n+      <artifactId>broker-connections</artifactId>\n+      <version>2.16.0-SNAPSHOT</version>\n+   </parent>\n+\n+   <artifactId>amqp-receiving-messages</artifactId>\n+   <packaging>jar</packaging>\n+   <name>ActiveMQ Artemis JMS Client Side Load Balancing Example</name>", "originalCommit": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1ODE1MA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513558150", "bodyText": "Is the version not dependency-managed somewhere already?", "author": "gemmellr", "createdAt": "2020-10-28T15:52:35Z", "path": "examples/features/broker-connection/amqp-receiving-messages/pom.xml", "diffHunk": "@@ -0,0 +1,165 @@\n+<?xml version='1.0'?>\n+<!--\n+Licensed to the Apache Software Foundation (ASF) under one\n+or more contributor license agreements.  See the NOTICE file\n+distributed with this work for additional information\n+regarding copyright ownership.  The ASF licenses this file\n+to you under the Apache License, Version 2.0 (the\n+\"License\"); you may not use this file except in compliance\n+with the License.  You may obtain a copy of the License at\n+\n+  http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing,\n+software distributed under the License is distributed on an\n+\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+KIND, either express or implied.  See the License for the\n+specific language governing permissions and limitations\n+under the License.\n+-->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+   <modelVersion>4.0.0</modelVersion>\n+\n+   <parent>\n+      <groupId>org.apache.activemq.examples.broker-connection</groupId>\n+      <artifactId>broker-connections</artifactId>\n+      <version>2.16.0-SNAPSHOT</version>\n+   </parent>\n+\n+   <artifactId>amqp-receiving-messages</artifactId>\n+   <packaging>jar</packaging>\n+   <name>ActiveMQ Artemis JMS Client Side Load Balancing Example</name>\n+\n+   <properties>\n+      <activemq.basedir>${project.basedir}/../../../..</activemq.basedir>\n+   </properties>\n+\n+   <dependencies>\n+      <dependency>\n+         <groupId>org.apache.qpid</groupId>\n+         <artifactId>qpid-jms-client</artifactId>\n+         <version>${qpid.jms.version}</version>", "originalCommit": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxNjU4Mw==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513616583", "bodyText": "this is just like any other example using qpid-jms.", "author": "clebertsuconic", "createdAt": "2020-10-28T17:07:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1ODE1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU1ODk4NA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513558984", "bodyText": "I'd avoid using the AMQPS port for non-TLS examples.", "author": "gemmellr", "createdAt": "2020-10-28T15:53:39Z", "path": "examples/features/broker-connection/amqp-receiving-messages/pom.xml", "diffHunk": "@@ -0,0 +1,165 @@\n+<?xml version='1.0'?>\n+<!--\n+Licensed to the Apache Software Foundation (ASF) under one\n+or more contributor license agreements.  See the NOTICE file\n+distributed with this work for additional information\n+regarding copyright ownership.  The ASF licenses this file\n+to you under the Apache License, Version 2.0 (the\n+\"License\"); you may not use this file except in compliance\n+with the License.  You may obtain a copy of the License at\n+\n+  http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing,\n+software distributed under the License is distributed on an\n+\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+KIND, either express or implied.  See the License for the\n+specific language governing permissions and limitations\n+under the License.\n+-->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+   <modelVersion>4.0.0</modelVersion>\n+\n+   <parent>\n+      <groupId>org.apache.activemq.examples.broker-connection</groupId>\n+      <artifactId>broker-connections</artifactId>\n+      <version>2.16.0-SNAPSHOT</version>\n+   </parent>\n+\n+   <artifactId>amqp-receiving-messages</artifactId>\n+   <packaging>jar</packaging>\n+   <name>ActiveMQ Artemis JMS Client Side Load Balancing Example</name>\n+\n+   <properties>\n+      <activemq.basedir>${project.basedir}/../../../..</activemq.basedir>\n+   </properties>\n+\n+   <dependencies>\n+      <dependency>\n+         <groupId>org.apache.qpid</groupId>\n+         <artifactId>qpid-jms-client</artifactId>\n+         <version>${qpid.jms.version}</version>\n+      </dependency>\n+   </dependencies>\n+\n+   <build>\n+      <plugins>\n+         <plugin>\n+            <groupId>org.apache.activemq</groupId>\n+            <artifactId>artemis-maven-plugin</artifactId>\n+            <executions>\n+               <execution>\n+                  <id>create0</id>\n+                  <goals>\n+                     <goal>create</goal>\n+                  </goals>\n+                  <configuration>\n+                     <ignore>${noServer}</ignore>\n+                     <instance>${basedir}/target/server0</instance>\n+                     <allowAnonymous>true</allowAnonymous>\n+                     <configuration>${basedir}/target/classes/activemq/server0</configuration>\n+                     <!-- this makes it easier in certain envs -->\n+                     <javaOptions>-Djava.net.preferIPv4Stack=true</javaOptions>\n+                  </configuration>\n+               </execution>\n+               <execution>\n+                  <id>create1</id>\n+                  <goals>\n+                     <goal>create</goal>\n+                  </goals>\n+                  <configuration>\n+                     <ignore>${noServer}</ignore>\n+                     <instance>${basedir}/target/server1</instance>\n+                     <allowAnonymous>true</allowAnonymous>\n+                     <configuration>${basedir}/target/classes/activemq/server1</configuration>\n+                     <!-- this makes it easier in certain envs -->\n+                     <javaOptions>-Djava.net.preferIPv4Stack=true</javaOptions>\n+                  </configuration>\n+               </execution>\n+               <!-- we first start broker 1, to avoid reconnecting statements -->\n+               <execution>\n+                  <id>start1</id>\n+                  <goals>\n+                     <goal>cli</goal>\n+                  </goals>\n+                  <configuration>\n+                     <ignore>${noServer}</ignore>\n+                     <spawn>true</spawn>\n+                     <location>${basedir}/target/server1</location>\n+                     <testURI>tcp://localhost:5672</testURI>\n+                     <args>\n+                        <param>run</param>\n+                     </args>\n+                     <name>server1</name>\n+                  </configuration>\n+               </execution>\n+               <execution>\n+                  <id>start0</id>\n+                  <goals>\n+                     <goal>cli</goal>\n+                  </goals>\n+                  <configuration>\n+                     <spawn>true</spawn>\n+                     <ignore>${noServer}</ignore>\n+                     <location>${basedir}/target/server0</location>\n+                     <testURI>tcp://localhost:5671</testURI>", "originalCommit": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2MDA0Mw==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513560043", "bodyText": "Name needs updated", "author": "gemmellr", "createdAt": "2020-10-28T15:54:58Z", "path": "examples/features/broker-connection/amqp-sending-messages/pom.xml", "diffHunk": "@@ -0,0 +1,165 @@\n+<?xml version='1.0'?>\n+<!--\n+Licensed to the Apache Software Foundation (ASF) under one\n+or more contributor license agreements.  See the NOTICE file\n+distributed with this work for additional information\n+regarding copyright ownership.  The ASF licenses this file\n+to you under the Apache License, Version 2.0 (the\n+\"License\"); you may not use this file except in compliance\n+with the License.  You may obtain a copy of the License at\n+\n+  http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing,\n+software distributed under the License is distributed on an\n+\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+KIND, either express or implied.  See the License for the\n+specific language governing permissions and limitations\n+under the License.\n+-->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+   <modelVersion>4.0.0</modelVersion>\n+\n+   <parent>\n+      <groupId>org.apache.activemq.examples.broker-connection</groupId>\n+      <artifactId>broker-connections</artifactId>\n+      <version>2.16.0-SNAPSHOT</version>\n+   </parent>\n+\n+   <artifactId>amqp-sending-messages</artifactId>\n+   <packaging>jar</packaging>\n+   <name>ActiveMQ Artemis JMS Client Side Load Balancing Example</name>", "originalCommit": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2MDI3NQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513560275", "bodyText": "I'd avoid using the AMQPS port for non-TLS examples.", "author": "gemmellr", "createdAt": "2020-10-28T15:55:14Z", "path": "examples/features/broker-connection/amqp-sending-messages/pom.xml", "diffHunk": "@@ -0,0 +1,165 @@\n+<?xml version='1.0'?>\n+<!--\n+Licensed to the Apache Software Foundation (ASF) under one\n+or more contributor license agreements.  See the NOTICE file\n+distributed with this work for additional information\n+regarding copyright ownership.  The ASF licenses this file\n+to you under the Apache License, Version 2.0 (the\n+\"License\"); you may not use this file except in compliance\n+with the License.  You may obtain a copy of the License at\n+\n+  http://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing,\n+software distributed under the License is distributed on an\n+\"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+KIND, either express or implied.  See the License for the\n+specific language governing permissions and limitations\n+under the License.\n+-->\n+\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+   <modelVersion>4.0.0</modelVersion>\n+\n+   <parent>\n+      <groupId>org.apache.activemq.examples.broker-connection</groupId>\n+      <artifactId>broker-connections</artifactId>\n+      <version>2.16.0-SNAPSHOT</version>\n+   </parent>\n+\n+   <artifactId>amqp-sending-messages</artifactId>\n+   <packaging>jar</packaging>\n+   <name>ActiveMQ Artemis JMS Client Side Load Balancing Example</name>\n+\n+   <properties>\n+      <activemq.basedir>${project.basedir}/../../../..</activemq.basedir>\n+   </properties>\n+\n+   <dependencies>\n+      <dependency>\n+         <groupId>org.apache.qpid</groupId>\n+         <artifactId>qpid-jms-client</artifactId>\n+         <version>${qpid.jms.version}</version>\n+      </dependency>\n+   </dependencies>\n+\n+   <build>\n+      <plugins>\n+         <plugin>\n+            <groupId>org.apache.activemq</groupId>\n+            <artifactId>artemis-maven-plugin</artifactId>\n+            <executions>\n+               <execution>\n+                  <id>create0</id>\n+                  <goals>\n+                     <goal>create</goal>\n+                  </goals>\n+                  <configuration>\n+                     <ignore>${noServer}</ignore>\n+                     <instance>${basedir}/target/server0</instance>\n+                     <allowAnonymous>true</allowAnonymous>\n+                     <configuration>${basedir}/target/classes/activemq/server0</configuration>\n+                     <!-- this makes it easier in certain envs -->\n+                     <javaOptions>-Djava.net.preferIPv4Stack=true</javaOptions>\n+                  </configuration>\n+               </execution>\n+               <execution>\n+                  <id>create1</id>\n+                  <goals>\n+                     <goal>create</goal>\n+                  </goals>\n+                  <configuration>\n+                     <ignore>${noServer}</ignore>\n+                     <instance>${basedir}/target/server1</instance>\n+                     <allowAnonymous>true</allowAnonymous>\n+                     <configuration>${basedir}/target/classes/activemq/server1</configuration>\n+                     <!-- this makes it easier in certain envs -->\n+                     <javaOptions>-Djava.net.preferIPv4Stack=true</javaOptions>\n+                  </configuration>\n+               </execution>\n+               <!-- we first start broker 1, to avoid reconnecting statements -->\n+               <execution>\n+                  <id>start1</id>\n+                  <goals>\n+                     <goal>cli</goal>\n+                  </goals>\n+                  <configuration>\n+                     <ignore>${noServer}</ignore>\n+                     <spawn>true</spawn>\n+                     <location>${basedir}/target/server1</location>\n+                     <testURI>tcp://localhost:5672</testURI>\n+                     <args>\n+                        <param>run</param>\n+                     </args>\n+                     <name>server1</name>\n+                  </configuration>\n+               </execution>\n+               <execution>\n+                  <id>start0</id>\n+                  <goals>\n+                     <goal>cli</goal>\n+                  </goals>\n+                  <configuration>\n+                     <spawn>true</spawn>\n+                     <ignore>${noServer}</ignore>\n+                     <location>${basedir}/target/server0</location>\n+                     <testURI>tcp://localhost:5671</testURI>", "originalCommit": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2MTEzNg==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513561136", "bodyText": "Stale comment", "author": "gemmellr", "createdAt": "2020-10-28T15:56:19Z", "path": "examples/features/broker-connection/amqp-receiving-messages/src/main/java/org/apache/activemq/artemis/jms/example/BrokerConnectionReceiver.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq.artemis.jms.example;\n+\n+import javax.jms.Connection;\n+import javax.jms.ConnectionFactory;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageProducer;\n+import javax.jms.Queue;\n+import javax.jms.Session;\n+import javax.jms.TextMessage;\n+\n+import org.apache.qpid.jms.JmsConnectionFactory;\n+\n+/**\n+ * This example demonstrates how sessions created from a single connection can be load\n+ * balanced across the different nodes of the cluster.\n+ * <p>\n+ * In this example there are three nodes and we use a round-robin client side load-balancing\n+ * policy.\n+ */", "originalCommit": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2MjgwMA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513562800", "bodyText": "Readme needs updated", "author": "gemmellr", "createdAt": "2020-10-28T15:58:14Z", "path": "examples/features/broker-connection/amqp-sending-overssl/readme.md", "diffHunk": "@@ -0,0 +1,15 @@\n+# JMS SSL Example", "originalCommit": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2NDQyNg==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513564426", "bodyText": "I know the target of the example is SSL between the brokers...but it might make more sense to use SSL for the clients too. Then you would only need one acceptor.\nThis basically makes it seem like SSL isnt being used.", "author": "gemmellr", "createdAt": "2020-10-28T16:00:04Z", "path": "examples/features/broker-connection/amqp-sending-overssl/src/main/java/org/apache/activemq/artemis/jms/example/BrokerConnectionSenderSSL.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq.artemis.jms.example;\n+\n+import javax.jms.Connection;\n+import javax.jms.ConnectionFactory;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageProducer;\n+import javax.jms.Queue;\n+import javax.jms.Session;\n+import javax.jms.TextMessage;\n+\n+import org.apache.qpid.jms.JmsConnectionFactory;\n+\n+/**\n+ * This example is demonstrating how messages are transferred from one broker towards another broker\n+ * through the sender element on a AMQP Broker Connection.\n+ */\n+public class BrokerConnectionSenderSSL {\n+\n+   public static void main(final String[] args) throws Exception {\n+      Connection connectionOnServer0 = null;\n+      ConnectionFactory connectionFactoryServer0 = new JmsConnectionFactory(\"amqp://localhost:5671\");", "originalCommit": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3OTYwNA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513579604", "bodyText": "I'm not showing how to use SSL on  the client here.. .this is already covered elsewhere.", "author": "clebertsuconic", "createdAt": "2020-10-28T16:19:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2NDQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU4ODM1Mg==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513588352", "bodyText": "I know that, as I commented. Its just weird though. The example broker config is actually more complicated due to not using SSL for the client...which wouldnt add any complexity since all the stores are already in place.", "author": "gemmellr", "createdAt": "2020-10-28T16:30:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2NDQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzYxNzU0NA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513617544", "bodyText": "I would not do that on this version.. there's a lot of stuff to cover already.", "author": "clebertsuconic", "createdAt": "2020-10-28T17:08:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2NDQyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDIzMjE1OQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r514232159", "bodyText": "I'm sending a change for this on the PR #3318", "author": "clebertsuconic", "createdAt": "2020-10-29T12:49:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2NDQyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2NzI5OA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513567298", "bodyText": "Per the offline discussion yesterday, this listener isnt required and is somewhat misleading implying it has to be a route-container. The single normal (client) listener can be used.", "author": "gemmellr", "createdAt": "2020-10-28T16:03:28Z", "path": "tests/integration-tests/src/test/resources/QpidRouterPeerTest-qpidr.conf", "diffHunk": "@@ -0,0 +1,51 @@\n+ #\n+ # Licensed to the Apache Software Foundation (ASF) under one or more\n+ # contributor license agreements. See the NOTICE file distributed with\n+ # this work for additional information regarding copyright ownership.\n+ # The ASF licenses this file to You under the Apache License, Version 2.0\n+ # (the \"License\"); you may not use this file except in compliance with\n+ # the License. You may obtain a copy of the License at\n+ #\n+ #     http://www.apache.org/licenses/LICENSE-2.0\n+ #\n+ # Unless required by applicable law or agreed to in writing, software\n+ # distributed under the License is distributed on an \"AS IS\" BASIS,\n+ # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ # See the License for the specific language governing permissions and\n+ # limitations under the License.\n+ #\n+\n+ router {\n+     mode: standalone\n+     id: INT.A\n+ }\n+#log {\n+    #module: DEFAULT\n+    #enable: trace+\n+    #outputFile: /tmp/qdrouterd.log\n+#}\n+\n+ # The broker connects into this port\n+ listener {\n+     saslMechanisms: ANONYMOUS\n+     host: 0.0.0.0\n+     role: route-container\n+     linkCapacity: 1123\n+     authenticatePeer: no\n+     port: 24621\n+ }\n+", "originalCommit": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2NzU2NQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513567565", "bodyText": "I would remove the capacity config personally, most people wont need that.", "author": "gemmellr", "createdAt": "2020-10-28T16:03:47Z", "path": "tests/integration-tests/src/test/resources/QpidRouterPeerTest-qpidr.conf", "diffHunk": "@@ -0,0 +1,51 @@\n+ #\n+ # Licensed to the Apache Software Foundation (ASF) under one or more\n+ # contributor license agreements. See the NOTICE file distributed with\n+ # this work for additional information regarding copyright ownership.\n+ # The ASF licenses this file to You under the Apache License, Version 2.0\n+ # (the \"License\"); you may not use this file except in compliance with\n+ # the License. You may obtain a copy of the License at\n+ #\n+ #     http://www.apache.org/licenses/LICENSE-2.0\n+ #\n+ # Unless required by applicable law or agreed to in writing, software\n+ # distributed under the License is distributed on an \"AS IS\" BASIS,\n+ # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ # See the License for the specific language governing permissions and\n+ # limitations under the License.\n+ #\n+\n+ router {\n+     mode: standalone\n+     id: INT.A\n+ }\n+#log {\n+    #module: DEFAULT\n+    #enable: trace+\n+    #outputFile: /tmp/qdrouterd.log\n+#}\n+\n+ # The broker connects into this port\n+ listener {\n+     saslMechanisms: ANONYMOUS\n+     host: 0.0.0.0\n+     role: route-container\n+     linkCapacity: 1123\n+     authenticatePeer: no\n+     port: 24621\n+ }\n+\n+ # Clients connect to this port\n+ listener {\n+     saslMechanisms: ANONYMOUS\n+     host: 0.0.0.0\n+     linkCapacity: 555\n+     role: normal\n+     authenticatePeer: no\n+     port: 24622\n+ }", "originalCommit": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY3NTM3Mg==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513675372", "bodyText": "this test is just a tool to developers.. not intended as documentation.\nWill do it.. but it's outside of the scope.", "author": "clebertsuconic", "createdAt": "2020-10-28T18:34:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2NzU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2OTc0NA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513569744", "bodyText": "Given this will be the typical case, I think not printing (perhaps debug logging?) the stacktrace would be good, and instead having the assumption check say why it is skipping", "author": "gemmellr", "createdAt": "2020-10-28T16:06:24Z", "path": "tests/integration-tests/src/test/java/org/apache/activemq/artemis/tests/integration/amqp/connect/QpidDispatchPeerTest.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.activemq.artemis.tests.integration.amqp.connect;\n+\n+import javax.jms.Connection;\n+import javax.jms.ConnectionFactory;\n+import javax.jms.DeliveryMode;\n+import javax.jms.MessageConsumer;\n+import javax.jms.MessageProducer;\n+import javax.jms.Queue;\n+import javax.jms.Session;\n+import javax.jms.TextMessage;\n+import java.net.URL;\n+\n+import org.apache.activemq.artemis.api.core.QueueConfiguration;\n+import org.apache.activemq.artemis.api.core.RoutingType;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectConfiguration;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectionAddressType;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectionElement;\n+import org.apache.activemq.artemis.core.server.ActiveMQServer;\n+import org.apache.activemq.artemis.core.server.impl.AddressInfo;\n+import org.apache.activemq.artemis.tests.integration.amqp.AmqpClientTestSupport;\n+import org.apache.activemq.artemis.tests.util.CFUtil;\n+import org.apache.activemq.artemis.tests.util.Wait;\n+import org.apache.activemq.artemis.utils.ExecuteUtil;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Assume;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+/** This test will only be executed if you have qdrouterd available on your system, otherwise is ignored by an assume exception. */\n+public class QpidDispatchPeerTest extends AmqpClientTestSupport {\n+\n+   ExecuteUtil.ProcessHolder qpidProcess;\n+\n+   /**\n+    * This will validate if the environemnt has qdrouterd installed and if this test can be used or not.\n+    */\n+   @BeforeClass\n+   public static void validateqdrotuer() {\n+      try {\n+         int result = ExecuteUtil.runCommand(true, \"qdrouterd\", \"--version\");\n+         Assume.assumeTrue(\"qdrouterd does not exist\", result == 0);\n+      } catch (Exception e) {\n+         e.printStackTrace();", "originalCommit": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU5NDU2MA==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513594560", "bodyText": "Adding a \":\" between the name and generated bit would aid readability when debugging protocol trace.", "author": "gemmellr", "createdAt": "2020-10-28T16:38:54Z", "path": "artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/connect/AMQPBrokerConnection.java", "diffHunk": "@@ -0,0 +1,556 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.activemq.artemis.protocol.amqp.connect;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Stream;\n+\n+import org.apache.activemq.artemis.api.core.ActiveMQException;\n+import org.apache.activemq.artemis.api.core.QueueConfiguration;\n+import org.apache.activemq.artemis.api.core.RoutingType;\n+import org.apache.activemq.artemis.api.core.SimpleString;\n+import org.apache.activemq.artemis.api.core.TransportConfiguration;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectConfiguration;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectionAddressType;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectionElement;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPMirrorBrokerConnectionElement;\n+import org.apache.activemq.artemis.core.postoffice.Binding;\n+import org.apache.activemq.artemis.core.postoffice.QueueBinding;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.NettyConnection;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.NettyConnector;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.TransportConstants;\n+import org.apache.activemq.artemis.core.server.ActiveMQComponent;\n+import org.apache.activemq.artemis.core.server.ActiveMQServer;\n+import org.apache.activemq.artemis.core.server.BrokerConnection;\n+import org.apache.activemq.artemis.core.server.Consumer;\n+import org.apache.activemq.artemis.core.server.Queue;\n+import org.apache.activemq.artemis.core.server.impl.AddressInfo;\n+import org.apache.activemq.artemis.core.server.mirror.MirrorController;\n+import org.apache.activemq.artemis.core.server.plugin.ActiveMQServerQueuePlugin;\n+import org.apache.activemq.artemis.protocol.amqp.broker.AMQPSessionCallback;\n+import org.apache.activemq.artemis.protocol.amqp.broker.ActiveMQProtonRemotingConnection;\n+import org.apache.activemq.artemis.protocol.amqp.broker.ProtonProtocolManager;\n+import org.apache.activemq.artemis.protocol.amqp.connect.mirror.AMQPMirrorControllerAggregation;\n+import org.apache.activemq.artemis.protocol.amqp.connect.mirror.AMQPMirrorControllerSource;\n+import org.apache.activemq.artemis.protocol.amqp.logger.ActiveMQAMQPProtocolLogger;\n+import org.apache.activemq.artemis.protocol.amqp.proton.AMQPSessionContext;\n+import org.apache.activemq.artemis.protocol.amqp.proton.ProtonServerSenderContext;\n+import org.apache.activemq.artemis.protocol.amqp.proton.SenderController;\n+import org.apache.activemq.artemis.protocol.amqp.sasl.ClientSASL;\n+import org.apache.activemq.artemis.protocol.amqp.sasl.ClientSASLFactory;\n+import org.apache.activemq.artemis.spi.core.protocol.ConnectionEntry;\n+import org.apache.activemq.artemis.spi.core.remoting.ClientConnectionLifeCycleListener;\n+import org.apache.activemq.artemis.spi.core.remoting.ClientProtocolManager;\n+import org.apache.activemq.artemis.spi.core.remoting.Connection;\n+import org.apache.activemq.artemis.utils.ConfigurationHelper;\n+import org.apache.activemq.artemis.utils.UUIDGenerator;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.Source;\n+import org.apache.qpid.proton.amqp.messaging.Target;\n+import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;\n+import org.apache.qpid.proton.amqp.transport.SenderSettleMode;\n+import org.apache.qpid.proton.engine.Receiver;\n+import org.apache.qpid.proton.engine.Sender;\n+import org.apache.qpid.proton.engine.Session;\n+import org.jboss.logging.Logger;\n+\n+public class AMQPBrokerConnection implements ClientConnectionLifeCycleListener, ActiveMQServerQueuePlugin, BrokerConnection {\n+\n+   private static final Logger logger = Logger.getLogger(AMQPBrokerConnection.class);\n+\n+   private final AMQPBrokerConnectConfiguration brokerConnectConfiguration;\n+   private final ProtonProtocolManager protonProtocolManager;\n+   private final ActiveMQServer server;\n+   private final NettyConnector bridgesConnector;\n+   private NettyConnection connection;\n+   private Session session;\n+   private AMQPSessionContext sessionContext;\n+   private ActiveMQProtonRemotingConnection protonRemotingConnection;\n+   private volatile boolean started = false;\n+   private final AMQPBrokerConnectionManager bridgeManager;\n+   private int retryCounter = 0;\n+   private volatile ScheduledFuture reconnectFuture;\n+   private Set<Queue> senders = new HashSet<>();\n+   private Set<Queue> receivers = new HashSet<>();\n+\n+   final Executor connectExecutor;\n+   final ScheduledExecutorService scheduledExecutorService;\n+\n+   /** This is just for logging.\n+    *  the actual connection will come from the amqpConnection configuration*/\n+   String host;\n+\n+   /** This is just for logging.\n+    *  the actual connection will come from the amqpConnection configuration*/\n+   int port;\n+\n+   public AMQPBrokerConnection(AMQPBrokerConnectionManager bridgeManager, AMQPBrokerConnectConfiguration brokerConnectConfiguration,\n+                               ProtonProtocolManager protonProtocolManager,\n+                               ActiveMQServer server,\n+                               NettyConnector bridgesConnector) {\n+      this.bridgeManager = bridgeManager;\n+      this.brokerConnectConfiguration = brokerConnectConfiguration;\n+      this.protonProtocolManager = protonProtocolManager;\n+      this.server = server;\n+      this.bridgesConnector = bridgesConnector;\n+      connectExecutor = server.getExecutorFactory().getExecutor();\n+      scheduledExecutorService = server.getScheduledPool();\n+   }\n+\n+   @Override\n+   public String getName() {\n+      return brokerConnectConfiguration.getName();\n+   }\n+\n+   @Override\n+   public String getProtocol() {\n+      return \"AMQP\";\n+   }\n+\n+   @Override\n+   public boolean isStarted() {\n+      return started;\n+   }\n+\n+   @Override\n+   public void stop() {\n+      if (connection != null) {\n+         connection.close();\n+      }\n+      ScheduledFuture scheduledFuture = reconnectFuture;\n+      reconnectFuture = null;\n+      if (scheduledFuture != null) {\n+         scheduledFuture.cancel(true);\n+      }\n+      started = false;\n+   }\n+\n+   @Override\n+   public void start() throws Exception {\n+      started = true;\n+      server.getConfiguration().registerBrokerPlugin(this);\n+      try {\n+\n+         for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+            if (connectionElement.getType() == AMQPBrokerConnectionAddressType.MIRROR) {\n+               installMirrorController((AMQPMirrorBrokerConnectionElement)connectionElement, server);\n+            }\n+         }\n+      } catch (Throwable e) {\n+         logger.warn(e.getMessage(), e);\n+         return;\n+      }\n+      connectExecutor.execute(() -> doConnect());\n+   }\n+\n+   public NettyConnection getConnection() {\n+      return connection;\n+   }\n+\n+   @Override\n+   public void afterCreateQueue(Queue queue) {\n+      connectExecutor.execute(() -> {\n+         for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+            validateMatching(queue, connectionElement);\n+         }\n+      });\n+   }\n+\n+   public void validateMatching(Queue queue, AMQPBrokerConnectionElement connectionElement) {\n+      if (connectionElement.getType() != AMQPBrokerConnectionAddressType.MIRROR) {\n+         if (connectionElement.getQueueName() != null) {\n+            if (queue.getName().equals(connectionElement.getQueueName())) {\n+               createLink(queue, connectionElement);\n+            }\n+         } else if (connectionElement.match(queue.getAddress(), server.getConfiguration().getWildcardConfiguration())) {\n+            createLink(queue, connectionElement);\n+         }\n+      }\n+   }\n+\n+   public void createLink(Queue queue, AMQPBrokerConnectionElement connectionElement) {\n+      if (connectionElement.getType() == AMQPBrokerConnectionAddressType.PEER) {\n+         connectSender(queue, queue.getAddress().toString(), Symbol.valueOf(\"qd.waypoint\"));\n+         connectReceiver(protonRemotingConnection, session, sessionContext, queue, Symbol.valueOf(\"qd.waypoint\"));\n+      } else {\n+         if (connectionElement.getType() == AMQPBrokerConnectionAddressType.SENDER) {\n+            connectSender(queue, queue.getAddress().toString());\n+         }\n+         if (connectionElement.getType() == AMQPBrokerConnectionAddressType.RECEIVER) {\n+            connectReceiver(protonRemotingConnection, session, sessionContext, queue);\n+         }\n+      }\n+   }\n+\n+   private void doConnect() {\n+      try {\n+         List<TransportConfiguration> configurationList = brokerConnectConfiguration.getTransportConfigurations();\n+\n+         TransportConfiguration tpConfig = configurationList.get(0);\n+\n+         String hostOnParameter = ConfigurationHelper.getStringProperty(TransportConstants.HOST_PROP_NAME, TransportConstants.DEFAULT_HOST, tpConfig.getParams());\n+         int portOnParameter = ConfigurationHelper.getIntProperty(TransportConstants.PORT_PROP_NAME, TransportConstants.DEFAULT_PORT, tpConfig.getParams());\n+         this.host = hostOnParameter;\n+         this.port = portOnParameter;\n+         connection = bridgesConnector.createConnection(null, hostOnParameter, portOnParameter);\n+\n+         if (connection == null) {\n+            retryConnection();\n+            return;\n+         }\n+\n+         reconnectFuture = null;\n+         retryCounter = 0;\n+\n+         // before we retry the connection we need to remove any previous links\n+         // as they will need to be recreated\n+         senders.clear();\n+         receivers.clear();\n+\n+         ClientSASLFactory saslFactory = null;\n+\n+         if (brokerConnectConfiguration.getUser() != null && brokerConnectConfiguration.getPassword() != null) {\n+            saslFactory = availableMechanims -> {\n+               if (availableMechanims != null && Arrays.asList(availableMechanims).contains(\"PLAIN\")) {\n+                  return new PlainSASLMechanism(brokerConnectConfiguration.getUser(), brokerConnectConfiguration.getPassword());\n+               } else {\n+                  return null;\n+               }\n+            };\n+         }\n+\n+         ConnectionEntry entry = protonProtocolManager.createOutgoingConnectionEntry(connection, saslFactory);\n+         protonRemotingConnection = (ActiveMQProtonRemotingConnection) entry.connection;\n+         connection.getChannel().pipeline().addLast(new AMQPBrokerConnectionChannelHandler(bridgesConnector.getChannelGroup(), protonRemotingConnection.getAmqpConnection().getHandler()));\n+\n+         protonRemotingConnection.getAmqpConnection().runLater(() -> {\n+            protonRemotingConnection.getAmqpConnection().open();\n+            protonRemotingConnection.getAmqpConnection().flush();\n+         });\n+\n+         session = protonRemotingConnection.getAmqpConnection().getHandler().getConnection().session();\n+         sessionContext = protonRemotingConnection.getAmqpConnection().getSessionExtension(session);\n+         protonRemotingConnection.getAmqpConnection().runLater(() -> {\n+            session.open();\n+            protonRemotingConnection.getAmqpConnection().flush();\n+         });\n+\n+         if (brokerConnectConfiguration.getConnectionElements() != null) {\n+            Stream<Binding> bindingStream = server.getPostOffice().getAllBindings();\n+\n+            bindingStream.forEach(binding -> {\n+               if (binding instanceof QueueBinding) {\n+                  Queue queue = ((QueueBinding) binding).getQueue();\n+                  for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+                     validateMatching(queue, connectionElement);\n+                  }\n+               }\n+            });\n+\n+            for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+               if (connectionElement.getType() == AMQPBrokerConnectionAddressType.MIRROR) {\n+                  AMQPMirrorBrokerConnectionElement replica = (AMQPMirrorBrokerConnectionElement)connectionElement;\n+                  Queue queue = server.locateQueue(replica.getSourceMirrorAddress());\n+\n+                  connectSender(queue, ProtonProtocolManager.MIRROR_ADDRESS);\n+               }\n+            }\n+         }\n+\n+         protonRemotingConnection.getAmqpConnection().flush();\n+\n+         bridgeManager.connected(connection, this);\n+      } catch (Throwable e) {\n+         error(e);\n+      }\n+   }\n+\n+   public void retryConnection() {\n+      if (bridgeManager.isStarted() && started) {\n+         if (brokerConnectConfiguration.getReconnectAttempts() < 0 || retryCounter < brokerConnectConfiguration.getReconnectAttempts()) {\n+            retryCounter++;\n+            ActiveMQAMQPProtocolLogger.LOGGER.retryConnection(brokerConnectConfiguration.getName(), host, port, retryCounter, brokerConnectConfiguration.getReconnectAttempts());\n+            if (logger.isDebugEnabled()) {\n+               logger.debug(\"Reconnecting in \" + brokerConnectConfiguration.getRetryInterval() + \", this is the \" + retryCounter + \" of \" + brokerConnectConfiguration.getReconnectAttempts());\n+            }\n+            reconnectFuture = scheduledExecutorService.schedule(() -> connectExecutor.execute(() -> doConnect()), brokerConnectConfiguration.getRetryInterval(), TimeUnit.MILLISECONDS);\n+         } else {\n+            ActiveMQAMQPProtocolLogger.LOGGER.retryConnectionFailed(brokerConnectConfiguration.getName(), host, port, retryCounter, brokerConnectConfiguration.getReconnectAttempts());\n+            if (logger.isDebugEnabled()) {\n+               logger.debug(\"no more reconnections as the retry counter reached \" + retryCounter + \" out of \" + brokerConnectConfiguration.getReconnectAttempts());\n+            }\n+         }\n+      }\n+   }\n+\n+   /** The reason this method is static is the following:\n+    *\n+    *  It is returning the snfQueue to the replica, and I needed isolation from the actual instance.\n+    *  During development I had a mistake where I used a property from the Object,\n+    *  so, I needed this isolation for my organization and making sure nothing would be shared. */\n+   private static QueueBinding installMirrorController(AMQPMirrorBrokerConnectionElement replicaConfig, ActiveMQServer server) throws Exception {\n+\n+      AddressInfo addressInfo = server.getAddressInfo(replicaConfig.getSourceMirrorAddress());\n+      if (addressInfo == null) {\n+         addressInfo = new AddressInfo(replicaConfig.getSourceMirrorAddress()).addRoutingType(RoutingType.ANYCAST).setAutoCreated(false).setTemporary(!replicaConfig.isDurable());\n+         server.addAddressInfo(addressInfo);\n+      }\n+\n+      if (addressInfo.getRoutingType() != RoutingType.ANYCAST) {\n+         throw new IllegalArgumentException(\"sourceMirrorAddress is not ANYCAST\");\n+      }\n+\n+      Queue mirrorControlQueue = server.locateQueue(replicaConfig.getSourceMirrorAddress());\n+\n+      if (mirrorControlQueue == null) {\n+         mirrorControlQueue = server.createQueue(new QueueConfiguration(replicaConfig.getSourceMirrorAddress()).setAddress(replicaConfig.getSourceMirrorAddress()).setRoutingType(RoutingType.ANYCAST).setDurable(replicaConfig.isDurable()), true);\n+      }\n+\n+      mirrorControlQueue.setMirrorController(true);\n+\n+      QueueBinding snfReplicaQueueBinding = (QueueBinding)server.getPostOffice().getBinding(replicaConfig.getSourceMirrorAddress());\n+      if (snfReplicaQueueBinding == null) {\n+         logger.warn(\"Queue does not exist even after creation! \" + replicaConfig);\n+         throw new IllegalAccessException(\"Cannot start replica\");\n+      }\n+\n+      Queue snfQueue = snfReplicaQueueBinding.getQueue();\n+\n+      if (!snfQueue.getAddress().equals(replicaConfig.getSourceMirrorAddress())) {\n+         logger.warn(\"Queue \" + snfQueue + \" belong to a different address (\" + snfQueue.getAddress() + \"), while we expected it to be \" + addressInfo.getName());\n+         throw new IllegalAccessException(\"Cannot start replica\");\n+      }\n+\n+      AMQPMirrorControllerSource newPartition = new AMQPMirrorControllerSource(snfQueue, server, replicaConfig.isMessageAcknowledgements());\n+\n+      server.scanAddresses(newPartition);\n+\n+      MirrorController currentMirrorController = server.getMirrorController();\n+\n+      if (currentMirrorController == null) {\n+         server.installMirrorController(newPartition);\n+      } else {\n+         // Replace a standard implementation by an aggregated supporting multiple targets\n+         if (currentMirrorController instanceof AMQPMirrorControllerSource) {\n+            // replacing the simple mirror control for an aggregator\n+            AMQPMirrorControllerAggregation remoteAggregation = new AMQPMirrorControllerAggregation();\n+            remoteAggregation.addPartition((AMQPMirrorControllerSource) currentMirrorController);\n+            currentMirrorController = remoteAggregation;\n+            server.installMirrorController(remoteAggregation);\n+         }\n+         ((AMQPMirrorControllerAggregation) currentMirrorController).addPartition(newPartition);\n+      }\n+\n+      return snfReplicaQueueBinding;\n+   }\n+\n+   private void connectReceiver(ActiveMQProtonRemotingConnection protonRemotingConnection,\n+                                Session session,\n+                                AMQPSessionContext sessionContext,\n+                                Queue queue,\n+                                Symbol... capabilities) {\n+      if (logger.isDebugEnabled()) {\n+         logger.debug(\"Connecting inbound for \" + queue);\n+      }\n+\n+      if (session == null) {\n+         logger.debug(\"session is null\");\n+         return;\n+      }\n+\n+      protonRemotingConnection.getAmqpConnection().runLater(() -> {\n+\n+         if (receivers.contains(queue)) {\n+            logger.debug(\"Receiver for queue \" + queue + \" already exists, just giving up\");\n+            return;\n+         }\n+         receivers.add(queue);\n+         Receiver receiver = session.receiver(queue.getName().toString() + UUIDGenerator.getInstance().generateStringUUID());", "originalCommit": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU5OTQ4Mg==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513599482", "bodyText": "also, the link is named based on the queue name, but then the address name as the source address....I'd tend to expect the receiver link name to incorporate the source address", "author": "gemmellr", "createdAt": "2020-10-28T16:44:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU5NDU2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU5NDcyOQ==", "url": "https://github.com/apache/activemq-artemis/pull/3316#discussion_r513594729", "bodyText": "Adding a \":\" between the name and generated bit would aid readability when debugging protocol trace.", "author": "gemmellr", "createdAt": "2020-10-28T16:39:11Z", "path": "artemis-protocols/artemis-amqp-protocol/src/main/java/org/apache/activemq/artemis/protocol/amqp/connect/AMQPBrokerConnection.java", "diffHunk": "@@ -0,0 +1,556 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.activemq.artemis.protocol.amqp.connect;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Stream;\n+\n+import org.apache.activemq.artemis.api.core.ActiveMQException;\n+import org.apache.activemq.artemis.api.core.QueueConfiguration;\n+import org.apache.activemq.artemis.api.core.RoutingType;\n+import org.apache.activemq.artemis.api.core.SimpleString;\n+import org.apache.activemq.artemis.api.core.TransportConfiguration;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectConfiguration;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectionAddressType;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPBrokerConnectionElement;\n+import org.apache.activemq.artemis.core.config.amqpBrokerConnectivity.AMQPMirrorBrokerConnectionElement;\n+import org.apache.activemq.artemis.core.postoffice.Binding;\n+import org.apache.activemq.artemis.core.postoffice.QueueBinding;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.NettyConnection;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.NettyConnector;\n+import org.apache.activemq.artemis.core.remoting.impl.netty.TransportConstants;\n+import org.apache.activemq.artemis.core.server.ActiveMQComponent;\n+import org.apache.activemq.artemis.core.server.ActiveMQServer;\n+import org.apache.activemq.artemis.core.server.BrokerConnection;\n+import org.apache.activemq.artemis.core.server.Consumer;\n+import org.apache.activemq.artemis.core.server.Queue;\n+import org.apache.activemq.artemis.core.server.impl.AddressInfo;\n+import org.apache.activemq.artemis.core.server.mirror.MirrorController;\n+import org.apache.activemq.artemis.core.server.plugin.ActiveMQServerQueuePlugin;\n+import org.apache.activemq.artemis.protocol.amqp.broker.AMQPSessionCallback;\n+import org.apache.activemq.artemis.protocol.amqp.broker.ActiveMQProtonRemotingConnection;\n+import org.apache.activemq.artemis.protocol.amqp.broker.ProtonProtocolManager;\n+import org.apache.activemq.artemis.protocol.amqp.connect.mirror.AMQPMirrorControllerAggregation;\n+import org.apache.activemq.artemis.protocol.amqp.connect.mirror.AMQPMirrorControllerSource;\n+import org.apache.activemq.artemis.protocol.amqp.logger.ActiveMQAMQPProtocolLogger;\n+import org.apache.activemq.artemis.protocol.amqp.proton.AMQPSessionContext;\n+import org.apache.activemq.artemis.protocol.amqp.proton.ProtonServerSenderContext;\n+import org.apache.activemq.artemis.protocol.amqp.proton.SenderController;\n+import org.apache.activemq.artemis.protocol.amqp.sasl.ClientSASL;\n+import org.apache.activemq.artemis.protocol.amqp.sasl.ClientSASLFactory;\n+import org.apache.activemq.artemis.spi.core.protocol.ConnectionEntry;\n+import org.apache.activemq.artemis.spi.core.remoting.ClientConnectionLifeCycleListener;\n+import org.apache.activemq.artemis.spi.core.remoting.ClientProtocolManager;\n+import org.apache.activemq.artemis.spi.core.remoting.Connection;\n+import org.apache.activemq.artemis.utils.ConfigurationHelper;\n+import org.apache.activemq.artemis.utils.UUIDGenerator;\n+import org.apache.qpid.proton.amqp.Symbol;\n+import org.apache.qpid.proton.amqp.messaging.Source;\n+import org.apache.qpid.proton.amqp.messaging.Target;\n+import org.apache.qpid.proton.amqp.transport.ReceiverSettleMode;\n+import org.apache.qpid.proton.amqp.transport.SenderSettleMode;\n+import org.apache.qpid.proton.engine.Receiver;\n+import org.apache.qpid.proton.engine.Sender;\n+import org.apache.qpid.proton.engine.Session;\n+import org.jboss.logging.Logger;\n+\n+public class AMQPBrokerConnection implements ClientConnectionLifeCycleListener, ActiveMQServerQueuePlugin, BrokerConnection {\n+\n+   private static final Logger logger = Logger.getLogger(AMQPBrokerConnection.class);\n+\n+   private final AMQPBrokerConnectConfiguration brokerConnectConfiguration;\n+   private final ProtonProtocolManager protonProtocolManager;\n+   private final ActiveMQServer server;\n+   private final NettyConnector bridgesConnector;\n+   private NettyConnection connection;\n+   private Session session;\n+   private AMQPSessionContext sessionContext;\n+   private ActiveMQProtonRemotingConnection protonRemotingConnection;\n+   private volatile boolean started = false;\n+   private final AMQPBrokerConnectionManager bridgeManager;\n+   private int retryCounter = 0;\n+   private volatile ScheduledFuture reconnectFuture;\n+   private Set<Queue> senders = new HashSet<>();\n+   private Set<Queue> receivers = new HashSet<>();\n+\n+   final Executor connectExecutor;\n+   final ScheduledExecutorService scheduledExecutorService;\n+\n+   /** This is just for logging.\n+    *  the actual connection will come from the amqpConnection configuration*/\n+   String host;\n+\n+   /** This is just for logging.\n+    *  the actual connection will come from the amqpConnection configuration*/\n+   int port;\n+\n+   public AMQPBrokerConnection(AMQPBrokerConnectionManager bridgeManager, AMQPBrokerConnectConfiguration brokerConnectConfiguration,\n+                               ProtonProtocolManager protonProtocolManager,\n+                               ActiveMQServer server,\n+                               NettyConnector bridgesConnector) {\n+      this.bridgeManager = bridgeManager;\n+      this.brokerConnectConfiguration = brokerConnectConfiguration;\n+      this.protonProtocolManager = protonProtocolManager;\n+      this.server = server;\n+      this.bridgesConnector = bridgesConnector;\n+      connectExecutor = server.getExecutorFactory().getExecutor();\n+      scheduledExecutorService = server.getScheduledPool();\n+   }\n+\n+   @Override\n+   public String getName() {\n+      return brokerConnectConfiguration.getName();\n+   }\n+\n+   @Override\n+   public String getProtocol() {\n+      return \"AMQP\";\n+   }\n+\n+   @Override\n+   public boolean isStarted() {\n+      return started;\n+   }\n+\n+   @Override\n+   public void stop() {\n+      if (connection != null) {\n+         connection.close();\n+      }\n+      ScheduledFuture scheduledFuture = reconnectFuture;\n+      reconnectFuture = null;\n+      if (scheduledFuture != null) {\n+         scheduledFuture.cancel(true);\n+      }\n+      started = false;\n+   }\n+\n+   @Override\n+   public void start() throws Exception {\n+      started = true;\n+      server.getConfiguration().registerBrokerPlugin(this);\n+      try {\n+\n+         for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+            if (connectionElement.getType() == AMQPBrokerConnectionAddressType.MIRROR) {\n+               installMirrorController((AMQPMirrorBrokerConnectionElement)connectionElement, server);\n+            }\n+         }\n+      } catch (Throwable e) {\n+         logger.warn(e.getMessage(), e);\n+         return;\n+      }\n+      connectExecutor.execute(() -> doConnect());\n+   }\n+\n+   public NettyConnection getConnection() {\n+      return connection;\n+   }\n+\n+   @Override\n+   public void afterCreateQueue(Queue queue) {\n+      connectExecutor.execute(() -> {\n+         for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+            validateMatching(queue, connectionElement);\n+         }\n+      });\n+   }\n+\n+   public void validateMatching(Queue queue, AMQPBrokerConnectionElement connectionElement) {\n+      if (connectionElement.getType() != AMQPBrokerConnectionAddressType.MIRROR) {\n+         if (connectionElement.getQueueName() != null) {\n+            if (queue.getName().equals(connectionElement.getQueueName())) {\n+               createLink(queue, connectionElement);\n+            }\n+         } else if (connectionElement.match(queue.getAddress(), server.getConfiguration().getWildcardConfiguration())) {\n+            createLink(queue, connectionElement);\n+         }\n+      }\n+   }\n+\n+   public void createLink(Queue queue, AMQPBrokerConnectionElement connectionElement) {\n+      if (connectionElement.getType() == AMQPBrokerConnectionAddressType.PEER) {\n+         connectSender(queue, queue.getAddress().toString(), Symbol.valueOf(\"qd.waypoint\"));\n+         connectReceiver(protonRemotingConnection, session, sessionContext, queue, Symbol.valueOf(\"qd.waypoint\"));\n+      } else {\n+         if (connectionElement.getType() == AMQPBrokerConnectionAddressType.SENDER) {\n+            connectSender(queue, queue.getAddress().toString());\n+         }\n+         if (connectionElement.getType() == AMQPBrokerConnectionAddressType.RECEIVER) {\n+            connectReceiver(protonRemotingConnection, session, sessionContext, queue);\n+         }\n+      }\n+   }\n+\n+   private void doConnect() {\n+      try {\n+         List<TransportConfiguration> configurationList = brokerConnectConfiguration.getTransportConfigurations();\n+\n+         TransportConfiguration tpConfig = configurationList.get(0);\n+\n+         String hostOnParameter = ConfigurationHelper.getStringProperty(TransportConstants.HOST_PROP_NAME, TransportConstants.DEFAULT_HOST, tpConfig.getParams());\n+         int portOnParameter = ConfigurationHelper.getIntProperty(TransportConstants.PORT_PROP_NAME, TransportConstants.DEFAULT_PORT, tpConfig.getParams());\n+         this.host = hostOnParameter;\n+         this.port = portOnParameter;\n+         connection = bridgesConnector.createConnection(null, hostOnParameter, portOnParameter);\n+\n+         if (connection == null) {\n+            retryConnection();\n+            return;\n+         }\n+\n+         reconnectFuture = null;\n+         retryCounter = 0;\n+\n+         // before we retry the connection we need to remove any previous links\n+         // as they will need to be recreated\n+         senders.clear();\n+         receivers.clear();\n+\n+         ClientSASLFactory saslFactory = null;\n+\n+         if (brokerConnectConfiguration.getUser() != null && brokerConnectConfiguration.getPassword() != null) {\n+            saslFactory = availableMechanims -> {\n+               if (availableMechanims != null && Arrays.asList(availableMechanims).contains(\"PLAIN\")) {\n+                  return new PlainSASLMechanism(brokerConnectConfiguration.getUser(), brokerConnectConfiguration.getPassword());\n+               } else {\n+                  return null;\n+               }\n+            };\n+         }\n+\n+         ConnectionEntry entry = protonProtocolManager.createOutgoingConnectionEntry(connection, saslFactory);\n+         protonRemotingConnection = (ActiveMQProtonRemotingConnection) entry.connection;\n+         connection.getChannel().pipeline().addLast(new AMQPBrokerConnectionChannelHandler(bridgesConnector.getChannelGroup(), protonRemotingConnection.getAmqpConnection().getHandler()));\n+\n+         protonRemotingConnection.getAmqpConnection().runLater(() -> {\n+            protonRemotingConnection.getAmqpConnection().open();\n+            protonRemotingConnection.getAmqpConnection().flush();\n+         });\n+\n+         session = protonRemotingConnection.getAmqpConnection().getHandler().getConnection().session();\n+         sessionContext = protonRemotingConnection.getAmqpConnection().getSessionExtension(session);\n+         protonRemotingConnection.getAmqpConnection().runLater(() -> {\n+            session.open();\n+            protonRemotingConnection.getAmqpConnection().flush();\n+         });\n+\n+         if (brokerConnectConfiguration.getConnectionElements() != null) {\n+            Stream<Binding> bindingStream = server.getPostOffice().getAllBindings();\n+\n+            bindingStream.forEach(binding -> {\n+               if (binding instanceof QueueBinding) {\n+                  Queue queue = ((QueueBinding) binding).getQueue();\n+                  for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+                     validateMatching(queue, connectionElement);\n+                  }\n+               }\n+            });\n+\n+            for (AMQPBrokerConnectionElement connectionElement : brokerConnectConfiguration.getConnectionElements()) {\n+               if (connectionElement.getType() == AMQPBrokerConnectionAddressType.MIRROR) {\n+                  AMQPMirrorBrokerConnectionElement replica = (AMQPMirrorBrokerConnectionElement)connectionElement;\n+                  Queue queue = server.locateQueue(replica.getSourceMirrorAddress());\n+\n+                  connectSender(queue, ProtonProtocolManager.MIRROR_ADDRESS);\n+               }\n+            }\n+         }\n+\n+         protonRemotingConnection.getAmqpConnection().flush();\n+\n+         bridgeManager.connected(connection, this);\n+      } catch (Throwable e) {\n+         error(e);\n+      }\n+   }\n+\n+   public void retryConnection() {\n+      if (bridgeManager.isStarted() && started) {\n+         if (brokerConnectConfiguration.getReconnectAttempts() < 0 || retryCounter < brokerConnectConfiguration.getReconnectAttempts()) {\n+            retryCounter++;\n+            ActiveMQAMQPProtocolLogger.LOGGER.retryConnection(brokerConnectConfiguration.getName(), host, port, retryCounter, brokerConnectConfiguration.getReconnectAttempts());\n+            if (logger.isDebugEnabled()) {\n+               logger.debug(\"Reconnecting in \" + brokerConnectConfiguration.getRetryInterval() + \", this is the \" + retryCounter + \" of \" + brokerConnectConfiguration.getReconnectAttempts());\n+            }\n+            reconnectFuture = scheduledExecutorService.schedule(() -> connectExecutor.execute(() -> doConnect()), brokerConnectConfiguration.getRetryInterval(), TimeUnit.MILLISECONDS);\n+         } else {\n+            ActiveMQAMQPProtocolLogger.LOGGER.retryConnectionFailed(brokerConnectConfiguration.getName(), host, port, retryCounter, brokerConnectConfiguration.getReconnectAttempts());\n+            if (logger.isDebugEnabled()) {\n+               logger.debug(\"no more reconnections as the retry counter reached \" + retryCounter + \" out of \" + brokerConnectConfiguration.getReconnectAttempts());\n+            }\n+         }\n+      }\n+   }\n+\n+   /** The reason this method is static is the following:\n+    *\n+    *  It is returning the snfQueue to the replica, and I needed isolation from the actual instance.\n+    *  During development I had a mistake where I used a property from the Object,\n+    *  so, I needed this isolation for my organization and making sure nothing would be shared. */\n+   private static QueueBinding installMirrorController(AMQPMirrorBrokerConnectionElement replicaConfig, ActiveMQServer server) throws Exception {\n+\n+      AddressInfo addressInfo = server.getAddressInfo(replicaConfig.getSourceMirrorAddress());\n+      if (addressInfo == null) {\n+         addressInfo = new AddressInfo(replicaConfig.getSourceMirrorAddress()).addRoutingType(RoutingType.ANYCAST).setAutoCreated(false).setTemporary(!replicaConfig.isDurable());\n+         server.addAddressInfo(addressInfo);\n+      }\n+\n+      if (addressInfo.getRoutingType() != RoutingType.ANYCAST) {\n+         throw new IllegalArgumentException(\"sourceMirrorAddress is not ANYCAST\");\n+      }\n+\n+      Queue mirrorControlQueue = server.locateQueue(replicaConfig.getSourceMirrorAddress());\n+\n+      if (mirrorControlQueue == null) {\n+         mirrorControlQueue = server.createQueue(new QueueConfiguration(replicaConfig.getSourceMirrorAddress()).setAddress(replicaConfig.getSourceMirrorAddress()).setRoutingType(RoutingType.ANYCAST).setDurable(replicaConfig.isDurable()), true);\n+      }\n+\n+      mirrorControlQueue.setMirrorController(true);\n+\n+      QueueBinding snfReplicaQueueBinding = (QueueBinding)server.getPostOffice().getBinding(replicaConfig.getSourceMirrorAddress());\n+      if (snfReplicaQueueBinding == null) {\n+         logger.warn(\"Queue does not exist even after creation! \" + replicaConfig);\n+         throw new IllegalAccessException(\"Cannot start replica\");\n+      }\n+\n+      Queue snfQueue = snfReplicaQueueBinding.getQueue();\n+\n+      if (!snfQueue.getAddress().equals(replicaConfig.getSourceMirrorAddress())) {\n+         logger.warn(\"Queue \" + snfQueue + \" belong to a different address (\" + snfQueue.getAddress() + \"), while we expected it to be \" + addressInfo.getName());\n+         throw new IllegalAccessException(\"Cannot start replica\");\n+      }\n+\n+      AMQPMirrorControllerSource newPartition = new AMQPMirrorControllerSource(snfQueue, server, replicaConfig.isMessageAcknowledgements());\n+\n+      server.scanAddresses(newPartition);\n+\n+      MirrorController currentMirrorController = server.getMirrorController();\n+\n+      if (currentMirrorController == null) {\n+         server.installMirrorController(newPartition);\n+      } else {\n+         // Replace a standard implementation by an aggregated supporting multiple targets\n+         if (currentMirrorController instanceof AMQPMirrorControllerSource) {\n+            // replacing the simple mirror control for an aggregator\n+            AMQPMirrorControllerAggregation remoteAggregation = new AMQPMirrorControllerAggregation();\n+            remoteAggregation.addPartition((AMQPMirrorControllerSource) currentMirrorController);\n+            currentMirrorController = remoteAggregation;\n+            server.installMirrorController(remoteAggregation);\n+         }\n+         ((AMQPMirrorControllerAggregation) currentMirrorController).addPartition(newPartition);\n+      }\n+\n+      return snfReplicaQueueBinding;\n+   }\n+\n+   private void connectReceiver(ActiveMQProtonRemotingConnection protonRemotingConnection,\n+                                Session session,\n+                                AMQPSessionContext sessionContext,\n+                                Queue queue,\n+                                Symbol... capabilities) {\n+      if (logger.isDebugEnabled()) {\n+         logger.debug(\"Connecting inbound for \" + queue);\n+      }\n+\n+      if (session == null) {\n+         logger.debug(\"session is null\");\n+         return;\n+      }\n+\n+      protonRemotingConnection.getAmqpConnection().runLater(() -> {\n+\n+         if (receivers.contains(queue)) {\n+            logger.debug(\"Receiver for queue \" + queue + \" already exists, just giving up\");\n+            return;\n+         }\n+         receivers.add(queue);\n+         Receiver receiver = session.receiver(queue.getName().toString() + UUIDGenerator.getInstance().generateStringUUID());\n+         receiver.setSenderSettleMode(SenderSettleMode.UNSETTLED);\n+         receiver.setReceiverSettleMode(ReceiverSettleMode.FIRST);\n+         Target target = new Target();\n+         target.setAddress(queue.getAddress().toString());\n+         receiver.setTarget(target);\n+\n+         Source source = new Source();\n+         source.setAddress(queue.getAddress().toString());\n+         receiver.setSource(source);\n+\n+         if (capabilities != null) {\n+            source.setCapabilities(capabilities);\n+         }\n+\n+         receiver.open();\n+         protonRemotingConnection.getAmqpConnection().flush();\n+         try {\n+            sessionContext.addReceiver(receiver);\n+         } catch (Exception e) {\n+            error(e);\n+         }\n+      });\n+   }\n+\n+   private void connectSender(Queue queue,\n+                              String targetName,\n+                              Symbol... capabilities) {\n+      if (logger.isDebugEnabled()) {\n+         logger.debug(\"Connecting outbound for \" + queue);\n+      }\n+\n+\n+      if (session == null) {\n+         logger.debug(\"Session is null\");\n+         return;\n+      }\n+\n+      protonRemotingConnection.getAmqpConnection().runLater(() -> {\n+         try {\n+            if (senders.contains(queue)) {\n+               logger.debug(\"Sender for queue \" + queue + \" already exists, just giving up\");\n+               return;\n+            }\n+            senders.add(queue);\n+            Sender sender = session.sender(targetName + UUIDGenerator.getInstance().generateStringUUID());", "originalCommit": "12280cdaaa313a01ade5b5cd41134a1d3b0abbb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}