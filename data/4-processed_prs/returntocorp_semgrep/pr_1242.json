{"pr_number": 1242, "pr_title": "Clara/taint analysis", "pr_createdAt": "2020-07-10T22:55:13Z", "pr_url": "https://github.com/returntocorp/semgrep/pull/1242", "timeline": [{"oid": "6c853bbe70412bb02737fb32a1557ec80aeca314", "url": "https://github.com/returntocorp/semgrep/commit/6c853bbe70412bb02737fb32a1557ec80aeca314", "message": "new test file", "committedDate": "2020-07-09T22:18:09Z", "type": "commit"}, {"oid": "6a112c05dfef038b8a832847fa06e4622aaf9de2", "url": "https://github.com/returntocorp/semgrep/commit/6a112c05dfef038b8a832847fa06e4622aaf9de2", "message": "very hacky but functonal product of call with Drew", "committedDate": "2020-07-09T22:22:06Z", "type": "commit"}, {"oid": "02208b69d6b74b56fdee64be1e66bb1aac7d4fd8", "url": "https://github.com/returntocorp/semgrep/commit/02208b69d6b74b56fdee64be1e66bb1aac7d4fd8", "message": "cleaning up rule.py for taint tracking", "committedDate": "2020-07-09T23:36:27Z", "type": "commit"}, {"oid": "582b894191b7c1bb1341ccb3e879cf649d885a6a", "url": "https://github.com/returntocorp/semgrep/commit/582b894191b7c1bb1341ccb3e879cf649d885a6a", "message": "enforcing type correctness and removing hacky write-in of python as language", "committedDate": "2020-07-10T00:33:00Z", "type": "commit"}, {"oid": "eb017d7f033bb4baa6f85374dd909a4825164f2b", "url": "https://github.com/returntocorp/semgrep/commit/eb017d7f033bb4baa6f85374dd909a4825164f2b", "message": "amend test output", "committedDate": "2020-07-10T00:33:41Z", "type": "commit"}, {"oid": "7dbdf7ed08c02ffcdaebb8d655d82ed965ae1737", "url": "https://github.com/returntocorp/semgrep/commit/7dbdf7ed08c02ffcdaebb8d655d82ed965ae1737", "message": "Update test files for taint analysis", "committedDate": "2020-07-10T00:46:12Z", "type": "commit"}, {"oid": "f26b18e73fdd3bd9f959ebc8942a4b24e42bfb72", "url": "https://github.com/returntocorp/semgrep/commit/f26b18e73fdd3bd9f959ebc8942a4b24e42bfb72", "message": "Update test files for taint analysis again", "committedDate": "2020-07-10T00:47:29Z", "type": "commit"}, {"oid": "c50b021319d79daa669c622eac9567d6ac9a28ea", "url": "https://github.com/returntocorp/semgrep/commit/c50b021319d79daa669c622eac9567d6ac9a28ea", "message": "decompose redundant code between search and taint-analysis rules", "committedDate": "2020-07-10T20:51:18Z", "type": "commit"}, {"oid": "3b74d401d90eaddbb8f079d7258a0bbebdd511e8", "url": "https://github.com/returntocorp/semgrep/commit/3b74d401d90eaddbb8f079d7258a0bbebdd511e8", "message": "fix pattern span typing for taint-analysis", "committedDate": "2020-07-10T21:57:27Z", "type": "commit"}, {"oid": "a6af09ad9f4064ed72e117dc2c6576112778122e", "url": "https://github.com/returntocorp/semgrep/commit/a6af09ad9f4064ed72e117dc2c6576112778122e", "message": "remove pdb calls... and write a rule for it\n\n'", "committedDate": "2020-07-10T22:09:41Z", "type": "commit"}, {"oid": "05f95a518083aad169a8209ad6899c4534603021", "url": "https://github.com/returntocorp/semgrep/commit/05f95a518083aad169a8209ad6899c4534603021", "message": "streamline pattern list-ifying", "committedDate": "2020-07-10T22:43:17Z", "type": "commit"}, {"oid": "d1e84af8f910cd8c4b3ffc9773b7bb5644b22c64", "url": "https://github.com/returntocorp/semgrep/commit/d1e84af8f910cd8c4b3ffc9773b7bb5644b22c64", "message": "remove pdb call for debugging", "committedDate": "2020-07-10T22:45:06Z", "type": "commit"}, {"oid": "37fcd41817127de87af16a04b659b2a80726f6fa", "url": "https://github.com/returntocorp/semgrep/commit/37fcd41817127de87af16a04b659b2a80726f6fa", "message": "Merge branch 'develop' into clara/taint-analysis", "committedDate": "2020-07-11T01:25:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc2OTU5NA==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r453769594", "bodyText": "FWIW, I'd probably s/track/taint here for specificity", "author": "nbrahms", "createdAt": "2020-07-13T16:19:10Z", "path": "semgrep-core/data/basic_tainting.yml", "diffHunk": "@@ -1,5 +1,6 @@\n rules:\n   - id: classic\n+    mode: track", "originalCommit": "37fcd41817127de87af16a04b659b2a80726f6fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2NTIzMQ==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r453965231", "bodyText": "what does s/track/taint mean? something like track-mode: True where track-mode: False is the default?", "author": "chmccreery", "createdAt": "2020-07-13T22:05:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc2OTU5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAzMTc0NA==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454031744", "bodyText": "Oohh just swap the words \ud83e\udd26\u200d\u2640\ufe0f  yes will do", "author": "chmccreery", "createdAt": "2020-07-14T00:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc2OTU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc2OTg0MA==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r453769840", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                languages: [python, python]\n          \n          \n            \n                languages: [python]", "author": "nbrahms", "createdAt": "2020-07-13T16:19:33Z", "path": "semgrep-core/data/basic_tainting.yml", "diffHunk": "@@ -11,5 +12,18 @@ rules:\n       - sanitize(...)\n       - sanitize1(...)\n     message: A user input source() went into a dangerous sink()\n+    languages: [python, python]", "originalCommit": "37fcd41817127de87af16a04b659b2a80726f6fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc3MTE3NQ==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r453771175", "bodyText": "I'd probably make this an enum instead of a str to avoid future potential bugs.", "author": "nbrahms", "createdAt": "2020-07-13T16:21:44Z", "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -217,6 +217,72 @@ def _write_equivalences_file(self, fp: IO, equivalences: List[Equivalence]) -> N\n         yaml.dump({\"equivalences\": [e.to_json() for e in equivalences]}, fp)\n         fp.flush()\n \n+    def _run_core_command(\n+        self,\n+        patterns_json: List[Any],\n+        patterns: List[Pattern],\n+        targets: List[Path],\n+        language: Language,\n+        rule: Rule,\n+        rules_flag: str,", "originalCommit": "37fcd41817127de87af16a04b659b2a80726f6fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA1MjA4NQ==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454052085", "bodyText": "Like this? https://docs.python.org/3.4/library/enum.html\nSo it would be of type Mode and would evaluate to search = 1 and taint = 2 or something like that?", "author": "chmccreery", "createdAt": "2020-07-14T01:58:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc3MTE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1NzQ3MQ==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454657471", "bodyText": "I think enum is the wrong word for me to use.\nI mean this:\nMode = NewType(\"Mode\", str)\n\nSearchMode = Mode(\"search\")\nTaintMode = Mode(\"taint\")", "author": "nbrahms", "createdAt": "2020-07-14T21:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc3MTE3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwMzg4MA==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454703880", "bodyText": "done", "author": "chmccreery", "createdAt": "2020-07-14T23:33:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc3MTE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc3MTkxMA==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r453771910", "bodyText": "This function is probably complex enough that we want to subfunction it.\nI can show you a fun PyCharm-fu to automate this.", "author": "nbrahms", "createdAt": "2020-07-13T16:22:51Z", "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -225,111 +291,93 @@ def _run_rule(\n         \"\"\"\n         outputs: List[PatternMatch] = []  # multiple invocations per language\n         errors: List[CoreException] = []\n-        equivalences = rule.equivalences\n \n-        for language, all_patterns_for_language in self._group_patterns_by_language(\n-            [rule]\n-        ).items():\n-            try:\n+        if rule._mode == \"track\":\n+            for language in rule._languages:\n                 targets = target_manager.get_files(\n                     language, rule.includes, rule.excludes\n                 )\n-            except _UnknownLanguageError as ex:\n-                raise UnknownLanguageError(\n-                    short_msg=\"invalid language\",\n-                    long_msg=f\"unsupported language {language}\",\n-                    spans=[rule.languages_span.with_context(before=1, after=1)],\n-                ) from ex\n-\n-            if targets == []:\n-                continue\n-\n-            # semgrep-core doesn't know about OPERATORS.REGEX - this is\n-            # strictly a semgrep Python feature. Regex filtering is\n-            # performed purely in Python code then compared against\n-            # semgrep-core's results for other patterns.\n-            patterns_regex, patterns = partition(\n-                lambda p: p.expression.operator == OPERATORS.REGEX,\n-                all_patterns_for_language,\n-            )\n-            if patterns_regex:\n-                patterns_json = [pattern.to_json() for pattern in patterns_regex]\n-\n-                try:\n-                    patterns_re = [\n-                        (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n-                        for pattern in patterns_json\n-                    ]\n-                except re.error as err:\n-                    raise SemgrepError(f\"invalid regular expression specified: {err}\")\n-\n-                re_fn = functools.partial(get_re_matches, patterns_re)\n-                with multiprocessing.Pool(self._jobs) as pool:\n-                    matches = pool.map(re_fn, targets)\n-\n-                outputs.extend(\n-                    single_match\n-                    for file_matches in matches\n-                    for single_match in file_matches\n+                pattern_json = rule._raw.copy()\n+                del pattern_json[\"mode\"]\n+                pattern = Pattern(\n+                    0, rule.expression, rule.severity, language, rule._yaml.span\n                 )\n \n-            patterns_json = [p.to_json() for p in patterns]\n-            with tempfile.NamedTemporaryFile(\n-                \"w\"\n-            ) as pattern_file, tempfile.NamedTemporaryFile(\n-                \"w\"\n-            ) as target_file, tempfile.NamedTemporaryFile(\n-                \"w\"\n-            ) as equiv_file:\n-                yaml = YAML()\n-                yaml.dump({\"rules\": patterns_json}, pattern_file)\n-                pattern_file.flush()\n-                target_file.write(\"\\n\".join(str(t) for t in targets))\n-                target_file.flush()\n-\n-                cmd = [SEMGREP_PATH] + [\n-                    \"-lang\",\n+                output_json = self._run_core_command(\n+                    [pattern_json],\n+                    [pattern],\n+                    targets,\n                     language,\n-                    \"-rules_file\",\n-                    pattern_file.name,\n-                    \"-j\",\n-                    str(self._jobs),\n-                    \"-target_file\",\n-                    target_file.name,\n-                    \"-use_parsing_cache\",\n+                    rule,\n+                    \"-tainting_rules_file\",\n                     cache_dir,\n-                ]\n-\n-                if equivalences:\n-                    self._write_equivalences_file(equiv_file, equivalences)\n-                    cmd += [\"-equivalences\", equiv_file.name]\n+                )\n \n-                core_run = sub_run(cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)\n+        else:\n+            for language, all_patterns_for_language in self._group_patterns_by_language(", "originalCommit": "37fcd41817127de87af16a04b659b2a80726f6fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc3MjYxNA==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r453772614", "bodyText": "We probably want to be consistent with the _mode comparisons, so we have a consistent fallback mode.", "author": "nbrahms", "createdAt": "2020-07-13T16:23:56Z", "path": "semgrep/semgrep/evaluation.py", "diffHunk": "@@ -207,16 +207,21 @@ def evaluate(\n         }\n     ]\n     debug_print(str(pattern_ids_to_pattern_matches))\n-    valid_ranges_to_output = evaluate_expression(\n-        rule.expression,\n-        pattern_ids_to_pattern_matches,\n-        flags={RCE_RULE_FLAG: allow_exec},\n-        steps_for_debugging=steps_for_debugging,\n-    )\n+    if rule._mode == \"search\":", "originalCommit": "37fcd41817127de87af16a04b659b2a80726f6fa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkyNTE5MQ==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r453925191", "bodyText": "good point- just fixed this", "author": "chmccreery", "createdAt": "2020-07-13T20:51:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc3MjYxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc3MzQ4NQ==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r453773485", "bodyText": "I'm guessing we can probably simplify this logic with the above. Happy to hack through it with you.", "author": "nbrahms", "createdAt": "2020-07-13T16:25:19Z", "path": "semgrep/semgrep/semgrep_main.py", "diffHunk": "@@ -61,8 +61,18 @@ def validate_single_rule(\n             + [e.span for e in extra_key_spans],\n             help=help_msg,\n         )\n-\n-    # Raises InvalidRuleSchemaError if fails to parse\n+    else:", "originalCommit": "37fcd41817127de87af16a04b659b2a80726f6fa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0bdead3741b6544201eddcf41153c10dde207645", "url": "https://github.com/returntocorp/semgrep/commit/0bdead3741b6544201eddcf41153c10dde207645", "message": "Merge branch 'develop' into clara/taint-analysis", "committedDate": "2020-07-13T17:24:43Z", "type": "commit"}, {"oid": "524c0b2d0cb88099332e770e47030cf2f644dd3c", "url": "https://github.com/returntocorp/semgrep/commit/524c0b2d0cb88099332e770e47030cf2f644dd3c", "message": "fix indentation bug from refactoring (adding errors to nonexistent dictionary)", "committedDate": "2020-07-13T17:55:03Z", "type": "commit"}, {"oid": "da3e8a9131fcba50a0a18ce74b068cd998ae821d", "url": "https://github.com/returntocorp/semgrep/commit/da3e8a9131fcba50a0a18ce74b068cd998ae821d", "message": "Merge branch 'clara/taint-analysis' of github.com:returntocorp/semgrep into clara/taint-analysis", "committedDate": "2020-07-13T17:55:37Z", "type": "commit"}, {"oid": "b6e05a3fffacf19c7948566eb59d67ee30f88c8c", "url": "https://github.com/returntocorp/semgrep/commit/b6e05a3fffacf19c7948566eb59d67ee30f88c8c", "message": "update error message to include track/search differences", "committedDate": "2020-07-13T20:50:58Z", "type": "commit"}, {"oid": "1312428bdd848dee0c04014d3582f7c9ef3ac1b2", "url": "https://github.com/returntocorp/semgrep/commit/1312428bdd848dee0c04014d3582f7c9ef3ac1b2", "message": "make fallback behavior consistent with default mode", "committedDate": "2020-07-13T20:51:29Z", "type": "commit"}, {"oid": "e7710ea56902c4fce57c2468a744e8f844e70da5", "url": "https://github.com/returntocorp/semgrep/commit/e7710ea56902c4fce57c2468a744e8f844e70da5", "message": "fix languages with no files bug", "committedDate": "2020-07-14T00:24:04Z", "type": "commit"}, {"oid": "ec9c1ed5d2ef3ece6fe179caaadc0606f439d5fc", "url": "https://github.com/returntocorp/semgrep/commit/ec9c1ed5d2ef3ece6fe179caaadc0606f439d5fc", "message": "flatten logic for error messages based on extra/missing keys", "committedDate": "2020-07-14T00:51:44Z", "type": "commit"}, {"oid": "c1249446262fb4cbf49073ebcf48f09bbd4c16fd", "url": "https://github.com/returntocorp/semgrep/commit/c1249446262fb4cbf49073ebcf48f09bbd4c16fd", "message": "change mode: track to mode: taint and avoid parallel paths for taint tracking and search mode", "committedDate": "2020-07-14T01:54:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU2ODI2NA==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454568264", "bodyText": "[0] always makes me nervous because what if rules is empty or there are mixed rules and you only consider the first case. I would generally tend to use map, filter, partition logic here.", "author": "DrewDennison", "createdAt": "2020-07-14T18:45:03Z", "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -150,11 +150,16 @@ def _flatten_rule_patterns(self, rules: List[Rule]) -> Iterator[Pattern]:\n     def _group_patterns_by_language(\n         self, rules: List[Rule]\n     ) -> Dict[Language, List[Pattern]]:\n-        # a rule can have multiple patterns inside it. Flatten these so we can send semgrep a single yml file list of patterns\n-        patterns: List[Pattern] = list(self._flatten_rule_patterns(rules))\n+\n         by_lang: Dict[Language, List[Pattern]] = collections.defaultdict(list)\n-        for pattern in patterns:\n-            by_lang[pattern.language].append(pattern)\n+        if rules[0]._mode == \"taint\":", "originalCommit": "c1249446262fb4cbf49073ebcf48f09bbd4c16fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwNDE1NA==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454704154", "bodyText": "re-factored it so this isn't even a list (it was always [rule] before, and doesn't need to become a list until later)", "author": "chmccreery", "createdAt": "2020-07-14T23:33:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU2ODI2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU2ODk3MA==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454568970", "bodyText": "do we also support metadata?", "author": "DrewDennison", "createdAt": "2020-07-14T18:46:13Z", "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -225,111 +296,58 @@ def _run_rule(\n         \"\"\"\n         outputs: List[PatternMatch] = []  # multiple invocations per language\n         errors: List[CoreException] = []\n-        equivalences = rule.equivalences\n \n         for language, all_patterns_for_language in self._group_patterns_by_language(\n             [rule]\n         ).items():\n-            try:\n-                targets = target_manager.get_files(\n-                    language, rule.includes, rule.excludes\n-                )\n-            except _UnknownLanguageError as ex:\n-                raise UnknownLanguageError(\n-                    short_msg=\"invalid language\",\n-                    long_msg=f\"unsupported language {language}\",\n-                    spans=[rule.languages_span.with_context(before=1, after=1)],\n-                ) from ex\n \n+            targets = self.get_files_for_language(language, rule, target_manager)\n             if targets == []:\n                 continue\n \n-            # semgrep-core doesn't know about OPERATORS.REGEX - this is\n-            # strictly a semgrep Python feature. Regex filtering is\n-            # performed purely in Python code then compared against\n-            # semgrep-core's results for other patterns.\n-            patterns_regex, patterns = partition(\n-                lambda p: p.expression.operator == OPERATORS.REGEX,\n-                all_patterns_for_language,\n-            )\n-            if patterns_regex:\n-                patterns_json = [pattern.to_json() for pattern in patterns_regex]\n+            if rule._mode == \"taint\":\n+                pattern_json = rule._raw.copy()\n+                del pattern_json[\"mode\"]", "originalCommit": "c1249446262fb4cbf49073ebcf48f09bbd4c16fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxNDY0Ng==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454714646", "bodyText": "There's an auxiliary metadata field outside of patterns, which I assume is what Drew is referring to?", "author": "nbrahms", "createdAt": "2020-07-15T00:08:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU2ODk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0MTI0OA==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454741248", "bodyText": "Ah, great! I just added a check for this to say it isn't supported", "author": "chmccreery", "createdAt": "2020-07-15T01:45:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU2ODk3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU2OTE1MA==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454569150", "bodyText": "make a constant?", "author": "DrewDennison", "createdAt": "2020-07-14T18:46:35Z", "path": "semgrep/semgrep/evaluation.py", "diffHunk": "@@ -207,16 +207,21 @@ def evaluate(\n         }\n     ]\n     debug_print(str(pattern_ids_to_pattern_matches))\n-    valid_ranges_to_output = evaluate_expression(\n-        rule.expression,\n-        pattern_ids_to_pattern_matches,\n-        flags={RCE_RULE_FLAG: allow_exec},\n-        steps_for_debugging=steps_for_debugging,\n-    )\n+    if rule._mode == \"track\":", "originalCommit": "c1249446262fb4cbf49073ebcf48f09bbd4c16fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwMzQ1MQ==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454703451", "bodyText": "done", "author": "chmccreery", "createdAt": "2020-07-14T23:31:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU2OTE1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU2OTM4OA==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454569388", "bodyText": "make mode a constant?", "author": "DrewDennison", "createdAt": "2020-07-14T18:47:01Z", "path": "semgrep/semgrep/rule.py", "diffHunk": "@@ -65,7 +67,33 @@ def __init__(self, raw: YamlTree[YamlMap]) -> None:\n         self._includes = path_dict.get(\"include\", [])\n         self._excludes = path_dict.get(\"exclude\", [])\n         self._languages = [Language(l) for l in self._raw[\"languages\"]]\n-        self._expression = self._build_boolean_expression(self._yaml)\n+\n+        # check taint/search mode\n+        self._expression, mode = self._taint_or_search_patterns_validation(self._yaml)\n+        self._mode = mode\n+\n+    def _taint_or_search_patterns_validation(\n+        self, rule: YamlTree[YamlMap]\n+    ) -> Tuple[BooleanRuleExpression, str]:\n+\n+        rule_raw = rule.value\n+        _mode = rule_raw.get(\"mode\")", "originalCommit": "c1249446262fb4cbf49073ebcf48f09bbd4c16fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcwMzU3MA==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454703570", "bodyText": "done", "author": "chmccreery", "createdAt": "2020-07-14T23:32:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU2OTM4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1NjQ0MQ==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454656441", "bodyText": "I assume you don't want to comment changes to this file?", "author": "nbrahms", "createdAt": "2020-07-14T21:29:00Z", "path": ".pre-commit-config.yaml", "diffHunk": "@@ -40,32 +40,32 @@ repos:\n         additional_dependencies: [\"flake8-bugbear==20.1.4\"]\n         args: [\"--select=B,E9,F63,F7,F82\"]\n \n-  - repo: https://github.com/returntocorp/semgrep\n-    rev: 'v0.12.0'\n-    hooks:\n-      - id: semgrep-develop\n-        name: Semgrep Python\n-        types: [python]\n-        exclude: \"^semgrep/tests/.+$|^install-scripts/.+$|^release-scripts/.+$|^semgrep/setup.py$\"\n-        args: ['--config', 'https://semgrep.live/p/python', '--error']\n+  # - repo: https://github.com/returntocorp/semgrep", "originalCommit": "c1249446262fb4cbf49073ebcf48f09bbd4c16fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY3MzExMw==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454673113", "bodyText": "Oh yeah, we just changed this so that it would run on my machine, right? Or should I delete the commented-out pieces and commit the change? I guess I didn't understand what the impact of this was/if it was supposed to be pushed up", "author": "chmccreery", "createdAt": "2020-07-14T22:06:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1NjQ0MQ=="}], "type": "inlineReview"}, {"oid": "bb2dd4c6ff970626d12be5dc35df6ec393335e61", "url": "https://github.com/returntocorp/semgrep/commit/bb2dd4c6ff970626d12be5dc35df6ec393335e61", "message": "fix s/track/taint", "committedDate": "2020-07-14T21:46:51Z", "type": "commit"}, {"oid": "a512e1eca530dce1ecc0b4270b4b7ce5f2b50dfe", "url": "https://github.com/returntocorp/semgrep/commit/a512e1eca530dce1ecc0b4270b4b7ce5f2b50dfe", "message": "define NewType for Mode and declare constants and valid set", "committedDate": "2020-07-14T23:19:14Z", "type": "commit"}, {"oid": "85a1df6dce07a3dc4226b29d748c878126cd0b11", "url": "https://github.com/returntocorp/semgrep/commit/85a1df6dce07a3dc4226b29d748c878126cd0b11", "message": "get rid of unnecessary list of 1 rule notation", "committedDate": "2020-07-14T23:29:01Z", "type": "commit"}, {"oid": "0349ba8ed91a2d0b4974f8ede7e62ed6b700fb9f", "url": "https://github.com/returntocorp/semgrep/commit/0349ba8ed91a2d0b4974f8ede7e62ed6b700fb9f", "message": "Merge branch 'develop' into clara/taint-analysis", "committedDate": "2020-07-14T23:46:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxNTY4OQ==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454715689", "bodyText": "\ud83d\udc4d", "author": "nbrahms", "createdAt": "2020-07-15T00:11:53Z", "path": "semgrep/semgrep/semgrep_main.py", "diffHunk": "@@ -46,23 +46,37 @@ def validate_single_rule(\n     rule: YamlMap = rule_yaml.value\n \n     rule_keys = set({k.value for k in rule.keys()})\n-    if not rule_keys.issuperset(YAML_MUST_HAVE_KEYS):\n-        missing_keys = YAML_MUST_HAVE_KEYS - rule_keys\n-\n-        extra_keys: Set[str] = rule_keys - YAML_ALL_VALID_RULE_KEYS\n-        extra_key_spans = sorted([rule.key_tree(k) for k in extra_keys])\n-        help_msg = None\n-        if extra_keys:\n-            help_msg = f\"Unexpected keys {extra_keys} found. Is one of these a typo of {missing_keys}?\"\n+    extra_keys = rule_keys - YAML_ALL_VALID_RULE_KEYS\n+    extra_key_spans = sorted([rule.key_tree(k) for k in extra_keys])\n+    missing_keys = YAML_MUST_HAVE_KEYS - rule_keys\n+\n+    if missing_keys and extra_keys:", "originalCommit": "0349ba8ed91a2d0b4974f8ede7e62ed6b700fb9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxODkwNQ==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454718905", "bodyText": "\ud83d\ude04", "author": "chmccreery", "createdAt": "2020-07-15T00:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxNTY4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxNjA0Mw==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454716043", "bodyText": "nit:\nYAML_TAINT_KEYS = YAML_TAINT_MUST_HAVE_KEYS | { \"pattern-sanitizers\" }", "author": "nbrahms", "createdAt": "2020-07-15T00:13:08Z", "path": "semgrep/semgrep/semgrep_types.py", "diffHunk": "@@ -57,14 +64,18 @@ class OPERATORS:\n     OPERATORS.EQUIVALENCES,\n     OPERATORS.REGEX,\n }\n+YAML_TOP_LEVEL_PATTERN_KEYS = {\n+    pattern_name\n+    for op in YAML_VALID_TOP_LEVEL_OPERATORS\n+    for pattern_name in OPERATOR_PATTERN_NAMES_MAP[op]\n+}\n+YAML_TAINT_KEYS = {\"pattern-sinks\", \"pattern-sources\", \"pattern-sanitizers\"}", "originalCommit": "0349ba8ed91a2d0b4974f8ede7e62ed6b700fb9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxNjMwMA==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454716300", "bodyText": "You can just use rule_raw.get(\"mode\", DEFAULT_MODE) here, and remove a case below.", "author": "nbrahms", "createdAt": "2020-07-15T00:14:09Z", "path": "semgrep/semgrep/rule.py", "diffHunk": "@@ -65,7 +72,35 @@ def __init__(self, raw: YamlTree[YamlMap]) -> None:\n         self._includes = path_dict.get(\"include\", [])\n         self._excludes = path_dict.get(\"exclude\", [])\n         self._languages = [Language(l) for l in self._raw[\"languages\"]]\n-        self._expression = self._build_boolean_expression(self._yaml)\n+\n+        # check taint/search mode\n+        self._expression, self._mode = self._taint_or_search_patterns_validation(\n+            self._yaml\n+        )\n+\n+    def _taint_or_search_patterns_validation(\n+        self, rule: YamlTree[YamlMap]\n+    ) -> Tuple[BooleanRuleExpression, Mode]:\n+\n+        rule_raw = rule.value\n+        _mode = rule_raw.get(\"mode\")", "originalCommit": "0349ba8ed91a2d0b4974f8ede7e62ed6b700fb9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcyMTc4NQ==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454721785", "bodyText": "It won't let me put more than 1 arg into get() because rule_raw is a YamlMap object, not a dictionary. Do you have another idea? This approach would be cleaner...", "author": "chmccreery", "createdAt": "2020-07-15T00:34:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxNjMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0MTYwMw==", "url": "https://github.com/returntocorp/semgrep/pull/1242#discussion_r454741603", "bodyText": "It didn't like the \"or\" approach either, so I went with a ternary, which has a similar effect wrt code structure and complexity", "author": "chmccreery", "createdAt": "2020-07-15T01:47:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcxNjMwMA=="}], "type": "inlineReview"}, {"oid": "0e104be318329bf5a674c9def669220fe5bd962e", "url": "https://github.com/returntocorp/semgrep/commit/0e104be318329bf5a674c9def669220fe5bd962e", "message": "fixing stylistic nit", "committedDate": "2020-07-15T00:45:39Z", "type": "commit"}, {"oid": "1f49f291a629dc35f5f1eaa6f94b0de53ee5cb75", "url": "https://github.com/returntocorp/semgrep/commit/1f49f291a629dc35f5f1eaa6f94b0de53ee5cb75", "message": "simplifying logic in taint_or_search_patterns", "committedDate": "2020-07-15T01:18:52Z", "type": "commit"}, {"oid": "a94cd7293eb992f0b9110ca25df92981cf732e26", "url": "https://github.com/returntocorp/semgrep/commit/a94cd7293eb992f0b9110ca25df92981cf732e26", "message": "add check for unsupported metadata in taint-tracking mode", "committedDate": "2020-07-15T01:43:05Z", "type": "commit"}]}