{"pr_number": 1481, "pr_title": "Match against destructured parameters with metavariables in js", "pr_createdAt": "2020-08-10T23:18:07Z", "pr_url": "https://github.com/returntocorp/semgrep/pull/1481", "timeline": [{"oid": "077b799f03753d8221f0c1d6f662105aa02ef049", "url": "https://github.com/returntocorp/semgrep/commit/077b799f03753d8221f0c1d6f662105aa02ef049", "message": "Match against destructured parameters with metavariables in js\n\nPreviously, we could not match these, as we could not reuse the symbol\nin\n\n  let $FOO = arg.$FOO\n\nwhen matching\n\n  let foo = arg.foo\n\nHere we add the ability to match pure identifier nodes against\nidentifier expressions, allowing this match.\n\nFixes #1005.", "committedDate": "2020-08-10T23:17:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzNzQwNQ==", "url": "https://github.com/returntocorp/semgrep/pull/1481#discussion_r468237405", "bodyText": "Note that I also print debugging information even when the two node types differ.", "author": "nbrahms", "createdAt": "2020-08-10T23:18:57Z", "path": "semgrep-core/matching/Matching_generic.ml", "diffHunk": "@@ -218,16 +218,22 @@ let equal_ast_binded_code (a: AST.any) (b: AST.any) : bool =\n        *)\n       let a = Lib.abstract_position_info_any a in\n       let b = Lib.abstract_position_info_any b in\n-      let res = a =*= b in\n-      if !Flag.debug_matching && not res\n-      then begin\n-        pr2 (spf \"A = %s\" (str_of_any a));\n-        pr2 (spf \"B = %s\" (str_of_any b));\n-      end;\n-      res\n-\n+      a =*= b\n+  | A.I _, A.E (A.Id (b_id, _)) ->\n+    (* Allow identifier nodes to match pure identifier expressions *)\n+      equal_ast_binded_code a (A.I b_id)\n   | _, _ ->\n       false\n+  ) in\n+\n+  if !Flag.debug_matching && not res\n+  then begin", "originalCommit": "077b799f03753d8221f0c1d6f662105aa02ef049", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIzODI4Mw==", "url": "https://github.com/returntocorp/semgrep/pull/1481#discussion_r468238283", "bodyText": "This isn't tail recursive, but it only ever gets to a stack depth of 2, so \ud83e\udd37", "author": "nbrahms", "createdAt": "2020-08-10T23:21:47Z", "path": "semgrep-core/matching/Matching_generic.ml", "diffHunk": "@@ -198,8 +198,8 @@ let (fail : tin -> tout) = fun _tin ->\n (* pre: both 'a' and 'b' contains only regular code; there are no\n  * metavariables inside them.\n  *)\n-let equal_ast_binded_code (a: AST.any) (b: AST.any) : bool =\n-  match a, b with\n+let rec equal_ast_binded_code (a: AST.any) (b: AST.any) : bool = (", "originalCommit": "077b799f03753d8221f0c1d6f662105aa02ef049", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f21873269c36ed0b2fdb78893d056724ffcb9125", "url": "https://github.com/returntocorp/semgrep/commit/f21873269c36ed0b2fdb78893d056724ffcb9125", "message": "fixup! Match against destructured parameters with metavariables in js", "committedDate": "2020-08-10T23:23:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY4OTAyOA==", "url": "https://github.com/returntocorp/semgrep/pull/1481#discussion_r468689028", "bodyText": "@aryx @mjambon I'm open to suggestions on how to do this better :)", "author": "nbrahms", "createdAt": "2020-08-11T15:56:26Z", "path": "semgrep-core/matching/Matching_generic.ml", "diffHunk": "@@ -218,16 +218,22 @@ let equal_ast_binded_code (a: AST.any) (b: AST.any) : bool =\n        *)\n       let a = Lib.abstract_position_info_any a in\n       let b = Lib.abstract_position_info_any b in\n-      let res = a =*= b in\n-      if !Flag.debug_matching && not res\n-      then begin\n-        pr2 (spf \"A = %s\" (str_of_any a));\n-        pr2 (spf \"B = %s\" (str_of_any b));\n-      end;\n-      res\n-\n+      a =*= b\n+  | A.I _, A.E (A.Id (b_id, _)) ->", "originalCommit": "f21873269c36ed0b2fdb78893d056724ffcb9125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ0OTc5Mw==", "url": "https://github.com/returntocorp/semgrep/pull/1481#discussion_r471449793", "bodyText": "We might need also to handle the symetric pattern\nA.E (A.ID (a_id, _)), A.I _", "author": "aryx", "createdAt": "2020-08-17T12:39:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY4OTAyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ1MjYxMA==", "url": "https://github.com/returntocorp/semgrep/pull/1481#discussion_r471452610", "bodyText": "Maybe add a comment such as\n\"you should prefer to add metavar as expression (A.E), not id (A.I), see Generic_vs_generic.m_ident_and_id_info_add_in_env_Expr  but in some cases you have no choice\nand you need to match an expression metavar with an id metavar.\nFor example, we want the pattern 'const $X = foo.$X'  to match 'const bar = foo.bar' (this is useful in the Javascript transpilation context of complex pattern parameter).\"", "author": "aryx", "createdAt": "2020-08-17T12:44:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY4OTAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ1MDI2OA==", "url": "https://github.com/returntocorp/semgrep/pull/1481#discussion_r471450268", "bodyText": "I would also add the simpler  const $X = foo.$X; more obvious testcase.", "author": "aryx", "createdAt": "2020-08-17T12:40:19Z", "path": "semgrep-core/tests/js/misc_destructuring_2.sgrep", "diffHunk": "@@ -0,0 +1,3 @@\n+function $F ({$FOO}, ...) {", "originalCommit": "f21873269c36ed0b2fdb78893d056724ffcb9125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTYxNzg3NA==", "url": "https://github.com/returntocorp/semgrep/pull/1481#discussion_r471617874", "bodyText": "Oddly enough you can not write this pattern \ud83e\udd37", "author": "nbrahms", "createdAt": "2020-08-17T17:04:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ1MDI2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTYxOTkyMw==", "url": "https://github.com/returntocorp/semgrep/pull/1481#discussion_r471619923", "bodyText": "Apparently you can only write this pattern via transpilation from destructuring; it can not be parsed directly.", "author": "nbrahms", "createdAt": "2020-08-17T17:06:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQ1MDI2OA=="}], "type": "inlineReview"}, {"oid": "75702ae8f5d49f94d505c2334aa4dfdb59f11d84", "url": "https://github.com/returntocorp/semgrep/commit/75702ae8f5d49f94d505c2334aa4dfdb59f11d84", "message": "fixup! Match against destructured parameters with metavariables in js", "committedDate": "2020-08-17T17:05:00Z", "type": "commit"}]}