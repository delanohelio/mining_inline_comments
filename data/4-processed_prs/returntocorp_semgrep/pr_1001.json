{"pr_number": 1001, "pr_title": "core_runner: pass targets using -target_file instead of as list", "pr_createdAt": "2020-06-13T01:19:35Z", "pr_url": "https://github.com/returntocorp/semgrep/pull/1001", "timeline": [{"oid": "7a1fe03d5df64b072725a64e2e1f24e658437a57", "url": "https://github.com/returntocorp/semgrep/commit/7a1fe03d5df64b072725a64e2e1f24e658437a57", "message": "core_runner: pass targets using -target_file instead of as list\n\nPassing as a list to subprocess will potentially hit command line\ncharacter limits. This bypasses the limit by using semgrep-core's\ntarget_file option.", "committedDate": "2020-06-13T02:11:48Z", "type": "commit"}, {"oid": "7a1fe03d5df64b072725a64e2e1f24e658437a57", "url": "https://github.com/returntocorp/semgrep/commit/7a1fe03d5df64b072725a64e2e1f24e658437a57", "message": "core_runner: pass targets using -target_file instead of as list\n\nPassing as a list to subprocess will potentially hit command line\ncharacter limits. This bypasses the limit by using semgrep-core's\ntarget_file option.", "committedDate": "2020-06-13T02:11:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyOTcwMw==", "url": "https://github.com/returntocorp/semgrep/pull/1001#discussion_r440329703", "bodyText": "Most of this diff is deindenting", "author": "brendongo", "createdAt": "2020-06-15T17:21:38Z", "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -199,99 +199,98 @@ def _run_rule(\n         outputs: List[PatternMatch] = []  # multiple invocations per language\n         errors: List[Any] = []\n         equivalences = rule.equivalences\n-        with tempfile.NamedTemporaryFile(\"w\") as equiv_fout:\n \n-            if equivalences:\n-                self._write_equivalences_file(equiv_fout, equivalences)\n+        for language, all_patterns_for_language in self._group_patterns_by_language(", "originalCommit": "7a1fe03d5df64b072725a64e2e1f24e658437a57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzNzg0OA==", "url": "https://github.com/returntocorp/semgrep/pull/1001#discussion_r440337848", "bodyText": "Hah nice, these loops were getting a bit unwieldy.", "author": "mschwager", "createdAt": "2020-06-15T17:36:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMyOTcwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzODE3Mg==", "url": "https://github.com/returntocorp/semgrep/pull/1001#discussion_r440338172", "bodyText": "I think we can remove this comment at this point. I'm assuming we're good here since we moved to ruamel instead of yaml.", "author": "mschwager", "createdAt": "2020-06-15T17:37:09Z", "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -199,99 +199,98 @@ def _run_rule(\n         outputs: List[PatternMatch] = []  # multiple invocations per language\n         errors: List[Any] = []\n         equivalences = rule.equivalences\n-        with tempfile.NamedTemporaryFile(\"w\") as equiv_fout:\n \n-            if equivalences:\n-                self._write_equivalences_file(equiv_fout, equivalences)\n+        for language, all_patterns_for_language in self._group_patterns_by_language(\n+            [rule]\n+        ).items():\n+            targets = target_manager.get_files(language, rule.includes, rule.excludes)\n+            if targets == []:\n+                continue\n+\n+            # semgrep-core doesn't know about OPERATORS.REGEX - this is\n+            # strictly a semgrep Python feature. Regex filtering is\n+            # performed purely in Python code then compared against\n+            # semgrep-core's results for other patterns.\n+            patterns_regex, patterns = partition(\n+                lambda p: p.expression.operator == OPERATORS.REGEX,\n+                all_patterns_for_language,\n+            )\n+            if patterns_regex:\n+                patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-            for language, all_patterns_for_language in self._group_patterns_by_language(\n-                [rule]\n-            ).items():\n-                targets = target_manager.get_files(\n-                    language, rule.includes, rule.excludes\n-                )\n-                if targets == []:\n-                    continue\n+                try:\n+                    patterns_re = [\n+                        (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n+                        for pattern in patterns_json\n+                    ]\n+                except re.error as err:\n+                    raise SemgrepError(f\"invalid regular expression specified: {err}\")\n \n-                # semgrep-core doesn't know about OPERATORS.REGEX - this is\n-                # strictly a semgrep Python feature. Regex filtering is\n-                # performed purely in Python code then compared against\n-                # semgrep-core's results for other patterns.\n-                patterns_regex, patterns = partition(\n-                    lambda p: p.expression.operator == OPERATORS.REGEX,\n-                    all_patterns_for_language,\n+                re_fn = functools.partial(get_re_matches, patterns_re)\n+                with multiprocessing.Pool(self._jobs) as pool:\n+                    matches = pool.map(re_fn, targets)\n+\n+                outputs.extend(\n+                    single_match\n+                    for file_matches in matches\n+                    for single_match in file_matches\n                 )\n-                if patterns_regex:\n-                    patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-                    try:\n-                        patterns_re = [\n-                            (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n-                            for pattern in patterns_json\n-                        ]\n-                    except re.error as err:\n-                        raise SemgrepError(\n-                            f\"invalid regular expression specified: {err}\"\n-                        )\n+            patterns_json = [p.to_json() for p in patterns]\n+            # very important not to sort keys here", "originalCommit": "7a1fe03d5df64b072725a64e2e1f24e658437a57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM1MDk4NQ==", "url": "https://github.com/returntocorp/semgrep/pull/1001#discussion_r440350985", "bodyText": "Good point. Though i think not cause of ruamel change but cause of per-rule running change.", "author": "brendongo", "createdAt": "2020-06-15T18:00:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzODE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzODU2NQ==", "url": "https://github.com/returntocorp/semgrep/pull/1001#discussion_r440338565", "bodyText": "We can drop the f-string here, we're not interpolating anything.", "author": "mschwager", "createdAt": "2020-06-15T17:37:56Z", "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -199,99 +199,98 @@ def _run_rule(\n         outputs: List[PatternMatch] = []  # multiple invocations per language\n         errors: List[Any] = []\n         equivalences = rule.equivalences\n-        with tempfile.NamedTemporaryFile(\"w\") as equiv_fout:\n \n-            if equivalences:\n-                self._write_equivalences_file(equiv_fout, equivalences)\n+        for language, all_patterns_for_language in self._group_patterns_by_language(\n+            [rule]\n+        ).items():\n+            targets = target_manager.get_files(language, rule.includes, rule.excludes)\n+            if targets == []:\n+                continue\n+\n+            # semgrep-core doesn't know about OPERATORS.REGEX - this is\n+            # strictly a semgrep Python feature. Regex filtering is\n+            # performed purely in Python code then compared against\n+            # semgrep-core's results for other patterns.\n+            patterns_regex, patterns = partition(\n+                lambda p: p.expression.operator == OPERATORS.REGEX,\n+                all_patterns_for_language,\n+            )\n+            if patterns_regex:\n+                patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-            for language, all_patterns_for_language in self._group_patterns_by_language(\n-                [rule]\n-            ).items():\n-                targets = target_manager.get_files(\n-                    language, rule.includes, rule.excludes\n-                )\n-                if targets == []:\n-                    continue\n+                try:\n+                    patterns_re = [\n+                        (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n+                        for pattern in patterns_json\n+                    ]\n+                except re.error as err:\n+                    raise SemgrepError(f\"invalid regular expression specified: {err}\")\n \n-                # semgrep-core doesn't know about OPERATORS.REGEX - this is\n-                # strictly a semgrep Python feature. Regex filtering is\n-                # performed purely in Python code then compared against\n-                # semgrep-core's results for other patterns.\n-                patterns_regex, patterns = partition(\n-                    lambda p: p.expression.operator == OPERATORS.REGEX,\n-                    all_patterns_for_language,\n+                re_fn = functools.partial(get_re_matches, patterns_re)\n+                with multiprocessing.Pool(self._jobs) as pool:\n+                    matches = pool.map(re_fn, targets)\n+\n+                outputs.extend(\n+                    single_match\n+                    for file_matches in matches\n+                    for single_match in file_matches\n                 )\n-                if patterns_regex:\n-                    patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-                    try:\n-                        patterns_re = [\n-                            (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n-                            for pattern in patterns_json\n-                        ]\n-                    except re.error as err:\n-                        raise SemgrepError(\n-                            f\"invalid regular expression specified: {err}\"\n-                        )\n+            patterns_json = [p.to_json() for p in patterns]\n+            # very important not to sort keys here\n+            with tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as pattern_file, tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as target_file, tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as equiv_file:\n+                yaml = YAML()\n+                yaml.dump({\"rules\": patterns_json}, pattern_file)\n+                pattern_file.flush()\n+                target_file.write(\"\\n\".join([str(t) for t in targets]))\n+                target_file.flush()\n+\n+                cmd = [SEMGREP_PATH] + [\n+                    \"-lang\",\n+                    language,\n+                    f\"-rules_file\",", "originalCommit": "7a1fe03d5df64b072725a64e2e1f24e658437a57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzOTI4OQ==", "url": "https://github.com/returntocorp/semgrep/pull/1001#discussion_r440339289", "bodyText": "Since these two += aren't conditional, we can just include them in the original cmd definition.", "author": "mschwager", "createdAt": "2020-06-15T17:39:14Z", "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -199,99 +199,98 @@ def _run_rule(\n         outputs: List[PatternMatch] = []  # multiple invocations per language\n         errors: List[Any] = []\n         equivalences = rule.equivalences\n-        with tempfile.NamedTemporaryFile(\"w\") as equiv_fout:\n \n-            if equivalences:\n-                self._write_equivalences_file(equiv_fout, equivalences)\n+        for language, all_patterns_for_language in self._group_patterns_by_language(\n+            [rule]\n+        ).items():\n+            targets = target_manager.get_files(language, rule.includes, rule.excludes)\n+            if targets == []:\n+                continue\n+\n+            # semgrep-core doesn't know about OPERATORS.REGEX - this is\n+            # strictly a semgrep Python feature. Regex filtering is\n+            # performed purely in Python code then compared against\n+            # semgrep-core's results for other patterns.\n+            patterns_regex, patterns = partition(\n+                lambda p: p.expression.operator == OPERATORS.REGEX,\n+                all_patterns_for_language,\n+            )\n+            if patterns_regex:\n+                patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-            for language, all_patterns_for_language in self._group_patterns_by_language(\n-                [rule]\n-            ).items():\n-                targets = target_manager.get_files(\n-                    language, rule.includes, rule.excludes\n-                )\n-                if targets == []:\n-                    continue\n+                try:\n+                    patterns_re = [\n+                        (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n+                        for pattern in patterns_json\n+                    ]\n+                except re.error as err:\n+                    raise SemgrepError(f\"invalid regular expression specified: {err}\")\n \n-                # semgrep-core doesn't know about OPERATORS.REGEX - this is\n-                # strictly a semgrep Python feature. Regex filtering is\n-                # performed purely in Python code then compared against\n-                # semgrep-core's results for other patterns.\n-                patterns_regex, patterns = partition(\n-                    lambda p: p.expression.operator == OPERATORS.REGEX,\n-                    all_patterns_for_language,\n+                re_fn = functools.partial(get_re_matches, patterns_re)\n+                with multiprocessing.Pool(self._jobs) as pool:\n+                    matches = pool.map(re_fn, targets)\n+\n+                outputs.extend(\n+                    single_match\n+                    for file_matches in matches\n+                    for single_match in file_matches\n                 )\n-                if patterns_regex:\n-                    patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-                    try:\n-                        patterns_re = [\n-                            (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n-                            for pattern in patterns_json\n-                        ]\n-                    except re.error as err:\n-                        raise SemgrepError(\n-                            f\"invalid regular expression specified: {err}\"\n-                        )\n+            patterns_json = [p.to_json() for p in patterns]\n+            # very important not to sort keys here\n+            with tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as pattern_file, tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as target_file, tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as equiv_file:\n+                yaml = YAML()\n+                yaml.dump({\"rules\": patterns_json}, pattern_file)\n+                pattern_file.flush()\n+                target_file.write(\"\\n\".join([str(t) for t in targets]))\n+                target_file.flush()\n+\n+                cmd = [SEMGREP_PATH] + [\n+                    \"-lang\",\n+                    language,\n+                    f\"-rules_file\",\n+                    pattern_file.name,\n+                ]\n+\n+                if equivalences:\n+                    self._write_equivalences_file(equiv_file, equivalences)\n+                    cmd += [\"-equivalences\", equiv_file.name]\n+\n+                cmd += [\"-j\", str(self._jobs)]\n+                cmd += [\"-target_file\", target_file.name]", "originalCommit": "7a1fe03d5df64b072725a64e2e1f24e658437a57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMzOTg5MQ==", "url": "https://github.com/returntocorp/semgrep/pull/1001#discussion_r440339891", "bodyText": "We can do outputs.extend(PatternMatch(m) for m in output_json[\"matches\"]) (no list comp) here to be a bit more memory efficient.", "author": "mschwager", "createdAt": "2020-06-15T17:40:16Z", "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -199,99 +199,98 @@ def _run_rule(\n         outputs: List[PatternMatch] = []  # multiple invocations per language\n         errors: List[Any] = []\n         equivalences = rule.equivalences\n-        with tempfile.NamedTemporaryFile(\"w\") as equiv_fout:\n \n-            if equivalences:\n-                self._write_equivalences_file(equiv_fout, equivalences)\n+        for language, all_patterns_for_language in self._group_patterns_by_language(\n+            [rule]\n+        ).items():\n+            targets = target_manager.get_files(language, rule.includes, rule.excludes)\n+            if targets == []:\n+                continue\n+\n+            # semgrep-core doesn't know about OPERATORS.REGEX - this is\n+            # strictly a semgrep Python feature. Regex filtering is\n+            # performed purely in Python code then compared against\n+            # semgrep-core's results for other patterns.\n+            patterns_regex, patterns = partition(\n+                lambda p: p.expression.operator == OPERATORS.REGEX,\n+                all_patterns_for_language,\n+            )\n+            if patterns_regex:\n+                patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-            for language, all_patterns_for_language in self._group_patterns_by_language(\n-                [rule]\n-            ).items():\n-                targets = target_manager.get_files(\n-                    language, rule.includes, rule.excludes\n-                )\n-                if targets == []:\n-                    continue\n+                try:\n+                    patterns_re = [\n+                        (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n+                        for pattern in patterns_json\n+                    ]\n+                except re.error as err:\n+                    raise SemgrepError(f\"invalid regular expression specified: {err}\")\n \n-                # semgrep-core doesn't know about OPERATORS.REGEX - this is\n-                # strictly a semgrep Python feature. Regex filtering is\n-                # performed purely in Python code then compared against\n-                # semgrep-core's results for other patterns.\n-                patterns_regex, patterns = partition(\n-                    lambda p: p.expression.operator == OPERATORS.REGEX,\n-                    all_patterns_for_language,\n+                re_fn = functools.partial(get_re_matches, patterns_re)\n+                with multiprocessing.Pool(self._jobs) as pool:\n+                    matches = pool.map(re_fn, targets)\n+\n+                outputs.extend(\n+                    single_match\n+                    for file_matches in matches\n+                    for single_match in file_matches\n                 )\n-                if patterns_regex:\n-                    patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-                    try:\n-                        patterns_re = [\n-                            (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n-                            for pattern in patterns_json\n-                        ]\n-                    except re.error as err:\n-                        raise SemgrepError(\n-                            f\"invalid regular expression specified: {err}\"\n-                        )\n+            patterns_json = [p.to_json() for p in patterns]\n+            # very important not to sort keys here\n+            with tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as pattern_file, tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as target_file, tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as equiv_file:\n+                yaml = YAML()\n+                yaml.dump({\"rules\": patterns_json}, pattern_file)\n+                pattern_file.flush()\n+                target_file.write(\"\\n\".join([str(t) for t in targets]))\n+                target_file.flush()\n+\n+                cmd = [SEMGREP_PATH] + [\n+                    \"-lang\",\n+                    language,\n+                    f\"-rules_file\",\n+                    pattern_file.name,\n+                ]\n+\n+                if equivalences:\n+                    self._write_equivalences_file(equiv_file, equivalences)\n+                    cmd += [\"-equivalences\", equiv_file.name]\n+\n+                cmd += [\"-j\", str(self._jobs)]\n+                cmd += [\"-target_file\", target_file.name]\n+\n+                debug_print(f\"Running semgrep... '{cmd}'\")\n+                core_run = subprocess.run(\n+                    cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE\n+                )\n \n-                    re_fn = functools.partial(get_re_matches, patterns_re)\n-                    with multiprocessing.Pool(self._jobs) as pool:\n-                        matches = pool.map(re_fn, targets)\n-\n-                    outputs.extend(\n-                        single_match\n-                        for file_matches in matches\n-                        for single_match in file_matches\n-                    )\n-\n-                patterns_json = [p.to_json() for p in patterns]\n-                # very important not to sort keys here\n-                with tempfile.NamedTemporaryFile(\"w\") as fout:\n-                    yaml = YAML()\n-                    yaml.dump({\"rules\": patterns_json}, fout)\n-                    fout.flush()\n-                    cmd = [SEMGREP_PATH] + [\n-                        \"-lang\",\n-                        language,\n-                        f\"-rules_file\",\n-                        fout.name,\n-                    ]\n+                debug_print(core_run.stderr.decode(\"utf-8\", \"replace\"))\n \n-                    if equivalences:\n-                        cmd += [\"-equivalences\", equiv_fout.name]\n-                    cmd += [\"-j\", str(self._jobs)]\n-                    cmd += [str(path) for path in targets]\n-\n-                    debug_print(f\"Running semgrep... '{cmd}'\")\n-                    core_run = subprocess.run(\n-                        cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE\n-                    )\n-\n-                    debug_print(core_run.stderr.decode(\"utf-8\", \"replace\"))\n-\n-                    if core_run.returncode != 0:\n-                        try:\n-                            # see if semgrep output a JSON error that we can decode\n-                            semgrep_output = core_run.stdout.decode(\"utf-8\", \"replace\")\n-                            output_json = json.loads(semgrep_output)\n-                            if \"error\" in output_json:\n-                                self._semgrep_error_json_to_message_then_exit(\n-                                    output_json\n-                                )\n-                            else:\n-                                raise SemgrepError(\n-                                    f\"unexpected non-json output while invoking semgrep-core:\\n{PLEASE_FILE_ISSUE_TEXT}\"\n-                                )\n-                        except Exception as e:\n+                if core_run.returncode != 0:\n+                    try:\n+                        # see if semgrep output a JSON error that we can decode\n+                        semgrep_output = core_run.stdout.decode(\"utf-8\", \"replace\")\n+                        output_json = json.loads(semgrep_output)\n+                        if \"error\" in output_json:\n+                            self._semgrep_error_json_to_message_then_exit(output_json)\n+                        else:\n                             raise SemgrepError(\n-                                f\"non-zero return code while invoking semgrep-core:\\n\\t{e}\\n{PLEASE_FILE_ISSUE_TEXT}\"\n+                                f\"unexpected non-json output while invoking semgrep-core:\\n{PLEASE_FILE_ISSUE_TEXT}\"\n                             )\n+                    except Exception as e:\n+                        raise SemgrepError(\n+                            f\"non-zero return code while invoking semgrep-core:\\n\\t{e}\\n{PLEASE_FILE_ISSUE_TEXT}\"\n+                        )\n \n-                    output_json = json.loads(\n-                        (core_run.stdout.decode(\"utf-8\", \"replace\"))\n-                    )\n-                    errors.extend(output_json[\"errors\"])\n-                    outputs.extend([PatternMatch(m) for m in output_json[\"matches\"]])\n+                output_json = json.loads((core_run.stdout.decode(\"utf-8\", \"replace\")))\n+                errors.extend(output_json[\"errors\"])\n+                outputs.extend([PatternMatch(m) for m in output_json[\"matches\"]])", "originalCommit": "7a1fe03d5df64b072725a64e2e1f24e658437a57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM0MDc4OQ==", "url": "https://github.com/returntocorp/semgrep/pull/1001#discussion_r440340789", "bodyText": "We can do \"\\n\".join(str(t) for t in targets) (no list comp) to be a bit more memory efficient.", "author": "mschwager", "createdAt": "2020-06-15T17:41:52Z", "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -199,99 +199,98 @@ def _run_rule(\n         outputs: List[PatternMatch] = []  # multiple invocations per language\n         errors: List[Any] = []\n         equivalences = rule.equivalences\n-        with tempfile.NamedTemporaryFile(\"w\") as equiv_fout:\n \n-            if equivalences:\n-                self._write_equivalences_file(equiv_fout, equivalences)\n+        for language, all_patterns_for_language in self._group_patterns_by_language(\n+            [rule]\n+        ).items():\n+            targets = target_manager.get_files(language, rule.includes, rule.excludes)\n+            if targets == []:\n+                continue\n+\n+            # semgrep-core doesn't know about OPERATORS.REGEX - this is\n+            # strictly a semgrep Python feature. Regex filtering is\n+            # performed purely in Python code then compared against\n+            # semgrep-core's results for other patterns.\n+            patterns_regex, patterns = partition(\n+                lambda p: p.expression.operator == OPERATORS.REGEX,\n+                all_patterns_for_language,\n+            )\n+            if patterns_regex:\n+                patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-            for language, all_patterns_for_language in self._group_patterns_by_language(\n-                [rule]\n-            ).items():\n-                targets = target_manager.get_files(\n-                    language, rule.includes, rule.excludes\n-                )\n-                if targets == []:\n-                    continue\n+                try:\n+                    patterns_re = [\n+                        (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n+                        for pattern in patterns_json\n+                    ]\n+                except re.error as err:\n+                    raise SemgrepError(f\"invalid regular expression specified: {err}\")\n \n-                # semgrep-core doesn't know about OPERATORS.REGEX - this is\n-                # strictly a semgrep Python feature. Regex filtering is\n-                # performed purely in Python code then compared against\n-                # semgrep-core's results for other patterns.\n-                patterns_regex, patterns = partition(\n-                    lambda p: p.expression.operator == OPERATORS.REGEX,\n-                    all_patterns_for_language,\n+                re_fn = functools.partial(get_re_matches, patterns_re)\n+                with multiprocessing.Pool(self._jobs) as pool:\n+                    matches = pool.map(re_fn, targets)\n+\n+                outputs.extend(\n+                    single_match\n+                    for file_matches in matches\n+                    for single_match in file_matches\n                 )\n-                if patterns_regex:\n-                    patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-                    try:\n-                        patterns_re = [\n-                            (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n-                            for pattern in patterns_json\n-                        ]\n-                    except re.error as err:\n-                        raise SemgrepError(\n-                            f\"invalid regular expression specified: {err}\"\n-                        )\n+            patterns_json = [p.to_json() for p in patterns]\n+            # very important not to sort keys here\n+            with tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as pattern_file, tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as target_file, tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as equiv_file:\n+                yaml = YAML()\n+                yaml.dump({\"rules\": patterns_json}, pattern_file)\n+                pattern_file.flush()\n+                target_file.write(\"\\n\".join([str(t) for t in targets]))", "originalCommit": "7a1fe03d5df64b072725a64e2e1f24e658437a57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2773340c769910bfba4d432df20851819170b99c", "url": "https://github.com/returntocorp/semgrep/commit/2773340c769910bfba4d432df20851819170b99c", "message": "fixup! core_runner: pass targets using -target_file instead of as list", "committedDate": "2020-06-15T18:00:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MzQwNg==", "url": "https://github.com/returntocorp/semgrep/pull/1001#discussion_r440373406", "bodyText": "Nit: I think we can include these args in the original cmd = ... line. Unless arg ordering matters here?", "author": "mschwager", "createdAt": "2020-06-15T18:42:28Z", "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -199,99 +199,96 @@ def _run_rule(\n         outputs: List[PatternMatch] = []  # multiple invocations per language\n         errors: List[Any] = []\n         equivalences = rule.equivalences\n-        with tempfile.NamedTemporaryFile(\"w\") as equiv_fout:\n \n-            if equivalences:\n-                self._write_equivalences_file(equiv_fout, equivalences)\n+        for language, all_patterns_for_language in self._group_patterns_by_language(\n+            [rule]\n+        ).items():\n+            targets = target_manager.get_files(language, rule.includes, rule.excludes)\n+            if targets == []:\n+                continue\n+\n+            # semgrep-core doesn't know about OPERATORS.REGEX - this is\n+            # strictly a semgrep Python feature. Regex filtering is\n+            # performed purely in Python code then compared against\n+            # semgrep-core's results for other patterns.\n+            patterns_regex, patterns = partition(\n+                lambda p: p.expression.operator == OPERATORS.REGEX,\n+                all_patterns_for_language,\n+            )\n+            if patterns_regex:\n+                patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-            for language, all_patterns_for_language in self._group_patterns_by_language(\n-                [rule]\n-            ).items():\n-                targets = target_manager.get_files(\n-                    language, rule.includes, rule.excludes\n-                )\n-                if targets == []:\n-                    continue\n+                try:\n+                    patterns_re = [\n+                        (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n+                        for pattern in patterns_json\n+                    ]\n+                except re.error as err:\n+                    raise SemgrepError(f\"invalid regular expression specified: {err}\")\n \n-                # semgrep-core doesn't know about OPERATORS.REGEX - this is\n-                # strictly a semgrep Python feature. Regex filtering is\n-                # performed purely in Python code then compared against\n-                # semgrep-core's results for other patterns.\n-                patterns_regex, patterns = partition(\n-                    lambda p: p.expression.operator == OPERATORS.REGEX,\n-                    all_patterns_for_language,\n+                re_fn = functools.partial(get_re_matches, patterns_re)\n+                with multiprocessing.Pool(self._jobs) as pool:\n+                    matches = pool.map(re_fn, targets)\n+\n+                outputs.extend(\n+                    single_match\n+                    for file_matches in matches\n+                    for single_match in file_matches\n                 )\n-                if patterns_regex:\n-                    patterns_json = [pattern.to_json() for pattern in patterns_regex]\n \n-                    try:\n-                        patterns_re = [\n-                            (pattern[\"id\"], re.compile(pattern[\"pattern\"]))\n-                            for pattern in patterns_json\n-                        ]\n-                    except re.error as err:\n-                        raise SemgrepError(\n-                            f\"invalid regular expression specified: {err}\"\n-                        )\n+            patterns_json = [p.to_json() for p in patterns]\n+            with tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as pattern_file, tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as target_file, tempfile.NamedTemporaryFile(\n+                \"w\"\n+            ) as equiv_file:\n+                yaml = YAML()\n+                yaml.dump({\"rules\": patterns_json}, pattern_file)\n+                pattern_file.flush()\n+                target_file.write(\"\\n\".join(str(t) for t in targets))\n+                target_file.flush()\n+\n+                cmd = [SEMGREP_PATH] + [\n+                    \"-lang\",\n+                    language,\n+                    \"-rules_file\",\n+                    pattern_file.name,\n+                ]\n+\n+                if equivalences:\n+                    self._write_equivalences_file(equiv_file, equivalences)\n+                    cmd += [\"-equivalences\", equiv_file.name]\n+\n+                cmd += [\"-j\", str(self._jobs), \"-target_file\", target_file.name]", "originalCommit": "2773340c769910bfba4d432df20851819170b99c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3NDU3MA==", "url": "https://github.com/returntocorp/semgrep/pull/1001#discussion_r440374570", "bodyText": "It doesn't. let me do that", "author": "brendongo", "createdAt": "2020-06-15T18:44:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDM3MzQwNg=="}], "type": "inlineReview"}, {"oid": "fb9ebedd65b184976148e5a97dc5fb35918dc682", "url": "https://github.com/returntocorp/semgrep/commit/fb9ebedd65b184976148e5a97dc5fb35918dc682", "message": "fixup! core_runner: pass targets using -target_file instead of as list", "committedDate": "2020-06-15T18:46:18Z", "type": "commit"}]}