{"pr_number": 1284, "pr_title": "Skeleton to use the Go tree-sitter parser", "pr_createdAt": "2020-07-15T12:48:52Z", "pr_url": "https://github.com/returntocorp/semgrep/pull/1284", "timeline": [{"oid": "a6cc30c0ba56311de421e5ac91ec355132da3c5a", "url": "https://github.com/returntocorp/semgrep/commit/a6cc30c0ba56311de421e5ac91ec355132da3c5a", "message": "Skeleton to use the Go tree-sitter parser\n\nThis is part1 of adding support for the Go tree-sitter-based parser.\nThis diff just integrate the go tree-sitter library in the build system\nand create a boilerplate Parse_go_tree_sitter.ml to be filled later.\n\nTest plan:\nmake", "committedDate": "2020-07-15T12:48:00Z", "type": "commit"}, {"oid": "071048de5ceb5356d326ca94740a48f45a963b19", "url": "https://github.com/returntocorp/semgrep/commit/071048de5ceb5356d326ca94740a48f45a963b19", "message": "* semgrep-core/parsing/Parse_go_tree_sitter.ml:\nremove the map_ prefix to every func (optional but I prefer the boilerplate\ncode that way)", "committedDate": "2020-07-15T12:57:45Z", "type": "commit"}, {"oid": "df910e3b3a09767f57da4617fb44c4c5a730f3b7", "url": "https://github.com/returntocorp/semgrep/commit/df910e3b3a09767f57da4617fb44c4c5a730f3b7", "message": "* semgrep-core/parsing/Parse_go_tree_sitter.ml: add prelude header and\nmain emtry point", "committedDate": "2020-07-15T13:09:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2Nzk4OA==", "url": "https://github.com/returntocorp/semgrep/pull/1284#discussion_r455267988", "bodyText": "should this be in a Java parsing PR instead?", "author": "nbrahms", "createdAt": "2020-07-15T18:48:03Z", "path": "semgrep-core/parsing/Parse_java_tree_sitter.ml", "diffHunk": "@@ -50,13 +51,11 @@ module G = AST_generic\n \n [@@@warning \"-32\"]\n \n-type env = unit\n+type env = H.env\n \n-let token (env : env) (_tok : Tree_sitter_run.Token.t) =\n-  failwith \"not implemented\"\n+let token (env : env) (_tok : Tree_sitter_run.Token.t) = H.token", "originalCommit": "df910e3b3a09767f57da4617fb44c4c5a730f3b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2ODU0NQ==", "url": "https://github.com/returntocorp/semgrep/pull/1284#discussion_r455268545", "bodyText": "yes it should ...", "author": "aryx", "createdAt": "2020-07-15T18:49:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2Nzk4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2OTA3NA==", "url": "https://github.com/returntocorp/semgrep/pull/1284#discussion_r455269074", "bodyText": "FWIW I'd love to see us, in the future, clearly separating boilerplate vs. contributed code.\nE.g.\nmatch Boilerplate.interpreted_string_literal env v with\n  (v1, v2, v3) -> todo env (v1, v2, v3)\nhere", "author": "nbrahms", "createdAt": "2020-07-15T18:50:03Z", "path": "semgrep-core/parsing/Parse_go_tree_sitter.ml", "diffHunk": "@@ -0,0 +1,1547 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU General Public License (GPL)\n+ * version 2 as published by the Free Software Foundation.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * file license.txt for more details.\n+ *)\n+open Common\n+module AST = Ast_go\n+module CST = Tree_sitter_go.CST\n+module PI = Parse_info\n+(* open Ast_go *)\n+module G = AST_generic\n+module H = Parse_tree_sitter_helpers\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* Go parser using ocaml-tree-sitter-lang/go and converting\n+ * to pfff/lang_go/parsing/ast_go.ml\n+ *\n+ * The resulting AST can then be converted to the generic AST by using\n+ * pfff/lang_go/analyze/go_to_generic.ml\n+ *)\n+\n+(*****************************************************************************)\n+(* Helpers *)\n+(*****************************************************************************)\n+\n+(*****************************************************************************)\n+(* Boilerplate converter *)\n+(*****************************************************************************)\n+(* This was started by copying ocaml-tree-sitter-lang/go/.../Boilerplate.ml *)\n+\n+(**\n+   Boilerplate to be used as a template when mapping the go CST\n+   to another type of tree.\n+*)\n+\n+(* Disable warnings against unused variables *)\n+[@@@warning \"-26-27\"]\n+\n+(* Disable warning against unused 'rec' *)\n+[@@@warning \"-39\"]\n+\n+[@@@warning \"-32\"]\n+\n+type env = H.env\n+\n+let token (env : env) (_tok : Tree_sitter_run.Token.t) = H.token\n+\n+let blank (env : env) () = ()\n+\n+let todo (env : env) _ =\n+   failwith \"not implemented\"\n+\n+let int_literal (env : env) (tok : CST.int_literal) =\n+  token env tok (* int_literal *)\n+\n+let identifier (env : env) (tok : CST.identifier) =\n+  token env tok (* identifier *)\n+\n+let raw_string_literal (env : env) (tok : CST.raw_string_literal) =\n+  token env tok (* raw_string_literal *)\n+\n+let rune_literal (env : env) (tok : CST.rune_literal) =\n+  token env tok (* rune_literal *)\n+\n+let float_literal (env : env) (tok : CST.float_literal) =\n+  token env tok (* float_literal *)\n+\n+let imaginary_literal (env : env) (tok : CST.imaginary_literal) =\n+  token env tok (* imaginary_literal *)\n+\n+let escape_sequence (env : env) (tok : CST.escape_sequence) =\n+  token env tok (* escape_sequence *)\n+\n+let qualified_type (env : env) ((v1, v2, v3) : CST.qualified_type) =\n+  let v1 = token env v1 (* identifier *) in\n+  let v2 = token env v2 (* \".\" *) in\n+  let v3 = token env v3 (* identifier *) in\n+  todo env (v1, v2, v3)\n+\n+let package_clause (env : env) ((v1, v2) : CST.package_clause) =\n+  let v1 = token env v1 (* \"package\" *) in\n+  let v2 = token env v2 (* identifier *) in\n+  todo env (v1, v2)\n+\n+let empty_labeled_statement (env : env) ((v1, v2) : CST.empty_labeled_statement) =\n+  let v1 = token env v1 (* identifier *) in\n+  let v2 = token env v2 (* \":\" *) in\n+  todo env (v1, v2)\n+\n+let interpreted_string_literal (env : env) ((v1, v2, v3) : CST.interpreted_string_literal) =\n+  let v1 = token env v1 (* \"\\\"\" *) in", "originalCommit": "df910e3b3a09767f57da4617fb44c4c5a730f3b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2OTg2OQ==", "url": "https://github.com/returntocorp/semgrep/pull/1284#discussion_r455269869", "bodyText": "The motivation is to reduce, as much as possible, any manual work when rev'ing the grammar later.", "author": "nbrahms", "createdAt": "2020-07-15T18:51:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2OTA3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI3ODc2MQ==", "url": "https://github.com/returntocorp/semgrep/pull/1284#discussion_r455278761", "bodyText": "I don't think we can call Boilerplate from Parse_go_tree_sitter.ml. We copy-paste Boilerplate.ml initially but\nin my next diff I will update every final \"actions\" in Parse_go_tree_sitter.ml.\nWhen we rev'ing the grammar later, we will regenerate CST.ml and the OCaml compiler will help us pinpoint\nall the place in Parse_go_tree_sitter.ml we need to update. I don't think it will be too much work.", "author": "aryx", "createdAt": "2020-07-15T19:07:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTI2OTA3NA=="}], "type": "inlineReview"}]}