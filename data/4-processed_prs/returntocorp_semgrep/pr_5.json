{"pr_number": 5, "pr_title": "initial sgrep lint in python supporting multiple rules in a directory", "pr_createdAt": "2020-01-22T03:11:05Z", "pr_url": "https://github.com/returntocorp/semgrep/pull/5", "timeline": [{"oid": "dd72756e1fd57d518b7fe267f7f971eba39161f2", "url": "https://github.com/returntocorp/semgrep/commit/dd72756e1fd57d518b7fe267f7f971eba39161f2", "message": "initial sgrep lint in python supporting multiple rules in a directory", "committedDate": "2020-01-22T03:04:20Z", "type": "commit"}, {"oid": "abd3d84863cf9030cce5aad3fbbdc6765df93a8e", "url": "https://github.com/returntocorp/semgrep/commit/abd3d84863cf9030cce5aad3fbbdc6765df93a8e", "message": "cleanup", "committedDate": "2020-01-22T03:11:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc3NjYwNg==", "url": "https://github.com/returntocorp/semgrep/pull/5#discussion_r369776606", "bodyText": "I think you currently need also to have -sgrep_lint as an argument.", "author": "aryx", "createdAt": "2020-01-22T20:07:10Z", "path": "lint.py", "diffHunk": "@@ -0,0 +1,94 @@\n+#!/usr/bin/env python3\n+import os\n+import pathlib\n+import subprocess\n+import sys\n+import tempfile\n+import traceback\n+from pathlib import PurePath\n+\n+import click\n+import yaml\n+\n+# validate input yaml files\n+\n+# validate patterns inside yaml files\n+\n+# glob yaml files into a single rule files, adjusting check ids\n+MUST_HAVE_KEYS = set(['id', 'pattern', 'message', 'languages', 'severity'])\n+YML_EXTENSIONS = ['.yml', '.yaml']\n+\n+SGREP_PATH = \"sgrep\"\n+\n+\n+def print_error(e):\n+    sys.stderr.write(e + os.linesep)\n+    sys.stderr.flush()\n+\n+\n+def parse_sgrep_yml(file_path: str):\n+    #print_error(f'loading rules from {file_path}...')\n+    try:\n+        y = yaml.safe_load(open(file_path))\n+    except FileNotFoundError:\n+        return None\n+    except yaml.scanner.ScannerError as se:\n+        print_error(se)\n+        return None\n+\n+    if not 'rules' in y:\n+        print_error(f'{file_path} should have top-level key named `rules`')\n+        return None\n+\n+    rules = []\n+    for i, rule in enumerate(y['rules']):\n+        if not rule:\n+            continue\n+        rule_id_err_msg = f'(rule id: {rule[\"id\"]})' if ('id' in rule) else ''\n+        if MUST_HAVE_KEYS != set(rule.keys()):\n+            print_error(\n+                f'{file_path} is missing keys at rule {i}{rule_id_err_msg}, must have: {MUST_HAVE_KEYS}')\n+        else:\n+            rules.append(rule)\n+    return rules\n+\n+\n+@click.command()\n+@click.argument(\"yaml_file_or_dirs\", nargs=1, type=click.Path(),\n+                #help=f\"The YAML file or directory of YAML files ending in {YML_EXTENSIONS} with rules\",\n+                )\n+@click.argument(\"target_files_or_dirs\", nargs=-1, type=click.Path())\n+def main(yaml_file_or_dirs, target_files_or_dirs):\n+    all_rules = []\n+    errors, not_errors = 0, 0\n+    for root, dirs, files in os.walk(yaml_file_or_dirs):\n+        dirs.sort()\n+        for filename in sorted(files):\n+            if pathlib.Path(filename).suffix in YML_EXTENSIONS:\n+                full_path = os.path.join(root, filename)\n+                rules_in_file = parse_sgrep_yml(full_path)\n+                if rules_in_file is None:\n+                    errors += 1\n+                else:\n+                    not_errors += 1\n+                    for rule in rules_in_file:\n+                        prefix = '.'.join([x for x in PurePath(\n+                            pathlib.Path(full_path)).parts[:-1] if len(x)])\n+                        new_id = f\"{prefix}.{rule['id']}\".lstrip('.')\n+                        rule['id'] = new_id\n+                    all_rules.extend(list(rules_in_file))\n+\n+    # create unified yml file\n+    unified = {'rules': list(all_rules)}\n+    print_error(\n+        f'running {len(all_rules)} rules from {not_errors} yaml files ({errors} yaml files were invalid)')\n+    with tempfile.NamedTemporaryFile('w') as fout:\n+        fout.write(yaml.safe_dump(unified, sort_keys=False))\n+        fout.flush()\n+        cmd = f'{SGREP_PATH} -rule_file={fout.name} {\" \".join(list(target_files_or_dirs))}'", "originalCommit": "abd3d84863cf9030cce5aad3fbbdc6765df93a8e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "dd94aa270e678afe1f67aff8c3f2fa7225cfce98", "url": "https://github.com/returntocorp/semgrep/commit/dd94aa270e678afe1f67aff8c3f2fa7225cfce98", "message": "midpoint", "committedDate": "2020-01-24T23:56:11Z", "type": "commit"}, {"oid": "1de99913d9fb647c5dc0f781dcbb0444f001be34", "url": "https://github.com/returntocorp/semgrep/commit/1de99913d9fb647c5dc0f781dcbb0444f001be34", "message": "passing all tests", "committedDate": "2020-01-25T00:04:48Z", "type": "commit"}, {"oid": "e8d7c456899ca09b28560dac2d57da6b089b9703", "url": "https://github.com/returntocorp/semgrep/commit/e8d7c456899ca09b28560dac2d57da6b089b9703", "message": "a bit ugly because not actually recusive but working", "committedDate": "2020-01-25T01:31:49Z", "type": "commit"}]}