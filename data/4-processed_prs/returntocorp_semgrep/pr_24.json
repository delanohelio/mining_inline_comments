{"pr_number": 24, "pr_title": "Fix single file rule argument", "pr_createdAt": "2020-01-30T00:02:28Z", "pr_url": "https://github.com/returntocorp/semgrep/pull/24", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE1OTM2Nw==", "url": "https://github.com/returntocorp/semgrep/pull/24#discussion_r373159367", "bodyText": "@ulziibay should this be under an else:", "author": "ievans", "createdAt": "2020-01-30T19:50:54Z", "path": "sgrep.py", "diffHunk": "@@ -270,27 +270,37 @@ def rewrite_message_with_metavars(yaml_rule, sgrep_result):\n     return msg_text\n \n \n-def collect_rules(yaml_file_or_dirs: str) -> Tuple[List[Dict[str, Any]], Tuple[int, int]]:\n+def _collect_rules_from_files(files: List[str], root: Optional[str] = None)-> Tuple[List[Dict[str, Any]], Tuple[int, int]]:\n     collected_rules = []\n     errors, not_errors = 0, 0\n-    for root, dirs, files in os.walk(yaml_file_or_dirs):\n-        dirs.sort()\n-        for filename in sorted(files):\n-            if pathlib.Path(filename).suffix in YML_EXTENSIONS:\n+    for filename in sorted(files):\n+        if pathlib.Path(filename).suffix in YML_EXTENSIONS:\n+            if root:\n                 full_path = os.path.join(root, filename)\n-                rules_in_file = parse_sgrep_yml(full_path)\n-                if rules_in_file is None:\n-                    errors += 1\n-                else:\n-                    not_errors += 1\n-                    for rule in rules_in_file:\n-                        prefix = '.'.join([x for x in PurePath(\n-                            pathlib.Path(full_path)).parts[:-1] if len(x)])\n-                        new_id = f\"{prefix}.{rule['id']}\".lstrip('.')\n-                        rule['id'] = new_id\n-                    collected_rules.extend(rules_in_file)\n+            else:\n+                full_path = filename\n+            rules_in_file = parse_sgrep_yml(full_path)\n+            if rules_in_file is None:\n+                errors += 1\n+            else:\n+                not_errors += 1\n+                for rule in rules_in_file:\n+                    prefix = '.'.join([x for x in PurePath(\n+                        pathlib.Path(full_path)).parts[:-1] if len(x)])\n+                    new_id = f\"{prefix}.{rule['id']}\".lstrip('.')\n+                    rule['id'] = new_id\n+                collected_rules.extend(rules_in_file)\n     return collected_rules, (errors, not_errors)\n \n+def collect_rules(yaml_file_or_dirs: str) -> Tuple[List[Dict[str, Any]], Tuple[int, int]]:\n+    if os.path.isfile(yaml_file_or_dirs):\n+        file_path = os.path.abspath(yaml_file_or_dirs)\n+        return _collect_rules_from_files([file_path])\n+\n+    for root, dirs, files in os.walk(yaml_file_or_dirs):", "originalCommit": "6ef6024a10103eadc28b45d52dc00ba9ebeb1603", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE4NjU1Mw==", "url": "https://github.com/returntocorp/semgrep/pull/24#discussion_r373186553", "bodyText": "Same logic no? This version is better because of better indentation", "author": "ulziibay", "createdAt": "2020-01-30T20:50:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE1OTM2Nw=="}], "type": "inlineReview"}, {"oid": "2dd825e634bc01ec1f1d424e66d19b5d7b3fb647", "url": "https://github.com/returntocorp/semgrep/commit/2dd825e634bc01ec1f1d424e66d19b5d7b3fb647", "message": "Fix single file rule argument", "committedDate": "2020-01-31T00:19:51Z", "type": "commit"}, {"oid": "5fffdc6563a9fa155300a27ee65c811cecd69682", "url": "https://github.com/returntocorp/semgrep/commit/5fffdc6563a9fa155300a27ee65c811cecd69682", "message": "Address comments about code reuse", "committedDate": "2020-01-31T00:20:30Z", "type": "commit"}, {"oid": "5fffdc6563a9fa155300a27ee65c811cecd69682", "url": "https://github.com/returntocorp/semgrep/commit/5fffdc6563a9fa155300a27ee65c811cecd69682", "message": "Address comments about code reuse", "committedDate": "2020-01-31T00:20:30Z", "type": "forcePushed"}]}