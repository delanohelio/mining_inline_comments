{"pr_number": 2256, "pr_title": "Preliminaries for matching with memoization", "pr_createdAt": "2020-12-15T03:44:04Z", "pr_url": "https://github.com/returntocorp/semgrep/pull/2256", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzMDM5Mg==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543130392", "bodyText": "maybe better to define a new type for those 3 variants instead of using option option.\ntype capture_ellipsis = NotInEllipsis | EllipsisButNoCapture | EllipsisCapture of string * char list", "author": "aryx", "createdAt": "2020-12-15T08:11:12Z", "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option", "originalCommit": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg0MzMwMA==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543843300", "bodyText": "I did that.", "author": "mjambon", "createdAt": "2020-12-16T02:32:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzMDM5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzMTQyOA==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543131428", "bodyText": "Why not Any_char? Why symbol?", "author": "aryx", "createdAt": "2020-12-15T08:13:03Z", "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)", "originalCommit": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzMzQxOA==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543133418", "bodyText": "Why not closer to what semgrep does and use:\ntype pattern =\n| Literal of char\n| Metavar of string\n| Ellipsis\ninstead of split in 2 with pattern_atom and pattern with those option string.\nAlso why do you need to capture the content of an Ellipsis?\nIs it to imitate the ugly thing I do in semgrep-core to capture the range of the sequence of matched statements?", "author": "aryx", "createdAt": "2020-12-15T08:16:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzMTQyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzcyNTk4NQ==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543725985", "bodyText": "Why not Any_char? Why symbol?\n\nIt's because we don't really care that they are of type char. It could be anything.\n\nWhy not closer to what semgrep does and use:\ntype pattern =\n| Literal of char\n| Metavar of string\n| Ellipsis\ninstead of split in 2 with pattern_atom and pattern with those option string.\n\nI picked the list because the list type is well-known. It makes it clear that the pattern is structured as a list rather than any tree.\n\nAlso why do you need to capture the content of an Ellipsis?\nIs it to imitate the ugly thing I do in semgrep-core to capture the range of the sequence of matched statements?\n\nYes. Like anything that determines the result of the function, it must be made part of the cache key.", "author": "mjambon", "createdAt": "2020-12-15T22:14:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzMTQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzNDAxOQ==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543134019", "bodyText": "Then this could be just:\nlet sampe_pattern = [\nLiteral 'A'; Metavar \"thing\"; Ellipsis; Metavar \"thing\"]", "author": "aryx", "createdAt": "2020-12-15T08:17:21Z", "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [", "originalCommit": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg0MzExMw==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543843113", "bodyText": "I think it's clearer this way. I added comments about the differences between semgrep and this.", "author": "mjambon", "createdAt": "2020-12-16T02:32:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzNDAxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzNzM0NA==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543137344", "bodyText": "why?", "author": "aryx", "createdAt": "2020-12-15T08:22:57Z", "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [\n+  Symbol 'A', None;\n+  Any_symbol, Some \"thing\";\n+  Ellipsis, None;\n+  Backref \"thing\", None;\n+]\n+\n+(*\n+   Unlike in semgrep syntax, we distinguish metavariable assignments\n+   from metavariable dereferencing.", "originalCommit": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzODI2MA==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543138260", "bodyText": "To make things more explicit? What do you win by having Backref and the string option in pattern to\nrepresent those 2 different things?", "author": "aryx", "createdAt": "2020-12-15T08:24:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzNzM0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg0MTc2NA==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543841764", "bodyText": "I explained this in the file.", "author": "mjambon", "createdAt": "2020-12-16T02:30:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzNzM0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0MDcxMA==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543140710", "bodyText": "this would be clearer if we had 3 constructors instead of Some Some.", "author": "aryx", "createdAt": "2020-12-15T08:27:54Z", "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [\n+  Symbol 'A', None;\n+  Any_symbol, Some \"thing\";\n+  Ellipsis, None;\n+  Backref \"thing\", None;\n+]\n+\n+(*\n+   Unlike in semgrep syntax, we distinguish metavariable assignments\n+   from metavariable dereferencing.\n+\n+   This function checks that variable assignments are unique and that\n+   backreferences refer to a valid variable name.\n+\n+   This is a sanity check, not part of the matching algorithm.\n+*)\n+let rec check_pattern_ env (pat : pattern) =\n+  match pat with\n+  | [] -> ()\n+  | (atom, opt_name) :: pat ->\n+      let new_env =\n+        match opt_name with\n+        | None -> env\n+        | Some name ->\n+            if List.mem name env then\n+              failwith (\"multiple atoms have the same name: \" ^ name)\n+            else\n+              name :: env\n+      in\n+      (match atom with\n+       | Any_symbol -> ()\n+       | Symbol _ -> ()\n+       | Ellipsis -> ()\n+       | Backref name ->\n+           if not (List.mem name env) then\n+             failwith (\"backreference to invalid name: \" ^ name)\n+      );\n+      check_pattern_ new_env pat\n+\n+let check_pattern pat =\n+  check_pattern_ [] pat\n+\n+(*\n+   Initialize the capture of symbols by an ellipsis.\n+   'init_acc' is a stack, holding symbols in reverse order.\n+*)\n+let init_ellipsis opt_name init_acc =", "originalCommit": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg0MTQyOA==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543841428", "bodyText": "I did that.", "author": "mjambon", "createdAt": "2020-12-16T02:29:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0MDcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0MTA3OA==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543141078", "bodyText": "You would not need those extra comments if None was NotInEllipsis.", "author": "aryx", "createdAt": "2020-12-15T08:28:33Z", "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [\n+  Symbol 'A', None;\n+  Any_symbol, Some \"thing\";\n+  Ellipsis, None;\n+  Backref \"thing\", None;\n+]\n+\n+(*\n+   Unlike in semgrep syntax, we distinguish metavariable assignments\n+   from metavariable dereferencing.\n+\n+   This function checks that variable assignments are unique and that\n+   backreferences refer to a valid variable name.\n+\n+   This is a sanity check, not part of the matching algorithm.\n+*)\n+let rec check_pattern_ env (pat : pattern) =\n+  match pat with\n+  | [] -> ()\n+  | (atom, opt_name) :: pat ->\n+      let new_env =\n+        match opt_name with\n+        | None -> env\n+        | Some name ->\n+            if List.mem name env then\n+              failwith (\"multiple atoms have the same name: \" ^ name)\n+            else\n+              name :: env\n+      in\n+      (match atom with\n+       | Any_symbol -> ()\n+       | Symbol _ -> ()\n+       | Ellipsis -> ()\n+       | Backref name ->\n+           if not (List.mem name env) then\n+             failwith (\"backreference to invalid name: \" ^ name)\n+      );\n+      check_pattern_ new_env pat\n+\n+let check_pattern pat =\n+  check_pattern_ [] pat\n+\n+(*\n+   Initialize the capture of symbols by an ellipsis.\n+   'init_acc' is a stack, holding symbols in reverse order.\n+*)\n+let init_ellipsis opt_name init_acc =\n+  match opt_name with\n+  | None -> Some None\n+  | Some name -> Some (Some (name, init_acc))\n+\n+let extend_ellipsis opt_ellipsis symbol =\n+  match opt_ellipsis with\n+  | None -> opt_ellipsis\n+  | Some None -> opt_ellipsis\n+  | Some (Some (name, acc)) -> Some (Some (name, symbol :: acc))\n+\n+let close_ellipsis opt_ellipsis env =\n+  match opt_ellipsis with\n+  | None -> env\n+  | Some None -> env\n+  | Some (Some (name, acc)) -> Env.add name (List.rev acc) env\n+\n+(*\n+   Extend the environment by adding captured subsequences:\n+   - add the named ellipsis that ended just before the current match,\n+     if applicable\n+   - add the named atom that was just matched, if applicable\n+*)\n+let extend env opt_ellipsis opt_name captured_sequence =\n+  let env =\n+    match opt_ellipsis with\n+    | None -> env       (* we were not in an ellipsis *)", "originalCommit": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0MjA4Mg==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543142082", "bodyText": "Can you add a comment explaining the intuition behind this caching idea. What do you try to cache\nand why it avoids work.", "author": "aryx", "createdAt": "2020-12-15T08:30:07Z", "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [\n+  Symbol 'A', None;\n+  Any_symbol, Some \"thing\";\n+  Ellipsis, None;\n+  Backref \"thing\", None;\n+]\n+\n+(*\n+   Unlike in semgrep syntax, we distinguish metavariable assignments\n+   from metavariable dereferencing.\n+\n+   This function checks that variable assignments are unique and that\n+   backreferences refer to a valid variable name.\n+\n+   This is a sanity check, not part of the matching algorithm.\n+*)\n+let rec check_pattern_ env (pat : pattern) =\n+  match pat with\n+  | [] -> ()\n+  | (atom, opt_name) :: pat ->\n+      let new_env =\n+        match opt_name with\n+        | None -> env\n+        | Some name ->\n+            if List.mem name env then\n+              failwith (\"multiple atoms have the same name: \" ^ name)\n+            else\n+              name :: env\n+      in\n+      (match atom with\n+       | Any_symbol -> ()\n+       | Symbol _ -> ()\n+       | Ellipsis -> ()\n+       | Backref name ->\n+           if not (List.mem name env) then\n+             failwith (\"backreference to invalid name: \" ^ name)\n+      );\n+      check_pattern_ new_env pat\n+\n+let check_pattern pat =\n+  check_pattern_ [] pat\n+\n+(*\n+   Initialize the capture of symbols by an ellipsis.\n+   'init_acc' is a stack, holding symbols in reverse order.\n+*)\n+let init_ellipsis opt_name init_acc =\n+  match opt_name with\n+  | None -> Some None\n+  | Some name -> Some (Some (name, init_acc))\n+\n+let extend_ellipsis opt_ellipsis symbol =\n+  match opt_ellipsis with\n+  | None -> opt_ellipsis\n+  | Some None -> opt_ellipsis\n+  | Some (Some (name, acc)) -> Some (Some (name, symbol :: acc))\n+\n+let close_ellipsis opt_ellipsis env =\n+  match opt_ellipsis with\n+  | None -> env\n+  | Some None -> env\n+  | Some (Some (name, acc)) -> Env.add name (List.rev acc) env\n+\n+(*\n+   Extend the environment by adding captured subsequences:\n+   - add the named ellipsis that ended just before the current match,\n+     if applicable\n+   - add the named atom that was just matched, if applicable\n+*)\n+let extend env opt_ellipsis opt_name captured_sequence =\n+  let env =\n+    match opt_ellipsis with\n+    | None -> env       (* we were not in an ellipsis *)\n+    | Some None -> env  (* we were in an anonymous ellipsis *)\n+    | Some (Some (ellipsis_name, acc)) ->\n+        Env.add ellipsis_name (List.rev acc) env\n+  in\n+  match opt_name with\n+  | None -> env\n+  | Some name ->\n+      Env.add name captured_sequence env\n+\n+(*\n+   Turn a string into a list of chars.\n+*)\n+let parse s =\n+  let acc = ref [] in\n+  for i = String.length s - 1 downto 0 do\n+    acc := s.[i] :: !acc\n+  done;\n+  !acc\n+\n+let unparse l =\n+  let buf = Buffer.create (List.length l) in\n+  List.iter (Buffer.add_char buf) l;\n+  Buffer.contents buf\n+\n+let print_result oc opt_bindings =\n+  match opt_bindings with\n+  | None ->\n+      fprintf oc \"not a match\\n\"\n+  | Some l ->\n+      fprintf oc \"match: {\\n\";\n+      List.iter (fun (name, subseq) ->\n+        fprintf oc \"  %s: %S\\n\"\n+          name subseq\n+      ) l;\n+      fprintf oc \"}\\n\"\n+\n+(* to be appended to existing line *)\n+let print_ellipsis oc ellipsis =\n+  match ellipsis with\n+  | None -> ()\n+  | Some None -> fprintf oc \" in-ellipsis\"\n+  | Some (Some (name, acc)) ->\n+      fprintf oc \" in-ellipsis:%s:%S\" name (unparse (List.rev acc))\n+\n+(* to be appended to existing line *)\n+let print_env oc env =\n+  fprintf oc \" {\";\n+  let is_first = ref true in\n+  Env.bindings env\n+  |> List.iter (fun (name, subseq) ->\n+    if !is_first then\n+      is_first := false\n+    else\n+      fprintf oc \" \";\n+    fprintf oc \"%s:%S\"\n+      name\n+      (unparse subseq)\n+  );\n+  fprintf oc \"}\"\n+\n+(* to be appended to existing line *)\n+let print_pat_head oc pat =\n+  match pat with\n+  | [] ->\n+      fprintf oc \" _:''\"\n+  | (atom, opt_name) :: _ ->\n+      (match opt_name with\n+       | None -> fprintf oc \" _:\"\n+       | Some name -> fprintf oc \" %s:\" name\n+      );\n+      match atom with\n+      | Any_symbol -> fprintf oc \"_\"\n+      | Symbol c -> fprintf oc \"%C\" c\n+      | Ellipsis -> fprintf oc \"...\"\n+      | Backref name -> fprintf oc \"%s\" name\n+\n+(* to be appended to existing line *)\n+let print_input_head oc input =\n+  match input with\n+  | [] ->\n+      fprintf oc \" ''\"\n+  | symbol :: _ ->\n+      fprintf oc \" %C\" symbol\n+\n+let max_trace_lines = 100\n+\n+(* print single line *)\n+let trace_match_call ~trace stat ellipsis env pat input =\n+  let match_calls = stat.match_calls + 1 in\n+  stat.match_calls <- match_calls;\n+  if trace then\n+    if match_calls <= max_trace_lines then\n+      printf \"match%a%a%a%a\\n\"\n+        print_ellipsis ellipsis\n+        print_env env\n+        print_pat_head pat\n+        print_input_head input\n+    else if match_calls = max_trace_lines + 1 then\n+      printf \"[exceeded max trace lines = %i]\\n%!\" max_trace_lines\n+\n+module Cache_key = struct\n+  type t = ellipsis * env * pattern * input", "originalCommit": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg0MTExNA==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543841114", "bodyText": "I added  something.", "author": "mjambon", "createdAt": "2020-12-16T02:29:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0MjA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0Mzg2OQ==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543143869", "bodyText": "would be nice  to have the return type here. What does a matcher return?", "author": "aryx", "createdAt": "2020-12-15T08:32:43Z", "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [\n+  Symbol 'A', None;\n+  Any_symbol, Some \"thing\";\n+  Ellipsis, None;\n+  Backref \"thing\", None;\n+]\n+\n+(*\n+   Unlike in semgrep syntax, we distinguish metavariable assignments\n+   from metavariable dereferencing.\n+\n+   This function checks that variable assignments are unique and that\n+   backreferences refer to a valid variable name.\n+\n+   This is a sanity check, not part of the matching algorithm.\n+*)\n+let rec check_pattern_ env (pat : pattern) =\n+  match pat with\n+  | [] -> ()\n+  | (atom, opt_name) :: pat ->\n+      let new_env =\n+        match opt_name with\n+        | None -> env\n+        | Some name ->\n+            if List.mem name env then\n+              failwith (\"multiple atoms have the same name: \" ^ name)\n+            else\n+              name :: env\n+      in\n+      (match atom with\n+       | Any_symbol -> ()\n+       | Symbol _ -> ()\n+       | Ellipsis -> ()\n+       | Backref name ->\n+           if not (List.mem name env) then\n+             failwith (\"backreference to invalid name: \" ^ name)\n+      );\n+      check_pattern_ new_env pat\n+\n+let check_pattern pat =\n+  check_pattern_ [] pat\n+\n+(*\n+   Initialize the capture of symbols by an ellipsis.\n+   'init_acc' is a stack, holding symbols in reverse order.\n+*)\n+let init_ellipsis opt_name init_acc =\n+  match opt_name with\n+  | None -> Some None\n+  | Some name -> Some (Some (name, init_acc))\n+\n+let extend_ellipsis opt_ellipsis symbol =\n+  match opt_ellipsis with\n+  | None -> opt_ellipsis\n+  | Some None -> opt_ellipsis\n+  | Some (Some (name, acc)) -> Some (Some (name, symbol :: acc))\n+\n+let close_ellipsis opt_ellipsis env =\n+  match opt_ellipsis with\n+  | None -> env\n+  | Some None -> env\n+  | Some (Some (name, acc)) -> Env.add name (List.rev acc) env\n+\n+(*\n+   Extend the environment by adding captured subsequences:\n+   - add the named ellipsis that ended just before the current match,\n+     if applicable\n+   - add the named atom that was just matched, if applicable\n+*)\n+let extend env opt_ellipsis opt_name captured_sequence =\n+  let env =\n+    match opt_ellipsis with\n+    | None -> env       (* we were not in an ellipsis *)\n+    | Some None -> env  (* we were in an anonymous ellipsis *)\n+    | Some (Some (ellipsis_name, acc)) ->\n+        Env.add ellipsis_name (List.rev acc) env\n+  in\n+  match opt_name with\n+  | None -> env\n+  | Some name ->\n+      Env.add name captured_sequence env\n+\n+(*\n+   Turn a string into a list of chars.\n+*)\n+let parse s =\n+  let acc = ref [] in\n+  for i = String.length s - 1 downto 0 do\n+    acc := s.[i] :: !acc\n+  done;\n+  !acc\n+\n+let unparse l =\n+  let buf = Buffer.create (List.length l) in\n+  List.iter (Buffer.add_char buf) l;\n+  Buffer.contents buf\n+\n+let print_result oc opt_bindings =\n+  match opt_bindings with\n+  | None ->\n+      fprintf oc \"not a match\\n\"\n+  | Some l ->\n+      fprintf oc \"match: {\\n\";\n+      List.iter (fun (name, subseq) ->\n+        fprintf oc \"  %s: %S\\n\"\n+          name subseq\n+      ) l;\n+      fprintf oc \"}\\n\"\n+\n+(* to be appended to existing line *)\n+let print_ellipsis oc ellipsis =\n+  match ellipsis with\n+  | None -> ()\n+  | Some None -> fprintf oc \" in-ellipsis\"\n+  | Some (Some (name, acc)) ->\n+      fprintf oc \" in-ellipsis:%s:%S\" name (unparse (List.rev acc))\n+\n+(* to be appended to existing line *)\n+let print_env oc env =\n+  fprintf oc \" {\";\n+  let is_first = ref true in\n+  Env.bindings env\n+  |> List.iter (fun (name, subseq) ->\n+    if !is_first then\n+      is_first := false\n+    else\n+      fprintf oc \" \";\n+    fprintf oc \"%s:%S\"\n+      name\n+      (unparse subseq)\n+  );\n+  fprintf oc \"}\"\n+\n+(* to be appended to existing line *)\n+let print_pat_head oc pat =\n+  match pat with\n+  | [] ->\n+      fprintf oc \" _:''\"\n+  | (atom, opt_name) :: _ ->\n+      (match opt_name with\n+       | None -> fprintf oc \" _:\"\n+       | Some name -> fprintf oc \" %s:\" name\n+      );\n+      match atom with\n+      | Any_symbol -> fprintf oc \"_\"\n+      | Symbol c -> fprintf oc \"%C\" c\n+      | Ellipsis -> fprintf oc \"...\"\n+      | Backref name -> fprintf oc \"%s\" name\n+\n+(* to be appended to existing line *)\n+let print_input_head oc input =\n+  match input with\n+  | [] ->\n+      fprintf oc \" ''\"\n+  | symbol :: _ ->\n+      fprintf oc \" %C\" symbol\n+\n+let max_trace_lines = 100\n+\n+(* print single line *)\n+let trace_match_call ~trace stat ellipsis env pat input =\n+  let match_calls = stat.match_calls + 1 in\n+  stat.match_calls <- match_calls;\n+  if trace then\n+    if match_calls <= max_trace_lines then\n+      printf \"match%a%a%a%a\\n\"\n+        print_ellipsis ellipsis\n+        print_env env\n+        print_pat_head pat\n+        print_input_head input\n+    else if match_calls = max_trace_lines + 1 then\n+      printf \"[exceeded max trace lines = %i]\\n%!\" max_trace_lines\n+\n+module Cache_key = struct\n+  type t = ellipsis * env * pattern * input\n+\n+  let equal (ellipsis1, env1, pat1, input1) (ellipsis2, env2, pat2, input2) =\n+    (==) pat1 pat2\n+    && (==) input1 input2\n+    && ellipsis1 = ellipsis2\n+    && Env.equal (=) env1 env2\n+\n+  let hash_env env =\n+    Env.fold\n+      (fun k v h ->\n+         Hashtbl.hash_param 10 100 k\n+         + Hashtbl.hash_param 10 100 v\n+         + h)\n+      env 0\n+\n+  (*\n+     We define a custom hash function because the default one doesn't work\n+     on maps (two equal maps may have different tree structures).\n+\n+     OCaml's default 'Hashtbl.hash' is the same as 'Hashtbl.hash_param 10 100'.\n+     First parameter (10): maximum of number of meaningful nodes used\n+                           by the hashing function.\n+                           (int-like constants, floats, strings)\n+     Second parameter (100): maximum total number of nodes used by the hashing\n+                             function.\n+     See the documentation for the Hashtbl module for more info.\n+  *)\n+  let hash (ellipsis, env, pat, input) =\n+    Hashtbl.hash_param 10 100 ellipsis\n+    + Hashtbl.hash_param 10 100 pat\n+    + Hashtbl.hash_param 10 100 input\n+    + hash_env env\n+end\n+\n+module Memoize = struct\n+  module Tbl = Hashtbl.Make (Cache_key)\n+\n+  (* only use cache once in 3 times *)\n+  let cache_every = 3\n+\n+  let should_use_cache input =\n+    Hashtbl.hash_param 5 10 input mod cache_every = 0\n+\n+  let get tbl compute ellipsis env pat input =\n+    (* only use the cache on some inputs because it's expensive *)\n+    if should_use_cache input then\n+      let key = (ellipsis, env, pat, input) in\n+      match Tbl.find_opt tbl key with\n+      | None ->\n+          let res = compute ellipsis env pat input in\n+          Tbl.add tbl key res;\n+          res\n+      | Some res -> res\n+    else\n+      compute ellipsis env pat input\n+\n+  let create compute =\n+    (*\n+       Initial table size impact performance.\n+    *)\n+    let tbl = Tbl.create 8192 in\n+    fun ellipsis env pat input ->\n+      get tbl compute ellipsis env pat input\n+end\n+\n+(*\n+   Main matching function.\n+\n+   Checks if a pattern matches the entire input sequence.\n+   Returns the captured symbols or sequences of symbols for which a\n+   name was specified in the pattern.\n+*)\n+let match_input ?(trace = true) ?(cache = false) root_pat root_input =\n+  let stat = { match_calls = 0 } in\n+  let get_from_cache = ref (fun _ellipsis _env _pat _input -> assert false) in\n+\n+  let rec match_ (ellipsis : ellipsis) (env : env) pat input =\n+    trace_match_call ~trace stat ellipsis env pat input;\n+    !get_from_cache ellipsis env pat input\n+\n+  and uncached_match ellipsis env pat input =", "originalCommit": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0NzY1OA==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543147658", "bodyText": "Apparently either None when no match or a Some with a triplet with X, the environment, and the rest of the input.", "author": "aryx", "createdAt": "2020-12-15T08:38:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0Mzg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg0MDU3MQ==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543840571", "bodyText": "I clarified this", "author": "mjambon", "createdAt": "2020-12-16T02:28:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0Mzg2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0NjAxOA==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543146018", "bodyText": "Maybe a small comment saying that essentially the code below\nrecurse on the pattern list, and inside this recurse on the input list.", "author": "aryx", "createdAt": "2020-12-15T08:36:11Z", "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [\n+  Symbol 'A', None;\n+  Any_symbol, Some \"thing\";\n+  Ellipsis, None;\n+  Backref \"thing\", None;\n+]\n+\n+(*\n+   Unlike in semgrep syntax, we distinguish metavariable assignments\n+   from metavariable dereferencing.\n+\n+   This function checks that variable assignments are unique and that\n+   backreferences refer to a valid variable name.\n+\n+   This is a sanity check, not part of the matching algorithm.\n+*)\n+let rec check_pattern_ env (pat : pattern) =\n+  match pat with\n+  | [] -> ()\n+  | (atom, opt_name) :: pat ->\n+      let new_env =\n+        match opt_name with\n+        | None -> env\n+        | Some name ->\n+            if List.mem name env then\n+              failwith (\"multiple atoms have the same name: \" ^ name)\n+            else\n+              name :: env\n+      in\n+      (match atom with\n+       | Any_symbol -> ()\n+       | Symbol _ -> ()\n+       | Ellipsis -> ()\n+       | Backref name ->\n+           if not (List.mem name env) then\n+             failwith (\"backreference to invalid name: \" ^ name)\n+      );\n+      check_pattern_ new_env pat\n+\n+let check_pattern pat =\n+  check_pattern_ [] pat\n+\n+(*\n+   Initialize the capture of symbols by an ellipsis.\n+   'init_acc' is a stack, holding symbols in reverse order.\n+*)\n+let init_ellipsis opt_name init_acc =\n+  match opt_name with\n+  | None -> Some None\n+  | Some name -> Some (Some (name, init_acc))\n+\n+let extend_ellipsis opt_ellipsis symbol =\n+  match opt_ellipsis with\n+  | None -> opt_ellipsis\n+  | Some None -> opt_ellipsis\n+  | Some (Some (name, acc)) -> Some (Some (name, symbol :: acc))\n+\n+let close_ellipsis opt_ellipsis env =\n+  match opt_ellipsis with\n+  | None -> env\n+  | Some None -> env\n+  | Some (Some (name, acc)) -> Env.add name (List.rev acc) env\n+\n+(*\n+   Extend the environment by adding captured subsequences:\n+   - add the named ellipsis that ended just before the current match,\n+     if applicable\n+   - add the named atom that was just matched, if applicable\n+*)\n+let extend env opt_ellipsis opt_name captured_sequence =\n+  let env =\n+    match opt_ellipsis with\n+    | None -> env       (* we were not in an ellipsis *)\n+    | Some None -> env  (* we were in an anonymous ellipsis *)\n+    | Some (Some (ellipsis_name, acc)) ->\n+        Env.add ellipsis_name (List.rev acc) env\n+  in\n+  match opt_name with\n+  | None -> env\n+  | Some name ->\n+      Env.add name captured_sequence env\n+\n+(*\n+   Turn a string into a list of chars.\n+*)\n+let parse s =\n+  let acc = ref [] in\n+  for i = String.length s - 1 downto 0 do\n+    acc := s.[i] :: !acc\n+  done;\n+  !acc\n+\n+let unparse l =\n+  let buf = Buffer.create (List.length l) in\n+  List.iter (Buffer.add_char buf) l;\n+  Buffer.contents buf\n+\n+let print_result oc opt_bindings =\n+  match opt_bindings with\n+  | None ->\n+      fprintf oc \"not a match\\n\"\n+  | Some l ->\n+      fprintf oc \"match: {\\n\";\n+      List.iter (fun (name, subseq) ->\n+        fprintf oc \"  %s: %S\\n\"\n+          name subseq\n+      ) l;\n+      fprintf oc \"}\\n\"\n+\n+(* to be appended to existing line *)\n+let print_ellipsis oc ellipsis =\n+  match ellipsis with\n+  | None -> ()\n+  | Some None -> fprintf oc \" in-ellipsis\"\n+  | Some (Some (name, acc)) ->\n+      fprintf oc \" in-ellipsis:%s:%S\" name (unparse (List.rev acc))\n+\n+(* to be appended to existing line *)\n+let print_env oc env =\n+  fprintf oc \" {\";\n+  let is_first = ref true in\n+  Env.bindings env\n+  |> List.iter (fun (name, subseq) ->\n+    if !is_first then\n+      is_first := false\n+    else\n+      fprintf oc \" \";\n+    fprintf oc \"%s:%S\"\n+      name\n+      (unparse subseq)\n+  );\n+  fprintf oc \"}\"\n+\n+(* to be appended to existing line *)\n+let print_pat_head oc pat =\n+  match pat with\n+  | [] ->\n+      fprintf oc \" _:''\"\n+  | (atom, opt_name) :: _ ->\n+      (match opt_name with\n+       | None -> fprintf oc \" _:\"\n+       | Some name -> fprintf oc \" %s:\" name\n+      );\n+      match atom with\n+      | Any_symbol -> fprintf oc \"_\"\n+      | Symbol c -> fprintf oc \"%C\" c\n+      | Ellipsis -> fprintf oc \"...\"\n+      | Backref name -> fprintf oc \"%s\" name\n+\n+(* to be appended to existing line *)\n+let print_input_head oc input =\n+  match input with\n+  | [] ->\n+      fprintf oc \" ''\"\n+  | symbol :: _ ->\n+      fprintf oc \" %C\" symbol\n+\n+let max_trace_lines = 100\n+\n+(* print single line *)\n+let trace_match_call ~trace stat ellipsis env pat input =\n+  let match_calls = stat.match_calls + 1 in\n+  stat.match_calls <- match_calls;\n+  if trace then\n+    if match_calls <= max_trace_lines then\n+      printf \"match%a%a%a%a\\n\"\n+        print_ellipsis ellipsis\n+        print_env env\n+        print_pat_head pat\n+        print_input_head input\n+    else if match_calls = max_trace_lines + 1 then\n+      printf \"[exceeded max trace lines = %i]\\n%!\" max_trace_lines\n+\n+module Cache_key = struct\n+  type t = ellipsis * env * pattern * input\n+\n+  let equal (ellipsis1, env1, pat1, input1) (ellipsis2, env2, pat2, input2) =\n+    (==) pat1 pat2\n+    && (==) input1 input2\n+    && ellipsis1 = ellipsis2\n+    && Env.equal (=) env1 env2\n+\n+  let hash_env env =\n+    Env.fold\n+      (fun k v h ->\n+         Hashtbl.hash_param 10 100 k\n+         + Hashtbl.hash_param 10 100 v\n+         + h)\n+      env 0\n+\n+  (*\n+     We define a custom hash function because the default one doesn't work\n+     on maps (two equal maps may have different tree structures).\n+\n+     OCaml's default 'Hashtbl.hash' is the same as 'Hashtbl.hash_param 10 100'.\n+     First parameter (10): maximum of number of meaningful nodes used\n+                           by the hashing function.\n+                           (int-like constants, floats, strings)\n+     Second parameter (100): maximum total number of nodes used by the hashing\n+                             function.\n+     See the documentation for the Hashtbl module for more info.\n+  *)\n+  let hash (ellipsis, env, pat, input) =\n+    Hashtbl.hash_param 10 100 ellipsis\n+    + Hashtbl.hash_param 10 100 pat\n+    + Hashtbl.hash_param 10 100 input\n+    + hash_env env\n+end\n+\n+module Memoize = struct\n+  module Tbl = Hashtbl.Make (Cache_key)\n+\n+  (* only use cache once in 3 times *)\n+  let cache_every = 3\n+\n+  let should_use_cache input =\n+    Hashtbl.hash_param 5 10 input mod cache_every = 0\n+\n+  let get tbl compute ellipsis env pat input =\n+    (* only use the cache on some inputs because it's expensive *)\n+    if should_use_cache input then\n+      let key = (ellipsis, env, pat, input) in\n+      match Tbl.find_opt tbl key with\n+      | None ->\n+          let res = compute ellipsis env pat input in\n+          Tbl.add tbl key res;\n+          res\n+      | Some res -> res\n+    else\n+      compute ellipsis env pat input\n+\n+  let create compute =\n+    (*\n+       Initial table size impact performance.\n+    *)\n+    let tbl = Tbl.create 8192 in\n+    fun ellipsis env pat input ->\n+      get tbl compute ellipsis env pat input\n+end\n+\n+(*\n+   Main matching function.\n+\n+   Checks if a pattern matches the entire input sequence.\n+   Returns the captured symbols or sequences of symbols for which a\n+   name was specified in the pattern.", "originalCommit": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzg0MDM0OQ==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543840349", "bodyText": "done", "author": "mjambon", "createdAt": "2020-12-16T02:28:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0NjAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0NjU4MA==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543146580", "bodyText": "Maybe better to be explicit here, given there's not so many cases in pattern_atom:\n| Any_symbol  | Symbol _ -> None", "author": "aryx", "createdAt": "2020-12-15T08:36:59Z", "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [\n+  Symbol 'A', None;\n+  Any_symbol, Some \"thing\";\n+  Ellipsis, None;\n+  Backref \"thing\", None;\n+]\n+\n+(*\n+   Unlike in semgrep syntax, we distinguish metavariable assignments\n+   from metavariable dereferencing.\n+\n+   This function checks that variable assignments are unique and that\n+   backreferences refer to a valid variable name.\n+\n+   This is a sanity check, not part of the matching algorithm.\n+*)\n+let rec check_pattern_ env (pat : pattern) =\n+  match pat with\n+  | [] -> ()\n+  | (atom, opt_name) :: pat ->\n+      let new_env =\n+        match opt_name with\n+        | None -> env\n+        | Some name ->\n+            if List.mem name env then\n+              failwith (\"multiple atoms have the same name: \" ^ name)\n+            else\n+              name :: env\n+      in\n+      (match atom with\n+       | Any_symbol -> ()\n+       | Symbol _ -> ()\n+       | Ellipsis -> ()\n+       | Backref name ->\n+           if not (List.mem name env) then\n+             failwith (\"backreference to invalid name: \" ^ name)\n+      );\n+      check_pattern_ new_env pat\n+\n+let check_pattern pat =\n+  check_pattern_ [] pat\n+\n+(*\n+   Initialize the capture of symbols by an ellipsis.\n+   'init_acc' is a stack, holding symbols in reverse order.\n+*)\n+let init_ellipsis opt_name init_acc =\n+  match opt_name with\n+  | None -> Some None\n+  | Some name -> Some (Some (name, init_acc))\n+\n+let extend_ellipsis opt_ellipsis symbol =\n+  match opt_ellipsis with\n+  | None -> opt_ellipsis\n+  | Some None -> opt_ellipsis\n+  | Some (Some (name, acc)) -> Some (Some (name, symbol :: acc))\n+\n+let close_ellipsis opt_ellipsis env =\n+  match opt_ellipsis with\n+  | None -> env\n+  | Some None -> env\n+  | Some (Some (name, acc)) -> Env.add name (List.rev acc) env\n+\n+(*\n+   Extend the environment by adding captured subsequences:\n+   - add the named ellipsis that ended just before the current match,\n+     if applicable\n+   - add the named atom that was just matched, if applicable\n+*)\n+let extend env opt_ellipsis opt_name captured_sequence =\n+  let env =\n+    match opt_ellipsis with\n+    | None -> env       (* we were not in an ellipsis *)\n+    | Some None -> env  (* we were in an anonymous ellipsis *)\n+    | Some (Some (ellipsis_name, acc)) ->\n+        Env.add ellipsis_name (List.rev acc) env\n+  in\n+  match opt_name with\n+  | None -> env\n+  | Some name ->\n+      Env.add name captured_sequence env\n+\n+(*\n+   Turn a string into a list of chars.\n+*)\n+let parse s =\n+  let acc = ref [] in\n+  for i = String.length s - 1 downto 0 do\n+    acc := s.[i] :: !acc\n+  done;\n+  !acc\n+\n+let unparse l =\n+  let buf = Buffer.create (List.length l) in\n+  List.iter (Buffer.add_char buf) l;\n+  Buffer.contents buf\n+\n+let print_result oc opt_bindings =\n+  match opt_bindings with\n+  | None ->\n+      fprintf oc \"not a match\\n\"\n+  | Some l ->\n+      fprintf oc \"match: {\\n\";\n+      List.iter (fun (name, subseq) ->\n+        fprintf oc \"  %s: %S\\n\"\n+          name subseq\n+      ) l;\n+      fprintf oc \"}\\n\"\n+\n+(* to be appended to existing line *)\n+let print_ellipsis oc ellipsis =\n+  match ellipsis with\n+  | None -> ()\n+  | Some None -> fprintf oc \" in-ellipsis\"\n+  | Some (Some (name, acc)) ->\n+      fprintf oc \" in-ellipsis:%s:%S\" name (unparse (List.rev acc))\n+\n+(* to be appended to existing line *)\n+let print_env oc env =\n+  fprintf oc \" {\";\n+  let is_first = ref true in\n+  Env.bindings env\n+  |> List.iter (fun (name, subseq) ->\n+    if !is_first then\n+      is_first := false\n+    else\n+      fprintf oc \" \";\n+    fprintf oc \"%s:%S\"\n+      name\n+      (unparse subseq)\n+  );\n+  fprintf oc \"}\"\n+\n+(* to be appended to existing line *)\n+let print_pat_head oc pat =\n+  match pat with\n+  | [] ->\n+      fprintf oc \" _:''\"\n+  | (atom, opt_name) :: _ ->\n+      (match opt_name with\n+       | None -> fprintf oc \" _:\"\n+       | Some name -> fprintf oc \" %s:\" name\n+      );\n+      match atom with\n+      | Any_symbol -> fprintf oc \"_\"\n+      | Symbol c -> fprintf oc \"%C\" c\n+      | Ellipsis -> fprintf oc \"...\"\n+      | Backref name -> fprintf oc \"%s\" name\n+\n+(* to be appended to existing line *)\n+let print_input_head oc input =\n+  match input with\n+  | [] ->\n+      fprintf oc \" ''\"\n+  | symbol :: _ ->\n+      fprintf oc \" %C\" symbol\n+\n+let max_trace_lines = 100\n+\n+(* print single line *)\n+let trace_match_call ~trace stat ellipsis env pat input =\n+  let match_calls = stat.match_calls + 1 in\n+  stat.match_calls <- match_calls;\n+  if trace then\n+    if match_calls <= max_trace_lines then\n+      printf \"match%a%a%a%a\\n\"\n+        print_ellipsis ellipsis\n+        print_env env\n+        print_pat_head pat\n+        print_input_head input\n+    else if match_calls = max_trace_lines + 1 then\n+      printf \"[exceeded max trace lines = %i]\\n%!\" max_trace_lines\n+\n+module Cache_key = struct\n+  type t = ellipsis * env * pattern * input\n+\n+  let equal (ellipsis1, env1, pat1, input1) (ellipsis2, env2, pat2, input2) =\n+    (==) pat1 pat2\n+    && (==) input1 input2\n+    && ellipsis1 = ellipsis2\n+    && Env.equal (=) env1 env2\n+\n+  let hash_env env =\n+    Env.fold\n+      (fun k v h ->\n+         Hashtbl.hash_param 10 100 k\n+         + Hashtbl.hash_param 10 100 v\n+         + h)\n+      env 0\n+\n+  (*\n+     We define a custom hash function because the default one doesn't work\n+     on maps (two equal maps may have different tree structures).\n+\n+     OCaml's default 'Hashtbl.hash' is the same as 'Hashtbl.hash_param 10 100'.\n+     First parameter (10): maximum of number of meaningful nodes used\n+                           by the hashing function.\n+                           (int-like constants, floats, strings)\n+     Second parameter (100): maximum total number of nodes used by the hashing\n+                             function.\n+     See the documentation for the Hashtbl module for more info.\n+  *)\n+  let hash (ellipsis, env, pat, input) =\n+    Hashtbl.hash_param 10 100 ellipsis\n+    + Hashtbl.hash_param 10 100 pat\n+    + Hashtbl.hash_param 10 100 input\n+    + hash_env env\n+end\n+\n+module Memoize = struct\n+  module Tbl = Hashtbl.Make (Cache_key)\n+\n+  (* only use cache once in 3 times *)\n+  let cache_every = 3\n+\n+  let should_use_cache input =\n+    Hashtbl.hash_param 5 10 input mod cache_every = 0\n+\n+  let get tbl compute ellipsis env pat input =\n+    (* only use the cache on some inputs because it's expensive *)\n+    if should_use_cache input then\n+      let key = (ellipsis, env, pat, input) in\n+      match Tbl.find_opt tbl key with\n+      | None ->\n+          let res = compute ellipsis env pat input in\n+          Tbl.add tbl key res;\n+          res\n+      | Some res -> res\n+    else\n+      compute ellipsis env pat input\n+\n+  let create compute =\n+    (*\n+       Initial table size impact performance.\n+    *)\n+    let tbl = Tbl.create 8192 in\n+    fun ellipsis env pat input ->\n+      get tbl compute ellipsis env pat input\n+end\n+\n+(*\n+   Main matching function.\n+\n+   Checks if a pattern matches the entire input sequence.\n+   Returns the captured symbols or sequences of symbols for which a\n+   name was specified in the pattern.\n+*)\n+let match_input ?(trace = true) ?(cache = false) root_pat root_input =\n+  let stat = { match_calls = 0 } in\n+  let get_from_cache = ref (fun _ellipsis _env _pat _input -> assert false) in\n+\n+  let rec match_ (ellipsis : ellipsis) (env : env) pat input =\n+    trace_match_call ~trace stat ellipsis env pat input;\n+    !get_from_cache ellipsis env pat input\n+\n+  and uncached_match ellipsis env pat input =\n+    let orig_pat = pat in\n+    let orig_input = input in\n+    let in_ellipsis = ellipsis <> None in\n+    match pat with\n+    | [] ->\n+        (match input with\n+         | [] ->\n+             let env = close_ellipsis ellipsis env in\n+             Some env\n+         | symbol :: input ->\n+             if in_ellipsis then\n+               let ellipsis = extend_ellipsis ellipsis symbol in\n+               match_ ellipsis env orig_pat input\n+             else\n+               None\n+        )\n+    | (pat_atom, opt_name) :: pat ->\n+        match input with\n+        | [] ->\n+            (* end of input, only empty sequence can match *)\n+            (match pat_atom with\n+             | Ellipsis ->\n+                 let env = extend env ellipsis opt_name [] in\n+                 match_ (init_ellipsis opt_name []) env pat input\n+             | Backref name ->\n+                 (match Env.find_opt name env with\n+                  | Some [] ->\n+                      let env = extend env ellipsis opt_name [] in\n+                      match_ None env pat input\n+                  | _ ->\n+                      None\n+                 )\n+             | _ -> None", "originalCommit": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgzODAzNQ==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543838035", "bodyText": "done", "author": "mjambon", "createdAt": "2020-12-16T02:25:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0NjU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1MTQ0Nw==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543151447", "bodyText": "Would be great to have an example where I can understand how memoizing would improve the performance.\nOn your sample_pattern, with a simple input like A B C C C C C C C C B C C\nwhy do we avoid redoing the same work thx to memoization?", "author": "aryx", "createdAt": "2020-12-15T08:44:24Z", "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [\n+  Symbol 'A', None;\n+  Any_symbol, Some \"thing\";\n+  Ellipsis, None;\n+  Backref \"thing\", None;\n+]\n+\n+(*\n+   Unlike in semgrep syntax, we distinguish metavariable assignments\n+   from metavariable dereferencing.\n+\n+   This function checks that variable assignments are unique and that\n+   backreferences refer to a valid variable name.\n+\n+   This is a sanity check, not part of the matching algorithm.\n+*)\n+let rec check_pattern_ env (pat : pattern) =\n+  match pat with\n+  | [] -> ()\n+  | (atom, opt_name) :: pat ->\n+      let new_env =\n+        match opt_name with\n+        | None -> env\n+        | Some name ->\n+            if List.mem name env then\n+              failwith (\"multiple atoms have the same name: \" ^ name)\n+            else\n+              name :: env\n+      in\n+      (match atom with\n+       | Any_symbol -> ()\n+       | Symbol _ -> ()\n+       | Ellipsis -> ()\n+       | Backref name ->\n+           if not (List.mem name env) then\n+             failwith (\"backreference to invalid name: \" ^ name)\n+      );\n+      check_pattern_ new_env pat\n+\n+let check_pattern pat =\n+  check_pattern_ [] pat\n+\n+(*\n+   Initialize the capture of symbols by an ellipsis.\n+   'init_acc' is a stack, holding symbols in reverse order.\n+*)\n+let init_ellipsis opt_name init_acc =\n+  match opt_name with\n+  | None -> Some None\n+  | Some name -> Some (Some (name, init_acc))\n+\n+let extend_ellipsis opt_ellipsis symbol =\n+  match opt_ellipsis with\n+  | None -> opt_ellipsis\n+  | Some None -> opt_ellipsis\n+  | Some (Some (name, acc)) -> Some (Some (name, symbol :: acc))\n+\n+let close_ellipsis opt_ellipsis env =\n+  match opt_ellipsis with\n+  | None -> env\n+  | Some None -> env\n+  | Some (Some (name, acc)) -> Env.add name (List.rev acc) env\n+\n+(*\n+   Extend the environment by adding captured subsequences:\n+   - add the named ellipsis that ended just before the current match,\n+     if applicable\n+   - add the named atom that was just matched, if applicable\n+*)\n+let extend env opt_ellipsis opt_name captured_sequence =\n+  let env =\n+    match opt_ellipsis with\n+    | None -> env       (* we were not in an ellipsis *)\n+    | Some None -> env  (* we were in an anonymous ellipsis *)\n+    | Some (Some (ellipsis_name, acc)) ->\n+        Env.add ellipsis_name (List.rev acc) env\n+  in\n+  match opt_name with\n+  | None -> env\n+  | Some name ->\n+      Env.add name captured_sequence env\n+\n+(*\n+   Turn a string into a list of chars.\n+*)\n+let parse s =\n+  let acc = ref [] in\n+  for i = String.length s - 1 downto 0 do\n+    acc := s.[i] :: !acc\n+  done;\n+  !acc\n+\n+let unparse l =\n+  let buf = Buffer.create (List.length l) in\n+  List.iter (Buffer.add_char buf) l;\n+  Buffer.contents buf\n+\n+let print_result oc opt_bindings =\n+  match opt_bindings with\n+  | None ->\n+      fprintf oc \"not a match\\n\"\n+  | Some l ->\n+      fprintf oc \"match: {\\n\";\n+      List.iter (fun (name, subseq) ->\n+        fprintf oc \"  %s: %S\\n\"\n+          name subseq\n+      ) l;\n+      fprintf oc \"}\\n\"\n+\n+(* to be appended to existing line *)\n+let print_ellipsis oc ellipsis =\n+  match ellipsis with\n+  | None -> ()\n+  | Some None -> fprintf oc \" in-ellipsis\"\n+  | Some (Some (name, acc)) ->\n+      fprintf oc \" in-ellipsis:%s:%S\" name (unparse (List.rev acc))\n+\n+(* to be appended to existing line *)\n+let print_env oc env =\n+  fprintf oc \" {\";\n+  let is_first = ref true in\n+  Env.bindings env\n+  |> List.iter (fun (name, subseq) ->\n+    if !is_first then\n+      is_first := false\n+    else\n+      fprintf oc \" \";\n+    fprintf oc \"%s:%S\"\n+      name\n+      (unparse subseq)\n+  );\n+  fprintf oc \"}\"\n+\n+(* to be appended to existing line *)\n+let print_pat_head oc pat =\n+  match pat with\n+  | [] ->\n+      fprintf oc \" _:''\"\n+  | (atom, opt_name) :: _ ->\n+      (match opt_name with\n+       | None -> fprintf oc \" _:\"\n+       | Some name -> fprintf oc \" %s:\" name\n+      );\n+      match atom with\n+      | Any_symbol -> fprintf oc \"_\"\n+      | Symbol c -> fprintf oc \"%C\" c\n+      | Ellipsis -> fprintf oc \"...\"\n+      | Backref name -> fprintf oc \"%s\" name\n+\n+(* to be appended to existing line *)\n+let print_input_head oc input =\n+  match input with\n+  | [] ->\n+      fprintf oc \" ''\"\n+  | symbol :: _ ->\n+      fprintf oc \" %C\" symbol\n+\n+let max_trace_lines = 100\n+\n+(* print single line *)\n+let trace_match_call ~trace stat ellipsis env pat input =\n+  let match_calls = stat.match_calls + 1 in\n+  stat.match_calls <- match_calls;\n+  if trace then\n+    if match_calls <= max_trace_lines then\n+      printf \"match%a%a%a%a\\n\"\n+        print_ellipsis ellipsis\n+        print_env env\n+        print_pat_head pat\n+        print_input_head input\n+    else if match_calls = max_trace_lines + 1 then\n+      printf \"[exceeded max trace lines = %i]\\n%!\" max_trace_lines\n+\n+module Cache_key = struct\n+  type t = ellipsis * env * pattern * input\n+\n+  let equal (ellipsis1, env1, pat1, input1) (ellipsis2, env2, pat2, input2) =\n+    (==) pat1 pat2\n+    && (==) input1 input2\n+    && ellipsis1 = ellipsis2\n+    && Env.equal (=) env1 env2\n+\n+  let hash_env env =\n+    Env.fold\n+      (fun k v h ->\n+         Hashtbl.hash_param 10 100 k\n+         + Hashtbl.hash_param 10 100 v\n+         + h)\n+      env 0\n+\n+  (*\n+     We define a custom hash function because the default one doesn't work\n+     on maps (two equal maps may have different tree structures).\n+\n+     OCaml's default 'Hashtbl.hash' is the same as 'Hashtbl.hash_param 10 100'.\n+     First parameter (10): maximum of number of meaningful nodes used\n+                           by the hashing function.\n+                           (int-like constants, floats, strings)\n+     Second parameter (100): maximum total number of nodes used by the hashing\n+                             function.\n+     See the documentation for the Hashtbl module for more info.\n+  *)\n+  let hash (ellipsis, env, pat, input) =\n+    Hashtbl.hash_param 10 100 ellipsis\n+    + Hashtbl.hash_param 10 100 pat\n+    + Hashtbl.hash_param 10 100 input\n+    + hash_env env\n+end\n+\n+module Memoize = struct\n+  module Tbl = Hashtbl.Make (Cache_key)\n+\n+  (* only use cache once in 3 times *)\n+  let cache_every = 3\n+\n+  let should_use_cache input =\n+    Hashtbl.hash_param 5 10 input mod cache_every = 0\n+\n+  let get tbl compute ellipsis env pat input =\n+    (* only use the cache on some inputs because it's expensive *)\n+    if should_use_cache input then\n+      let key = (ellipsis, env, pat, input) in\n+      match Tbl.find_opt tbl key with\n+      | None ->\n+          let res = compute ellipsis env pat input in\n+          Tbl.add tbl key res;\n+          res\n+      | Some res -> res\n+    else\n+      compute ellipsis env pat input\n+\n+  let create compute =\n+    (*\n+       Initial table size impact performance.\n+    *)\n+    let tbl = Tbl.create 8192 in\n+    fun ellipsis env pat input ->\n+      get tbl compute ellipsis env pat input\n+end\n+\n+(*\n+   Main matching function.\n+\n+   Checks if a pattern matches the entire input sequence.\n+   Returns the captured symbols or sequences of symbols for which a\n+   name was specified in the pattern.\n+*)\n+let match_input ?(trace = true) ?(cache = false) root_pat root_input =\n+  let stat = { match_calls = 0 } in\n+  let get_from_cache = ref (fun _ellipsis _env _pat _input -> assert false) in\n+\n+  let rec match_ (ellipsis : ellipsis) (env : env) pat input =\n+    trace_match_call ~trace stat ellipsis env pat input;\n+    !get_from_cache ellipsis env pat input\n+\n+  and uncached_match ellipsis env pat input =\n+    let orig_pat = pat in\n+    let orig_input = input in\n+    let in_ellipsis = ellipsis <> None in\n+    match pat with\n+    | [] ->\n+        (match input with\n+         | [] ->\n+             let env = close_ellipsis ellipsis env in\n+             Some env\n+         | symbol :: input ->\n+             if in_ellipsis then\n+               let ellipsis = extend_ellipsis ellipsis symbol in\n+               match_ ellipsis env orig_pat input\n+             else\n+               None\n+        )\n+    | (pat_atom, opt_name) :: pat ->\n+        match input with\n+        | [] ->\n+            (* end of input, only empty sequence can match *)\n+            (match pat_atom with\n+             | Ellipsis ->\n+                 let env = extend env ellipsis opt_name [] in\n+                 match_ (init_ellipsis opt_name []) env pat input\n+             | Backref name ->\n+                 (match Env.find_opt name env with\n+                  | Some [] ->\n+                      let env = extend env ellipsis opt_name [] in\n+                      match_ None env pat input\n+                  | _ ->\n+                      None\n+                 )\n+             | _ -> None\n+            )\n+        | symbol :: input ->\n+            let head_match =\n+              match pat_atom with\n+              | Any_symbol ->\n+                  let env = extend env ellipsis opt_name [symbol] in\n+                  Some (None, env, input)\n+              | Symbol x ->\n+                  if x = symbol then\n+                    let env = extend env ellipsis opt_name [symbol] in\n+                    Some (None, env, input)\n+                  else\n+                    None\n+              | Ellipsis ->\n+                  (* start new ellipsis but don't consume first symbol *)\n+                  let env = close_ellipsis ellipsis env in\n+                  Some (init_ellipsis opt_name [], env, orig_input)\n+              | Backref name ->\n+                  (match Env.find_opt name env with\n+                   | Some [symbol0] when symbol0 = symbol ->\n+                       let env = extend env ellipsis opt_name [symbol] in\n+                       Some (None, env, input)\n+                   | _ ->\n+                       None\n+                  )\n+            in\n+            let matches_here =\n+              match head_match with\n+              | None -> None\n+              | Some (ellipsis, env, input) ->\n+                  (* match the rest of the pattern with the rest of the\n+                     input *)\n+                  match_ ellipsis env pat input\n+            in\n+            match matches_here with\n+            | Some _ as x -> x\n+            | None ->\n+                if in_ellipsis then\n+                  (* skip input symbol and retry *)\n+                  let ellipsis = extend_ellipsis ellipsis symbol in\n+                  match_ ellipsis env orig_pat input\n+                else\n+                  None\n+  in\n+  if cache then\n+    get_from_cache := Memoize.create uncached_match", "originalCommit": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgzNjk5NQ==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543836995", "bodyText": "This is a lot harder to explain than I thought. See other my comment. Best illustration is a trace.", "author": "mjambon", "createdAt": "2020-12-16T02:23:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1MTQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1MjkyMw==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543152923", "bodyText": "This is great!", "author": "aryx", "createdAt": "2020-12-15T08:46:41Z", "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [\n+  Symbol 'A', None;\n+  Any_symbol, Some \"thing\";\n+  Ellipsis, None;\n+  Backref \"thing\", None;\n+]\n+\n+(*\n+   Unlike in semgrep syntax, we distinguish metavariable assignments\n+   from metavariable dereferencing.\n+\n+   This function checks that variable assignments are unique and that\n+   backreferences refer to a valid variable name.\n+\n+   This is a sanity check, not part of the matching algorithm.\n+*)\n+let rec check_pattern_ env (pat : pattern) =\n+  match pat with\n+  | [] -> ()\n+  | (atom, opt_name) :: pat ->\n+      let new_env =\n+        match opt_name with\n+        | None -> env\n+        | Some name ->\n+            if List.mem name env then\n+              failwith (\"multiple atoms have the same name: \" ^ name)\n+            else\n+              name :: env\n+      in\n+      (match atom with\n+       | Any_symbol -> ()\n+       | Symbol _ -> ()\n+       | Ellipsis -> ()\n+       | Backref name ->\n+           if not (List.mem name env) then\n+             failwith (\"backreference to invalid name: \" ^ name)\n+      );\n+      check_pattern_ new_env pat\n+\n+let check_pattern pat =\n+  check_pattern_ [] pat\n+\n+(*\n+   Initialize the capture of symbols by an ellipsis.\n+   'init_acc' is a stack, holding symbols in reverse order.\n+*)\n+let init_ellipsis opt_name init_acc =\n+  match opt_name with\n+  | None -> Some None\n+  | Some name -> Some (Some (name, init_acc))\n+\n+let extend_ellipsis opt_ellipsis symbol =\n+  match opt_ellipsis with\n+  | None -> opt_ellipsis\n+  | Some None -> opt_ellipsis\n+  | Some (Some (name, acc)) -> Some (Some (name, symbol :: acc))\n+\n+let close_ellipsis opt_ellipsis env =\n+  match opt_ellipsis with\n+  | None -> env\n+  | Some None -> env\n+  | Some (Some (name, acc)) -> Env.add name (List.rev acc) env\n+\n+(*\n+   Extend the environment by adding captured subsequences:\n+   - add the named ellipsis that ended just before the current match,\n+     if applicable\n+   - add the named atom that was just matched, if applicable\n+*)\n+let extend env opt_ellipsis opt_name captured_sequence =\n+  let env =\n+    match opt_ellipsis with\n+    | None -> env       (* we were not in an ellipsis *)\n+    | Some None -> env  (* we were in an anonymous ellipsis *)\n+    | Some (Some (ellipsis_name, acc)) ->\n+        Env.add ellipsis_name (List.rev acc) env\n+  in\n+  match opt_name with\n+  | None -> env\n+  | Some name ->\n+      Env.add name captured_sequence env\n+\n+(*\n+   Turn a string into a list of chars.\n+*)\n+let parse s =\n+  let acc = ref [] in\n+  for i = String.length s - 1 downto 0 do\n+    acc := s.[i] :: !acc\n+  done;\n+  !acc\n+\n+let unparse l =\n+  let buf = Buffer.create (List.length l) in\n+  List.iter (Buffer.add_char buf) l;\n+  Buffer.contents buf\n+\n+let print_result oc opt_bindings =\n+  match opt_bindings with\n+  | None ->\n+      fprintf oc \"not a match\\n\"\n+  | Some l ->\n+      fprintf oc \"match: {\\n\";\n+      List.iter (fun (name, subseq) ->\n+        fprintf oc \"  %s: %S\\n\"\n+          name subseq\n+      ) l;\n+      fprintf oc \"}\\n\"\n+\n+(* to be appended to existing line *)\n+let print_ellipsis oc ellipsis =\n+  match ellipsis with\n+  | None -> ()\n+  | Some None -> fprintf oc \" in-ellipsis\"\n+  | Some (Some (name, acc)) ->\n+      fprintf oc \" in-ellipsis:%s:%S\" name (unparse (List.rev acc))\n+\n+(* to be appended to existing line *)\n+let print_env oc env =\n+  fprintf oc \" {\";\n+  let is_first = ref true in\n+  Env.bindings env\n+  |> List.iter (fun (name, subseq) ->\n+    if !is_first then\n+      is_first := false\n+    else\n+      fprintf oc \" \";\n+    fprintf oc \"%s:%S\"\n+      name\n+      (unparse subseq)\n+  );\n+  fprintf oc \"}\"\n+\n+(* to be appended to existing line *)\n+let print_pat_head oc pat =\n+  match pat with\n+  | [] ->\n+      fprintf oc \" _:''\"\n+  | (atom, opt_name) :: _ ->\n+      (match opt_name with\n+       | None -> fprintf oc \" _:\"\n+       | Some name -> fprintf oc \" %s:\" name\n+      );\n+      match atom with\n+      | Any_symbol -> fprintf oc \"_\"\n+      | Symbol c -> fprintf oc \"%C\" c\n+      | Ellipsis -> fprintf oc \"...\"\n+      | Backref name -> fprintf oc \"%s\" name\n+\n+(* to be appended to existing line *)\n+let print_input_head oc input =\n+  match input with\n+  | [] ->\n+      fprintf oc \" ''\"\n+  | symbol :: _ ->\n+      fprintf oc \" %C\" symbol\n+\n+let max_trace_lines = 100\n+\n+(* print single line *)\n+let trace_match_call ~trace stat ellipsis env pat input =\n+  let match_calls = stat.match_calls + 1 in\n+  stat.match_calls <- match_calls;\n+  if trace then\n+    if match_calls <= max_trace_lines then\n+      printf \"match%a%a%a%a\\n\"\n+        print_ellipsis ellipsis\n+        print_env env\n+        print_pat_head pat\n+        print_input_head input\n+    else if match_calls = max_trace_lines + 1 then\n+      printf \"[exceeded max trace lines = %i]\\n%!\" max_trace_lines\n+\n+module Cache_key = struct\n+  type t = ellipsis * env * pattern * input\n+\n+  let equal (ellipsis1, env1, pat1, input1) (ellipsis2, env2, pat2, input2) =\n+    (==) pat1 pat2\n+    && (==) input1 input2\n+    && ellipsis1 = ellipsis2\n+    && Env.equal (=) env1 env2\n+\n+  let hash_env env =\n+    Env.fold\n+      (fun k v h ->\n+         Hashtbl.hash_param 10 100 k\n+         + Hashtbl.hash_param 10 100 v\n+         + h)\n+      env 0\n+\n+  (*\n+     We define a custom hash function because the default one doesn't work\n+     on maps (two equal maps may have different tree structures).\n+\n+     OCaml's default 'Hashtbl.hash' is the same as 'Hashtbl.hash_param 10 100'.\n+     First parameter (10): maximum of number of meaningful nodes used\n+                           by the hashing function.\n+                           (int-like constants, floats, strings)\n+     Second parameter (100): maximum total number of nodes used by the hashing\n+                             function.\n+     See the documentation for the Hashtbl module for more info.\n+  *)\n+  let hash (ellipsis, env, pat, input) =\n+    Hashtbl.hash_param 10 100 ellipsis\n+    + Hashtbl.hash_param 10 100 pat\n+    + Hashtbl.hash_param 10 100 input\n+    + hash_env env\n+end\n+\n+module Memoize = struct\n+  module Tbl = Hashtbl.Make (Cache_key)\n+\n+  (* only use cache once in 3 times *)\n+  let cache_every = 3\n+\n+  let should_use_cache input =\n+    Hashtbl.hash_param 5 10 input mod cache_every = 0\n+\n+  let get tbl compute ellipsis env pat input =\n+    (* only use the cache on some inputs because it's expensive *)\n+    if should_use_cache input then\n+      let key = (ellipsis, env, pat, input) in\n+      match Tbl.find_opt tbl key with\n+      | None ->\n+          let res = compute ellipsis env pat input in\n+          Tbl.add tbl key res;\n+          res\n+      | Some res -> res\n+    else\n+      compute ellipsis env pat input\n+\n+  let create compute =\n+    (*\n+       Initial table size impact performance.\n+    *)\n+    let tbl = Tbl.create 8192 in\n+    fun ellipsis env pat input ->\n+      get tbl compute ellipsis env pat input\n+end\n+\n+(*\n+   Main matching function.\n+\n+   Checks if a pattern matches the entire input sequence.\n+   Returns the captured symbols or sequences of symbols for which a\n+   name was specified in the pattern.\n+*)\n+let match_input ?(trace = true) ?(cache = false) root_pat root_input =\n+  let stat = { match_calls = 0 } in\n+  let get_from_cache = ref (fun _ellipsis _env _pat _input -> assert false) in\n+\n+  let rec match_ (ellipsis : ellipsis) (env : env) pat input =\n+    trace_match_call ~trace stat ellipsis env pat input;\n+    !get_from_cache ellipsis env pat input\n+\n+  and uncached_match ellipsis env pat input =\n+    let orig_pat = pat in\n+    let orig_input = input in\n+    let in_ellipsis = ellipsis <> None in\n+    match pat with\n+    | [] ->\n+        (match input with\n+         | [] ->\n+             let env = close_ellipsis ellipsis env in\n+             Some env\n+         | symbol :: input ->\n+             if in_ellipsis then\n+               let ellipsis = extend_ellipsis ellipsis symbol in\n+               match_ ellipsis env orig_pat input\n+             else\n+               None\n+        )\n+    | (pat_atom, opt_name) :: pat ->\n+        match input with\n+        | [] ->\n+            (* end of input, only empty sequence can match *)\n+            (match pat_atom with\n+             | Ellipsis ->\n+                 let env = extend env ellipsis opt_name [] in\n+                 match_ (init_ellipsis opt_name []) env pat input\n+             | Backref name ->\n+                 (match Env.find_opt name env with\n+                  | Some [] ->\n+                      let env = extend env ellipsis opt_name [] in\n+                      match_ None env pat input\n+                  | _ ->\n+                      None\n+                 )\n+             | _ -> None\n+            )\n+        | symbol :: input ->\n+            let head_match =\n+              match pat_atom with\n+              | Any_symbol ->\n+                  let env = extend env ellipsis opt_name [symbol] in\n+                  Some (None, env, input)\n+              | Symbol x ->\n+                  if x = symbol then\n+                    let env = extend env ellipsis opt_name [symbol] in\n+                    Some (None, env, input)\n+                  else\n+                    None\n+              | Ellipsis ->\n+                  (* start new ellipsis but don't consume first symbol *)\n+                  let env = close_ellipsis ellipsis env in\n+                  Some (init_ellipsis opt_name [], env, orig_input)\n+              | Backref name ->\n+                  (match Env.find_opt name env with\n+                   | Some [symbol0] when symbol0 = symbol ->\n+                       let env = extend env ellipsis opt_name [symbol] in\n+                       Some (None, env, input)\n+                   | _ ->\n+                       None\n+                  )\n+            in\n+            let matches_here =\n+              match head_match with\n+              | None -> None\n+              | Some (ellipsis, env, input) ->\n+                  (* match the rest of the pattern with the rest of the\n+                     input *)\n+                  match_ ellipsis env pat input\n+            in\n+            match matches_here with\n+            | Some _ as x -> x\n+            | None ->\n+                if in_ellipsis then\n+                  (* skip input symbol and retry *)\n+                  let ellipsis = extend_ellipsis ellipsis symbol in\n+                  match_ ellipsis env orig_pat input\n+                else\n+                  None\n+  in\n+  if cache then\n+    get_from_cache := Memoize.create uncached_match\n+  else\n+    get_from_cache := uncached_match;\n+\n+  let opt_captures =\n+    match match_ None Env.empty root_pat root_input with\n+    | None -> None\n+    | Some env -> Some (Env.bindings env)\n+  in\n+  opt_captures, stat\n+\n+(********** Tests **********)\n+\n+let print_time name f =\n+  let t1 = Unix.gettimeofday () in\n+  let res = f () in\n+  let t2 = Unix.gettimeofday () in\n+  printf \"%s: %.6f s\\n%!\" name (t2 -. t1);\n+  res\n+\n+let check_match ?cache pat input_str expected_opt_bindings =\n+  let sort = Option.map (List.sort compare) in\n+  let normalize opt_bindings =\n+    Option.map (fun bindings ->\n+      List.map (fun (var, symbols) -> (var, unparse symbols)) bindings\n+    ) opt_bindings\n+    |> sort\n+  in\n+  check_pattern pat;\n+  let input = parse input_str in\n+  let expected = sort expected_opt_bindings in\n+  let actual =\n+    let res, stat =\n+      print_time \"match function\" (fun () ->\n+        match_input ?cache pat input\n+      )\n+    in\n+    printf \"input length: %i\\n\" (String.length input_str);\n+    printf \"number of calls to the match function: %i\\n\" stat.match_calls;\n+    normalize res\n+  in\n+  print_result stdout actual;\n+  Alcotest.(check bool) \"equal\" true (expected = actual)\n+\n+let test_simple_symbol () =\n+  let pat = [Symbol 'A', Some \"a\"] in\n+  let input = \"A\" in\n+  check_match pat input (Some [\"a\", \"A\"])\n+\n+let test_simple_ellipsis () =\n+  let pat = [Ellipsis, Some \"x\"] in\n+  let input = \"ABC\" in\n+  check_match pat input (Some [\"x\", \"ABC\"])\n+\n+let test_any_symbol () =\n+  let pat = [Any_symbol, Some \"a\"] in\n+  let input = \"A\" in\n+  check_match pat input (Some [\"a\", \"A\"])\n+\n+let test_floating_symbol () =\n+  let pat = [\n+    Ellipsis, Some \"head\";\n+    Symbol 'A', Some \"a\";\n+    Ellipsis, Some \"tail\";\n+  ] in\n+  let input = \"012345A6789\" in\n+  check_match pat input (Some [\n+    \"head\", \"012345\";\n+    \"a\", \"A\";\n+    \"tail\", \"6789\";\n+  ])\n+\n+let test_backref ~cache () =\n+  let pat = [\n+    Ellipsis, None;\n+    Any_symbol, Some \"orig\";\n+    Backref \"orig\", Some \"copy\";\n+    Ellipsis, None;\n+  ] in\n+  let input = \"ABBC\" in\n+  check_match ~cache pat input (Some [\n+    \"orig\", \"B\";\n+    \"copy\", \"B\";\n+  ])\n+\n+let test_gap () =\n+  let pat = [\n+    Symbol 'A', Some \"a\";\n+    Ellipsis, Some \"gap\";\n+    Symbol 'B', Some \"b\";\n+  ] in\n+  let input = \"A12B\" in\n+  check_match pat input (Some [\n+    \"a\", \"A\";\n+    \"gap\", \"12\";\n+    \"b\", \"B\";\n+  ])\n+\n+let test_backref_backtrack ~cache () =\n+  let pat = [\n+    Ellipsis, None;\n+    Any_symbol, Some \"x\";\n+    Ellipsis, None;\n+    Backref \"x\", None;\n+    Symbol 'C', None;\n+    Ellipsis, None;\n+  ] in\n+  let input = \"ABBCA\" in\n+  check_match ~cache pat input (Some [\n+    \"x\", \"B\";\n+  ])\n+\n+(*\n+   Deterministically generate a random-looking string.\n+*)\n+let pseudo_random_string len pick_from =\n+  let n = String.length pick_from in\n+  assert (n > 0);\n+  Random.init 0;\n+  String.init len (fun _i ->\n+    pick_from.[Random.int n]\n+  )\n+\n+(*\n+   This is equivalent in semgrep to searching for a pattern like", "originalCommit": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1MzE4MA==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543153180", "bodyText": "can you explain why it's n^2, by unfolding the work done each time.", "author": "aryx", "createdAt": "2020-12-15T08:47:05Z", "path": "semgrep-core/toy-matcher/Matcher.ml", "diffHunk": "@@ -0,0 +1,562 @@\n+(*\n+   A matcher operating on sequences of symbols,\n+   using the same basic matching algorithm as semgrep-core.\n+\n+   The goals are:\n+\n+   - Clarify semgrep-core's matching algorithm by not having to deal with any\n+     of the real-world complexity.\n+   - Keep the semgrep-core implementation separate and easy to follow,\n+     without functors.\n+*)\n+\n+open Printf\n+\n+type pattern_atom =\n+  | Any_symbol         (* match any single symbol *)\n+  | Symbol of char     (* match a specific symbol *)\n+  | Ellipsis           (* match any sequence of symbols *)\n+  | Backref of string  (* match the same thing that was previous matched\n+                          by the pattern atom of that name. *)\n+\n+(*\n+   A pattern is a list of pattern atoms with an optional name.\n+   The presence of a name indicates that the symbol or sequence it matches\n+   must be captured, i.e. stored in the environment.\n+*)\n+type pattern = (pattern_atom * string option) list\n+\n+type input = char list\n+\n+(* Captured subsequences. *)\n+module Env = Map.Make (String)\n+type env = char list Env.t\n+\n+(*\n+   Accumulator use to store the symbols matched by the current ellipsis.\n+\n+     None = we're not in an ellipsis\n+     Some None = we're in an ellipsis but it has no name and it's not capturing\n+\n+     Some (Some (\"foo\", acc)) = acc is the stack of symbols, i.e. the list\n+     of symbols captured so far by the current ellipsis in reverse order\n+*)\n+type ellipsis = (string * char list) option option\n+\n+type stat = {\n+  mutable match_calls: int;\n+}\n+\n+let sample_pattern : pattern = [\n+  Symbol 'A', None;\n+  Any_symbol, Some \"thing\";\n+  Ellipsis, None;\n+  Backref \"thing\", None;\n+]\n+\n+(*\n+   Unlike in semgrep syntax, we distinguish metavariable assignments\n+   from metavariable dereferencing.\n+\n+   This function checks that variable assignments are unique and that\n+   backreferences refer to a valid variable name.\n+\n+   This is a sanity check, not part of the matching algorithm.\n+*)\n+let rec check_pattern_ env (pat : pattern) =\n+  match pat with\n+  | [] -> ()\n+  | (atom, opt_name) :: pat ->\n+      let new_env =\n+        match opt_name with\n+        | None -> env\n+        | Some name ->\n+            if List.mem name env then\n+              failwith (\"multiple atoms have the same name: \" ^ name)\n+            else\n+              name :: env\n+      in\n+      (match atom with\n+       | Any_symbol -> ()\n+       | Symbol _ -> ()\n+       | Ellipsis -> ()\n+       | Backref name ->\n+           if not (List.mem name env) then\n+             failwith (\"backreference to invalid name: \" ^ name)\n+      );\n+      check_pattern_ new_env pat\n+\n+let check_pattern pat =\n+  check_pattern_ [] pat\n+\n+(*\n+   Initialize the capture of symbols by an ellipsis.\n+   'init_acc' is a stack, holding symbols in reverse order.\n+*)\n+let init_ellipsis opt_name init_acc =\n+  match opt_name with\n+  | None -> Some None\n+  | Some name -> Some (Some (name, init_acc))\n+\n+let extend_ellipsis opt_ellipsis symbol =\n+  match opt_ellipsis with\n+  | None -> opt_ellipsis\n+  | Some None -> opt_ellipsis\n+  | Some (Some (name, acc)) -> Some (Some (name, symbol :: acc))\n+\n+let close_ellipsis opt_ellipsis env =\n+  match opt_ellipsis with\n+  | None -> env\n+  | Some None -> env\n+  | Some (Some (name, acc)) -> Env.add name (List.rev acc) env\n+\n+(*\n+   Extend the environment by adding captured subsequences:\n+   - add the named ellipsis that ended just before the current match,\n+     if applicable\n+   - add the named atom that was just matched, if applicable\n+*)\n+let extend env opt_ellipsis opt_name captured_sequence =\n+  let env =\n+    match opt_ellipsis with\n+    | None -> env       (* we were not in an ellipsis *)\n+    | Some None -> env  (* we were in an anonymous ellipsis *)\n+    | Some (Some (ellipsis_name, acc)) ->\n+        Env.add ellipsis_name (List.rev acc) env\n+  in\n+  match opt_name with\n+  | None -> env\n+  | Some name ->\n+      Env.add name captured_sequence env\n+\n+(*\n+   Turn a string into a list of chars.\n+*)\n+let parse s =\n+  let acc = ref [] in\n+  for i = String.length s - 1 downto 0 do\n+    acc := s.[i] :: !acc\n+  done;\n+  !acc\n+\n+let unparse l =\n+  let buf = Buffer.create (List.length l) in\n+  List.iter (Buffer.add_char buf) l;\n+  Buffer.contents buf\n+\n+let print_result oc opt_bindings =\n+  match opt_bindings with\n+  | None ->\n+      fprintf oc \"not a match\\n\"\n+  | Some l ->\n+      fprintf oc \"match: {\\n\";\n+      List.iter (fun (name, subseq) ->\n+        fprintf oc \"  %s: %S\\n\"\n+          name subseq\n+      ) l;\n+      fprintf oc \"}\\n\"\n+\n+(* to be appended to existing line *)\n+let print_ellipsis oc ellipsis =\n+  match ellipsis with\n+  | None -> ()\n+  | Some None -> fprintf oc \" in-ellipsis\"\n+  | Some (Some (name, acc)) ->\n+      fprintf oc \" in-ellipsis:%s:%S\" name (unparse (List.rev acc))\n+\n+(* to be appended to existing line *)\n+let print_env oc env =\n+  fprintf oc \" {\";\n+  let is_first = ref true in\n+  Env.bindings env\n+  |> List.iter (fun (name, subseq) ->\n+    if !is_first then\n+      is_first := false\n+    else\n+      fprintf oc \" \";\n+    fprintf oc \"%s:%S\"\n+      name\n+      (unparse subseq)\n+  );\n+  fprintf oc \"}\"\n+\n+(* to be appended to existing line *)\n+let print_pat_head oc pat =\n+  match pat with\n+  | [] ->\n+      fprintf oc \" _:''\"\n+  | (atom, opt_name) :: _ ->\n+      (match opt_name with\n+       | None -> fprintf oc \" _:\"\n+       | Some name -> fprintf oc \" %s:\" name\n+      );\n+      match atom with\n+      | Any_symbol -> fprintf oc \"_\"\n+      | Symbol c -> fprintf oc \"%C\" c\n+      | Ellipsis -> fprintf oc \"...\"\n+      | Backref name -> fprintf oc \"%s\" name\n+\n+(* to be appended to existing line *)\n+let print_input_head oc input =\n+  match input with\n+  | [] ->\n+      fprintf oc \" ''\"\n+  | symbol :: _ ->\n+      fprintf oc \" %C\" symbol\n+\n+let max_trace_lines = 100\n+\n+(* print single line *)\n+let trace_match_call ~trace stat ellipsis env pat input =\n+  let match_calls = stat.match_calls + 1 in\n+  stat.match_calls <- match_calls;\n+  if trace then\n+    if match_calls <= max_trace_lines then\n+      printf \"match%a%a%a%a\\n\"\n+        print_ellipsis ellipsis\n+        print_env env\n+        print_pat_head pat\n+        print_input_head input\n+    else if match_calls = max_trace_lines + 1 then\n+      printf \"[exceeded max trace lines = %i]\\n%!\" max_trace_lines\n+\n+module Cache_key = struct\n+  type t = ellipsis * env * pattern * input\n+\n+  let equal (ellipsis1, env1, pat1, input1) (ellipsis2, env2, pat2, input2) =\n+    (==) pat1 pat2\n+    && (==) input1 input2\n+    && ellipsis1 = ellipsis2\n+    && Env.equal (=) env1 env2\n+\n+  let hash_env env =\n+    Env.fold\n+      (fun k v h ->\n+         Hashtbl.hash_param 10 100 k\n+         + Hashtbl.hash_param 10 100 v\n+         + h)\n+      env 0\n+\n+  (*\n+     We define a custom hash function because the default one doesn't work\n+     on maps (two equal maps may have different tree structures).\n+\n+     OCaml's default 'Hashtbl.hash' is the same as 'Hashtbl.hash_param 10 100'.\n+     First parameter (10): maximum of number of meaningful nodes used\n+                           by the hashing function.\n+                           (int-like constants, floats, strings)\n+     Second parameter (100): maximum total number of nodes used by the hashing\n+                             function.\n+     See the documentation for the Hashtbl module for more info.\n+  *)\n+  let hash (ellipsis, env, pat, input) =\n+    Hashtbl.hash_param 10 100 ellipsis\n+    + Hashtbl.hash_param 10 100 pat\n+    + Hashtbl.hash_param 10 100 input\n+    + hash_env env\n+end\n+\n+module Memoize = struct\n+  module Tbl = Hashtbl.Make (Cache_key)\n+\n+  (* only use cache once in 3 times *)\n+  let cache_every = 3\n+\n+  let should_use_cache input =\n+    Hashtbl.hash_param 5 10 input mod cache_every = 0\n+\n+  let get tbl compute ellipsis env pat input =\n+    (* only use the cache on some inputs because it's expensive *)\n+    if should_use_cache input then\n+      let key = (ellipsis, env, pat, input) in\n+      match Tbl.find_opt tbl key with\n+      | None ->\n+          let res = compute ellipsis env pat input in\n+          Tbl.add tbl key res;\n+          res\n+      | Some res -> res\n+    else\n+      compute ellipsis env pat input\n+\n+  let create compute =\n+    (*\n+       Initial table size impact performance.\n+    *)\n+    let tbl = Tbl.create 8192 in\n+    fun ellipsis env pat input ->\n+      get tbl compute ellipsis env pat input\n+end\n+\n+(*\n+   Main matching function.\n+\n+   Checks if a pattern matches the entire input sequence.\n+   Returns the captured symbols or sequences of symbols for which a\n+   name was specified in the pattern.\n+*)\n+let match_input ?(trace = true) ?(cache = false) root_pat root_input =\n+  let stat = { match_calls = 0 } in\n+  let get_from_cache = ref (fun _ellipsis _env _pat _input -> assert false) in\n+\n+  let rec match_ (ellipsis : ellipsis) (env : env) pat input =\n+    trace_match_call ~trace stat ellipsis env pat input;\n+    !get_from_cache ellipsis env pat input\n+\n+  and uncached_match ellipsis env pat input =\n+    let orig_pat = pat in\n+    let orig_input = input in\n+    let in_ellipsis = ellipsis <> None in\n+    match pat with\n+    | [] ->\n+        (match input with\n+         | [] ->\n+             let env = close_ellipsis ellipsis env in\n+             Some env\n+         | symbol :: input ->\n+             if in_ellipsis then\n+               let ellipsis = extend_ellipsis ellipsis symbol in\n+               match_ ellipsis env orig_pat input\n+             else\n+               None\n+        )\n+    | (pat_atom, opt_name) :: pat ->\n+        match input with\n+        | [] ->\n+            (* end of input, only empty sequence can match *)\n+            (match pat_atom with\n+             | Ellipsis ->\n+                 let env = extend env ellipsis opt_name [] in\n+                 match_ (init_ellipsis opt_name []) env pat input\n+             | Backref name ->\n+                 (match Env.find_opt name env with\n+                  | Some [] ->\n+                      let env = extend env ellipsis opt_name [] in\n+                      match_ None env pat input\n+                  | _ ->\n+                      None\n+                 )\n+             | _ -> None\n+            )\n+        | symbol :: input ->\n+            let head_match =\n+              match pat_atom with\n+              | Any_symbol ->\n+                  let env = extend env ellipsis opt_name [symbol] in\n+                  Some (None, env, input)\n+              | Symbol x ->\n+                  if x = symbol then\n+                    let env = extend env ellipsis opt_name [symbol] in\n+                    Some (None, env, input)\n+                  else\n+                    None\n+              | Ellipsis ->\n+                  (* start new ellipsis but don't consume first symbol *)\n+                  let env = close_ellipsis ellipsis env in\n+                  Some (init_ellipsis opt_name [], env, orig_input)\n+              | Backref name ->\n+                  (match Env.find_opt name env with\n+                   | Some [symbol0] when symbol0 = symbol ->\n+                       let env = extend env ellipsis opt_name [symbol] in\n+                       Some (None, env, input)\n+                   | _ ->\n+                       None\n+                  )\n+            in\n+            let matches_here =\n+              match head_match with\n+              | None -> None\n+              | Some (ellipsis, env, input) ->\n+                  (* match the rest of the pattern with the rest of the\n+                     input *)\n+                  match_ ellipsis env pat input\n+            in\n+            match matches_here with\n+            | Some _ as x -> x\n+            | None ->\n+                if in_ellipsis then\n+                  (* skip input symbol and retry *)\n+                  let ellipsis = extend_ellipsis ellipsis symbol in\n+                  match_ ellipsis env orig_pat input\n+                else\n+                  None\n+  in\n+  if cache then\n+    get_from_cache := Memoize.create uncached_match\n+  else\n+    get_from_cache := uncached_match;\n+\n+  let opt_captures =\n+    match match_ None Env.empty root_pat root_input with\n+    | None -> None\n+    | Some env -> Some (Env.bindings env)\n+  in\n+  opt_captures, stat\n+\n+(********** Tests **********)\n+\n+let print_time name f =\n+  let t1 = Unix.gettimeofday () in\n+  let res = f () in\n+  let t2 = Unix.gettimeofday () in\n+  printf \"%s: %.6f s\\n%!\" name (t2 -. t1);\n+  res\n+\n+let check_match ?cache pat input_str expected_opt_bindings =\n+  let sort = Option.map (List.sort compare) in\n+  let normalize opt_bindings =\n+    Option.map (fun bindings ->\n+      List.map (fun (var, symbols) -> (var, unparse symbols)) bindings\n+    ) opt_bindings\n+    |> sort\n+  in\n+  check_pattern pat;\n+  let input = parse input_str in\n+  let expected = sort expected_opt_bindings in\n+  let actual =\n+    let res, stat =\n+      print_time \"match function\" (fun () ->\n+        match_input ?cache pat input\n+      )\n+    in\n+    printf \"input length: %i\\n\" (String.length input_str);\n+    printf \"number of calls to the match function: %i\\n\" stat.match_calls;\n+    normalize res\n+  in\n+  print_result stdout actual;\n+  Alcotest.(check bool) \"equal\" true (expected = actual)\n+\n+let test_simple_symbol () =\n+  let pat = [Symbol 'A', Some \"a\"] in\n+  let input = \"A\" in\n+  check_match pat input (Some [\"a\", \"A\"])\n+\n+let test_simple_ellipsis () =\n+  let pat = [Ellipsis, Some \"x\"] in\n+  let input = \"ABC\" in\n+  check_match pat input (Some [\"x\", \"ABC\"])\n+\n+let test_any_symbol () =\n+  let pat = [Any_symbol, Some \"a\"] in\n+  let input = \"A\" in\n+  check_match pat input (Some [\"a\", \"A\"])\n+\n+let test_floating_symbol () =\n+  let pat = [\n+    Ellipsis, Some \"head\";\n+    Symbol 'A', Some \"a\";\n+    Ellipsis, Some \"tail\";\n+  ] in\n+  let input = \"012345A6789\" in\n+  check_match pat input (Some [\n+    \"head\", \"012345\";\n+    \"a\", \"A\";\n+    \"tail\", \"6789\";\n+  ])\n+\n+let test_backref ~cache () =\n+  let pat = [\n+    Ellipsis, None;\n+    Any_symbol, Some \"orig\";\n+    Backref \"orig\", Some \"copy\";\n+    Ellipsis, None;\n+  ] in\n+  let input = \"ABBC\" in\n+  check_match ~cache pat input (Some [\n+    \"orig\", \"B\";\n+    \"copy\", \"B\";\n+  ])\n+\n+let test_gap () =\n+  let pat = [\n+    Symbol 'A', Some \"a\";\n+    Ellipsis, Some \"gap\";\n+    Symbol 'B', Some \"b\";\n+  ] in\n+  let input = \"A12B\" in\n+  check_match pat input (Some [\n+    \"a\", \"A\";\n+    \"gap\", \"12\";\n+    \"b\", \"B\";\n+  ])\n+\n+let test_backref_backtrack ~cache () =\n+  let pat = [\n+    Ellipsis, None;\n+    Any_symbol, Some \"x\";\n+    Ellipsis, None;\n+    Backref \"x\", None;\n+    Symbol 'C', None;\n+    Ellipsis, None;\n+  ] in\n+  let input = \"ABBCA\" in\n+  check_match ~cache pat input (Some [\n+    \"x\", \"B\";\n+  ])\n+\n+(*\n+   Deterministically generate a random-looking string.\n+*)\n+let pseudo_random_string len pick_from =\n+  let n = String.length pick_from in\n+  assert (n > 0);\n+  Random.init 0;\n+  String.init len (fun _i ->\n+    pick_from.[Random.int n]\n+  )\n+\n+(*\n+   This is equivalent in semgrep to searching for a pattern like\n+   '$A; ... foo;', in a file where the statement 'foo;' doesn't exist.\n+\n+   With the naive match algorithm, the complexity is O(n^2) where n is the", "originalCommit": "96d6d2ee4e62cb5ffa62c5d454a7cd351a7c8220", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzgzNjM4MQ==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r543836381", "bodyText": "I added a bunch of comments to the file. For this specifically, I tried explaining things in comments but concluded it's better to run make bench and observe the traces.", "author": "mjambon", "createdAt": "2020-12-16T02:22:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE1MzE4MA=="}], "type": "inlineReview"}, {"oid": "fccef5bdff767540d87742ea1e5409fa78855b46", "url": "https://github.com/returntocorp/semgrep/commit/fccef5bdff767540d87742ea1e5409fa78855b46", "message": "Documentation", "committedDate": "2020-12-16T02:56:20Z", "type": "forcePushed"}, {"oid": "25f2275011bf2efdb9707ea7e11a4c246604177e", "url": "https://github.com/returntocorp/semgrep/commit/25f2275011bf2efdb9707ea7e11a4c246604177e", "message": "Add toy matcher with a very first test", "committedDate": "2021-01-11T22:54:55Z", "type": "commit"}, {"oid": "736115f8939d4df5ea9807116f6760a8bf2e4c7b", "url": "https://github.com/returntocorp/semgrep/commit/736115f8939d4df5ea9807116f6760a8bf2e4c7b", "message": "Some tests for the toy matcher. Needs fixing.", "committedDate": "2021-01-11T22:54:55Z", "type": "commit"}, {"oid": "769f1a9a8dd1b36b7c410d184bec0166ca31d63f", "url": "https://github.com/returntocorp/semgrep/commit/769f1a9a8dd1b36b7c410d184bec0166ca31d63f", "message": "Add tracing of match calls (up to 100 calls)", "committedDate": "2021-01-11T22:54:55Z", "type": "commit"}, {"oid": "45a05fd2e637e07f1cb6d2f1dca3efb4be90cfed", "url": "https://github.com/returntocorp/semgrep/commit/45a05fd2e637e07f1cb6d2f1dca3efb4be90cfed", "message": "Fix ellipsis matching", "committedDate": "2021-01-11T22:54:55Z", "type": "commit"}, {"oid": "0bc25095be8c859544c3febe1b24a431f12cae10", "url": "https://github.com/returntocorp/semgrep/commit/0bc25095be8c859544c3febe1b24a431f12cae10", "message": "Add optional caching (memoization) to the toy matcher.\nPreliminary results:\n- the same test makes only 40,000 calls to the match function instead of\n  50,000,000 without caching.\n- the cached version takes slightly longer!", "committedDate": "2021-01-11T22:54:55Z", "type": "commit"}, {"oid": "c5ecc7eeff062cd5ef50e8c70cd322f6c19cc390", "url": "https://github.com/returntocorp/semgrep/commit/c5ecc7eeff062cd5ef50e8c70cd322f6c19cc390", "message": "Use more realistic (= non-uniform) test input, resulting in better\nperformance.", "committedDate": "2021-01-11T22:54:55Z", "type": "commit"}, {"oid": "00e1e08ac55c0a6b22a6fec7185e34ed3ad37e8a", "url": "https://github.com/returntocorp/semgrep/commit/00e1e08ac55c0a6b22a6fec7185e34ed3ad37e8a", "message": "Only consult the cache on 1/3 of the inputs, making things a bit faster.", "committedDate": "2021-01-11T22:54:55Z", "type": "commit"}, {"oid": "f70c91138ba9982f51d668dc27b2fcc1fe1efeab", "url": "https://github.com/returntocorp/semgrep/commit/f70c91138ba9982f51d668dc27b2fcc1fe1efeab", "message": "Add readme to toy matcher + add to semgrep-core 'make test'", "committedDate": "2021-01-11T22:54:55Z", "type": "commit"}, {"oid": "f45b3f8bef527faffce898743f046beabd107488", "url": "https://github.com/returntocorp/semgrep/commit/f45b3f8bef527faffce898743f046beabd107488", "message": "Skip slow benchmark tests by default", "committedDate": "2021-01-11T22:54:55Z", "type": "commit"}, {"oid": "8eea9ace39b56a8a791e941c786391144e9c8d26", "url": "https://github.com/returntocorp/semgrep/commit/8eea9ace39b56a8a791e941c786391144e9c8d26", "message": "Unskip a test, eliminate semgrep warning", "committedDate": "2021-01-11T22:54:55Z", "type": "commit"}, {"oid": "02ef182d8bf35a6ee51b7d1fe6c45cc1415ccbde", "url": "https://github.com/returntocorp/semgrep/commit/02ef182d8bf35a6ee51b7d1fe6c45cc1415ccbde", "message": "Clarify ellipsis accumulator type", "committedDate": "2021-01-11T22:54:55Z", "type": "commit"}, {"oid": "13d4db0b4c15c0a99c09a75af7f4c9771606103c", "url": "https://github.com/returntocorp/semgrep/commit/13d4db0b4c15c0a99c09a75af7f4c9771606103c", "message": "Add documentation and to-do", "committedDate": "2021-01-11T22:54:55Z", "type": "commit"}, {"oid": "71ef6d3bb6af029ad41c328c3dc7733963316e33", "url": "https://github.com/returntocorp/semgrep/commit/71ef6d3bb6af029ad41c328c3dc7733963316e33", "message": "Better style", "committedDate": "2021-01-11T22:54:55Z", "type": "commit"}, {"oid": "5c7753040cb21c924c6720bd1d24cda2acf4f4c7", "url": "https://github.com/returntocorp/semgrep/commit/5c7753040cb21c924c6720bd1d24cda2acf4f4c7", "message": "Documentation", "committedDate": "2021-01-11T22:54:55Z", "type": "commit"}, {"oid": "2cc77dd6562746bafdedeb453f71959f56f18408", "url": "https://github.com/returntocorp/semgrep/commit/2cc77dd6562746bafdedeb453f71959f56f18408", "message": "Fix toy-matcher makefile", "committedDate": "2021-01-11T22:57:14Z", "type": "commit"}, {"oid": "92280be5de234739f653febbf5709ed3e8e72b68", "url": "https://github.com/returntocorp/semgrep/commit/92280be5de234739f653febbf5709ed3e8e72b68", "message": "Carry around minimal environment in the toy matcher so as to minimize\nreuse of cache entries, whose keys include this set of bindings.", "committedDate": "2021-01-11T22:57:14Z", "type": "commit"}, {"oid": "d2e3cdb40e4989d902992850df3742c459ddae8b", "url": "https://github.com/returntocorp/semgrep/commit/d2e3cdb40e4989d902992850df3742c459ddae8b", "message": "Document toy matcher", "committedDate": "2021-01-11T22:57:14Z", "type": "commit"}, {"oid": "2a1196b0ce1e53a8145603350b4894c4410fdd54", "url": "https://github.com/returntocorp/semgrep/commit/2a1196b0ce1e53a8145603350b4894c4410fdd54", "message": "Prepare pattern for cached matching (needs a few unit tests)", "committedDate": "2021-01-12T07:05:44Z", "type": "commit"}, {"oid": "2a1196b0ce1e53a8145603350b4894c4410fdd54", "url": "https://github.com/returntocorp/semgrep/commit/2a1196b0ce1e53a8145603350b4894c4410fdd54", "message": "Prepare pattern for cached matching (needs a few unit tests)", "committedDate": "2021-01-12T07:05:44Z", "type": "forcePushed"}, {"oid": "25b58abb2f890635316cec8580cfb2024da9b9cf", "url": "https://github.com/returntocorp/semgrep/commit/25b58abb2f890635316cec8580cfb2024da9b9cf", "message": "Add 'Caching.prepare_target'", "committedDate": "2021-01-12T22:21:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjM3MzA0OA==", "url": "https://github.com/returntocorp/semgrep/pull/2256#discussion_r556373048", "bodyText": "You can use the Logging module in pfff/commons/. It's not too bad. Look for the use of logger in other files.", "author": "aryx", "createdAt": "2021-01-13T09:20:34Z", "path": "semgrep-core/parsing/Caching.ml", "diffHunk": "@@ -0,0 +1,163 @@\n+(*\n+   Decorate a pattern and target ASTs to make the suitable for memoization\n+   during matching.\n+*)\n+\n+open Printf\n+open AST_generic\n+\n+(* A set of metavariables. Access cost is O(log n). *)\n+module Names = AST_generic.String_set\n+\n+(* Count the number of occurrences of each backreference of a metavariable. *)\n+module Name_counts = Map.Make (String)\n+\n+let print_names oc names =\n+  List.iter (fun s -> fprintf oc \"  %s\\n\" s) (Names.elements names)\n+\n+let print_name_counts oc name_counts =\n+  List.iter\n+    (fun (s, n) -> fprintf oc \"  %s: %i\\n\" s n)\n+    (Name_counts.bindings name_counts)\n+\n+let add_one k name_counts =\n+  match Name_counts.find_opt k name_counts with\n+  | None -> Name_counts.add k 1 name_counts\n+  | Some n -> Name_counts.add k (n + 1) name_counts\n+\n+let get_count k name_counts =\n+  match Name_counts.find_opt k name_counts with\n+  | None -> 0\n+  | Some n -> n\n+\n+let diff_count k ~new_counts ~old_counts =\n+  let n = get_count k new_counts - get_count k old_counts in\n+  assert (n >= 0);\n+  n\n+\n+let diff_backrefs bound_metavars ~new_backref_counts ~old_backref_counts =\n+  let not_backrefs_in_rest_of_pattern =\n+    Names.fold (fun k acc ->\n+      let added_backref_count =\n+        diff_count k\n+          ~new_counts:new_backref_counts\n+          ~old_counts:old_backref_counts\n+      in\n+      match added_backref_count with\n+      | 0 -> Names.add k acc\n+      | _ -> acc\n+    ) bound_metavars Names.empty\n+  in\n+  Names.diff bound_metavars not_backrefs_in_rest_of_pattern\n+\n+let create_create_id () =\n+  let n = ref 0 in\n+  fun () ->\n+    let id = !n in\n+    assert (id >= 0);\n+    incr n;\n+    id\n+\n+(*\n+   During matching a pattern node against a program node, we consult\n+   a cache to see if we already have run this before and return the\n+   cached result. This is memoization.\n+\n+   A cache key is formed from the contents of the pattern node,\n+   the program node, and all the environment that is sufficient to determine\n+   the result of the computation. The environment includes the set\n+   of bound metavariables that are referenced in the rest of the pattern.\n+   For this, it is correct to use all the bound metavariables rather than the\n+   ones that really needed. However, this reduces caching efficiency by having\n+   irrelevant parts of the environment, the unused metavariables, in the cache\n+   key.\n+\n+   This function decorates the pattern AST with the set of metavariables\n+   that are used in the rest of the pattern. This set is consulted at runtime\n+   to determine whether a captured metavariable should go into the cache key.\n+*)\n+let prepare_pattern ?(debug = false) any =\n+  let bound_metavars = ref Names.empty in\n+  let backref_counts = ref Name_counts.empty in\n+  let add_metavar name =\n+    if Names.mem name !bound_metavars then\n+      backref_counts := add_one name !backref_counts\n+    else\n+      bound_metavars := Names.add name !bound_metavars\n+  in\n+  let create_id = create_create_id () in\n+  (*\n+     This is the list of actions to run in reverse order of the original\n+     traversal of statements.\n+  *)\n+  let stack = ref [] in\n+  let add_to_stack f = stack := f :: ! stack in\n+\n+  let visitor = Visitor_AST.mk_visitor {\n+    Visitor_AST.default_visitor with\n+    kident = (fun (_k, _) (id, _tok) ->\n+      if debug then\n+        printf \"kident %s\\n\" id;", "originalCommit": "25b58abb2f890635316cec8580cfb2024da9b9cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "978f4a0f6ace6746205009b4138455d7e397f0f9", "url": "https://github.com/returntocorp/semgrep/commit/978f4a0f6ace6746205009b4138455d7e397f0f9", "message": "Merge branch 'develop' into mj/match-perf", "committedDate": "2021-01-13T10:18:59Z", "type": "commit"}, {"oid": "8430a06375e96ec2b3ee5bbb2c6c27e9befe64d9", "url": "https://github.com/returntocorp/semgrep/commit/8430a06375e96ec2b3ee5bbb2c6c27e9befe64d9", "message": "Disable calls to Caching.prepare_xxx because of many test regressions.\nProbably comes from the need to provide an empty equal on s_backrefs\nlike we have for s_bf.", "committedDate": "2021-01-13T10:23:41Z", "type": "commit"}]}