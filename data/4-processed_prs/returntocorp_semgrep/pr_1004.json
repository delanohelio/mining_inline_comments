{"pr_number": 1004, "pr_title": "Add 'how to think about writing rules' examples to documentation.", "pr_createdAt": "2020-06-13T03:01:28Z", "pr_url": "https://github.com/returntocorp/semgrep/pull/1004", "timeline": [{"oid": "69272b9d271e5576b12f0c17d10e56a1a4b7950d", "url": "https://github.com/returntocorp/semgrep/commit/69272b9d271e5576b12f0c17d10e56a1a4b7950d", "message": "Initial commit for https://github.com/returntocorp/enterprise/issues/232", "committedDate": "2020-06-13T01:46:15Z", "type": "commit"}, {"oid": "f690dee395efa08c4dddc4fd53fb38ed4ea82829", "url": "https://github.com/returntocorp/semgrep/commit/f690dee395efa08c4dddc4fd53fb38ed4ea82829", "message": "Add 'this before that' example", "committedDate": "2020-06-13T02:58:32Z", "type": "commit"}, {"oid": "2b054989a8d01cdf022dee4a3984034256554b32", "url": "https://github.com/returntocorp/semgrep/commit/2b054989a8d01cdf022dee4a3984034256554b32", "message": "Add 'coming soon' sections so I can finish for the weekend", "committedDate": "2020-06-13T02:59:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NDE5NQ==", "url": "https://github.com/returntocorp/semgrep/pull/1004#discussion_r441194195", "bodyText": "Nice! I like this example a lot, and is a common use case I imagine security engrs caring about \ud83d\udc4d", "author": "clintgibler", "createdAt": "2020-06-16T23:18:35Z", "path": "docs/writing_rules/examples.md", "diffHunk": "@@ -0,0 +1,232 @@\n+\n+## Auditing Dangerous Function Use\n+\n+Using Semgrep to audit dangerous function calls is easy.\n+\n+1. Match a function call by name.\n+2. Filter out hardcoded strings.\n+3. Look explicitly for dangerous keyword arguments.\n+\n+Let's do an example with the `subprocess` module in Python.\n+\n+**Match the function call by name.** The ellipsis operator `...` abstracts away whole segments of code. Effectively, it says \"I don't care about what's in here.\"\n+\n+```yaml\n+patterns:\n+- pattern: subprocess.call(...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/eq5Z\n+\n+**Filter out hardcoded strings.** The ellipsis operator can be used inside quotes to represent any string literal. We can filter out static strings by using this with the `pattern-not` clause.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.call(\"...\")", "originalCommit": "2b054989a8d01cdf022dee4a3984034256554b32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NDk4NA==", "url": "https://github.com/returntocorp/semgrep/pull/1004#discussion_r441194984", "bodyText": "Suggested rewording:\nSemgrep will match `(..., shell=True)` only when `shell=True` is the last argument, but that's not what we want, as `shell=True` is dangerous regardless of the order in which it's passed in. We can update our pattern to handle cases where `shell=True` is a keyword argument regardless of the order it's passed in by using the ellipsis operator on both sides of `shell=True`.", "author": "clintgibler", "createdAt": "2020-06-16T23:21:12Z", "path": "docs/writing_rules/examples.md", "diffHunk": "@@ -0,0 +1,232 @@\n+\n+## Auditing Dangerous Function Use\n+\n+Using Semgrep to audit dangerous function calls is easy.\n+\n+1. Match a function call by name.\n+2. Filter out hardcoded strings.\n+3. Look explicitly for dangerous keyword arguments.\n+\n+Let's do an example with the `subprocess` module in Python.\n+\n+**Match the function call by name.** The ellipsis operator `...` abstracts away whole segments of code. Effectively, it says \"I don't care about what's in here.\"\n+\n+```yaml\n+patterns:\n+- pattern: subprocess.call(...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/eq5Z\n+\n+**Filter out hardcoded strings.** The ellipsis operator can be used inside quotes to represent any string literal. We can filter out static strings by using this with the `pattern-not` clause.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.call(\"...\")\n+- pattern: subprocess.call(...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Doesn't match here anymore!\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/v8X8\n+\n+**Look explicitly for dangerous keyword arguments.** You may want to match only when [certain keyword arguments are present](https://docs.python.org/3/library/subprocess.html#security-considerations). We can write keyword arguments just like in Python into our pattern. Combined with the ellipsis operator, this pattern will match if `shell=True` appears at the end of the sequence of arguments.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.call(\"...\")\n+- pattern: subprocess.call(..., shell=True)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Doesn't match here anymore!\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Oops! We don't match here anymore either!\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/d8J6\n+\n+Semgrep will match `(..., shell=True)` only when `shell=True` is the last argument. To fix this, we can use the ellipsis operator on both sides of `shell=True`.", "originalCommit": "2b054989a8d01cdf022dee4a3984034256554b32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NjQ4Mw==", "url": "https://github.com/returntocorp/semgrep/pull/1004#discussion_r441196483", "bodyText": "Suggested rewording, to make it clear about the impact of this even if the person isn't a security person or familiar with Python:\n\nLook explicitly for dangerous keyword arguments. You may want to match only when certain keyword arguments are present. For example, when subprocess.call is passed the keyword argument shell=True, Python won't auto-escape shell metacharacters that are passed in, which, if an attacker has control over the input, may lead to them being able to run arbitrary shell commands.\nWe can match keyword arguments just like in Python into our pattern. Combined with the ellipsis operator, this pattern will match if shell=True appears at the end of the sequence of arguments.", "author": "clintgibler", "createdAt": "2020-06-16T23:26:14Z", "path": "docs/writing_rules/examples.md", "diffHunk": "@@ -0,0 +1,232 @@\n+\n+## Auditing Dangerous Function Use\n+\n+Using Semgrep to audit dangerous function calls is easy.\n+\n+1. Match a function call by name.\n+2. Filter out hardcoded strings.\n+3. Look explicitly for dangerous keyword arguments.\n+\n+Let's do an example with the `subprocess` module in Python.\n+\n+**Match the function call by name.** The ellipsis operator `...` abstracts away whole segments of code. Effectively, it says \"I don't care about what's in here.\"\n+\n+```yaml\n+patterns:\n+- pattern: subprocess.call(...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/eq5Z\n+\n+**Filter out hardcoded strings.** The ellipsis operator can be used inside quotes to represent any string literal. We can filter out static strings by using this with the `pattern-not` clause.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.call(\"...\")\n+- pattern: subprocess.call(...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Doesn't match here anymore!\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/v8X8\n+\n+**Look explicitly for dangerous keyword arguments.** You may want to match only when [certain keyword arguments are present](https://docs.python.org/3/library/subprocess.html#security-considerations). We can write keyword arguments just like in Python into our pattern. Combined with the ellipsis operator, this pattern will match if `shell=True` appears at the end of the sequence of arguments.", "originalCommit": "2b054989a8d01cdf022dee4a3984034256554b32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5NzYxNw==", "url": "https://github.com/returntocorp/semgrep/pull/1004#discussion_r441197617", "bodyText": "Consider splitting this into 2 paragraphs to make it more readable - add newline before \"Metavariables let you match any code expression.\"\nConsider adding at the end of second paragraph:\n\nTo learn more about metavariables, see the primary docs.", "author": "clintgibler", "createdAt": "2020-06-16T23:29:51Z", "path": "docs/writing_rules/examples.md", "diffHunk": "@@ -0,0 +1,232 @@\n+\n+## Auditing Dangerous Function Use\n+\n+Using Semgrep to audit dangerous function calls is easy.\n+\n+1. Match a function call by name.\n+2. Filter out hardcoded strings.\n+3. Look explicitly for dangerous keyword arguments.\n+\n+Let's do an example with the `subprocess` module in Python.\n+\n+**Match the function call by name.** The ellipsis operator `...` abstracts away whole segments of code. Effectively, it says \"I don't care about what's in here.\"\n+\n+```yaml\n+patterns:\n+- pattern: subprocess.call(...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/eq5Z\n+\n+**Filter out hardcoded strings.** The ellipsis operator can be used inside quotes to represent any string literal. We can filter out static strings by using this with the `pattern-not` clause.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.call(\"...\")\n+- pattern: subprocess.call(...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Doesn't match here anymore!\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/v8X8\n+\n+**Look explicitly for dangerous keyword arguments.** You may want to match only when [certain keyword arguments are present](https://docs.python.org/3/library/subprocess.html#security-considerations). We can write keyword arguments just like in Python into our pattern. Combined with the ellipsis operator, this pattern will match if `shell=True` appears at the end of the sequence of arguments.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.call(\"...\")\n+- pattern: subprocess.call(..., shell=True)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Doesn't match here anymore!\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Oops! We don't match here anymore either!\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/d8J6\n+\n+Semgrep will match `(..., shell=True)` only when `shell=True` is the last argument. To fix this, we can use the ellipsis operator on both sides of `shell=True`.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.call(\"...\")\n+- pattern: subprocess.call(..., shell=True, ...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here too!\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/ZqKW\n+\n+**Bonus: Match any `subprocess` function with `shell=True`.** As you probably noticed, `subprocess.run` is subject to the same issue as `subprocess.call`. `subprocess.run` [was made available in Python 3.5](https://docs.python.org/3/library/subprocess.html#older-high-level-api). We can match both `subprocess.call` and `subprocess.run` by using **metavariables**. Metavariables let you match any code expression. To use metavariables in Semgrep, use the dollar sign as a prefix and all capital letters. In this example, we will use `subprocess.$FUNC`. The name can be anything -- it's just a like a variable in a normal language and will \"hold\" the expression it matches.", "originalCommit": "2b054989a8d01cdf022dee4a3984034256554b32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5ODQyNA==", "url": "https://github.com/returntocorp/semgrep/pull/1004#discussion_r441198424", "bodyText": "I really like the tone, style, and examples in this, awesome work! \ud83c\udf89 \ud83d\udd7a\nCould you make a quick index at the top, like https://github.com/returntocorp/semgrep/blob/develop/docs/pattern-features.md, that makes it easy to get a glimpse into what's contained and jump to a specific example?", "author": "clintgibler", "createdAt": "2020-06-16T23:32:29Z", "path": "docs/writing_rules/examples.md", "diffHunk": "@@ -0,0 +1,232 @@\n+", "originalCommit": "2b054989a8d01cdf022dee4a3984034256554b32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5OTI1MA==", "url": "https://github.com/returntocorp/semgrep/pull/1004#discussion_r441199250", "bodyText": "Propose: \"a function's API.\" -> \"an API.\"", "author": "clintgibler", "createdAt": "2020-06-16T23:35:33Z", "path": "docs/writing_rules/examples.md", "diffHunk": "@@ -0,0 +1,232 @@\n+\n+## Auditing Dangerous Function Use\n+\n+Using Semgrep to audit dangerous function calls is easy.\n+\n+1. Match a function call by name.\n+2. Filter out hardcoded strings.\n+3. Look explicitly for dangerous keyword arguments.\n+\n+Let's do an example with the `subprocess` module in Python.\n+\n+**Match the function call by name.** The ellipsis operator `...` abstracts away whole segments of code. Effectively, it says \"I don't care about what's in here.\"\n+\n+```yaml\n+patterns:\n+- pattern: subprocess.call(...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/eq5Z\n+\n+**Filter out hardcoded strings.** The ellipsis operator can be used inside quotes to represent any string literal. We can filter out static strings by using this with the `pattern-not` clause.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.call(\"...\")\n+- pattern: subprocess.call(...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Doesn't match here anymore!\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/v8X8\n+\n+**Look explicitly for dangerous keyword arguments.** You may want to match only when [certain keyword arguments are present](https://docs.python.org/3/library/subprocess.html#security-considerations). We can write keyword arguments just like in Python into our pattern. Combined with the ellipsis operator, this pattern will match if `shell=True` appears at the end of the sequence of arguments.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.call(\"...\")\n+- pattern: subprocess.call(..., shell=True)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Doesn't match here anymore!\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Oops! We don't match here anymore either!\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/d8J6\n+\n+Semgrep will match `(..., shell=True)` only when `shell=True` is the last argument. To fix this, we can use the ellipsis operator on both sides of `shell=True`.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.call(\"...\")\n+- pattern: subprocess.call(..., shell=True, ...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here too!\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/ZqKW\n+\n+**Bonus: Match any `subprocess` function with `shell=True`.** As you probably noticed, `subprocess.run` is subject to the same issue as `subprocess.call`. `subprocess.run` [was made available in Python 3.5](https://docs.python.org/3/library/subprocess.html#older-high-level-api). We can match both `subprocess.call` and `subprocess.run` by using **metavariables**. Metavariables let you match any code expression. To use metavariables in Semgrep, use the dollar sign as a prefix and all capital letters. In this example, we will use `subprocess.$FUNC`. The name can be anything -- it's just a like a variable in a normal language and will \"hold\" the expression it matches.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.$FUNC(\"...\")\n+- pattern: subprocess.$FUNC(..., shell=True, ...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here too!\n+```\n+\n+https://semgrep.live/nJ9d\n+\n+## Enforce Specific Use of an API\n+\n+Sometimes you may wish to enforce the specific use of a function's API. There are many examples of this, such as `subprocess.call(..., shell=True, ...)` above; you may wish to match and fail any commit where `shell=True`. This is easy to do in Semgrep, as seen in the above section.", "originalCommit": "2b054989a8d01cdf022dee4a3984034256554b32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTE5OTcwMA==", "url": "https://github.com/returntocorp/semgrep/pull/1004#discussion_r441199700", "bodyText": "Propose removing \"function APIs\" => \"APIs\"\nAdd \",\" after \"web context\"\n\"to make sure\" => should this be \"to make sure to include\"?", "author": "clintgibler", "createdAt": "2020-06-16T23:37:09Z", "path": "docs/writing_rules/examples.md", "diffHunk": "@@ -0,0 +1,232 @@\n+\n+## Auditing Dangerous Function Use\n+\n+Using Semgrep to audit dangerous function calls is easy.\n+\n+1. Match a function call by name.\n+2. Filter out hardcoded strings.\n+3. Look explicitly for dangerous keyword arguments.\n+\n+Let's do an example with the `subprocess` module in Python.\n+\n+**Match the function call by name.** The ellipsis operator `...` abstracts away whole segments of code. Effectively, it says \"I don't care about what's in here.\"\n+\n+```yaml\n+patterns:\n+- pattern: subprocess.call(...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/eq5Z\n+\n+**Filter out hardcoded strings.** The ellipsis operator can be used inside quotes to represent any string literal. We can filter out static strings by using this with the `pattern-not` clause.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.call(\"...\")\n+- pattern: subprocess.call(...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Doesn't match here anymore!\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/v8X8\n+\n+**Look explicitly for dangerous keyword arguments.** You may want to match only when [certain keyword arguments are present](https://docs.python.org/3/library/subprocess.html#security-considerations). We can write keyword arguments just like in Python into our pattern. Combined with the ellipsis operator, this pattern will match if `shell=True` appears at the end of the sequence of arguments.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.call(\"...\")\n+- pattern: subprocess.call(..., shell=True)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Doesn't match here anymore!\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Oops! We don't match here anymore either!\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/d8J6\n+\n+Semgrep will match `(..., shell=True)` only when `shell=True` is the last argument. To fix this, we can use the ellipsis operator on both sides of `shell=True`.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.call(\"...\")\n+- pattern: subprocess.call(..., shell=True, ...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here too!\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/ZqKW\n+\n+**Bonus: Match any `subprocess` function with `shell=True`.** As you probably noticed, `subprocess.run` is subject to the same issue as `subprocess.call`. `subprocess.run` [was made available in Python 3.5](https://docs.python.org/3/library/subprocess.html#older-high-level-api). We can match both `subprocess.call` and `subprocess.run` by using **metavariables**. Metavariables let you match any code expression. To use metavariables in Semgrep, use the dollar sign as a prefix and all capital letters. In this example, we will use `subprocess.$FUNC`. The name can be anything -- it's just a like a variable in a normal language and will \"hold\" the expression it matches.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.$FUNC(\"...\")\n+- pattern: subprocess.$FUNC(..., shell=True, ...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here too!\n+```\n+\n+https://semgrep.live/nJ9d\n+\n+## Enforce Specific Use of an API\n+\n+Sometimes you may wish to enforce the specific use of a function's API. There are many examples of this, such as `subprocess.call(..., shell=True, ...)` above; you may wish to match and fail any commit where `shell=True`. This is easy to do in Semgrep, as seen in the above section.\n+\n+However, there are also function APIs that are insecure by default--or insecure depending on context, such as Jinja2, which does [not enable autoescaping by default](https://github.com/pallets/jinja/blob/2a8515d2e53a2be475d9df3fe44e308501201a95/src/jinja2/environment.py#L296). Jinja2 is an arbitrary templating engine, so this makes sense in non-web contexts. This may not be obvious, though, and if you are working directly with the Jinja2 engine in a web context you want to make sure `autoescape=True`.", "originalCommit": "2b054989a8d01cdf022dee4a3984034256554b32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwMDE0OQ==", "url": "https://github.com/returntocorp/semgrep/pull/1004#discussion_r441200149", "bodyText": "Since the writing order used in above examples includes the semgrep link below the code example, should we replace [setting secure cookies in Flask] with a link to the Flask docs, and then include https://semgrep.live/EwB5 below the patterns?", "author": "clintgibler", "createdAt": "2020-06-16T23:38:49Z", "path": "docs/writing_rules/examples.md", "diffHunk": "@@ -0,0 +1,232 @@\n+\n+## Auditing Dangerous Function Use\n+\n+Using Semgrep to audit dangerous function calls is easy.\n+\n+1. Match a function call by name.\n+2. Filter out hardcoded strings.\n+3. Look explicitly for dangerous keyword arguments.\n+\n+Let's do an example with the `subprocess` module in Python.\n+\n+**Match the function call by name.** The ellipsis operator `...` abstracts away whole segments of code. Effectively, it says \"I don't care about what's in here.\"\n+\n+```yaml\n+patterns:\n+- pattern: subprocess.call(...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/eq5Z\n+\n+**Filter out hardcoded strings.** The ellipsis operator can be used inside quotes to represent any string literal. We can filter out static strings by using this with the `pattern-not` clause.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.call(\"...\")\n+- pattern: subprocess.call(...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Doesn't match here anymore!\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/v8X8\n+\n+**Look explicitly for dangerous keyword arguments.** You may want to match only when [certain keyword arguments are present](https://docs.python.org/3/library/subprocess.html#security-considerations). We can write keyword arguments just like in Python into our pattern. Combined with the ellipsis operator, this pattern will match if `shell=True` appears at the end of the sequence of arguments.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.call(\"...\")\n+- pattern: subprocess.call(..., shell=True)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Doesn't match here anymore!\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Oops! We don't match here anymore either!\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/d8J6\n+\n+Semgrep will match `(..., shell=True)` only when `shell=True` is the last argument. To fix this, we can use the ellipsis operator on both sides of `shell=True`.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.call(\"...\")\n+- pattern: subprocess.call(..., shell=True, ...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here too!\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/ZqKW\n+\n+**Bonus: Match any `subprocess` function with `shell=True`.** As you probably noticed, `subprocess.run` is subject to the same issue as `subprocess.call`. `subprocess.run` [was made available in Python 3.5](https://docs.python.org/3/library/subprocess.html#older-high-level-api). We can match both `subprocess.call` and `subprocess.run` by using **metavariables**. Metavariables let you match any code expression. To use metavariables in Semgrep, use the dollar sign as a prefix and all capital letters. In this example, we will use `subprocess.$FUNC`. The name can be anything -- it's just a like a variable in a normal language and will \"hold\" the expression it matches.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.$FUNC(\"...\")\n+- pattern: subprocess.$FUNC(..., shell=True, ...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here too!\n+```\n+\n+https://semgrep.live/nJ9d\n+\n+## Enforce Specific Use of an API\n+\n+Sometimes you may wish to enforce the specific use of a function's API. There are many examples of this, such as `subprocess.call(..., shell=True, ...)` above; you may wish to match and fail any commit where `shell=True`. This is easy to do in Semgrep, as seen in the above section.\n+\n+However, there are also function APIs that are insecure by default--or insecure depending on context, such as Jinja2, which does [not enable autoescaping by default](https://github.com/pallets/jinja/blob/2a8515d2e53a2be475d9df3fe44e308501201a95/src/jinja2/environment.py#L296). Jinja2 is an arbitrary templating engine, so this makes sense in non-web contexts. This may not be obvious, though, and if you are working directly with the Jinja2 engine in a web context you want to make sure `autoescape=True`.\n+\n+(Not to scare anyone: Flask, for instance, [autoescapes templates with the '.html' extension](https://github.com/pallets/jinja/blob/2a8515d2e53a2be475d9df3fe44e308501201a95/src/jinja2/environment.py#L296).)\n+\n+This is an interesting case because we want to enforce the **presence** of `autoescape=True`. *Matching* this is easy:\n+\n+```yaml\n+patterns:\n+- pattern: jinja2.Environment(..., autoescape=True, ...)\n+```\n+\n+But what we *want* is to alert when the *opposite* conditions are met. Therefore we want to match (1) when `autoescape=False` **and** (2) when `autoescape` is not present in the function call at all! This pattern will match when `jinja2.Environment()` does not contain `autoescape=True`:\n+\n+```yaml\n+patterns:\n+- pattern-not: jinja2.Environment(..., autoescape=True, ...)\n+- pattern: jinja2.Environment(...)\n+```\n+\n+\ud83d\udea7\ud83d\udea7 Coming soon: semgrep.live link \ud83d\udea7\ud83d\udea7\n+\n+This can be generalized with the following approach:\n+\n+1. Match the function call by name.\n+2. Filter out good patterns.\n+\n+### Secure Cookies in Flask\n+\n+Another example of this approach is [setting secure cookies in Flask](https://semgrep.live/EwB5).", "originalCommit": "2b054989a8d01cdf022dee4a3984034256554b32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIwMDc1NQ==", "url": "https://github.com/returntocorp/semgrep/pull/1004#discussion_r441200755", "bodyText": "Can you add a link to the pattern-not-inside docs here? https://github.com/returntocorp/semgrep/blob/develop/docs/configuration-files.md#pattern-not-inside", "author": "clintgibler", "createdAt": "2020-06-16T23:40:56Z", "path": "docs/writing_rules/examples.md", "diffHunk": "@@ -0,0 +1,232 @@\n+\n+## Auditing Dangerous Function Use\n+\n+Using Semgrep to audit dangerous function calls is easy.\n+\n+1. Match a function call by name.\n+2. Filter out hardcoded strings.\n+3. Look explicitly for dangerous keyword arguments.\n+\n+Let's do an example with the `subprocess` module in Python.\n+\n+**Match the function call by name.** The ellipsis operator `...` abstracts away whole segments of code. Effectively, it says \"I don't care about what's in here.\"\n+\n+```yaml\n+patterns:\n+- pattern: subprocess.call(...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/eq5Z\n+\n+**Filter out hardcoded strings.** The ellipsis operator can be used inside quotes to represent any string literal. We can filter out static strings by using this with the `pattern-not` clause.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.call(\"...\")\n+- pattern: subprocess.call(...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Doesn't match here anymore!\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/v8X8\n+\n+**Look explicitly for dangerous keyword arguments.** You may want to match only when [certain keyword arguments are present](https://docs.python.org/3/library/subprocess.html#security-considerations). We can write keyword arguments just like in Python into our pattern. Combined with the ellipsis operator, this pattern will match if `shell=True` appears at the end of the sequence of arguments.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.call(\"...\")\n+- pattern: subprocess.call(..., shell=True)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Doesn't match here anymore!\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Oops! We don't match here anymore either!\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/d8J6\n+\n+Semgrep will match `(..., shell=True)` only when `shell=True` is the last argument. To fix this, we can use the ellipsis operator on both sides of `shell=True`.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.call(\"...\")\n+- pattern: subprocess.call(..., shell=True, ...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here too!\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Doesn't match here\n+```\n+\n+https://semgrep.live/ZqKW\n+\n+**Bonus: Match any `subprocess` function with `shell=True`.** As you probably noticed, `subprocess.run` is subject to the same issue as `subprocess.call`. `subprocess.run` [was made available in Python 3.5](https://docs.python.org/3/library/subprocess.html#older-high-level-api). We can match both `subprocess.call` and `subprocess.run` by using **metavariables**. Metavariables let you match any code expression. To use metavariables in Semgrep, use the dollar sign as a prefix and all capital letters. In this example, we will use `subprocess.$FUNC`. The name can be anything -- it's just a like a variable in a normal language and will \"hold\" the expression it matches.\n+\n+```yaml\n+patterns:\n+- pattern-not: subprocess.$FUNC(\"...\")\n+- pattern: subprocess.$FUNC(..., shell=True, ...)\n+```\n+\n+```python\n+import subprocess\n+import sys\n+\n+subprocess.call(\"echo 'hello'\") # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1])) # Doesn't match\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here\n+subprocess.call(\"grep -R {} .\".format(sys.argv[1]), shell=True, cwd=\"/home/user\") # Matches here\n+subprocess.run(\"grep -R {} .\".format(sys.argv[1]), shell=True) # Matches here too!\n+```\n+\n+https://semgrep.live/nJ9d\n+\n+## Enforce Specific Use of an API\n+\n+Sometimes you may wish to enforce the specific use of a function's API. There are many examples of this, such as `subprocess.call(..., shell=True, ...)` above; you may wish to match and fail any commit where `shell=True`. This is easy to do in Semgrep, as seen in the above section.\n+\n+However, there are also function APIs that are insecure by default--or insecure depending on context, such as Jinja2, which does [not enable autoescaping by default](https://github.com/pallets/jinja/blob/2a8515d2e53a2be475d9df3fe44e308501201a95/src/jinja2/environment.py#L296). Jinja2 is an arbitrary templating engine, so this makes sense in non-web contexts. This may not be obvious, though, and if you are working directly with the Jinja2 engine in a web context you want to make sure `autoescape=True`.\n+\n+(Not to scare anyone: Flask, for instance, [autoescapes templates with the '.html' extension](https://github.com/pallets/jinja/blob/2a8515d2e53a2be475d9df3fe44e308501201a95/src/jinja2/environment.py#L296).)\n+\n+This is an interesting case because we want to enforce the **presence** of `autoescape=True`. *Matching* this is easy:\n+\n+```yaml\n+patterns:\n+- pattern: jinja2.Environment(..., autoescape=True, ...)\n+```\n+\n+But what we *want* is to alert when the *opposite* conditions are met. Therefore we want to match (1) when `autoescape=False` **and** (2) when `autoescape` is not present in the function call at all! This pattern will match when `jinja2.Environment()` does not contain `autoescape=True`:\n+\n+```yaml\n+patterns:\n+- pattern-not: jinja2.Environment(..., autoescape=True, ...)\n+- pattern: jinja2.Environment(...)\n+```\n+\n+\ud83d\udea7\ud83d\udea7 Coming soon: semgrep.live link \ud83d\udea7\ud83d\udea7\n+\n+This can be generalized with the following approach:\n+\n+1. Match the function call by name.\n+2. Filter out good patterns.\n+\n+### Secure Cookies in Flask\n+\n+Another example of this approach is [setting secure cookies in Flask](https://semgrep.live/EwB5).\n+\n+```yaml\n+patterns:\n+- pattern-not: flask.response.set_cookie(..., httponly=True, secure=True,...)\n+- pattern: flask.response.set_cookie(...)\n+```\n+\n+## Ensure One Function is Called Before Another\n+\n+You can ensure one function is called before another in Semgrep by utilizing the `pattern-not-inside` clause. The approach will be:", "originalCommit": "2b054989a8d01cdf022dee4a3984034256554b32", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fecc8d092b3d82bd092a7dc38846399ef62689b8", "url": "https://github.com/returntocorp/semgrep/commit/fecc8d092b3d82bd092a7dc38846399ef62689b8", "message": "Address comments.", "committedDate": "2020-06-17T00:53:13Z", "type": "commit"}, {"oid": "cf7bcdebaad055588d7922440f0b68506b9c76bb", "url": "https://github.com/returntocorp/semgrep/commit/cf7bcdebaad055588d7922440f0b68506b9c76bb", "message": "Add documentation link for pattern-not-inside", "committedDate": "2020-06-17T00:54:03Z", "type": "commit"}, {"oid": "3360de3a216b2c60dd08bd522cbfedac23ed2f02", "url": "https://github.com/returntocorp/semgrep/commit/3360de3a216b2c60dd08bd522cbfedac23ed2f02", "message": "Add TOC", "committedDate": "2020-06-17T00:55:37Z", "type": "commit"}]}