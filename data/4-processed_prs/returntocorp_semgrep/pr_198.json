{"pr_number": 198, "pr_title": "pattern-where-python", "pr_createdAt": "2020-02-25T20:30:49Z", "pr_url": "https://github.com/returntocorp/semgrep/pull/198", "timeline": [{"oid": "3c862343e0f9b52fef9c9f5bf34b9af13379928f", "url": "https://github.com/returntocorp/semgrep/commit/3c862343e0f9b52fef9c9f5bf34b9af13379928f", "message": "Prototype where-python pattern, need to fix other test cases, now SgrepRange instead of Range is used (#166)", "committedDate": "2020-02-25T20:29:04Z", "type": "commit"}, {"oid": "3cb781ffbcfcebf712573c9e3456c9f0fa6dcc98", "url": "https://github.com/returntocorp/semgrep/commit/3cb781ffbcfcebf712573c9e3456c9f0fa6dcc98", "message": "complete port to SRange", "committedDate": "2020-02-25T20:29:47Z", "type": "commit"}, {"oid": "f9d0f0b6d299f199fc52509048ea8c4e0ff45f9c", "url": "https://github.com/returntocorp/semgrep/commit/f9d0f0b6d299f199fc52509048ea8c4e0ff45f9c", "message": "black", "committedDate": "2020-02-25T20:32:07Z", "type": "commit"}, {"oid": "4dbe3d902f23140f6d39359b86633bbf9fe2da57", "url": "https://github.com/returntocorp/semgrep/commit/4dbe3d902f23140f6d39359b86633bbf9fe2da57", "message": "flags.dangerously_allow_arbitrary_code_execution_from_rules", "committedDate": "2020-02-25T20:43:16Z", "type": "commit"}, {"oid": "fe05523066c5b876003f5e0c83dcb56df6adf277", "url": "https://github.com/returntocorp/semgrep/commit/fe05523066c5b876003f5e0c83dcb56df6adf277", "message": "switich to a class for rule expression", "committedDate": "2020-02-25T22:36:27Z", "type": "commit"}, {"oid": "19ffecf7800d43a584351496f42f32119c05c920", "url": "https://github.com/returntocorp/semgrep/commit/19ffecf7800d43a584351496f42f32119c05c920", "message": "consistent logic for where-python", "committedDate": "2020-02-25T23:36:15Z", "type": "commit"}, {"oid": "07a6f40afbe43a68671cddce32a32d5aba8bc8d5", "url": "https://github.com/returntocorp/semgrep/commit/07a6f40afbe43a68671cddce32a32d5aba8bc8d5", "message": "black", "committedDate": "2020-02-25T23:36:51Z", "type": "commit"}, {"oid": "7e5ba8b63ae1faea1f12bc12442ecc3bac01f422", "url": "https://github.com/returntocorp/semgrep/commit/7e5ba8b63ae1faea1f12bc12442ecc3bac01f422", "message": "mypy", "committedDate": "2020-02-25T23:56:46Z", "type": "commit"}, {"oid": "bda1b2ead35a7c3c1d176ef78063a6f489ee08fd", "url": "https://github.com/returntocorp/semgrep/commit/bda1b2ead35a7c3c1d176ef78063a6f489ee08fd", "message": "avoid validating patterns that don't need to be sent to sgrep", "committedDate": "2020-02-26T00:36:56Z", "type": "commit"}, {"oid": "7d4e45de6a52131e97a4269696d1bd93a024381c", "url": "https://github.com/returntocorp/semgrep/commit/7d4e45de6a52131e97a4269696d1bd93a024381c", "message": "shut up mypy", "committedDate": "2020-02-26T00:39:57Z", "type": "commit"}, {"oid": "c80f2baff2b50a84ef148caa9343273e4742c2d1", "url": "https://github.com/returntocorp/semgrep/commit/c80f2baff2b50a84ef148caa9343273e4742c2d1", "message": "black", "committedDate": "2020-02-26T00:40:07Z", "type": "commit"}, {"oid": "1f388d74c706d65f1501ded896d3a8d283c2a1f0", "url": "https://github.com/returntocorp/semgrep/commit/1f388d74c706d65f1501ded896d3a8d283c2a1f0", "message": "pre-commit", "committedDate": "2020-02-26T00:44:55Z", "type": "commit"}, {"oid": "7771b4d26118d6f0888c17dd4d45e38c0cb9451e", "url": "https://github.com/returntocorp/semgrep/commit/7771b4d26118d6f0888c17dd4d45e38c0cb9451e", "message": "fix single rule id", "committedDate": "2020-02-26T06:22:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3NjQ2NA==", "url": "https://github.com/returntocorp/semgrep/pull/198#discussion_r384676464", "bodyText": "alala, would be nice to have algebraic datatype in Python ...", "author": "aryx", "createdAt": "2020-02-26T18:20:38Z", "path": "sgrep.py", "diffHunk": "@@ -229,77 +257,140 @@ def _evaluate_single_expression(\n                 if is_enclosed:\n                     output_ranges.add(arange)\n                     break  # found a match, no need to keep going\n-        # print(f\"after filter `{operator}`: {output_ranges}\")\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n         return output_ranges\n-    elif operator == OPERATORS.AND_NOT_INSIDE:\n+    elif expression.operator == OPERATORS.AND_NOT_INSIDE:\n         # remove all ranges enclosed by or equal to\n         output_ranges = ranges_left.copy()\n         for arange in ranges_left:\n             for keep_inside_this_range in results_for_pattern:\n                 if keep_inside_this_range.is_enclosing_or_eq(arange):\n                     output_ranges.remove(arange)\n                     break\n-        # print(f\"after filter `{operator}`: {output_ranges}\")\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n+        return output_ranges\n+    elif expression.operator == OPERATORS.WHERE_PYTHON:\n+        if not RCE_RULE_FLAG not in flags:\n+            print_error_exit(\n+                f\"at least one rule needs to execute arbitrary code; this is dangerous! if you want to continue, enable the flag: RCE_RULE_FLAG\"\n+            )\n+        assert expression.operand, \"must have operand for this operator type\"", "originalCommit": "7771b4d26118d6f0888c17dd4d45e38c0cb9451e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3Njk0MQ==", "url": "https://github.com/returntocorp/semgrep/pull/198#discussion_r384676941", "bodyText": "woohoo", "author": "aryx", "createdAt": "2020-02-26T18:21:29Z", "path": "sgrep.py", "diffHunk": "@@ -229,77 +257,140 @@ def _evaluate_single_expression(\n                 if is_enclosed:\n                     output_ranges.add(arange)\n                     break  # found a match, no need to keep going\n-        # print(f\"after filter `{operator}`: {output_ranges}\")\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n         return output_ranges\n-    elif operator == OPERATORS.AND_NOT_INSIDE:\n+    elif expression.operator == OPERATORS.AND_NOT_INSIDE:\n         # remove all ranges enclosed by or equal to\n         output_ranges = ranges_left.copy()\n         for arange in ranges_left:\n             for keep_inside_this_range in results_for_pattern:\n                 if keep_inside_this_range.is_enclosing_or_eq(arange):\n                     output_ranges.remove(arange)\n                     break\n-        # print(f\"after filter `{operator}`: {output_ranges}\")\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n+        return output_ranges\n+    elif expression.operator == OPERATORS.WHERE_PYTHON:\n+        if not RCE_RULE_FLAG not in flags:\n+            print_error_exit(\n+                f\"at least one rule needs to execute arbitrary code; this is dangerous! if you want to continue, enable the flag: RCE_RULE_FLAG\"\n+            )\n+        assert expression.operand, \"must have operand for this operator type\"\n+\n+        output_ranges = set()\n+        # Look through every range that hasn't been filtered yet\n+        for sgrep_range in list(flatten(results.values())):\n+            # Only need to check where-python clause if the range hasn't already been filtered\n+\n+            if sgrep_range.range in ranges_left:\n+                debug_print(\n+                    f\"WHERE is {expression.operand}, metavars: {sgrep_range.metavars}\"\n+                )\n+                if where_python_statement_matches(\n+                    expression.operand, sgrep_range.metavars\n+                ):\n+                    output_ranges.add(sgrep_range.range)\n+        debug_print(f\"after filter `{expression.operator}`: {output_ranges}\")\n         return output_ranges\n+\n     else:\n         raise NotImplementedError(\n-            f\"{PLEASE_FILE_ISSUE_TEXT}: unknown operator {operator}\"\n+            f\"{PLEASE_FILE_ISSUE_TEXT}: unknown operator {expression.operator}\"\n         )\n \n \n-def evaluate_expression(expression, results: Dict[str, List[Range]]) -> Set[Range]:\n-    ranges_left = set(flatten(results.values()))\n-    return _evaluate_expression(expression, results, ranges_left)\n+# Given a `where-python` expression as a string and currently matched metavars,\n+# return whether the expression matches as a boolean\n+def where_python_statement_matches(\n+    where_expression: str, metavars: Dict[str, str]\n+) -> bool:\n+    # TODO: filter out obvious dangerous things here\n+    global output\n+    output = None\n+\n+    # HACK: we're executing arbitrary Python in the where-python,\n+    # be careful my friend\n+    vars = metavars\n+    try:\n+        exec(f\"global output; output = {where_expression}\")", "originalCommit": "7771b4d26118d6f0888c17dd4d45e38c0cb9451e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3NzE1OQ==", "url": "https://github.com/returntocorp/semgrep/pull/198#discussion_r384677159", "bodyText": "What is the difference between exec and eval?", "author": "aryx", "createdAt": "2020-02-26T18:21:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3Njk0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg0NDQwNw==", "url": "https://github.com/returntocorp/semgrep/pull/198#discussion_r384844407", "bodyText": "https://stackoverflow.com/questions/2220699/whats-the-difference-between-eval-exec-and-compile/29456463#29456463 @aryx this is a great explanation", "author": "ievans", "createdAt": "2020-02-27T00:15:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDY3Njk0MQ=="}], "type": "inlineReview"}, {"oid": "a0ed4b508298b7666e271a7cc6686bf97434c132", "url": "https://github.com/returntocorp/semgrep/commit/a0ed4b508298b7666e271a7cc6686bf97434c132", "message": "Merge branch 'develop' into feature/where-python", "committedDate": "2020-02-26T19:41:33Z", "type": "commit"}, {"oid": "571f3c24cbbc1f81e376608d7900b248759d3c53", "url": "https://github.com/returntocorp/semgrep/commit/571f3c24cbbc1f81e376608d7900b248759d3c53", "message": "Update sgrep.py\n\nMissing f string", "committedDate": "2020-02-26T20:29:31Z", "type": "commit"}, {"oid": "1f277c205662ed9b0ae44693b87cf080ea102462", "url": "https://github.com/returntocorp/semgrep/commit/1f277c205662ed9b0ae44693b87cf080ea102462", "message": "clearer error messages for invalid YAML files (#215)\n\n* better error messages and tests, close issue #210", "committedDate": "2020-02-27T16:19:26Z", "type": "commit"}]}