{"pr_number": 2125, "pr_title": "Port tree-sitter-c CST to ast_c.ml", "pr_createdAt": "2020-11-25T16:25:55Z", "pr_url": "https://github.com/returntocorp/semgrep/pull/2125", "timeline": [{"oid": "4fbe41f83765c2587d9b5d1acfc5cbb95aa6667b", "url": "https://github.com/returntocorp/semgrep/commit/4fbe41f83765c2587d9b5d1acfc5cbb95aa6667b", "message": "Start of using tree-sitter-c to parse C code\n\ntest plan:\n$ /home/pad/semgrep/_build/default/cli/Main.exe -dump_ast misc_ifdef_strings.c\n\nwhich currently fails and dump the tree-sitter C CST.", "committedDate": "2020-11-24T10:15:43Z", "type": "commit"}, {"oid": "cf4f42cbb9c0480beb9dc3cb33c36ea808fcd818", "url": "https://github.com/returntocorp/semgrep/commit/cf4f42cbb9c0480beb9dc3cb33c36ea808fcd818", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: remove map_ prefix", "committedDate": "2020-11-24T10:20:33Z", "type": "commit"}, {"oid": "72859c69efc0cfc4924f93f7ba45fc586ba3cb0f", "url": "https://github.com/returntocorp/semgrep/commit/72859c69efc0cfc4924f93f7ba45fc586ba3cb0f", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: clean some warnings", "committedDate": "2020-11-24T10:26:57Z", "type": "commit"}, {"oid": "9c845b6cda8f73268949dde759ed646f53e0a2bf", "url": "https://github.com/returntocorp/semgrep/commit/9c845b6cda8f73268949dde759ed646f53e0a2bf", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: adding types for expr", "committedDate": "2020-11-24T10:39:02Z", "type": "commit"}, {"oid": "b07bc992c133e66a19eb98505d3f7c3a858b8ec2", "url": "https://github.com/returntocorp/semgrep/commit/b07bc992c133e66a19eb98505d3f7c3a858b8ec2", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: adding type annotations", "committedDate": "2020-11-24T10:52:19Z", "type": "commit"}, {"oid": "b1c4b23e65008bbc8f9c2fe04241ad75eeb5ddad", "url": "https://github.com/returntocorp/semgrep/commit/b1c4b23e65008bbc8f9c2fe04241ad75eeb5ddad", "message": "* semgrep-core/parsing/Parse_tree_sitter_helpers.mli: extend env type", "committedDate": "2020-11-24T10:56:19Z", "type": "commit"}, {"oid": "22a128f910d918a7f87587643d626b1b4bdcfeff", "url": "https://github.com/returntocorp/semgrep/commit/22a128f910d918a7f87587643d626b1b4bdcfeff", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: convert operators", "committedDate": "2020-11-24T11:23:27Z", "type": "commit"}, {"oid": "b04afbe1ac0736c1a03af9bed07d4e862a0911f5", "url": "https://github.com/returntocorp/semgrep/commit/b04afbe1ac0736c1a03af9bed07d4e862a0911f5", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: progress", "committedDate": "2020-11-24T11:38:10Z", "type": "commit"}, {"oid": "e497a29d505518704e6e0e0507ec9ae1881ab871", "url": "https://github.com/returntocorp/semgrep/commit/e497a29d505518704e6e0e0507ec9ae1881ab871", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: progress", "committedDate": "2020-11-24T12:05:19Z", "type": "commit"}, {"oid": "e7a18c167c0bfbd45ed7c0ad267a1df17cc2201d", "url": "https://github.com/returntocorp/semgrep/commit/e7a18c167c0bfbd45ed7c0ad267a1df17cc2201d", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: progress", "committedDate": "2020-11-24T13:38:19Z", "type": "commit"}, {"oid": "183984ee7f9cb7b3000e3552df5ceab89051b08f", "url": "https://github.com/returntocorp/semgrep/commit/183984ee7f9cb7b3000e3552df5ceab89051b08f", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: progress", "committedDate": "2020-11-24T13:54:38Z", "type": "commit"}, {"oid": "e1b3d23d57d2e1424a7e33cc1045359795230d6c", "url": "https://github.com/returntocorp/semgrep/commit/e1b3d23d57d2e1424a7e33cc1045359795230d6c", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: progress", "committedDate": "2020-11-24T14:06:29Z", "type": "commit"}, {"oid": "5e816f8111d03010f8149e3e27f049d52cb09e80", "url": "https://github.com/returntocorp/semgrep/commit/5e816f8111d03010f8149e3e27f049d52cb09e80", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: progress", "committedDate": "2020-11-24T14:56:49Z", "type": "commit"}, {"oid": "c273e0f6ea37cc579e4167102d1137cba58d6c26", "url": "https://github.com/returntocorp/semgrep/commit/c273e0f6ea37cc579e4167102d1137cba58d6c26", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: progress", "committedDate": "2020-11-24T15:10:13Z", "type": "commit"}, {"oid": "66cab7ca86e50a869feaf08b03eb70332ea2b45d", "url": "https://github.com/returntocorp/semgrep/commit/66cab7ca86e50a869feaf08b03eb70332ea2b45d", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: misc", "committedDate": "2020-11-24T15:22:28Z", "type": "commit"}, {"oid": "c610072db47b77581a7b751cbf535b659cee93b2", "url": "https://github.com/returntocorp/semgrep/commit/c610072db47b77581a7b751cbf535b659cee93b2", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: before declarator", "committedDate": "2020-11-24T15:46:36Z", "type": "commit"}, {"oid": "350da353f42988d5188f540d4ce60209c739983d", "url": "https://github.com/returntocorp/semgrep/commit/350da353f42988d5188f540d4ce60209c739983d", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: declarators", "committedDate": "2020-11-24T16:17:19Z", "type": "commit"}, {"oid": "3aac9cca598a311f2a1c6e48cc033679d6215a7c", "url": "https://github.com/returntocorp/semgrep/commit/3aac9cca598a311f2a1c6e48cc033679d6215a7c", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: progress", "committedDate": "2020-11-24T16:50:50Z", "type": "commit"}, {"oid": "78a90b1fa1afb8966f1be6f3fbcbb3724d564bbb", "url": "https://github.com/returntocorp/semgrep/commit/78a90b1fa1afb8966f1be6f3fbcbb3724d564bbb", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: progress", "committedDate": "2020-11-24T16:59:02Z", "type": "commit"}, {"oid": "640f663c1d4cb28f6d277a88fc33c29756a5ab69", "url": "https://github.com/returntocorp/semgrep/commit/640f663c1d4cb28f6d277a88fc33c29756a5ab69", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: progress", "committedDate": "2020-11-25T08:34:11Z", "type": "commit"}, {"oid": "49c023fd0a9407f4b8d19acf07eb163189b8dbe6", "url": "https://github.com/returntocorp/semgrep/commit/49c023fd0a9407f4b8d19acf07eb163189b8dbe6", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: CE after toplevel type split in definition and directive", "committedDate": "2020-11-25T09:29:26Z", "type": "commit"}, {"oid": "3cdf25d8c444ea43cd04ed89e93624aec7b0b82c", "url": "https://github.com/returntocorp/semgrep/commit/3cdf25d8c444ea43cd04ed89e93624aec7b0b82c", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: bool and null", "committedDate": "2020-11-25T10:24:34Z", "type": "commit"}, {"oid": "c947149c17b9f45294638d63ce8fb3bd2bef2fdf", "url": "https://github.com/returntocorp/semgrep/commit/c947149c17b9f45294638d63ce8fb3bd2bef2fdf", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: progress with new constructs\nin ast_c.ml", "committedDate": "2020-11-25T11:37:03Z", "type": "commit"}, {"oid": "4ea790bbb30afb1d56b661d7fa67a42b8a2efbc3", "url": "https://github.com/returntocorp/semgrep/commit/4ea790bbb30afb1d56b661d7fa67a42b8a2efbc3", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: progress", "committedDate": "2020-11-25T11:53:41Z", "type": "commit"}, {"oid": "16021ec801a77d89c70fcec822a63b7ae48c3026", "url": "https://github.com/returntocorp/semgrep/commit/16021ec801a77d89c70fcec822a63b7ae48c3026", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: before merge toplevel/stmt", "committedDate": "2020-11-25T14:04:16Z", "type": "commit"}, {"oid": "deeb02154b97f4d9656af027b480ddc7b4cf1a6d", "url": "https://github.com/returntocorp/semgrep/commit/deeb02154b97f4d9656af027b480ddc7b4cf1a6d", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: progress", "committedDate": "2020-11-25T14:48:09Z", "type": "commit"}, {"oid": "c1d77406042e64275747887c2d5fa1e697164eca", "url": "https://github.com/returntocorp/semgrep/commit/c1d77406042e64275747887c2d5fa1e697164eca", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: basic ArrayInit", "committedDate": "2020-11-25T15:04:03Z", "type": "commit"}, {"oid": "620f0fd1c0548a652892d22f009fcd700c342f0c", "url": "https://github.com/returntocorp/semgrep/commit/620f0fd1c0548a652892d22f009fcd700c342f0c", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml:\nhandle struct and enum defs", "committedDate": "2020-11-25T15:32:03Z", "type": "commit"}, {"oid": "fe4a1c086fa8ccaf5220794500217daf72b935d8", "url": "https://github.com/returntocorp/semgrep/commit/fe4a1c086fa8ccaf5220794500217daf72b935d8", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: CaseStmt", "committedDate": "2020-11-25T15:51:08Z", "type": "commit"}, {"oid": "09ea2cd4519c59bd2db11c533d59cc8cab41afcd", "url": "https://github.com/returntocorp/semgrep/commit/09ea2cd4519c59bd2db11c533d59cc8cab41afcd", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: DONE! FINALLY!", "committedDate": "2020-11-25T16:02:29Z", "type": "commit"}, {"oid": "ed4e2548092662fa73c3937deedc3bfd72ee373e", "url": "https://github.com/returntocorp/semgrep/commit/ed4e2548092662fa73c3937deedc3bfd72ee373e", "message": "* semgrep-core/parsing/Parse_c_tree_sitter.ml: fixing all unused var\nwarning by prefixing those vars with a _", "committedDate": "2020-11-25T16:13:25Z", "type": "commit"}, {"oid": "e8fb3530b2279963054c7cb048eed35c3f066362", "url": "https://github.com/returntocorp/semgrep/commit/e8fb3530b2279963054c7cb048eed35c3f066362", "message": "* semgrep-core/tests/Test.ml: do not fail when partial parse error", "committedDate": "2020-11-25T16:20:47Z", "type": "commit"}, {"oid": "c3afa705b43541bc12d47d2f56eefdfeeb903bd4", "url": "https://github.com/returntocorp/semgrep/commit/c3afa705b43541bc12d47d2f56eefdfeeb903bd4", "message": "* semgrep-core/tests/c/misc_ifdef_strings.c: forgot test files", "committedDate": "2020-11-25T16:26:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDY1ODU1NQ==", "url": "https://github.com/returntocorp/semgrep/pull/2125#discussion_r530658555", "bodyText": "Maybe rename it to Number if it can hold an int or a float?", "author": "mjambon", "createdAt": "2020-11-25T21:47:35Z", "path": "semgrep-core/parsing/Parse_c_tree_sitter.ml", "diffHunk": "@@ -0,0 +1,1746 @@\n+(* Yoann Padioleau\n+ *\n+ * Copyright (C) 2020 r2c\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU General Public License (GPL)\n+ * version 2 as published by the Free Software Foundation.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+ * file license.txt for more details.\n+ *)\n+open Common\n+module AST = Ast_c\n+module CST = Tree_sitter_c.CST\n+module PI = Parse_info\n+open Cst_cpp\n+open Ast_c\n+module G = AST_generic\n+module H = Parse_tree_sitter_helpers\n+\n+(*****************************************************************************)\n+(* Prelude *)\n+(*****************************************************************************)\n+(* C parser using ocaml-tree-sitter-lang/c and converting\n+ * to pfff/lang_c/parsing/ast_c.ml\n+ *\n+ * The resulting AST can then be converted to the generic AST by using\n+ * pfff/lang_c/analyze/c_to_generic.ml\n+ *)\n+\n+(*****************************************************************************)\n+(* Helpers *)\n+(*****************************************************************************)\n+type extra = {\n+  (* gensym *)\n+  mutable cnt: int;\n+  mutable struct_defs_toadd: struct_def list;\n+  mutable enum_defs_toadd: enum_def list;\n+  mutable typedefs_toadd: type_def list;\n+}\n+(* similar to Ast_c_build env *)\n+let default_extra_env = {\n+  cnt = 0;\n+\n+  struct_defs_toadd = [];\n+  enum_defs_toadd = [];\n+  typedefs_toadd = [];\n+}\n+let gensym_struct cnt =\n+  spf \"__anon_struct_%d\" cnt\n+\n+let gensym_enum cnt =\n+  spf \"__anon_enum_%d\" cnt\n+\n+type env = extra H.env\n+\n+let _fake = G.fake\n+let token = H.token\n+let str = H.str\n+\n+(*****************************************************************************)\n+(* Boilerplate converter *)\n+(*****************************************************************************)\n+(* This was started by copying ocaml-tree-sitter-lang/go/.../Boilerplate.ml *)\n+\n+(**\n+   Boilerplate to be used as a template when mapping the c CST\n+   to another type of tree.\n+*)\n+\n+let anon_choice_BANG_67174d6 (env : env) (x : CST.anon_choice_BANG_67174d6) =\n+  (match x with\n+  | `BANG tok -> Not, token env tok (* \"!\" *)\n+  | `TILDE tok -> Tilde, token env tok (* \"~\" *)\n+  | `DASH tok -> UnMinus, token env tok (* \"-\" *)\n+  | `PLUS tok -> UnPlus, token env tok (* \"+\" *)\n+  )\n+\n+\n+let type_qualifier (env : env) (x : CST.type_qualifier) =\n+  (match x with\n+  | `Const tok -> token env tok (* \"const\" *)\n+  | `Vola tok -> token env tok (* \"volatile\" *)\n+  | `Rest tok -> token env tok (* \"restrict\" *)\n+  | `X__Atomic tok -> token env tok (* \"_Atomic\" *)\n+  )\n+\n+\n+let identifier (env : env) (tok : CST.identifier) : name =\n+  str env tok (* pattern [a-zA-Z_]\\w* *)\n+\n+let storage_class_specifier (env : env) (x : CST.storage_class_specifier) =\n+  (match x with\n+  | `Extern tok -> token env tok (* \"extern\" *)\n+  | `Static tok -> token env tok (* \"static\" *)\n+  | `Auto tok -> token env tok (* \"auto\" *)\n+  | `Regi tok -> token env tok (* \"register\" *)\n+  | `Inline tok -> token env tok (* \"inline\" *)\n+  )\n+\n+let ms_call_modifier (env : env) (x : CST.ms_call_modifier) =\n+  (match x with\n+  | `X___cdecl tok -> token env tok (* \"__cdecl\" *)\n+  | `X___clrc tok -> token env tok (* \"__clrcall\" *)\n+  | `X___stdc tok -> token env tok (* \"__stdcall\" *)\n+  | `X___fast tok -> token env tok (* \"__fastcall\" *)\n+  | `X___this tok -> token env tok (* \"__thiscall\" *)\n+  | `X___vect tok -> token env tok (* \"__vectorcall\" *)\n+  )\n+\n+let ms_unaligned_ptr_modifier (env : env) (x : CST.ms_unaligned_ptr_modifier) =\n+  (match x with\n+  | `X__unal tok -> token env tok (* \"_unaligned\" *)\n+  | `X___unal tok -> token env tok (* \"__unaligned\" *)\n+  )\n+\n+let anon_choice_DASHDASH_d11def2 (env : env) (x : CST.anon_choice_DASHDASH_d11def2) =\n+  (match x with\n+  | `DASHDASH tok -> Dec, token env tok (* \"--\" *)\n+  | `PLUSPLUS tok -> Inc, token env tok (* \"++\" *)\n+  )\n+\n+let string_literal (env : env) ((v1, v2, v3) : CST.string_literal) : string wrap =\n+  let v1 =\n+    (match v1 with\n+    | `LDQUOT tok -> token env tok (* \"L\\\"\" *)\n+    | `UDQUOT_c163aae tok -> token env tok (* \"u\\\"\" *)\n+    | `UDQUOT_df3447d tok -> token env tok (* \"U\\\"\" *)\n+    | `U8DQUOT tok -> token env tok (* \"u8\\\"\" *)\n+    | `DQUOT tok -> token env tok (* \"\\\"\" *)\n+    )\n+  in\n+  let v2 =\n+    List.map (fun x ->\n+      (match x with\n+      | `Imm_tok_pat_c7f65b4 tok ->\n+          str env tok (* pattern \"[^\\\\\\\\\\\"\\\\n]+\" *)\n+      | `Esc_seq tok -> str env tok (* escape_sequence *)\n+      )\n+    ) v2\n+  in\n+  let v3 = token env v3 (* \"\\\"\" *) in\n+  let s = v2 |> List.map fst |> String.concat \"\" in\n+  s, PI.combine_infos v1 (List.map snd v2 @ [v3])\n+\n+let char_literal (env : env) ((v1, v2, v3) : CST.char_literal) : string wrap =\n+  let v1 =\n+    (match v1 with\n+    | `LSQUOT tok -> token env tok (* \"L'\" *)\n+    | `USQUOT_d861d39 tok -> token env tok (* \"u'\" *)\n+    | `USQUOT_2701bdc tok -> token env tok (* \"U'\" *)\n+    | `U8SQUOT tok -> token env tok (* \"u8'\" *)\n+    | `SQUOT tok -> token env tok (* \"'\" *)\n+    )\n+  in\n+  let v2 =\n+    (match v2 with\n+    | `Esc_seq tok -> str env tok (* escape_sequence *)\n+    | `Imm_tok_pat_36637e2 tok ->\n+        str env tok (* pattern \"[^\\\\n']\" *)\n+    )\n+  in\n+  let v3 = token env v3 (* \"'\" *) in\n+  let s = fst v2 in\n+  s, PI.combine_infos v1 ([snd v2; v3])\n+\n+\n+let anon_choice_pat_25b90ba_4a37f8c (env : env) (x : CST.anon_choice_pat_25b90ba_4a37f8c) =\n+  (match x with\n+  | `Pat_25b90ba tok ->\n+      token env tok (* pattern #[ \t]*ifdef *)\n+  | `Pat_9d92f6a tok ->\n+      token env tok (* pattern #[ \t]*ifndef *)\n+  )\n+\n+let ms_pointer_modifier (env : env) (x : CST.ms_pointer_modifier) =\n+  (match x with\n+  | `Ms_unal_ptr_modi x -> ms_unaligned_ptr_modifier env x\n+  | `Ms_rest_modi tok -> token env tok (* \"__restrict\" *)\n+  | `Ms_unsi_ptr_modi tok -> token env tok (* \"__uptr\" *)\n+  | `Ms_signed_ptr_modi tok -> token env tok (* \"__sptr\" *)\n+  )\n+\n+(* can actually contain a complex expression, but just parsed as a string\n+ * until non-escaped newline in tree-sitter-c.\n+ *)\n+let preproc_arg env tok =\n+  str env tok\n+\n+let preproc_call (env : env) ((v1, v2, v3) : CST.preproc_call) =\n+  let v1 = identifier env v1 (* pattern #[ \\t]*[a-zA-Z]\\w* *) in\n+  let _v3 = token env v3 (* \"\\n\" *) in\n+  let v2 =\n+    (match v2 with\n+    | Some tok -> Some (preproc_arg env tok) (* preproc_arg *)\n+    | None -> None\n+    )\n+  in\n+  OtherDirective (v1, v2)\n+\n+let field_designator (env : env) ((v1, v2) : CST.field_designator) : name =\n+  let _v1 = token env v1 (* \".\" *) in\n+  let v2 = str env v2 (* pattern [a-zA-Z_]\\w* *) in\n+  v2\n+\n+let preproc_defined (env : env) (x : CST.preproc_defined) : tok * name =\n+  (match x with\n+  | `Defi_LPAR_id_RPAR (v1, v2, v3, v4) ->\n+      let v1 = token env v1 (* \"defined\" *) in\n+      let _v2 = token env v2 (* \"(\" *) in\n+      let v3 = identifier env v3 (* pattern [a-zA-Z_]\\w* *) in\n+      let _v4 = token env v4 (* \")\" *) in\n+      v1, v3\n+  | `Defi_id (v1, v2) ->\n+      let v1 = token env v1 (* \"defined\" *) in\n+      let v2 = identifier env v2 (* pattern [a-zA-Z_]\\w* *) in\n+      v1, v2\n+  )\n+\n+let anon_choice_type_id_d3c4b5f (env : env) (x : CST.anon_choice_type_id_d3c4b5f) =\n+  (match x with\n+  | `Id tok -> str env tok (* pattern [a-zA-Z_]\\w* *)\n+  | `DOTDOTDOT tok -> \"...\", token env tok (* \"...\" *)\n+  )\n+\n+let ms_declspec_modifier (env : env) ((v1, v2, v3, v4) : CST.ms_declspec_modifier) =\n+  let _v1 = token env v1 (* \"__declspec\" *) in\n+  let _v2 = token env v2 (* \"(\" *) in\n+  let _v3 = token env v3 (* pattern [a-zA-Z_]\\w* *) in\n+  let _v4 = token env v4 (* \")\" *) in\n+  ()\n+\n+let preproc_def (env : env) ((v1, v2, v3, v4) : CST.preproc_def) : directive =\n+  let v1 = token env v1 (* pattern #[ \t]*define *) in\n+  let v2 = str env v2 (* pattern [a-zA-Z_]\\w* *) in\n+  let v3 =\n+    (match v3 with\n+    | Some tok -> Some (preproc_arg env tok) (* preproc_arg *)\n+    | None -> None)\n+  in\n+  let _v4 = token env v4 (* \"\\n\" *) in\n+  (match v3 with\n+  | Some x -> Define (v1, v2, Some (CppExpr (String x)))\n+  | None -> Define (v1, v2, None)\n+  )\n+\n+let rec preproc_argument_list (env : env) ((v1, v2, v3) : CST.preproc_argument_list) : argument list bracket =\n+  let v1 = token env v1 (* \"(\" *) in\n+  let v2 =\n+    (match v2 with\n+    | Some (v1, v2) ->\n+        let v1 = preproc_expression env v1 in\n+        let v2 =\n+          List.map (fun (v1, v2) ->\n+            let _v1 = token env v1 (* \",\" *) in\n+            let v2 = preproc_expression env v2 in\n+            v2\n+          ) v2\n+        in\n+        v1::v2\n+    | None -> [])\n+  in\n+  let v3 = token env v3 (* \")\" *) in\n+  v1, (v2 |> List.map (fun x -> Arg x)), v3\n+\n+and preproc_binary_expression (env : env) (x : CST.preproc_binary_expression)\n+ : expr =\n+  (match x with\n+  | `Prep_exp_PLUS_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"+\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Arith Plus in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_DASH_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"-\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Arith Minus in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_STAR_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"*\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Arith Mul in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_SLASH_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"/\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Arith Div in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_PERC_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"%\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Arith Mod in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_BARBAR_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"||\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Logical OrLog in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_AMPAMP_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"&&\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Logical AndLog in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_BAR_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"|\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Arith Or in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_HAT_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"^\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Arith Xor in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_AMP_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"&\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Arith And in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_EQEQ_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"==\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Logical Eq in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_BANGEQ_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"!=\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Logical NotEq in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_GT_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \">\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Logical Sup in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_GTEQ_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \">=\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Logical SupEq in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_LTEQ_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"<=\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Logical InfEq in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_LT_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"<\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Logical Inf in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_LTLT_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \"<<\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Arith DecLeft in\n+      Binary (v1, (op, v2), v3)\n+  | `Prep_exp_GTGT_prep_exp (v1, v2, v3) ->\n+      let v1 = preproc_expression env v1 in\n+      let v2 = token env v2 (* \">>\" *) in\n+      let v3 = preproc_expression env v3 in\n+      let op = Arith DecRight in\n+      Binary (v1, (op, v2), v3)\n+  )\n+\n+and preproc_call_expression (env : env) ((v1, v2) : CST.preproc_call_expression) =\n+  let v1 = identifier env v1 (* pattern [a-zA-Z_]\\w* *) in\n+  let v2 = preproc_argument_list env v2 in\n+  Call (Id v1, v2)\n+\n+(* Int or Float ! *)\n+and number_literal env tok =\n+  let n = str env tok in\n+  Int n", "originalCommit": "c3afa705b43541bc12d47d2f56eefdfeeb903bd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}