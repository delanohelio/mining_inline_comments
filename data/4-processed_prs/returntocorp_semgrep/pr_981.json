{"pr_number": 981, "pr_title": "Refactor main into OutputHandler", "pr_createdAt": "2020-06-11T21:34:23Z", "pr_url": "https://github.com/returntocorp/semgrep/pull/981", "timeline": [{"oid": "f8b110b4a3a181b958992be45438c51685a400f0", "url": "https://github.com/returntocorp/semgrep/commit/f8b110b4a3a181b958992be45438c51685a400f0", "message": "Refactor main into OutputHandler\n\nThe idea is that all output will be routed through the output handler. This will allow us to collect errors to eventually be added to the JSON, print data as it's ready, and capture output for test purposes.\n\nNot everything is wired up to it yet, I wanted to keep this diff under control.", "committedDate": "2020-06-11T21:37:29Z", "type": "forcePushed"}, {"oid": "3545dd8f3ee001ba3fbcf2fcadf59f1da41b9340", "url": "https://github.com/returntocorp/semgrep/commit/3545dd8f3ee001ba3fbcf2fcadf59f1da41b9340", "message": "Refactor main into OutputHandler\n\nThe idea is that all output will be routed through the output handler. This will allow us to collect errors to eventually be added to the JSON, print data as it's ready, and capture output for test purposes.\n\nNot everything is wired up to it yet, I wanted to keep this diff under control.", "committedDate": "2020-06-11T22:04:27Z", "type": "forcePushed"}, {"oid": "6eb620bb7b4706cdd9e362eda8d274ccaef021a8", "url": "https://github.com/returntocorp/semgrep/commit/6eb620bb7b4706cdd9e362eda8d274ccaef021a8", "message": "Refactor main into OutputHandler\n\nThe idea is that all output will be routed through the output handler. This will allow us to collect errors to eventually be added to the JSON, print data as it's ready, and capture output for test purposes.\n\nNot everything is wired up to it yet, I wanted to keep this diff under control.", "committedDate": "2020-06-12T14:47:52Z", "type": "commit"}, {"oid": "6eb620bb7b4706cdd9e362eda8d274ccaef021a8", "url": "https://github.com/returntocorp/semgrep/commit/6eb620bb7b4706cdd9e362eda8d274ccaef021a8", "message": "Refactor main into OutputHandler\n\nThe idea is that all output will be routed through the output handler. This will allow us to collect errors to eventually be added to the JSON, print data as it's ready, and capture output for test purposes.\n\nNot everything is wired up to it yet, I wanted to keep this diff under control.", "committedDate": "2020-06-12T14:47:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3ODM1NQ==", "url": "https://github.com/returntocorp/semgrep/pull/981#discussion_r439478355", "bodyText": "What's the advantage of a context manager here? Can we just initialize OutputHandlers where necessary and continue to let __main__ be the final arbiter of exceptions and exiting? It seems odd to have our output handler doing a sys.exit for us.", "author": "mschwager", "createdAt": "2020-06-12T15:10:06Z", "path": "semgrep/semgrep/output.py", "diffHunk": "@@ -173,3 +187,178 @@ def build_output(\n     else:\n         # https://github.com/python/mypy/issues/6366\n         raise RuntimeError(f\"Unhandled output format: {type(output_format).__name__}\")\n+\n+\n+class OutputSettings(NamedTuple):\n+    output_format: OutputFormat\n+    output_destination: Optional[str]\n+    quiet: bool\n+    error_on_findings: bool\n+\n+\n+@contextlib.contextmanager\n+def managed_output(output_settings: OutputSettings) -> Generator:  # type: ignore", "originalCommit": "6eb620bb7b4706cdd9e362eda8d274ccaef021a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ4NjUzNw==", "url": "https://github.com/returntocorp/semgrep/pull/981#discussion_r439486537", "bodyText": "The point of the context manager was to ensure that .close() gets called and that no matter what happens, we output all the errors we've collected so far in a consistent way.\nI agree - I don't love having the output manager call sys.exit. However, I don't agree that main should be the final arbiter of exceptions - the whole point of this is to allow us to be able to collect things to output that will always be print in the event of a final exception, which I don't think __main__ is well set up to do.", "author": "rcoh", "createdAt": "2020-06-12T15:24:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3ODM1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwMDIzNQ==", "url": "https://github.com/returntocorp/semgrep/pull/981#discussion_r439500235", "bodyText": "How about we let the OutputHandler deal with the output and have __main__ deal with the exit codes? I.e. call .close() in finally, but re-raise the exception ex in the except so __main__ can grab the code and exit. That way OutputHandler doesn't need to worry about exit_code, but can still do all the printing.\nI believe this should give us the behavior we want, e.g.\nIn [32]: try: \n    ...:     raise Exception('EXCEPTION') \n    ...: except Exception as e: \n    ...:     print('EXCEPT') \n    ...:     raise \n    ...: finally: \n    ...:     print('FINALLY') \n    ...:                                                                                                \nEXCEPT\nFINALLY\n---------------------------------------------------------------------------\nException                                 Traceback (most recent call last)\n<ipython-input-32-04917ed8d528> in <module>\n      1 try:\n----> 2     raise Exception('EXCEPTION')\n      3 except Exception as e:\n      4     print('EXCEPT')\n      5     raise\n\nException: EXCEPTION", "author": "mschwager", "createdAt": "2020-06-12T15:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3ODM1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTUwNzcwMg==", "url": "https://github.com/returntocorp/semgrep/pull/981#discussion_r439507702", "bodyText": "\ud83d\udc4d I like this", "author": "rcoh", "createdAt": "2020-06-12T16:03:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3ODM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3ODQyNw==", "url": "https://github.com/returntocorp/semgrep/pull/981#discussion_r439478427", "bodyText": "This feels kinda hamfisted compared to using Python's builtin mechanism for doing this:\ntry:\n    ...\nexcept ExceptionType1:\n    ...\nexcept ExceptionType2:\n    ...", "author": "mschwager", "createdAt": "2020-06-12T15:10:11Z", "path": "semgrep/semgrep/output.py", "diffHunk": "@@ -173,3 +187,178 @@ def build_output(\n     else:\n         # https://github.com/python/mypy/issues/6366\n         raise RuntimeError(f\"Unhandled output format: {type(output_format).__name__}\")\n+\n+\n+class OutputSettings(NamedTuple):\n+    output_format: OutputFormat\n+    output_destination: Optional[str]\n+    quiet: bool\n+    error_on_findings: bool\n+\n+\n+@contextlib.contextmanager\n+def managed_output(output_settings: OutputSettings) -> Generator:  # type: ignore\n+    handler = OutputHandler(output_settings)\n+    try:\n+        yield handler\n+    except Exception as ex:\n+        handler.handle_unhandled_exception(ex)\n+    finally:\n+        exit_code = handler.close()\n+        sys.exit(exit_code)\n+\n+\n+class OutputHandler:\n+    \"\"\"\n+    Handle all output in a central location. Rather than calling `print_error` directly,\n+    you should call `handle_*` as appropriate.\n+\n+    In normal usage, it should be constructed via the contextmanager, `managed_output`. It ensures that everything\n+    is handled properly if exceptions are thrown.\n+\n+    If you need to stop execution immediately (think carefully if you really want this!), throw an exception.\n+    If this is normal behavior, the exception _must_ inherit from `SemgrepError`.\n+\n+    If you want execution to continue, _report_ the exception via the appropriate `handle_*` method.\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        output_settings: OutputSettings,\n+        stderr: IO = sys.stderr,\n+        stdout: IO = sys.stdout,\n+    ):\n+        self.settings = output_settings\n+        self.stderr = stderr\n+        self.stdout = stdout\n+\n+        self.rule_matches: List[RuleMatch] = []\n+        self.debug_steps_by_rule: Dict[Rule, List[Dict[str, Any]]] = {}\n+        self.rules: FrozenSet[Rule] = frozenset()\n+        self.semgrep_core_errors: List[Dict[str, Any]] = []\n+        self.semgrep_rule_errors: List[SemgrepError] = []\n+        self.has_output = False\n+\n+        self.exit_code = 0\n+        self.final_error: Optional[Exception] = None\n+\n+    def handle_semgrep_core_errors(self, semgrep_errors: List[Dict[str, Any]]) -> None:\n+        \"\"\"\n+        Report errors coming directly from semgrep-core (raw JSON objects)\n+        \"\"\"\n+        self.semgrep_core_errors += semgrep_errors\n+        if self.settings.output_format == OutputFormat.TEXT:\n+            for error in semgrep_errors:\n+                print_error(pretty_error(error))\n+\n+    def handle_semgrep_rule_errors(self, error: SemgrepError) -> None:\n+        \"\"\"\n+        Report parse errors from semgrep rules. Either:\n+        - when the pattern fails to parse in semgrep-core\n+        - when the YAML or YAML structure is invalid\n+        \"\"\"\n+        self.semgrep_rule_errors.append(error)\n+        self._output_exception(error)\n+\n+    def handle_semgrep_core_output(\n+        self,\n+        rule_matches_by_rule: Dict[Rule, List[RuleMatch]],\n+        debug_steps_by_rule: Dict[Rule, List[Dict[str, Any]]],\n+    ) -> None:\n+        self.has_output = True\n+        self.rules = self.rules.union(rule_matches_by_rule.keys())\n+        self.rule_matches += [\n+            match\n+            for matches_of_one_rule in rule_matches_by_rule.values()\n+            for match in matches_of_one_rule\n+        ]\n+\n+        self.debug_steps_by_rule.update(debug_steps_by_rule)\n+\n+    def handle_unhandled_exception(self, ex: Exception) -> None:\n+        \"\"\"\n+        This is called by the context manager upon an unhandled exception. If you want to record a final\n+        error & set the exit code, but keep executing to perform cleanup tasks, call this method.\n+        \"\"\"\n+        if isinstance(ex, SemgrepError):", "originalCommit": "6eb620bb7b4706cdd9e362eda8d274ccaef021a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ4MzA0Nw==", "url": "https://github.com/returntocorp/semgrep/pull/981#discussion_r439483047", "bodyText": "I sort of agree, I'm abusing exceptions are more general purpose errors here.\nWe want to be able to merely record that an error occurred and keep going, hence passing exception objects around rather than throwing them. This is replacing code, that simply called print_error(\"some string\").\nBut to be able to incorporate output for all stages of the pipeline into JSON, we need a more structured approach.", "author": "rcoh", "createdAt": "2020-06-12T15:18:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3ODQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3OTQ5Mg==", "url": "https://github.com/returntocorp/semgrep/pull/981#discussion_r439479492", "bodyText": "Instead of dealing with something like final_error we could just continue to catch exceptions in __main__ and output their contents there. If you still want to use something like _output_exception you could make a @staticmethod (it doesn't use self anyway) and use it in __main__.\nAgain, it feels kinda weird to have our output handler also manage all program exceptions as well. What if we want to catch and handle them elsewhere?", "author": "mschwager", "createdAt": "2020-06-12T15:12:07Z", "path": "semgrep/semgrep/output.py", "diffHunk": "@@ -173,3 +187,178 @@ def build_output(\n     else:\n         # https://github.com/python/mypy/issues/6366\n         raise RuntimeError(f\"Unhandled output format: {type(output_format).__name__}\")\n+\n+\n+class OutputSettings(NamedTuple):\n+    output_format: OutputFormat\n+    output_destination: Optional[str]\n+    quiet: bool\n+    error_on_findings: bool\n+\n+\n+@contextlib.contextmanager\n+def managed_output(output_settings: OutputSettings) -> Generator:  # type: ignore\n+    handler = OutputHandler(output_settings)\n+    try:\n+        yield handler\n+    except Exception as ex:\n+        handler.handle_unhandled_exception(ex)\n+    finally:\n+        exit_code = handler.close()\n+        sys.exit(exit_code)\n+\n+\n+class OutputHandler:\n+    \"\"\"\n+    Handle all output in a central location. Rather than calling `print_error` directly,\n+    you should call `handle_*` as appropriate.\n+\n+    In normal usage, it should be constructed via the contextmanager, `managed_output`. It ensures that everything\n+    is handled properly if exceptions are thrown.\n+\n+    If you need to stop execution immediately (think carefully if you really want this!), throw an exception.\n+    If this is normal behavior, the exception _must_ inherit from `SemgrepError`.\n+\n+    If you want execution to continue, _report_ the exception via the appropriate `handle_*` method.\n+    \"\"\"\n+\n+    def __init__(\n+        self,\n+        output_settings: OutputSettings,\n+        stderr: IO = sys.stderr,\n+        stdout: IO = sys.stdout,\n+    ):\n+        self.settings = output_settings\n+        self.stderr = stderr\n+        self.stdout = stdout\n+\n+        self.rule_matches: List[RuleMatch] = []\n+        self.debug_steps_by_rule: Dict[Rule, List[Dict[str, Any]]] = {}\n+        self.rules: FrozenSet[Rule] = frozenset()\n+        self.semgrep_core_errors: List[Dict[str, Any]] = []\n+        self.semgrep_rule_errors: List[SemgrepError] = []\n+        self.has_output = False\n+\n+        self.exit_code = 0\n+        self.final_error: Optional[Exception] = None\n+\n+    def handle_semgrep_core_errors(self, semgrep_errors: List[Dict[str, Any]]) -> None:\n+        \"\"\"\n+        Report errors coming directly from semgrep-core (raw JSON objects)\n+        \"\"\"\n+        self.semgrep_core_errors += semgrep_errors\n+        if self.settings.output_format == OutputFormat.TEXT:\n+            for error in semgrep_errors:\n+                print_error(pretty_error(error))\n+\n+    def handle_semgrep_rule_errors(self, error: SemgrepError) -> None:\n+        \"\"\"\n+        Report parse errors from semgrep rules. Either:\n+        - when the pattern fails to parse in semgrep-core\n+        - when the YAML or YAML structure is invalid\n+        \"\"\"\n+        self.semgrep_rule_errors.append(error)\n+        self._output_exception(error)\n+\n+    def handle_semgrep_core_output(\n+        self,\n+        rule_matches_by_rule: Dict[Rule, List[RuleMatch]],\n+        debug_steps_by_rule: Dict[Rule, List[Dict[str, Any]]],\n+    ) -> None:\n+        self.has_output = True\n+        self.rules = self.rules.union(rule_matches_by_rule.keys())\n+        self.rule_matches += [\n+            match\n+            for matches_of_one_rule in rule_matches_by_rule.values()\n+            for match in matches_of_one_rule\n+        ]\n+\n+        self.debug_steps_by_rule.update(debug_steps_by_rule)\n+\n+    def handle_unhandled_exception(self, ex: Exception) -> None:\n+        \"\"\"\n+        This is called by the context manager upon an unhandled exception. If you want to record a final\n+        error & set the exit code, but keep executing to perform cleanup tasks, call this method.\n+        \"\"\"\n+        if isinstance(ex, SemgrepError):\n+            self.exit_code = ex.code\n+        else:\n+            self.exit_code = FATAL_EXIT_CODE\n+        self.final_error = ex\n+\n+    def _output_exception(self, ex: Exception) -> None:\n+        if isinstance(ex, SemgrepError):\n+            print_error(str(ex))\n+        else:\n+            # If it isn't a known SemgrepError, bail hard.\n+            print_error(PLEASE_FILE_ISSUE_TEXT)\n+            raise ex\n+\n+    def close(self) -> int:\n+        \"\"\"\n+        Close the output handler.\n+\n+        This will write any output that hasn't been written so far. It returns\n+        the exit code of the program.\n+        \"\"\"\n+        # TODO: incorporate final_error into JSON output (https://github.com/returntocorp/semgrep/issues/746)\n+        if self.final_error:\n+            self._output_exception(self.final_error)", "originalCommit": "6eb620bb7b4706cdd9e362eda8d274ccaef021a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ4NjI5Ng==", "url": "https://github.com/returntocorp/semgrep/pull/981#discussion_r439486296", "bodyText": "if you want to capture an exception internally, handle it and move on, there is no reason you can't do that. The output manager handles exceptions to provide a unified way of reporting them the user in whatever way they've requested via assorted parameters, without having to have the internal code care about the output format.\nIn __main__ we don't actually know anything about the output mode, so we don't have the context we need to know how to handle the exception properly.", "author": "rcoh", "createdAt": "2020-06-12T15:24:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ3OTQ5Mg=="}], "type": "inlineReview"}, {"oid": "8c89bad9103521f5565ed6b989017bbc7338f65c", "url": "https://github.com/returntocorp/semgrep/commit/8c89bad9103521f5565ed6b989017bbc7338f65c", "message": "Remove sys.exit call from managed_output", "committedDate": "2020-06-12T16:43:54Z", "type": "commit"}, {"oid": "8c89bad9103521f5565ed6b989017bbc7338f65c", "url": "https://github.com/returntocorp/semgrep/commit/8c89bad9103521f5565ed6b989017bbc7338f65c", "message": "Remove sys.exit call from managed_output", "committedDate": "2020-06-12T16:43:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0NjYwMg==", "url": "https://github.com/returntocorp/semgrep/pull/981#discussion_r439546602", "bodyText": "I think we can avoid the indirection with final_error by doing something like:\n    try:\n        yield output_handler\n    except SemgrepError as ex:\n        output_handler.close()\n        print_error(str(ex))\n        raise\n    except Exception:\n        output_handler.close()\n        raise\n    else:\n        output_handler.close()\nA bit wonky with output_handler.close() in each block, but it's necessary for the different print ordering with SemgrepError.", "author": "mschwager", "createdAt": "2020-06-12T17:18:01Z", "path": "semgrep/semgrep/output.py", "diffHunk": "@@ -173,3 +185,167 @@ def build_output(\n     else:\n         # https://github.com/python/mypy/issues/6366\n         raise RuntimeError(f\"Unhandled output format: {type(output_format).__name__}\")\n+\n+\n+class OutputSettings(NamedTuple):\n+    output_format: OutputFormat\n+    output_destination: Optional[str]\n+    quiet: bool\n+    error_on_findings: bool\n+\n+\n+@contextlib.contextmanager\n+def managed_output(output_settings: OutputSettings) -> Generator:  # type: ignore\n+    \"\"\"\n+    Context manager to capture uncaught exceptions &\n+    \"\"\"\n+    output_handler = OutputHandler(output_settings)\n+    try:\n+        yield output_handler\n+    except Exception as ex:", "originalCommit": "8c89bad9103521f5565ed6b989017bbc7338f65c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0NzI5Ng==", "url": "https://github.com/returntocorp/semgrep/pull/981#discussion_r439547296", "bodyText": "I want to eventually be able to get final_error into the JSON output so passing it in was intentional.", "author": "rcoh", "createdAt": "2020-06-12T17:19:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0NjYwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0ODMxOQ==", "url": "https://github.com/returntocorp/semgrep/pull/981#discussion_r439548319", "bodyText": "Ahh, that makes sense \ud83d\udc4d", "author": "mschwager", "createdAt": "2020-06-12T17:21:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU0NjYwMg=="}], "type": "inlineReview"}]}