{"pr_number": 946, "pr_title": "target_manager: handle all file filtering in python instead of ocaml", "pr_createdAt": "2020-06-09T02:11:49Z", "pr_url": "https://github.com/returntocorp/semgrep/pull/946", "timeline": [{"oid": "ca4d0ed30b11254ef653889eb7be0fba01b43031", "url": "https://github.com/returntocorp/semgrep/commit/ca4d0ed30b11254ef653889eb7be0fba01b43031", "message": "WIP", "committedDate": "2020-06-09T23:58:00Z", "type": "forcePushed"}, {"oid": "ab807474ce0428b7d3311d3c16f286ecd78183ec", "url": "https://github.com/returntocorp/semgrep/commit/ab807474ce0428b7d3311d3c16f286ecd78183ec", "message": "wip", "committedDate": "2020-06-11T00:15:36Z", "type": "forcePushed"}, {"oid": "b8e24808e7a250fb3ab76cc3a80a0a08032f5fee", "url": "https://github.com/returntocorp/semgrep/commit/b8e24808e7a250fb3ab76cc3a80a0a08032f5fee", "message": "Dedup parse errors", "committedDate": "2020-06-11T23:21:43Z", "type": "forcePushed"}, {"oid": "c29da4b60d1dc227612a19054c1483e601a3554b", "url": "https://github.com/returntocorp/semgrep/commit/c29da4b60d1dc227612a19054c1483e601a3554b", "message": "Dedup parse errors", "committedDate": "2020-06-11T23:46:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTE0MDc4MA==", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439140780", "bodyText": "\"excludes\" here twice \u270c\ufe0f", "author": "minusworld", "createdAt": "2020-06-12T00:17:21Z", "path": "semgrep/semgrep/target_manager.py", "diffHunk": "@@ -0,0 +1,223 @@\n+import subprocess\n+from pathlib import Path\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+\n+from semgrep.error import NotGitProjectError\n+from semgrep.error import UnknownLanguageError\n+from semgrep.util import partition_set\n+\n+\n+def lang_to_exts(language: str) -> List[str]:\n+    \"\"\"\n+        Convert language to expected file extensions\n+\n+        If language is not a supported semgrep language then\n+        raises UnknownLanguageError\n+    \"\"\"\n+    if language in [\"python\", \"python2\", \"python3\", \"py\"]:\n+        return [\"py\", \"pyi\"]\n+    elif language in [\"js\", \"javascript\"]:\n+        return [\"js\"]\n+    elif language in [\"java\"]:\n+        return [\"java\"]\n+    elif language in [\"c\"]:\n+        return [\"c\"]\n+    elif language in [\"go\", \"golang\"]:\n+        return [\"go\"]\n+    elif language in [\"ml\", \"ocaml\"]:\n+        return [\"mli\", \"ml\", \"mly\", \"mll\"]\n+    else:\n+        raise UnknownLanguageError(f\"Unsupported Language: {language}\")\n+\n+\n+class TargetManager:\n+    def __init__(\n+        self,\n+        includes: List[str],\n+        excludes: List[str],\n+        targets: List[str],\n+        visible_to_git_only: bool = False,\n+    ) -> None:\n+        \"\"\"\n+            Handles all file include/exclude logic for semgrep\n+\n+            If visible_to_git_only is true then will only consider files that are\n+            tracked or (untracked but not ignored) by git\n+        \"\"\"\n+        self._targets = targets\n+        self._includes = includes\n+        self._excludes = excludes\n+        self._visible_to_git_only = visible_to_git_only\n+\n+        self._filtered_targets: Dict[str, Set[Path]] = {}\n+\n+    @staticmethod\n+    def resolve_targets(targets: List[str]) -> Set[Path]:\n+        \"\"\"\n+            Return list of Path objects appropriately resolving relative paths\n+            (relative to cwd) if necessary\n+        \"\"\"\n+        base_path = Path(\".\")\n+        return set(\n+            Path(target) if Path(target).is_absolute() else base_path.joinpath(target)\n+            for target in targets\n+        )\n+\n+    def _parse_output(self, output: str, curr_dir: Path) -> Set[Path]:\n+        \"\"\"\n+            Convert a newline delimited list of files to a set of path objects\n+            prepends curr_dir to all paths in said list\n+\n+            If list is empty then returns an empty set\n+        \"\"\"\n+        files: Set[Path] = set()\n+        if output:\n+            files = set(Path(curr_dir) / elem for elem in output.strip().split(\"\\n\"))\n+        return files\n+\n+    def _expand_dir(self, curr_dir: Path, language: str) -> Set[Path]:\n+        \"\"\"\n+            Recursively go through a directory and return list of all files with\n+            default file extention of language\n+        \"\"\"\n+        extensions = lang_to_exts(language)\n+        expanded: Set[Path] = set()\n+\n+        for ext in extensions:\n+            if self._visible_to_git_only:\n+                try:\n+                    # Tracked files\n+                    tracked_output = subprocess.check_output(\n+                        [\"git\", \"ls-files\", f\"*.{ext}\"],\n+                        cwd=curr_dir.resolve(),\n+                        encoding=\"utf-8\",\n+                        stderr=subprocess.DEVNULL,\n+                    )\n+\n+                    # Untracked but not ignored files\n+                    untracked_output = subprocess.check_output(\n+                        [\n+                            \"git\",\n+                            \"ls-files\",\n+                            \"--other\",\n+                            \"--exclude-standard\",\n+                            f\"*.{ext}\",\n+                        ],\n+                        cwd=curr_dir.resolve(),\n+                        encoding=\"utf-8\",\n+                        stderr=subprocess.DEVNULL,\n+                    )\n+                except subprocess.CalledProcessError:\n+                    raise NotGitProjectError(\n+                        f\"{curr_dir.resolve()} is not a git repository.\"\n+                    )\n+\n+                tracked = self._parse_output(tracked_output, curr_dir)\n+                untracked_unignored = self._parse_output(untracked_output, curr_dir)\n+\n+                expanded = expanded.union(tracked)\n+                expanded = expanded.union(untracked_unignored)\n+\n+            else:\n+                output = subprocess.run(\n+                    [\"find\", curr_dir, \"-type\", \"f\", \"-name\", f\"*.{ext}\"],\n+                    encoding=\"utf-8\",\n+                    stdout=subprocess.PIPE,\n+                    stderr=subprocess.PIPE,\n+                )\n+\n+                # Note find already gives paths relative to pwd so no need to prepend curr_dir\n+                ext_files = self._parse_output(output.stdout, Path(\".\"))\n+                expanded = expanded.union(ext_files)\n+\n+        return expanded\n+\n+    def expand_targets(self, targets: Set[Path], lang: str) -> Set[Path]:\n+        \"\"\"\n+            Explore all directories. Remove duplicates\n+        \"\"\"\n+        expanded = set()\n+        for target in targets:\n+            if not target.exists():\n+                continue\n+\n+            if target.is_dir():\n+                expanded.update(self._expand_dir(target, lang))\n+            else:\n+                expanded.add(target)\n+\n+        return expanded\n+\n+    @staticmethod\n+    def match_glob(path: Path, globs: List[str]) -> bool:\n+        \"\"\"\n+            Return true if path or any parent of path matches any glob in globs\n+        \"\"\"\n+        subpaths = [path, *path.parents]\n+        return any(p.match(glob) for p in subpaths for glob in globs)\n+\n+    @staticmethod\n+    def filter_includes(arr: Set[Path], includes: List[str]) -> Set[Path]:\n+        \"\"\"\n+            Returns all elements in arr that match any includes pattern\n+\n+            If includes is empty, returns arr unchanged\n+        \"\"\"\n+        if not includes:\n+            return arr\n+\n+        return set(elem for elem in arr if TargetManager.match_glob(elem, includes))\n+\n+    @staticmethod\n+    def filter_excludes(arr: Set[Path], excludes: List[str]) -> Set[Path]:\n+        \"\"\"\n+            Returns all elements in arr that do not match any excludes excludes", "originalCommit": "c29da4b60d1dc227612a19054c1483e601a3554b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjQxMA==", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439682410", "bodyText": "this will break on large repos", "author": "DrewDennison", "createdAt": "2020-06-12T23:49:45Z", "path": "semgrep/semgrep/core_runner.py", "diffHunk": "@@ -273,7 +260,7 @@ def _run_rules(\n                     if equivalences:\n                         cmd += [\"-equivalences\", equiv_fout.name]\n                     cmd += [\"-j\", str(self._jobs)]\n-                    cmd += [*self.targeting_options, *[str(path) for path in targets]]\n+                    cmd += [str(path) for path in targets]", "originalCommit": "97ffaf45ad7f0c5fc50189365c034aa790e2e318", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NzE1Mg==", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439687152", "bodyText": "Yeahp. was thinking of using the -target-file argument i added to semgrep-core in a follow up PR", "author": "brendongo", "createdAt": "2020-06-13T00:21:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjU4Mw==", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439682583", "bodyText": "is this logic duplicated in ocaml or hopefully this is now the single source of truth?", "author": "DrewDennison", "createdAt": "2020-06-12T23:50:48Z", "path": "semgrep/semgrep/target_manager.py", "diffHunk": "@@ -0,0 +1,234 @@\n+import subprocess\n+from pathlib import Path\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+\n+from semgrep.error import NotGitProjectError\n+from semgrep.error import UnknownLanguageError\n+from semgrep.util import partition_set\n+\n+\n+def lang_to_exts(language: str) -> List[str]:\n+    \"\"\"\n+        Convert language to expected file extensions\n+\n+        If language is not a supported semgrep language then\n+        raises UnknownLanguageError\n+    \"\"\"\n+    if language in [\"python\", \"python2\", \"python3\", \"py\"]:", "originalCommit": "97ffaf45ad7f0c5fc50189365c034aa790e2e318", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NTE5OA==", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439685198", "bodyText": "It still is for now. We can pull out the things in a follow up PR", "author": "brendongo", "createdAt": "2020-06-13T00:06:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjgxOA==", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439682818", "bodyText": "what's the run time of this command? Seems slow compared to extracting globs from .gitignore", "author": "DrewDennison", "createdAt": "2020-06-12T23:52:10Z", "path": "semgrep/semgrep/target_manager.py", "diffHunk": "@@ -0,0 +1,234 @@\n+import subprocess\n+from pathlib import Path\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+\n+from semgrep.error import NotGitProjectError\n+from semgrep.error import UnknownLanguageError\n+from semgrep.util import partition_set\n+\n+\n+def lang_to_exts(language: str) -> List[str]:\n+    \"\"\"\n+        Convert language to expected file extensions\n+\n+        If language is not a supported semgrep language then\n+        raises UnknownLanguageError\n+    \"\"\"\n+    if language in [\"python\", \"python2\", \"python3\", \"py\"]:\n+        return [\"py\", \"pyi\"]\n+    elif language in [\"js\", \"javascript\"]:\n+        return [\"js\"]\n+    elif language in [\"java\"]:\n+        return [\"java\"]\n+    elif language in [\"c\"]:\n+        return [\"c\"]\n+    elif language in [\"go\", \"golang\"]:\n+        return [\"go\"]\n+    elif language in [\"ml\", \"ocaml\"]:\n+        return [\"mli\", \"ml\", \"mly\", \"mll\"]\n+    else:\n+        raise UnknownLanguageError(f\"Unsupported Language: {language}\")\n+\n+\n+class TargetManager:\n+    def __init__(\n+        self,\n+        includes: List[str],\n+        excludes: List[str],\n+        targets: List[str],\n+        visible_to_git_only: bool = False,\n+    ) -> None:\n+        \"\"\"\n+            Handles all file include/exclude logic for semgrep\n+\n+            If visible_to_git_only is true then will only consider files that are\n+            tracked or (untracked but not ignored) by git\n+        \"\"\"\n+        self._targets = targets\n+        self._includes = includes\n+        self._excludes = excludes\n+        self._visible_to_git_only = visible_to_git_only\n+\n+        self._filtered_targets: Dict[str, Set[Path]] = {}\n+\n+    @staticmethod\n+    def resolve_targets(targets: List[str]) -> Set[Path]:\n+        \"\"\"\n+            Return list of Path objects appropriately resolving relative paths\n+            (relative to cwd) if necessary\n+        \"\"\"\n+        base_path = Path(\".\")\n+        return set(\n+            Path(target) if Path(target).is_absolute() else base_path.joinpath(target)\n+            for target in targets\n+        )\n+\n+    @staticmethod\n+    def _parse_output(output: str, curr_dir: Path) -> Set[Path]:\n+        \"\"\"\n+            Convert a newline delimited list of files to a set of path objects\n+            prepends curr_dir to all paths in said list\n+\n+            If list is empty then returns an empty set\n+        \"\"\"\n+        files: Set[Path] = set()\n+        if output:\n+            files = set(Path(curr_dir) / elem for elem in output.strip().split(\"\\n\"))\n+        return files\n+\n+    @staticmethod\n+    def _expand_dir(\n+        curr_dir: Path, language: str, visible_to_git_only: bool\n+    ) -> Set[Path]:\n+        \"\"\"\n+            Recursively go through a directory and return list of all files with\n+            default file extention of language\n+        \"\"\"\n+        extensions = lang_to_exts(language)\n+        expanded: Set[Path] = set()\n+\n+        for ext in extensions:\n+            if visible_to_git_only:\n+                try:\n+                    # Tracked files\n+                    tracked_output = subprocess.check_output(\n+                        [\"git\", \"ls-files\", f\"*.{ext}\"],", "originalCommit": "97ffaf45ad7f0c5fc50189365c034aa790e2e318", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NTEyMg==", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439685122", "bodyText": "find . -type f -name \"*.py\"  0.00s user 0.00s system 87% cpu 0.007 total\ngit ls-files \"*.py\"  0.00s user 0.01s system 74% cpu 0.014 total\nNegligible difference with find tbh", "author": "brendongo", "createdAt": "2020-06-13T00:06:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjgxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjkwMQ==", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439682901", "bodyText": "shouldn't we be using Path(.).rglob(\"*\")?", "author": "DrewDennison", "createdAt": "2020-06-12T23:52:38Z", "path": "semgrep/semgrep/target_manager.py", "diffHunk": "@@ -0,0 +1,234 @@\n+import subprocess\n+from pathlib import Path\n+from typing import Dict\n+from typing import List\n+from typing import Set\n+\n+from semgrep.error import NotGitProjectError\n+from semgrep.error import UnknownLanguageError\n+from semgrep.util import partition_set\n+\n+\n+def lang_to_exts(language: str) -> List[str]:\n+    \"\"\"\n+        Convert language to expected file extensions\n+\n+        If language is not a supported semgrep language then\n+        raises UnknownLanguageError\n+    \"\"\"\n+    if language in [\"python\", \"python2\", \"python3\", \"py\"]:\n+        return [\"py\", \"pyi\"]\n+    elif language in [\"js\", \"javascript\"]:\n+        return [\"js\"]\n+    elif language in [\"java\"]:\n+        return [\"java\"]\n+    elif language in [\"c\"]:\n+        return [\"c\"]\n+    elif language in [\"go\", \"golang\"]:\n+        return [\"go\"]\n+    elif language in [\"ml\", \"ocaml\"]:\n+        return [\"mli\", \"ml\", \"mly\", \"mll\"]\n+    else:\n+        raise UnknownLanguageError(f\"Unsupported Language: {language}\")\n+\n+\n+class TargetManager:\n+    def __init__(\n+        self,\n+        includes: List[str],\n+        excludes: List[str],\n+        targets: List[str],\n+        visible_to_git_only: bool = False,\n+    ) -> None:\n+        \"\"\"\n+            Handles all file include/exclude logic for semgrep\n+\n+            If visible_to_git_only is true then will only consider files that are\n+            tracked or (untracked but not ignored) by git\n+        \"\"\"\n+        self._targets = targets\n+        self._includes = includes\n+        self._excludes = excludes\n+        self._visible_to_git_only = visible_to_git_only\n+\n+        self._filtered_targets: Dict[str, Set[Path]] = {}\n+\n+    @staticmethod\n+    def resolve_targets(targets: List[str]) -> Set[Path]:\n+        \"\"\"\n+            Return list of Path objects appropriately resolving relative paths\n+            (relative to cwd) if necessary\n+        \"\"\"\n+        base_path = Path(\".\")\n+        return set(\n+            Path(target) if Path(target).is_absolute() else base_path.joinpath(target)\n+            for target in targets\n+        )\n+\n+    @staticmethod\n+    def _parse_output(output: str, curr_dir: Path) -> Set[Path]:\n+        \"\"\"\n+            Convert a newline delimited list of files to a set of path objects\n+            prepends curr_dir to all paths in said list\n+\n+            If list is empty then returns an empty set\n+        \"\"\"\n+        files: Set[Path] = set()\n+        if output:\n+            files = set(Path(curr_dir) / elem for elem in output.strip().split(\"\\n\"))\n+        return files\n+\n+    @staticmethod\n+    def _expand_dir(\n+        curr_dir: Path, language: str, visible_to_git_only: bool\n+    ) -> Set[Path]:\n+        \"\"\"\n+            Recursively go through a directory and return list of all files with\n+            default file extention of language\n+        \"\"\"\n+        extensions = lang_to_exts(language)\n+        expanded: Set[Path] = set()\n+\n+        for ext in extensions:\n+            if visible_to_git_only:\n+                try:\n+                    # Tracked files\n+                    tracked_output = subprocess.check_output(\n+                        [\"git\", \"ls-files\", f\"*.{ext}\"],\n+                        cwd=curr_dir.resolve(),\n+                        encoding=\"utf-8\",\n+                        stderr=subprocess.DEVNULL,\n+                    )\n+\n+                    # Untracked but not ignored files\n+                    untracked_output = subprocess.check_output(\n+                        [\n+                            \"git\",\n+                            \"ls-files\",\n+                            \"--other\",\n+                            \"--exclude-standard\",\n+                            f\"*.{ext}\",\n+                        ],\n+                        cwd=curr_dir.resolve(),\n+                        encoding=\"utf-8\",\n+                        stderr=subprocess.DEVNULL,\n+                    )\n+                except subprocess.CalledProcessError:\n+                    raise NotGitProjectError(\n+                        f\"{curr_dir.resolve()} is not a git repository.\"\n+                    )\n+\n+                tracked = TargetManager._parse_output(tracked_output, curr_dir)\n+                untracked_unignored = TargetManager._parse_output(\n+                    untracked_output, curr_dir\n+                )\n+\n+                expanded = expanded.union(tracked)\n+                expanded = expanded.union(untracked_unignored)\n+\n+            else:\n+                output = subprocess.run(\n+                    [\"find\", curr_dir, \"-type\", \"f\", \"-name\", f\"*.{ext}\"],", "originalCommit": "97ffaf45ad7f0c5fc50189365c034aa790e2e318", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NDY5NA==", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439684694", "bodyText": "This is exactly what semgrep-core does right now", "author": "brendongo", "createdAt": "2020-06-13T00:03:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NTg0MQ==", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439685841", "bodyText": "python3 -c \"from pathlib import Path; [p for p in Path('..').rglob('*.py')]\"  0.06s user 0.06s system 96% cpu 0.129 total\npython3 -c \"from pathlib import Path;\"  0.03s user 0.01s system 90% cpu 0.044 total\n\nQuick and dirty experiment is using glob takes 10x more time (70 ms vs 7ms) for the small number of files in semgrep", "author": "brendongo", "createdAt": "2020-06-13T00:11:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4NjAwMw==", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439686003", "bodyText": "amazing", "author": "DrewDennison", "createdAt": "2020-06-13T00:12:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjkwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4Njc2OQ==", "url": "https://github.com/returntocorp/semgrep/pull/946#discussion_r439686769", "bodyText": "time python3 -c 'import subprocess; subprocess.run([\"find\", \"..\", \"-type\", \"f\", \"-name\", f\"*.py\"])'  0.05s user 0.08s system 69% cpu 0.112 total\nWith subprocess overhead they're around equivalent.", "author": "brendongo", "createdAt": "2020-06-13T00:18:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjkwMQ=="}], "type": "inlineReview"}, {"oid": "a9544d46412e4eeebe29d551fc340d467b85be20", "url": "https://github.com/returntocorp/semgrep/commit/a9544d46412e4eeebe29d551fc340d467b85be20", "message": "target_manager: handle all file filtering in python instead of ocaml", "committedDate": "2020-06-12T23:54:06Z", "type": "commit"}, {"oid": "82123a71efb745f97ccf4b19191a4ffe6f7f912d", "url": "https://github.com/returntocorp/semgrep/commit/82123a71efb745f97ccf4b19191a4ffe6f7f912d", "message": "WIP", "committedDate": "2020-06-12T23:54:06Z", "type": "commit"}, {"oid": "f8530b232b1a00145ba66b42d92dcf35ad0ae8cf", "url": "https://github.com/returntocorp/semgrep/commit/f8530b232b1a00145ba66b42d92dcf35ad0ae8cf", "message": "wip", "committedDate": "2020-06-12T23:54:06Z", "type": "commit"}, {"oid": "e8ddc0e5569d2212679ce32aead52ba5ef85e6da", "url": "https://github.com/returntocorp/semgrep/commit/e8ddc0e5569d2212679ce32aead52ba5ef85e6da", "message": "Hook up target_manager", "committedDate": "2020-06-13T00:02:08Z", "type": "commit"}, {"oid": "eab56a16eb5c43e8824cc58f6a17dcaf1a6f2891", "url": "https://github.com/returntocorp/semgrep/commit/eab56a16eb5c43e8824cc58f6a17dcaf1a6f2891", "message": "Dedup parse errors", "committedDate": "2020-06-13T00:02:09Z", "type": "commit"}, {"oid": "55bdc2b8ea191430949d1495b088689c57d6e78b", "url": "https://github.com/returntocorp/semgrep/commit/55bdc2b8ea191430949d1495b088689c57d6e78b", "message": "Add unit tests for target_manager", "committedDate": "2020-06-13T00:02:09Z", "type": "commit"}, {"oid": "55bdc2b8ea191430949d1495b088689c57d6e78b", "url": "https://github.com/returntocorp/semgrep/commit/55bdc2b8ea191430949d1495b088689c57d6e78b", "message": "Add unit tests for target_manager", "committedDate": "2020-06-13T00:02:09Z", "type": "forcePushed"}]}