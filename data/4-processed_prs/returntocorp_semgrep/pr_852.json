{"pr_number": 852, "pr_title": "Optimize deep statement matching", "pr_createdAt": "2020-05-28T11:54:29Z", "pr_url": "https://github.com/returntocorp/semgrep/pull/852", "timeline": [{"oid": "b356625e48fa85ff0cd0f0d862c0828bcee9e89d", "url": "https://github.com/returntocorp/semgrep/commit/b356625e48fa85ff0cd0f0d862c0828bcee9e89d", "message": "Optimize deep statement matching\n\nThis should close #827 and #664\n\nThe code to handle foo(); ...; bar(); was very naive\nand was doing lots of useless work. This fixes that.\n\nTest plan:\ntime pipenv run semgrep -f ~/semgrep/tests/PERF/ajin.yaml ~/semgrep/tests/PERF/three.js\n3.2s\n\n(was 3min before)\n\n+ /home/pad/github/semgrep/semgrep-core/_build/default/bin/Main.exe -profile -lang py -f tests/PERF/ellipsis-python.sgrep tests/PERF/my_first_calculator.py\n---------------------\nprofiling result\n---------------------\nMain total                               :      1.670 sec          1 count\nParse_python.parse                       :      0.918 sec          1 count\nParse_python.tokens                      :      0.525 sec          2 count\nSemgrep.check                            :      0.458 sec          1 count\nParser_python.main                       :      0.277 sec          1 count\nSemgrep.match_sts_sts                    :      0.186 sec      41627 count\n\n(was 85sec before)\n\n+ /home/pad/github/semgrep/semgrep-core/_build/default/bin/Main.exe -profile -lang js -f tests/PERF/ellipsis-js.sgrep tests/PERF/three.js\n---------------------\nprofiling result\n---------------------\nMain total                               :      2.151 sec          1 count\nParse_js.parse                           :      1.236 sec          1 count\nParse_js.tokens                          :      0.398 sec          2 count\nSemgrep.check                            :      0.389 sec          1 count\nSemgrep.match_sts_sts                    :      0.239 sec      16824 count\nParser_js.module_item                    :      0.192 sec        609 count\n\n(was a lot more before)", "committedDate": "2020-05-28T11:54:04Z", "type": "commit"}, {"oid": "a808f872e0d5d98a24c5b9ff7671fa208711afbf", "url": "https://github.com/returntocorp/semgrep/commit/a808f872e0d5d98a24c5b9ff7671fa208711afbf", "message": "Adding -debug -profile to semgrep-core and SEMGREP_CORE_DEBUG/PROFILE env var\n\nThose options are useful to debug or profile semgrep-core.\nUsing the environment variable allows us to pass options to semgrep-core\nwithout having to modify semgrep-python.\n\nTest plan:\npad@yrax:~/github/semgrep/semgrep$ export SEMGREP_CORE_DEBUG=1\npad@yrax:~/github/semgrep/semgrep$ export SEMGREP_CORE_PROFILE=1\npad@yrax:~/github/semgrep/semgrep$ pipenv run semgrep -f ../semgrep-core/tests/PERF/ajin.yaml ../semgrep-core/tests/PERF/three.js\nDebug mode On\nExecuted as: semgrep-core -lang javascript -rules_file /tmp/tmpqfdc1lug -j 8 ../semgrep-core/tests/PERF/three.js\nProfile mode On\ndisabling -j when in profiling mode\nPARSING: ../semgrep-core/tests/PERF/three.js\nsaving rules file for debugging in: /tmp/semgrep_core_rule-4e8afb.yaml\n---------------------\nprofiling result\n---------------------\nMain total                               :      1.625 sec          1 count\nParse_js.parse                           :      0.724 sec          1 count\nSemgrep.check                            :      0.568 sec          1 count\nSemgrep.match_sts_sts                    :      0.333 sec     185064 count", "committedDate": "2020-05-28T13:05:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgyMTk2OA==", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r431821968", "bodyText": "@rcoh maybe this was the issue. Maybe you were running the ocaml programs with profiling information but\nbecause of -j the job was actually done in another process ...", "author": "aryx", "createdAt": "2020-05-28T13:10:22Z", "path": "semgrep-core/bin/Main.ml", "diffHunk": "@@ -843,8 +870,25 @@ let main () =\n     spf \"Usage: %s [options] <pattern> <files_or_dirs> \\nOptions:\"\n       (Filename.basename Sys.argv.(0))\n   in\n+\n+  let argv =\n+   (Array.to_list Sys.argv) @\n+   (if Sys.getenv_opt \"SEMGREP_CORE_DEBUG\" <> None then [\"-debug\"] else[])@\n+   (if Sys.getenv_opt \"SEMGREP_CORE_PROFILE\" <> None then [\"-profile\"] else[])\n+  in\n+\n   (* does side effect on many global flags *)\n-  let args = Common.parse_options (options()) usage_msg Sys.argv in\n+  let args = Common.parse_options (options()) usage_msg (Array.of_list argv) in\n+\n+  if !debug then begin\n+    pr2 \"Debug mode On\";\n+    pr2 (spf \"Executed as: %s\" (Sys.argv|>Array.to_list|> String.concat \" \"));\n+  end;\n+  if !profile then begin", "originalCommit": "a808f872e0d5d98a24c5b9ff7671fa208711afbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkyMTU2NQ==", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r431921565", "bodyText": "Yeah that occurred to me after I read that multi threading in OCaml is actually multiprocessing", "author": "rcoh", "createdAt": "2020-05-28T15:22:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgyMTk2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk3ODgyMg==", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r431978822", "bodyText": "Well, OCaml has concurrent threads (Xavier Leroy the author of OCaml actually added the first POSIX C thead library for Linux a long time ago, and he did it because he wanted threads in OCaml), but it does not have yet multi-core threads. There is work ongoing to suppor that.\nNote that neither Python/PHP/Ruby/... have multi-core threads either.", "author": "aryx", "createdAt": "2020-05-28T16:46:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgyMTk2OA=="}], "type": "inlineReview"}, {"oid": "9fa558912a589ad1ce91cdfabdef24f476258737", "url": "https://github.com/returntocorp/semgrep/commit/9fa558912a589ad1ce91cdfabdef24f476258737", "message": "Profiling information for each rule\n\nThis allows to see which rules take the most time. Note that\nwhen called from semgrep-python, the rule id are not very readable,\nbut the generated file is saved in /tmp/ so you can find back\nwhat the rule it corresponds to.\n\nTest plan:\nexport SEMGREP_CORE_PROFILE=1\nexport SEMGREP_CORE_DEBUG=1\npad@yrax:~/github/semgrep/semgrep$ pipenv run semgrep -f ../semgrep-core/tests/PERF/ajin.yaml ../semgrep-core/tests/PERF/three.js\nDebug mode On\nExecuted as: semgrep-core -lang javascript -rules_file /tmp/tmpy5pzp3p_ -j 8 ../semgrep-core/tests/PERF/three.js\nProfile mode On\ndisabling -j when in profiling mode\nPARSING: ../semgrep-core/tests/PERF/three.js\nsaving rules file for debugging in: /tmp/semgrep_core_rule-97ae74.yaml\n---------------------\nprofiling result\n---------------------\nMain total                               :      1.975 sec          1 count\nParse_js.parse                           :      0.828 sec          1 count\nSemgrep.check                            :      0.791 sec          1 count\nSemgrep.match_sts_sts                    :      0.559 sec     185064 count\nParse_js.tokens                          :      0.335 sec         12 count\nParser_js.module_item                    :      0.083 sec        609 count\nNormalize_ast.normalize                  :      0.058 sec          1 count\nCommon.=~                                :      0.043 sec      51044 count\nCommon.full_charpos_to_pos_large         :      0.042 sec         12 count\nrule:0..0.10                             :      0.035 sec      16824 count\nrule:0..0.9                              :      0.031 sec      16824 count\nrule:0..0.8                              :      0.030 sec      16824 count\nrule:0..0.7                              :      0.029 sec      16824 count\nrule:0..0.6                              :      0.029 sec      16824 count\nrule:0..0.5                              :      0.029 sec      16824 count\nrule:0..0.4                              :      0.029 sec      16824 count\nrule:0..0.0                              :      0.029 sec      16824 count\nrule:0..0.2                              :      0.029 sec      16824 count\nrule:0..0.1                              :      0.029 sec      16824 count\nrule:0..0.3                              :      0.029 sec      16824 count\nfile_type_of_file                        :      0.000 sec          2 count\nSemgrep.apply_equivalences               :      0.000 sec         11 count\nCommon.sort_by_xxx                       :      0.000 sec         11 count\nUnix.stat                                :      0.000 sec         12 count", "committedDate": "2020-05-28T13:23:53Z", "type": "commit"}, {"oid": "3d28f8f2fbc9c74a9c5d511b4549f32d6a13ea7a", "url": "https://github.com/returntocorp/semgrep/commit/3d28f8f2fbc9c74a9c5d511b4549f32d6a13ea7a", "message": "* docs/development.md: improve doc", "committedDate": "2020-05-28T14:01:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0MTM0NQ==", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r432041345", "bodyText": "+1 for explaining the context and the intent", "author": "mjambon", "createdAt": "2020-05-28T18:36:25Z", "path": "semgrep-core/matching/Generic_vs_generic.ml", "diffHunk": "@@ -1259,13 +1259,74 @@ and m_other_attribute_operator = m_other_xxx\n \n (*s: function [[Generic_vs_generic.m_stmts_deep]] *)\n and m_stmts_deep (xsa: A.stmt list) (xsb: A.stmt list) =\n-  if !Flag.go_deeper_stmt && (has_ellipsis_stmts xsa)\n-  then\n-    m_list__m_stmt xsa xsb >!> (fun () ->\n-      let xsb' = SubAST_generic.flatten_substmts_of_stmts xsb in\n-      m_list__m_stmt xsa xsb'\n-    )\n-  else m_list__m_stmt xsa xsb\n+  (* opti: this was the old code:\n+   *   if !Flag.go_deeper_stmt && (has_ellipsis_stmts xsa)\n+   *   then\n+   *   m_list__m_stmt xsa xsb >!> (fun () ->\n+   *     let xsb' = SubAST_generic.flatten_substmts_of_stmts xsb in\n+   *     m_list__m_stmt xsa xsb'\n+   *   )\n+   *   else m_list__m_stmt xsa xsb\n+   *\n+   * but this was really slow on huge files because with a pattern like\n+   * 'foo(); ...; bar();' we would call flatten_substmts_of_stmts\n+   * on each sequences in the program, even though foo(); was not\n+   * matched first.\n+   * Better to first match the first element, and if it matches and\n+   * we have a '...' that was not matched on the current sequence,\n+   * then we try with flatten_substmts_of_stmts.\n+   *\n+   * The code below is mostly a copy paste of m_list__m_stmt. We could\n+   * factorize, but I prefer to control and limit the number of places\n+   * where we call m_stmts_deep. Once we call m_list__m_stmt, we\n+   * are in a simpler world where the list of stmts will not grow.\n+   *)", "originalCommit": "3d28f8f2fbc9c74a9c5d511b4549f32d6a13ea7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0NjMxOQ==", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r431946319", "bodyText": "FWIW, I prefer having the labeled arguments here \ud83e\udd37", "author": "nbrahms", "createdAt": "2020-05-28T15:56:40Z", "path": "semgrep-core/matching/Semgrep_generic.ml", "diffHunk": "@@ -322,9 +337,7 @@ let check2 ~hook rules equivs file lang ast =\n (*e: function [[Semgrep_generic.check2]] *)\n \n (*s: function [[Semgrep_generic.check]] *)\n-let check ~hook rules equivs file lang =\n-  Common.profile_code \"Sgrep_generic.check\" (\n-    fun () -> check2 ~hook rules equivs file lang\n-  )\n+let check ~hook a b c d e =", "originalCommit": "3d28f8f2fbc9c74a9c5d511b4549f32d6a13ea7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM3MjE0Nw==", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r432372147", "bodyText": "True, it's just that those Common.profile_code are just hacks because there's no super easy way to profile code. In theory I should just run ocamlprof and get nice stats, but I like the focused profile that allows Common.profile_code. Then I want to mimimize the amount of modifications I have to do to the program to support this non-functional property (profiling), so I do that. A better way probably would be to use the recent OCaml attribute to do that, have something like [@@ profile] let check a b c d = ... Maybe @mjambon knows a good ppx rewriter that support that.", "author": "aryx", "createdAt": "2020-05-29T09:39:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0NjMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk0NzU1NQ==", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r431947555", "bodyText": "What about naming the wrapper match_e_e_profiled (et c. for other profiled calls)?\nI know I was rather confused by the ...2 naming scheme when I first met this code base.", "author": "nbrahms", "createdAt": "2020-05-28T15:58:27Z", "path": "semgrep-core/matching/Semgrep_generic.ml", "diffHunk": "@@ -58,19 +58,27 @@ type ('a, 'b) matcher = 'a -> 'b ->\n (*****************************************************************************)\n \n (*s: function [[Semgrep_generic.match_e_e]] *)\n-let match_e_e pattern e =\n+let match_e_e2 pattern e =\n   let env = Matching_generic.empty_environment () in\n   GG.m_expr pattern e env\n (*e: function [[Semgrep_generic.match_e_e]] *)\n+let match_e_e ruleid a b =", "originalCommit": "3d28f8f2fbc9c74a9c5d511b4549f32d6a13ea7a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk3NTk4Ng==", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r431975986", "bodyText": "Is the motivation to separate these two cases for documentation?\n(vs. | [], _ ->)", "author": "nbrahms", "createdAt": "2020-05-28T16:41:35Z", "path": "semgrep-core/matching/Generic_vs_generic.ml", "diffHunk": "@@ -1259,13 +1259,74 @@ and m_other_attribute_operator = m_other_xxx\n \n (*s: function [[Generic_vs_generic.m_stmts_deep]] *)\n and m_stmts_deep (xsa: A.stmt list) (xsb: A.stmt list) =\n-  if !Flag.go_deeper_stmt && (has_ellipsis_stmts xsa)\n-  then\n-    m_list__m_stmt xsa xsb >!> (fun () ->\n-      let xsb' = SubAST_generic.flatten_substmts_of_stmts xsb in\n-      m_list__m_stmt xsa xsb'\n-    )\n-  else m_list__m_stmt xsa xsb\n+  (* opti: this was the old code:\n+   *   if !Flag.go_deeper_stmt && (has_ellipsis_stmts xsa)\n+   *   then\n+   *   m_list__m_stmt xsa xsb >!> (fun () ->\n+   *     let xsb' = SubAST_generic.flatten_substmts_of_stmts xsb in\n+   *     m_list__m_stmt xsa xsb'\n+   *   )\n+   *   else m_list__m_stmt xsa xsb\n+   *\n+   * but this was really slow on huge files because with a pattern like\n+   * 'foo(); ...; bar();' we would call flatten_substmts_of_stmts\n+   * on each sequences in the program, even though foo(); was not\n+   * matched first.\n+   * Better to first match the first element, and if it matches and\n+   * we have a '...' that was not matched on the current sequence,\n+   * then we try with flatten_substmts_of_stmts.\n+   *\n+   * The code below is mostly a copy paste of m_list__m_stmt. We could\n+   * factorize, but I prefer to control and limit the number of places\n+   * where we call m_stmts_deep. Once we call m_list__m_stmt, we\n+   * are in a simpler world where the list of stmts will not grow.\n+   *)\n+  match xsa, xsb with\n+  | [], [] ->\n+      return ()\n+  (*s: [[Generic_vs_generic.m_list__m_stmt()]] empty list vs list case *)\n+  (* less-is-ok:\n+   * it's ok to have statements after in the concrete code as long as we\n+   * matched all the statements in the pattern (there is an implicit\n+   * '...' at the end, in addition to implicit '...' at the beginning\n+   * handled by kstmts calling the pattern for each subsequences).\n+   * TODO: sgrep_generic though then display the whole sequence as a match\n+   * instead of just the relevant part.\n+   *)\n+  | [], _::_ ->\n+      return ()\n+  (*e: [[Generic_vs_generic.m_list__m_stmt()]] empty list vs list case *)", "originalCommit": "3d28f8f2fbc9c74a9c5d511b4549f32d6a13ea7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM3MzEwMw==", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r432373103", "bodyText": "It's just more precise. there is already a case above for [], [], so [], _ below would be more general that it needs to be.", "author": "aryx", "createdAt": "2020-05-29T09:41:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTk3NTk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0NzY3Mg==", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r432047672", "bodyText": "how does one get documentation on >||>?\n>>= seems common enough that it's nicer than Monad.bind, but I'm struggling to grok >||> and >!>. Maybe use the Googleable version instead?", "author": "nbrahms", "createdAt": "2020-05-28T18:47:54Z", "path": "semgrep-core/matching/Generic_vs_generic.ml", "diffHunk": "@@ -1259,13 +1259,74 @@ and m_other_attribute_operator = m_other_xxx\n \n (*s: function [[Generic_vs_generic.m_stmts_deep]] *)\n and m_stmts_deep (xsa: A.stmt list) (xsb: A.stmt list) =\n-  if !Flag.go_deeper_stmt && (has_ellipsis_stmts xsa)\n-  then\n-    m_list__m_stmt xsa xsb >!> (fun () ->\n-      let xsb' = SubAST_generic.flatten_substmts_of_stmts xsb in\n-      m_list__m_stmt xsa xsb'\n-    )\n-  else m_list__m_stmt xsa xsb\n+  (* opti: this was the old code:\n+   *   if !Flag.go_deeper_stmt && (has_ellipsis_stmts xsa)\n+   *   then\n+   *   m_list__m_stmt xsa xsb >!> (fun () ->\n+   *     let xsb' = SubAST_generic.flatten_substmts_of_stmts xsb in\n+   *     m_list__m_stmt xsa xsb'\n+   *   )\n+   *   else m_list__m_stmt xsa xsb\n+   *\n+   * but this was really slow on huge files because with a pattern like\n+   * 'foo(); ...; bar();' we would call flatten_substmts_of_stmts\n+   * on each sequences in the program, even though foo(); was not\n+   * matched first.\n+   * Better to first match the first element, and if it matches and\n+   * we have a '...' that was not matched on the current sequence,\n+   * then we try with flatten_substmts_of_stmts.\n+   *\n+   * The code below is mostly a copy paste of m_list__m_stmt. We could\n+   * factorize, but I prefer to control and limit the number of places\n+   * where we call m_stmts_deep. Once we call m_list__m_stmt, we\n+   * are in a simpler world where the list of stmts will not grow.\n+   *)\n+  match xsa, xsb with\n+  | [], [] ->\n+      return ()\n+  (*s: [[Generic_vs_generic.m_list__m_stmt()]] empty list vs list case *)\n+  (* less-is-ok:\n+   * it's ok to have statements after in the concrete code as long as we\n+   * matched all the statements in the pattern (there is an implicit\n+   * '...' at the end, in addition to implicit '...' at the beginning\n+   * handled by kstmts calling the pattern for each subsequences).\n+   * TODO: sgrep_generic though then display the whole sequence as a match\n+   * instead of just the relevant part.\n+   *)\n+  | [], _::_ ->\n+      return ()\n+  (*e: [[Generic_vs_generic.m_list__m_stmt()]] empty list vs list case *)\n+\n+  (* dots: '...', can also match no statement *)\n+  | [A.ExprStmt (A.Ellipsis _i)], [] ->\n+      return ()\n+\n+  | (A.ExprStmt (A.Ellipsis i))::xsa, xb::xsb ->\n+    (* let's first try the without going deep *)\n+     (\n+      (* can match nothing *)\n+      (m_list__m_stmt xsa (xb::xsb)) >||>", "originalCommit": "3d28f8f2fbc9c74a9c5d511b4549f32d6a13ea7a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA5NTAwNA==", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r432095004", "bodyText": "FWIW:\nhttp://symbolhound.com/?q=%3E%7C%7C%3E+ocaml\nhttp://symbolhound.com/?q=%3E%21%3E+ocaml\nboth return no results.", "author": "nbrahms", "createdAt": "2020-05-28T20:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0NzY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA5NzgwMQ==", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r432097801", "bodyText": "following", "author": "rcoh", "createdAt": "2020-05-28T20:14:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0NzY3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM3MzUxMg==", "url": "https://github.com/returntocorp/semgrep/pull/852#discussion_r432373512", "bodyText": "It's defined in Matching_generic.ml, which is 'open'ed at the beginning of the file.\nNeither >>= nor >||> are predefined OCaml operators. I've defined those operators\nfor the purpose of the matching process.", "author": "aryx", "createdAt": "2020-05-29T09:42:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjA0NzY3Mg=="}], "type": "inlineReview"}, {"oid": "868cc94121b940cdebb27f9d3c5374ec24524a3d", "url": "https://github.com/returntocorp/semgrep/commit/868cc94121b940cdebb27f9d3c5374ec24524a3d", "message": "Merge branch 'develop' into optimize_deep_stmt", "committedDate": "2020-05-28T20:20:24Z", "type": "commit"}]}