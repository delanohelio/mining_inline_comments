{"pr_number": 432, "pr_title": "Add spawner module", "pr_createdAt": "2020-04-27T01:47:14Z", "pr_url": "https://github.com/PGMDev/PGM/pull/432", "timeline": [{"oid": "797b8a7b2e9526312a0fc186c68c46ec3a2bf271", "url": "https://github.com/PGMDev/PGM/commit/797b8a7b2e9526312a0fc186c68c46ec3a2bf271", "message": "Initial module structure and parsing\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-26T03:48:07Z", "type": "commit"}, {"oid": "469dd2d125d7579c5ba9d482e1a313f0a1596adc", "url": "https://github.com/PGMDev/PGM/commit/469dd2d125d7579c5ba9d482e1a313f0a1596adc", "message": "Add object structure\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-26T04:43:28Z", "type": "commit"}, {"oid": "9e535bc713b2edb995065e744e28f659faea7c5c", "url": "https://github.com/PGMDev/PGM/commit/9e535bc713b2edb995065e744e28f659faea7c5c", "message": "Initial spawning behavior\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-26T19:30:58Z", "type": "commit"}, {"oid": "7d50ac1a4e9d7bb9819cb17afae8187ae4270bd7", "url": "https://github.com/PGMDev/PGM/commit/7d50ac1a4e9d7bb9819cb17afae8187ae4270bd7", "message": "Merge branch 'master' of https://github.com/Electroid/PGM into spawner-module", "committedDate": "2020-04-26T19:47:15Z", "type": "commit"}, {"oid": "6e110f08e6ab7c3f2522dc6ba7855ac4f8d98fab", "url": "https://github.com/PGMDev/PGM/commit/6e110f08e6ab7c3f2522dc6ba7855ac4f8d98fab", "message": "Finish mob spawning\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-26T21:01:34Z", "type": "commit"}, {"oid": "0d31d99600a0437047a421cbcfc606643093e644", "url": "https://github.com/PGMDev/PGM/commit/0d31d99600a0437047a421cbcfc606643093e644", "message": "Add TNT and Potions\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-26T22:20:25Z", "type": "commit"}, {"oid": "20423df11258ba8d6869b5495511111506a98925", "url": "https://github.com/PGMDev/PGM/commit/20423df11258ba8d6869b5495511111506a98925", "message": "Add item object\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-26T23:18:15Z", "type": "commit"}, {"oid": "c975bf9c4bb2e782659e58fbf34dcbb5b0482972", "url": "https://github.com/PGMDev/PGM/commit/c975bf9c4bb2e782659e58fbf34dcbb5b0482972", "message": "Fix extra stack spawning\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-26T23:25:20Z", "type": "commit"}, {"oid": "e78c890977a634d9b185a24456b2c40ec3014d68", "url": "https://github.com/PGMDev/PGM/commit/e78c890977a634d9b185a24456b2c40ec3014d68", "message": "Format code\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-26T23:52:21Z", "type": "commit"}, {"oid": "f0d602128e794468325ada8bef767d5bce0dbb4f", "url": "https://github.com/PGMDev/PGM/commit/f0d602128e794468325ada8bef767d5bce0dbb4f", "message": "Format\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-28T00:16:43Z", "type": "forcePushed"}, {"oid": "60a68714d335acf085d63a837b51ce467dea497c", "url": "https://github.com/PGMDev/PGM/commit/60a68714d335acf085d63a837b51ce467dea497c", "message": "Add filter support", "committedDate": "2020-04-28T00:14:37Z", "type": "forcePushed"}, {"oid": "3b12f6fbef7e44df6451c61c23a5120f9fa9f1ad", "url": "https://github.com/PGMDev/PGM/commit/3b12f6fbef7e44df6451c61c23a5120f9fa9f1ad", "message": "Add filter support\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-28T00:26:27Z", "type": "commit"}, {"oid": "3b12f6fbef7e44df6451c61c23a5120f9fa9f1ad", "url": "https://github.com/PGMDev/PGM/commit/3b12f6fbef7e44df6451c61c23a5120f9fa9f1ad", "message": "Add filter support\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-28T00:26:27Z", "type": "forcePushed"}, {"oid": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "url": "https://github.com/PGMDev/PGM/commit/ff23cb29ee991482a9b3789ab7ec9f831223cd59", "message": "Format\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-28T00:29:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkxODEwMw==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416918103", "bodyText": "See Feature and other examples of it, you'll want Spawner implements Feature.", "author": "Electroid", "createdAt": "2020-04-28T20:58:39Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.logging.Logger;\n+import org.bukkit.Location;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+\n+public class Spawner implements Listener, Tickable {", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkxODM3Ng==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416918376", "bodyText": "Is this nessecary, looks unused?", "author": "Electroid", "createdAt": "2020-04-28T20:59:07Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.logging.Logger;\n+import org.bukkit.Location;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+\n+public class Spawner implements Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+  private final Logger logger;", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyMzMyMg==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416923322", "bodyText": "Instead of storing a static variable, just use Match#getRandom when you need it.", "author": "Electroid", "createdAt": "2020-04-28T21:07:51Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.logging.Logger;\n+import org.bukkit.Location;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+\n+public class Spawner implements Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+  private final Logger logger;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private List<Player> trackedPlayers = new ArrayList<>();\n+\n+  private static final Random RANDOM = new Random();", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNDU2Mg==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416924562", "bodyText": "We should avoid at all costs having any Collection with a hard reference to a Player or MatchPlayer, it's essentially a trouble maker for memory leaks. Try using OnlinePlayerMapAdapter", "author": "Electroid", "createdAt": "2020-04-28T21:10:02Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.logging.Logger;\n+import org.bukkit.Location;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+\n+public class Spawner implements Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+  private final Logger logger;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private List<Player> trackedPlayers = new ArrayList<>();", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNTI2Nw==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416925267", "bodyText": "Is this a filter on the players or the spawner location? If it's players, you'll want to name is playerFilter.", "author": "Electroid", "createdAt": "2020-04-28T21:11:23Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerDefinition.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import tc.oc.pgm.api.filter.Filter;\n+import tc.oc.pgm.api.region.Region;\n+\n+public class SpawnerDefinition {\n+\n+  public Region spawnRegion;\n+  public String id;\n+  public int count;\n+  public Region playerRegion;\n+  public int maxEntities;\n+  public Duration minDelay, maxDelay, delay;\n+  public List<SpawnerObject> objects;\n+  public Filter filter;", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNTY2Ng==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416925666", "bodyText": "Be more specific than count, what does this mean?", "author": "Electroid", "createdAt": "2020-04-28T21:12:02Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerDefinition.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import tc.oc.pgm.api.filter.Filter;\n+import tc.oc.pgm.api.region.Region;\n+\n+public class SpawnerDefinition {\n+\n+  public Region spawnRegion;\n+  public String id;\n+  public int count;", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNjgwNw==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416926807", "bodyText": "Other than augmenting vanilla, what's the use-case for varied delays?", "author": "Electroid", "createdAt": "2020-04-28T21:14:01Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerDefinition.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import tc.oc.pgm.api.filter.Filter;\n+import tc.oc.pgm.api.region.Region;\n+\n+public class SpawnerDefinition {\n+\n+  public Region spawnRegion;\n+  public String id;\n+  public int count;\n+  public Region playerRegion;\n+  public int maxEntities;\n+  public Duration minDelay, maxDelay, delay;", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwNzYzMA==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417007630", "bodyText": "The idea was to have the ability to create randomized delays between two values", "author": "EricZeiberg", "createdAt": "2020-04-29T00:39:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNjgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyNzIzNg==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416927236", "bodyText": "This should not be in a MapModule class.", "author": "Electroid", "createdAt": "2020-04-28T21:14:52Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerModule.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package tc.oc.pgm.spawner;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.potion.PotionEffect;\n+import org.jdom2.Attribute;\n+import org.jdom2.Document;\n+import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.filters.FilterModule;\n+import tc.oc.pgm.filters.FilterParser;\n+import tc.oc.pgm.filters.StaticFilter;\n+import tc.oc.pgm.kits.KitParser;\n+import tc.oc.pgm.regions.RegionModule;\n+import tc.oc.pgm.regions.RegionParser;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectEntity;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectItem;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectPotion;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectTNT;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.xml.InvalidXMLException;\n+import tc.oc.pgm.util.xml.XMLUtils;\n+\n+public class SpawnerModule implements MapModule {\n+\n+  private static final List<SpawnerDefinition> spawnerDefinitions = new ArrayList<>();\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyOTgwNA==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416929804", "bodyText": "Be careful, can't use static, since each MapContext will have it's own MapModule.\nAs of right now, all maps will share the same spawners!", "author": "Electroid", "createdAt": "2020-04-28T21:19:58Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerModule.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package tc.oc.pgm.spawner;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.potion.PotionEffect;\n+import org.jdom2.Attribute;\n+import org.jdom2.Document;\n+import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.filters.FilterModule;\n+import tc.oc.pgm.filters.FilterParser;\n+import tc.oc.pgm.filters.StaticFilter;\n+import tc.oc.pgm.kits.KitParser;\n+import tc.oc.pgm.regions.RegionModule;\n+import tc.oc.pgm.regions.RegionParser;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectEntity;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectItem;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectPotion;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectTNT;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.xml.InvalidXMLException;\n+import tc.oc.pgm.util.xml.XMLUtils;\n+\n+public class SpawnerModule implements MapModule {\n+\n+  private static final List<SpawnerDefinition> spawnerDefinitions = new ArrayList<>();", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwODQzMA==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417008430", "bodyText": "Ooh good catch! I was getting some weird behavior when testing this feature, now I know why.", "author": "EricZeiberg", "createdAt": "2020-04-29T00:42:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyOTgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzMDQyOQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416930429", "bodyText": "TimeUtils has helpful methods for comparing durations.", "author": "Electroid", "createdAt": "2020-04-28T21:21:08Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerModule.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package tc.oc.pgm.spawner;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.potion.PotionEffect;\n+import org.jdom2.Attribute;\n+import org.jdom2.Document;\n+import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.filters.FilterModule;\n+import tc.oc.pgm.filters.FilterParser;\n+import tc.oc.pgm.filters.StaticFilter;\n+import tc.oc.pgm.kits.KitParser;\n+import tc.oc.pgm.regions.RegionModule;\n+import tc.oc.pgm.regions.RegionParser;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectEntity;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectItem;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectPotion;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectTNT;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.xml.InvalidXMLException;\n+import tc.oc.pgm.util.xml.XMLUtils;\n+\n+public class SpawnerModule implements MapModule {\n+\n+  private static final List<SpawnerDefinition> spawnerDefinitions = new ArrayList<>();\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  @Override\n+  public MatchModule createMatchModule(Match match) {\n+    return new SpawnerMatchModule(match, spawnerDefinitions);\n+  }\n+\n+  public static class Factory implements MapModuleFactory<SpawnerModule> {\n+    @Override\n+    public Collection<Class<? extends MapModule>> getWeakDependencies() {\n+      return ImmutableList.of(RegionModule.class, FilterModule.class);\n+    }\n+\n+    @Override\n+    public SpawnerModule parse(MapFactory factory, Logger logger, Document doc)\n+        throws InvalidXMLException {\n+      SpawnerModule spawnerModule = new SpawnerModule();\n+      RegionParser regionParser = factory.getRegions();\n+      KitParser kitParser = factory.getKits();\n+      FilterParser filterParser = factory.getFilters();\n+\n+      for (Element element :\n+          XMLUtils.flattenElements(doc.getRootElement(), \"spawners\", \"spawner\")) {\n+        SpawnerDefinition spawnerDefinition = new SpawnerDefinition();\n+        spawnerDefinition.spawnRegion =\n+            regionParser.parseRequiredRegionProperty(element, \"spawn-region\");\n+        spawnerDefinition.playerRegion =\n+            regionParser.parseRequiredRegionProperty(element, \"player-region\");\n+        spawnerDefinition.id = element.getAttributeValue(\"id\");\n+        Attribute delay = element.getAttribute(\"delay\");\n+        Attribute minDelay = element.getAttribute(\"min-delay\");\n+        Attribute maxDelay = element.getAttribute(\"max-delay\");\n+\n+        if ((minDelay != null || maxDelay != null) && delay != null) {\n+          throw new InvalidXMLException(\n+              \"Attribute 'minDelay' and 'maxDelay' cannot be combined with 'delay'\", element);\n+        }\n+\n+        spawnerDefinition.delay = XMLUtils.parseDuration(delay, Duration.ofSeconds(10));\n+        spawnerDefinition.minDelay = XMLUtils.parseDuration(minDelay, spawnerDefinition.delay);\n+        spawnerDefinition.maxDelay = XMLUtils.parseDuration(maxDelay, spawnerDefinition.delay);\n+\n+        if (spawnerDefinition.maxDelay.compareTo(spawnerDefinition.minDelay) < 0) {", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzOTkxOA==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416939918", "bodyText": "One of the more difficult parts of contributing to PGM modules is finding the right balance between features and abstraction. While I think these are all cool features, we don't have the proper abstractions to support them yet.\nWhile PGM has a comprehensive system for parsing items, it does not have an approach for parsing entities (such as tnt, potions, or projectiles). For instance, <projectiles> has its own syntax for spawning projectile entities.\nBefore introducing these features, I think we will need to brainstorm a way to create entity \"templates\" similar to how we create item \"templates\" whenever you parse a kit.\nSince that will take a lot of work, I would suggest changing the MVP of this module to just be items.", "author": "Electroid", "createdAt": "2020-04-28T21:38:54Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerModule.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package tc.oc.pgm.spawner;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.potion.PotionEffect;\n+import org.jdom2.Attribute;\n+import org.jdom2.Document;\n+import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.filters.FilterModule;\n+import tc.oc.pgm.filters.FilterParser;\n+import tc.oc.pgm.filters.StaticFilter;\n+import tc.oc.pgm.kits.KitParser;\n+import tc.oc.pgm.regions.RegionModule;\n+import tc.oc.pgm.regions.RegionParser;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectEntity;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectItem;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectPotion;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectTNT;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.xml.InvalidXMLException;\n+import tc.oc.pgm.util.xml.XMLUtils;\n+\n+public class SpawnerModule implements MapModule {\n+\n+  private static final List<SpawnerDefinition> spawnerDefinitions = new ArrayList<>();\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  @Override\n+  public MatchModule createMatchModule(Match match) {\n+    return new SpawnerMatchModule(match, spawnerDefinitions);\n+  }\n+\n+  public static class Factory implements MapModuleFactory<SpawnerModule> {\n+    @Override\n+    public Collection<Class<? extends MapModule>> getWeakDependencies() {\n+      return ImmutableList.of(RegionModule.class, FilterModule.class);\n+    }\n+\n+    @Override\n+    public SpawnerModule parse(MapFactory factory, Logger logger, Document doc)\n+        throws InvalidXMLException {\n+      SpawnerModule spawnerModule = new SpawnerModule();\n+      RegionParser regionParser = factory.getRegions();\n+      KitParser kitParser = factory.getKits();\n+      FilterParser filterParser = factory.getFilters();\n+\n+      for (Element element :\n+          XMLUtils.flattenElements(doc.getRootElement(), \"spawners\", \"spawner\")) {\n+        SpawnerDefinition spawnerDefinition = new SpawnerDefinition();\n+        spawnerDefinition.spawnRegion =\n+            regionParser.parseRequiredRegionProperty(element, \"spawn-region\");\n+        spawnerDefinition.playerRegion =\n+            regionParser.parseRequiredRegionProperty(element, \"player-region\");\n+        spawnerDefinition.id = element.getAttributeValue(\"id\");\n+        Attribute delay = element.getAttribute(\"delay\");\n+        Attribute minDelay = element.getAttribute(\"min-delay\");\n+        Attribute maxDelay = element.getAttribute(\"max-delay\");\n+\n+        if ((minDelay != null || maxDelay != null) && delay != null) {\n+          throw new InvalidXMLException(\n+              \"Attribute 'minDelay' and 'maxDelay' cannot be combined with 'delay'\", element);\n+        }\n+\n+        spawnerDefinition.delay = XMLUtils.parseDuration(delay, Duration.ofSeconds(10));\n+        spawnerDefinition.minDelay = XMLUtils.parseDuration(minDelay, spawnerDefinition.delay);\n+        spawnerDefinition.maxDelay = XMLUtils.parseDuration(maxDelay, spawnerDefinition.delay);\n+\n+        if (spawnerDefinition.maxDelay.compareTo(spawnerDefinition.minDelay) < 0) {\n+          throw new InvalidXMLException(\"Max delay cannot be smaller than min delay\", element);\n+        }\n+\n+        spawnerDefinition.maxEntities =\n+            XMLUtils.parseNumber(\n+                element.getAttribute(\"max-entities\"), Integer.class, Integer.MAX_VALUE);\n+        spawnerDefinition.filter =\n+            filterParser.parseFilterProperty(element, \"filter\", StaticFilter.ALLOW);\n+\n+        List<SpawnerObject> objects = new ArrayList<>();\n+        for (Element object : XMLUtils.getChildren(element, \"entity\", \"item\", \"tnt\", \"effect\")) {\n+          int count;\n+          switch (object.getName()) {\n+            case \"entity\":\n+              count = XMLUtils.parseNumber(object.getAttribute(\"count\"), Integer.class, 1);\n+              SpawnerObjectEntity entity =\n+                  new SpawnerObjectEntity(XMLUtils.parseEntityType(object), count);\n+              objects.add(entity);\n+              break;\n+            case \"tnt\":\n+              Duration fuse = XMLUtils.parseDuration(object.getAttribute(\"fuse\"));\n+              float power = XMLUtils.parseNumber(object.getAttribute(\"power\"), Float.class);\n+              count = XMLUtils.parseNumber(object.getAttribute(\"count\"), Integer.class, 1);\n+              SpawnerObjectTNT tnt =\n+                  new SpawnerObjectTNT(power, (int) TimeUtils.toTicks(fuse), count);\n+              objects.add(tnt);\n+              break;\n+            case \"effect\":\n+              PotionEffect effect = XMLUtils.parsePotionEffect(object);\n+              count = XMLUtils.parseNumber(object.getAttribute(\"count\"), Integer.class, 1);\n+              SpawnerObjectPotion potion = new SpawnerObjectPotion(count, effect);\n+              objects.add(potion);\n+              break;", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MDY2Nw==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416940667", "bodyText": "This doesn't seem necessary, because you could just have non-trackable entities return 0 on spawnCount", "author": "Electroid", "createdAt": "2020-04-28T21:40:20Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerObject.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+\n+public interface SpawnerObject {\n+\n+  void spawn(Location location);\n+\n+  /**\n+   * Some objects are tracked and added to the max entities count (Mobs, items) while others\n+   * (ThrownPotions, TNT) are not.\n+   *\n+   * @return whether the object affects the entity count.\n+   */\n+  boolean isTracked();", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzAwOTMzNg==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417009336", "bodyText": "That seems a bit confusing, as the spawnCount getter is expected to return how many of the object was spawned, not if they contribute to the entity cap.", "author": "EricZeiberg", "createdAt": "2020-04-29T00:46:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MDY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MDc2NQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416940765", "bodyText": "getSpawnCount", "author": "Electroid", "createdAt": "2020-04-28T21:40:30Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerObject.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+\n+public interface SpawnerObject {\n+\n+  void spawn(Location location);\n+\n+  /**\n+   * Some objects are tracked and added to the max entities count (Mobs, items) while others\n+   * (ThrownPotions, TNT) are not.\n+   *\n+   * @return whether the object affects the entity count.\n+   */\n+  boolean isTracked();\n+\n+  int spawnCount();", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MDk2MQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416940961", "bodyText": "Spawnable", "author": "Electroid", "createdAt": "2020-04-28T21:40:57Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerObject.java", "diffHunk": "@@ -0,0 +1,18 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+\n+public interface SpawnerObject {", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MjA3MA==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416942070", "bodyText": "I think you'll need to clamp this value so map makers can't spawn 10k entities.", "author": "Electroid", "createdAt": "2020-04-28T21:43:11Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerModule.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package tc.oc.pgm.spawner;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.time.Duration;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.logging.Logger;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.potion.PotionEffect;\n+import org.jdom2.Attribute;\n+import org.jdom2.Document;\n+import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.filters.FilterModule;\n+import tc.oc.pgm.filters.FilterParser;\n+import tc.oc.pgm.filters.StaticFilter;\n+import tc.oc.pgm.kits.KitParser;\n+import tc.oc.pgm.regions.RegionModule;\n+import tc.oc.pgm.regions.RegionParser;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectEntity;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectItem;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectPotion;\n+import tc.oc.pgm.spawner.objects.SpawnerObjectTNT;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.xml.InvalidXMLException;\n+import tc.oc.pgm.util.xml.XMLUtils;\n+\n+public class SpawnerModule implements MapModule {\n+\n+  private static final List<SpawnerDefinition> spawnerDefinitions = new ArrayList<>();\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  @Override\n+  public MatchModule createMatchModule(Match match) {\n+    return new SpawnerMatchModule(match, spawnerDefinitions);\n+  }\n+\n+  public static class Factory implements MapModuleFactory<SpawnerModule> {\n+    @Override\n+    public Collection<Class<? extends MapModule>> getWeakDependencies() {\n+      return ImmutableList.of(RegionModule.class, FilterModule.class);\n+    }\n+\n+    @Override\n+    public SpawnerModule parse(MapFactory factory, Logger logger, Document doc)\n+        throws InvalidXMLException {\n+      SpawnerModule spawnerModule = new SpawnerModule();\n+      RegionParser regionParser = factory.getRegions();\n+      KitParser kitParser = factory.getKits();\n+      FilterParser filterParser = factory.getFilters();\n+\n+      for (Element element :\n+          XMLUtils.flattenElements(doc.getRootElement(), \"spawners\", \"spawner\")) {\n+        SpawnerDefinition spawnerDefinition = new SpawnerDefinition();\n+        spawnerDefinition.spawnRegion =\n+            regionParser.parseRequiredRegionProperty(element, \"spawn-region\");\n+        spawnerDefinition.playerRegion =\n+            regionParser.parseRequiredRegionProperty(element, \"player-region\");\n+        spawnerDefinition.id = element.getAttributeValue(\"id\");\n+        Attribute delay = element.getAttribute(\"delay\");\n+        Attribute minDelay = element.getAttribute(\"min-delay\");\n+        Attribute maxDelay = element.getAttribute(\"max-delay\");\n+\n+        if ((minDelay != null || maxDelay != null) && delay != null) {\n+          throw new InvalidXMLException(\n+              \"Attribute 'minDelay' and 'maxDelay' cannot be combined with 'delay'\", element);\n+        }\n+\n+        spawnerDefinition.delay = XMLUtils.parseDuration(delay, Duration.ofSeconds(10));\n+        spawnerDefinition.minDelay = XMLUtils.parseDuration(minDelay, spawnerDefinition.delay);\n+        spawnerDefinition.maxDelay = XMLUtils.parseDuration(maxDelay, spawnerDefinition.delay);\n+\n+        if (spawnerDefinition.maxDelay.compareTo(spawnerDefinition.minDelay) < 0) {\n+          throw new InvalidXMLException(\"Max delay cannot be smaller than min delay\", element);\n+        }\n+\n+        spawnerDefinition.maxEntities =\n+            XMLUtils.parseNumber(\n+                element.getAttribute(\"max-entities\"), Integer.class, Integer.MAX_VALUE);\n+        spawnerDefinition.filter =\n+            filterParser.parseFilterProperty(element, \"filter\", StaticFilter.ALLOW);\n+\n+        List<SpawnerObject> objects = new ArrayList<>();\n+        for (Element object : XMLUtils.getChildren(element, \"entity\", \"item\", \"tnt\", \"effect\")) {\n+          int count;\n+          switch (object.getName()) {\n+            case \"entity\":\n+              count = XMLUtils.parseNumber(object.getAttribute(\"count\"), Integer.class, 1);", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NjMxMg==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416946312", "bodyText": "Make a helper method for that if check.", "author": "Electroid", "createdAt": "2020-04-28T21:52:25Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.logging.Logger;\n+import org.bukkit.Location;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+\n+public class Spawner implements Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+  private final Logger logger;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private List<Player> trackedPlayers = new ArrayList<>();\n+\n+  private static final Random RANDOM = new Random();\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match, Logger logger) {\n+    this.definition = definition;\n+    this.match = match;\n+    this.logger = logger;\n+\n+    this.lastTick = match.getTick().tick;\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (SpawnerObject object : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(RANDOM);\n+        object.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()));\n+        if (object.isTracked()) {\n+          spawnedEntities = spawnedEntities + object.spawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (RANDOM.nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities < definition.maxEntities && trackedPlayers.size() != 0) {\n+      for (Player p : trackedPlayers) {\n+        if (definition.filter.query(match.getPlayer(p).getQuery()).isAllowed()) {\n+          return true;\n+        }\n+      }\n+      return false;\n+    }\n+    return false;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (event.getEntity().getMetadata(SpawnerModule.METADATA_KEY, PGM.get()) != null) {", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NzM2Nw==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r416947367", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (spawnedEntities < definition.maxEntities && trackedPlayers.size() != 0) {\n          \n          \n            \n               if (spawnedEntities  > definition.maxEntities || trackedPlayers.isEmpty()) return false;", "author": "Electroid", "createdAt": "2020-04-28T21:54:48Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.logging.Logger;\n+import org.bukkit.Location;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+\n+public class Spawner implements Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+  private final Logger logger;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private List<Player> trackedPlayers = new ArrayList<>();\n+\n+  private static final Random RANDOM = new Random();\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match, Logger logger) {\n+    this.definition = definition;\n+    this.match = match;\n+    this.logger = logger;\n+\n+    this.lastTick = match.getTick().tick;\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (SpawnerObject object : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(RANDOM);\n+        object.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()));\n+        if (object.isTracked()) {\n+          spawnedEntities = spawnedEntities + object.spawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (RANDOM.nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities < definition.maxEntities && trackedPlayers.size() != 0) {", "originalCommit": "ff23cb29ee991482a9b3789ab7ec9f831223cd59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "75d0e3c087261fd7eec035462609ad66caddf167", "url": "https://github.com/PGMDev/PGM/commit/75d0e3c087261fd7eec035462609ad66caddf167", "message": "Make Spawner implement Feature and refactor some stuff\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-29T00:52:21Z", "type": "commit"}, {"oid": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "url": "https://github.com/PGMDev/PGM/commit/dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "message": "Add particles and remove non-item spawnables\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-04-29T19:13:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1NDU4MQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417654581", "bodyText": "So typically the best way to sort variables in a class is (at least in this project)\n// static variables\n//\n// final variables\n//\n// other variables\n\nprotected final static String METADATA_KEY = \"spawner\";\n\nprivate final Match match;\nprivate final SpawnerDefinition definition;\nprivate final OnlinePlayerMapAdapter<MatchPlayer> players;\n\nprivate long lastTick;\nprivate long currentDelay;\nprivate long spawnedEntities;", "author": "Electroid", "createdAt": "2020-04-29T22:41:00Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1NjEwOQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417656109", "bodyText": "Small if guards can be collapsed.\nif (!canSpawn()) return;\nCould also change this to be:\nif (!canSpawn() || match.getTick().tick - lastTick < generatedDelay) return;", "author": "Electroid", "createdAt": "2020-04-29T22:45:09Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1OTYyNA==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417659624", "bodyText": "Use final whenever you can.", "author": "Electroid", "createdAt": "2020-04-29T22:55:17Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1OTcwNw==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417659707", "bodyText": "Also this variable name can just be location", "author": "Electroid", "createdAt": "2020-04-29T22:55:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY1OTYyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MDA3NQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417660075", "bodyText": "Use player instead of p, 1 letter arguments are usually only okay for Exception e in try/catch blocks.", "author": "Electroid", "createdAt": "2020-04-29T22:56:29Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MDE3Ng==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417660176", "bodyText": "isTracked", "author": "Electroid", "createdAt": "2020-04-29T22:56:45Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTrackedEntity(Entity entity) {", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MDM1NQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417660355", "bodyText": "spawnedEntities -= event.getEntity().getItemStack().getAmount()", "author": "Electroid", "createdAt": "2020-04-29T22:57:16Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTrackedEntity(Entity entity) {\n+    return entity.getMetadata(METADATA_KEY, PGM.get()) != null;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities--;\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onItemDespawn(ItemDespawnEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities = spawnedEntities - event.getEntity().getItemStack().getAmount();", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MTYzMg==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417661632", "bodyText": "final MatchPlayer player = match.getParticipant(event.getPlayer());\nif (player == null) return;\n// ...", "author": "Electroid", "createdAt": "2020-04-29T23:01:10Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTrackedEntity(Entity entity) {\n+    return entity.getMetadata(METADATA_KEY, PGM.get()) != null;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities--;\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onItemDespawn(ItemDespawnEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities = spawnedEntities - event.getEntity().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerPickup(PlayerPickupItemEvent event) {\n+    if (isTrackedEntity(event.getItem())) {\n+      spawnedEntities = spawnedEntities - event.getItem().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerMove(CoarsePlayerMoveEvent event) {\n+    Player player = event.getPlayer();\n+    if (match.getPlayer(player).isObserving()) {\n+      return;\n+    }", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MjA0Mg==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417662042", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                if (definition.playerRegion.contains(event.getPlayer()) && trackedPlayers.get(player) == null) {\n          \n          \n            \n                  trackedPlayers.put(player, match.getPlayer(player));\n          \n          \n            \n                } else if (!definition.playerRegion.contains(event.getPlayer())) {\n          \n          \n            \n                  trackedPlayers.remove(player);\n          \n          \n            \n                }\n          \n          \n            \n                if (definition.playerRegion.contains(event.getPlayer())) {\n          \n          \n            \n                  trackedPlayers.putIfAbsent(player, match.getPlayer(player));\n          \n          \n            \n                } else {\n          \n          \n            \n                  trackedPlayers.remove(player);\n          \n          \n            \n                }", "author": "Electroid", "createdAt": "2020-04-29T23:02:26Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTrackedEntity(Entity entity) {\n+    return entity.getMetadata(METADATA_KEY, PGM.get()) != null;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities--;\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onItemDespawn(ItemDespawnEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities = spawnedEntities - event.getEntity().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerPickup(PlayerPickupItemEvent event) {\n+    if (isTrackedEntity(event.getItem())) {\n+      spawnedEntities = spawnedEntities - event.getItem().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerMove(CoarsePlayerMoveEvent event) {\n+    Player player = event.getPlayer();\n+    if (match.getPlayer(player).isObserving()) {\n+      return;\n+    }\n+    if (definition.playerRegion.contains(event.getPlayer()) && trackedPlayers.get(player) == null) {\n+      trackedPlayers.put(player, match.getPlayer(player));\n+    } else if (!definition.playerRegion.contains(event.getPlayer())) {\n+      trackedPlayers.remove(player);\n+    }", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MjI1NQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417662255", "bodyText": "Since you're using OnlinePlayerMapAdapter players are automatically removed on quit, so you can remove this.", "author": "Electroid", "createdAt": "2020-04-29T23:03:08Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTrackedEntity(Entity entity) {\n+    return entity.getMetadata(METADATA_KEY, PGM.get()) != null;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities--;\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onItemDespawn(ItemDespawnEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities = spawnedEntities - event.getEntity().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerPickup(PlayerPickupItemEvent event) {\n+    if (isTrackedEntity(event.getItem())) {\n+      spawnedEntities = spawnedEntities - event.getItem().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerMove(CoarsePlayerMoveEvent event) {\n+    Player player = event.getPlayer();\n+    if (match.getPlayer(player).isObserving()) {\n+      return;\n+    }\n+    if (definition.playerRegion.contains(event.getPlayer()) && trackedPlayers.get(player) == null) {\n+      trackedPlayers.put(player, match.getPlayer(player));\n+    } else if (!definition.playerRegion.contains(event.getPlayer())) {\n+      trackedPlayers.remove(player);\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerQuit(PlayerQuitEvent event) {\n+    trackedPlayers.remove(event.getPlayer());\n+  }", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2MjkxMA==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417662910", "bodyText": "You'll want to clear this when the match ends. MatchFinishEvent", "author": "Electroid", "createdAt": "2020-04-29T23:05:03Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2Mzc1Ng==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417663756", "bodyText": "I'd make a constructor for this and use it. Make all these variables final.", "author": "Electroid", "createdAt": "2020-04-29T23:07:39Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerDefinition.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.time.Duration;\n+import java.util.List;\n+import tc.oc.pgm.api.feature.FeatureDefinition;\n+import tc.oc.pgm.api.feature.FeatureInfo;\n+import tc.oc.pgm.api.filter.Filter;\n+import tc.oc.pgm.api.region.Region;\n+\n+@FeatureInfo(name = \"spawner\")\n+public class SpawnerDefinition implements FeatureDefinition {", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2NTIzNA==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417665234", "bodyText": "final", "author": "Electroid", "createdAt": "2020-04-29T23:11:57Z", "path": "core/src/main/java/tc/oc/pgm/spawner/SpawnerMatchModule.java", "diffHunk": "@@ -0,0 +1,26 @@\n+package tc.oc.pgm.spawner;\n+\n+import java.util.List;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+\n+public class SpawnerMatchModule implements MatchModule {\n+\n+  private Match match;\n+  private List<SpawnerDefinition> definitions;", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2NTYwMg==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417665602", "bodyText": "Make this a private static final, change to spawner-item", "author": "Electroid", "createdAt": "2020-04-29T23:13:04Z", "path": "core/src/main/java/tc/oc/pgm/spawner/objects/SpawnableItem.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package tc.oc.pgm.spawner.objects;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Item;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.spawner.Spawnable;\n+import tc.oc.pgm.spawner.Spawner;\n+import tc.oc.pgm.util.nms.NMSHacks;\n+\n+public class SpawnableItem implements Spawnable {\n+\n+  private int count;\n+  private ItemStack stack;\n+  private String metadataValue = \"Spawner Item\";", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2NTc2NQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417665765", "bodyText": "Can't you set the count in ItemStack#setAmount ? And not need to store count?", "author": "Electroid", "createdAt": "2020-04-29T23:13:30Z", "path": "core/src/main/java/tc/oc/pgm/spawner/objects/SpawnableItem.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package tc.oc.pgm.spawner.objects;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Item;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.spawner.Spawnable;\n+import tc.oc.pgm.spawner.Spawner;\n+import tc.oc.pgm.util.nms.NMSHacks;\n+\n+public class SpawnableItem implements Spawnable {\n+\n+  private int count;\n+  private ItemStack stack;", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzY2NjA5NA==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r417666094", "bodyText": "Don't use NMSHacks it will soon be totally gone. For that API you can use World#spigot#playParticle (I think that's what it is)", "author": "Electroid", "createdAt": "2020-04-29T23:14:26Z", "path": "core/src/main/java/tc/oc/pgm/spawner/objects/SpawnableItem.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package tc.oc.pgm.spawner.objects;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Item;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.metadata.FixedMetadataValue;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.spawner.Spawnable;\n+import tc.oc.pgm.spawner.Spawner;\n+import tc.oc.pgm.util.nms.NMSHacks;\n+\n+public class SpawnableItem implements Spawnable {\n+\n+  private int count;\n+  private ItemStack stack;\n+  private String metadataValue = \"Spawner Item\";\n+\n+  public SpawnableItem(ItemStack stack) {\n+    this.count = stack.getAmount();\n+    this.stack = stack;\n+  }\n+\n+  @Override\n+  public void spawn(Location location, Match match) {\n+    Item item = location.getWorld().dropItem(location.add(0, 1, 0), stack);\n+    item.setMetadata(Spawner.METADATA_KEY, new FixedMetadataValue(PGM.get(), metadataValue));\n+\n+    Object particle =\n+        NMSHacks.particlesPacket(\n+            \"FLAME\", true, location.toVector(), new Vector(0.15, 0.15, 0.15), 0, 40);\n+    for (MatchPlayer player : match.getPlayers()) {\n+      NMSHacks.sendPacket(player.getBukkit(), particle);\n+    }", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwMDc1Mg==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418500752", "bodyText": "Can be one line\nif (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) return false;", "author": "KingOfSquares", "createdAt": "2020-05-01T11:02:58Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwMDg0OQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418500849", "bodyText": "Can also be one line:\nif (definition.playerFilter.query(p.getQuery()).isAllowed()) return true;", "author": "KingOfSquares", "createdAt": "2020-05-01T11:03:30Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwMTA2MA==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418501060", "bodyText": "final long", "author": "KingOfSquares", "createdAt": "2020-05-01T11:04:19Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwMTQzMg==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418501432", "bodyText": "if (isTrackedEntity(event.getEntity())) spawnedEntities--;", "author": "KingOfSquares", "createdAt": "2020-05-01T11:05:42Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTrackedEntity(Entity entity) {\n+    return entity.getMetadata(METADATA_KEY, PGM.get()) != null;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities--;", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODUwMTcyNA==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418501724", "bodyText": "if (match.getPlayer(player).isObserving()) return;", "author": "KingOfSquares", "createdAt": "2020-05-01T11:06:34Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,148 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Location;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.event.player.PlayerQuitEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  private final SpawnerDefinition definition;\n+  private final Match match;\n+\n+  private long lastTick;\n+\n+  private int spawnedEntities;\n+  private OnlinePlayerMapAdapter<MatchPlayer> trackedPlayers;\n+\n+  public static final String METADATA_KEY = \"PGM_SPAWNER_OBJECT\";\n+\n+  private static long generatedDelay;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.trackedPlayers = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) {\n+      return;\n+    }\n+    if (match.getTick().tick - lastTick >= generatedDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        Vector randomSpawnLoc = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(\n+            new Location(\n+                match.getWorld(),\n+                randomSpawnLoc.getX(),\n+                randomSpawnLoc.getY(),\n+                randomSpawnLoc.getZ()),\n+            match);\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      generatedDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      generatedDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || trackedPlayers.isEmpty()) {\n+      return false;\n+    }\n+    for (MatchPlayer p : trackedPlayers.values()) {\n+      if (definition.playerFilter.query(p.getQuery()).isAllowed()) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTrackedEntity(Entity entity) {\n+    return entity.getMetadata(METADATA_KEY, PGM.get()) != null;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities--;\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onItemDespawn(ItemDespawnEvent event) {\n+    if (isTrackedEntity(event.getEntity())) {\n+      spawnedEntities = spawnedEntities - event.getEntity().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerPickup(PlayerPickupItemEvent event) {\n+    if (isTrackedEntity(event.getItem())) {\n+      spawnedEntities = spawnedEntities - event.getItem().getItemStack().getAmount();\n+    }\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerMove(CoarsePlayerMoveEvent event) {\n+    Player player = event.getPlayer();\n+    if (match.getPlayer(player).isObserving()) {\n+      return;", "originalCommit": "dfe3b857558b140aeee17d4d6161db0a7d6cf4d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8943829d855b3a2b65dad079e1b2ff69e64814af", "url": "https://github.com/PGMDev/PGM/commit/8943829d855b3a2b65dad079e1b2ff69e64814af", "message": "Merge branch 'master' into spawner-module", "committedDate": "2020-05-01T23:43:52Z", "type": "commit"}, {"oid": "4fc649c86dc38581d2c1a9f3c93f42b7abef98c4", "url": "https://github.com/PGMDev/PGM/commit/4fc649c86dc38581d2c1a9f3c93f42b7abef98c4", "message": "More code style changes, use #playEffect\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-05-02T00:30:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk3MzUxNQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418973515", "bodyText": "Since you do toLocation twice below. Just have location be a Location.", "author": "Electroid", "createdAt": "2020-05-02T15:44:56Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Effect;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  public static final String METADATA_KEY = \"spawner\";\n+\n+  private final Match match;\n+  private final SpawnerDefinition definition;\n+  private final OnlinePlayerMapAdapter<MatchPlayer> players;\n+\n+  private long lastTick;\n+  private long currentDelay;\n+  private long spawnedEntities;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.players = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) return;\n+    if (match.getTick().tick - lastTick >= currentDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        final Vector location = definition.spawnRegion.getRandom(match.getRandom());", "originalCommit": "4fc649c86dc38581d2c1a9f3c93f42b7abef98c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk3MzU2Nw==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418973567", "bodyText": "I think this should be handled in generateDelay. Maybe rename the method calculateDelay", "author": "Electroid", "createdAt": "2020-05-02T15:45:36Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Effect;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  public static final String METADATA_KEY = \"spawner\";\n+\n+  private final Match match;\n+  private final SpawnerDefinition definition;\n+  private final OnlinePlayerMapAdapter<MatchPlayer> players;\n+\n+  private long lastTick;\n+  private long currentDelay;\n+  private long spawnedEntities;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.players = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) return;\n+    if (match.getTick().tick - lastTick >= currentDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        final Vector location = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(location.toLocation(match.getWorld()), match);\n+        match\n+            .getWorld()\n+            .spigot()\n+            .playEffect(\n+                location.toLocation(match.getWorld()), Effect.FLAME, 0, 0, 0, 0.15f, 0, 0, 40, 64);\n+\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;", "originalCommit": "4fc649c86dc38581d2c1a9f3c93f42b7abef98c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk3MzYwNQ==", "url": "https://github.com/PGMDev/PGM/pull/432#discussion_r418973605", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  spawnedEntities = spawnedEntities - event.getItem().getItemStack().getAmount();\n          \n          \n            \n                  spawnedEntities -= event.getItem().getItemStack().getAmount();", "author": "Electroid", "createdAt": "2020-05-02T15:45:58Z", "path": "core/src/main/java/tc/oc/pgm/spawner/Spawner.java", "diffHunk": "@@ -0,0 +1,134 @@\n+package tc.oc.pgm.spawner;\n+\n+import org.bukkit.Effect;\n+import org.bukkit.entity.Entity;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.EventPriority;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.entity.EntityDeathEvent;\n+import org.bukkit.event.entity.ItemDespawnEvent;\n+import org.bukkit.event.player.PlayerPickupItemEvent;\n+import org.bukkit.util.Vector;\n+import tc.oc.pgm.api.PGM;\n+import tc.oc.pgm.api.event.CoarsePlayerMoveEvent;\n+import tc.oc.pgm.api.feature.Feature;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.Tickable;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.time.Tick;\n+import tc.oc.pgm.util.TimeUtils;\n+import tc.oc.pgm.util.bukkit.OnlinePlayerMapAdapter;\n+\n+public class Spawner implements Feature<SpawnerDefinition>, Listener, Tickable {\n+\n+  public static final String METADATA_KEY = \"spawner\";\n+\n+  private final Match match;\n+  private final SpawnerDefinition definition;\n+  private final OnlinePlayerMapAdapter<MatchPlayer> players;\n+\n+  private long lastTick;\n+  private long currentDelay;\n+  private long spawnedEntities;\n+\n+  public Spawner(SpawnerDefinition definition, Match match) {\n+    this.definition = definition;\n+    this.match = match;\n+\n+    this.lastTick = match.getTick().tick;\n+    this.players = new OnlinePlayerMapAdapter<>(PGM.get());\n+    generateDelay();\n+  }\n+\n+  @Override\n+  public String getId() {\n+    return definition.id;\n+  }\n+\n+  @Override\n+  public SpawnerDefinition getDefinition() {\n+    return definition;\n+  }\n+\n+  @Override\n+  public void tick(Match match, Tick tick) {\n+    if (!canSpawn()) return;\n+    if (match.getTick().tick - lastTick >= currentDelay) {\n+      for (Spawnable spawnable : definition.objects) {\n+        final Vector location = definition.spawnRegion.getRandom(match.getRandom());\n+        spawnable.spawn(location.toLocation(match.getWorld()), match);\n+        match\n+            .getWorld()\n+            .spigot()\n+            .playEffect(\n+                location.toLocation(match.getWorld()), Effect.FLAME, 0, 0, 0, 0.15f, 0, 0, 40, 64);\n+\n+        if (spawnable.isTracked()) {\n+          spawnedEntities = spawnedEntities + spawnable.getSpawnCount();\n+        }\n+      }\n+      generateDelay();\n+      lastTick = match.getTick().tick;\n+    }\n+  }\n+\n+  private void generateDelay() {\n+    if (definition.minDelay == definition.maxDelay) {\n+      currentDelay = TimeUtils.toTicks(definition.delay);\n+    } else {\n+      long maxDelay = TimeUtils.toTicks(definition.maxDelay);\n+      long minDelay = TimeUtils.toTicks(definition.minDelay);\n+      currentDelay =\n+          (long)\n+              (match.getRandom().nextDouble() * (maxDelay - minDelay)\n+                  + minDelay); // Picks a random tick duration between minDelay and maxDelay\n+    }\n+  }\n+\n+  private boolean canSpawn() {\n+    if (spawnedEntities >= definition.maxEntities || players.isEmpty()) return false;\n+    for (MatchPlayer player : players.values()) {\n+      if (definition.playerFilter.query(player.getQuery()).isAllowed()) return true;\n+    }\n+    return false;\n+  }\n+\n+  private boolean isTracked(Entity entity) {\n+    return entity.getMetadata(METADATA_KEY, PGM.get()) != null;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onEntityDeath(EntityDeathEvent event) {\n+    if (isTracked(event.getEntity())) spawnedEntities--;\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onItemDespawn(ItemDespawnEvent event) {\n+    if (isTracked(event.getEntity()))\n+      spawnedEntities -= event.getEntity().getItemStack().getAmount();\n+  }\n+\n+  @EventHandler(priority = EventPriority.MONITOR)\n+  public void onPlayerPickup(PlayerPickupItemEvent event) {\n+    if (isTracked(event.getItem()))\n+      spawnedEntities = spawnedEntities - event.getItem().getItemStack().getAmount();", "originalCommit": "4fc649c86dc38581d2c1a9f3c93f42b7abef98c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "24760b150d33fef1d757cc8a398f4169d4d19f68", "url": "https://github.com/PGMDev/PGM/commit/24760b150d33fef1d757cc8a398f4169d4d19f68", "message": "Merge branch 'master' into spawner-module", "committedDate": "2020-05-02T15:48:24Z", "type": "commit"}, {"oid": "5c3b1f945cf605802246f444a9e74b8a59b781ab", "url": "https://github.com/PGMDev/PGM/commit/5c3b1f945cf605802246f444a9e74b8a59b781ab", "message": "More small code style changes\n\nSigned-off-by: Eric Zeiberg <ejzeiberg@gmail.com>", "committedDate": "2020-05-02T15:54:27Z", "type": "commit"}, {"oid": "0ccb62b0842a7c131b6cc352232116f0f0616f28", "url": "https://github.com/PGMDev/PGM/commit/0ccb62b0842a7c131b6cc352232116f0f0616f28", "message": "Merge branch 'spawner-module' of https://github.com/EricZeiberg/PGM into spawner-module", "committedDate": "2020-05-02T15:54:44Z", "type": "commit"}]}