{"pr_number": 729, "pr_title": "Menu fixes and refactors", "pr_createdAt": "2020-12-03T22:46:17Z", "pr_url": "https://github.com/PGMDev/PGM/pull/729", "timeline": [{"oid": "4dfed4b717aab20d3d335b755fde210993de2d4c", "url": "https://github.com/PGMDev/PGM/commit/4dfed4b717aab20d3d335b755fde210993de2d4c", "message": "Smaller fixes\n\n- Switch WeakHashMap for WeakCollection\n- Make enabling and disabling inventories public\n- Stops checking clicks in other worlds\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-12-05T15:31:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgyODE2MA==", "url": "https://github.com/PGMDev/PGM/pull/729#discussion_r536828160", "bodyText": "Is there a better way to do this? This it totally nebulous.", "author": "Electroid", "createdAt": "2020-12-05T17:33:36Z", "path": "util/src/main/java/tc/oc/pgm/util/menu/pattern/Dynamic5RowMenuArranger.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.util.menu.pattern;\n+\n+import java.util.List;\n+import tc.oc.pgm.util.menu.InventoryMenuItem;\n+import tc.oc.pgm.util.menu.InventoryMenuUtils;\n+\n+public class Dynamic5RowMenuArranger extends MenuArranger {\n+\n+  @Override\n+  public List<InventoryMenuItem> arrangeItems(List<InventoryMenuItem> itemsWithoutSpaces) {\n+\n+    // Figure out which slots to use\n+    int[] slots = new int[Math.min(itemsWithoutSpaces.size(), 18)];\n+\n+    switch (slots.length) {", "originalCommit": "4dfed4b717aab20d3d335b755fde210993de2d4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzAyNDAxOA==", "url": "https://github.com/PGMDev/PGM/pull/729#discussion_r537024018", "bodyText": "It felt the most intuitive way to have a different display for each amount. I could always reduce the \"customization\" for less code?", "author": "KingOfSquares", "createdAt": "2020-12-06T12:01:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgyODE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzE1MzI2OQ==", "url": "https://github.com/PGMDev/PGM/pull/729#discussion_r537153269", "bodyText": "You can create a similar algorithm without hand-picked slots", "author": "Pablete1234", "createdAt": "2020-12-06T23:51:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgyODE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzczNjE2Mw==", "url": "https://github.com/PGMDev/PGM/pull/729#discussion_r537736163", "bodyText": "This could just be my opinion but the checkerboard pattern for player heads just seems strange. I don't see any reason for it as it just increases the number of pages required to display a full team due to the excess padding.\n\nI think the teams should use some logic to spread them evenly but like you say I'm sure some math can be done for this.", "author": "Pugzy", "createdAt": "2020-12-07T18:36:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgyODE2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0NDkxOQ==", "url": "https://github.com/PGMDev/PGM/pull/729#discussion_r537744919", "bodyText": "Seems like the algorithm would just start in the upper left hand corner and skip a slot?", "author": "Electroid", "createdAt": "2020-12-07T18:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjgyODE2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0NDAxOQ==", "url": "https://github.com/PGMDev/PGM/pull/729#discussion_r537744019", "bodyText": "Why not just let them see their stats? My thought was if they disable stats it won't automatically display at the end of the match, but if they really want to see it, by all means let them.", "author": "Electroid", "createdAt": "2020-12-07T18:48:58Z", "path": "core/src/main/java/tc/oc/pgm/command/StatsCommand.java", "diffHunk": "@@ -21,21 +21,23 @@\n       aliases = {\"stats\"},\n       desc = \"Show your stats for the match\")\n   public void stats(Audience audience, CommandSender sender, MatchPlayer player, Match match) {\n+    if (player.getSettings().getValue(SettingKey.STATS).equals(SettingValue.STATS_ON)) {\n+      throw TextException.of(\"match.stats.disabled\");", "originalCommit": "4dfed4b717aab20d3d335b755fde210993de2d4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE0ODYzMw==", "url": "https://github.com/PGMDev/PGM/pull/729#discussion_r540148633", "bodyText": "That makes sense, ill remove this code from the command", "author": "KingOfSquares", "createdAt": "2020-12-10T12:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzc0NDAxOQ=="}], "type": "inlineReview"}, {"oid": "d7429d7a63acb72262f293cd2bf6496d045852ee", "url": "https://github.com/PGMDev/PGM/commit/d7429d7a63acb72262f293cd2bf6496d045852ee", "message": "Remove setting check from stat command\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-12-10T13:16:24Z", "type": "forcePushed"}, {"oid": "152ebff3eea7d2521032c52f93dfddd951a0aa5b", "url": "https://github.com/PGMDev/PGM/commit/152ebff3eea7d2521032c52f93dfddd951a0aa5b", "message": "Fix rebase issues\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2020-12-20T22:58:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjkwMDYyMg==", "url": "https://github.com/PGMDev/PGM/pull/729#discussion_r546900622", "bodyText": "We can't depend on this because it's nms. Use a WeakHashMap with Boolean values.", "author": "Electroid", "createdAt": "2020-12-21T19:54:14Z", "path": "util/src/main/java/tc/oc/pgm/util/menu/InventoryMenu.java", "diffHunk": "@@ -0,0 +1,315 @@\n+package tc.oc.pgm.util.menu;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static net.kyori.adventure.text.Component.translatable;\n+import static tc.oc.pgm.util.menu.InventoryMenuUtils.howManyRows;\n+\n+import com.google.common.collect.Lists;\n+import java.util.ArrayList;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+import net.kyori.adventure.text.Component;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Material;\n+import org.bukkit.World;\n+import org.bukkit.craftbukkit.v1_8_R3.util.WeakCollection;", "originalCommit": "152ebff3eea7d2521032c52f93dfddd951a0aa5b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bdf96bae32105afef25da94e490e04ead2a6cd35", "url": "https://github.com/PGMDev/PGM/commit/bdf96bae32105afef25da94e490e04ead2a6cd35", "message": "InventoryMenu refactor\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2021-01-04T23:20:18Z", "type": "commit"}, {"oid": "3e1708cafd85314635d93530786682e876f50472", "url": "https://github.com/PGMDev/PGM/commit/3e1708cafd85314635d93530786682e876f50472", "message": "Fix rebase issues\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2021-01-04T23:20:18Z", "type": "commit"}, {"oid": "cc87fb20c07731b13af6374198c6688b5fa2b450", "url": "https://github.com/PGMDev/PGM/commit/cc87fb20c07731b13af6374198c6688b5fa2b450", "message": "Simplify some menu building\n- fix some pagination issues\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2021-01-04T23:20:18Z", "type": "commit"}, {"oid": "591a70c8c251a6d321a8f3ea2a2723b42a733fe2", "url": "https://github.com/PGMDev/PGM/commit/591a70c8c251a6d321a8f3ea2a2723b42a733fe2", "message": "WeakCollection -> WeakHashmap\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2021-01-04T23:20:18Z", "type": "commit"}, {"oid": "591a70c8c251a6d321a8f3ea2a2723b42a733fe2", "url": "https://github.com/PGMDev/PGM/commit/591a70c8c251a6d321a8f3ea2a2723b42a733fe2", "message": "WeakCollection -> WeakHashmap\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2021-01-04T23:20:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzAwNDk5MQ==", "url": "https://github.com/PGMDev/PGM/pull/729#discussion_r557004991", "bodyText": "Why not just event.getPlayer() ?", "author": "Pablete1234", "createdAt": "2021-01-14T02:31:37Z", "path": "core/src/main/java/tc/oc/pgm/observers/ObserverToolsMatchModule.java", "diffHunk": "@@ -80,14 +83,14 @@ public void onToolClick(PlayerInteractEvent event) {\n       MatchPlayer player = match.getPlayer(event.getPlayer());\n \n       if (item.getType().equals(TOOL_MATERIAL) && player != null && canUse(player)) {\n-        this.toolItem.onInventoryClick(null, player, ClickType.RIGHT);\n+        this.toolItem.onInventoryClick(null, player.getBukkit(), ClickType.RIGHT);", "originalCommit": "591a70c8c251a6d321a8f3ea2a2723b42a733fe2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzAwNjA0Nw==", "url": "https://github.com/PGMDev/PGM/pull/729#discussion_r557006047", "bodyText": "Is there no simpler way to get an audience so you can call send warning? Kinda liked how most of the menu stuff no longer relies on MatchPlayer at all", "author": "Pablete1234", "createdAt": "2021-01-14T02:35:27Z", "path": "core/src/main/java/tc/oc/pgm/observers/tools/GamemodeTool.java", "diffHunk": "@@ -32,37 +33,37 @@ public ChatColor getColor() {\n   }\n \n   @Override\n-  public List<String> getLore(MatchPlayer player) {\n+  public List<String> getLore(Player player) {\n     Component gamemode =\n         translatable(\"gameMode.\" + player.getGameMode().name().toLowerCase(), NamedTextColor.AQUA);\n     Component lore = translatable(\"setting.gamemode.lore\", NamedTextColor.GRAY, gamemode);\n-    return Lists.newArrayList(TextTranslations.translateLegacy(lore, player.getBukkit()));\n+    return Lists.newArrayList(TextTranslations.translateLegacy(lore, player));\n   }\n \n   @Override\n-  public Material getMaterial(MatchPlayer player) {\n+  public Material getMaterial(Player player) {\n     return isCreative(player) ? Material.SEA_LANTERN : Material.PRISMARINE;\n   }\n \n   @Override\n-  public void onInventoryClick(InventoryMenu menu, MatchPlayer player, ClickType clickType) {\n+  public void onInventoryClick(InventoryMenu menu, Player player, ClickType clickType) {\n     toggleObserverGameMode(player);\n     menu.refreshWindow(player);\n   }\n \n-  public void toggleObserverGameMode(MatchPlayer player) {\n+  public void toggleObserverGameMode(Player player) {\n     player.setGameMode(getOppositeMode(player.getGameMode()));\n     if (player.getGameMode() == GameMode.SPECTATOR) {\n-      player.sendWarning(getToggleMessage());\n+      PGM.get().getMatchManager().getPlayer(player).sendWarning(getToggleMessage());", "originalCommit": "591a70c8c251a6d321a8f3ea2a2723b42a733fe2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzAwNjUyOQ==", "url": "https://github.com/PGMDev/PGM/pull/729#discussion_r557006529", "bodyText": "Should probably check for permission too here", "author": "Pablete1234", "createdAt": "2021-01-14T02:37:07Z", "path": "core/src/main/java/tc/oc/pgm/observers/tools/GamemodeTool.java", "diffHunk": "@@ -32,37 +33,37 @@ public ChatColor getColor() {\n   }\n \n   @Override\n-  public List<String> getLore(MatchPlayer player) {\n+  public List<String> getLore(Player player) {\n     Component gamemode =\n         translatable(\"gameMode.\" + player.getGameMode().name().toLowerCase(), NamedTextColor.AQUA);\n     Component lore = translatable(\"setting.gamemode.lore\", NamedTextColor.GRAY, gamemode);\n-    return Lists.newArrayList(TextTranslations.translateLegacy(lore, player.getBukkit()));\n+    return Lists.newArrayList(TextTranslations.translateLegacy(lore, player));\n   }\n \n   @Override\n-  public Material getMaterial(MatchPlayer player) {\n+  public Material getMaterial(Player player) {\n     return isCreative(player) ? Material.SEA_LANTERN : Material.PRISMARINE;\n   }\n \n   @Override\n-  public void onInventoryClick(InventoryMenu menu, MatchPlayer player, ClickType clickType) {\n+  public void onInventoryClick(InventoryMenu menu, Player player, ClickType clickType) {\n     toggleObserverGameMode(player);\n     menu.refreshWindow(player);\n   }\n \n-  public void toggleObserverGameMode(MatchPlayer player) {\n+  public void toggleObserverGameMode(Player player) {\n     player.setGameMode(getOppositeMode(player.getGameMode()));\n     if (player.getGameMode() == GameMode.SPECTATOR) {\n-      player.sendWarning(getToggleMessage());\n+      PGM.get().getMatchManager().getPlayer(player).sendWarning(getToggleMessage());\n     } else if (isCreative(player)) {\n       // Note: When WorldEdit is present, this executes a command to ensure the player is not stuck\n       if (Bukkit.getPluginManager().isPluginEnabled(\"WorldEdit\")) {", "originalCommit": "591a70c8c251a6d321a8f3ea2a2723b42a733fe2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzAxNTA0MQ==", "url": "https://github.com/PGMDev/PGM/pull/729#discussion_r557015041", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  List<InventoryMenuItem> currentPage = pages.get(i);\n          \n          \n            \n                  currentPage.add(null);\n          \n          \n            \n                  currentPage.add(null);\n          \n          \n            \n                  currentPage.add(\n          \n          \n            \n                      // Is there a previous page?\n          \n          \n            \n                      i == 0 ? null : new PageInventoryMenuItem(pages.get(i - 1), menuArranger, false));\n          \n          \n            \n                  currentPage.add(null);\n          \n          \n            \n                  currentPage.add(null);\n          \n          \n            \n                  currentPage.add(null);\n          \n          \n            \n                  currentPage.add(\n          \n          \n            \n                      // Is there a next page?\n          \n          \n            \n                      pages.size() - 1 == i\n          \n          \n            \n                          ? null\n          \n          \n            \n                          : new PageInventoryMenuItem(pages.get(i + 1), menuArranger, true));\n          \n          \n            \n                  currentPage.add(null);\n          \n          \n            \n                  currentPage.add(null);\n          \n          \n            \n                  List<InventoryMenuItem> currentPage = pages.get(i);\n          \n          \n            \n                  for (int item = 0; item < ROW_WIDTH; item++) currentPage.add(null);\n          \n          \n            \n                  if (i > 0) currentPage.set(2, new PageInventoryMenuItem(pages.get(i - 1), menuArranger, false));\n          \n          \n            \n                  if (i < pages.size() - 1) currentPage.set(6, new PageInventoryMenuItem(pages.get(i - 1), menuArranger, false));\n          \n      \n    \n    \n  \n\nYou can simply add 9 items on a loop and then set the 2 overrides for previous/next pages, adding so many currentPage.add(null) is a bit dirty", "author": "Pablete1234", "createdAt": "2021-01-14T03:07:13Z", "path": "util/src/main/java/tc/oc/pgm/util/menu/InventoryMenu.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package tc.oc.pgm.util.menu;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static net.kyori.adventure.text.Component.translatable;\n+import static tc.oc.pgm.util.menu.InventoryMenuUtils.howManyRows;\n+\n+import com.google.common.collect.Lists;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.WeakHashMap;\n+import javax.annotation.Nullable;\n+import net.kyori.adventure.text.Component;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.Material;\n+import org.bukkit.World;\n+import org.bukkit.entity.Player;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.HandlerList;\n+import org.bukkit.event.Listener;\n+import org.bukkit.event.inventory.ClickType;\n+import org.bukkit.event.inventory.InventoryClickEvent;\n+import org.bukkit.event.inventory.InventoryCloseEvent;\n+import org.bukkit.event.world.WorldUnloadEvent;\n+import org.bukkit.inventory.Inventory;\n+import org.bukkit.inventory.ItemFlag;\n+import org.bukkit.inventory.ItemStack;\n+import org.bukkit.inventory.meta.ItemMeta;\n+import tc.oc.pgm.util.StringUtils;\n+import tc.oc.pgm.util.bukkit.BukkitUtils;\n+import tc.oc.pgm.util.menu.pattern.MenuArranger;\n+import tc.oc.pgm.util.text.TextTranslations;\n+\n+/**\n+ * A way to make a GUI menu that users can interact with.\n+ *\n+ * <p>The {@link MenuArranger} is what decides whether a menu will be paginated, and how the items\n+ * will be scattered throughout the GUI. This means any list passed in the constructor of an {@link\n+ * InventoryMenu} should only have <b>non-{@code null}</b> elements.\n+ *\n+ * <p>Whenever an item in this inventory is clicked it will automatically call the items {@code\n+ * onInventoryClick} method. If that (or any) method changes something in the GUI {@link\n+ * #refreshWindow(Player)} or {@link #refreshAll()} should be called to rebuild the GUI for the\n+ * relevant players.\n+ */\n+public class InventoryMenu implements Listener {\n+\n+  protected static final int ROW_WIDTH = 9; // Number of columns per row\n+  protected static final int MAX_ROWS = 6; // Max allowed row size\n+\n+  private final List<InventoryMenuItem> inventoryMenuItems;\n+\n+  private final WeakHashMap<Player, Boolean> viewing = new WeakHashMap<>();\n+\n+  private final Component title; // Title of the inventory\n+  private int rows; // The # of rows in the inventory\n+  private final World world; // The world this inventory exists in;\n+\n+  /**\n+   * InventoryMenu: An easy way to make an GUI menu that users can interact with.\n+   *\n+   * <p>Note: Code here was initially extracted from PickerMatchModule to allow for reuse\n+   *\n+   * @param world - The world this inventory should exist it\n+   * @param title - the inventory title\n+   * @param items - The items this inventory will contain, null counts as spaces\n+   * @param menuArranger arranges the items in different ways while also assisting pagination, is\n+   *     null when called by page items\n+   * @param rows - The maximum amount of rows the menu can have\n+   * @param pagesPossible internal boolean used to prevent infinite pages\n+   */\n+  private InventoryMenu(\n+      World world,\n+      Component title,\n+      List<InventoryMenuItem> items,\n+      @Nullable MenuArranger menuArranger,\n+      int rows,\n+      boolean pagesPossible) {\n+    this.title = title;\n+    this.rows = rows;\n+    this.inventoryMenuItems = applyPatternAndAddPages(items, menuArranger, pagesPossible);\n+    // This argument check needs to be under the applyPattern call because it can increase the row\n+    // number(pagination)\n+    checkArgument(rows > 0 && rows <= MAX_ROWS, \"Row size must be between 1 and \" + MAX_ROWS);\n+    this.world = world;\n+    enableInventory();\n+  }\n+\n+  public InventoryMenu(\n+      World world,\n+      Component title,\n+      List<InventoryMenuItem> items,\n+      MenuArranger menuArranger,\n+      int rows) {\n+    this(world, title, items, menuArranger, rows, true);\n+  }\n+\n+  public InventoryMenu(\n+      World world, Component title, List<InventoryMenuItem> items, MenuArranger menuArranger) {\n+    this(world, title, items, menuArranger, menuArranger.rows(), true);\n+  }\n+\n+  private InventoryMenu(World world, Component title, List<InventoryMenuItem> items) {\n+    this(world, title, items, null, howManyRows(items), false);\n+  }\n+\n+  public ItemStack[] createWindowContents(final Player player) {\n+    List<ItemStack> items = Lists.newArrayList();\n+    for (InventoryMenuItem item : this.inventoryMenuItems) {\n+      if (item == null) items.add(null);\n+      else items.add(item.createItem(player));\n+    }\n+\n+    return items.toArray(new ItemStack[0]);\n+  }\n+\n+  public String getTranslatedTitle(Player player) {\n+    return TextTranslations.translateLegacy(title, player);\n+  }\n+\n+  public boolean isViewing(Player player) {\n+    return viewing.containsKey(player);\n+  }\n+\n+  public void display(Player player) {\n+    this.showWindow(player);\n+    this.viewing.put(player, true);\n+  }\n+\n+  public boolean remove(Player player) {\n+    return this.viewing.remove(player);\n+  }\n+\n+  public void refreshAll() {\n+    viewing.keySet().forEach(this::refreshWindow);\n+  }\n+\n+  private int getInventorySize() {\n+    return ROW_WIDTH * rows;\n+  }\n+\n+  /**\n+   * Open the window for the given player, or refresh its contents if they already have it open, and\n+   * return the current contents.\n+   *\n+   * <p>If the window is currently open but too small to hold the current contents, it will be\n+   * closed and reopened.\n+   *\n+   * <p>If the player is not currently allowed to have the window open, close any window they have\n+   * open and return null.\n+   */\n+  private Inventory showWindow(Player player) {\n+    ItemStack[] contents = createWindowContents(player);\n+    Inventory inv = getOpenWindow(player);\n+    if (inv != null && inv.getSize() < contents.length) {\n+      inv = null;\n+      closeWindow(player);\n+    }\n+    if (inv == null) {\n+      inv = openWindow(player, contents);\n+    } else {\n+      inv.setContents(contents);\n+    }\n+    return inv;\n+  }\n+\n+  /**\n+   * If the given player currently has the window open, refresh its contents and return the updated\n+   * inventory. The window will be closed and reopened if it is too small to hold the current\n+   * contents.\n+   *\n+   * <p>If the window is open but should be closed, close it and return null.\n+   *\n+   * <p>If the player does not have the window open, return null.\n+   */\n+  public @Nullable Inventory refreshWindow(Player player) {\n+    Inventory inv = getOpenWindow(player);\n+    if (inv != null) {\n+      ItemStack[] contents = createWindowContents(player);\n+      if (inv.getSize() < contents.length) {\n+        closeWindow(player);\n+        inv = openWindow(player, contents);\n+      } else {\n+        inv.setContents(contents);\n+      }\n+    }\n+    return inv;\n+  }\n+\n+  /**\n+   * Return the inventory of the given player's currently open window, or null if the player does\n+   * not have the window open.\n+   */\n+  private @Nullable Inventory getOpenWindow(Player player) {\n+    if (isViewing(player)) {\n+      return player.getOpenInventory().getTopInventory();\n+    }\n+    return null;\n+  }\n+\n+  /** Close any window that is currently open for the given player */\n+  private void closeWindow(Player player) {\n+    if (isViewing(player)) {\n+      player.closeInventory();\n+    }\n+  }\n+\n+  /** Open a new window for the given player displaying the given contents */\n+  private Inventory openWindow(Player player, ItemStack[] contents) {\n+    closeWindow(player);\n+    Inventory inv =\n+        Bukkit.createInventory(\n+            player, getInventorySize(), StringUtils.truncate(getTranslatedTitle(player), 32));\n+\n+    inv.setContents(contents);\n+    player.openInventory(inv);\n+    viewing.put(player, true);\n+    return inv;\n+  }\n+\n+  @EventHandler\n+  public void onInventoryClick(final InventoryClickEvent event) {\n+    if (inventoryMenuItems == null\n+        || this.world != event.getWorld()\n+        || event.getCurrentItem() == null\n+        || event.getCurrentItem().getItemMeta() == null\n+        || event.getCurrentItem().getItemMeta().getDisplayName() == null) return;\n+\n+    if (event.getWhoClicked() instanceof Player) {\n+      Player player = ((Player) event.getWhoClicked());\n+      if (isViewing(player)) {\n+        ItemStack clicked = event.getCurrentItem();\n+        for (InventoryMenuItem item : this.inventoryMenuItems) {\n+          if (item == null) continue;\n+\n+          if (clicked.equals(item.createItem(player))) {\n+            item.onInventoryClick(this, player, event.getClick());\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onInventoryClose(final InventoryCloseEvent event) {\n+    // Remove viewing of menu upon inventory close\n+    Player player = (Player) event.getPlayer();\n+    this.remove(player);\n+  }\n+\n+  @EventHandler\n+  public void onWorldUnload(WorldUnloadEvent event) {\n+    if (this.world != event.getWorld()) return;\n+    disableInventory();\n+  }\n+\n+  public void disableInventory() {\n+    viewing.keySet().forEach(this::closeWindow);\n+    viewing.clear();\n+    HandlerList.unregisterAll(this);\n+  }\n+\n+  public void enableInventory() {\n+    Bukkit.getPluginManager().registerEvents(this, BukkitUtils.getPlugin());\n+  }\n+\n+  private List<InventoryMenuItem> applyPatternAndAddPages(\n+      List<InventoryMenuItem> items, MenuArranger menuArranger, boolean pagesPossible) {\n+\n+    List<InventoryMenuItem> mutableItems = new ArrayList<>(items);\n+    if (!pagesPossible) return items;\n+\n+    // Quick exit if we dont need any pages\n+    if (menuArranger.automatedPaginationLimit() > mutableItems.size())\n+      return menuArranger.arrangeItems(mutableItems);\n+\n+    // We need pages!!\n+    rows++;\n+\n+    List<List<InventoryMenuItem>> pages = new ArrayList<>();\n+\n+    // Put items into pages\n+    List<InventoryMenuItem> page = new ArrayList<>();\n+    for (int i = 0; !mutableItems.isEmpty(); i++) {\n+      page.add(mutableItems.remove(0));\n+      if (i + 1 == menuArranger.automatedPaginationLimit() || mutableItems.isEmpty()) { // new page\n+        pages.add(new ArrayList<>(menuArranger.arrangeItems(page)));\n+        page.clear();\n+        i = 0;\n+      }\n+    }\n+\n+    // Insert pagination items on every page\n+    for (int i = 0; i < pages.size(); i++) {\n+      List<InventoryMenuItem> currentPage = pages.get(i);\n+      currentPage.add(null);\n+      currentPage.add(null);\n+      currentPage.add(\n+          // Is there a previous page?\n+          i == 0 ? null : new PageInventoryMenuItem(pages.get(i - 1), menuArranger, false));\n+      currentPage.add(null);\n+      currentPage.add(null);\n+      currentPage.add(null);\n+      currentPage.add(\n+          // Is there a next page?\n+          pages.size() - 1 == i\n+              ? null\n+              : new PageInventoryMenuItem(pages.get(i + 1), menuArranger, true));\n+      currentPage.add(null);\n+      currentPage.add(null);", "originalCommit": "591a70c8c251a6d321a8f3ea2a2723b42a733fe2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "be376edce8213a0ccffc899ba80ba8458419017a", "url": "https://github.com/PGMDev/PGM/commit/be376edce8213a0ccffc899ba80ba8458419017a", "message": "Apply feedback from code review\n- Also remove onInventoryClose listener\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2021-01-14T15:58:16Z", "type": "commit"}, {"oid": "23fe2da63005bcda86e98ea3109f62cc97cd167b", "url": "https://github.com/PGMDev/PGM/commit/23fe2da63005bcda86e98ea3109f62cc97cd167b", "message": "Remove getColor from InventoryMenuItem\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2021-01-14T21:09:18Z", "type": "commit"}, {"oid": "c33780ef342f988017adfe7d0d139a375437d89f", "url": "https://github.com/PGMDev/PGM/commit/c33780ef342f988017adfe7d0d139a375437d89f", "message": "Remove duplicate code\n\nSigned-off-by: KingSimon <19822231+KingOfSquares@users.noreply.github.com>", "committedDate": "2021-01-14T21:17:36Z", "type": "commit"}]}