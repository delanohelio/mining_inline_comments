{"pr_number": 338, "pr_title": "Match Stats", "pr_createdAt": "2020-02-27T14:25:31Z", "pr_url": "https://github.com/PGMDev/PGM/pull/338", "timeline": [{"oid": "94f5e09ac6763ad49f80780f8125dec2cc56da7d", "url": "https://github.com/PGMDev/PGM/commit/94f5e09ac6763ad49f80780f8125dec2cc56da7d", "message": "Remove unneeded abstraction\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>", "committedDate": "2020-02-27T20:59:11Z", "type": "forcePushed"}, {"oid": "6cd5c8972575269d5c170e49c8df6b1f643081d9", "url": "https://github.com/PGMDev/PGM/commit/6cd5c8972575269d5c170e49c8df6b1f643081d9", "message": "Formatting\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>", "committedDate": "2020-03-01T20:53:51Z", "type": "forcePushed"}, {"oid": "bf2758441dd907ba88439d52dd1ae7e949ec8538", "url": "https://github.com/PGMDev/PGM/commit/bf2758441dd907ba88439d52dd1ae7e949ec8538", "message": "Add match stats\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>", "committedDate": "2020-03-05T19:20:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjYwNg==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388536606", "bodyText": "Why this change?", "author": "TheMolkaPL", "createdAt": "2020-03-05T20:11:48Z", "path": "core/src/main/java/tc/oc/pgm/PGMPlugin.java", "diffHunk": "@@ -40,23 +40,7 @@\n import tc.oc.pgm.api.player.MatchPlayer;\n import tc.oc.pgm.api.setting.SettingKey;\n import tc.oc.pgm.api.setting.SettingValue;\n-import tc.oc.pgm.commands.AdminCommands;\n-import tc.oc.pgm.commands.ClassCommands;\n-import tc.oc.pgm.commands.CycleCommands;\n-import tc.oc.pgm.commands.DestroyableCommands;\n-import tc.oc.pgm.commands.FreeForAllCommands;\n-import tc.oc.pgm.commands.GoalCommands;\n-import tc.oc.pgm.commands.InventoryCommands;\n-import tc.oc.pgm.commands.JoinCommands;\n-import tc.oc.pgm.commands.MapCommands;\n-import tc.oc.pgm.commands.MapPoolCommands;\n-import tc.oc.pgm.commands.MatchCommands;\n-import tc.oc.pgm.commands.ModeCommands;\n-import tc.oc.pgm.commands.ObserverCommands;\n-import tc.oc.pgm.commands.SettingCommands;\n-import tc.oc.pgm.commands.StartCommands;\n-import tc.oc.pgm.commands.TeamCommands;\n-import tc.oc.pgm.commands.TimeLimitCommands;\n+import tc.oc.pgm.commands.*;", "originalCommit": "bf2758441dd907ba88439d52dd1ae7e949ec8538", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk3NzA0Ng==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388977046", "bodyText": "It was either my IDE or Maven formatting, any issues with doing this?", "author": "KingOfSquares", "createdAt": "2020-03-06T15:42:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjYwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4NjA4Mw==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389086083", "bodyText": "It's just unnecessary :P", "author": "TheMolkaPL", "createdAt": "2020-03-06T19:03:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjYwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExOTQ0OQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389119449", "bodyText": "It looks nicer? I can undo it", "author": "KingOfSquares", "createdAt": "2020-03-06T20:08:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjYwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI2MjAyMw==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389262023", "bodyText": "Do i really have to? I dont see the point of filling up the import list when you are going to register all commands and match modules anyways :p", "author": "KingOfSquares", "createdAt": "2020-03-07T15:27:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjYwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI4MjIwNQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389282205", "bodyText": "You don't have to. I'm always trying to keep local code standards and change only what's necessary. :P", "author": "TheMolkaPL", "createdAt": "2020-03-07T17:13:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjYwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMTk4Mw==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389301983", "bodyText": "You should avoid wildcard imports, they're bad", "author": "Pablete1234", "createdAt": "2020-03-07T18:25:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjczNQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388536735", "bodyText": "Why this change?", "author": "TheMolkaPL", "createdAt": "2020-03-05T20:12:00Z", "path": "core/src/main/java/tc/oc/pgm/api/Modules.java", "diffHunk": "@@ -56,33 +56,7 @@\n import tc.oc.pgm.kits.KitModule;\n import tc.oc.pgm.modes.ObjectiveModesMatchModule;\n import tc.oc.pgm.modes.ObjectiveModesModule;\n-import tc.oc.pgm.modules.ArrowRemovalMatchModule;\n-import tc.oc.pgm.modules.DiscardPotionBottlesMatchModule;\n-import tc.oc.pgm.modules.DiscardPotionBottlesModule;\n-import tc.oc.pgm.modules.EventFilterMatchModule;\n-import tc.oc.pgm.modules.FriendlyFireRefundMatchModule;\n-import tc.oc.pgm.modules.FriendlyFireRefundModule;\n-import tc.oc.pgm.modules.InternalMatchModule;\n-import tc.oc.pgm.modules.InternalModule;\n-import tc.oc.pgm.modules.ItemDestroyMatchModule;\n-import tc.oc.pgm.modules.ItemDestroyModule;\n-import tc.oc.pgm.modules.ItemKeepMatchModule;\n-import tc.oc.pgm.modules.ItemKeepModule;\n-import tc.oc.pgm.modules.LaneMatchModule;\n-import tc.oc.pgm.modules.LaneModule;\n-import tc.oc.pgm.modules.MaxBuildHeightMatchModule;\n-import tc.oc.pgm.modules.MaxBuildHeightModule;\n-import tc.oc.pgm.modules.MobsMatchModule;\n-import tc.oc.pgm.modules.MobsModule;\n-import tc.oc.pgm.modules.ModifyBowProjectileMatchModule;\n-import tc.oc.pgm.modules.ModifyBowProjectileModule;\n-import tc.oc.pgm.modules.MultiTradeMatchModule;\n-import tc.oc.pgm.modules.PlayableRegionMatchModule;\n-import tc.oc.pgm.modules.PlayableRegionModule;\n-import tc.oc.pgm.modules.SoundsMatchModule;\n-import tc.oc.pgm.modules.TimeLockModule;\n-import tc.oc.pgm.modules.ToolRepairMatchModule;\n-import tc.oc.pgm.modules.ToolRepairModule;\n+import tc.oc.pgm.modules.*;", "originalCommit": "bf2758441dd907ba88439d52dd1ae7e949ec8538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjg5MA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388536890", "bodyText": "Should be placed inside the translations file.", "author": "TheMolkaPL", "createdAt": "2020-03-05T20:12:21Z", "path": "core/src/main/java/tc/oc/pgm/commands/StatCommands.java", "diffHunk": "@@ -0,0 +1,23 @@\n+package tc.oc.pgm.commands;\n+\n+import app.ashcon.intake.Command;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.command.CommandSender;\n+import tc.oc.pgm.modules.StatsMatchModule;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+\n+public class StatCommands {\n+\n+  @Command(\n+      aliases = {\"stats\"},\n+      desc = \"Shows your stats for this match\")\n+  public static void checkStats(CommandSender sender) {\n+    sender.sendMessage(\n+        ComponentUtils.horizontalLineHeading(\n+            ChatColor.DARK_GREEN + \"Current stats\",", "originalCommit": "bf2758441dd907ba88439d52dd1ae7e949ec8538", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODk3NzI5Mw==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388977293", "bodyText": "Of course! Great catch", "author": "KingOfSquares", "createdAt": "2020-03-06T15:42:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjg5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNjk4MQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388536981", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public static class playerStats {\n          \n          \n            \n              public static class PlayerStats {", "author": "TheMolkaPL", "createdAt": "2020-03-05T20:12:34Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {", "originalCommit": "bf2758441dd907ba88439d52dd1ae7e949ec8538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNzQ4NQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388537485", "bodyText": "You don't have to define zeros in each :P Keep it simple :P", "author": "TheMolkaPL", "createdAt": "2020-03-05T20:13:25Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;", "originalCommit": "bf2758441dd907ba88439d52dd1ae7e949ec8538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzNzc5Ng==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388537796", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  String KD;\n          \n          \n            \n                  String kd;", "author": "TheMolkaPL", "createdAt": "2020-03-05T20:14:04Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;", "originalCommit": "bf2758441dd907ba88439d52dd1ae7e949ec8538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzODU1MA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388538550", "bodyText": "Can we change it to a constant in this class? Also, call it decimalFormat because df is very cryptic.", "author": "TheMolkaPL", "createdAt": "2020-03-05T20:15:36Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");", "originalCommit": "bf2758441dd907ba88439d52dd1ae7e949ec8538", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3Mjk2MQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388572961", "bodyText": "when you have df.format(number); it being called df isn't very cryptic tbh", "author": "Pablete1234", "createdAt": "2020-03-05T21:21:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzODU1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTAzOTAyNg==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389039026", "bodyText": "Can we change it to a constant in this class? Also, call it decimalFormat because df is very cryptic.\n\nWhat do you mean change it to a constant, the K/D variable?", "author": "KingOfSquares", "createdAt": "2020-03-06T17:26:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzODU1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4NzUyMA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389087520", "bodyText": "Make DecimalFormat a constant so it is not created each time it is used. Look that this is going to parse your input string (#.##) each time to create a new DecimalFormat instance.", "author": "TheMolkaPL", "createdAt": "2020-03-06T19:06:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzODU1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExNzQ2OQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389117469", "bodyText": "Yes of course!", "author": "KingOfSquares", "createdAt": "2020-03-06T20:04:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzODU1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388539013", "bodyText": "Please make it private.", "author": "TheMolkaPL", "createdAt": "2020-03-05T20:16:30Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;", "originalCommit": "bf2758441dd907ba88439d52dd1ae7e949ec8538", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTk4NQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388539985", "bodyText": "Also, I would persist player UUIDs, not player names since UUIDs are unique by definition.", "author": "TheMolkaPL", "createdAt": "2020-03-05T20:18:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0MDQ5Mg==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389040492", "bodyText": "But when i enter in player#getBukkit#getDisplayName it keeps the colors and everything when displaying the best, does this also work with UUID? I only see a potential error if players use /nick, but it should be prevented to disguise as someone existing anyways.", "author": "KingOfSquares", "createdAt": "2020-03-06T17:29:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA0Nzk4OA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389047988", "bodyText": "And why private? It is accessed by StatCommands", "author": "KingOfSquares", "createdAt": "2020-03-06T17:43:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA4ODk3Ng==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389088976", "bodyText": "But when i enter in player#getBukkit#getDisplayName it keeps the colors and everything when displaying the best, does this also work with UUID? I only see a potential error if players use /nick, but it should be prevented to disguise as someone existing anyways.\n\nPlayer names are not unique so you shouldn't use them as a key anywhere.\n\nAnd why private? It is accessed by StatCommands\n\nhttps://dzone.com/articles/following-oop-principles-hermetization-in-java", "author": "TheMolkaPL", "createdAt": "2020-03-06T19:09:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4NTg1NA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389185854", "bodyText": "Will this: match#getPlayer(UUID)#getBukkit()#getDisplayName() return null if the player with the given UUID is offline?", "author": "KingOfSquares", "createdAt": "2020-03-06T23:04:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMjMwNw==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389212307", "bodyText": "Yes", "author": "TheMolkaPL", "createdAt": "2020-03-07T01:19:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI0Nzc4Nw==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389247787", "bodyText": "Then how would i get the playername of a player that has the best results but is offline?", "author": "KingOfSquares", "createdAt": "2020-03-07T11:23:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI1NTQ0OA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389255448", "bodyText": "You need to store that in PlayerStats then.", "author": "TheMolkaPL", "createdAt": "2020-03-07T13:41:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI2MTg5OA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389261898", "bodyText": "I got it!!", "author": "KingOfSquares", "createdAt": "2020-03-07T15:25:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMTkzNA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389301934", "bodyText": "Authors are not online but their name is displayed. The player names can be resolved from their UUID, and should be stored in a cache anyways. It's not stats' responsability to know playernames", "author": "Pablete1234", "createdAt": "2020-03-07T18:24:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTAxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUzOTQ1Mw==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388539453", "bodyText": "You shouldn't be catching NPEs :D If something returns null please check it with the if statements", "author": "TheMolkaPL", "createdAt": "2020-03-05T20:17:25Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }", "originalCommit": "bf2758441dd907ba88439d52dd1ae7e949ec8538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0MDY4MA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388540680", "bodyText": "I see your are using murderer.getBukkit().getName() and event.getVictim().getBukkit().getName() in this method. Can you make local variables in this method to make the code cleaner?", "author": "TheMolkaPL", "createdAt": "2020-03-05T20:19:24Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());", "originalCommit": "bf2758441dd907ba88439d52dd1ae7e949ec8538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0MTA4MA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388541080", "bodyText": "You should change the name and display name to local variables here too.", "author": "TheMolkaPL", "createdAt": "2020-03-05T20:20:08Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      }\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+        murdererStats.onMurder();\n+        NMSHacks.sendHotbarMessage(\n+            murderer.getBukkit().getPlayer(), murdererStats.getBasicStatsMessage());\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    HashMap<String, Integer> allKills = new HashMap<>();\n+    HashMap<String, Integer> allKillstreaks = new HashMap<>();\n+    HashMap<String, Integer> allDeaths = new HashMap<>();\n+    HashMap<String, Integer> allBowshots = new HashMap<>();\n+    for (MatchPlayer player : match.getPlayers()) {\n+      allKills.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).kills);\n+      allKillstreaks.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).killstreakMax);\n+      allDeaths.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).deaths);\n+      allBowshots.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).longestBowKill);", "originalCommit": "bf2758441dd907ba88439d52dd1ae7e949ec8538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0MTU4Ng==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388541586", "bodyText": "Missing newline character.", "author": "TheMolkaPL", "createdAt": "2020-03-05T20:21:03Z", "path": "util-bukkit/src/main/i18n/templates/strings.properties", "diffHunk": "@@ -944,3 +944,13 @@ moderation.reports.hover = Reported by {0}\n # {0} = IP address\n moderation.commands.banIP = The IP address ({0}) has been banned.\n moderation.commands.invalidIP = {0} is not a valid IP address.\n+\n+# {X} = The number of the relevant stat\n+stats.basic = Kills: {0}(Killstreak: {1}), Deaths: {2}, K/D: {3}\n+\n+# {0} = Username\n+# {1} = The number of the relevant stat\n+stats.kills = Kills: {0} : {1}\n+stats.killstreak = Killstreak: {0} : {1}\n+stats.deaths = Deaths: {0} : {1}\n+stats.bowshot = Longest bowshot: {0} : {1} block(s)", "originalCommit": "bf2758441dd907ba88439d52dd1ae7e949ec8538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0MjMzMw==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388542333", "bodyText": "I think we should make a class representing Map.Entry<String, Integer> topResult.", "author": "TheMolkaPL", "createdAt": "2020-03-05T20:22:01Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      }\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+        murdererStats.onMurder();\n+        NMSHacks.sendHotbarMessage(\n+            murderer.getBukkit().getPlayer(), murdererStats.getBasicStatsMessage());\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    HashMap<String, Integer> allKills = new HashMap<>();\n+    HashMap<String, Integer> allKillstreaks = new HashMap<>();\n+    HashMap<String, Integer> allDeaths = new HashMap<>();\n+    HashMap<String, Integer> allBowshots = new HashMap<>();\n+    for (MatchPlayer player : match.getPlayers()) {\n+      allKills.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).kills);\n+      allKillstreaks.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).killstreakMax);\n+      allDeaths.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).deaths);\n+      allBowshots.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).longestBowKill);\n+    }\n+    Component killMessage = getKillsMessage(sortStats(allKills));\n+    Component killstreakMessage = getKillstreakMessage(sortStats(allKillstreaks));\n+    Component deathMessage = getDeathsMessage(sortStats(allDeaths));\n+    Map.Entry<String, Integer> bestBowshot = sortStats(allBowshots);\n+    Component bowshotMessage = getBowshotMessage(bestBowshot);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW + \"Best stats this match\",\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.getValue()\n+          != 0) { // Prevent this from showing if bows are not used on the map played\n+        viewer.sendMessage(bowshotMessage);\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private Map.Entry<String, Integer> sortStats(HashMap<String, Integer> map) {\n+    Object[] a = map.entrySet().toArray();\n+    Arrays.sort(\n+        a,\n+        (Comparator)\n+            (o1, o2) ->\n+                ((Map.Entry<String, Integer>) o2)\n+                    .getValue()\n+                    .compareTo(((Map.Entry<String, Integer>) o1).getValue()));\n+    return (Map.Entry<String, Integer>) a[0];\n+  }\n+\n+  Component getKillsMessage(Map.Entry<String, Integer> topResult) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.kills\",\n+                new PersonalizedText(topResult.getKey()),\n+                new PersonalizedText(Integer.toString(topResult.getValue()), ChatColor.GREEN))\n+            .render());\n+  }\n+\n+  Component getKillstreakMessage(Map.Entry<String, Integer> topResult) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.killstreak\",\n+                new PersonalizedText(topResult.getKey()),\n+                new PersonalizedText(Integer.toString(topResult.getValue()), ChatColor.GREEN))\n+            .render());\n+  }\n+\n+  Component getDeathsMessage(Map.Entry<String, Integer> topResult) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.deaths\",\n+                new PersonalizedText(topResult.getKey()),\n+                new PersonalizedText(Integer.toString(topResult.getValue()), ChatColor.RED))\n+            .render());\n+  }\n+\n+  Component getBowshotMessage(Map.Entry<String, Integer> topResult) {", "originalCommit": "bf2758441dd907ba88439d52dd1ae7e949ec8538", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3ODMwMg==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388578302", "bodyText": "A Record here would be amazing, too bad we're on java 8 and not 14 \ud83d\ude22", "author": "Pablete1234", "createdAt": "2020-03-05T21:32:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0MjMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExOTAwMg==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389119002", "bodyText": "What do you mean Molka? Represent topResult as class in which way?", "author": "KingOfSquares", "createdAt": "2020-03-06T20:07:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0MjMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMjI2Mw==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389212263", "bodyText": "Make a class with two fields, String and int. A dedicated class with named fields is easier to understand than Map.Entry.", "author": "TheMolkaPL", "createdAt": "2020-03-07T01:18:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0MjMzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTI2MTg2Mg==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389261862", "bodyText": "This should be resolved in coming update, thanks :)", "author": "KingOfSquares", "createdAt": "2020-03-07T15:25:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0MjMzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3NjQ3NA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388576474", "bodyText": "Make this a repeating task, send the message for a second or so or else it fades away too quick", "author": "Pablete1234", "createdAt": "2020-03-05T21:29:01Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });", "originalCommit": "bf2758441dd907ba88439d52dd1ae7e949ec8538", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE3NjMzNA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389176334", "bodyText": "How do i make it repeat? I tried #runTaskTimer with a delay of 0 and interval of 5, but that looked like a infinite thing, right?", "author": "KingOfSquares", "createdAt": "2020-03-06T22:33:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3NjQ3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMwMjA0MA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389302040", "bodyText": "i'm not sure with the scheduler. I know bukkit has it's own runRepeatingTask but idk why the match scheduler would not expose it", "author": "Pablete1234", "createdAt": "2020-03-07T18:26:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3NjQ3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMxMzM3NA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389313374", "bodyText": "Yeah that is exposed with the scheduler through runTaskTimer But that is neverending! How do i stop it o_o", "author": "KingOfSquares", "createdAt": "2020-03-07T21:27:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3NjQ3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMyMTc5Mg==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389321792", "bodyText": "It returns an int for the task id. you can cancel task by it's id", "author": "Pablete1234", "createdAt": "2020-03-08T00:00:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3NjQ3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1Mjk4NQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389352985", "bodyText": "Yeah, but i have to cancel the task through Bukkit#getScheduler#cancelTask\nMatch#getScheduler(MatchScope.LOADED)#cancelTask does not exist.", "author": "KingOfSquares", "createdAt": "2020-03-08T09:49:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3NjQ3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM1MzA0Mg==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389353042", "bodyText": "And the normal runTaskTimer does not return an int, you have to do #getTaskId it seems", "author": "KingOfSquares", "createdAt": "2020-03-08T09:50:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3NjQ3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3Njg3OQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388576879", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                HashMap<String, Integer> allKills = new HashMap<>();\n          \n          \n            \n                HashMap<String, Integer> allKillstreaks = new HashMap<>();\n          \n          \n            \n                HashMap<String, Integer> allDeaths = new HashMap<>();\n          \n          \n            \n                HashMap<String, Integer> allBowshots = new HashMap<>();\n          \n          \n            \n                Map<String, Integer> allKills = new HashMap<>();\n          \n          \n            \n                Map<String, Integer> allKillstreaks = new HashMap<>();\n          \n          \n            \n                Map<String, Integer> allDeaths = new HashMap<>();\n          \n          \n            \n                Map<String, Integer> allBowshots = new HashMap<>();", "author": "Pablete1234", "createdAt": "2020-03-05T21:29:51Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      }\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+        murdererStats.onMurder();\n+        NMSHacks.sendHotbarMessage(\n+            murderer.getBukkit().getPlayer(), murdererStats.getBasicStatsMessage());\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    HashMap<String, Integer> allKills = new HashMap<>();\n+    HashMap<String, Integer> allKillstreaks = new HashMap<>();\n+    HashMap<String, Integer> allDeaths = new HashMap<>();\n+    HashMap<String, Integer> allBowshots = new HashMap<>();", "originalCommit": "bf2758441dd907ba88439d52dd1ae7e949ec8538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3NzA2NQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388577065", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private Map.Entry<String, Integer> sortStats(HashMap<String, Integer> map) {\n          \n          \n            \n              private Map.Entry<String, Integer> sortStats(Map<String, Integer> map) {", "author": "Pablete1234", "createdAt": "2020-03-05T21:30:09Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      }\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+        murdererStats.onMurder();\n+        NMSHacks.sendHotbarMessage(\n+            murderer.getBukkit().getPlayer(), murdererStats.getBasicStatsMessage());\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    HashMap<String, Integer> allKills = new HashMap<>();\n+    HashMap<String, Integer> allKillstreaks = new HashMap<>();\n+    HashMap<String, Integer> allDeaths = new HashMap<>();\n+    HashMap<String, Integer> allBowshots = new HashMap<>();\n+    for (MatchPlayer player : match.getPlayers()) {\n+      allKills.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).kills);\n+      allKillstreaks.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).killstreakMax);\n+      allDeaths.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).deaths);\n+      allBowshots.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).longestBowKill);\n+    }\n+    Component killMessage = getKillsMessage(sortStats(allKills));\n+    Component killstreakMessage = getKillstreakMessage(sortStats(allKillstreaks));\n+    Component deathMessage = getDeathsMessage(sortStats(allDeaths));\n+    Map.Entry<String, Integer> bestBowshot = sortStats(allBowshots);\n+    Component bowshotMessage = getBowshotMessage(bestBowshot);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW + \"Best stats this match\",\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.getValue()\n+          != 0) { // Prevent this from showing if bows are not used on the map played\n+        viewer.sendMessage(bowshotMessage);\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private Map.Entry<String, Integer> sortStats(HashMap<String, Integer> map) {", "originalCommit": "bf2758441dd907ba88439d52dd1ae7e949ec8538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3Nzg5NQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r388577895", "bodyText": "Something along the lines of:\nreturn map.entrySet().stream()\n  .max(Comparator.comparingInt(Map.Entry::getValue))\n  .orElse(null);", "author": "Pablete1234", "createdAt": "2020-03-05T21:31:49Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,233 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class playerStats {\n+    private int kills = 0;\n+    private int deaths = 0;\n+    private int killstreak = 0;\n+    private int killstreakMax = 0;\n+    private int longestBowKill = 0;\n+\n+    public void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    public void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    public void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(new DecimalFormat(\"#\").format(Math.round(distance)));\n+      }\n+    }\n+\n+    public Component getBasicStatsMessage() {\n+      String KD;\n+      if (deaths == 0) {\n+        KD = \"0\";\n+      } else {\n+        DecimalFormat df = new DecimalFormat(\"#.##\");\n+        KD = df.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(KD, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  public static Map<String, playerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    try {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    } catch (NullPointerException ignored) {\n+    }\n+\n+    playerStats victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    if (victimStats == null) {\n+      allPlayerStats.put(victim.getBukkit().getName(), new playerStats());\n+      victimStats = allPlayerStats.get(event.getVictim().getBukkit().getName());\n+    }\n+    victimStats.onDeath();\n+\n+    playerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            0,\n+            () -> {\n+              NMSHacks.sendHotbarMessage(\n+                  victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer.getState())\n+            != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      playerStats murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murderer.getBukkit().getName(), new playerStats());\n+        murdererStats = allPlayerStats.get(murderer.getBukkit().getName());\n+      }\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+        murdererStats.onMurder();\n+        NMSHacks.sendHotbarMessage(\n+            murderer.getBukkit().getPlayer(), murdererStats.getBasicStatsMessage());\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    HashMap<String, Integer> allKills = new HashMap<>();\n+    HashMap<String, Integer> allKillstreaks = new HashMap<>();\n+    HashMap<String, Integer> allDeaths = new HashMap<>();\n+    HashMap<String, Integer> allBowshots = new HashMap<>();\n+    for (MatchPlayer player : match.getPlayers()) {\n+      allKills.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).kills);\n+      allKillstreaks.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).killstreakMax);\n+      allDeaths.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).deaths);\n+      allBowshots.put(\n+          player.getBukkit().getDisplayName(),\n+          allPlayerStats.get(player.getBukkit().getName()).longestBowKill);\n+    }\n+    Component killMessage = getKillsMessage(sortStats(allKills));\n+    Component killstreakMessage = getKillstreakMessage(sortStats(allKillstreaks));\n+    Component deathMessage = getDeathsMessage(sortStats(allDeaths));\n+    Map.Entry<String, Integer> bestBowshot = sortStats(allBowshots);\n+    Component bowshotMessage = getBowshotMessage(bestBowshot);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW + \"Best stats this match\",\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.getValue()\n+          != 0) { // Prevent this from showing if bows are not used on the map played\n+        viewer.sendMessage(bowshotMessage);\n+      }\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private Map.Entry<String, Integer> sortStats(HashMap<String, Integer> map) {\n+    Object[] a = map.entrySet().toArray();\n+    Arrays.sort(\n+        a,\n+        (Comparator)\n+            (o1, o2) ->\n+                ((Map.Entry<String, Integer>) o2)\n+                    .getValue()\n+                    .compareTo(((Map.Entry<String, Integer>) o1).getValue()));\n+    return (Map.Entry<String, Integer>) a[0];", "originalCommit": "bf2758441dd907ba88439d52dd1ae7e949ec8538", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE4MDI1Nw==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389180257", "bodyText": "Why this in favour of what i wrote? Is there a standard i'm doing wrong? :)\nOr does it just look prettier (Your does)", "author": "KingOfSquares", "createdAt": "2020-03-06T22:45:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3Nzg5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxMTk4MA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389211980", "bodyText": "It's easier to read ^^", "author": "TheMolkaPL", "createdAt": "2020-03-07T01:16:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3Nzg5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTM2ODA1Nw==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389368057", "bodyText": "More concise (less code, same outcome)\nBetter readability\nAvoids extra allocation of an object array.\nDoesn't do weird casting from object to entry.\nThe complexity of finding a max or min is O(n) instead of O(n log n) that good sorting algs have\nIsn't painful to read (yes, i'm mentioning readability twice, because it is double as relevant).", "author": "Pablete1234", "createdAt": "2020-03-08T13:11:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU3Nzg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQyMzcwMg==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389423702", "bodyText": "I\u2019m curious why you chose to call this directly instead of\nfinalMurderer.sendHotbarMessage(finalMurdererStats.getBasicStatsMessage())?\nThe MatchPlayer#sendHotbarMessage method calls NMSHacks anyway, so it may be a little more consistent if you like.\nBesides that, great job! This will be awesome once merged \ud83d\ude04", "author": "applenick", "createdAt": "2020-03-09T00:36:03Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static Map<UUID, PlayerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    if (event.getKiller() != null) {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    }\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (victimStats == null) {\n+      allPlayerStats.put(victimUUID, new PlayerStats());\n+      victimStats = allPlayerStats.get(victimUUID);\n+    }\n+\n+    victimStats.onDeath();\n+\n+    PlayerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    int victimTaskId =\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  NMSHacks.sendHotbarMessage(\n+                      victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+                })\n+            .getTaskId();\n+\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            70,\n+            () -> {\n+              Bukkit.getScheduler().cancelTask(victimTaskId);\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murdererUUID, new PlayerStats());\n+        murdererStats = allPlayerStats.get(murdererUUID);\n+      }\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+\n+        murdererStats.onMurder();\n+\n+        MatchPlayer finalMurderer = murderer;\n+        PlayerStats finalMurdererStats = murdererStats;\n+        int murdererTaskId =\n+            event\n+                .getMatch()\n+                .getScheduler(MatchScope.LOADED)\n+                .runTaskTimer(\n+                    0,\n+                    5,\n+                    () -> {\n+                      NMSHacks.sendHotbarMessage(\n+                          finalMurderer.getBukkit(), finalMurdererStats.getBasicStatsMessage());\n+                    })", "originalCommit": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTcwNDAyNQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389704025", "bodyText": "Ah! I never knew that, thanks! :)", "author": "KingOfSquares", "createdAt": "2020-03-09T14:03:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQyMzcwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQyMzcyNg==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389423726", "bodyText": "See other comment about this.", "author": "applenick", "createdAt": "2020-03-09T00:36:23Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static Map<UUID, PlayerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    if (event.getKiller() != null) {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    }\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (victimStats == null) {\n+      allPlayerStats.put(victimUUID, new PlayerStats());\n+      victimStats = allPlayerStats.get(victimUUID);\n+    }\n+\n+    victimStats.onDeath();\n+\n+    PlayerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    int victimTaskId =\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  NMSHacks.sendHotbarMessage(\n+                      victim.getBukkit(), finalVictimStats.getBasicStatsMessage());", "originalCommit": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjQ4NA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389432484", "bodyText": "Why are you doing this that complicated way? :P You can cast numbers between datatypes.", "author": "TheMolkaPL", "createdAt": "2020-03-09T01:47:45Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));", "originalCommit": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTcwNzU1NQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389707555", "bodyText": "Like this?\n private void setLongestBowKill(double distance) { if (distance > longestBowKill) { longestBowKill = (int) distance; } }", "author": "KingOfSquares", "createdAt": "2020-03-09T14:07:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjQ4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3NDU3Nw==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389874577", "bodyText": "Exactly, but don't compare doubles with < > ==\nhttps://howtodoinjava.com/java/basics/correctly-compare-float-double/", "author": "TheMolkaPL", "createdAt": "2020-03-09T18:17:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjQ4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAzMDE3OQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r390030179", "bodyText": "So like this?\nprivate void setLongestBowKill(double distance) { if (new BigDecimal(distance).compareTo(new BigDecimal(longestBowKill)) > 0) { longestBowKill = (int) distance; } }", "author": "KingOfSquares", "createdAt": "2020-03-10T00:18:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjQ4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjUwMQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389432501", "bodyText": "Can be final", "author": "TheMolkaPL", "createdAt": "2020-03-09T01:47:53Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");", "originalCommit": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjU3NQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389432575", "bodyText": "This is defining static context from the instance context.", "author": "TheMolkaPL", "createdAt": "2020-03-09T01:48:27Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static Map<UUID, PlayerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();", "originalCommit": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTcwODM4MA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389708380", "bodyText": "What does that mean? haha", "author": "KingOfSquares", "createdAt": "2020-03-09T14:07:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg3MjY4Mw==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389872683", "bodyText": "allPlayerStats is a static variable. This means that the variable is global and not object depended. If you create a new instance of StatsMatchModule the contents of allPlayerStats should still be the same. The problem is that you are modifying static (global) variable from the object (its constructor). You should either make allPlayerStats non-static and make it object depended, or initialize it just once and make it a constant. If so, there will only be one instance of this allPlayerStats map.\nprivate final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\nor\nprivate static final Map<UUID, PlayerStats> ALL_PLAYER_STATS = new HashMap<>();", "author": "TheMolkaPL", "createdAt": "2020-03-09T18:14:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjU3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxNzIyMg==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r390017222", "bodyText": "What do i even need the constructor for? I only added it because Electroids example has it. The Module does not need to get passed any objects on creation anyways.., i will make i private static final.", "author": "KingOfSquares", "createdAt": "2020-03-09T23:32:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjg3Mw==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389432873", "bodyText": "This method seems to be very long. Could you try to slice it into smaller ones? Would make it easier to read.", "author": "TheMolkaPL", "createdAt": "2020-03-09T01:50:19Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static Map<UUID, PlayerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    if (event.getKiller() != null) {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    }\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (victimStats == null) {\n+      allPlayerStats.put(victimUUID, new PlayerStats());\n+      victimStats = allPlayerStats.get(victimUUID);\n+    }\n+\n+    victimStats.onDeath();\n+\n+    PlayerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    int victimTaskId =\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  NMSHacks.sendHotbarMessage(\n+                      victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+                })\n+            .getTaskId();\n+\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            70,\n+            () -> {\n+              Bukkit.getScheduler().cancelTask(victimTaskId);\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murdererUUID, new PlayerStats());\n+        murdererStats = allPlayerStats.get(murdererUUID);\n+      }\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+\n+        murdererStats.onMurder();\n+\n+        MatchPlayer finalMurderer = murderer;\n+        PlayerStats finalMurdererStats = murdererStats;\n+        int murdererTaskId =\n+            event\n+                .getMatch()\n+                .getScheduler(MatchScope.LOADED)\n+                .runTaskTimer(\n+                    0,\n+                    5,\n+                    () -> {\n+                      NMSHacks.sendHotbarMessage(\n+                          finalMurderer.getBukkit(), finalMurdererStats.getBasicStatsMessage());\n+                    })\n+                .getTaskId();\n+\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskLater(\n+                70,\n+                () -> {\n+                  Bukkit.getScheduler().cancelTask(murdererTaskId);\n+                });\n+      }\n+    }\n+  }", "originalCommit": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTEwNjMwMA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r391106300", "bodyText": "Yeah i'm splitting it up, you will see next commit.", "author": "KingOfSquares", "createdAt": "2020-03-11T16:37:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzMjg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzNDE5OQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r389434199", "bodyText": "These methods are actually the same. The only difference seems to be translation keys and colors. To keep this DRY we could try make a generic method with these as parameters, and these methods would call it.\nComponent getBowshotMessage(TopResult topResult, Match match) {\n  return getMessage(\"stats.bowshot\", topResult, match, ChatColor.YELLOW);\n}\n\nComponent getMessage(String messageKey, TopResult topResult, Match match, CharColor color) {\n  return new Component(\n      new PersonalizedTranslatable(\n              messageKey,\n              playerName(match, topResult.uuid),\n              new PersonalizedText(Integer.toString(topResult.stat), color))\n          .render());\n}", "author": "TheMolkaPL", "createdAt": "2020-03-09T01:58:59Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,299 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.nms.NMSHacks;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private DecimalFormat decimalFormatBowshot = new DecimalFormat(\"#\");\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = Integer.parseInt(decimalFormatBowshot.format(Math.round(distance)));\n+      }\n+    }\n+\n+    private DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static Map<UUID, PlayerStats> allPlayerStats;\n+\n+  public StatsMatchModule() {\n+    allPlayerStats = new HashMap<>();\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+    if (event.getKiller() != null) {\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+    }\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (victimStats == null) {\n+      allPlayerStats.put(victimUUID, new PlayerStats());\n+      victimStats = allPlayerStats.get(victimUUID);\n+    }\n+\n+    victimStats.onDeath();\n+\n+    PlayerStats finalVictimStats = victimStats;\n+    // Without this delay the \"Press LShift to dismount\" message from the death minecart will\n+    // override the stats message.\n+    int victimTaskId =\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  NMSHacks.sendHotbarMessage(\n+                      victim.getBukkit(), finalVictimStats.getBasicStatsMessage());\n+                })\n+            .getTaskId();\n+\n+    event\n+        .getMatch()\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            70,\n+            () -> {\n+              Bukkit.getScheduler().cancelTask(victimTaskId);\n+            });\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (murdererStats == null) {\n+        allPlayerStats.put(murdererUUID, new PlayerStats());\n+        murdererStats = allPlayerStats.get(murdererUUID);\n+      }\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+\n+        murdererStats.onMurder();\n+\n+        MatchPlayer finalMurderer = murderer;\n+        PlayerStats finalMurdererStats = murdererStats;\n+        int murdererTaskId =\n+            event\n+                .getMatch()\n+                .getScheduler(MatchScope.LOADED)\n+                .runTaskTimer(\n+                    0,\n+                    5,\n+                    () -> {\n+                      NMSHacks.sendHotbarMessage(\n+                          finalMurderer.getBukkit(), finalMurdererStats.getBasicStatsMessage());\n+                    })\n+                .getTaskId();\n+\n+        event\n+            .getMatch()\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskLater(\n+                70,\n+                () -> {\n+                  Bukkit.getScheduler().cancelTask(murdererTaskId);\n+                });\n+      }\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Match match = event.getMatch();\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (allPlayerStats.get(playerUUID) == null) {\n+        allPlayerStats.put(playerUUID, new PlayerStats());\n+      }\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getKillsMessage(sortStats(allKills), match);\n+    Component killstreakMessage = getKillstreakMessage(sortStats(allKillstreaks), match);\n+    Component deathMessage = getDeathsMessage(sortStats(allDeaths), match);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    Component bowshotMessage = getBowshotMessage(bestBowshot, match);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0)\n+        viewer.sendMessage(bowshotMessage); // Prevent from showing if bows are not used\n+    }\n+  }\n+\n+  private static class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }\n+\n+  private TopResult sortStats(Map<UUID, Integer> map) {\n+    Map.Entry<UUID, Integer> mapEntry =\n+        map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+    TopResult topResult = new TopResult();\n+\n+    if (mapEntry == null) { // Should never happen, but acts as a failsafe\n+      topResult.uuid = UUID.fromString(\"3c7db14d-ac4b-4e35-b2c6-3b2237f382be\");\n+      topResult.stat = 0;\n+      return topResult;\n+    }\n+    topResult.uuid = mapEntry.getKey();\n+    topResult.stat = mapEntry.getValue();\n+    return topResult;\n+  }\n+\n+  Component getKillsMessage(TopResult topResult, Match match) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.kills\",\n+                playerName(match, topResult.uuid),\n+                new PersonalizedText(Integer.toString(topResult.stat), ChatColor.GREEN))\n+            .render());\n+  }\n+\n+  Component getKillstreakMessage(TopResult topResult, Match match) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.killstreak\",\n+                playerName(match, topResult.uuid),\n+                new PersonalizedText(Integer.toString(topResult.stat), ChatColor.GREEN))\n+            .render());\n+  }\n+\n+  Component getDeathsMessage(TopResult topResult, Match match) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.deaths\",\n+                playerName(match, topResult.uuid),\n+                new PersonalizedText(Integer.toString(topResult.stat), ChatColor.RED))\n+            .render());\n+  }\n+\n+  Component getBowshotMessage(TopResult topResult, Match match) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                \"stats.bowshot\",\n+                playerName(match, topResult.uuid),\n+                new PersonalizedText(Integer.toString(topResult.stat), ChatColor.YELLOW))\n+            .render());\n+  }", "originalCommit": "5f7559bff5d256dba7c67d7cafc28b604ef82ea3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwOTkyOQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r390009929", "bodyText": "Do we even need a Component constructor for each message then? Why not just call getMessage from a method directly.", "author": "KingOfSquares", "createdAt": "2020-03-09T23:08:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQzNDE5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4MTcxMQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r392381711", "bodyText": "May want to make this private final Match match;", "author": "applenick", "createdAt": "2020-03-13T17:49:45Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -35,10 +34,17 @@\n \n     @Override\n     public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n-      return new StatsMatchModule();\n+      return new StatsMatchModule(match);\n     }\n   }\n \n+  Match match;", "originalCommit": "604cd9fc475b6aef61c769009ed0e19bb67c35bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4NTUwOQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r392385509", "bodyText": "This should be something along the lines of hasNoStats or at the very least playerStatsDoesNotExist. Gotta remember camel case \ud83d\udc2b", "author": "applenick", "createdAt": "2020-03-13T17:57:21Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  Match match;\n+  private static final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (PlayerStatsDoesNotExist(victimUUID)) victimStats = putNewPlayer(victimUUID);\n+\n+    victimStats.onDeath();\n+\n+    sendLongHotbarMessage(victim, victimStats.getBasicStatsMessage());\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (PlayerStatsDoesNotExist(murdererUUID)) murdererStats = putNewPlayer(murdererUUID);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendLongHotbarMessage(murderer, murdererStats.getBasicStatsMessage());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (PlayerStatsDoesNotExist(playerUUID)) playerStats = putNewPlayer(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getMessage(\"stats.kills\", sortStats(allKills), ChatColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"stats.killstreak\", sortStats(allKillstreaks), ChatColor.GREEN);\n+    Component deathMessage = getMessage(\"stats.deaths\", sortStats(allDeaths), ChatColor.RED);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    String bowMessageKey = (bestBowshot.stat == 1) ? \"stats.bowshot.block\" : \"stats.bowshot.blocks\";\n+    Component bowshotMessage = getMessage(bowMessageKey, bestBowshot, ChatColor.YELLOW);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0) viewer.sendMessage(bowshotMessage);\n+    }\n+  }\n+\n+  private static class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }\n+\n+  private TopResult sortStats(Map<UUID, Integer> map) {\n+    Map.Entry<UUID, Integer> mapEntry =\n+        map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+    TopResult topResult = new TopResult();\n+\n+    if (mapEntry == null) { // Should never happen, but acts as a failsafe\n+      topResult.uuid = UUID.fromString(\"3c7db14d-ac4b-4e35-b2c6-3b2237f382be\");\n+      topResult.stat = 0;\n+      return topResult;\n+    }\n+\n+    topResult.uuid = mapEntry.getKey();\n+    topResult.stat = mapEntry.getValue();\n+\n+    return topResult;\n+  }\n+\n+  private void sendLongHotbarMessage(MatchPlayer player, Component message) {\n+    int taskId =\n+        match\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  player.sendHotbarMessage(message);\n+                })\n+            .getTaskId();\n+\n+    match\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            20 * 4,\n+            () -> {\n+              Bukkit.getScheduler().cancelTask(taskId);\n+            });\n+  }\n+\n+  Component getMessage(String messageKey, TopResult topResult, ChatColor color) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                messageKey,\n+                playerName(topResult.uuid),\n+                new PersonalizedText(Integer.toString(topResult.stat), color).render())\n+            .render());\n+  }\n+\n+  private PersonalizedText playerName(UUID playerUUID) {\n+    if (Bukkit.getPlayer(playerUUID) == null) {\n+      if (Bukkit.getOfflinePlayer(playerUUID).getName() == null) {\n+        return new PersonalizedText(\"Noone\", ChatColor.MAGIC, ChatColor.BLACK);\n+      }\n+      return new PersonalizedText(\n+          Bukkit.getOfflinePlayer(playerUUID).getName(), ChatColor.DARK_AQUA);\n+    }\n+    return new PersonalizedText(match.getPlayer(playerUUID).getBukkit().getDisplayName());\n+  }\n+\n+  public static boolean PlayerStatsDoesNotExist(UUID player) {", "originalCommit": "604cd9fc475b6aef61c769009ed0e19bb67c35bb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d836d0ac23ea8b041197a3efdf815397bfe9f196", "url": "https://github.com/PGMDev/PGM/commit/d836d0ac23ea8b041197a3efdf815397bfe9f196", "message": "Match is now final, method name fix\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>", "committedDate": "2020-03-19T12:07:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwNTk0OA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r391705948", "bodyText": "StatsCommands", "author": "Electroid", "createdAt": "2020-03-12T15:35:34Z", "path": "core/src/main/java/tc/oc/pgm/PGMPlugin.java", "diffHunk": "@@ -320,6 +321,7 @@ private void registerCommands() {\n     node.registerCommands(new SettingCommands());\n     node.registerCommands(new ObserverCommands());\n     node.registerCommands(new MapPoolCommands());\n+    node.registerCommands(new StatCommands());", "originalCommit": "94883a4d75940b41d27168ac71873438a8396979", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwNjgyNQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r391706825", "bodyText": "MatchModules should not store player data in static variables. Remove the static.", "author": "Electroid", "createdAt": "2020-03-12T15:36:51Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,247 @@\n+package tc.oc.pgm.modules;\n+\n+import java.math.BigDecimal;\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (new BigDecimal(distance).compareTo(new BigDecimal(longestBowKill)) > 0) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();", "originalCommit": "94883a4d75940b41d27168ac71873438a8396979", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMTgyMw==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396121823", "bodyText": "Already fixed.", "author": "KingOfSquares", "createdAt": "2020-03-22T17:51:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwNjgyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwNzE1NQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r391707155", "bodyText": "In Java, methods should start with a lower case letter.", "author": "Electroid", "createdAt": "2020-03-12T15:37:23Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,247 @@\n+package tc.oc.pgm.modules;\n+\n+import java.math.BigDecimal;\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule();\n+    }\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (new BigDecimal(distance).compareTo(new BigDecimal(longestBowKill)) > 0) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  private static final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    Match match = event.getMatch();\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (PlayerStatsDoesNotExist(victimUUID)) victimStats = putNewPlayer(victimUUID);", "originalCommit": "94883a4d75940b41d27168ac71873438a8396979", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMTgzNA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396121834", "bodyText": "Already fixed.", "author": "KingOfSquares", "createdAt": "2020-03-22T17:51:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTcwNzE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTM2NA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396111364", "bodyText": "You don't need this. In Modules.java you can put instead:\nregister(StatsMatchModule.class, StatsMatchModule::new);", "author": "Electroid", "createdAt": "2020-03-22T16:15:12Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }", "originalCommit": "6481e3c922c1f50afc7c782061ceb901886fd55e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTYwNQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396111605", "bodyText": "To avoid the possibility of a 0 bow kill:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    longestBowKill = (int) distance;\n          \n          \n            \n                    longestBowKill = (int) Math.ceil(distance);", "author": "Electroid", "createdAt": "2020-03-22T16:17:31Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;", "originalCommit": "6481e3c922c1f50afc7c782061ceb901886fd55e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMzk5Mw==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396123993", "bodyText": "I am not sure why that would be needed, i already prevent any message containing bow kills from showing if they are 0.", "author": "KingOfSquares", "createdAt": "2020-03-22T18:12:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTYwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE3MjI4OA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396172288", "bodyText": "It's good form.", "author": "Electroid", "createdAt": "2020-03-23T01:05:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTYwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTg0NQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396111845", "bodyText": "You don't need this null check, these maps will never be null.", "author": "Electroid", "createdAt": "2020-03-22T16:19:40Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (hasNoStats(victimUUID)) victimStats = putNewPlayer(victimUUID);\n+\n+    victimStats.onDeath();\n+\n+    sendLongHotbarMessage(victim, victimStats.getBasicStatsMessage());\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (hasNoStats(murdererUUID)) murdererStats = putNewPlayer(murdererUUID);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendLongHotbarMessage(murderer, murdererStats.getBasicStatsMessage());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (hasNoStats(playerUUID)) playerStats = putNewPlayer(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getMessage(\"stats.kills\", sortStats(allKills), ChatColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"stats.killstreak\", sortStats(allKillstreaks), ChatColor.GREEN);\n+    Component deathMessage = getMessage(\"stats.deaths\", sortStats(allDeaths), ChatColor.RED);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    String bowMessageKey = (bestBowshot.stat == 1) ? \"stats.bowshot.block\" : \"stats.bowshot.blocks\";\n+    Component bowshotMessage = getMessage(bowMessageKey, bestBowshot, ChatColor.YELLOW);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0) viewer.sendMessage(bowshotMessage);\n+    }\n+  }\n+\n+  private class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }\n+\n+  private TopResult sortStats(Map<UUID, Integer> map) {\n+    Map.Entry<UUID, Integer> mapEntry =\n+        map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+    TopResult topResult = new TopResult();\n+\n+    if (mapEntry == null) { // Should never happen, but acts as a failsafe\n+      topResult.uuid = UUID.fromString(\"3c7db14d-ac4b-4e35-b2c6-3b2237f382be\");\n+      topResult.stat = 0;\n+      return topResult;\n+    }", "originalCommit": "6481e3c922c1f50afc7c782061ceb901886fd55e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMTkwNQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396121905", "bodyText": "Ok!", "author": "KingOfSquares", "createdAt": "2020-03-22T17:52:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTkwMA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396111900", "bodyText": "You don't need this class.\nJust use Map.Entry<UUID, Integer>", "author": "Electroid", "createdAt": "2020-03-22T16:20:21Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (hasNoStats(victimUUID)) victimStats = putNewPlayer(victimUUID);\n+\n+    victimStats.onDeath();\n+\n+    sendLongHotbarMessage(victim, victimStats.getBasicStatsMessage());\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (hasNoStats(murdererUUID)) murdererStats = putNewPlayer(murdererUUID);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendLongHotbarMessage(murderer, murdererStats.getBasicStatsMessage());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (hasNoStats(playerUUID)) playerStats = putNewPlayer(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getMessage(\"stats.kills\", sortStats(allKills), ChatColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"stats.killstreak\", sortStats(allKillstreaks), ChatColor.GREEN);\n+    Component deathMessage = getMessage(\"stats.deaths\", sortStats(allDeaths), ChatColor.RED);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    String bowMessageKey = (bestBowshot.stat == 1) ? \"stats.bowshot.block\" : \"stats.bowshot.blocks\";\n+    Component bowshotMessage = getMessage(bowMessageKey, bestBowshot, ChatColor.YELLOW);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0) viewer.sendMessage(bowshotMessage);\n+    }\n+  }\n+\n+  private class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }", "originalCommit": "6481e3c922c1f50afc7c782061ceb901886fd55e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMjU2MQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396122561", "bodyText": "That is the way i did it before, that change was done because of @TheMolkaPL s suggestion earlier. You can see his reasoning #338 (comment)\nI can remove it if you still disagree", "author": "KingOfSquares", "createdAt": "2020-03-22T17:58:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE3MjI0MA==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396172240", "bodyText": "I would remove it.", "author": "Electroid", "createdAt": "2020-03-23T01:04:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTkwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQzOTk5Nw==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396439997", "bodyText": "Sure, i've removed it now.", "author": "KingOfSquares", "createdAt": "2020-03-23T13:14:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMTkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMjE0NQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396112145", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            () -> {\n          \n          \n            \n                              player.sendHotbarMessage(message);\n          \n          \n            \n                            })\n          \n          \n            \n                            () -> player.sendHotbarMessage(message));", "author": "Electroid", "createdAt": "2020-03-22T16:22:20Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (hasNoStats(victimUUID)) victimStats = putNewPlayer(victimUUID);\n+\n+    victimStats.onDeath();\n+\n+    sendLongHotbarMessage(victim, victimStats.getBasicStatsMessage());\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (hasNoStats(murdererUUID)) murdererStats = putNewPlayer(murdererUUID);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendLongHotbarMessage(murderer, murdererStats.getBasicStatsMessage());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (hasNoStats(playerUUID)) playerStats = putNewPlayer(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getMessage(\"stats.kills\", sortStats(allKills), ChatColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"stats.killstreak\", sortStats(allKillstreaks), ChatColor.GREEN);\n+    Component deathMessage = getMessage(\"stats.deaths\", sortStats(allDeaths), ChatColor.RED);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    String bowMessageKey = (bestBowshot.stat == 1) ? \"stats.bowshot.block\" : \"stats.bowshot.blocks\";\n+    Component bowshotMessage = getMessage(bowMessageKey, bestBowshot, ChatColor.YELLOW);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0) viewer.sendMessage(bowshotMessage);\n+    }\n+  }\n+\n+  private class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }\n+\n+  private TopResult sortStats(Map<UUID, Integer> map) {\n+    Map.Entry<UUID, Integer> mapEntry =\n+        map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+    TopResult topResult = new TopResult();\n+\n+    if (mapEntry == null) { // Should never happen, but acts as a failsafe\n+      topResult.uuid = UUID.fromString(\"3c7db14d-ac4b-4e35-b2c6-3b2237f382be\");\n+      topResult.stat = 0;\n+      return topResult;\n+    }\n+\n+    topResult.uuid = mapEntry.getKey();\n+    topResult.stat = mapEntry.getValue();\n+\n+    return topResult;\n+  }\n+\n+  private void sendLongHotbarMessage(MatchPlayer player, Component message) {\n+    int taskId =\n+        match\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  player.sendHotbarMessage(message);\n+                })", "originalCommit": "6481e3c922c1f50afc7c782061ceb901886fd55e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMjI0Mg==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396112242", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        () -> {\n          \n          \n            \n                          Bukkit.getScheduler().cancelTask(taskId);\n          \n          \n            \n                        });\n          \n          \n            \n                        () -> Bukkit.getScheduler().cancelTask(taskId));", "author": "Electroid", "createdAt": "2020-03-22T16:23:00Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (hasNoStats(victimUUID)) victimStats = putNewPlayer(victimUUID);\n+\n+    victimStats.onDeath();\n+\n+    sendLongHotbarMessage(victim, victimStats.getBasicStatsMessage());\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (hasNoStats(murdererUUID)) murdererStats = putNewPlayer(murdererUUID);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendLongHotbarMessage(murderer, murdererStats.getBasicStatsMessage());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (hasNoStats(playerUUID)) playerStats = putNewPlayer(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getMessage(\"stats.kills\", sortStats(allKills), ChatColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"stats.killstreak\", sortStats(allKillstreaks), ChatColor.GREEN);\n+    Component deathMessage = getMessage(\"stats.deaths\", sortStats(allDeaths), ChatColor.RED);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    String bowMessageKey = (bestBowshot.stat == 1) ? \"stats.bowshot.block\" : \"stats.bowshot.blocks\";\n+    Component bowshotMessage = getMessage(bowMessageKey, bestBowshot, ChatColor.YELLOW);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0) viewer.sendMessage(bowshotMessage);\n+    }\n+  }\n+\n+  private class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }\n+\n+  private TopResult sortStats(Map<UUID, Integer> map) {\n+    Map.Entry<UUID, Integer> mapEntry =\n+        map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+    TopResult topResult = new TopResult();\n+\n+    if (mapEntry == null) { // Should never happen, but acts as a failsafe\n+      topResult.uuid = UUID.fromString(\"3c7db14d-ac4b-4e35-b2c6-3b2237f382be\");\n+      topResult.stat = 0;\n+      return topResult;\n+    }\n+\n+    topResult.uuid = mapEntry.getKey();\n+    topResult.stat = mapEntry.getValue();\n+\n+    return topResult;\n+  }\n+\n+  private void sendLongHotbarMessage(MatchPlayer player, Component message) {\n+    int taskId =\n+        match\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  player.sendHotbarMessage(message);\n+                })\n+            .getTaskId();\n+\n+    match\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            20 * 4,\n+            () -> {\n+              Bukkit.getScheduler().cancelTask(taskId);\n+            });", "originalCommit": "6481e3c922c1f50afc7c782061ceb901886fd55e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjExMjM2OQ==", "url": "https://github.com/PGMDev/PGM/pull/338#discussion_r396112369", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return new PersonalizedText(\"Noone\", ChatColor.MAGIC, ChatColor.BLACK);\n          \n          \n            \n                    return new PersonalizedText(\"Unknown\", ChatColor.MAGIC, ChatColor.BLACK);", "author": "Electroid", "createdAt": "2020-03-22T16:23:44Z", "path": "core/src/main/java/tc/oc/pgm/modules/StatsMatchModule.java", "diffHunk": "@@ -0,0 +1,250 @@\n+package tc.oc.pgm.modules;\n+\n+import java.text.DecimalFormat;\n+import java.util.Comparator;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.UUID;\n+import net.md_5.bungee.api.ChatColor;\n+import org.bukkit.Bukkit;\n+import org.bukkit.event.EventHandler;\n+import org.bukkit.event.Listener;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n+import tc.oc.pgm.api.match.MatchScope;\n+import tc.oc.pgm.api.match.event.MatchFinishEvent;\n+import tc.oc.pgm.api.match.factory.MatchModuleFactory;\n+import tc.oc.pgm.api.module.exception.ModuleLoadException;\n+import tc.oc.pgm.api.player.MatchPlayer;\n+import tc.oc.pgm.api.player.PlayerRelation;\n+import tc.oc.pgm.api.player.event.MatchPlayerDeathEvent;\n+import tc.oc.pgm.events.ListenerScope;\n+import tc.oc.pgm.tracker.damage.ProjectileInfo;\n+import tc.oc.util.bukkit.component.Component;\n+import tc.oc.util.bukkit.component.ComponentUtils;\n+import tc.oc.util.bukkit.component.Components;\n+import tc.oc.util.bukkit.component.types.PersonalizedText;\n+import tc.oc.util.bukkit.component.types.PersonalizedTranslatable;\n+import tc.oc.util.bukkit.translations.AllTranslations;\n+\n+@ListenerScope(MatchScope.RUNNING)\n+public class StatsMatchModule implements MatchModule, Listener {\n+\n+  public static class Factory implements MatchModuleFactory<StatsMatchModule> {\n+\n+    @Override\n+    public StatsMatchModule createMatchModule(Match match) throws ModuleLoadException {\n+      return new StatsMatchModule(match);\n+    }\n+  }\n+\n+  private final Match match;\n+  private final Map<UUID, PlayerStats> allPlayerStats = new HashMap<>();\n+\n+  StatsMatchModule(Match match){\n+    this.match = match;\n+  }\n+\n+  public static class PlayerStats {\n+    private int kills;\n+    private int deaths;\n+    private int killstreak;\n+    private int killstreakMax;\n+    private int longestBowKill;\n+\n+    private void onMurder() {\n+      kills++;\n+      killstreak++;\n+      if (killstreak > killstreakMax) killstreakMax = killstreak;\n+    }\n+\n+    private void onDeath() {\n+      deaths++;\n+      killstreak = 0;\n+    }\n+\n+    private void setLongestBowKill(double distance) {\n+      if (distance > longestBowKill) {\n+        longestBowKill = (int) distance;\n+      }\n+    }\n+\n+    private final DecimalFormat decimalFormatKd = new DecimalFormat(\"#.##\");\n+\n+    Component getBasicStatsMessage() {\n+      String kd;\n+      if (deaths == 0) {\n+        kd = \"0\";\n+      } else {\n+        kd = decimalFormatKd.format(kills / deaths);\n+      }\n+      return new Component(\n+          new PersonalizedTranslatable(\n+                  \"stats.basic\",\n+                  new PersonalizedText(Integer.toString(kills), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(killstreak), ChatColor.GREEN),\n+                  new PersonalizedText(Integer.toString(deaths), ChatColor.RED),\n+                  new PersonalizedText(kd, ChatColor.GREEN))\n+              .render());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onPlayerDeath(MatchPlayerDeathEvent event) {\n+    MatchPlayer victim = event.getVictim();\n+    MatchPlayer murderer = null;\n+\n+    if (event.getKiller() != null)\n+      murderer = event.getKiller().getParty().getPlayer(event.getKiller().getId());\n+\n+    UUID victimUUID = victim.getId();\n+    PlayerStats victimStats = allPlayerStats.get(victimUUID);\n+\n+    if (hasNoStats(victimUUID)) victimStats = putNewPlayer(victimUUID);\n+\n+    victimStats.onDeath();\n+\n+    sendLongHotbarMessage(victim, victimStats.getBasicStatsMessage());\n+\n+    if (murderer != null\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.ALLY\n+        && PlayerRelation.get(victim.getParticipantState(), murderer) != PlayerRelation.SELF) {\n+      UUID murdererUUID = murderer.getId();\n+      PlayerStats murdererStats = allPlayerStats.get(murdererUUID);\n+\n+      if (hasNoStats(murdererUUID)) murdererStats = putNewPlayer(murdererUUID);\n+\n+      if (event.getDamageInfo() instanceof ProjectileInfo) {\n+        murdererStats.setLongestBowKill(\n+            victim\n+                .getState()\n+                .getLocation()\n+                .distance(((ProjectileInfo) event.getDamageInfo()).getOrigin()));\n+      }\n+\n+      murdererStats.onMurder();\n+\n+      sendLongHotbarMessage(murderer, murdererStats.getBasicStatsMessage());\n+    }\n+  }\n+\n+  @EventHandler\n+  public void onMatchEnd(MatchFinishEvent event) {\n+    Map<UUID, Integer> allKills = new HashMap<>();\n+    Map<UUID, Integer> allKillstreaks = new HashMap<>();\n+    Map<UUID, Integer> allDeaths = new HashMap<>();\n+    Map<UUID, Integer> allBowshots = new HashMap<>();\n+\n+    for (Map.Entry<UUID, PlayerStats> mapEntry : allPlayerStats.entrySet()) {\n+      UUID playerUUID = mapEntry.getKey();\n+      PlayerStats playerStats = mapEntry.getValue();\n+\n+      if (hasNoStats(playerUUID)) playerStats = putNewPlayer(playerUUID);\n+\n+      allKills.put(playerUUID, playerStats.kills);\n+      allKillstreaks.put(playerUUID, playerStats.killstreakMax);\n+      allDeaths.put(playerUUID, playerStats.deaths);\n+      allBowshots.put(playerUUID, playerStats.longestBowKill);\n+    }\n+\n+    Component killMessage = getMessage(\"stats.kills\", sortStats(allKills), ChatColor.GREEN);\n+    Component killstreakMessage =\n+        getMessage(\"stats.killstreak\", sortStats(allKillstreaks), ChatColor.GREEN);\n+    Component deathMessage = getMessage(\"stats.deaths\", sortStats(allDeaths), ChatColor.RED);\n+    TopResult bestBowshot = sortStats(allBowshots);\n+    String bowMessageKey = (bestBowshot.stat == 1) ? \"stats.bowshot.block\" : \"stats.bowshot.blocks\";\n+    Component bowshotMessage = getMessage(bowMessageKey, bestBowshot, ChatColor.YELLOW);\n+\n+    for (MatchPlayer viewer : match.getPlayers()) {\n+      viewer.sendMessage(\n+          Components.fromLegacyText(\n+              ComponentUtils.horizontalLineHeading(\n+                  ChatColor.YELLOW\n+                      + AllTranslations.get().translate(\"stats.best\", viewer.getBukkit()),\n+                  ChatColor.WHITE,\n+                  ComponentUtils.MAX_CHAT_WIDTH)));\n+\n+      viewer.sendMessage(killMessage);\n+      viewer.sendMessage(killstreakMessage);\n+      viewer.sendMessage(deathMessage);\n+      if (bestBowshot.stat != 0) viewer.sendMessage(bowshotMessage);\n+    }\n+  }\n+\n+  private class TopResult {\n+    UUID uuid;\n+    int stat;\n+  }\n+\n+  private TopResult sortStats(Map<UUID, Integer> map) {\n+    Map.Entry<UUID, Integer> mapEntry =\n+        map.entrySet().stream().max(Comparator.comparingInt(Map.Entry::getValue)).orElse(null);\n+    TopResult topResult = new TopResult();\n+\n+    if (mapEntry == null) { // Should never happen, but acts as a failsafe\n+      topResult.uuid = UUID.fromString(\"3c7db14d-ac4b-4e35-b2c6-3b2237f382be\");\n+      topResult.stat = 0;\n+      return topResult;\n+    }\n+\n+    topResult.uuid = mapEntry.getKey();\n+    topResult.stat = mapEntry.getValue();\n+\n+    return topResult;\n+  }\n+\n+  private void sendLongHotbarMessage(MatchPlayer player, Component message) {\n+    int taskId =\n+        match\n+            .getScheduler(MatchScope.LOADED)\n+            .runTaskTimer(\n+                0,\n+                5,\n+                () -> {\n+                  player.sendHotbarMessage(message);\n+                })\n+            .getTaskId();\n+\n+    match\n+        .getScheduler(MatchScope.LOADED)\n+        .runTaskLater(\n+            20 * 4,\n+            () -> {\n+              Bukkit.getScheduler().cancelTask(taskId);\n+            });\n+  }\n+\n+  Component getMessage(String messageKey, TopResult topResult, ChatColor color) {\n+    return new Component(\n+        new PersonalizedTranslatable(\n+                messageKey,\n+                playerName(topResult.uuid),\n+                new PersonalizedText(Integer.toString(topResult.stat), color).render())\n+            .render());\n+  }\n+\n+  private PersonalizedText playerName(UUID playerUUID) {\n+    if (Bukkit.getPlayer(playerUUID) == null) {\n+      if (Bukkit.getOfflinePlayer(playerUUID).getName() == null) {\n+        return new PersonalizedText(\"Noone\", ChatColor.MAGIC, ChatColor.BLACK);", "originalCommit": "6481e3c922c1f50afc7c782061ceb901886fd55e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6265d25fda39abe4ac4b3e601f35f43a5d44dc02", "url": "https://github.com/PGMDev/PGM/commit/6265d25fda39abe4ac4b3e601f35f43a5d44dc02", "message": "Add a toggle for tracking stats.\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>", "committedDate": "2020-03-23T17:11:37Z", "type": "forcePushed"}, {"oid": "0cbc316af51261e666f21f439048129a5b606b38", "url": "https://github.com/PGMDev/PGM/commit/0cbc316af51261e666f21f439048129a5b606b38", "message": "Add a toggle for tracking stats.\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>", "committedDate": "2020-03-23T19:56:10Z", "type": "forcePushed"}, {"oid": "724c6cd68d642c21ec088edae06aeb07fb2c24c7", "url": "https://github.com/PGMDev/PGM/commit/724c6cd68d642c21ec088edae06aeb07fb2c24c7", "message": "Add match stats\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>", "committedDate": "2020-03-23T23:40:59Z", "type": "commit"}, {"oid": "c5dd7341a8f552b2c766f7a8396be7d6fc773d1f", "url": "https://github.com/PGMDev/PGM/commit/c5dd7341a8f552b2c766f7a8396be7d6fc773d1f", "message": "Move all strings into translations, persist UUIDs instead of player names, changed logic so that if an offline player wins there will be no NPE, removed wildcard imports, simplify some definitions, clean up naming of some variables, enchance the sorting, and some more.\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>", "committedDate": "2020-03-23T23:40:59Z", "type": "commit"}, {"oid": "17499279dc816c68cf7e1bec9af285b5246ccde4", "url": "https://github.com/PGMDev/PGM/commit/17499279dc816c68cf7e1bec9af285b5246ccde4", "message": "Now calls sendHotbarMessage directly from the MatchPlayer, changed comparing of doubles to use BigDecimal comparing, sliced up the long onPlayerDeath method into a more readable version, simplified the construction of some stat messages, and some more smaller things.\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>", "committedDate": "2020-03-23T23:40:59Z", "type": "commit"}, {"oid": "2bc9f2c57616a16716ad011fd47265021022342f", "url": "https://github.com/PGMDev/PGM/commit/2bc9f2c57616a16716ad011fd47265021022342f", "message": "Revert BigDecimals, clean up refrences to Match, tweaked the bowshot message\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>", "committedDate": "2020-03-23T23:40:59Z", "type": "commit"}, {"oid": "90ffe44f7f06f2c53bc7fec77fda175a2a1fce70", "url": "https://github.com/PGMDev/PGM/commit/90ffe44f7f06f2c53bc7fec77fda175a2a1fce70", "message": "Match is now final, method name fix\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>", "committedDate": "2020-03-23T23:40:59Z", "type": "commit"}, {"oid": "00542f0d1302ce9f3f282d2c180fb10e47005ba2", "url": "https://github.com/PGMDev/PGM/commit/00542f0d1302ce9f3f282d2c180fb10e47005ba2", "message": "Remove non needed static defenitions\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>", "committedDate": "2020-03-23T23:40:59Z", "type": "commit"}, {"oid": "19d143d74bf14b534864b1e3ae9364a632f827d6", "url": "https://github.com/PGMDev/PGM/commit/19d143d74bf14b534864b1e3ae9364a632f827d6", "message": "Clean up formatting, remove unnecessary abstractions and code.\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>", "committedDate": "2020-03-23T23:40:59Z", "type": "commit"}, {"oid": "3535c808e480d0e1776bda9eb41cc51bb2fba228", "url": "https://github.com/PGMDev/PGM/commit/3535c808e480d0e1776bda9eb41cc51bb2fba228", "message": "Remove redundant imports.\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>", "committedDate": "2020-03-23T23:40:59Z", "type": "commit"}, {"oid": "223fee75787b704a1e6cd03c22603bbbe64e1be7", "url": "https://github.com/PGMDev/PGM/commit/223fee75787b704a1e6cd03c22603bbbe64e1be7", "message": "Add a toggle for tracking stats.\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>", "committedDate": "2020-03-23T23:40:59Z", "type": "forcePushed"}, {"oid": "f4cf3a52a37f63ac0360dd9a6c17cece529ed654", "url": "https://github.com/PGMDev/PGM/commit/f4cf3a52a37f63ac0360dd9a6c17cece529ed654", "message": "Add a toggle for tracking stats.\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>", "committedDate": "2020-03-24T00:01:53Z", "type": "commit"}, {"oid": "f4cf3a52a37f63ac0360dd9a6c17cece529ed654", "url": "https://github.com/PGMDev/PGM/commit/f4cf3a52a37f63ac0360dd9a6c17cece529ed654", "message": "Add a toggle for tracking stats.\n\nSigned-off-by: KingOfSquares <simonmorland@gmail.com>", "committedDate": "2020-03-24T00:01:53Z", "type": "forcePushed"}]}