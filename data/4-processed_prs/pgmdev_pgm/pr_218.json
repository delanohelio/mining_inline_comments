{"pr_number": 218, "pr_title": "Map, MapModule, and MatchModule refactors", "pr_createdAt": "2020-01-10T17:44:40Z", "pr_url": "https://github.com/PGMDev/PGM/pull/218", "timeline": [{"oid": "4fd9be07ae445ef7d73d0e0b5a66f3de7ed4e8c4", "url": "https://github.com/PGMDev/PGM/commit/4fd9be07ae445ef7d73d0e0b5a66f3de7ed4e8c4", "message": "WIP: Remove various debug statements\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-20T05:16:33Z", "type": "forcePushed"}, {"oid": "6bf2ebfbf1a364e1148883316ad1fe097182b5e6", "url": "https://github.com/PGMDev/PGM/commit/6bf2ebfbf1a364e1148883316ad1fe097182b5e6", "message": "WIP: End of WIP\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-23T08:23:17Z", "type": "forcePushed"}, {"oid": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "url": "https://github.com/PGMDev/PGM/commit/88e7cfe63ec24b171c800f60f5aecff4f7faee60", "message": "Fix various CME/NPE exceptions\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-23T09:01:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjE0NA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370912144", "bodyText": "Why is this an int instead of Difficulty?", "author": "TheMolkaPL", "createdAt": "2020-01-25T03:59:56Z", "path": "src/main/java/tc/oc/pgm/api/map/MapInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package tc.oc.pgm.api.map;\n+\n+import java.text.Normalizer;\n+import java.util.Collection;\n+import javax.annotation.Nullable;\n+import tc.oc.named.Named;\n+import tc.oc.util.Version;\n+\n+/** Essential information about a map. */\n+public interface MapInfo extends Named, Comparable<MapInfo>, Cloneable {\n+\n+  /**\n+   * Get a unique id for the map.\n+   *\n+   * @return A unique id.\n+   */\n+  String getId();\n+\n+  /**\n+   * Get the proto of the map's {@link org.jdom2.Document}.\n+   *\n+   * @see MapProtos\n+   * @return The proto.\n+   */\n+  Version getProto();\n+\n+  /**\n+   * Get the version of the map.\n+   *\n+   * @return The version.\n+   */\n+  Version getVersion();\n+\n+  /**\n+   * Get a unique, human-readable name for the map.\n+   *\n+   * @return A name, alphanumeric with spaces are allowed.\n+   */\n+  String getName();\n+\n+  /**\n+   * Get a short, human-readable description of the map's objective.\n+   *\n+   * @return A description.\n+   */\n+  String getDescription();\n+\n+  /**\n+   * Get all {@link Contributor}s that contributed significantly to the map.\n+   *\n+   * <p>There must be at least 1 author.\n+   *\n+   * @return The authors.\n+   */\n+  Collection<Contributor> getAuthors();\n+\n+  /**\n+   * Get all {@link Contributor}s that helped contribute to the map.\n+   *\n+   * @return The contributors.\n+   */\n+  Collection<Contributor> getContributors();\n+\n+  /**\n+   * Get any special rules that players must follow for the map.\n+   *\n+   * <p>Keep these to a minimum, it is often difficult to enforce these rules.\n+   *\n+   * @return A collection of rules.\n+   */\n+  Collection<String> getRules();\n+\n+  /**\n+   * Get the {@link org.bukkit.Difficulty#ordinal()} level for the map.\n+   *\n+   * @return The difficulty level.\n+   */\n+  int getDifficulty();", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDA0NQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944045", "bodyText": "Moving away from having Bukkit literals in the api.", "author": "Electroid", "createdAt": "2020-01-25T17:03:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjE0NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NjE5OQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370946199", "bodyText": "why?", "author": "TheMolkaPL", "createdAt": "2020-01-25T17:47:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjE0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjIwMA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370912200", "bodyText": "What about a BaseComponent?", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:01:30Z", "path": "src/main/java/tc/oc/pgm/api/map/MapInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package tc.oc.pgm.api.map;\n+\n+import java.text.Normalizer;\n+import java.util.Collection;\n+import javax.annotation.Nullable;\n+import tc.oc.named.Named;\n+import tc.oc.util.Version;\n+\n+/** Essential information about a map. */\n+public interface MapInfo extends Named, Comparable<MapInfo>, Cloneable {\n+\n+  /**\n+   * Get a unique id for the map.\n+   *\n+   * @return A unique id.\n+   */\n+  String getId();\n+\n+  /**\n+   * Get the proto of the map's {@link org.jdom2.Document}.\n+   *\n+   * @see MapProtos\n+   * @return The proto.\n+   */\n+  Version getProto();\n+\n+  /**\n+   * Get the version of the map.\n+   *\n+   * @return The version.\n+   */\n+  Version getVersion();\n+\n+  /**\n+   * Get a unique, human-readable name for the map.\n+   *\n+   * @return A name, alphanumeric with spaces are allowed.\n+   */\n+  String getName();\n+\n+  /**\n+   * Get a short, human-readable description of the map's objective.\n+   *\n+   * @return A description.\n+   */\n+  String getDescription();", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDA4NA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944084", "bodyText": "Components are rendering level stuff, this interface is just descriptive.", "author": "Electroid", "createdAt": "2020-01-25T17:03:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjI3Nw==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370912277", "bodyText": "The documentation should say if these are all maptags (with automatic maptags) or just XML defined.", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:03:25Z", "path": "src/main/java/tc/oc/pgm/api/map/MapInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package tc.oc.pgm.api.map;\n+\n+import java.text.Normalizer;\n+import java.util.Collection;\n+import javax.annotation.Nullable;\n+import tc.oc.named.Named;\n+import tc.oc.util.Version;\n+\n+/** Essential information about a map. */\n+public interface MapInfo extends Named, Comparable<MapInfo>, Cloneable {\n+\n+  /**\n+   * Get a unique id for the map.\n+   *\n+   * @return A unique id.\n+   */\n+  String getId();\n+\n+  /**\n+   * Get the proto of the map's {@link org.jdom2.Document}.\n+   *\n+   * @see MapProtos\n+   * @return The proto.\n+   */\n+  Version getProto();\n+\n+  /**\n+   * Get the version of the map.\n+   *\n+   * @return The version.\n+   */\n+  Version getVersion();\n+\n+  /**\n+   * Get a unique, human-readable name for the map.\n+   *\n+   * @return A name, alphanumeric with spaces are allowed.\n+   */\n+  String getName();\n+\n+  /**\n+   * Get a short, human-readable description of the map's objective.\n+   *\n+   * @return A description.\n+   */\n+  String getDescription();\n+\n+  /**\n+   * Get all {@link Contributor}s that contributed significantly to the map.\n+   *\n+   * <p>There must be at least 1 author.\n+   *\n+   * @return The authors.\n+   */\n+  Collection<Contributor> getAuthors();\n+\n+  /**\n+   * Get all {@link Contributor}s that helped contribute to the map.\n+   *\n+   * @return The contributors.\n+   */\n+  Collection<Contributor> getContributors();\n+\n+  /**\n+   * Get any special rules that players must follow for the map.\n+   *\n+   * <p>Keep these to a minimum, it is often difficult to enforce these rules.\n+   *\n+   * @return A collection of rules.\n+   */\n+  Collection<String> getRules();\n+\n+  /**\n+   * Get the {@link org.bukkit.Difficulty#ordinal()} level for the map.\n+   *\n+   * @return The difficulty level.\n+   */\n+  int getDifficulty();\n+\n+  /**\n+   * Get a collection of \"hash tags\" used to describe the map.", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjMzMA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370912330", "bodyText": "If it's null why should throw NPE to find bugs easier.", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:04:54Z", "path": "src/main/java/tc/oc/pgm/api/map/MapInfo.java", "diffHunk": "@@ -0,0 +1,113 @@\n+package tc.oc.pgm.api.map;\n+\n+import java.text.Normalizer;\n+import java.util.Collection;\n+import javax.annotation.Nullable;\n+import tc.oc.named.Named;\n+import tc.oc.util.Version;\n+\n+/** Essential information about a map. */\n+public interface MapInfo extends Named, Comparable<MapInfo>, Cloneable {\n+\n+  /**\n+   * Get a unique id for the map.\n+   *\n+   * @return A unique id.\n+   */\n+  String getId();\n+\n+  /**\n+   * Get the proto of the map's {@link org.jdom2.Document}.\n+   *\n+   * @see MapProtos\n+   * @return The proto.\n+   */\n+  Version getProto();\n+\n+  /**\n+   * Get the version of the map.\n+   *\n+   * @return The version.\n+   */\n+  Version getVersion();\n+\n+  /**\n+   * Get a unique, human-readable name for the map.\n+   *\n+   * @return A name, alphanumeric with spaces are allowed.\n+   */\n+  String getName();\n+\n+  /**\n+   * Get a short, human-readable description of the map's objective.\n+   *\n+   * @return A description.\n+   */\n+  String getDescription();\n+\n+  /**\n+   * Get all {@link Contributor}s that contributed significantly to the map.\n+   *\n+   * <p>There must be at least 1 author.\n+   *\n+   * @return The authors.\n+   */\n+  Collection<Contributor> getAuthors();\n+\n+  /**\n+   * Get all {@link Contributor}s that helped contribute to the map.\n+   *\n+   * @return The contributors.\n+   */\n+  Collection<Contributor> getContributors();\n+\n+  /**\n+   * Get any special rules that players must follow for the map.\n+   *\n+   * <p>Keep these to a minimum, it is often difficult to enforce these rules.\n+   *\n+   * @return A collection of rules.\n+   */\n+  Collection<String> getRules();\n+\n+  /**\n+   * Get the {@link org.bukkit.Difficulty#ordinal()} level for the map.\n+   *\n+   * @return The difficulty level.\n+   */\n+  int getDifficulty();\n+\n+  /**\n+   * Get a collection of \"hash tags\" used to describe the map.\n+   *\n+   * @return A collection of tags.\n+   */\n+  Collection<MapTag> getTags();\n+\n+  /**\n+   * Get the maximum number of players that can participate on each team.\n+   *\n+   * @return Maximum number of players on each team.\n+   */\n+  Collection<Integer> getMaxPlayers();\n+\n+  /**\n+   * Create an immutable copy of this info.\n+   *\n+   * @return A cloned {@link MapInfo}.\n+   */\n+  MapInfo clone();\n+\n+  @Override\n+  default int compareTo(MapInfo o) {\n+    return getId().compareTo(o.getId());\n+  }\n+\n+  static String normalizeName(@Nullable String idOrName) {\n+    return idOrName == null\n+        ? \"\"", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkzMTAzMA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370931030", "bodyText": "Since it's @Nullable, i assume if you use the /map without map argument it will get thru this and then if the result is an empty string will get replaced with the current map.", "author": "Pablete1234", "createdAt": "2020-01-25T12:29:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjMzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjQ4NQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370912485", "bodyText": "We should deprecate these three parsers and explain why they shouldn't be here imho.", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:09:51Z", "path": "src/main/java/tc/oc/pgm/api/map/factory/MapFactory.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package tc.oc.pgm.api.map.factory;\n+\n+import tc.oc.pgm.api.map.MapContext;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.exception.MapException;\n+import tc.oc.pgm.api.module.ModuleContext;\n+import tc.oc.pgm.features.FeatureDefinitionContext;\n+import tc.oc.pgm.filters.FilterParser;\n+import tc.oc.pgm.kits.KitParser;\n+import tc.oc.pgm.regions.RegionParser;\n+import tc.oc.util.Version;\n+\n+/** A factory for creating {@link MapInfo}s and {@link MapContext}s. */\n+public interface MapFactory extends ModuleContext<MapModule>, AutoCloseable {\n+\n+  RegionParser getRegions();\n+\n+  FilterParser getFilters();\n+\n+  KitParser getKits();", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mzk2Mw==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943963", "bodyText": "It's too widely used at this point. But I'll add some descriptions.", "author": "Electroid", "createdAt": "2020-01-25T17:01:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjgxMA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370912810", "bodyText": "This match field will now pop up in each MatchModule implementation. We should have MatchModule.Impl with this to keep it DRY.", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:18:37Z", "path": "src/main/java/tc/oc/pgm/blockdrops/BlockDropsMatchModule.java", "diffHunk": "@@ -52,9 +52,10 @@\n   // die that do not fire an event e.g. the tick age limit, but this should be\n   // rare and they will only leak until the end of the match.\n   private final Set<FallingBlock> fallingBlocksThatWillNotLand = new HashSet<>();\n+  private final Match match;", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mzk0NQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943945", "bodyText": "There are some MatchModules that don't even need a Match reference. They just use event listeners. Not really nessecary.", "author": "Electroid", "createdAt": "2020-01-25T17:00:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMjgxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzAyNg==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913026", "bodyText": "Keep that * import :P", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:23:50Z", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -1,16 +1,15 @@\n package tc.oc.pgm.commands;\n \n-import static com.google.common.base.Preconditions.*;\n+import static com.google.common.base.Preconditions.checkNotNull;", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0MzkwMQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943901", "bodyText": "? It's just the google syntax cleaner.", "author": "Electroid", "createdAt": "2020-01-25T17:00:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzExOA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913118", "bodyText": "The previous syntax was way easier imo. Just /maps #many #tags instead of commas, dashes and other difficult combinations you need to do to put multiple maptags.", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:26:31Z", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -27,43 +26,53 @@\n import tc.oc.pgm.AllTranslations;\n import tc.oc.pgm.api.Permissions;\n import tc.oc.pgm.api.chat.Audience;\n-import tc.oc.pgm.api.match.MatchManager;\n+import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapLibrary;\n+import tc.oc.pgm.api.map.MapTag;\n import tc.oc.pgm.commands.annotations.Text;\n-import tc.oc.pgm.map.Contributor;\n-import tc.oc.pgm.map.MapInfo;\n-import tc.oc.pgm.map.MapLibrary;\n-import tc.oc.pgm.map.MapPersistentContext;\n-import tc.oc.pgm.map.PGMMap;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.maptag.MapTagsCondition;\n+import tc.oc.pgm.rotation.MapOrder;\n import tc.oc.pgm.util.PrettyPaginatedResult;\n import tc.oc.util.components.ComponentUtils;\n import tc.oc.util.components.Components;\n \n public class MapCommands {\n \n+  @Command(\n+      aliases = {\"loadnewmaps\"},\n+      desc = \"Loads new maps and outputs any errors\")\n+  public static void loadNewMaps(MapLibrary library, @Switch('f') boolean force) {\n+    library.loadNewMaps(force); // MapLibrary will handle sending output asynchronously\n+  }\n+\n   @Command(\n       aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[-a <author>] [-p <page>] [[!]#<maptag>...]\",\n+      usage = \"[-a <author>] [-p <page>] [-# <tag1>,<tag2>]\",", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzIxMw==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913213", "bodyText": "This should fix the page number input I think? Also doing flags for maptags which always start with # isn't obvious to end-user.", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:30:02Z", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -27,43 +26,53 @@\n import tc.oc.pgm.AllTranslations;\n import tc.oc.pgm.api.Permissions;\n import tc.oc.pgm.api.chat.Audience;\n-import tc.oc.pgm.api.match.MatchManager;\n+import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapLibrary;\n+import tc.oc.pgm.api.map.MapTag;\n import tc.oc.pgm.commands.annotations.Text;\n-import tc.oc.pgm.map.Contributor;\n-import tc.oc.pgm.map.MapInfo;\n-import tc.oc.pgm.map.MapLibrary;\n-import tc.oc.pgm.map.MapPersistentContext;\n-import tc.oc.pgm.map.PGMMap;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.maptag.MapTagsCondition;\n+import tc.oc.pgm.rotation.MapOrder;\n import tc.oc.pgm.util.PrettyPaginatedResult;\n import tc.oc.util.components.ComponentUtils;\n import tc.oc.util.components.Components;\n \n public class MapCommands {\n \n+  @Command(\n+      aliases = {\"loadnewmaps\"},\n+      desc = \"Loads new maps and outputs any errors\")\n+  public static void loadNewMaps(MapLibrary library, @Switch('f') boolean force) {\n+    library.loadNewMaps(force); // MapLibrary will handle sending output asynchronously\n+  }\n+\n   @Command(\n       aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[-a <author>] [-p <page>] [[!]#<maptag>...]\",\n+      usage = \"[-a <author>] [-p <page>] [-# <tag1>,<tag2>]\",\n       help =\n           \"Shows all the maps that are currently loaded including ones that are not in the rotation.\")\n   public static void maplist(\n       Audience audience,\n       CommandSender sender,\n       MapLibrary library,\n-      MapTagsCondition mapTags,\n+      @Fallback(Type.NULL) @Switch('t') String tags,", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDExNQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944115", "bodyText": "Yea, will remove the -p, because everyone was just using /maps N", "author": "Electroid", "createdAt": "2020-01-25T17:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzM2Mw==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913363", "bodyText": "People can no longer negate maptags as @Pablete1234 suggested me to do. Let's say if people would want to search for all DTM maps except the ones mixed with cores (SSB) - /maps #monument !#core", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:33:15Z", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -27,43 +26,53 @@\n import tc.oc.pgm.AllTranslations;\n import tc.oc.pgm.api.Permissions;\n import tc.oc.pgm.api.chat.Audience;\n-import tc.oc.pgm.api.match.MatchManager;\n+import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapLibrary;\n+import tc.oc.pgm.api.map.MapTag;\n import tc.oc.pgm.commands.annotations.Text;\n-import tc.oc.pgm.map.Contributor;\n-import tc.oc.pgm.map.MapInfo;\n-import tc.oc.pgm.map.MapLibrary;\n-import tc.oc.pgm.map.MapPersistentContext;\n-import tc.oc.pgm.map.PGMMap;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.maptag.MapTagsCondition;\n+import tc.oc.pgm.rotation.MapOrder;\n import tc.oc.pgm.util.PrettyPaginatedResult;\n import tc.oc.util.components.ComponentUtils;\n import tc.oc.util.components.Components;\n \n public class MapCommands {\n \n+  @Command(\n+      aliases = {\"loadnewmaps\"},\n+      desc = \"Loads new maps and outputs any errors\")\n+  public static void loadNewMaps(MapLibrary library, @Switch('f') boolean force) {\n+    library.loadNewMaps(force); // MapLibrary will handle sending output asynchronously\n+  }\n+\n   @Command(\n       aliases = {\"maplist\", \"maps\", \"ml\"},\n       desc = \"Shows the maps that are currently loaded\",\n-      usage = \"[-a <author>] [-p <page>] [[!]#<maptag>...]\",\n+      usage = \"[-a <author>] [-p <page>] [-# <tag1>,<tag2>]\",\n       help =\n           \"Shows all the maps that are currently loaded including ones that are not in the rotation.\")\n   public static void maplist(\n       Audience audience,\n       CommandSender sender,\n       MapLibrary library,\n-      MapTagsCondition mapTags,\n+      @Fallback(Type.NULL) @Switch('t') String tags,\n       @Fallback(Type.NULL) @Switch('a') String author,\n       @Fallback(Type.NULL) @Switch('p') Integer page)\n       throws CommandException {\n     if (page == null) page = 1;\n \n-    Stream<PGMMap> search = library.getMaps().stream().filter(mapTags);\n+    Stream<MapInfo> search = Sets.newHashSet(library.getMaps()).stream();\n+    if (tags != null) {\n+      final Set<String> tagSet =\n+          Stream.of(tags.split(\",\")).map(String::trim).collect(Collectors.toSet());\n+      search = search.filter(map -> matchesTags(map, tagSet));", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzQyMA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913420", "bodyText": "tags aren't always lower case, getId() is.", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:35:26Z", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -73,20 +82,30 @@ public static void maplist(\n     String listHeader =\n         ComponentUtils.horizontalLineHeading(title, ChatColor.BLUE, ComponentUtils.MAX_CHAT_WIDTH);\n \n-    new PrettyPaginatedResult<PGMMap>(listHeader, resultsPerPage) {\n+    new PrettyPaginatedResult<MapInfo>(listHeader, resultsPerPage) {\n       @Override\n-      public String format(PGMMap map, int index) {\n-        return (index + 1) + \". \" + map.getInfo().getShortDescription(sender);\n+      public String format(MapInfo map, int index) {\n+        return (index + 1) + \". \" + map.getStyledName(NameStyle.FANCY).toLegacyText();\n       }\n     }.display(audience, ImmutableSortedSet.copyOf(maps), page);\n   }\n \n-  private static boolean matchesAuthor(PGMMap map, String query) {\n+  private static boolean matchesTags(MapInfo map, Set<String> tags) {\n+    if (checkNotNull(tags).isEmpty()) return true;\n+    for (MapTag tag : checkNotNull(map).getTags()) {\n+      if (tags.contains(tag.getId())) {", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzUwNg==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913506", "bodyText": "I think this should be translatable? I guess in Arabic you should have v1.0 Airship Battle since they read right-to-left.", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:37:42Z", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -97,144 +116,113 @@ private static boolean matchesAuthor(PGMMap map, String query) {\n       aliases = {\"mapinfo\", \"map\"},\n       desc = \"Shows information a certain map\",\n       usage = \"[map name] - defaults to the current map\")\n-  public void map(Audience audience, CommandSender sender, @Text PGMMap map) {\n-    MapInfo mapInfo = map.getInfo();\n-    audience.sendMessage(mapInfo.getFormattedMapTitle());\n-\n-    MapPersistentContext persistentContext = map.getPersistentContext();\n-\n-    Component edition = new PersonalizedText(mapInfo.getLocalizedEdition(), ChatColor.GOLD);\n-    if (!edition.toPlainText().isEmpty()) {\n-      audience.sendMessage(\n-          new PersonalizedText(mapInfoLabel(\"command.map.mapInfo.edition\"), edition));\n-    }\n+  public void map(Audience audience, CommandSender sender, @Text MapInfo map) {\n+    audience.sendMessage(\n+        ComponentUtils.horizontalLineHeading(\n+            ChatColor.DARK_AQUA\n+                + map.getName()\n+                + \" \"\n+                + ChatColor.GRAY\n+                + map.getVersion().toString(),", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDE3Mw==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944173", "bodyText": "Sure, but not a high priority.", "author": "Electroid", "createdAt": "2020-01-25T17:05:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzUwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NjI3MQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370946271", "bodyText": "Leave a todo there so we don't forget it when we migrate to text library.", "author": "TheMolkaPL", "createdAt": "2020-01-25T17:49:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzYxMw==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913613", "bodyText": "Instead of putting # here we should call toString() instead.", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:40:15Z", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -97,144 +116,113 @@ private static boolean matchesAuthor(PGMMap map, String query) {\n       aliases = {\"mapinfo\", \"map\"},\n       desc = \"Shows information a certain map\",\n       usage = \"[map name] - defaults to the current map\")\n-  public void map(Audience audience, CommandSender sender, @Text PGMMap map) {\n-    MapInfo mapInfo = map.getInfo();\n-    audience.sendMessage(mapInfo.getFormattedMapTitle());\n-\n-    MapPersistentContext persistentContext = map.getPersistentContext();\n-\n-    Component edition = new PersonalizedText(mapInfo.getLocalizedEdition(), ChatColor.GOLD);\n-    if (!edition.toPlainText().isEmpty()) {\n-      audience.sendMessage(\n-          new PersonalizedText(mapInfoLabel(\"command.map.mapInfo.edition\"), edition));\n-    }\n+  public void map(Audience audience, CommandSender sender, @Text MapInfo map) {\n+    audience.sendMessage(\n+        ComponentUtils.horizontalLineHeading(\n+            ChatColor.DARK_AQUA\n+                + map.getName()\n+                + \" \"\n+                + ChatColor.GRAY\n+                + map.getVersion().toString(),\n+            ChatColor.RED));\n \n     audience.sendMessage(\n         new PersonalizedText(\n             mapInfoLabel(\"command.map.mapInfo.objective\"),\n-            new PersonalizedText(mapInfo.objective, ChatColor.GOLD)));\n+            new PersonalizedText(map.getDescription(), ChatColor.GOLD)));\n \n-    List<Contributor> authors = mapInfo.getNamedAuthors();\n+    Collection<Contributor> authors = map.getAuthors();\n     if (authors.size() == 1) {\n       audience.sendMessage(\n           new PersonalizedText(\n               mapInfoLabel(\"command.map.mapInfo.authorSingular\"),\n-              formatContribution(authors.get(0))));\n+              formatContribution(authors.iterator().next())));\n     } else {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.authorPlural\"));\n       for (Contributor author : authors) {\n         audience.sendMessage(new PersonalizedText(\"  \").extra(formatContribution(author)));\n       }\n     }\n \n-    List<Contributor> contributors = mapInfo.getNamedContributors();\n+    Collection<Contributor> contributors = map.getContributors();\n     if (!contributors.isEmpty()) {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.contributors\"));\n       for (Contributor contributor : contributors) {\n         audience.sendMessage(new PersonalizedText(\"  \").extra(formatContribution(contributor)));\n       }\n     }\n \n-    if (mapInfo.rules.size() > 0) {\n+    if (!map.getRules().isEmpty()) {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.rules\"));\n \n-      for (int i = 0; i < mapInfo.rules.size(); i++) {\n+      int i = 0;\n+      for (String rule : map.getRules()) {\n         audience.sendMessage(\n             new PersonalizedText(\n-                new PersonalizedText((i + 1) + \") \", ChatColor.WHITE),\n-                new PersonalizedText(mapInfo.rules.get(i), ChatColor.GOLD)));\n+                new PersonalizedText(++i + \") \", ChatColor.WHITE),\n+                new PersonalizedText(rule, ChatColor.GOLD)));\n       }\n     }\n \n     audience.sendMessage(\n         new PersonalizedText(\n             mapInfoLabel(\"command.map.mapInfo.playerLimit\"),\n-            createPlayerLimitComponent(sender, persistentContext)));\n+            createPlayerLimitComponent(sender, map)));\n \n     if (sender.hasPermission(Permissions.DEBUG)) {\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.genre\"),\n-              new PersonalizedText(mapInfo.getLocalizedGenre(), ChatColor.GOLD)));\n       audience.sendMessage(\n           new PersonalizedText(\n               mapInfoLabel(\"command.map.mapInfo.proto\"),\n-              new PersonalizedText(mapInfo.proto.toString(), ChatColor.GOLD)));\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.folder\"),\n-              new PersonalizedText(map.getFolder().getRelativePath().toString(), ChatColor.GOLD)));\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.source\"),\n-              new PersonalizedText(map.getSource().getPath().toString(), ChatColor.GOLD)));\n+              new PersonalizedText(map.getProto().toString(), ChatColor.GOLD)));\n     }\n \n-    URL xmlLink = map.getFolder().getDescriptionFileUrl();\n-    if (xmlLink != null) {\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              new PersonalizedText(ChatColor.DARK_PURPLE, ChatColor.BOLD)\n-                  .extra(new PersonalizedTranslatable(\"command.map.mapInfo.xml\"))\n-                  .extra(\": \"),\n-              Components.link(xmlLink)\n-                  .hoverEvent(\n-                      HoverEvent.Action.SHOW_TEXT,\n-                      new PersonalizedTranslatable(\"command.map.mapInfo.sourceCode.tip\")\n-                          .render())));\n-    }\n-\n-    Set<MapTag> mapTags = persistentContext.getMapTags();\n-    audience.sendMessage(createTagsComponent(mapTags).color(ChatColor.YELLOW));\n+    audience.sendMessage(createTagsComponent(map.getTags()));\n   }\n \n-  private static Component createTagsComponent(Set<MapTag> tags) {\n+  private Component createTagsComponent(Collection<MapTag> tags) {\n     checkNotNull(tags);\n \n-    Component result = new PersonalizedText();\n+    Component result = mapInfoLabel(\"command.map.mapInfo.tags\");\n     MapTag[] mapTags = tags.toArray(new MapTag[0]);\n     for (int i = 0; i < mapTags.length; i++) {\n       if (i != 0) {\n         result.extra(Components.space());\n       }\n \n-      MapTag mapTag = mapTags[i];\n+      String mapTag = mapTags[i].getId();\n       Component component =\n-          mapTags[i]\n-              .getComponentName()\n-              .clickEvent(ClickEvent.Action.RUN_COMMAND, \"/maplist \" + mapTag.toString())\n+          new PersonalizedText(\"#\" + mapTag, ChatColor.GOLD)", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzY2MQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913661", "bodyText": "BTW, maptags in voting books are yellow so I would keep them yellow here too for consistency.", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:41:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzYxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDIyOQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944229", "bodyText": "I made them gold to keep the output consistent in /map. So might look at the voting book too.", "author": "Electroid", "createdAt": "2020-01-25T17:06:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzYxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzc0OQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913749", "bodyText": "/maps is an alias to /maplist so I would keep /maplist here. :P", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:44:13Z", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -97,144 +116,113 @@ private static boolean matchesAuthor(PGMMap map, String query) {\n       aliases = {\"mapinfo\", \"map\"},\n       desc = \"Shows information a certain map\",\n       usage = \"[map name] - defaults to the current map\")\n-  public void map(Audience audience, CommandSender sender, @Text PGMMap map) {\n-    MapInfo mapInfo = map.getInfo();\n-    audience.sendMessage(mapInfo.getFormattedMapTitle());\n-\n-    MapPersistentContext persistentContext = map.getPersistentContext();\n-\n-    Component edition = new PersonalizedText(mapInfo.getLocalizedEdition(), ChatColor.GOLD);\n-    if (!edition.toPlainText().isEmpty()) {\n-      audience.sendMessage(\n-          new PersonalizedText(mapInfoLabel(\"command.map.mapInfo.edition\"), edition));\n-    }\n+  public void map(Audience audience, CommandSender sender, @Text MapInfo map) {\n+    audience.sendMessage(\n+        ComponentUtils.horizontalLineHeading(\n+            ChatColor.DARK_AQUA\n+                + map.getName()\n+                + \" \"\n+                + ChatColor.GRAY\n+                + map.getVersion().toString(),\n+            ChatColor.RED));\n \n     audience.sendMessage(\n         new PersonalizedText(\n             mapInfoLabel(\"command.map.mapInfo.objective\"),\n-            new PersonalizedText(mapInfo.objective, ChatColor.GOLD)));\n+            new PersonalizedText(map.getDescription(), ChatColor.GOLD)));\n \n-    List<Contributor> authors = mapInfo.getNamedAuthors();\n+    Collection<Contributor> authors = map.getAuthors();\n     if (authors.size() == 1) {\n       audience.sendMessage(\n           new PersonalizedText(\n               mapInfoLabel(\"command.map.mapInfo.authorSingular\"),\n-              formatContribution(authors.get(0))));\n+              formatContribution(authors.iterator().next())));\n     } else {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.authorPlural\"));\n       for (Contributor author : authors) {\n         audience.sendMessage(new PersonalizedText(\"  \").extra(formatContribution(author)));\n       }\n     }\n \n-    List<Contributor> contributors = mapInfo.getNamedContributors();\n+    Collection<Contributor> contributors = map.getContributors();\n     if (!contributors.isEmpty()) {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.contributors\"));\n       for (Contributor contributor : contributors) {\n         audience.sendMessage(new PersonalizedText(\"  \").extra(formatContribution(contributor)));\n       }\n     }\n \n-    if (mapInfo.rules.size() > 0) {\n+    if (!map.getRules().isEmpty()) {\n       audience.sendMessage(mapInfoLabel(\"command.map.mapInfo.rules\"));\n \n-      for (int i = 0; i < mapInfo.rules.size(); i++) {\n+      int i = 0;\n+      for (String rule : map.getRules()) {\n         audience.sendMessage(\n             new PersonalizedText(\n-                new PersonalizedText((i + 1) + \") \", ChatColor.WHITE),\n-                new PersonalizedText(mapInfo.rules.get(i), ChatColor.GOLD)));\n+                new PersonalizedText(++i + \") \", ChatColor.WHITE),\n+                new PersonalizedText(rule, ChatColor.GOLD)));\n       }\n     }\n \n     audience.sendMessage(\n         new PersonalizedText(\n             mapInfoLabel(\"command.map.mapInfo.playerLimit\"),\n-            createPlayerLimitComponent(sender, persistentContext)));\n+            createPlayerLimitComponent(sender, map)));\n \n     if (sender.hasPermission(Permissions.DEBUG)) {\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.genre\"),\n-              new PersonalizedText(mapInfo.getLocalizedGenre(), ChatColor.GOLD)));\n       audience.sendMessage(\n           new PersonalizedText(\n               mapInfoLabel(\"command.map.mapInfo.proto\"),\n-              new PersonalizedText(mapInfo.proto.toString(), ChatColor.GOLD)));\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.folder\"),\n-              new PersonalizedText(map.getFolder().getRelativePath().toString(), ChatColor.GOLD)));\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              mapInfoLabel(\"command.map.mapInfo.source\"),\n-              new PersonalizedText(map.getSource().getPath().toString(), ChatColor.GOLD)));\n+              new PersonalizedText(map.getProto().toString(), ChatColor.GOLD)));\n     }\n \n-    URL xmlLink = map.getFolder().getDescriptionFileUrl();\n-    if (xmlLink != null) {\n-      audience.sendMessage(\n-          new PersonalizedText(\n-              new PersonalizedText(ChatColor.DARK_PURPLE, ChatColor.BOLD)\n-                  .extra(new PersonalizedTranslatable(\"command.map.mapInfo.xml\"))\n-                  .extra(\": \"),\n-              Components.link(xmlLink)\n-                  .hoverEvent(\n-                      HoverEvent.Action.SHOW_TEXT,\n-                      new PersonalizedTranslatable(\"command.map.mapInfo.sourceCode.tip\")\n-                          .render())));\n-    }\n-\n-    Set<MapTag> mapTags = persistentContext.getMapTags();\n-    audience.sendMessage(createTagsComponent(mapTags).color(ChatColor.YELLOW));\n+    audience.sendMessage(createTagsComponent(map.getTags()));\n   }\n \n-  private static Component createTagsComponent(Set<MapTag> tags) {\n+  private Component createTagsComponent(Collection<MapTag> tags) {\n     checkNotNull(tags);\n \n-    Component result = new PersonalizedText();\n+    Component result = mapInfoLabel(\"command.map.mapInfo.tags\");\n     MapTag[] mapTags = tags.toArray(new MapTag[0]);\n     for (int i = 0; i < mapTags.length; i++) {\n       if (i != 0) {\n         result.extra(Components.space());\n       }\n \n-      MapTag mapTag = mapTags[i];\n+      String mapTag = mapTags[i].getId();\n       Component component =\n-          mapTags[i]\n-              .getComponentName()\n-              .clickEvent(ClickEvent.Action.RUN_COMMAND, \"/maplist \" + mapTag.toString())\n+          new PersonalizedText(\"#\" + mapTag, ChatColor.GOLD)\n+              .bold(false)\n+              .clickEvent(ClickEvent.Action.RUN_COMMAND, \"/maps -t \" + mapTag)", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDI0Nw==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944247", "bodyText": "/maps is the main command.", "author": "Electroid", "createdAt": "2020-01-25T17:06:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzc0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxMzkyMA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370913920", "bodyText": "We completly have lost tab suggestion for maptags :(", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:49:22Z", "path": "src/main/java/tc/oc/pgm/commands/provider/MapTagsConditionProvider.java", "diffHunk": "@@ -1,108 +0,0 @@\n-package tc.oc.pgm.commands.provider;\n-\n-import static com.google.common.base.Preconditions.*;\n-\n-import app.ashcon.intake.argument.ArgumentException;\n-import app.ashcon.intake.argument.CommandArgs;\n-import app.ashcon.intake.argument.Namespace;\n-import app.ashcon.intake.parametric.Provider;\n-import app.ashcon.intake.parametric.ProvisionException;\n-import java.lang.annotation.Annotation;\n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.Comparator;\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Locale;\n-import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n-import java.util.TreeSet;\n-import javax.annotation.Nullable;\n-import tc.oc.pgm.map.MapLibrary;\n-import tc.oc.pgm.map.PGMMap;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.maptag.MapTagsCondition;\n-import tc.oc.util.Pair;\n-\n-public class MapTagsConditionProvider implements Provider<MapTagsCondition> {\n-\n-  private static final String PREFIX = Character.toString(MapTag.SYMBOL);\n-  private static final String NEGATION = \"!\";\n-\n-  private final MapLibrary mapLibrary;\n-\n-  public MapTagsConditionProvider(MapLibrary mapLibrary) {\n-    this.mapLibrary = checkNotNull(mapLibrary);\n-  }\n-\n-  @Override\n-  public String getName() {\n-    return \"maptags\";\n-  }\n-\n-  @Nullable\n-  @Override\n-  public MapTagsCondition get(CommandArgs args, List<? extends Annotation> list)\n-      throws ArgumentException, ProvisionException {\n-    Map<MapTag, Boolean> mapTags = new HashMap<>();\n-    while (args.hasNext()) {\n-      parseMapTag(args.next())\n-          .ifPresent(\n-              pair -> {\n-                if (!pair.first.isEmpty()) {\n-                  mapTags.put(MapTag.forName(pair.first), pair.second);\n-                }\n-              });\n-    }\n-\n-    return new MapTagsCondition(mapTags);\n-  }\n-\n-  @Override\n-  public List<String> getSuggestions(\n-      String prefix, Namespace namespace, List<? extends Annotation> modifiers) {\n-    return parseMapTag(prefix)\n-        .map(\n-            pair -> {\n-              Set<String> mapTags = new TreeSet<>(Comparator.naturalOrder());\n-              for (PGMMap map : mapLibrary.getMaps()) {\n-                for (MapTag mapTag : map.getPersistentContext().getMapTags()) {\n-                  if (mapTag.getName().startsWith(pair.first)) {\n-                    mapTags.add(mapTagToString(mapTag, pair.second));\n-                  }\n-                }\n-              }\n-\n-              return (List<String>) new ArrayList<>(mapTags);\n-            })\n-        .orElse(Collections.emptyList());\n-  }", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDAxMw==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370914013", "bodyText": "I feel that we should make the description a BaseComponent too. Control The Point should be translatable.", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:51:58Z", "path": "src/main/java/tc/oc/pgm/controlpoint/ControlPointModule.java", "diffHunk": "@@ -2,81 +2,92 @@\n \n import com.google.common.collect.ImmutableList;\n import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedList;\n import java.util.List;\n-import java.util.Set;\n import java.util.logging.Logger;\n import org.jdom2.Document;\n import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.MapTag;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n import tc.oc.pgm.filters.FilterModule;\n import tc.oc.pgm.goals.GoalMatchModule;\n-import tc.oc.pgm.goals.GoalModule;\n-import tc.oc.pgm.map.MapModule;\n-import tc.oc.pgm.map.MapModuleContext;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.module.ModuleDescription;\n import tc.oc.pgm.regions.RegionModule;\n import tc.oc.pgm.teams.TeamModule;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.xml.InvalidXMLException;\n \n-@ModuleDescription(\n-    name = \"Control Points\",\n-    depends = {TeamModule.class, GoalModule.class, RegionModule.class, FilterModule.class})\n-public class ControlPointModule extends MapModule<ControlPointMatchModule> {\n-\n-  private static final MapTag CONTROLPOINT_TAG = MapTag.forName(\"controlpoint\");\n+public class ControlPointModule implements MapModule<ControlPointMatchModule> {\n \n+  private static final Collection<MapTag> TAGS =\n+      ImmutableList.of(MapTag.create(\"controlpoint\", \"Control the Point\", true, false));", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDI1OA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944258", "bodyText": "In the future, not today.", "author": "Electroid", "createdAt": "2020-01-25T17:07:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDAxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDE2NA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370914164", "bodyText": "Why complete removal?", "author": "TheMolkaPL", "createdAt": "2020-01-25T04:56:10Z", "path": "src/main/java/tc/oc/pgm/damage/DisableDamageModule.java", "diffHunk": "@@ -2,73 +2,63 @@\n \n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.SetMultimap;\n-import java.util.Set;\n import java.util.logging.Logger;\n import org.bukkit.event.entity.EntityDamageEvent.DamageCause;\n import org.jdom2.Document;\n import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n import tc.oc.pgm.api.player.PlayerRelation;\n-import tc.oc.pgm.map.MapModule;\n-import tc.oc.pgm.map.MapModuleContext;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.module.ModuleDescription;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.xml.InvalidXMLException;\n import tc.oc.xml.Node;\n \n-@ModuleDescription(name = \"DisableDamage\")\n-public class DisableDamageModule extends MapModule<DisableDamageMatchModule> {\n-\n-  private static final MapTag NOFALLDAMAGE_TAG = MapTag.forName(\"nofalldamage\");\n-\n+public class DisableDamageModule implements MapModule {\n   protected final SetMultimap<DamageCause, PlayerRelation> causes;\n \n   public DisableDamageModule(SetMultimap<DamageCause, PlayerRelation> causes) {\n     this.causes = causes;\n   }\n \n   @Override\n-  public void loadTags(Set<MapTag> tags) {\n-    if (causes.containsKey(DamageCause.FALL)) tags.add(NOFALLDAMAGE_TAG);", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDUxMA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370914510", "bodyText": "Fix the * import, please.", "author": "TheMolkaPL", "createdAt": "2020-01-25T05:05:38Z", "path": "src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java", "diffHunk": "@@ -1,14 +1,13 @@\n package tc.oc.pgm.listeners;\n \n-import static com.google.common.base.Preconditions.*;\n+import static com.google.common.base.Preconditions.checkNotNull;", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDY1MA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370914650", "bodyText": "This is going to break at least OCC website. The slug is used to locate map icons afaik. Can we leave slug here, please?", "author": "TheMolkaPL", "createdAt": "2020-01-25T05:08:57Z", "path": "src/main/java/tc/oc/pgm/listeners/ServerPingDataListener.java", "diffHunk": "@@ -101,40 +101,34 @@ private void serializeMatch(Match match, JsonObject jsonObject) {\n   private void appendNextMap(JsonObject jsonObject) {\n     checkNotNull(jsonObject);\n \n-    PGMMapOrder mapOrder = this.matchManager.getMapOrder();\n-    if (mapOrder != null) {\n-      PGMMap nextMap = mapOrder.getNextMap();\n+    MapInfo nextMap = mapOrder.getNextMap();\n \n-      if (nextMap != null) {\n-        JsonObject nextMapObject = new JsonObject();\n-        this.serializeMap(nextMap, nextMapObject);\n-        jsonObject.add(\"next_map\", nextMapObject);\n-      }\n+    if (nextMap != null) {\n+      JsonObject nextMapObject = new JsonObject();\n+      this.serializeMap(nextMap, nextMapObject);\n+      jsonObject.add(\"next_map\", nextMapObject);\n     }\n   }\n \n-  private void serializeMap(PGMMap map, JsonObject jsonObject) {\n+  private void serializeMap(MapInfo map, JsonObject jsonObject) {\n     checkNotNull(map);\n     checkNotNull(jsonObject);\n \n-    MapInfo mapInfo = map.getInfo();\n-    MapPersistentContext persistentContext = map.getPersistentContext();\n-\n-    jsonObject.addProperty(\"slug\", mapInfo.slug());\n-    jsonObject.addProperty(\"name\", mapInfo.name);\n-    jsonObject.addProperty(\"version\", mapInfo.version.toString());\n-    jsonObject.addProperty(\"objective\", mapInfo.objective);\n+    jsonObject.addProperty(\"id\", map.getId());", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NzIwOQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370947209", "bodyText": "<slug> is becoming <id> so I think we'll have to accept this breaking change.", "author": "Electroid", "createdAt": "2020-01-25T18:07:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDY1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDc5MQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370914791", "bodyText": "Why is this an integer instead of a Difficulty?", "author": "TheMolkaPL", "createdAt": "2020-01-25T05:13:23Z", "path": "src/main/java/tc/oc/pgm/map/MapInfoImpl.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package tc.oc.pgm.map;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.TreeSet;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+import org.bukkit.Difficulty;\n+import org.jdom2.Element;\n+import tc.oc.component.Component;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.AllTranslations;\n+import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapTag;\n+import tc.oc.pgm.map.contrib.PlayerContributor;\n+import tc.oc.pgm.map.contrib.PseudonymContributor;\n+import tc.oc.pgm.util.TranslationUtils;\n+import tc.oc.pgm.util.XMLUtils;\n+import tc.oc.server.NullCommandSender;\n+import tc.oc.util.Version;\n+import tc.oc.xml.InvalidXMLException;\n+import tc.oc.xml.Node;\n+\n+public class MapInfoImpl implements MapInfo {\n+  private static final int DEFAULT_DIFFICULTY = Difficulty.NORMAL.ordinal();\n+\n+  private final String id;\n+  private final Version proto;\n+  private final Version version;\n+  private final String name;\n+  private final String description;\n+  private final Collection<Contributor> authors;\n+  private final Collection<Contributor> contributors;\n+  private final Collection<String> rules;\n+  private final int difficulty;\n+  protected final Collection<MapTag> tags;\n+  protected final Collection<Integer> players;\n+\n+  public MapInfoImpl(\n+      @Nullable String id,\n+      Version proto,\n+      Version version,\n+      String name,\n+      String description,\n+      @Nullable Collection<Contributor> authors,\n+      @Nullable Collection<Contributor> contributors,\n+      @Nullable Collection<String> rules,\n+      @Nullable Integer difficulty,", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDI4MQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944281", "bodyText": "See other comment.", "author": "Electroid", "createdAt": "2020-01-25T17:07:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNDg1NQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370914855", "bodyText": "I think we should make a public static factory method to parse the XML and return a new instance of this class.", "author": "TheMolkaPL", "createdAt": "2020-01-25T05:15:29Z", "path": "src/main/java/tc/oc/pgm/map/MapInfoImpl.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package tc.oc.pgm.map;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.TreeSet;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+import org.bukkit.Difficulty;\n+import org.jdom2.Element;\n+import tc.oc.component.Component;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.AllTranslations;\n+import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapTag;\n+import tc.oc.pgm.map.contrib.PlayerContributor;\n+import tc.oc.pgm.map.contrib.PseudonymContributor;\n+import tc.oc.pgm.util.TranslationUtils;\n+import tc.oc.pgm.util.XMLUtils;\n+import tc.oc.server.NullCommandSender;\n+import tc.oc.util.Version;\n+import tc.oc.xml.InvalidXMLException;\n+import tc.oc.xml.Node;\n+\n+public class MapInfoImpl implements MapInfo {\n+  private static final int DEFAULT_DIFFICULTY = Difficulty.NORMAL.ordinal();\n+\n+  private final String id;\n+  private final Version proto;\n+  private final Version version;\n+  private final String name;\n+  private final String description;\n+  private final Collection<Contributor> authors;\n+  private final Collection<Contributor> contributors;\n+  private final Collection<String> rules;\n+  private final int difficulty;\n+  protected final Collection<MapTag> tags;\n+  protected final Collection<Integer> players;\n+\n+  public MapInfoImpl(\n+      @Nullable String id,\n+      Version proto,\n+      Version version,\n+      String name,\n+      String description,\n+      @Nullable Collection<Contributor> authors,\n+      @Nullable Collection<Contributor> contributors,\n+      @Nullable Collection<String> rules,\n+      @Nullable Integer difficulty,\n+      @Nullable Collection<MapTag> tags,\n+      @Nullable Collection<Integer> players) {\n+    this.name = checkNotNull(name);\n+    this.id = checkNotNull(MapInfo.normalizeName(id == null ? name : id));\n+    this.proto = checkNotNull(proto);\n+    this.version = checkNotNull(version);\n+    this.description = checkNotNull(description);\n+    this.authors = authors == null ? new LinkedList<>() : authors;\n+    this.contributors = contributors == null ? new LinkedList<>() : contributors;\n+    this.rules = rules == null ? new LinkedList<>() : rules;\n+    this.difficulty = difficulty == null ? DEFAULT_DIFFICULTY : difficulty;\n+    this.tags = tags == null ? new TreeSet<>() : tags;\n+    this.players = players == null ? new LinkedList<>() : players;\n+  }\n+\n+  public MapInfoImpl(MapInfo info) {\n+    this(\n+        checkNotNull(info).getId(),\n+        info.getProto(),\n+        info.getVersion(),\n+        info.getName(),\n+        info.getDescription(),\n+        info.getAuthors(),\n+        info.getContributors(),\n+        info.getRules(),\n+        info.getDifficulty(),\n+        info.getTags(),\n+        info.getMaxPlayers());\n+  }\n+\n+  public MapInfoImpl(Element root) throws InvalidXMLException {", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNTMxOQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370915319", "bodyText": "I called this SYMBOL originally because all these different special characters (mainly on scoreboard) were called SYMBOLs.", "author": "TheMolkaPL", "createdAt": "2020-01-25T05:29:23Z", "path": "src/main/java/tc/oc/pgm/map/MapTagImpl.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package tc.oc.pgm.map;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import tc.oc.pgm.api.map.MapTag;\n+\n+public class MapTagImpl implements MapTag {\n+\n+  private static final String HASHTAG = \"#\";", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNTQ0OA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370915448", "bodyText": "We lost the regex pattern to validate if the maptag was in lower case, between a-z, 0-9, with - or _. This is public and people from outside can create new instances of this class with illegal characters which will potentially lead to bugs.", "author": "TheMolkaPL", "createdAt": "2020-01-25T05:32:42Z", "path": "src/main/java/tc/oc/pgm/map/MapTagImpl.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package tc.oc.pgm.map;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import tc.oc.pgm.api.map.MapTag;\n+\n+public class MapTagImpl implements MapTag {\n+\n+  private static final String HASHTAG = \"#\";\n+  private final String id;\n+  private final String name;\n+  private final boolean gamemode;\n+  private final boolean auxiliary;\n+\n+  public MapTagImpl(String id, String name, boolean gamemode, boolean auxiliary) {\n+    this.id = checkNotNull(id);", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNTU3NA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370915574", "bodyText": "getName() and getDescription() maybe?", "author": "TheMolkaPL", "createdAt": "2020-01-25T05:36:26Z", "path": "src/main/java/tc/oc/pgm/api/map/MapTag.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package tc.oc.pgm.api.map;\n+\n+import tc.oc.pgm.map.MapTagImpl;\n+\n+/** A \"#hashtag\" that describes a {@link MapInfo} feature. */\n+public interface MapTag extends Comparable<MapTag> {\n+\n+  /**\n+   * Get a short id for the tag.\n+   *\n+   * @return A short, lowercase id without the \"#\".\n+   */\n+  String getId();\n+\n+  /**\n+   * Get a full name for the tag.\n+   *\n+   * @return A full name.\n+   */\n+  String getName();", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDkxNTY2MQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370915661", "bodyText": "Bukkit.getDifficulty()?", "author": "TheMolkaPL", "createdAt": "2020-01-25T05:39:09Z", "path": "src/main/java/tc/oc/pgm/map/MapInfoImpl.java", "diffHunk": "@@ -0,0 +1,238 @@\n+package tc.oc.pgm.map;\n+\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.TreeSet;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+import javax.annotation.Nullable;\n+import net.md_5.bungee.api.ChatColor;\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+import org.bukkit.Difficulty;\n+import org.jdom2.Element;\n+import tc.oc.component.Component;\n+import tc.oc.component.types.PersonalizedText;\n+import tc.oc.named.NameStyle;\n+import tc.oc.pgm.AllTranslations;\n+import tc.oc.pgm.api.map.Contributor;\n+import tc.oc.pgm.api.map.MapInfo;\n+import tc.oc.pgm.api.map.MapTag;\n+import tc.oc.pgm.map.contrib.PlayerContributor;\n+import tc.oc.pgm.map.contrib.PseudonymContributor;\n+import tc.oc.pgm.util.TranslationUtils;\n+import tc.oc.pgm.util.XMLUtils;\n+import tc.oc.server.NullCommandSender;\n+import tc.oc.util.Version;\n+import tc.oc.xml.InvalidXMLException;\n+import tc.oc.xml.Node;\n+\n+public class MapInfoImpl implements MapInfo {\n+  private static final int DEFAULT_DIFFICULTY = Difficulty.NORMAL.ordinal();\n+\n+  private final String id;\n+  private final Version proto;\n+  private final Version version;\n+  private final String name;\n+  private final String description;\n+  private final Collection<Contributor> authors;\n+  private final Collection<Contributor> contributors;\n+  private final Collection<String> rules;\n+  private final int difficulty;\n+  protected final Collection<MapTag> tags;\n+  protected final Collection<Integer> players;\n+\n+  public MapInfoImpl(\n+      @Nullable String id,\n+      Version proto,\n+      Version version,\n+      String name,\n+      String description,\n+      @Nullable Collection<Contributor> authors,\n+      @Nullable Collection<Contributor> contributors,\n+      @Nullable Collection<String> rules,\n+      @Nullable Integer difficulty,\n+      @Nullable Collection<MapTag> tags,\n+      @Nullable Collection<Integer> players) {\n+    this.name = checkNotNull(name);\n+    this.id = checkNotNull(MapInfo.normalizeName(id == null ? name : id));\n+    this.proto = checkNotNull(proto);\n+    this.version = checkNotNull(version);\n+    this.description = checkNotNull(description);\n+    this.authors = authors == null ? new LinkedList<>() : authors;\n+    this.contributors = contributors == null ? new LinkedList<>() : contributors;\n+    this.rules = rules == null ? new LinkedList<>() : rules;\n+    this.difficulty = difficulty == null ? DEFAULT_DIFFICULTY : difficulty;\n+    this.tags = tags == null ? new TreeSet<>() : tags;\n+    this.players = players == null ? new LinkedList<>() : players;\n+  }\n+\n+  public MapInfoImpl(MapInfo info) {\n+    this(\n+        checkNotNull(info).getId(),\n+        info.getProto(),\n+        info.getVersion(),\n+        info.getName(),\n+        info.getDescription(),\n+        info.getAuthors(),\n+        info.getContributors(),\n+        info.getRules(),\n+        info.getDifficulty(),\n+        info.getTags(),\n+        info.getMaxPlayers());\n+  }\n+\n+  public MapInfoImpl(Element root) throws InvalidXMLException {\n+    this(\n+        checkNotNull(root).getChildTextNormalize(\"slug\"),\n+        XMLUtils.parseSemanticVersion(Node.fromRequiredAttr(root, \"proto\")),\n+        XMLUtils.parseSemanticVersion(Node.fromRequiredChildOrAttr(root, \"version\")),\n+        Node.fromRequiredChildOrAttr(root, \"name\").getValueNormalize(),\n+        Node.fromRequiredChildOrAttr(root, \"objective\", \"description\").getValueNormalize(),\n+        parseContributors(root, \"author\"),\n+        parseContributors(root, \"contributor\"),\n+        parseRules(root),\n+        XMLUtils.parseEnum(\n+                Node.fromLastChildOrAttr(root, \"difficulty\"),\n+                Difficulty.class,\n+                \"difficulty\",\n+                Difficulty.NORMAL)", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mjg4MQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370942881", "bodyText": "I think this should count sum()?", "author": "TheMolkaPL", "createdAt": "2020-01-25T16:41:05Z", "path": "src/main/java/tc/oc/pgm/match/MatchImpl.java", "diffHunk": "@@ -131,7 +134,8 @@ protected MatchImpl(String id, PGMMap map, World world) {\n     this.state = new AtomicReference<>(MatchPhase.IDLE);\n     this.start = new AtomicLong(0);\n     this.end = new AtomicLong(0);\n-    this.capacity = new AtomicInteger(map.getPersistentContext().getTotalMaxPlayers());\n+    this.capacity =\n+        new AtomicInteger(map.getMaxPlayers().stream().findFirst().orElse(Bukkit.getMaxPlayers()));", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDM0OA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944348", "bodyText": "Ah yes, nice catch.", "author": "Electroid", "createdAt": "2020-01-25T17:09:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mjg4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mjk2MA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370942960", "bodyText": "If the world is null throw NPE for finding bugs easier?", "author": "TheMolkaPL", "createdAt": "2020-01-25T16:42:37Z", "path": "src/main/java/tc/oc/pgm/match/MatchManagerImpl.java", "diffHunk": "@@ -1,433 +1,206 @@\n package tc.oc.pgm.match;\n \n-import com.google.common.cache.*;\n-import com.google.common.collect.ImmutableSet;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.common.collect.Iterables;\n import java.io.File;\n import java.io.IOException;\n-import java.nio.file.Path;\n-import java.util.Collection;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.List;\n import java.util.Map;\n-import java.util.Optional;\n-import java.util.Set;\n+import java.util.concurrent.CompletableFuture;\n import java.util.concurrent.ConcurrentHashMap;\n-import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.Future;\n import java.util.concurrent.TimeUnit;\n-import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.concurrent.atomic.AtomicLong;\n import java.util.logging.Level;\n import java.util.logging.Logger;\n-import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n-import org.bukkit.*;\n+import org.bukkit.Difficulty;\n+import org.bukkit.Server;\n+import org.bukkit.World;\n+import org.bukkit.WorldCreator;\n import org.bukkit.entity.Player;\n-import tc.oc.pgm.Config;\n+import org.joda.time.Duration;\n+import tc.oc.chunk.NullChunkGenerator;\n import tc.oc.pgm.api.PGM;\n import tc.oc.pgm.api.chat.Audience;\n-import tc.oc.pgm.api.chat.MultiAudience;\n+import tc.oc.pgm.api.map.MapContext;\n+import tc.oc.pgm.api.map.exception.MapMissingException;\n import tc.oc.pgm.api.match.Match;\n import tc.oc.pgm.api.match.MatchManager;\n+import tc.oc.pgm.api.match.factory.MatchFactory;\n import tc.oc.pgm.api.player.MatchPlayer;\n-import tc.oc.pgm.map.*;\n-import tc.oc.pgm.module.ModuleLoadException;\n-import tc.oc.pgm.rotation.PGMMapOrder;\n-import tc.oc.pgm.terrain.TerrainModule;\n+import tc.oc.server.Scheduler;\n+import tc.oc.util.ClassLogger;\n import tc.oc.util.FileUtils;\n-import tc.oc.util.logging.ClassLogger;\n-import tc.oc.world.NMSHacks;\n \n-@SuppressWarnings(\"UnstableApiUsage\")\n-public class MatchManagerImpl implements MatchManager, MultiAudience {\n+public class MatchManagerImpl implements MatchFactory, MatchManager {\n+\n+  private static final Duration TIMEOUT = Duration.standardSeconds(30);\n \n   private final Logger logger;\n   private final Server server;\n-  private final MapLibrary library;\n-  private final MapLoader loader;\n-\n-  private final Map<String, Match> matchById = new ConcurrentHashMap<>();\n-  private final Map<String, String> matchIdByWorldName = new HashMap<>();\n-  private final LoadingCache<PGMMap, String> preMatch =\n-      CacheBuilder.newBuilder()\n-          .expireAfterWrite(10, TimeUnit.SECONDS)\n-          // If after 10 secs of writing the match it hasn't been loaded, unload & destroy it\n-          .removalListener(\n-              (RemovalNotification<PGMMap, String> r) -> {\n-                if (!matchById.get(r.getValue()).isLoaded()) unloadMatch(r.getValue());\n-              })\n-          .concurrencyLevel(1)\n-          .build(\n-              new CacheLoader<PGMMap, String>() {\n-                @Override\n-                public String load(@Nonnull PGMMap pgmMap) throws Exception {\n-                  return createPreMatch(pgmMap).getId();\n-                }\n-              });\n-  private final AtomicInteger count;\n-\n-  private PGMMapOrder pgmMapOrder;\n-\n-  public MatchManagerImpl(Server server, MapLibrary library, MapLoader loader)\n-      throws MapNotFoundException {\n-    this.logger = ClassLogger.get(PGM.get().getLogger(), getClass());\n-    this.server = server;\n-    this.library = library;\n-    this.loader = loader;\n-    this.count = new AtomicInteger(0);\n-\n-    loadNewMaps();\n-  }\n-\n-  public void createPreMatchAsync(final PGMMap map) {\n-    logger.fine(\"Creating pre-match for \" + map.getName() + \" async\");\n-    PGM.get()\n-        .getServer()\n-        .getScheduler()\n-        .runTaskAsynchronously(\n-            PGM.get(),\n-            () -> {\n-              try {\n-                preMatch.get(map);\n-                PGM.get()\n-                    .getLogger()\n-                    .fine(\"Done creating pre-match for \" + map.getName() + \" async\");\n-              } catch (Throwable t) {\n-                throw new RuntimeException(t);\n-              }\n-            });\n-  }\n-\n-  /**\n-   * Pre-creates a match, without loading it. Can and should be done async unless a /cycle 0 is\n-   * done.\n-   *\n-   * @param map The map to generate a pre-match for\n-   * @return The created pre-match\n-   * @throws Exception If the match fails to be generated\n-   */\n-  private Match createPreMatch(PGMMap map) throws Exception {\n-    logger.fine(\"Creating pre-match for \" + map.getName());\n-    String id = Integer.toString(count.getAndIncrement());\n-\n-    if (!map.getContext().isPresent()) {\n-      map.reload(true);\n-    }\n-\n-    final TerrainModule terrain = map.getContext().get().needModule(TerrainModule.class);\n-    final File src = terrain.getWorldFolder();\n+  private final Scheduler scheduler;\n \n-    final String worldName = createMatchFolder(id, src);\n-    final World world = createMatchWorld(worldName, map.getInfo(), terrain);\n+  private final AtomicLong matches;\n+  private final Map<String, Match> matchById;\n+  private final Map<String, Match> matchByWorld;\n \n-    final Match match = new MatchImpl(id, map, world);\n-\n-    matchById.put(match.getId(), match);\n-    matchIdByWorldName.put(match.getWorld().getName(), match.getId());\n-\n-    logger.fine(\"Done creating pre-match for \" + map.getName());\n-    return match;\n+  public MatchManagerImpl(Logger logger, Server server) {\n+    this.logger = ClassLogger.get(checkNotNull(logger), getClass());\n+    this.server = checkNotNull(server);\n+    this.scheduler = new Scheduler(PGM.get());\n+    this.matches = new AtomicLong(0);\n+    this.matchById = new ConcurrentHashMap<>();\n+    this.matchByWorld = new ConcurrentHashMap<>();\n   }\n \n   @Override\n-  public Match createMatch(PGMMap map) throws Throwable {\n-    final Match match = matchById.get(preMatch.get(map));\n-\n-    try {\n-      match.load();\n-    } catch (Throwable t) {\n-      unloadMatch(match.getId());\n-      throw t;\n-    } finally {\n-      // Remove all preMatches, since we already loaded one\n-      preMatch.invalidateAll();\n-    }\n-\n-    return match;\n-  }\n-\n-  private String createMatchFolder(String id, File src) throws IOException {\n-    final String worldName = getWorldName(id);\n-    final File dest = new File(server.getWorldContainer(), worldName);\n-\n-    if (dest.exists()) FileUtils.delete(dest);\n-\n-    if (!dest.mkdir()) {\n-      throw new IOException(\"Failed to create temporary world folder \" + dest);\n-    }\n-\n-    FileUtils.copy(new File(src, \"level.dat\"), new File(dest, \"level.dat\"));\n-\n-    File region = new File(src, \"region\");\n-    if (region.isDirectory()) {\n-      FileUtils.copy(region, new File(dest, \"region\"));\n-    }\n-\n-    File data = new File(src, \"data\");\n-    if (data.isDirectory()) {\n-      FileUtils.copy(data, new File(dest, \"data\"));\n-    }\n-\n-    return worldName;\n-  }\n-\n-  private World createMatchWorld(String worldName, MapInfo info, TerrainModule terrain) {\n-    WorldCreator creator = server.detectWorld(worldName);\n-    if (creator == null) creator = new WorldCreator(worldName);\n-    creator\n-        .environment(info.dimension)\n-        .generator(terrain.getChunkGenerator())\n-        .seed(terrain.getSeed());\n-\n-    final World world = createWorld(creator);\n-    if (world == null) {\n-      throw new IllegalStateException(\"Failed to create world, createWorld returned null\");\n-    }\n-\n-    world.setPVP(true);\n-    world.setSpawnFlags(false, false);\n-    world.setAutoSave(false);\n-\n-    if (info.difficulty != null) {\n-      world.setDifficulty(info.difficulty);\n-    } else {\n-      world.setDifficulty(server.getWorlds().get(0).getDifficulty());\n-    }\n-\n-    return world;\n+  public Match getMatch(@Nullable World world) {", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0MzA4NA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943084", "bodyText": "I think we should keep the * import?", "author": "TheMolkaPL", "createdAt": "2020-01-25T16:44:29Z", "path": "src/main/java/tc/oc/pgm/modes/ObjectiveModesModule.java", "diffHunk": "@@ -1,95 +1,102 @@\n package tc.oc.pgm.modes;\n \n-import static tc.oc.pgm.map.ProtoVersions.*;\n+import static tc.oc.pgm.api.map.MapProtos.MODES_IMPLEMENTATION_VERSION;", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0MzE2Mg==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943162", "bodyText": "Modules should have their own loggers if possible.", "author": "TheMolkaPL", "createdAt": "2020-01-25T16:45:48Z", "path": "src/main/java/tc/oc/pgm/modules/EventFilterMatchModule.java", "diffHunk": "@@ -39,14 +55,16 @@\n  * kept simple.\n  */\n @ListenerScope(MatchScope.LOADED)\n-public class EventFilterMatchModule extends MatchModule implements Listener {\n+public class EventFilterMatchModule implements MatchModule, Listener {\n+\n+  private final Match match;\n \n   public EventFilterMatchModule(Match match) {\n-    super(match);\n+    this.match = match;\n   }\n \n   boolean cancel(Cancellable event, @Nullable MatchPlayer actor, @Nullable Component message) {\n-    logger.fine(\"Cancel \" + event + \" actor=\" + actor);\n+    match.getLogger().fine(\"Cancel \" + event + \" actor=\" + actor);", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mzc4Mg==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943782", "bodyText": "Unnecessary newline", "author": "TheMolkaPL", "createdAt": "2020-01-25T16:57:43Z", "path": "src/main/java/tc/oc/pgm/score/ScoreModule.java", "diffHunk": "@@ -80,69 +71,78 @@ public ScoreConfig getConfig() {\n     return config;\n   }\n \n-  // ---------------------\n-  // ---- XML Parsing ----\n-  // ---------------------\n-\n-  public static ScoreModule parse(MapModuleContext context, Logger logger, Document doc)\n-      throws InvalidXMLException {\n-    SemanticVersion proto = context.getProto();\n+  public static class Factory implements MapModuleFactory<ScoreModule> {\n+    @Override\n+    public Collection<Class<? extends MapModule>> getSoftDependencies() {\n+      return ImmutableList.of(RegionModule.class, FilterModule.class);\n+    }\n \n-    List<Element> scoreElements = doc.getRootElement().getChildren(\"score\");\n-    if (scoreElements.size() == 0) {\n-      return null;\n+    @Override\n+    public Collection<Class<? extends MapModule>> getWeakDependencies() {\n+      return ImmutableList.of(BlitzModule.class);\n     }\n \n-    RegionParser regionParser = context.getRegionParser();\n-    ScoreConfig config = new ScoreConfig();\n-    ImmutableSet.Builder<ScoreBoxFactory> scoreBoxFactories = ImmutableSet.builder();\n-\n-    for (Element scoreEl : scoreElements) {\n-      config.scoreLimit = XMLUtils.parseNumber(scoreEl.getChild(\"limit\"), Integer.class, -1);\n-\n-      // For backwards compatibility, default kill/death points to 1 if proto is old and <king/> tag\n-      // is not present\n-      boolean scoreKillsByDefault =\n-          proto.isOlderThan(ProtoVersions.DEFAULT_SCORES_TO_ZERO)\n-              && scoreEl.getChild(\"king\") == null;\n-      config.deathScore =\n-          XMLUtils.parseNumber(\n-              scoreEl.getChild(\"deaths\"), Integer.class, scoreKillsByDefault ? 1 : 0);\n-      config.killScore =\n-          XMLUtils.parseNumber(\n-              scoreEl.getChild(\"kills\"), Integer.class, scoreKillsByDefault ? 1 : 0);\n-\n-      for (Element scoreBoxEl : scoreEl.getChildren(\"box\")) {\n-        int points =\n+    @Override\n+    public ScoreModule parse(MapFactory factory, Logger logger, Document doc)\n+        throws InvalidXMLException {\n+      Version proto = factory.getProto();\n+\n+      List<Element> scoreElements = doc.getRootElement().getChildren(\"score\");\n+      if (scoreElements.size() == 0) {\n+        return null;\n+      }\n+\n+      RegionParser regionParser = factory.getRegions();\n+      ScoreConfig config = new ScoreConfig();\n+      ImmutableSet.Builder<ScoreBoxFactory> scoreBoxFactories = ImmutableSet.builder();\n+\n+      for (Element scoreEl : scoreElements) {\n+        config.scoreLimit = XMLUtils.parseNumber(scoreEl.getChild(\"limit\"), Integer.class, -1);\n+\n+        // For backwards compatibility, default kill/death points to 1 if proto is old and <king/>\n+        // tag\n+        // is not present", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0MzgzNA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943834", "bodyText": "Should be translatable.", "author": "TheMolkaPL", "createdAt": "2020-01-25T16:58:48Z", "path": "src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java", "diffHunk": "@@ -70,6 +88,37 @@\n \n   protected @Nullable BukkitTask renderTask;\n \n+  private static String renderSidebarTitle(Collection<MapTag> tags) {\n+    final List<String> gamemode =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(tag -> !tag.isAuxiliary())\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+    final List<String> auxiliary =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(MapTag::isAuxiliary)\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+\n+    String title = \"\";\n+\n+    if (gamemode.size() == 1) {\n+      title = gamemode.get(0);\n+    } else if (gamemode.size() >= 2) {\n+      title = \"Objectives\";", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mzg3MQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943871", "bodyText": "& should also be translatable.", "author": "TheMolkaPL", "createdAt": "2020-01-25T16:59:24Z", "path": "src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java", "diffHunk": "@@ -70,6 +88,37 @@\n \n   protected @Nullable BukkitTask renderTask;\n \n+  private static String renderSidebarTitle(Collection<MapTag> tags) {\n+    final List<String> gamemode =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(tag -> !tag.isAuxiliary())\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+    final List<String> auxiliary =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(MapTag::isAuxiliary)\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+\n+    String title = \"\";\n+\n+    if (gamemode.size() == 1) {\n+      title = gamemode.get(0);\n+    } else if (gamemode.size() >= 2) {\n+      title = \"Objectives\";\n+    }\n+\n+    if (auxiliary.size() == 1) {\n+      title += (title.isEmpty() ? \"\" : \" & \") + auxiliary.get(0);\n+    } else if (gamemode.isEmpty() && auxiliary.size() == 2) {\n+      title = auxiliary.get(0) + \" & \" + auxiliary.get(1);", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0Mzg3Nw==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370943877", "bodyText": "This too", "author": "TheMolkaPL", "createdAt": "2020-01-25T16:59:31Z", "path": "src/main/java/tc/oc/pgm/scoreboard/SidebarMatchModule.java", "diffHunk": "@@ -70,6 +88,37 @@\n \n   protected @Nullable BukkitTask renderTask;\n \n+  private static String renderSidebarTitle(Collection<MapTag> tags) {\n+    final List<String> gamemode =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(tag -> !tag.isAuxiliary())\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+    final List<String> auxiliary =\n+        tags.stream()\n+            .filter(MapTag::isGamemode)\n+            .filter(MapTag::isAuxiliary)\n+            .map(MapTag::getName)\n+            .collect(Collectors.toList());\n+\n+    String title = \"\";\n+\n+    if (gamemode.size() == 1) {\n+      title = gamemode.get(0);\n+    } else if (gamemode.size() >= 2) {\n+      title = \"Objectives\";\n+    }\n+\n+    if (auxiliary.size() == 1) {\n+      title += (title.isEmpty() ? \"\" : \" & \") + auxiliary.get(0);\n+    } else if (gamemode.isEmpty() && auxiliary.size() == 2) {\n+      title = auxiliary.get(0) + \" & \" + auxiliary.get(1);\n+    }\n+\n+    return title.isEmpty() ? \"Match\" : title;", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDAyNg==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944026", "bodyText": "amount?", "author": "TheMolkaPL", "createdAt": "2020-01-25T17:02:41Z", "path": "src/main/java/tc/oc/pgm/teams/TeamModule.java", "diffHunk": "@@ -40,15 +39,44 @@ public TeamModule(Set<TeamFactory> teams, @Nullable Boolean requireEven) {\n   }\n \n   @Override\n-  public String toString() {\n-    return getClass().getSimpleName() + \"{teams=[\" + Joiner.on(\", \").join(teams) + \"]}\";\n+  public Collection<MapTag> getTags() {\n+    final int id = teams.size();", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDA4OA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944088", "bodyText": "Why complete removal?", "author": "TheMolkaPL", "createdAt": "2020-01-25T17:03:56Z", "path": "src/main/java/tc/oc/pgm/terrain/TerrainModule.java", "diffHunk": "@@ -1,40 +1,28 @@\n package tc.oc.pgm.terrain;\n \n-import java.io.File;\n import java.util.Random;\n-import java.util.Set;\n import java.util.logging.Logger;\n import javax.annotation.Nullable;\n import org.bukkit.generator.ChunkGenerator;\n import org.jdom2.Document;\n import org.jdom2.Element;\n import tc.oc.chunk.NullChunkGenerator;\n-import tc.oc.pgm.map.MapModule;\n-import tc.oc.pgm.map.MapModuleContext;\n-import tc.oc.pgm.map.MapModuleFactory;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.match.MatchModule;\n-import tc.oc.pgm.module.ModuleDescription;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n+import tc.oc.pgm.api.match.Match;\n+import tc.oc.pgm.api.match.MatchModule;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.xml.InvalidXMLException;\n-import tc.oc.xml.Node;\n \n-@ModuleDescription(name = \"Terrain\")\n-public class TerrainModule extends MapModule<MatchModule> {\n-\n-  private static final MapTag VANILLAWORLDGEN_TAG = MapTag.forName(\"vanillaworldgen\");\n+public class TerrainModule implements MapModule {\n \n   private final TerrainOptions options;\n \n   public TerrainModule(TerrainOptions options) {\n     this.options = options;\n   }\n \n-  @Override\n-  public void loadTags(Set<MapTag> tags) {\n-    if (options.vanilla) tags.add(VANILLAWORLDGEN_TAG);\n-  }", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDE0NQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944145", "bodyText": "Why complete removal?", "author": "TheMolkaPL", "createdAt": "2020-01-25T17:05:19Z", "path": "src/main/java/tc/oc/pgm/timelimit/TimeLimitModule.java", "diffHunk": "@@ -1,103 +1,89 @@\n package tc.oc.pgm.timelimit;\n \n-import java.util.Set;\n import java.util.logging.Logger;\n import javax.annotation.Nullable;\n import org.jdom2.Attribute;\n import org.jdom2.Document;\n import org.jdom2.Element;\n+import tc.oc.pgm.api.map.MapModule;\n+import tc.oc.pgm.api.map.MapProtos;\n+import tc.oc.pgm.api.map.factory.MapFactory;\n+import tc.oc.pgm.api.map.factory.MapModuleFactory;\n import tc.oc.pgm.api.match.Match;\n-import tc.oc.pgm.bossbar.BossBarModule;\n-import tc.oc.pgm.map.MapModule;\n-import tc.oc.pgm.map.MapModuleContext;\n-import tc.oc.pgm.map.ProtoVersions;\n-import tc.oc.pgm.maptag.MapTag;\n-import tc.oc.pgm.module.ModuleDescription;\n+import tc.oc.pgm.api.match.MatchModule;\n import tc.oc.pgm.result.VictoryCondition;\n import tc.oc.pgm.result.VictoryConditions;\n import tc.oc.pgm.util.XMLUtils;\n import tc.oc.util.components.PeriodFormats;\n import tc.oc.xml.InvalidXMLException;\n \n-@ModuleDescription(\n-    name = \"Time Limit\",\n-    requires = {BossBarModule.class})\n-public class TimeLimitModule extends MapModule<TimeLimitMatchModule> {\n-\n-  private static final MapTag TIMELIMIT_TAG = MapTag.forName(\"timelimit\");\n-\n+public class TimeLimitModule implements MapModule {\n   private final @Nullable TimeLimit timeLimit;\n \n   public TimeLimitModule(@Nullable TimeLimit limit) {\n     this.timeLimit = limit;\n   }\n \n   @Override\n-  public void loadTags(Set<MapTag> tags) {\n-    if (timeLimit != null) tags.add(TIMELIMIT_TAG);\n-  }", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDQ0MQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944441", "bodyText": "Too many tags.. you have to keep it simple.", "author": "Electroid", "createdAt": "2020-01-25T17:11:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDE0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NjQzNg==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370946436", "bodyText": "You could easily differentiate maps where you have to score n amount of points to win the match and maps where you have to score most points before the time ends. This one was pretty useful.", "author": "TheMolkaPL", "createdAt": "2020-01-25T17:52:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDE0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDk0NDMwMw==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r370944303", "bodyText": "Here too", "author": "TheMolkaPL", "createdAt": "2020-01-25T17:08:10Z", "path": "src/main/java/tc/oc/pgm/worldborder/WorldBorderModule.java", "diffHunk": "@@ -32,50 +28,48 @@ public WorldBorderModule(List<WorldBorder> borders) {\n   }\n \n   @Override\n-  public void loadTags(Set<MapTag> tags) {\n-    tags.add(WORLDBORDER_TAG);\n-  }", "originalCommit": "88e7cfe63ec24b171c800f60f5aecff4f7faee60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5fd3b360256ee9c73a19d35b4985291cda634b6a", "url": "https://github.com/PGMDev/PGM/commit/5fd3b360256ee9c73a19d35b4985291cda634b6a", "message": "Make Node a weak reference in XMLFeatureReference\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-27T08:08:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ2MTc5MQ==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r371461791", "bodyText": "Is this assuming a map if a next map is missing?\nNext map not being defined is completely normal (for example, on voted pools) and shouldn't be avoided or treated like an error.", "author": "Pablete1234", "createdAt": "2020-01-27T20:20:21Z", "path": "src/main/java/tc/oc/pgm/listeners/MotdListener.java", "diffHunk": "@@ -31,7 +31,9 @@ public MotdListener() {\n     this.format = Config.Motd.format();\n \n     // Ensure there are always default keys\n-    final MapInfo map = PGM.get().getMapOrder().getNextMap();\n+    MapInfo map = PGM.get().getMapOrder().getNextMap();\n+    if (map == null) map = PGM.get().getMapLibrary().getMaps().next();", "originalCommit": "a3d3f979d271a5e4d5d4542cc9e6372615a71717", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTkzMjk0Mg==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r371932942", "bodyText": "If we don't know what the true next map will be, what should the motd say? > PGM < ?", "author": "Electroid", "createdAt": "2020-01-28T17:00:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ2MTc5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTk5NzAwOA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r371997008", "bodyText": "Either the current map, or something else like Deciding next map, PGM, or whatever other placeholder", "author": "Pablete1234", "createdAt": "2020-01-28T19:03:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ2MTc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTQ3NzQ0NA==", "url": "https://github.com/PGMDev/PGM/pull/218#discussion_r371477444", "bodyText": "should probably just use:\n        final Map<Boolean, Set<String>> tagSet = Stream.of(tags.split(\",\"))\n                .map(String::toLowerCase)\n                .map(String::trim)\n                .collect(Collectors.partitioningBy(s -> s.startsWith(\"!\"),\n                        Collectors.mapping(\n                                (String s) ->  s.startsWith(\"!\") ? s.substring(1) : s,\n                                Collectors.toSet())));\n\nthat does both partitioning and removing the first char, that way you avoid the later transformation on the filter.\nAlso, i don't think linked lists are a good fit, should probably just use hash sets.", "author": "Pablete1234", "createdAt": "2020-01-27T20:55:55Z", "path": "src/main/java/tc/oc/pgm/commands/MapCommands.java", "diffHunk": "@@ -62,12 +66,19 @@ public static void maplist(\n       throws CommandException {\n     Stream<MapInfo> search = Sets.newHashSet(library.getMaps()).stream();\n     if (tags != null) {\n-      final Set<String> tagSet =\n+      final Map<Boolean, List<String>> tagSet =\n           Stream.of(tags.split(\",\"))\n               .map(String::toLowerCase)\n               .map(String::trim)\n-              .collect(Collectors.toSet());\n-      search = search.filter(map -> matchesTags(map, tagSet));\n+              .collect(Collectors.partitioningBy(s -> s.startsWith(\"!\")));\n+      search =\n+          search.filter(\n+              map ->\n+                  matchesTags(\n+                      map,\n+                      tagSet.getOrDefault(false, new LinkedList<>()),\n+                      Collections2.transform(\n+                          tagSet.getOrDefault(true, new LinkedList<>()), s -> s.substring(1))));", "originalCommit": "40753435ea04caad64af2fede440d6d4c7f4e4eb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "81301d06f6b907a9c86b9be370024f996c1a4a59", "url": "https://github.com/PGMDev/PGM/commit/81301d06f6b907a9c86b9be370024f996c1a4a59", "message": "WIP: Map, MapModule, and MatchModule refactors\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:07:32Z", "type": "commit"}, {"oid": "b5bc2466ea85b22426db49394a6ed4b9b49b62f4", "url": "https://github.com/PGMDev/PGM/commit/b5bc2466ea85b22426db49394a6ed4b9b49b62f4", "message": "WIP: Extract parsing and loading of MapContext into MapFactory\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:07:33Z", "type": "commit"}, {"oid": "d61de25fe678a93112b686f50bc4e120cd8aa053", "url": "https://github.com/PGMDev/PGM/commit/d61de25fe678a93112b686f50bc4e120cd8aa053", "message": "WIP: Loading works, now need to fix small bugs\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:07:33Z", "type": "commit"}, {"oid": "de80d65322aee79cc6aa0a100514b1946bb85ae0", "url": "https://github.com/PGMDev/PGM/commit/de80d65322aee79cc6aa0a100514b1946bb85ae0", "message": "WIP: Fix formatting\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:07:34Z", "type": "commit"}, {"oid": "702a285d3db3a34bac62e89b45f6fb58e9affc2f", "url": "https://github.com/PGMDev/PGM/commit/702a285d3db3a34bac62e89b45f6fb58e9affc2f", "message": "WIP: Improve module loading and fix deadlock issues\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:07:34Z", "type": "commit"}, {"oid": "54ea8df0c1b17aa541250d525a715b016f946ca0", "url": "https://github.com/PGMDev/PGM/commit/54ea8df0c1b17aa541250d525a715b016f946ca0", "message": "WIP: Refine MapInfo interfaces\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:07:34Z", "type": "commit"}, {"oid": "22f1ab6219494f2e3ee6095bb9b23a93248a73a4", "url": "https://github.com/PGMDev/PGM/commit/22f1ab6219494f2e3ee6095bb9b23a93248a73a4", "message": "WIP: Fix various Match/Map related memory leaks\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:07:34Z", "type": "commit"}, {"oid": "ccb9ded661cc71f48011a9b812cad8bf59e9194d", "url": "https://github.com/PGMDev/PGM/commit/ccb9ded661cc71f48011a9b812cad8bf59e9194d", "message": "WIP: Remove various debug statements\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:07:34Z", "type": "commit"}, {"oid": "6a190392217e758d6648c5c6e9fe3973d60c54b8", "url": "https://github.com/PGMDev/PGM/commit/6a190392217e758d6648c5c6e9fe3973d60c54b8", "message": "WIP: Fix scoreboard, map tags, and some XML parsing\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:18Z", "type": "commit"}, {"oid": "284743996dd3ab36539b4084bf118b1c410c6f4f", "url": "https://github.com/PGMDev/PGM/commit/284743996dd3ab36539b4084bf118b1c410c6f4f", "message": "WIP: Fix formatting of map errors\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:39Z", "type": "commit"}, {"oid": "e06b78ffe3ece94c8a73e8b6af357d848ecec925", "url": "https://github.com/PGMDev/PGM/commit/e06b78ffe3ece94c8a73e8b6af357d848ecec925", "message": "WIP: Add default maps back\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:40Z", "type": "commit"}, {"oid": "880a7bc94df17b2871006fd79dac1877f7df3886", "url": "https://github.com/PGMDev/PGM/commit/880a7bc94df17b2871006fd79dac1877f7df3886", "message": "WIP: Cycle to next map if there is an error, recursively\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:40Z", "type": "commit"}, {"oid": "c8161dd6c939114ddc9c94df606e42d6b035b743", "url": "https://github.com/PGMDev/PGM/commit/c8161dd6c939114ddc9c94df606e42d6b035b743", "message": "WIP: End of WIP\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:40Z", "type": "commit"}, {"oid": "ec756dce695ef7298cd98867a3a5c90a5bb6f813", "url": "https://github.com/PGMDev/PGM/commit/ec756dce695ef7298cd98867a3a5c90a5bb6f813", "message": "Fix NPE when Contributor names are still being loaded\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:40Z", "type": "commit"}, {"oid": "f048768e4874fe36201ab51542a5b15b4a9bc9f4", "url": "https://github.com/PGMDev/PGM/commit/f048768e4874fe36201ab51542a5b15b4a9bc9f4", "message": "Fix various CME/NPE exceptions\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:40Z", "type": "commit"}, {"oid": "5e311631c9253e7b9e8c9961850da792089034ec", "url": "https://github.com/PGMDev/PGM/commit/5e311631c9253e7b9e8c9961850da792089034ec", "message": "Teleport players over time on cycle\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:41Z", "type": "commit"}, {"oid": "1ba91873b7dca4ee61299cd315a6e72ce98b30c4", "url": "https://github.com/PGMDev/PGM/commit/1ba91873b7dca4ee61299cd315a6e72ce98b30c4", "message": "Refine World loading\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:41Z", "type": "commit"}, {"oid": "19ad99b9fbf1ca636ef19ce89e7f1733d451c991", "url": "https://github.com/PGMDev/PGM/commit/19ad99b9fbf1ca636ef19ce89e7f1733d451c991", "message": "Make Node a weak reference in XMLFeatureReference\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:41Z", "type": "commit"}, {"oid": "459c36b117ef8f6a377836da5cc44a4be4e00b66", "url": "https://github.com/PGMDev/PGM/commit/459c36b117ef8f6a377836da5cc44a4be4e00b66", "message": "Rebase to master and fix\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:41Z", "type": "commit"}, {"oid": "db1ace89fd7d89448af44a543dcd461ce7371f83", "url": "https://github.com/PGMDev/PGM/commit/db1ace89fd7d89448af44a543dcd461ce7371f83", "message": "Fix commands when there is no match\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:41Z", "type": "commit"}, {"oid": "c02af41697dbe0326b0e03435ce31be894676c31", "url": "https://github.com/PGMDev/PGM/commit/c02af41697dbe0326b0e03435ce31be894676c31", "message": "Add more documentation and bring back a few tags\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:42Z", "type": "commit"}, {"oid": "3ecabb11647cdcc1a4bbbde1e6716241d4be475e", "url": "https://github.com/PGMDev/PGM/commit/3ecabb11647cdcc1a4bbbde1e6716241d4be475e", "message": "Fix contributor name fetching\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:42Z", "type": "commit"}, {"oid": "fc98b55754aec855218c20b83308c0b31f8ef17f", "url": "https://github.com/PGMDev/PGM/commit/fc98b55754aec855218c20b83308c0b31f8ef17f", "message": "Fix map tags command search\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:42Z", "type": "commit"}, {"oid": "e0bb667b32e9af7f321a48e2bd54885ec6bff2a9", "url": "https://github.com/PGMDev/PGM/commit/e0bb667b32e9af7f321a48e2bd54885ec6bff2a9", "message": "Remove debug cycle messages\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:42Z", "type": "commit"}, {"oid": "9b2a830a20e789cf74090d1eea89dc14b75337e1", "url": "https://github.com/PGMDev/PGM/commit/9b2a830a20e789cf74090d1eea89dc14b75337e1", "message": "Fix default map sources\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:42Z", "type": "commit"}, {"oid": "5c8524c7e6e38a75c7c0fd3438886ca7bb123d39", "url": "https://github.com/PGMDev/PGM/commit/5c8524c7e6e38a75c7c0fd3438886ca7bb123d39", "message": "Add negated map tags\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:42Z", "type": "commit"}, {"oid": "e430378b97fc38be076427f469b513c914c87f8a", "url": "https://github.com/PGMDev/PGM/commit/e430378b97fc38be076427f469b513c914c87f8a", "message": "Fix NPE when map order fails\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:43Z", "type": "commit"}, {"oid": "85f58ef6c8dbf472f0e280baaa84bbfac021de8f", "url": "https://github.com/PGMDev/PGM/commit/85f58ef6c8dbf472f0e280baaa84bbfac021de8f", "message": "Allow /cancel to interrupt match precycle\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:43Z", "type": "commit"}, {"oid": "1f9a27591228c799422d015f0dac33add052180b", "url": "https://github.com/PGMDev/PGM/commit/1f9a27591228c799422d015f0dac33add052180b", "message": "Improve match lazy loading with a lock\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:43Z", "type": "commit"}, {"oid": "f5fd03be0158f766c5257449d6123ec16fc1edf7", "url": "https://github.com/PGMDev/PGM/commit/f5fd03be0158f766c5257449d6123ec16fc1edf7", "message": "Move sentry from Server to PGM\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:43Z", "type": "commit"}, {"oid": "88c131acbb7e2f2c493d4c26bc6a1a1f9eadb8d3", "url": "https://github.com/PGMDev/PGM/commit/88c131acbb7e2f2c493d4c26bc6a1a1f9eadb8d3", "message": "Only send tc.oc errors to sentry\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:44Z", "type": "commit"}, {"oid": "aa6633345107e7989e4f35552b6a7650e6b7c0b6", "url": "https://github.com/PGMDev/PGM/commit/aa6633345107e7989e4f35552b6a7650e6b7c0b6", "message": "Add workflow for a beta branch\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:44Z", "type": "commit"}, {"oid": "382be0654a79f94651b3b83bb90d3f010ade1251", "url": "https://github.com/PGMDev/PGM/commit/382be0654a79f94651b3b83bb90d3f010ade1251", "message": "Fix workflow stage names\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:44Z", "type": "commit"}, {"oid": "65a8fb73a43ddd8cec8daf4de3493e45a6bb58ed", "url": "https://github.com/PGMDev/PGM/commit/65a8fb73a43ddd8cec8daf4de3493e45a6bb58ed", "message": "Add build badge to readme\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:44Z", "type": "commit"}, {"oid": "79ce7636fbb9fe8d084141846f3183793b3b36bd", "url": "https://github.com/PGMDev/PGM/commit/79ce7636fbb9fe8d084141846f3183793b3b36bd", "message": "Seperate workflows into build and deploy\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:44Z", "type": "commit"}, {"oid": "8a47ed2a8ca0d09bc90e5716d0a25175965d832a", "url": "https://github.com/PGMDev/PGM/commit/8a47ed2a8ca0d09bc90e5716d0a25175965d832a", "message": "Do not build, only deploy on master/beta\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:45Z", "type": "commit"}, {"oid": "4abfb580d27d58b3235f9740a9126df9fd874ea8", "url": "https://github.com/PGMDev/PGM/commit/4abfb580d27d58b3235f9740a9126df9fd874ea8", "message": "Fix bad deploy artifacts\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:45Z", "type": "commit"}, {"oid": "482086ff60161039d75dd160c70b16209cf7c907", "url": "https://github.com/PGMDev/PGM/commit/482086ff60161039d75dd160c70b16209cf7c907", "message": "Do not append master to master branch deploys\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:45Z", "type": "commit"}, {"oid": "7ff85c3786b6ce83cfe194d9b1559ed47f698dbb", "url": "https://github.com/PGMDev/PGM/commit/7ff85c3786b6ce83cfe194d9b1559ed47f698dbb", "message": "Allow PGM to perform magic and unload the first world\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:10:45Z", "type": "commit"}, {"oid": "b5d597d2ca23da1748eb4cb007ceb77be9f4955a", "url": "https://github.com/PGMDev/PGM/commit/b5d597d2ca23da1748eb4cb007ceb77be9f4955a", "message": "Fix formatting\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:23:06Z", "type": "commit"}, {"oid": "db5dd5c9f1de6c5863a382f54bdde4cdb2124de7", "url": "https://github.com/PGMDev/PGM/commit/db5dd5c9f1de6c5863a382f54bdde4cdb2124de7", "message": "Fix observers ui command\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T03:27:58Z", "type": "commit"}, {"oid": "155904e3ff07109f25a2c1c75c1a0a82e6d5a9fd", "url": "https://github.com/PGMDev/PGM/commit/155904e3ff07109f25a2c1c75c1a0a82e6d5a9fd", "message": "Fix double command reegistration\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T05:49:50Z", "type": "commit"}, {"oid": "155904e3ff07109f25a2c1c75c1a0a82e6d5a9fd", "url": "https://github.com/PGMDev/PGM/commit/155904e3ff07109f25a2c1c75c1a0a82e6d5a9fd", "message": "Fix double command reegistration\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T05:49:50Z", "type": "forcePushed"}, {"oid": "53f3fc4e1d43671bac8f6eadb4b429cf4bed04a0", "url": "https://github.com/PGMDev/PGM/commit/53f3fc4e1d43671bac8f6eadb4b429cf4bed04a0", "message": "Fix various map order issues\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T16:02:06Z", "type": "commit"}, {"oid": "d7e18f7f3b3d2655c8fd93fbb3dad517fcf1dac7", "url": "https://github.com/PGMDev/PGM/commit/d7e18f7f3b3d2655c8fd93fbb3dad517fcf1dac7", "message": "Fix hashtag now showing on map tags\n\nSigned-off-by: Ashcon Partovi <ashcon@partovi.net>", "committedDate": "2020-01-29T16:53:27Z", "type": "commit"}]}