{"pr_number": 1476, "pr_title": "Add unit test for mvn validate action", "pr_createdAt": "2020-05-27T20:22:18Z", "pr_url": "https://github.com/confluentinc/schema-registry/pull/1476", "timeline": [{"oid": "2dfef2d4095095fbcd116bc23904cd28f0d89cfd", "url": "https://github.com/confluentinc/schema-registry/commit/2dfef2d4095095fbcd116bc23904cd28f0d89cfd", "message": "Add unit test for mvn validate action", "committedDate": "2020-05-27T20:21:33Z", "type": "commit"}, {"oid": "6b54c664cba96ca26d0cb3d6bf9cf6f7e829778c", "url": "https://github.com/confluentinc/schema-registry/commit/6b54c664cba96ca26d0cb3d6bf9cf6f7e829778c", "message": "Fix copyright", "committedDate": "2020-05-27T20:22:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQzMDAxNA==", "url": "https://github.com/confluentinc/schema-registry/pull/1476#discussion_r431430014", "bodyText": "Nit: missing space before bracket.", "author": "dragosvictor", "createdAt": "2020-05-27T20:43:23Z", "path": "maven-plugin/src/test/java/io/confluent/kafka/schemaregistry/maven/ValidateSchemaRegistryMojoTest.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.confluent.kafka.schemaregistry.maven;\n+\n+import io.confluent.kafka.schemaregistry.client.MockSchemaRegistryClient;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.avro.Schema;\n+import org.apache.maven.plugin.MojoExecutionException;\n+import org.apache.maven.plugin.MojoFailureException;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ValidateSchemaRegistryMojoTest extends SchemaRegistryTest{", "originalCommit": "6b54c664cba96ca26d0cb3d6bf9cf6f7e829778c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0MzMxNw==", "url": "https://github.com/confluentinc/schema-registry/pull/1476#discussion_r431443317", "bodyText": "Fixed", "author": "rayokota", "createdAt": "2020-05-27T21:08:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQzMDAxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQzMjg0Ng==", "url": "https://github.com/confluentinc/schema-registry/pull/1476#discussion_r431432846", "bodyText": "This seems to be testing both malformed and missing schemas. Is there a benefit to having 100 iterations here versus just one ?", "author": "dragosvictor", "createdAt": "2020-05-27T20:48:41Z", "path": "maven-plugin/src/test/java/io/confluent/kafka/schemaregistry/maven/ValidateSchemaRegistryMojoTest.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.confluent.kafka.schemaregistry.maven;\n+\n+import io.confluent.kafka.schemaregistry.client.MockSchemaRegistryClient;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.avro.Schema;\n+import org.apache.maven.plugin.MojoExecutionException;\n+import org.apache.maven.plugin.MojoFailureException;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ValidateSchemaRegistryMojoTest extends SchemaRegistryTest{\n+  ValidateSchemaRegistryMojo mojo;\n+\n+  @Before\n+  public void createMojo(){\n+    this.mojo = new ValidateSchemaRegistryMojo();\n+    this.mojo.client(new MockSchemaRegistryClient());\n+  }\n+\n+  @Test\n+  public void validate() throws IOException, MojoFailureException, MojoExecutionException {\n+    Map<String, Integer> expectedVersions = new LinkedHashMap<>();\n+\n+    Map<String, File> subjectToFile = new LinkedHashMap<>();\n+    int version = 1;\n+    for (int i = 0; i < 100; i++) {\n+      String keySubject = String.format(\"TestSubject%03d-key\", i);\n+      String valueSubject = String.format(\"TestSubject%03d-value\", i);\n+      Schema keySchema = Schema.create(Schema.Type.STRING);\n+      Schema valueSchema = Schema.createUnion(Arrays.asList(Schema.create(Schema.Type.STRING), Schema.create(Schema.Type.NULL)));\n+      File keySchemaFile = new File(this.tempDirectory, keySubject + \".avsc\");\n+      File valueSchemaFile = new File(this.tempDirectory, valueSubject + \".avsc\");\n+      writeSchema(keySchemaFile, keySchema);\n+      writeSchema(valueSchemaFile, valueSchema);\n+      subjectToFile.put(keySubject, keySchemaFile);\n+      expectedVersions.put(keySubject, version);\n+      subjectToFile.put(valueSubject, valueSchemaFile);\n+      expectedVersions.put(valueSubject, version);\n+    }\n+\n+    this.mojo.subjects = subjectToFile;\n+    this.mojo.execute();\n+  }\n+\n+  @Test(expected = IllegalStateException.class)\n+  public void malformedSchema() throws IOException, MojoFailureException, MojoExecutionException {\n+    Map<String, Integer> expectedVersions = new LinkedHashMap<>();\n+\n+    Map<String, File> subjectToFile = new LinkedHashMap<>();\n+    int version = 1;\n+    for (int i = 0; i < 100; i++) {\n+      String keySubject = String.format(\"TestSubject%03d-key\", i);\n+      String valueSubject = String.format(\"TestSubject%03d-value\", i);\n+      Schema keySchema = Schema.create(Schema.Type.STRING);\n+      Schema valueSchema = Schema.createUnion(Arrays.asList(Schema.create(Schema.Type.STRING), Schema.create(Schema.Type.NULL)));\n+      File keySchemaFile = new File(this.tempDirectory, keySubject + \".avsc\");\n+      File valueSchemaFile = new File(this.tempDirectory, valueSubject + \".avsc\");\n+      if (i % 7 == 0) {\n+        writeMalformedFile(keySchemaFile);\n+        writeMalformedFile(valueSchemaFile);\n+      }", "originalCommit": "6b54c664cba96ca26d0cb3d6bf9cf6f7e829778c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ0Mjk1NA==", "url": "https://github.com/confluentinc/schema-registry/pull/1476#discussion_r431442954", "bodyText": "This test was copied from the register action test.  Register and validate are similar, except register will send it to SR which will validate, while the validate action is just performed locally.", "author": "rayokota", "createdAt": "2020-05-27T21:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQzMjg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQzMzIyOQ==", "url": "https://github.com/confluentinc/schema-registry/pull/1476#discussion_r431433229", "bodyText": "Ditto w.r.t. the 'extra' schemas.", "author": "dragosvictor", "createdAt": "2020-05-27T20:49:19Z", "path": "maven-plugin/src/test/java/io/confluent/kafka/schemaregistry/maven/ValidateSchemaRegistryMojoTest.java", "diffHunk": "@@ -0,0 +1,117 @@\n+/*\n+ * Copyright 2020 Confluent Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package io.confluent.kafka.schemaregistry.maven;\n+\n+import io.confluent.kafka.schemaregistry.client.MockSchemaRegistryClient;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.apache.avro.Schema;\n+import org.apache.maven.plugin.MojoExecutionException;\n+import org.apache.maven.plugin.MojoFailureException;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class ValidateSchemaRegistryMojoTest extends SchemaRegistryTest{\n+  ValidateSchemaRegistryMojo mojo;\n+\n+  @Before\n+  public void createMojo(){\n+    this.mojo = new ValidateSchemaRegistryMojo();\n+    this.mojo.client(new MockSchemaRegistryClient());\n+  }\n+\n+  @Test\n+  public void validate() throws IOException, MojoFailureException, MojoExecutionException {\n+    Map<String, Integer> expectedVersions = new LinkedHashMap<>();\n+\n+    Map<String, File> subjectToFile = new LinkedHashMap<>();\n+    int version = 1;\n+    for (int i = 0; i < 100; i++) {\n+      String keySubject = String.format(\"TestSubject%03d-key\", i);\n+      String valueSubject = String.format(\"TestSubject%03d-value\", i);\n+      Schema keySchema = Schema.create(Schema.Type.STRING);\n+      Schema valueSchema = Schema.createUnion(Arrays.asList(Schema.create(Schema.Type.STRING), Schema.create(Schema.Type.NULL)));\n+      File keySchemaFile = new File(this.tempDirectory, keySubject + \".avsc\");\n+      File valueSchemaFile = new File(this.tempDirectory, valueSubject + \".avsc\");\n+      writeSchema(keySchemaFile, keySchema);\n+      writeSchema(valueSchemaFile, valueSchema);\n+      subjectToFile.put(keySubject, keySchemaFile);\n+      expectedVersions.put(keySubject, version);\n+      subjectToFile.put(valueSubject, valueSchemaFile);\n+      expectedVersions.put(valueSubject, version);\n+    }\n+\n+    this.mojo.subjects = subjectToFile;\n+    this.mojo.execute();\n+  }\n+\n+  @Test(expected = IllegalStateException.class)\n+  public void malformedSchema() throws IOException, MojoFailureException, MojoExecutionException {\n+    Map<String, Integer> expectedVersions = new LinkedHashMap<>();\n+\n+    Map<String, File> subjectToFile = new LinkedHashMap<>();\n+    int version = 1;\n+    for (int i = 0; i < 100; i++) {\n+      String keySubject = String.format(\"TestSubject%03d-key\", i);\n+      String valueSubject = String.format(\"TestSubject%03d-value\", i);\n+      Schema keySchema = Schema.create(Schema.Type.STRING);\n+      Schema valueSchema = Schema.createUnion(Arrays.asList(Schema.create(Schema.Type.STRING), Schema.create(Schema.Type.NULL)));\n+      File keySchemaFile = new File(this.tempDirectory, keySubject + \".avsc\");\n+      File valueSchemaFile = new File(this.tempDirectory, valueSubject + \".avsc\");\n+      if (i % 7 == 0) {\n+        writeMalformedFile(keySchemaFile);\n+        writeMalformedFile(valueSchemaFile);\n+      }\n+      subjectToFile.put(keySubject, keySchemaFile);\n+      expectedVersions.put(keySubject, version);\n+      subjectToFile.put(valueSubject, valueSchemaFile);\n+      expectedVersions.put(valueSubject, version);\n+    }\n+\n+    this.mojo.subjects = subjectToFile;\n+    this.mojo.execute();\n+  }\n+\n+  @Test(expected = IllegalStateException.class)\n+  public void missingSchemas() throws IOException, MojoFailureException, MojoExecutionException {\n+    Map<String, Integer> expectedVersions = new LinkedHashMap<>();\n+\n+    Map<String, File> subjectToFile = new LinkedHashMap<>();\n+    int version = 1;\n+    for (int i = 0; i < 100; i++) {\n+      String keySubject = String.format(\"TestSubject%03d-key\", i);\n+      String valueSubject = String.format(\"TestSubject%03d-value\", i);\n+      Schema keySchema = Schema.create(Schema.Type.STRING);\n+      Schema valueSchema = Schema.createUnion(Arrays.asList(Schema.create(Schema.Type.STRING), Schema.create(Schema.Type.NULL)));\n+      File keySchemaFile = new File(this.tempDirectory, keySubject + \".avsc\");\n+      File valueSchemaFile = new File(this.tempDirectory, valueSubject + \".avsc\");\n+      if (i % 7 == 0) {\n+        writeSchema(keySchemaFile, keySchema);\n+        writeSchema(valueSchemaFile, valueSchema);\n+      }", "originalCommit": "6b54c664cba96ca26d0cb3d6bf9cf6f7e829778c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d524b1bd622cdc4dcd8d4cbc80b9b692cc05a4e0", "url": "https://github.com/confluentinc/schema-registry/commit/d524b1bd622cdc4dcd8d4cbc80b9b692cc05a4e0", "message": "Fix whitespace", "committedDate": "2020-05-27T21:08:17Z", "type": "commit"}, {"oid": "8cda55c411748267922a832454116c0efb935b37", "url": "https://github.com/confluentinc/schema-registry/commit/8cda55c411748267922a832454116c0efb935b37", "message": "Fix malform tests", "committedDate": "2020-05-27T23:05:52Z", "type": "commit"}]}