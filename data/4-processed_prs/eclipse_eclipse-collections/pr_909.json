{"pr_number": 909, "pr_title": "Closes #723 added LongInterval", "pr_createdAt": "2020-06-08T02:19:35Z", "pr_url": "https://github.com/eclipse/eclipse-collections/pull/909", "timeline": [{"oid": "b0ad4852c58fd9afc4c7afbbaf27bf238c8774ce", "url": "https://github.com/eclipse/eclipse-collections/commit/b0ad4852c58fd9afc4c7afbbaf27bf238c8774ce", "message": "Closes #723 added LongInterval\n\nSigned-off-by: vmzakharov <zakharov.vladimir.m@gmail.com>", "committedDate": "2020-06-08T02:56:04Z", "type": "forcePushed"}, {"oid": "805fd16aee066a03b3166c52a2b2328eb30b361d", "url": "https://github.com/eclipse/eclipse-collections/commit/805fd16aee066a03b3166c52a2b2328eb30b361d", "message": "Closes #723 added LongInterval\n\nSigned-off-by: vmzakharov <zakharov.vladimir.m@gmail.com>", "committedDate": "2020-06-08T03:03:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3NTg2Nw==", "url": "https://github.com/eclipse/eclipse-collections/pull/909#discussion_r437075867", "bodyText": "isn't this always false? Also not tested?", "author": "mohrezaei", "createdAt": "2020-06-09T00:45:16Z", "path": "eclipse-collections/src/main/java/org/eclipse/collections/impl/list/primitive/LongInterval.java", "diffHunk": "@@ -0,0 +1,1092 @@\n+/*\n+ * Copyright (c) 2019 Goldman Sachs and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * and Eclipse Distribution License v. 1.0 which accompany this distribution.\n+ * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html\n+ * and the Eclipse Distribution License is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ */\n+\n+package org.eclipse.collections.impl.list.primitive;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Spliterator;\n+import java.util.function.LongConsumer;\n+\n+import org.eclipse.collections.api.LazyLongIterable;\n+import org.eclipse.collections.api.LongIterable;\n+import org.eclipse.collections.api.RichIterable;\n+import org.eclipse.collections.api.bag.primitive.MutableLongBag;\n+import org.eclipse.collections.api.block.function.primitive.LongToObjectFunction;\n+import org.eclipse.collections.api.block.function.primitive.ObjectLongIntToObjectFunction;\n+import org.eclipse.collections.api.block.function.primitive.ObjectLongToObjectFunction;\n+import org.eclipse.collections.api.block.predicate.primitive.LongPredicate;\n+import org.eclipse.collections.api.block.procedure.primitive.LongIntProcedure;\n+import org.eclipse.collections.api.block.procedure.primitive.LongLongProcedure;\n+import org.eclipse.collections.api.block.procedure.primitive.LongProcedure;\n+import org.eclipse.collections.api.factory.Lists;\n+import org.eclipse.collections.api.iterator.LongIterator;\n+import org.eclipse.collections.api.list.ImmutableList;\n+import org.eclipse.collections.api.list.MutableList;\n+import org.eclipse.collections.api.list.primitive.ImmutableLongList;\n+import org.eclipse.collections.api.list.primitive.LongList;\n+import org.eclipse.collections.api.list.primitive.MutableLongList;\n+import org.eclipse.collections.api.set.primitive.MutableLongSet;\n+import org.eclipse.collections.api.tuple.primitive.LongLongPair;\n+import org.eclipse.collections.api.tuple.primitive.LongObjectPair;\n+import org.eclipse.collections.impl.bag.mutable.primitive.LongHashBag;\n+import org.eclipse.collections.impl.block.factory.primitive.LongPredicates;\n+import org.eclipse.collections.impl.factory.primitive.LongLists;\n+import org.eclipse.collections.impl.lazy.primitive.CollectLongToObjectIterable;\n+import org.eclipse.collections.impl.lazy.primitive.LazyLongIterableAdapter;\n+import org.eclipse.collections.impl.lazy.primitive.ReverseLongIterable;\n+import org.eclipse.collections.impl.lazy.primitive.SelectLongIterable;\n+import org.eclipse.collections.impl.list.IntervalUtils;\n+import org.eclipse.collections.impl.list.mutable.primitive.LongArrayList;\n+import org.eclipse.collections.impl.set.mutable.primitive.LongHashSet;\n+import org.eclipse.collections.impl.tuple.primitive.PrimitiveTuples;\n+import org.eclipse.collections.impl.utility.Iterate;\n+\n+/**\n+ * An LongInterval is a range of longs that may be iterated over using a step value.\n+ * Note that the size of the interval (the number of elements in the list it represents)\n+ * is limited by the maximum value of the integer index.\n+ */\n+public final class LongInterval\n+        implements ImmutableLongList, Serializable\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    private final long from;\n+    private final long to;\n+    private final long step;\n+    private final int size;\n+\n+    private LongInterval(long from, long to, long step)\n+    {\n+        this.from = from;\n+        this.to = to;\n+        this.step = step;\n+\n+        this.size = IntervalUtils.intSize(this.from, this.to, this.step);\n+    }\n+\n+    /**\n+     * This static {@code from} method allows LongInterval to act as a fluent builder for itself.\n+     * It works in conjunction with the instance methods {@link #to(long)} and {@link #by(long)}.\n+     * <p>\n+     * Usage Example:\n+     * <pre>\n+     * LongInterval interval1 = LongInterval.from(1).to(5);         // results in: 1, 2, 3, 4, 5.\n+     * LongInterval interval2 = LongInterval.from(1).to(10).by(2);  // results in: 1, 3, 5, 7, 9.\n+     * </pre>\n+     */\n+    public static LongInterval from(long newFrom)\n+    {\n+        return LongInterval.fromToBy(newFrom, newFrom, 1);\n+    }\n+\n+    /**\n+     * This instance {@code to} method allows LongInterval to act as a fluent builder for itself.\n+     * It works in conjunction with the static method {@link #from(long)} and instance method {@link #by(long)}.\n+     * <p>\n+     * Usage Example:\n+     * <pre>\n+     * LongInterval interval1 = LongInterval.from(1).to(5);         // results in: 1, 2, 3, 4, 5.\n+     * LongInterval interval2 = LongInterval.from(1).to(10).by(2);  // results in: 1, 3, 5, 7, 9.\n+     * </pre>\n+     */\n+    public LongInterval to(long newTo)\n+    {\n+        return LongInterval.fromToBy(this.from, newTo, this.step);\n+    }\n+\n+    /**\n+     * This instance {@code by} method allows LongInterval to act as a fluent builder for itself.\n+     * It works in conjunction with the static method {@link #from(long)} and instance method {@link #to(long)}.\n+     * <p>\n+     * Usage Example:\n+     * <pre>\n+     * LongInterval interval1 = LongInterval.from(1).to(5);         // results in: 1, 2, 3, 4, 5.\n+     * LongInterval interval2 = LongInterval.from(1).to(10).by(2);  // results in: 1, 3, 5, 7, 9.\n+     * </pre>\n+     */\n+    public LongInterval by(long newStep)\n+    {\n+        return LongInterval.fromToBy(this.from, this.to, newStep);\n+    }\n+\n+    /**\n+     * Returns an LongInterval starting at zero.\n+     * <p>\n+     * Usage Example:\n+     * <pre>\n+     * LongInterval interval1 = LongInterval.zero().to(5);         // results in: 0, 1, 2, 3, 4, 5.\n+     * LongInterval interval2 = LongInterval.zero().to(10).by(2);  // results in: 0, 2, 4, 6, 8, 10.\n+     * </pre>\n+     */\n+    public static LongInterval zero()\n+    {\n+        return LongInterval.from(0);\n+    }\n+\n+    /**\n+     * Returns an LongInterval starting from 1 to the specified count value with a step value of 1.\n+     */\n+    public static LongInterval oneTo(long count)\n+    {\n+        return LongInterval.oneToBy(count, 1);\n+    }\n+\n+    /**\n+     * Returns an LongInterval starting from 1 to the specified count value with a step value of step.\n+     */\n+    public static LongInterval oneToBy(long count, long step)\n+    {\n+        if (count < 1)\n+        {\n+            throw new IllegalArgumentException(\"Only positive ranges allowed using oneToBy\");\n+        }\n+        return LongInterval.fromToBy(1, count, step);\n+    }\n+\n+    /**\n+     * Returns an LongInterval starting from 0 to the specified count value with a step value of 1.\n+     */\n+    public static LongInterval zeroTo(long count)\n+    {\n+        return LongInterval.zeroToBy(count, 1);\n+    }\n+\n+    /**\n+     * Returns an LongInterval starting from 0 to the specified count value with a step value of step.\n+     */\n+    public static LongInterval zeroToBy(long count, long step)\n+    {\n+        return LongInterval.fromToBy(0, count, step);\n+    }\n+\n+    /**\n+     * Returns an LongInterval starting from the value from to the specified value to with a step value of 1.\n+     */\n+    public static LongInterval fromTo(long from, long to)\n+    {\n+        if (from <= to)\n+        {\n+            return LongInterval.fromToBy(from, to, 1);\n+        }\n+        return LongInterval.fromToBy(from, to, -1);\n+    }\n+\n+    /**\n+     * Returns an LongInterval representing the even values from the value from to the value to.\n+     */\n+    public static LongInterval evensFromTo(long from, long to)\n+    {\n+        if (from % 2 != 0)\n+        {\n+            if (from < to)\n+            {\n+                from++;\n+            }\n+            else\n+            {\n+                from--;\n+            }\n+        }\n+        if (to % 2 != 0)\n+        {\n+            if (to > from)\n+            {\n+                to--;\n+            }\n+            else\n+            {\n+                to++;\n+            }\n+        }\n+        return LongInterval.fromToBy(from, to, to > from ? 2 : -2);\n+    }\n+\n+    /**\n+     * Returns an LongInterval representing the odd values from the value from to the value to.\n+     */\n+    public static LongInterval oddsFromTo(long from, long to)\n+    {\n+        if (from % 2 == 0)\n+        {\n+            if (from < to)\n+            {\n+                from++;\n+            }\n+            else\n+            {\n+                from--;\n+            }\n+        }\n+        if (to % 2 == 0)\n+        {\n+            if (to > from)\n+            {\n+                to--;\n+            }\n+            else\n+            {\n+                to++;\n+            }\n+        }\n+        return LongInterval.fromToBy(from, to, to > from ? 2 : -2);\n+    }\n+\n+    /**\n+     * Returns an LongInterval for the range of integers inclusively between from and to with the specified\n+     * stepBy value.\n+     */\n+    public static LongInterval fromToBy(long from, long to, long stepBy)\n+    {\n+        IntervalUtils.checkArguments(from, to, stepBy);\n+        return new LongInterval(from, to, stepBy);\n+    }\n+\n+    /**\n+     * Returns true if the LongInterval contains all of the specified long values.\n+     */\n+    @Override\n+    public boolean containsAll(long... values)\n+    {\n+        for (long value : values)\n+        {\n+            if (!this.contains(value))\n+            {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean containsAll(LongIterable source)\n+    {\n+        for (LongIterator iterator = source.longIterator(); iterator.hasNext(); )\n+        {\n+            if (!this.contains(iterator.next()))\n+            {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the LongInterval contains none of the specified long values.\n+     */\n+    public boolean containsNone(int... values)\n+    {\n+        for (long value : values)\n+        {\n+            if (this.contains(value))\n+            {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the LongInterval contains the specified long value.\n+     */\n+    @Override\n+    public boolean contains(long value)\n+    {\n+        return IntervalUtils.contains(value, this.from, this.to, this.step);\n+    }\n+\n+    @Override\n+    public void forEachWithIndex(LongIntProcedure procedure)\n+    {\n+        int index = 0;\n+        if (this.goForward())\n+        {\n+            for (long i = this.from; i <= this.to; i += this.step)\n+            {\n+                procedure.value((int) i, index++);\n+            }\n+        }\n+        else\n+        {\n+            for (long i = this.from; i >= this.to; i += this.step)\n+            {\n+                procedure.value((int) i, index++);\n+            }\n+        }\n+    }\n+\n+    public void forEachWithLongIndex(LongLongProcedure procedure)\n+    {\n+        long index = 0;\n+        if (this.goForward())\n+        {\n+            for (long i = this.from; i <= this.to; i += this.step)\n+            {\n+                procedure.value((int) i, index++);\n+            }\n+        }\n+        else\n+        {\n+            for (long i = this.from; i >= this.to; i += this.step)\n+            {\n+                procedure.value((int) i, index++);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void forEach(LongProcedure procedure)\n+    {\n+        this.each(procedure);\n+    }\n+\n+    private boolean goForward()\n+    {\n+        return this.from <= this.to && this.step > 0;\n+    }\n+\n+    /**\n+     * @since 7.0.\n+     */\n+    @Override\n+    public void each(LongProcedure procedure)\n+    {\n+        if (this.goForward())\n+        {\n+            for (long i = this.from; i <= this.to; i += this.step)\n+            {\n+                procedure.value((int) i);\n+            }\n+        }\n+        else\n+        {\n+            for (long i = this.from; i >= this.to; i += this.step)\n+            {\n+                procedure.value((int) i);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public int count(LongPredicate predicate)\n+    {\n+        int count = 0;\n+        for (int i = 0; i < this.size(); i++)\n+        {\n+            if (predicate.accept(this.get(i)))\n+            {\n+                count++;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    @Override\n+    public boolean anySatisfy(LongPredicate predicate)\n+    {\n+        for (int i = 0; i < this.size(); i++)\n+        {\n+            if (predicate.accept(this.get(i)))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean allSatisfy(LongPredicate predicate)\n+    {\n+        for (int i = 0; i < this.size(); i++)\n+        {\n+            if (!predicate.accept(this.get(i)))\n+            {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean noneSatisfy(LongPredicate predicate)\n+    {\n+        for (int i = 0; i < this.size(); i++)\n+        {\n+            if (predicate.accept(this.get(i)))\n+            {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean equals(Object otherList)\n+    {\n+        if (otherList == this)\n+        {\n+            return true;\n+        }\n+        if (!(otherList instanceof LongList))\n+        {\n+            return false;\n+        }\n+        LongList list = (LongList) otherList;\n+        if (this.size() != list.size())\n+        {\n+            return false;\n+        }\n+        if (this.from == this.to)\n+        {\n+            return this.from == list.get(0);\n+        }\n+\n+        if (otherList instanceof LongInterval)\n+        {\n+            LongInterval otherInterval = (LongInterval) otherList;\n+            return (this.getFirst() == otherInterval.getFirst())\n+                    && (this.getLast() == otherInterval.getLast())\n+                    && (this.step == otherInterval.step);\n+        }\n+\n+        if (this.from < this.to)\n+        {\n+            int listIndex = 0;\n+            for (long i = this.from; i <= this.to; i += this.step)\n+            {\n+                if (i != list.get(listIndex++))\n+                {\n+                    return false;\n+                }\n+            }\n+        }\n+        else\n+        {\n+            int listIndex = 0;\n+            for (long i = this.from; i >= this.to; i += this.step)\n+            {\n+                if (i != list.get(listIndex++))\n+                {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        int hashCode = 1;\n+        if (this.from == this.to)\n+        {\n+            hashCode = 31 * hashCode + (int) (this.from ^ this.from >>> 32);\n+        }\n+        else if (this.from < this.to)\n+        {\n+            for (long i = this.from; i <= this.to; i += this.step)\n+            {\n+                hashCode = 31 * hashCode + (int) (i ^ i >>> 32);\n+            }\n+        }\n+        else\n+        {\n+            for (long i = this.from; i >= this.to; i += this.step)\n+            {\n+                hashCode = 31 * hashCode + (int) (i ^ i >>> 32);\n+            }\n+        }\n+        return hashCode;\n+    }\n+\n+    /**\n+     * Returns a new LongInterval with the from and to values reversed and the step value negated.\n+     */\n+    @Override\n+    public LongInterval toReversed()\n+    {\n+        return LongInterval.fromToBy(this.to, this.from, -this.step);\n+    }\n+\n+    /**\n+     * @since 6.0\n+     */\n+    @Override\n+    public ImmutableLongList distinct()\n+    {\n+        return this;\n+    }\n+\n+    @Override\n+    public ImmutableLongList subList(int fromIndex, int toIndex)\n+    {\n+        throw new UnsupportedOperationException(\"subList not yet implemented!\");\n+    }\n+\n+    /**\n+     * Returns the size of the interval.\n+     */\n+    @Override\n+    public int size()\n+    {\n+        return this.size;\n+    }\n+\n+    @Override\n+    public long dotProduct(LongList list)\n+    {\n+        if (this.size() != list.size())\n+        {\n+            throw new IllegalArgumentException(\"Lists used in dotProduct must be the same size\");\n+        }\n+        long sum = 0L;\n+        for (int i = 0; i < this.size(); i++)\n+        {\n+            sum += this.get(i) * list.get(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Override\n+    public boolean isEmpty()\n+    {\n+        return this.size() == 0;", "originalCommit": "805fd16aee066a03b3166c52a2b2328eb30b361d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNDkwNQ==", "url": "https://github.com/eclipse/eclipse-collections/pull/909#discussion_r437104905", "bodyText": "Same issue in IntInterval (which I effectively cloned), can change implementation/add tests to both or have a separate PR to clean up this and other implementation issues. What do you suggest?", "author": "vmzakharov", "createdAt": "2020-06-09T02:36:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3NTg2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNjgxNw==", "url": "https://github.com/eclipse/eclipse-collections/pull/909#discussion_r437116817", "bodyText": "For my understanding, is the proposal to return false instead of doing the check? Like Moh says it will always be false but this implementation is not incorrect or did I miss something? Interval always makes me think twice about these terminating methods because Interval is a mix of eager and lazy functionality.", "author": "nikhilnanivadekar", "createdAt": "2020-06-09T03:25:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3NTg2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNzc0Mg==", "url": "https://github.com/eclipse/eclipse-collections/pull/909#discussion_r437117742", "bodyText": "yes, the proposal is to return false. An implementation that computes PI to 700 digits and then returns lastDigit == 0 would also work (the 700th digit of PI is 5) \ud83d\ude1b .", "author": "mohrezaei", "createdAt": "2020-06-09T03:29:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3NTg2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEyMjMwMw==", "url": "https://github.com/eclipse/eclipse-collections/pull/909#discussion_r437122303", "bodyText": "LOL \ud83d\ude02", "author": "nikhilnanivadekar", "createdAt": "2020-06-09T03:50:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3NTg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3ODI0NQ==", "url": "https://github.com/eclipse/eclipse-collections/pull/909#discussion_r437078245", "bodyText": "[N.B. comment applies to whole class, so placed up here]\nWhy is the looping in this class so inconsistent? Sometimes it's fully expanded (e.g. forEach, equals, etc). Sometimes, it's using a for-loop with this.get(i). Sometimes, it's using forEach* with a lambda. And yet other places, a LongIterator is used. It's like 4 different people wrote this class \ud83d\ude04", "author": "mohrezaei", "createdAt": "2020-06-09T00:54:00Z", "path": "eclipse-collections/src/main/java/org/eclipse/collections/impl/list/primitive/LongInterval.java", "diffHunk": "@@ -0,0 +1,1092 @@\n+/*", "originalCommit": "805fd16aee066a03b3166c52a2b2328eb30b361d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwNDkzOA==", "url": "https://github.com/eclipse/eclipse-collections/pull/909#discussion_r437104938", "bodyText": "Same as above - I followed the implementation pattern of IntInterval - one reason didn't want to diverge because it would make it harder to turn it into a code generated template if we decide to do so in the future.   My preference is to leave it as it and have a separate PR to clean up both classes (and keep them consistent). Please let me know what you think.", "author": "vmzakharov", "createdAt": "2020-06-09T02:36:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3ODI0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExMDQ5Mg==", "url": "https://github.com/eclipse/eclipse-collections/pull/909#discussion_r437110492", "bodyText": "My preference would be to have a clean implementation here and another PR to clean up IntInterval. Others are welcome to chime in. @donraab @nikhilnanivadekar @motlin ?", "author": "mohrezaei", "createdAt": "2020-06-09T02:59:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3ODI0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNTYyNw==", "url": "https://github.com/eclipse/eclipse-collections/pull/909#discussion_r437115627", "bodyText": "I am more of let\u2019s get this one in first and then clean up one or both. I am waiting for these PRs to be closer to release 10.3.0. So the fastest way to that is more preferable for me.", "author": "nikhilnanivadekar", "createdAt": "2020-06-09T03:20:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3ODI0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzU0NDY1Mw==", "url": "https://github.com/eclipse/eclipse-collections/pull/909#discussion_r437544653", "bodyText": "I have fixed sum() and added more tests for it (specifically to address the concern about overflow during calculation), and have added a test for isEmpty(). My preference now would be to get LongInterval in as is and open a new issue for LongInterval and IntInterval code clean up (happy to work on it as the potential is certainly there!)", "author": "vmzakharov", "createdAt": "2020-06-09T16:00:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3ODI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3ODYwOA==", "url": "https://github.com/eclipse/eclipse-collections/pull/909#discussion_r437078608", "bodyText": "does the formula based implementation not work for longs? overflow?", "author": "mohrezaei", "createdAt": "2020-06-09T00:55:29Z", "path": "eclipse-collections/src/main/java/org/eclipse/collections/impl/list/primitive/LongInterval.java", "diffHunk": "@@ -0,0 +1,1092 @@\n+/*\n+ * Copyright (c) 2019 Goldman Sachs and others.\n+ * All rights reserved. This program and the accompanying materials\n+ * are made available under the terms of the Eclipse Public License v1.0\n+ * and Eclipse Distribution License v. 1.0 which accompany this distribution.\n+ * The Eclipse Public License is available at http://www.eclipse.org/legal/epl-v10.html\n+ * and the Eclipse Distribution License is available at\n+ * http://www.eclipse.org/org/documents/edl-v10.php.\n+ */\n+\n+package org.eclipse.collections.impl.list.primitive;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.NoSuchElementException;\n+import java.util.Spliterator;\n+import java.util.function.LongConsumer;\n+\n+import org.eclipse.collections.api.LazyLongIterable;\n+import org.eclipse.collections.api.LongIterable;\n+import org.eclipse.collections.api.RichIterable;\n+import org.eclipse.collections.api.bag.primitive.MutableLongBag;\n+import org.eclipse.collections.api.block.function.primitive.LongToObjectFunction;\n+import org.eclipse.collections.api.block.function.primitive.ObjectLongIntToObjectFunction;\n+import org.eclipse.collections.api.block.function.primitive.ObjectLongToObjectFunction;\n+import org.eclipse.collections.api.block.predicate.primitive.LongPredicate;\n+import org.eclipse.collections.api.block.procedure.primitive.LongIntProcedure;\n+import org.eclipse.collections.api.block.procedure.primitive.LongLongProcedure;\n+import org.eclipse.collections.api.block.procedure.primitive.LongProcedure;\n+import org.eclipse.collections.api.factory.Lists;\n+import org.eclipse.collections.api.iterator.LongIterator;\n+import org.eclipse.collections.api.list.ImmutableList;\n+import org.eclipse.collections.api.list.MutableList;\n+import org.eclipse.collections.api.list.primitive.ImmutableLongList;\n+import org.eclipse.collections.api.list.primitive.LongList;\n+import org.eclipse.collections.api.list.primitive.MutableLongList;\n+import org.eclipse.collections.api.set.primitive.MutableLongSet;\n+import org.eclipse.collections.api.tuple.primitive.LongLongPair;\n+import org.eclipse.collections.api.tuple.primitive.LongObjectPair;\n+import org.eclipse.collections.impl.bag.mutable.primitive.LongHashBag;\n+import org.eclipse.collections.impl.block.factory.primitive.LongPredicates;\n+import org.eclipse.collections.impl.factory.primitive.LongLists;\n+import org.eclipse.collections.impl.lazy.primitive.CollectLongToObjectIterable;\n+import org.eclipse.collections.impl.lazy.primitive.LazyLongIterableAdapter;\n+import org.eclipse.collections.impl.lazy.primitive.ReverseLongIterable;\n+import org.eclipse.collections.impl.lazy.primitive.SelectLongIterable;\n+import org.eclipse.collections.impl.list.IntervalUtils;\n+import org.eclipse.collections.impl.list.mutable.primitive.LongArrayList;\n+import org.eclipse.collections.impl.set.mutable.primitive.LongHashSet;\n+import org.eclipse.collections.impl.tuple.primitive.PrimitiveTuples;\n+import org.eclipse.collections.impl.utility.Iterate;\n+\n+/**\n+ * An LongInterval is a range of longs that may be iterated over using a step value.\n+ * Note that the size of the interval (the number of elements in the list it represents)\n+ * is limited by the maximum value of the integer index.\n+ */\n+public final class LongInterval\n+        implements ImmutableLongList, Serializable\n+{\n+    private static final long serialVersionUID = 1L;\n+\n+    private final long from;\n+    private final long to;\n+    private final long step;\n+    private final int size;\n+\n+    private LongInterval(long from, long to, long step)\n+    {\n+        this.from = from;\n+        this.to = to;\n+        this.step = step;\n+\n+        this.size = IntervalUtils.intSize(this.from, this.to, this.step);\n+    }\n+\n+    /**\n+     * This static {@code from} method allows LongInterval to act as a fluent builder for itself.\n+     * It works in conjunction with the instance methods {@link #to(long)} and {@link #by(long)}.\n+     * <p>\n+     * Usage Example:\n+     * <pre>\n+     * LongInterval interval1 = LongInterval.from(1).to(5);         // results in: 1, 2, 3, 4, 5.\n+     * LongInterval interval2 = LongInterval.from(1).to(10).by(2);  // results in: 1, 3, 5, 7, 9.\n+     * </pre>\n+     */\n+    public static LongInterval from(long newFrom)\n+    {\n+        return LongInterval.fromToBy(newFrom, newFrom, 1);\n+    }\n+\n+    /**\n+     * This instance {@code to} method allows LongInterval to act as a fluent builder for itself.\n+     * It works in conjunction with the static method {@link #from(long)} and instance method {@link #by(long)}.\n+     * <p>\n+     * Usage Example:\n+     * <pre>\n+     * LongInterval interval1 = LongInterval.from(1).to(5);         // results in: 1, 2, 3, 4, 5.\n+     * LongInterval interval2 = LongInterval.from(1).to(10).by(2);  // results in: 1, 3, 5, 7, 9.\n+     * </pre>\n+     */\n+    public LongInterval to(long newTo)\n+    {\n+        return LongInterval.fromToBy(this.from, newTo, this.step);\n+    }\n+\n+    /**\n+     * This instance {@code by} method allows LongInterval to act as a fluent builder for itself.\n+     * It works in conjunction with the static method {@link #from(long)} and instance method {@link #to(long)}.\n+     * <p>\n+     * Usage Example:\n+     * <pre>\n+     * LongInterval interval1 = LongInterval.from(1).to(5);         // results in: 1, 2, 3, 4, 5.\n+     * LongInterval interval2 = LongInterval.from(1).to(10).by(2);  // results in: 1, 3, 5, 7, 9.\n+     * </pre>\n+     */\n+    public LongInterval by(long newStep)\n+    {\n+        return LongInterval.fromToBy(this.from, this.to, newStep);\n+    }\n+\n+    /**\n+     * Returns an LongInterval starting at zero.\n+     * <p>\n+     * Usage Example:\n+     * <pre>\n+     * LongInterval interval1 = LongInterval.zero().to(5);         // results in: 0, 1, 2, 3, 4, 5.\n+     * LongInterval interval2 = LongInterval.zero().to(10).by(2);  // results in: 0, 2, 4, 6, 8, 10.\n+     * </pre>\n+     */\n+    public static LongInterval zero()\n+    {\n+        return LongInterval.from(0);\n+    }\n+\n+    /**\n+     * Returns an LongInterval starting from 1 to the specified count value with a step value of 1.\n+     */\n+    public static LongInterval oneTo(long count)\n+    {\n+        return LongInterval.oneToBy(count, 1);\n+    }\n+\n+    /**\n+     * Returns an LongInterval starting from 1 to the specified count value with a step value of step.\n+     */\n+    public static LongInterval oneToBy(long count, long step)\n+    {\n+        if (count < 1)\n+        {\n+            throw new IllegalArgumentException(\"Only positive ranges allowed using oneToBy\");\n+        }\n+        return LongInterval.fromToBy(1, count, step);\n+    }\n+\n+    /**\n+     * Returns an LongInterval starting from 0 to the specified count value with a step value of 1.\n+     */\n+    public static LongInterval zeroTo(long count)\n+    {\n+        return LongInterval.zeroToBy(count, 1);\n+    }\n+\n+    /**\n+     * Returns an LongInterval starting from 0 to the specified count value with a step value of step.\n+     */\n+    public static LongInterval zeroToBy(long count, long step)\n+    {\n+        return LongInterval.fromToBy(0, count, step);\n+    }\n+\n+    /**\n+     * Returns an LongInterval starting from the value from to the specified value to with a step value of 1.\n+     */\n+    public static LongInterval fromTo(long from, long to)\n+    {\n+        if (from <= to)\n+        {\n+            return LongInterval.fromToBy(from, to, 1);\n+        }\n+        return LongInterval.fromToBy(from, to, -1);\n+    }\n+\n+    /**\n+     * Returns an LongInterval representing the even values from the value from to the value to.\n+     */\n+    public static LongInterval evensFromTo(long from, long to)\n+    {\n+        if (from % 2 != 0)\n+        {\n+            if (from < to)\n+            {\n+                from++;\n+            }\n+            else\n+            {\n+                from--;\n+            }\n+        }\n+        if (to % 2 != 0)\n+        {\n+            if (to > from)\n+            {\n+                to--;\n+            }\n+            else\n+            {\n+                to++;\n+            }\n+        }\n+        return LongInterval.fromToBy(from, to, to > from ? 2 : -2);\n+    }\n+\n+    /**\n+     * Returns an LongInterval representing the odd values from the value from to the value to.\n+     */\n+    public static LongInterval oddsFromTo(long from, long to)\n+    {\n+        if (from % 2 == 0)\n+        {\n+            if (from < to)\n+            {\n+                from++;\n+            }\n+            else\n+            {\n+                from--;\n+            }\n+        }\n+        if (to % 2 == 0)\n+        {\n+            if (to > from)\n+            {\n+                to--;\n+            }\n+            else\n+            {\n+                to++;\n+            }\n+        }\n+        return LongInterval.fromToBy(from, to, to > from ? 2 : -2);\n+    }\n+\n+    /**\n+     * Returns an LongInterval for the range of integers inclusively between from and to with the specified\n+     * stepBy value.\n+     */\n+    public static LongInterval fromToBy(long from, long to, long stepBy)\n+    {\n+        IntervalUtils.checkArguments(from, to, stepBy);\n+        return new LongInterval(from, to, stepBy);\n+    }\n+\n+    /**\n+     * Returns true if the LongInterval contains all of the specified long values.\n+     */\n+    @Override\n+    public boolean containsAll(long... values)\n+    {\n+        for (long value : values)\n+        {\n+            if (!this.contains(value))\n+            {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean containsAll(LongIterable source)\n+    {\n+        for (LongIterator iterator = source.longIterator(); iterator.hasNext(); )\n+        {\n+            if (!this.contains(iterator.next()))\n+            {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the LongInterval contains none of the specified long values.\n+     */\n+    public boolean containsNone(int... values)\n+    {\n+        for (long value : values)\n+        {\n+            if (this.contains(value))\n+            {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Returns true if the LongInterval contains the specified long value.\n+     */\n+    @Override\n+    public boolean contains(long value)\n+    {\n+        return IntervalUtils.contains(value, this.from, this.to, this.step);\n+    }\n+\n+    @Override\n+    public void forEachWithIndex(LongIntProcedure procedure)\n+    {\n+        int index = 0;\n+        if (this.goForward())\n+        {\n+            for (long i = this.from; i <= this.to; i += this.step)\n+            {\n+                procedure.value((int) i, index++);\n+            }\n+        }\n+        else\n+        {\n+            for (long i = this.from; i >= this.to; i += this.step)\n+            {\n+                procedure.value((int) i, index++);\n+            }\n+        }\n+    }\n+\n+    public void forEachWithLongIndex(LongLongProcedure procedure)\n+    {\n+        long index = 0;\n+        if (this.goForward())\n+        {\n+            for (long i = this.from; i <= this.to; i += this.step)\n+            {\n+                procedure.value((int) i, index++);\n+            }\n+        }\n+        else\n+        {\n+            for (long i = this.from; i >= this.to; i += this.step)\n+            {\n+                procedure.value((int) i, index++);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public void forEach(LongProcedure procedure)\n+    {\n+        this.each(procedure);\n+    }\n+\n+    private boolean goForward()\n+    {\n+        return this.from <= this.to && this.step > 0;\n+    }\n+\n+    /**\n+     * @since 7.0.\n+     */\n+    @Override\n+    public void each(LongProcedure procedure)\n+    {\n+        if (this.goForward())\n+        {\n+            for (long i = this.from; i <= this.to; i += this.step)\n+            {\n+                procedure.value((int) i);\n+            }\n+        }\n+        else\n+        {\n+            for (long i = this.from; i >= this.to; i += this.step)\n+            {\n+                procedure.value((int) i);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public int count(LongPredicate predicate)\n+    {\n+        int count = 0;\n+        for (int i = 0; i < this.size(); i++)\n+        {\n+            if (predicate.accept(this.get(i)))\n+            {\n+                count++;\n+            }\n+        }\n+        return count;\n+    }\n+\n+    @Override\n+    public boolean anySatisfy(LongPredicate predicate)\n+    {\n+        for (int i = 0; i < this.size(); i++)\n+        {\n+            if (predicate.accept(this.get(i)))\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public boolean allSatisfy(LongPredicate predicate)\n+    {\n+        for (int i = 0; i < this.size(); i++)\n+        {\n+            if (!predicate.accept(this.get(i)))\n+            {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean noneSatisfy(LongPredicate predicate)\n+    {\n+        for (int i = 0; i < this.size(); i++)\n+        {\n+            if (predicate.accept(this.get(i)))\n+            {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean equals(Object otherList)\n+    {\n+        if (otherList == this)\n+        {\n+            return true;\n+        }\n+        if (!(otherList instanceof LongList))\n+        {\n+            return false;\n+        }\n+        LongList list = (LongList) otherList;\n+        if (this.size() != list.size())\n+        {\n+            return false;\n+        }\n+        if (this.from == this.to)\n+        {\n+            return this.from == list.get(0);\n+        }\n+\n+        if (otherList instanceof LongInterval)\n+        {\n+            LongInterval otherInterval = (LongInterval) otherList;\n+            return (this.getFirst() == otherInterval.getFirst())\n+                    && (this.getLast() == otherInterval.getLast())\n+                    && (this.step == otherInterval.step);\n+        }\n+\n+        if (this.from < this.to)\n+        {\n+            int listIndex = 0;\n+            for (long i = this.from; i <= this.to; i += this.step)\n+            {\n+                if (i != list.get(listIndex++))\n+                {\n+                    return false;\n+                }\n+            }\n+        }\n+        else\n+        {\n+            int listIndex = 0;\n+            for (long i = this.from; i >= this.to; i += this.step)\n+            {\n+                if (i != list.get(listIndex++))\n+                {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode()\n+    {\n+        int hashCode = 1;\n+        if (this.from == this.to)\n+        {\n+            hashCode = 31 * hashCode + (int) (this.from ^ this.from >>> 32);\n+        }\n+        else if (this.from < this.to)\n+        {\n+            for (long i = this.from; i <= this.to; i += this.step)\n+            {\n+                hashCode = 31 * hashCode + (int) (i ^ i >>> 32);\n+            }\n+        }\n+        else\n+        {\n+            for (long i = this.from; i >= this.to; i += this.step)\n+            {\n+                hashCode = 31 * hashCode + (int) (i ^ i >>> 32);\n+            }\n+        }\n+        return hashCode;\n+    }\n+\n+    /**\n+     * Returns a new LongInterval with the from and to values reversed and the step value negated.\n+     */\n+    @Override\n+    public LongInterval toReversed()\n+    {\n+        return LongInterval.fromToBy(this.to, this.from, -this.step);\n+    }\n+\n+    /**\n+     * @since 6.0\n+     */\n+    @Override\n+    public ImmutableLongList distinct()\n+    {\n+        return this;\n+    }\n+\n+    @Override\n+    public ImmutableLongList subList(int fromIndex, int toIndex)\n+    {\n+        throw new UnsupportedOperationException(\"subList not yet implemented!\");\n+    }\n+\n+    /**\n+     * Returns the size of the interval.\n+     */\n+    @Override\n+    public int size()\n+    {\n+        return this.size;\n+    }\n+\n+    @Override\n+    public long dotProduct(LongList list)\n+    {\n+        if (this.size() != list.size())\n+        {\n+            throw new IllegalArgumentException(\"Lists used in dotProduct must be the same size\");\n+        }\n+        long sum = 0L;\n+        for (int i = 0; i < this.size(); i++)\n+        {\n+            sum += this.get(i) * list.get(i);\n+        }\n+        return sum;\n+    }\n+\n+    @Override\n+    public boolean isEmpty()\n+    {\n+        return this.size() == 0;\n+    }\n+\n+    @Override\n+    public boolean notEmpty()\n+    {\n+        return !this.isEmpty();\n+    }\n+\n+    @Override\n+    public String makeString()\n+    {\n+        return this.makeString(\", \");\n+    }\n+\n+    @Override\n+    public String makeString(String separator)\n+    {\n+        return this.makeString(\"\", separator, \"\");\n+    }\n+\n+    @Override\n+    public String makeString(String start, String separator, String end)\n+    {\n+        Appendable stringBuilder = new StringBuilder();\n+        this.appendString(stringBuilder, start, separator, end);\n+        return stringBuilder.toString();\n+    }\n+\n+    @Override\n+    public void appendString(Appendable appendable)\n+    {\n+        this.appendString(appendable, \", \");\n+    }\n+\n+    @Override\n+    public void appendString(Appendable appendable, String separator)\n+    {\n+        this.appendString(appendable, \"\", separator, \"\");\n+    }\n+\n+    @Override\n+    public void appendString(\n+            Appendable appendable,\n+            String start,\n+            String separator,\n+            String end)\n+    {\n+        try\n+        {\n+            appendable.append(start);\n+            for (int i = 0; i < this.size(); i++)\n+            {\n+                if (i > 0)\n+                {\n+                    appendable.append(separator);\n+                }\n+                long value = this.get(i);\n+                appendable.append(String.valueOf(value));\n+            }\n+            appendable.append(end);\n+        }\n+        catch (IOException e)\n+        {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    @Override\n+    public long[] toArray()\n+    {\n+        long[] result = new long[this.size()];\n+        this.forEachWithIndex((each, index) -> result[index] = each);\n+        return result;\n+    }\n+\n+    @Override\n+    public long[] toArray(long[] result)\n+    {\n+        if (result.length < this.size())\n+        {\n+            result = new long[this.size()];\n+        }\n+        long[] finalBypass = result;\n+        this.forEachWithIndex((each, index) -> finalBypass[index] = each);\n+        return result;\n+    }\n+\n+    @Override\n+    public <T> T injectInto(T injectedValue, ObjectLongToObjectFunction<? super T, ? extends T> function)\n+    {\n+        T result = injectedValue;\n+        if (this.goForward())\n+        {\n+            for (long i = this.from; i <= this.to; i += this.step)\n+            {\n+                result = function.valueOf(result, (int) i);\n+            }\n+        }\n+        else\n+        {\n+            for (long i = this.from; i >= this.to; i += this.step)\n+            {\n+                result = function.valueOf(result, (int) i);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public <T> T injectIntoWithIndex(T injectedValue, ObjectLongIntToObjectFunction<? super T, ? extends T> function)\n+    {\n+        T result = injectedValue;\n+        int index = 0;\n+\n+        if (this.goForward())\n+        {\n+            for (long i = this.from; i <= this.to; i += this.step)\n+            {\n+                result = function.valueOf(result, (int) i, index);\n+                index++;\n+            }\n+        }\n+        else\n+        {\n+            for (long i = this.from; i >= this.to; i += this.step)\n+            {\n+                result = function.valueOf(result, (int) i, index);\n+                index++;\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public RichIterable<LongIterable> chunk(int size)\n+    {\n+        if (size <= 0)\n+        {\n+            throw new IllegalArgumentException(\"Size for groups must be positive but was: \" + size);\n+        }\n+        MutableList<LongIterable> result = Lists.mutable.empty();\n+        if (this.notEmpty())\n+        {\n+            long innerFrom = this.from;\n+            long lastUpdated = this.from;\n+            if (this.from <= this.to)\n+            {\n+                while ((lastUpdated + this.step) <= this.to)\n+                {\n+                    MutableLongList batch = LongLists.mutable.empty();\n+                    for (long i = innerFrom; i <= this.to && batch.size() < size; i += this.step)\n+                    {\n+                        batch.add((int) i);\n+                        lastUpdated = (int) i;\n+                    }\n+                    result.add(batch);\n+                    innerFrom = lastUpdated + this.step;\n+                }\n+            }\n+            else\n+            {\n+                while ((lastUpdated + this.step) >= this.to)\n+                {\n+                    MutableLongList batch = LongLists.mutable.empty();\n+                    for (long i = innerFrom; i >= this.to && batch.size() < size; i += this.step)\n+                    {\n+                        batch.add((int) i);\n+                        lastUpdated = (int) i;\n+                    }\n+                    result.add(batch);\n+                    innerFrom = lastUpdated + this.step;\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public String toString()\n+    {\n+        return this.makeString(\"[\", \", \", \"]\");\n+    }\n+\n+    @Override\n+    public LongIterator longIterator()\n+    {\n+        return new LongIntervalIterator();\n+    }\n+\n+    @Override\n+    public long getFirst()\n+    {\n+        return this.from;\n+    }\n+\n+    @Override\n+    public long getLast()\n+    {\n+        return IntervalUtils.valueAtIndex(this.size() - 1, this.from, this.to, this.step);\n+    }\n+\n+    @Override\n+    public long get(int index)\n+    {\n+        this.checkBounds(\"index\", index);\n+        return IntervalUtils.valueAtIndex(index, this.from, this.to, this.step);\n+    }\n+\n+    private void checkBounds(String name, int index)\n+    {\n+        if (index < 0 || index >= this.size())\n+        {\n+            throw new IndexOutOfBoundsException(name + \": \" + index + ' ' + this);\n+        }\n+    }\n+\n+    @Override\n+    public int indexOf(long value)\n+    {\n+        return IntervalUtils.indexOf(value, this.from, this.to, this.step);\n+    }\n+\n+    @Override\n+    public int lastIndexOf(long value)\n+    {\n+        return this.indexOf(value);\n+    }\n+\n+    @Override\n+    public ImmutableLongList select(LongPredicate predicate)\n+    {\n+        return LongArrayList.newList(new SelectLongIterable(this, predicate)).toImmutable();\n+    }\n+\n+    @Override\n+    public ImmutableLongList reject(LongPredicate predicate)\n+    {\n+        return LongArrayList.newList(new SelectLongIterable(this, LongPredicates.not(predicate))).toImmutable();\n+    }\n+\n+    @Override\n+    public long detectIfNone(LongPredicate predicate, long ifNone)\n+    {\n+        return new SelectLongIterable(this, predicate).detectIfNone(predicate, ifNone);\n+    }\n+\n+    @Override\n+    public <V> ImmutableList<V> collect(LongToObjectFunction<? extends V> function)\n+    {\n+        return new CollectLongToObjectIterable<V>(this, function).toList().toImmutable();\n+    }\n+\n+    @Override\n+    public LazyLongIterable asReversed()\n+    {\n+        return ReverseLongIterable.adapt(this);\n+    }\n+\n+    @Override\n+    public long sum()\n+    {\n+        long sum = 0L;", "originalCommit": "805fd16aee066a03b3166c52a2b2328eb30b361d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEwMzY2OA==", "url": "https://github.com/eclipse/eclipse-collections/pull/909#discussion_r437103668", "bodyText": "Should work, will fix", "author": "vmzakharov", "createdAt": "2020-06-09T02:31:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3ODYwOA=="}], "type": "inlineReview"}, {"oid": "5da57ace2464b963a7e139060da4b3500559dc23", "url": "https://github.com/eclipse/eclipse-collections/commit/5da57ace2464b963a7e139060da4b3500559dc23", "message": "Closes #723 added LongInterval\n\nSigned-off-by: vmzakharov <zakharov.vladimir.m@gmail.com>", "committedDate": "2020-06-09T14:04:59Z", "type": "commit"}, {"oid": "5da57ace2464b963a7e139060da4b3500559dc23", "url": "https://github.com/eclipse/eclipse-collections/commit/5da57ace2464b963a7e139060da4b3500559dc23", "message": "Closes #723 added LongInterval\n\nSigned-off-by: vmzakharov <zakharov.vladimir.m@gmail.com>", "committedDate": "2020-06-09T14:04:59Z", "type": "forcePushed"}]}