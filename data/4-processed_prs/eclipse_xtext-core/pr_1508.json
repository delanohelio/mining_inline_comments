{"pr_number": 1508, "pr_title": "[eclipse/xtext#1777] ported more xtend code to java", "pr_createdAt": "2020-05-29T11:21:12Z", "pr_url": "https://github.com/eclipse/xtext-core/pull/1508", "timeline": [{"oid": "4fc97e47ad0883d8a18df2a300898e71ba0069b6", "url": "https://github.com/eclipse/xtext-core/commit/4fc97e47ad0883d8a18df2a300898e71ba0069b6", "message": "[eclipse/xtext#1777] ported more xtend code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-06-03T15:08:17Z", "type": "forcePushed"}, {"oid": "da6e7a2cc3da79f6b4ea2d791f2ee078ec73c79b", "url": "https://github.com/eclipse/xtext-core/commit/da6e7a2cc3da79f6b4ea2d791f2ee078ec73c79b", "message": "[eclipse/xtext#1777] ported more xtend code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-06-03T16:04:36Z", "type": "forcePushed"}, {"oid": "3354f637bfbc9e81340e98653931e88b3e56739e", "url": "https://github.com/eclipse/xtext-core/commit/3354f637bfbc9e81340e98653931e88b3e56739e", "message": "[eclipse/xtext#1777] ported more xtend code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-06-03T16:06:53Z", "type": "forcePushed"}, {"oid": "17eb5d66d6fdb446147bb66b27481dee35c810f5", "url": "https://github.com/eclipse/xtext-core/commit/17eb5d66d6fdb446147bb66b27481dee35c810f5", "message": "[eclipse/xtext#1777] ported more xtend code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-06-03T16:43:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAzNjI4OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1508#discussion_r435036289", "bodyText": "Double parentheses", "author": "szarnekow", "createdAt": "2020-06-04T07:06:47Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/node/GeneratorNodeProcessor.java", "diffHunk": "@@ -0,0 +1,432 @@\n+/**\n+ * Copyright (c) 2017, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace.node;\n+\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.stream.IntStream;\n+\n+import org.eclipse.xtend.lib.annotations.Delegate;\n+import org.eclipse.xtext.generator.trace.AbstractStatefulTraceRegion;\n+import org.eclipse.xtext.generator.trace.AbstractTraceRegion;\n+import org.eclipse.xtext.generator.trace.ILocationData;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.ITextRegionWithLineInformation;\n+import org.eclipse.xtext.util.TextRegionWithLineInformation;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @author Dennis Huebner - New GeneratorNodeProcessor.Context implementation\n+ */\n+public class GeneratorNodeProcessor {\n+\tpublic static class Result implements CharSequence, ITraceRegionProvider {\n+\t\tprivate final CharSequence contentsDelegate;\n+\n+\t\tprivate final AbstractTraceRegion traceRegion;\n+\n+\t\t@Override\n+\t\tpublic AbstractTraceRegion getTraceRegion() throws TraceNotFoundException {\n+\t\t\tif (traceRegion == null) {\n+\t\t\t\tthrow new TraceNotFoundException();\n+\t\t\t}\n+\t\t\treturn traceRegion;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn contentsDelegate.toString();\n+\t\t}\n+\n+\t\tpublic Result(CharSequence contents, AbstractTraceRegion traceRegion) {\n+\t\t\tthis.contentsDelegate = contents;\n+\t\t\tthis.traceRegion = traceRegion;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((contentsDelegate == null) ? 0 : contentsDelegate.hashCode());\n+\t\t\tresult = prime * result + ((traceRegion == null) ? 0 : traceRegion.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tResult other = (Result) obj;\n+\t\t\tif (contentsDelegate == null) {\n+\t\t\t\tif (other.contentsDelegate != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!contentsDelegate.equals(other.contentsDelegate))\n+\t\t\t\treturn false;\n+\t\t\tif (traceRegion == null) {\n+\t\t\t\tif (other.traceRegion != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!traceRegion.equals(other.traceRegion))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tpublic CharSequence getContents() {\n+\t\t\treturn contentsDelegate;\n+\t\t}\n+\n+\t\tpublic char charAt(int index) {\n+\t\t\treturn contentsDelegate.charAt(index);\n+\t\t}\n+\n+\t\tpublic IntStream chars() {\n+\t\t\treturn contentsDelegate.chars();\n+\t\t}\n+\n+\t\tpublic IntStream codePoints() {\n+\t\t\treturn contentsDelegate.codePoints();\n+\t\t}\n+\n+\t\tpublic int length() {\n+\t\t\treturn contentsDelegate.length();\n+\t\t}\n+\n+\t\tpublic CharSequence subSequence(int start, int end) {\n+\t\t\treturn contentsDelegate.subSequence(start, end);\n+\t\t}\n+\t}\n+\n+\tprotected static class Context {\n+\t\tprivate List<StringBuilder> lines = Lists.newArrayList(new StringBuilder());\n+\n+\t\tprivate Deque<IndentNode> currentIndents = new ArrayDeque<IndentNode>();\n+\n+\t\tprivate boolean pendingIndent = true;\n+\n+\t\tprivate AbstractTraceRegion currentRegion = null;\n+\n+\t\tprivate int contentLength = 0;\n+\n+\t\tprivate int indentLength = 0;\n+\n+\t\tpublic String currentLineContent() {\n+\t\t\treturn lines.get(currentLineNumber()).toString();\n+\t\t}\n+\n+\t\tpublic int contentLength() {\n+\t\t\tif (isPendingIndent()) {\n+\t\t\t\treturn (contentLength + indentLength);\n+\t\t\t} else {\n+\t\t\t\treturn contentLength;\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic int currentLineNumber() {\n+\t\t\treturn lines.size() - 1;\n+\t\t}\n+\n+\t\tpublic String getContent() {\n+\t\t\treturn Joiner.on(\"\").join(lines);\n+\t\t}\n+\n+\t\tpublic AbstractTraceRegion getCurrentRegion() {\n+\t\t\treturn currentRegion;\n+\t\t}\n+\n+\t\tpublic void increaseIndent(IndentNode node) {\n+\t\t\tcurrentIndents.push(node);\n+\t\t\trecalculateIndentLength();\n+\t\t}\n+\n+\t\tpublic void decreaseIndents() {\n+\t\t\tcurrentIndents.pop();\n+\t\t\trecalculateIndentLength();\n+\t\t}\n+\n+\t\tprotected int recalculateIndentLength() {\n+\t\t\treturn indentLength = IterableExtensions.fold(getCurrentIndents(), 0,\n+\t\t\t\t\t($0, $1) -> $0.intValue() + $1.getIndentationString().length());\n+\t\t}\n+\n+\t\tpublic void appendToCurrentLine(CharSequence chars) {\n+\t\t\tlines.get(currentLineNumber()).append(chars);\n+\t\t\tcontentLength = contentLength + chars.length();\n+\t\t}\n+\n+\t\tpublic boolean isPendingIndent() {\n+\t\t\treturn pendingIndent;\n+\t\t}\n+\n+\t\tpublic void addNewLine() {\n+\t\t\tlines.add(new StringBuilder());\n+\t\t}\n+\n+\t\tpublic void setPendingIndent(boolean pending) {\n+\t\t\tthis.pendingIndent = pending;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Replace the current line with new StringBuilder\n+\t\t */\n+\t\tpublic void resetCurrentLine() {\n+\t\t\tStringBuilder lineContent = lines.get(currentLineNumber());\n+\t\t\tif (!isNullOrEmpty(lineContent)) {\n+\t\t\t\tcontentLength = contentLength - lineContent.length();\n+\t\t\t}\n+\t\t\tlines.set(currentLineNumber(), new StringBuilder());\n+\t\t}\n+\n+\t\tpublic void insertIntoCurrentLine(int i, StringBuilder builder) {\n+\t\t\tlines.get(currentLineNumber()).insert(i, builder);\n+\t\t\tcontentLength = contentLength + builder.length();\n+\t\t}\n+\n+\t\t/**\n+\t\t * @return a copy of current indent nodes\n+\t\t */\n+\t\tpublic Deque<IndentNode> getCurrentIndents() {\n+\t\t\treturn new ArrayDeque<IndentNode>(currentIndents);\n+\t\t}\n+\n+\t\tpublic AbstractTraceRegion setCurrentRegion(AbstractTraceRegion region) {\n+\t\t\treturn currentRegion = region;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Used to avoid multi-pass processing, when constructing a trace region tree.\n+\t * \n+\t * @author Sven Efftinge - Initial contribution and API\n+\t */\n+\tpublic static class CompletableTraceRegion extends AbstractStatefulTraceRegion {\n+\t\tpublic static class CompletableTextRegion implements ITextRegionWithLineInformation {\n+\t\t\tprivate ITextRegionWithLineInformation delegate;\n+\n+\t\t\t@Delegate\n+\t\t\tpublic ITextRegionWithLineInformation getDelegate() {\n+\t\t\t\tif ((delegate == null)) {", "originalCommit": "17eb5d66d6fdb446147bb66b27481dee35c810f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAzNjkzMg==", "url": "https://github.com/eclipse/xtext-core/pull/1508#discussion_r435036932", "bodyText": "can be static", "author": "szarnekow", "createdAt": "2020-06-04T07:08:10Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/node/TemplateNode.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2017, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace.node;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.xtend2.lib.StringConcatenationClient;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * A template node applies a {@link StringConcatenationClient} to compute its children.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class TemplateNode extends CompositeGeneratorNode\n+\t\timplements StringConcatenationClient.TargetStringConcatenation {\n+\tprivate final GeneratorNodeExtensions nodeFactory;\n+\n+\tpublic TemplateNode(StringConcatenationClient contents, GeneratorNodeExtensions nodeFactory) {\n+\t\tthis.nodeFactory = nodeFactory;\n+\t\tStringConcatenationClient.appendTo(contents, this);\n+\t}\n+\n+\tprivate CompositeGeneratorNode currentParent = this;\n+\n+\t@Override\n+\tpublic void append(Object object, String indentation) {\n+\t\tif (indentation.length() > 0) {\n+\t\t\tCompositeGeneratorNode before = currentParent;\n+\t\t\ttry {\n+\t\t\t\tcurrentParent = new IndentNode(indentation, false, true);\n+\t\t\t\tbefore.getChildren().add(currentParent);\n+\t\t\t\tappend(object);\n+\t\t\t} finally {\n+\t\t\t\tcurrentParent = before;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tappend(object);\n+\t\t}\n+\t}\n+\n+\tprivate Splitter lineSplitter = Splitter.on(Pattern.compile(\"\\\\R\"));", "originalCommit": "17eb5d66d6fdb446147bb66b27481dee35c810f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAzNzIwMQ==", "url": "https://github.com/eclipse/xtext-core/pull/1508#discussion_r435037201", "bodyText": "unused? Maybe remove this method.", "author": "szarnekow", "createdAt": "2020-06-04T07:08:46Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/node/TemplateNode.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/**\n+ * Copyright (c) 2017, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace.node;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+\n+import org.eclipse.xtend2.lib.StringConcatenationClient;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.ListExtensions;\n+\n+import com.google.common.base.Splitter;\n+import com.google.common.collect.Iterables;\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * A template node applies a {@link StringConcatenationClient} to compute its children.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class TemplateNode extends CompositeGeneratorNode\n+\t\timplements StringConcatenationClient.TargetStringConcatenation {\n+\tprivate final GeneratorNodeExtensions nodeFactory;\n+\n+\tpublic TemplateNode(StringConcatenationClient contents, GeneratorNodeExtensions nodeFactory) {\n+\t\tthis.nodeFactory = nodeFactory;\n+\t\tStringConcatenationClient.appendTo(contents, this);\n+\t}\n+\n+\tprivate CompositeGeneratorNode currentParent = this;\n+\n+\t@Override\n+\tpublic void append(Object object, String indentation) {\n+\t\tif (indentation.length() > 0) {\n+\t\t\tCompositeGeneratorNode before = currentParent;\n+\t\t\ttry {\n+\t\t\t\tcurrentParent = new IndentNode(indentation, false, true);\n+\t\t\t\tbefore.getChildren().add(currentParent);\n+\t\t\t\tappend(object);\n+\t\t\t} finally {\n+\t\t\t\tcurrentParent = before;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tappend(object);\n+\t\t}\n+\t}\n+\n+\tprivate Splitter lineSplitter = Splitter.on(Pattern.compile(\"\\\\R\"));\n+\n+\t@Override\n+\tpublic void append(Object object) {\n+\t\tif (object == null) {\n+\t\t\treturn;\n+\t\t}\n+\t\tif (object instanceof StringConcatenationClient) {\n+\t\t\tnodeFactory.appendTemplate(currentParent, ((StringConcatenationClient) object));\n+\t\t} else if (object instanceof IGeneratorNode) {\n+\t\t\tcurrentParent.getChildren().add((IGeneratorNode) object);\n+\t\t} else {\n+\t\t\tString str = object.toString();\n+\t\t\tIterator<String> iter = lineSplitter.split(str).iterator();\n+\t\t\twhile (iter.hasNext()) {\n+\t\t\t\tString segment = iter.next();\n+\t\t\t\tnodeFactory.append(currentParent, segment);\n+\t\t\t\tif (iter.hasNext()) {\n+\t\t\t\t\tnewLine();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected Iterable<IGeneratorNode> leafsBackwards(IGeneratorNode it) {", "originalCommit": "17eb5d66d6fdb446147bb66b27481dee35c810f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAzODc0MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1508#discussion_r435038741", "bodyText": "deprecate and mark for removal?", "author": "cdietrich", "createdAt": "2020-06-04T07:11:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAzNzIwMQ=="}], "type": "inlineReview"}, {"oid": "60688817f5cf444ea4cf50b73fcdc87684ad4c4f", "url": "https://github.com/eclipse/xtext-core/commit/60688817f5cf444ea4cf50b73fcdc87684ad4c4f", "message": "[eclipse/xtext#1777] ported more xtend code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-06-04T07:32:30Z", "type": "commit"}, {"oid": "60688817f5cf444ea4cf50b73fcdc87684ad4c4f", "url": "https://github.com/eclipse/xtext-core/commit/60688817f5cf444ea4cf50b73fcdc87684ad4c4f", "message": "[eclipse/xtext#1777] ported more xtend code to java\n\nSigned-off-by: Christian Dietrich <christian.dietrich@itemis.de>", "committedDate": "2020-06-04T07:32:30Z", "type": "forcePushed"}]}