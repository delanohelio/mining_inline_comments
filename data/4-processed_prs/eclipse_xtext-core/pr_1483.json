{"pr_number": 1483, "pr_title": "[#1466] Global unique name validator", "pr_createdAt": "2020-05-11T07:29:07Z", "pr_url": "https://github.com/eclipse/xtext-core/pull/1483", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjgzODg0Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r422838847", "bodyText": "Copyright (c) 2020 Sebastian Zarnekow and others.", "author": "kthoms", "createdAt": "2020-05-11T07:31:45Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/LocalUniqueNameContext.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.", "originalCommit": "47084d000c209365279e692a52f7ee5ebedd6ad1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjgzOTAxMw==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r422839013", "bodyText": "Copyright (c) 2020 Sebastian Zarnekow and others.", "author": "kthoms", "createdAt": "2020-05-11T07:32:03Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/UniqueInResourceContext.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.", "originalCommit": "47084d000c209365279e692a52f7ee5ebedd6ad1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg0NjAxOA==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r422846018", "bodyText": "should we filter for null?", "author": "cdietrich", "createdAt": "2020-05-11T07:45:09Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/impl/IsAffectedExtension.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.resource.impl;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.IResourceDescription.Delta;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.inject.Binding;\n+import com.google.inject.Inject;\n+import com.google.inject.Injector;\n+import com.google.inject.Provider;\n+import com.google.inject.TypeLiteral;\n+\n+/**\n+ * An extension that can be bound to compute resources as being affected\n+ * by a change beyond the default linking semantics, e.g. some validations\n+ * may be necessary to be retriggered after changes to other resources. \n+ * \n+ * @since 2.22\n+ */\n+public interface IsAffectedExtension {\n+\t\n+\tstatic class AllIsAffectedExtensions implements Provider<ImmutableList<IsAffectedExtension>> {\n+\n+\t\t@Inject\tInjector injector;\n+\t\t\n+\t\t@Override\n+\t\tpublic ImmutableList<IsAffectedExtension> get() {\n+\t\t\tImmutableList.Builder<IsAffectedExtension> result = ImmutableList.builder();\n+\t\t\tList<Binding<IsAffectedExtension>> bindings = injector.findBindingsByType(TypeLiteral.get(IsAffectedExtension.class));\n+\t\t\tfor(Binding<IsAffectedExtension> binding: bindings) {\n+\t\t\t\tresult.add(binding.getProvider().get());", "originalCommit": "47084d000c209365279e692a52f7ee5ebedd6ad1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg0NzQ5OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r422847499", "bodyText": "does this work with dirty state?", "author": "cdietrich", "createdAt": "2020-05-11T07:47:54Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/DefaultUniqueNameContext.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.validation;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtext.resource.IContainer;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.IResourceDescriptionsProvider;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.resource.impl.AbstractCompoundSelectable;\n+import org.eclipse.xtext.scoping.ICaseInsensitivityHelper;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.INamesAreUniqueValidationHelper.Context;\n+\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * Standard implementation of a {@link INamesAreUniqueValidationHelper.Context}. \n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @since 2.22\n+ */\n+public class DefaultUniqueNameContext implements INamesAreUniqueValidationHelper.Context {\n+\n+\t/**\n+\t * Base class for {@link INamesAreUniqueValidationHelper.ContextProvider}.\n+\t */\n+\tpublic static abstract class BaseContextProvider implements INamesAreUniqueValidationHelper.ContextProvider {\n+\t\t@Inject\n+\t\tprivate IResourceServiceProvider.Registry resourceServiceProviderRegistry = IResourceServiceProvider.Registry.INSTANCE;\n+\t\t@Inject\n+\t\tprivate ICaseInsensitivityHelper caseInsensitivityHelper;\n+\t\t\n+\t\tprotected IResourceServiceProvider getResourceServiceProvider(Resource r) {\n+\t\t\treturn resourceServiceProviderRegistry.getResourceServiceProvider(r.getURI());\n+\t\t}\n+\t\t\n+\t\tprotected IResourceDescription getResourceDescription(Resource resource) {\n+\t\t\tIResourceDescription.Manager manager = getResourceDescriptionManager(resource);\n+\t\t\tif (manager != null) {\n+\t\t\t\treturn manager.getResourceDescription(resource);\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tprotected IResourceDescription.Manager getResourceDescriptionManager(Resource resource) {\n+\t\t\tIResourceServiceProvider resourceServiceProvider = getResourceServiceProvider(resource);\n+\t\t\tif (resourceServiceProvider==null)\n+\t\t\t\treturn null;\n+\t\t\treturn resourceServiceProvider.getResourceDescriptionManager();\n+\t\t}\n+\t\t\n+\t\tprotected ICaseInsensitivityHelper getCaseInsensitivityHelper() {\n+\t\t\treturn caseInsensitivityHelper;\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Base class for non-local unique name validation context providers.\n+\t */\n+\tpublic static abstract class BaseGlobalContextProvider extends BaseContextProvider {\n+\t\t@Inject\n+\t\tprivate IResourceDescriptionsProvider indexAccess;", "originalCommit": "47084d000c209365279e692a52f7ee5ebedd6ad1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg0ODE0Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r422848147", "bodyText": "Yes, it does.", "author": "szarnekow", "createdAt": "2020-05-11T07:49:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg0NzQ5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg1MTA0OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r422851049", "bodyText": "does this work on renames?", "author": "cdietrich", "createdAt": "2020-05-11T07:54:16Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/DefaultUniqueNameContext.java", "diffHunk": "@@ -0,0 +1,317 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.validation;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtext.resource.IContainer;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.IResourceDescriptionsProvider;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.resource.impl.AbstractCompoundSelectable;\n+import org.eclipse.xtext.scoping.ICaseInsensitivityHelper;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.INamesAreUniqueValidationHelper.Context;\n+\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * Standard implementation of a {@link INamesAreUniqueValidationHelper.Context}. \n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @since 2.22\n+ */\n+public class DefaultUniqueNameContext implements INamesAreUniqueValidationHelper.Context {\n+\n+\t/**\n+\t * Base class for {@link INamesAreUniqueValidationHelper.ContextProvider}.\n+\t */\n+\tpublic static abstract class BaseContextProvider implements INamesAreUniqueValidationHelper.ContextProvider {\n+\t\t@Inject\n+\t\tprivate IResourceServiceProvider.Registry resourceServiceProviderRegistry = IResourceServiceProvider.Registry.INSTANCE;\n+\t\t@Inject\n+\t\tprivate ICaseInsensitivityHelper caseInsensitivityHelper;\n+\t\t\n+\t\tprotected IResourceServiceProvider getResourceServiceProvider(Resource r) {\n+\t\t\treturn resourceServiceProviderRegistry.getResourceServiceProvider(r.getURI());\n+\t\t}\n+\t\t\n+\t\tprotected IResourceDescription getResourceDescription(Resource resource) {\n+\t\t\tIResourceDescription.Manager manager = getResourceDescriptionManager(resource);\n+\t\t\tif (manager != null) {\n+\t\t\t\treturn manager.getResourceDescription(resource);\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tprotected IResourceDescription.Manager getResourceDescriptionManager(Resource resource) {\n+\t\t\tIResourceServiceProvider resourceServiceProvider = getResourceServiceProvider(resource);\n+\t\t\tif (resourceServiceProvider==null)\n+\t\t\t\treturn null;\n+\t\t\treturn resourceServiceProvider.getResourceDescriptionManager();\n+\t\t}\n+\t\t\n+\t\tprotected ICaseInsensitivityHelper getCaseInsensitivityHelper() {\n+\t\t\treturn caseInsensitivityHelper;\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Base class for non-local unique name validation context providers.\n+\t */\n+\tpublic static abstract class BaseGlobalContextProvider extends BaseContextProvider {\n+\t\t@Inject\n+\t\tprivate IResourceDescriptionsProvider indexAccess;\n+\t\t\n+\t\tprotected IResourceDescriptions getIndex(Resource resource) {\n+\t\t\tResourceSet resourceSet = resource.getResourceSet();\n+\t\t\tif (resourceSet == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn indexAccess.getResourceDescriptions(resourceSet);\n+\t\t}\n+\t\t\n+\t\tprotected boolean intersects(IResourceDescription left, IResourceDescription right, boolean caseSensitive) {\n+\t\t\tfor(IEObjectDescription description: left.getExportedObjects()) {\n+\t\t\t\tIterable<IEObjectDescription> exportedObjects = right.getExportedObjects(EcorePackage.Literals.EOBJECT, description.getName(), !caseSensitive);\n+\t\t\t\tif (!Iterables.isEmpty(exportedObjects)) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\t\t\n+\t\tprotected boolean isAffected(IResourceDescription.Delta delta, IResourceDescription candidate, boolean caseSensitive) {\n+\t\t\tif (candidate.getURI().equals(delta.getUri())) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (delta.getNew() != null && intersects(delta.getNew(), candidate, caseSensitive)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tif (delta.getOld() != null && intersects(delta.getOld(), candidate, caseSensitive)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Provide a context for the entire index.\n+\t * \n+\t * Drawback: If a resoure in a project A introduces a duplication with a resource in project B,\n+\t * an incremental build of A may fail to notify B, if B is a dependency of A. Triggering a clean\n+\t * build in B will subsequently create the validation problem / fix the validation problem there, too\n+\t * but in Eclipse, the incremental build will not provide the same level of consistency.  \n+\t */\n+\t@Singleton\n+\tpublic static class Global extends BaseGlobalContextProvider {\n+\n+\t\t@Override\n+\t\tpublic Context tryGetContext(Resource resource, CancelIndicator cancelIndicator) {\n+\t\t\tIResourceDescriptions index = getIndex(resource);\n+\t\t\tif (index == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tIResourceDescription description = getResourceDescription(resource);\n+\t\t\tif (description != null) {\n+\t\t\t\treturn new DefaultUniqueNameContext(description, index, getCaseInsensitivityHelper(), cancelIndicator);\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t}\n+\t\t\n+\t\t@Override\n+\t\tpublic boolean isAffected(Collection<IResourceDescription.Delta> deltas, IResourceDescription candidate,\n+\t\t\t\tIResourceDescriptions context) {\n+\t\t\tfor(IResourceDescription.Delta delta: deltas) {\n+\t\t\t\tif (isAffected(delta, candidate, true)) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t}\n+\t\n+\t/**\n+\t * Provide a context for current {@link IContainer}.\n+\t */\n+\t@Singleton\n+\tpublic static class Container extends BaseGlobalContextProvider {\n+\n+\t\t@Inject\n+\t\tprivate IContainer.Manager containerManager;\n+\t\t\n+\t\t@Override\n+\t\tpublic Context tryGetContext(Resource resource, CancelIndicator cancelIndicator) {\n+\t\t\tIResourceDescriptions index = getIndex(resource);\n+\t\t\tif (index == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tIResourceDescription description = getResourceDescription(resource);\n+\t\t\tif (description == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tIContainer container = containerManager.getContainer(description, index);\n+\t\t\treturn new DefaultUniqueNameContext(description, container, getCaseInsensitivityHelper(), cancelIndicator);\n+\t\t}\n+\t\t\n+\t\t@Override\n+\t\tpublic boolean isAffected(\n+\t\t\t\tCollection<IResourceDescription.Delta> deltas,\n+\t\t\t\tIResourceDescription candidate,\n+\t\t\t\tIResourceDescriptions context) {\n+\t\t\tIContainer container = containerManager.getContainer(candidate, context);\n+\t\t\tfor(IResourceDescription.Delta delta: deltas) {\n+\t\t\t\tif (delta.getNew() == null) {\n+\t\t\t\t\tif (intersects(delta.getOld(), candidate, true)) {\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tif (container.getResourceDescription(delta.getUri())!=null) {\n+\t\t\t\t\t\tif (isAffected(delta, candidate, true)) {\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t}\n+\t\n+\t/**\n+\t * Provide a context for all visible {@link IContainer containers}.\n+\t */\n+\t@Singleton\n+\tpublic static class VisibleContainers extends BaseGlobalContextProvider {\n+\n+\t\tpublic static class Selectable extends AbstractCompoundSelectable {\n+\n+\t\t\tprivate final List<IContainer> containers;\n+\n+\t\t\tpublic Selectable(List<IContainer> containers) {\n+\t\t\t\tthis.containers = containers;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tprotected Iterable<? extends ISelectable> getSelectables() {\n+\t\t\t\treturn containers;\n+\t\t\t}\n+\t\t\t\n+\t\t}\n+\t\t\n+\t\t@Inject\n+\t\tprivate IContainer.Manager containerManager;\n+\t\t\n+\t\t@Override\n+\t\tpublic Context tryGetContext(Resource resource, CancelIndicator cancelIndicator) {\n+\t\t\tIResourceDescriptions index = getIndex(resource);\n+\t\t\tif (index == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tIResourceDescription description = getResourceDescription(resource);\n+\t\t\tif (description == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tList<IContainer> containers = containerManager.getVisibleContainers(description, index);\n+\t\t\treturn new DefaultUniqueNameContext(description, new Selectable(containers), getCaseInsensitivityHelper(), cancelIndicator);\n+\t\t}\n+\t\t\n+\t\t\n+\t\t\n+\t\t@Override\n+\t\tpublic boolean isAffected(Collection<IResourceDescription.Delta> deltas, IResourceDescription candidate,\n+\t\t\t\tIResourceDescriptions context) {\n+\t\t\tList<IContainer> containers = containerManager.getVisibleContainers(candidate, context);\n+\t\t\tfor(IResourceDescription.Delta delta: deltas) {\n+\t\t\t\tif (delta.getNew() == null) {\n+\t\t\t\t\tif (intersects(delta.getOld(), candidate, true)) {\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tfor(IContainer container: containers) {\n+\t\t\t\t\t\tif (container.getResourceDescription(delta.getUri())!=null) {\n+\t\t\t\t\t\t\tif (isAffected(delta, candidate, true)) {", "originalCommit": "47084d000c209365279e692a52f7ee5ebedd6ad1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2MDg1MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r422860851", "bodyText": "You mean file renames? Those should provide two deltas.", "author": "szarnekow", "createdAt": "2020-05-11T08:11:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg1MTA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2MTUzNQ==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r422861535", "bodyText": "hmmm", "author": "cdietrich", "createdAt": "2020-05-11T08:12:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg1MTA0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTEyNTU4NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r425125585", "bodyText": "Marking as resolved.", "author": "szarnekow", "createdAt": "2020-05-14T13:13:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg1MTA0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg1OTk2Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r422859962", "bodyText": "any reason why we use String and not QualifiedName?", "author": "cdietrich", "createdAt": "2020-05-11T08:09:57Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/LocalUniqueNameContext.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.validation;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.EObjectDescription;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.INamesAreUniqueValidationHelper.Context;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+\n+/**\n+ * <p>A case-sensitive, local validation context to check unique names in in the contents of \n+ * a container {@link EObject} or within a list.\n+ * </p>\n+ * Sample usage in a validation:\n+ * \n+ * <pre>\n+ * class MyDslValidator extends AbstractDeclarativeValidator {\n+ * \t&#64;Inject\n+ * \tINamesAreUniqueValidationHelper helper;\n+ * \n+ * \t&#64;Check\n+ * \tpublic void checkUniqueNames(Model model) {\n+ * \t\thelper.checkUniqueNames(new LocalUniqueNameContext(model), this);\n+ * \t}\n+ * }\n+ * </pre>\n+ * \n+ * @see INamesAreUniqueValidationHelper#checkUniqueNames(Context, ValidationMessageAcceptor)\n+ * \n+ * @since 2.22\n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class LocalUniqueNameContext implements INamesAreUniqueValidationHelper.Context, ISelectable {\n+\n+\tprivate final List<IEObjectDescription> objectsToValidate;\n+\tprivate final Map<String, Object> index;\n+\tprivate final CancelIndicator ci;\n+\n+\tpublic LocalUniqueNameContext(EObject container, Function<EObject, String> nameFunction, CancelIndicator ci) {", "originalCommit": "ca2a949a535d305f3d315115b2d919130c7a61c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2MTIzMw==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r422861233", "bodyText": "Locally its likely more convenient to work with the name directly. Do you think it would be added value to work with QN here?", "author": "szarnekow", "createdAt": "2020-05-11T08:12:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg1OTk2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2MzUwMA==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r422863500", "bodyText": "no. i just stumbled over it", "author": "cdietrich", "createdAt": "2020-05-11T08:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg1OTk2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2NDE2Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r422864167", "bodyText": "null check?", "author": "cdietrich", "createdAt": "2020-05-11T08:17:21Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/NamesAreUniqueValidator.java", "diffHunk": "@@ -62,18 +69,18 @@ public void checkUniqueNamesInResourceOf(EObject eObject) {\n \t}\n \n \tpublic void doCheckUniqueNames(Resource resource, CancelIndicator cancelIndicator) {\n-\t\tfinal IResourceServiceProvider resourceServiceProvider = resourceServiceProviderRegistry.getResourceServiceProvider(resource.getURI());\n-\t\tif (resourceServiceProvider==null)\n-\t\t\treturn;\n-\t\tIResourceDescription.Manager manager = resourceServiceProvider.getResourceDescriptionManager();\n-\t\tif (manager != null) {\n-\t\t\tIResourceDescription description = manager.getResourceDescription(resource);\n-\t\t\tif (description != null) {\n-\t\t\t\tIterable<IEObjectDescription> descriptions = description.getExportedObjects();\n-\t\t\t\thelper.checkUniqueNames(descriptions, cancelIndicator, this);\n-\t\t\t}\n+\t\tContext validationContext = getValidationContext(resource, cancelIndicator);\n+\t\tif (validationContext != null) {\n+\t\t\thelper.checkUniqueNames(validationContext, this);\n \t\t}\n \t}\n+\t\n+\t/**\n+\t * @since 2.22\n+\t */\n+\tprotected INamesAreUniqueValidationHelper.Context getValidationContext(Resource resource, CancelIndicator cancelIndicator) {\n+\t\treturn contextProvider.tryGetContext(resource, cancelIndicator);", "originalCommit": "ca2a949a535d305f3d315115b2d919130c7a61c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjkxMDE3OA==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r422910178", "bodyText": "Made it more resilient against old configurations", "author": "szarnekow", "createdAt": "2020-05-11T09:32:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2NDE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2NDI2OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r422864269", "bodyText": "or here?", "author": "cdietrich", "createdAt": "2020-05-11T08:17:31Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/NamesAreUniqueValidator.java", "diffHunk": "@@ -90,5 +97,19 @@ public void setResourceServiceProviderRegistry(IResourceServiceProvider.Registry\n \tpublic IResourceServiceProvider.Registry getResourceServiceProviderRegistry() {\n \t\treturn resourceServiceProviderRegistry;\n \t}\n+\t\n+\t/**\n+\t * @since 2.22\n+\t */\n+\tpublic INamesAreUniqueValidationHelper.ContextProvider getContextProvider() {\n+\t\treturn contextProvider;\n+\t}\n+\t\n+\t/**\n+\t * @since 2.22\n+\t */\n+\tpublic void setContextProvider(INamesAreUniqueValidationHelper.ContextProvider contextProvider) {\n+\t\tthis.contextProvider = contextProvider;", "originalCommit": "ca2a949a535d305f3d315115b2d919130c7a61c5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjkxMDMyMg==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r422910322", "bodyText": "Added an NPE guard here.", "author": "szarnekow", "createdAt": "2020-05-11T09:32:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjg2NDI2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzODYxMQ==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r423038611", "bodyText": "Are you using here indexed based for-loop for performance reason? Wouldn't enhanced-for perform the same?\nMaybe using return isAffectedExtensions.stream().anyMatch(ext -> ext.isAffected(deltas, candidate, context)); ? (May perform worse?)\nThe added lines have mixed space/tab indentation. Could you fix that, please?\nWe usually have a space before the parentheses after for. Please format.", "author": "kthoms", "createdAt": "2020-05-11T13:28:19Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/impl/DefaultResourceDescriptionManager.java", "diffHunk": "@@ -141,15 +145,30 @@ public boolean isAffected(Collection<Delta> deltas, IResourceDescription candida\n \t\t\t\t\tfor(int i = 0; i < containers.size() && !descriptionIsContained; i++) {\n \t\t\t\t\t\tdescriptionIsContained = containers.get(i).hasResourceDescription(uri);\n \t\t\t\t\t}\n-\t\t\t\t\tif (!descriptionIsContained)\n-\t\t\t\t\t\treturn false;\n+\t\t\t\t\tif (!descriptionIsContained) {\n+\t\t\t\t\t\treturn isAffectedDueToExtension(deltas, candidate, context);\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tif (isAffected(importedNames, delta.getNew()) || isAffected(importedNames, delta.getOld())) {\n \t\t\t\t\treturn true;\n \t\t\t\t}\n \t\t\t}\n         }\n-        return false;\n+        return isAffectedDueToExtension(deltas, candidate, context);\n+    }\n+    \n+    /**\n+     * Query all registered extensions.\n+     * \n+     * @since 2.22\n+     */\n+    protected boolean isAffectedDueToExtension(Collection<Delta> deltas, IResourceDescription candidate, IResourceDescriptions context) {\n+    \tfor(int i = 0; i < isAffectedExtensions.size(); i++) {", "originalCommit": "27aed667b641dccbcc1038739c2e510282b0610d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUwOTYzNQ==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r423509635", "bodyText": "It's called from a tight loop from the builder. I'll suffer a few more chars here to make the JIT's life easier.", "author": "szarnekow", "createdAt": "2020-05-12T07:10:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzODYxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzAzOTk0OA==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r423039948", "bodyText": "Answers true the\n=> Answers true when the", "author": "kthoms", "createdAt": "2020-05-11T13:30:17Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/impl/IsAffectedExtension.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.resource.impl;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.IResourceDescription.Delta;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.inject.Binding;\n+import com.google.inject.Inject;\n+import com.google.inject.Injector;\n+import com.google.inject.Provider;\n+import com.google.inject.TypeLiteral;\n+\n+/**\n+ * An extension that can be bound to compute resources as being affected\n+ * by a change beyond the default linking semantics, e.g. some validations\n+ * may be necessary to be retriggered after changes to other resources. \n+ * \n+ * @since 2.22\n+ */\n+public interface IsAffectedExtension {\n+\t\n+\tstatic class AllIsAffectedExtensions implements Provider<ImmutableList<IsAffectedExtension>> {\n+\n+\t\t@Inject\tInjector injector;\n+\t\t\n+\t\t@Override\n+\t\tpublic ImmutableList<IsAffectedExtension> get() {\n+\t\t\tImmutableList.Builder<IsAffectedExtension> result = ImmutableList.builder();\n+\t\t\tList<Binding<IsAffectedExtension>> bindings = injector.findBindingsByType(TypeLiteral.get(IsAffectedExtension.class));\n+\t\t\tfor(Binding<IsAffectedExtension> binding: bindings) {\n+\t\t\t\tIsAffectedExtension extension = binding.getProvider().get();\n+\t\t\t\tif (extension != null) {\n+\t\t\t\t\tresult.add(extension);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn result.build();\n+\t\t}\n+\t\t\n+\t}\n+\t\n+\t/**\n+\t * Answers true the given candidate is impacted by the given delta beyond the default", "originalCommit": "27aed667b641dccbcc1038739c2e510282b0610d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA0MTM3MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r423041371", "bodyText": "for(\n=> for (", "author": "kthoms", "createdAt": "2020-05-11T13:32:28Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/impl/IsAffectedExtension.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.resource.impl;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.IResourceDescription.Delta;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.inject.Binding;\n+import com.google.inject.Inject;\n+import com.google.inject.Injector;\n+import com.google.inject.Provider;\n+import com.google.inject.TypeLiteral;\n+\n+/**\n+ * An extension that can be bound to compute resources as being affected\n+ * by a change beyond the default linking semantics, e.g. some validations\n+ * may be necessary to be retriggered after changes to other resources. \n+ * \n+ * @since 2.22\n+ */\n+public interface IsAffectedExtension {\n+\t\n+\tstatic class AllIsAffectedExtensions implements Provider<ImmutableList<IsAffectedExtension>> {\n+\n+\t\t@Inject\tInjector injector;\n+\t\t\n+\t\t@Override\n+\t\tpublic ImmutableList<IsAffectedExtension> get() {\n+\t\t\tImmutableList.Builder<IsAffectedExtension> result = ImmutableList.builder();\n+\t\t\tList<Binding<IsAffectedExtension>> bindings = injector.findBindingsByType(TypeLiteral.get(IsAffectedExtension.class));\n+\t\t\tfor(Binding<IsAffectedExtension> binding: bindings) {", "originalCommit": "27aed667b641dccbcc1038739c2e510282b0610d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA0MTc4MA==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r423041780", "bodyText": "Typo in method name", "author": "kthoms", "createdAt": "2020-05-11T13:32:59Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/service/DefaultRuntimeModule.java", "diffHunk": "@@ -241,4 +247,12 @@ public void configureGenericSemanticSequencer(com.google.inject.Binder binder) {\n \tpublic void configureUseIndexFragmentsForLazyLinking(com.google.inject.Binder binder) {\n \t\tbinder.bind(Boolean.TYPE).annotatedWith(Names.named(LazyURIEncoder.USE_INDEXED_FRAGMENTS_BINDING)).toInstance(Boolean.TRUE);\n \t}\n+\t\n+\t/**\n+\t * @since 2.22\n+\t */\n+\tpublic void configureIsAffectdExtensions(Binder binder) {", "originalCommit": "27aed667b641dccbcc1038739c2e510282b0610d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA0Mzg5Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r423043893", "bodyText": "Is the assignment necessary here? The interface uses @ImplementedBy(CaseInsensitivityHelper.class)", "author": "kthoms", "createdAt": "2020-05-11T13:36:08Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/DefaultUniqueNameContext.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.validation;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtext.resource.IContainer;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.IResourceDescriptionsProvider;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.resource.impl.AbstractCompoundSelectable;\n+import org.eclipse.xtext.scoping.ICaseInsensitivityHelper;\n+import org.eclipse.xtext.scoping.impl.CaseInsensitivityHelper;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.INamesAreUniqueValidationHelper.Context;\n+\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * Standard implementation of a {@link INamesAreUniqueValidationHelper.Context}.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @since 2.22\n+ */\n+public class DefaultUniqueNameContext implements INamesAreUniqueValidationHelper.Context {\n+\n+\t/**\n+\t * Base class for {@link INamesAreUniqueValidationHelper.ContextProvider}.\n+\t */\n+\tpublic static abstract class BaseContextProvider implements INamesAreUniqueValidationHelper.ContextProvider {\n+\t\t@Inject\n+\t\tprivate IResourceServiceProvider.Registry resourceServiceProviderRegistry = IResourceServiceProvider.Registry.INSTANCE;\n+\t\t@Inject\n+\t\tprivate ICaseInsensitivityHelper caseInsensitivityHelper = new CaseInsensitivityHelper();", "originalCommit": "27aed667b641dccbcc1038739c2e510282b0610d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzUxNjQwMg==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r423516402", "bodyText": "I tried to make this as failsafe as I could think of. The org.eclipse.xtext.validation.NamesAreUniqueValidator has setters for its injected fields. That means, it was possible to use it without an injector - so did our tests. Now it has an additional field of type INamesAreUniqueValidationHelper.ContextProvider which may not be null by default to not break things. If this was on a green field, I'd probably used constructor injection.", "author": "szarnekow", "createdAt": "2020-05-12T07:23:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA0Mzg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA0NTE3MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r423045171", "bodyText": "encapsulate paragraph with <p>...</p>", "author": "kthoms", "createdAt": "2020-05-11T13:37:59Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/DefaultUniqueNameContext.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.validation;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtext.resource.IContainer;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.IResourceDescriptionsProvider;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.resource.impl.AbstractCompoundSelectable;\n+import org.eclipse.xtext.scoping.ICaseInsensitivityHelper;\n+import org.eclipse.xtext.scoping.impl.CaseInsensitivityHelper;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.INamesAreUniqueValidationHelper.Context;\n+\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * Standard implementation of a {@link INamesAreUniqueValidationHelper.Context}.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @since 2.22\n+ */\n+public class DefaultUniqueNameContext implements INamesAreUniqueValidationHelper.Context {\n+\n+\t/**\n+\t * Base class for {@link INamesAreUniqueValidationHelper.ContextProvider}.\n+\t */\n+\tpublic static abstract class BaseContextProvider implements INamesAreUniqueValidationHelper.ContextProvider {\n+\t\t@Inject\n+\t\tprivate IResourceServiceProvider.Registry resourceServiceProviderRegistry = IResourceServiceProvider.Registry.INSTANCE;\n+\t\t@Inject\n+\t\tprivate ICaseInsensitivityHelper caseInsensitivityHelper = new CaseInsensitivityHelper();\n+\n+\t\tprotected IResourceServiceProvider getResourceServiceProvider(Resource r) {\n+\t\t\treturn resourceServiceProviderRegistry.getResourceServiceProvider(r.getURI());\n+\t\t}\n+\n+\t\tprotected IResourceDescription getResourceDescription(Resource resource) {\n+\t\t\tIResourceDescription.Manager manager = getResourceDescriptionManager(resource);\n+\t\t\tif (manager != null) {\n+\t\t\t\treturn manager.getResourceDescription(resource);\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tprotected IResourceDescription.Manager getResourceDescriptionManager(Resource resource) {\n+\t\t\tIResourceServiceProvider resourceServiceProvider = getResourceServiceProvider(resource);\n+\t\t\tif (resourceServiceProvider == null)\n+\t\t\t\treturn null;\n+\t\t\treturn resourceServiceProvider.getResourceDescriptionManager();\n+\t\t}\n+\n+\t\tprotected ICaseInsensitivityHelper getCaseInsensitivityHelper() {\n+\t\t\treturn caseInsensitivityHelper;\n+\t\t}\n+\n+\t\tprotected void setResourceServiceProviderRegistry(\n+\t\t\t\tIResourceServiceProvider.Registry resourceServiceProviderRegistry) {\n+\t\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Base class for non-local unique name validation context providers.\n+\t */\n+\tpublic static abstract class BaseGlobalContextProvider extends BaseContextProvider {\n+\t\t@Inject\n+\t\tprivate IResourceDescriptionsProvider indexAccess;\n+\n+\t\tprotected IResourceDescriptions getIndex(Resource resource) {\n+\t\t\tResourceSet resourceSet = resource.getResourceSet();\n+\t\t\tif (resourceSet == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn indexAccess.getResourceDescriptions(resourceSet);\n+\t\t}\n+\n+\t\tprotected boolean intersects(IResourceDescription left, IResourceDescription right, boolean caseSensitive) {\n+\t\t\tfor (IEObjectDescription description : left.getExportedObjects()) {\n+\t\t\t\tIterable<IEObjectDescription> exportedObjects = right.getExportedObjects(EcorePackage.Literals.EOBJECT,\n+\t\t\t\t\t\tdescription.getName(), !caseSensitive);\n+\t\t\t\tif (!Iterables.isEmpty(exportedObjects)) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tprotected boolean isAffected(IResourceDescription.Delta delta, IResourceDescription candidate,\n+\t\t\t\tboolean caseSensitive) {\n+\t\t\tif (candidate.getURI().equals(delta.getUri())) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (delta.getNew() != null && intersects(delta.getNew(), candidate, caseSensitive)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tif (delta.getOld() != null && intersects(delta.getOld(), candidate, caseSensitive)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Provide a context for the entire index.\n+\t * ", "originalCommit": "27aed667b641dccbcc1038739c2e510282b0610d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA0NjM4Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r423046386", "bodyText": "you could combine both if's here", "author": "kthoms", "createdAt": "2020-05-11T13:39:43Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/DefaultUniqueNameContext.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.validation;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtext.resource.IContainer;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.IResourceDescriptionsProvider;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.resource.impl.AbstractCompoundSelectable;\n+import org.eclipse.xtext.scoping.ICaseInsensitivityHelper;\n+import org.eclipse.xtext.scoping.impl.CaseInsensitivityHelper;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.INamesAreUniqueValidationHelper.Context;\n+\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * Standard implementation of a {@link INamesAreUniqueValidationHelper.Context}.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @since 2.22\n+ */\n+public class DefaultUniqueNameContext implements INamesAreUniqueValidationHelper.Context {\n+\n+\t/**\n+\t * Base class for {@link INamesAreUniqueValidationHelper.ContextProvider}.\n+\t */\n+\tpublic static abstract class BaseContextProvider implements INamesAreUniqueValidationHelper.ContextProvider {\n+\t\t@Inject\n+\t\tprivate IResourceServiceProvider.Registry resourceServiceProviderRegistry = IResourceServiceProvider.Registry.INSTANCE;\n+\t\t@Inject\n+\t\tprivate ICaseInsensitivityHelper caseInsensitivityHelper = new CaseInsensitivityHelper();\n+\n+\t\tprotected IResourceServiceProvider getResourceServiceProvider(Resource r) {\n+\t\t\treturn resourceServiceProviderRegistry.getResourceServiceProvider(r.getURI());\n+\t\t}\n+\n+\t\tprotected IResourceDescription getResourceDescription(Resource resource) {\n+\t\t\tIResourceDescription.Manager manager = getResourceDescriptionManager(resource);\n+\t\t\tif (manager != null) {\n+\t\t\t\treturn manager.getResourceDescription(resource);\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tprotected IResourceDescription.Manager getResourceDescriptionManager(Resource resource) {\n+\t\t\tIResourceServiceProvider resourceServiceProvider = getResourceServiceProvider(resource);\n+\t\t\tif (resourceServiceProvider == null)\n+\t\t\t\treturn null;\n+\t\t\treturn resourceServiceProvider.getResourceDescriptionManager();\n+\t\t}\n+\n+\t\tprotected ICaseInsensitivityHelper getCaseInsensitivityHelper() {\n+\t\t\treturn caseInsensitivityHelper;\n+\t\t}\n+\n+\t\tprotected void setResourceServiceProviderRegistry(\n+\t\t\t\tIResourceServiceProvider.Registry resourceServiceProviderRegistry) {\n+\t\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Base class for non-local unique name validation context providers.\n+\t */\n+\tpublic static abstract class BaseGlobalContextProvider extends BaseContextProvider {\n+\t\t@Inject\n+\t\tprivate IResourceDescriptionsProvider indexAccess;\n+\n+\t\tprotected IResourceDescriptions getIndex(Resource resource) {\n+\t\t\tResourceSet resourceSet = resource.getResourceSet();\n+\t\t\tif (resourceSet == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn indexAccess.getResourceDescriptions(resourceSet);\n+\t\t}\n+\n+\t\tprotected boolean intersects(IResourceDescription left, IResourceDescription right, boolean caseSensitive) {\n+\t\t\tfor (IEObjectDescription description : left.getExportedObjects()) {\n+\t\t\t\tIterable<IEObjectDescription> exportedObjects = right.getExportedObjects(EcorePackage.Literals.EOBJECT,\n+\t\t\t\t\t\tdescription.getName(), !caseSensitive);\n+\t\t\t\tif (!Iterables.isEmpty(exportedObjects)) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tprotected boolean isAffected(IResourceDescription.Delta delta, IResourceDescription candidate,\n+\t\t\t\tboolean caseSensitive) {\n+\t\t\tif (candidate.getURI().equals(delta.getUri())) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (delta.getNew() != null && intersects(delta.getNew(), candidate, caseSensitive)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tif (delta.getOld() != null && intersects(delta.getOld(), candidate, caseSensitive)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Provide a context for the entire index.\n+\t * \n+\t * Drawback: If a resoure in a project A introduces a duplication with a resource in project B, an incremental build\n+\t * of A may fail to notify B, if B is a dependency of A. Triggering a clean build in B will subsequently create the\n+\t * validation problem / fix the validation problem there, too but in Eclipse, the incremental build will not provide\n+\t * the same level of consistency.\n+\t */\n+\t@Singleton\n+\tpublic static class Global extends BaseGlobalContextProvider {\n+\n+\t\t@Override\n+\t\tpublic Context tryGetContext(Resource resource, CancelIndicator cancelIndicator) {\n+\t\t\tIResourceDescriptions index = getIndex(resource);\n+\t\t\tif (index == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tIResourceDescription description = getResourceDescription(resource);\n+\t\t\tif (description != null) {\n+\t\t\t\treturn new DefaultUniqueNameContext(description, index, getCaseInsensitivityHelper(), cancelIndicator);\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isAffected(Collection<IResourceDescription.Delta> deltas, IResourceDescription candidate,\n+\t\t\t\tIResourceDescriptions context) {\n+\t\t\tfor (IResourceDescription.Delta delta : deltas) {\n+\t\t\t\tif (isAffected(delta, candidate, true)) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t}\n+\n+\t/**\n+\t * Provide a context for current {@link IContainer}.\n+\t */\n+\t@Singleton\n+\tpublic static class Container extends BaseGlobalContextProvider {\n+\n+\t\t@Inject\n+\t\tprivate IContainer.Manager containerManager;\n+\n+\t\t@Override\n+\t\tpublic Context tryGetContext(Resource resource, CancelIndicator cancelIndicator) {\n+\t\t\tIResourceDescriptions index = getIndex(resource);\n+\t\t\tif (index == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tIResourceDescription description = getResourceDescription(resource);\n+\t\t\tif (description == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tIContainer container = containerManager.getContainer(description, index);\n+\t\t\treturn new DefaultUniqueNameContext(description, container, getCaseInsensitivityHelper(), cancelIndicator);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isAffected(Collection<IResourceDescription.Delta> deltas, IResourceDescription candidate,\n+\t\t\t\tIResourceDescriptions context) {\n+\t\t\tIContainer container = containerManager.getContainer(candidate, context);\n+\t\t\tfor (IResourceDescription.Delta delta : deltas) {\n+\t\t\t\tif (delta.getNew() == null) {\n+\t\t\t\t\tif (intersects(delta.getOld(), candidate, true)) {\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tif (container.getResourceDescription(delta.getUri()) != null) {", "originalCommit": "27aed667b641dccbcc1038739c2e510282b0610d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA0NzE2MQ==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r423047161", "bodyText": "combine 2 if's, one indent level less?", "author": "kthoms", "createdAt": "2020-05-11T13:40:50Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/DefaultUniqueNameContext.java", "diffHunk": "@@ -0,0 +1,319 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.validation;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtext.resource.IContainer;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.IResourceDescriptionsProvider;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.resource.impl.AbstractCompoundSelectable;\n+import org.eclipse.xtext.scoping.ICaseInsensitivityHelper;\n+import org.eclipse.xtext.scoping.impl.CaseInsensitivityHelper;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.INamesAreUniqueValidationHelper.Context;\n+\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * Standard implementation of a {@link INamesAreUniqueValidationHelper.Context}.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @since 2.22\n+ */\n+public class DefaultUniqueNameContext implements INamesAreUniqueValidationHelper.Context {\n+\n+\t/**\n+\t * Base class for {@link INamesAreUniqueValidationHelper.ContextProvider}.\n+\t */\n+\tpublic static abstract class BaseContextProvider implements INamesAreUniqueValidationHelper.ContextProvider {\n+\t\t@Inject\n+\t\tprivate IResourceServiceProvider.Registry resourceServiceProviderRegistry = IResourceServiceProvider.Registry.INSTANCE;\n+\t\t@Inject\n+\t\tprivate ICaseInsensitivityHelper caseInsensitivityHelper = new CaseInsensitivityHelper();\n+\n+\t\tprotected IResourceServiceProvider getResourceServiceProvider(Resource r) {\n+\t\t\treturn resourceServiceProviderRegistry.getResourceServiceProvider(r.getURI());\n+\t\t}\n+\n+\t\tprotected IResourceDescription getResourceDescription(Resource resource) {\n+\t\t\tIResourceDescription.Manager manager = getResourceDescriptionManager(resource);\n+\t\t\tif (manager != null) {\n+\t\t\t\treturn manager.getResourceDescription(resource);\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tprotected IResourceDescription.Manager getResourceDescriptionManager(Resource resource) {\n+\t\t\tIResourceServiceProvider resourceServiceProvider = getResourceServiceProvider(resource);\n+\t\t\tif (resourceServiceProvider == null)\n+\t\t\t\treturn null;\n+\t\t\treturn resourceServiceProvider.getResourceDescriptionManager();\n+\t\t}\n+\n+\t\tprotected ICaseInsensitivityHelper getCaseInsensitivityHelper() {\n+\t\t\treturn caseInsensitivityHelper;\n+\t\t}\n+\n+\t\tprotected void setResourceServiceProviderRegistry(\n+\t\t\t\tIResourceServiceProvider.Registry resourceServiceProviderRegistry) {\n+\t\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Base class for non-local unique name validation context providers.\n+\t */\n+\tpublic static abstract class BaseGlobalContextProvider extends BaseContextProvider {\n+\t\t@Inject\n+\t\tprivate IResourceDescriptionsProvider indexAccess;\n+\n+\t\tprotected IResourceDescriptions getIndex(Resource resource) {\n+\t\t\tResourceSet resourceSet = resource.getResourceSet();\n+\t\t\tif (resourceSet == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn indexAccess.getResourceDescriptions(resourceSet);\n+\t\t}\n+\n+\t\tprotected boolean intersects(IResourceDescription left, IResourceDescription right, boolean caseSensitive) {\n+\t\t\tfor (IEObjectDescription description : left.getExportedObjects()) {\n+\t\t\t\tIterable<IEObjectDescription> exportedObjects = right.getExportedObjects(EcorePackage.Literals.EOBJECT,\n+\t\t\t\t\t\tdescription.getName(), !caseSensitive);\n+\t\t\t\tif (!Iterables.isEmpty(exportedObjects)) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tprotected boolean isAffected(IResourceDescription.Delta delta, IResourceDescription candidate,\n+\t\t\t\tboolean caseSensitive) {\n+\t\t\tif (candidate.getURI().equals(delta.getUri())) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (delta.getNew() != null && intersects(delta.getNew(), candidate, caseSensitive)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tif (delta.getOld() != null && intersects(delta.getOld(), candidate, caseSensitive)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Provide a context for the entire index.\n+\t * \n+\t * Drawback: If a resoure in a project A introduces a duplication with a resource in project B, an incremental build\n+\t * of A may fail to notify B, if B is a dependency of A. Triggering a clean build in B will subsequently create the\n+\t * validation problem / fix the validation problem there, too but in Eclipse, the incremental build will not provide\n+\t * the same level of consistency.\n+\t */\n+\t@Singleton\n+\tpublic static class Global extends BaseGlobalContextProvider {\n+\n+\t\t@Override\n+\t\tpublic Context tryGetContext(Resource resource, CancelIndicator cancelIndicator) {\n+\t\t\tIResourceDescriptions index = getIndex(resource);\n+\t\t\tif (index == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tIResourceDescription description = getResourceDescription(resource);\n+\t\t\tif (description != null) {\n+\t\t\t\treturn new DefaultUniqueNameContext(description, index, getCaseInsensitivityHelper(), cancelIndicator);\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isAffected(Collection<IResourceDescription.Delta> deltas, IResourceDescription candidate,\n+\t\t\t\tIResourceDescriptions context) {\n+\t\t\tfor (IResourceDescription.Delta delta : deltas) {\n+\t\t\t\tif (isAffected(delta, candidate, true)) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t}\n+\n+\t/**\n+\t * Provide a context for current {@link IContainer}.\n+\t */\n+\t@Singleton\n+\tpublic static class Container extends BaseGlobalContextProvider {\n+\n+\t\t@Inject\n+\t\tprivate IContainer.Manager containerManager;\n+\n+\t\t@Override\n+\t\tpublic Context tryGetContext(Resource resource, CancelIndicator cancelIndicator) {\n+\t\t\tIResourceDescriptions index = getIndex(resource);\n+\t\t\tif (index == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tIResourceDescription description = getResourceDescription(resource);\n+\t\t\tif (description == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tIContainer container = containerManager.getContainer(description, index);\n+\t\t\treturn new DefaultUniqueNameContext(description, container, getCaseInsensitivityHelper(), cancelIndicator);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isAffected(Collection<IResourceDescription.Delta> deltas, IResourceDescription candidate,\n+\t\t\t\tIResourceDescriptions context) {\n+\t\t\tIContainer container = containerManager.getContainer(candidate, context);\n+\t\t\tfor (IResourceDescription.Delta delta : deltas) {\n+\t\t\t\tif (delta.getNew() == null) {\n+\t\t\t\t\tif (intersects(delta.getOld(), candidate, true)) {\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tif (container.getResourceDescription(delta.getUri()) != null) {\n+\t\t\t\t\t\tif (isAffected(delta, candidate, true)) {\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t}\n+\n+\t/**\n+\t * Provide a context for all visible {@link IContainer containers}.\n+\t */\n+\t@Singleton\n+\tpublic static class VisibleContainers extends BaseGlobalContextProvider {\n+\n+\t\tpublic static class Selectable extends AbstractCompoundSelectable {\n+\n+\t\t\tprivate final List<IContainer> containers;\n+\n+\t\t\tpublic Selectable(List<IContainer> containers) {\n+\t\t\t\tthis.containers = containers;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tprotected Iterable<? extends ISelectable> getSelectables() {\n+\t\t\t\treturn containers;\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\t@Inject\n+\t\tprivate IContainer.Manager containerManager;\n+\n+\t\t@Override\n+\t\tpublic Context tryGetContext(Resource resource, CancelIndicator cancelIndicator) {\n+\t\t\tIResourceDescriptions index = getIndex(resource);\n+\t\t\tif (index == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tIResourceDescription description = getResourceDescription(resource);\n+\t\t\tif (description == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tList<IContainer> containers = containerManager.getVisibleContainers(description, index);\n+\t\t\treturn new DefaultUniqueNameContext(description, new Selectable(containers), getCaseInsensitivityHelper(),\n+\t\t\t\t\tcancelIndicator);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isAffected(Collection<IResourceDescription.Delta> deltas, IResourceDescription candidate,\n+\t\t\t\tIResourceDescriptions context) {\n+\t\t\tList<IContainer> containers = containerManager.getVisibleContainers(candidate, context);\n+\t\t\tfor (IResourceDescription.Delta delta : deltas) {\n+\t\t\t\tif (delta.getNew() == null) {\n+\t\t\t\t\tif (intersects(delta.getOld(), candidate, true)) {\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tfor (IContainer container : containers) {\n+\t\t\t\t\t\tif (container.getResourceDescription(delta.getUri()) != null) {\n+\t\t\t\t\t\t\tif (isAffected(delta, candidate, true)) {", "originalCommit": "27aed667b641dccbcc1038739c2e510282b0610d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA0Nzc1OA==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r423047758", "bodyText": "remove either be or return", "author": "kthoms", "createdAt": "2020-05-11T13:41:41Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/INamesAreUniqueValidationHelper.java", "diffHunk": "@@ -8,29 +8,142 @@\n  *******************************************************************************/\n package org.eclipse.xtext.validation;\n \n+import java.util.Collection;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.resource.Resource;\n import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.resource.IResourceDescription.Delta;\n+import org.eclipse.xtext.resource.impl.IsAffectedExtension;\n+import org.eclipse.xtext.scoping.ICaseInsensitivityHelper;\n import org.eclipse.xtext.util.CancelIndicator;\n \n import com.google.inject.ImplementedBy;\n \n /**\n+ * The helper can be used to validate unique names locally or across resource boundaries.\n+ * \n+ * @see LocalUniqueNameContext\n  * @author Sebastian Zarnekow - Initial contribution and API\n  */\n @ImplementedBy(NamesAreUniqueValidationHelper.class)\n public interface INamesAreUniqueValidationHelper {\n \n+\t/**\n+\t * Provide the context information for the unique name validation.\n+\t * \n+\t * @since 2.22\n+\t */\n+\t@ImplementedBy(DefaultUniqueNameContext.ExportedFromResource.class)\n+\tinterface ContextProvider extends IsAffectedExtension {\n+\t\t\n+\t\t/**\n+\t\t * Obtain the context of the unique name validation for the given resource.\n+\t\t * \n+\t\t * May be return null.", "originalCommit": "27aed667b641dccbcc1038739c2e510282b0610d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA0ODM0OA==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r423048348", "bodyText": "encapsulate paragraph <p>", "author": "kthoms", "createdAt": "2020-05-11T13:42:31Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/INamesAreUniqueValidationHelper.java", "diffHunk": "@@ -8,29 +8,142 @@\n  *******************************************************************************/\n package org.eclipse.xtext.validation;\n \n+import java.util.Collection;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.resource.Resource;\n import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.resource.IResourceDescription.Delta;\n+import org.eclipse.xtext.resource.impl.IsAffectedExtension;\n+import org.eclipse.xtext.scoping.ICaseInsensitivityHelper;\n import org.eclipse.xtext.util.CancelIndicator;\n \n import com.google.inject.ImplementedBy;\n \n /**\n+ * The helper can be used to validate unique names locally or across resource boundaries.\n+ * \n+ * @see LocalUniqueNameContext\n  * @author Sebastian Zarnekow - Initial contribution and API\n  */\n @ImplementedBy(NamesAreUniqueValidationHelper.class)\n public interface INamesAreUniqueValidationHelper {\n \n+\t/**\n+\t * Provide the context information for the unique name validation.\n+\t * \n+\t * @since 2.22\n+\t */\n+\t@ImplementedBy(DefaultUniqueNameContext.ExportedFromResource.class)\n+\tinterface ContextProvider extends IsAffectedExtension {\n+\t\t\n+\t\t/**\n+\t\t * Obtain the context of the unique name validation for the given resource.\n+\t\t * \n+\t\t * May be return null.\n+\t\t */\n+\t\tContext tryGetContext(Resource resource, CancelIndicator cancelIndicator);\n+\t\t\n+\t\t@Override\n+\t\tdefault boolean isAffected(Collection<Delta> deltas, IResourceDescription candidate,\n+\t\t\t\tIResourceDescriptions context) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Provides context information to the validation that allows to introspect the scope in which\n+\t * the validation for unique names is supposed to happen.\n+\t * \n+\t * The term <code>clusterType</code> is used to denote a EClass (super-)type of the current object", "originalCommit": "27aed667b641dccbcc1038739c2e510282b0610d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA0OTUwOA==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r423049508", "bodyText": "is it Procedures or Functions here? (there are so many and's here in the sentence anyway)", "author": "kthoms", "createdAt": "2020-05-11T13:44:17Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/INamesAreUniqueValidationHelper.java", "diffHunk": "@@ -8,29 +8,142 @@\n  *******************************************************************************/\n package org.eclipse.xtext.validation;\n \n+import java.util.Collection;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.resource.Resource;\n import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.resource.IResourceDescription.Delta;\n+import org.eclipse.xtext.resource.impl.IsAffectedExtension;\n+import org.eclipse.xtext.scoping.ICaseInsensitivityHelper;\n import org.eclipse.xtext.util.CancelIndicator;\n \n import com.google.inject.ImplementedBy;\n \n /**\n+ * The helper can be used to validate unique names locally or across resource boundaries.\n+ * \n+ * @see LocalUniqueNameContext\n  * @author Sebastian Zarnekow - Initial contribution and API\n  */\n @ImplementedBy(NamesAreUniqueValidationHelper.class)\n public interface INamesAreUniqueValidationHelper {\n \n+\t/**\n+\t * Provide the context information for the unique name validation.\n+\t * \n+\t * @since 2.22\n+\t */\n+\t@ImplementedBy(DefaultUniqueNameContext.ExportedFromResource.class)\n+\tinterface ContextProvider extends IsAffectedExtension {\n+\t\t\n+\t\t/**\n+\t\t * Obtain the context of the unique name validation for the given resource.\n+\t\t * \n+\t\t * May be return null.\n+\t\t */\n+\t\tContext tryGetContext(Resource resource, CancelIndicator cancelIndicator);\n+\t\t\n+\t\t@Override\n+\t\tdefault boolean isAffected(Collection<Delta> deltas, IResourceDescription candidate,\n+\t\t\t\tIResourceDescriptions context) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Provides context information to the validation that allows to introspect the scope in which\n+\t * the validation for unique names is supposed to happen.\n+\t * \n+\t * The term <code>clusterType</code> is used to denote a EClass (super-)type of the current object\n+\t * under validation. When checking the name for uniqueness, the objects that fulfil the given cluster\n+\t * type are considered. This can be used to define different namespaces. For example, a language that\n+\t * has the concepts of <code>Fields</code>, <code>Procedures</code> and \n+\t * <code>Functions</code> may provide two different cluster types. All fields must have a unique name\n+\t * and the executable <code>Procedures</code> and <code>Functions</code> use the same namespace and may", "originalCommit": "27aed667b641dccbcc1038739c2e510282b0610d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA0OTg4MA==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r423049880", "bodyText": "<p>", "author": "kthoms", "createdAt": "2020-05-11T13:44:51Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/INamesAreUniqueValidationHelper.java", "diffHunk": "@@ -8,29 +8,142 @@\n  *******************************************************************************/\n package org.eclipse.xtext.validation;\n \n+import java.util.Collection;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.resource.Resource;\n import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.resource.IResourceDescription.Delta;\n+import org.eclipse.xtext.resource.impl.IsAffectedExtension;\n+import org.eclipse.xtext.scoping.ICaseInsensitivityHelper;\n import org.eclipse.xtext.util.CancelIndicator;\n \n import com.google.inject.ImplementedBy;\n \n /**\n+ * The helper can be used to validate unique names locally or across resource boundaries.\n+ * \n+ * @see LocalUniqueNameContext\n  * @author Sebastian Zarnekow - Initial contribution and API\n  */\n @ImplementedBy(NamesAreUniqueValidationHelper.class)\n public interface INamesAreUniqueValidationHelper {\n \n+\t/**\n+\t * Provide the context information for the unique name validation.\n+\t * \n+\t * @since 2.22\n+\t */\n+\t@ImplementedBy(DefaultUniqueNameContext.ExportedFromResource.class)\n+\tinterface ContextProvider extends IsAffectedExtension {\n+\t\t\n+\t\t/**\n+\t\t * Obtain the context of the unique name validation for the given resource.\n+\t\t * \n+\t\t * May be return null.\n+\t\t */\n+\t\tContext tryGetContext(Resource resource, CancelIndicator cancelIndicator);\n+\t\t\n+\t\t@Override\n+\t\tdefault boolean isAffected(Collection<Delta> deltas, IResourceDescription candidate,\n+\t\t\t\tIResourceDescriptions context) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Provides context information to the validation that allows to introspect the scope in which\n+\t * the validation for unique names is supposed to happen.\n+\t * \n+\t * The term <code>clusterType</code> is used to denote a EClass (super-)type of the current object\n+\t * under validation. When checking the name for uniqueness, the objects that fulfil the given cluster\n+\t * type are considered. This can be used to define different namespaces. For example, a language that\n+\t * has the concepts of <code>Fields</code>, <code>Procedures</code> and \n+\t * <code>Functions</code> may provide two different cluster types. All fields must have a unique name\n+\t * and the executable <code>Procedures</code> and <code>Functions</code> use the same namespace and may\n+\t * not have duplicate names. \n+\t * \n+\t * @since 2.22\n+\t */\n+\tinterface Context {\n+\t\t/**\n+\t\t * Return a {@link ISelectable} that can be queried for elements with a given name to find duplicates.\n+\t\t * Depending on the type of objects that have to have unique names, different selectables must be returned.\n+\t\t * \n+\t\t * Some objects must be unique per project, others must be globally unique or only unique per file.", "originalCommit": "27aed667b641dccbcc1038739c2e510282b0610d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA1MDc2NA==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r423050764", "bodyText": "the , is obsolete here", "author": "kthoms", "createdAt": "2020-05-11T13:46:06Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/INamesAreUniqueValidationHelper.java", "diffHunk": "@@ -8,29 +8,142 @@\n  *******************************************************************************/\n package org.eclipse.xtext.validation;\n \n+import java.util.Collection;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.resource.Resource;\n import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.resource.IResourceDescription.Delta;\n+import org.eclipse.xtext.resource.impl.IsAffectedExtension;\n+import org.eclipse.xtext.scoping.ICaseInsensitivityHelper;\n import org.eclipse.xtext.util.CancelIndicator;\n \n import com.google.inject.ImplementedBy;\n \n /**\n+ * The helper can be used to validate unique names locally or across resource boundaries.\n+ * \n+ * @see LocalUniqueNameContext\n  * @author Sebastian Zarnekow - Initial contribution and API\n  */\n @ImplementedBy(NamesAreUniqueValidationHelper.class)\n public interface INamesAreUniqueValidationHelper {\n \n+\t/**\n+\t * Provide the context information for the unique name validation.\n+\t * \n+\t * @since 2.22\n+\t */\n+\t@ImplementedBy(DefaultUniqueNameContext.ExportedFromResource.class)\n+\tinterface ContextProvider extends IsAffectedExtension {\n+\t\t\n+\t\t/**\n+\t\t * Obtain the context of the unique name validation for the given resource.\n+\t\t * \n+\t\t * May be return null.\n+\t\t */\n+\t\tContext tryGetContext(Resource resource, CancelIndicator cancelIndicator);\n+\t\t\n+\t\t@Override\n+\t\tdefault boolean isAffected(Collection<Delta> deltas, IResourceDescription candidate,\n+\t\t\t\tIResourceDescriptions context) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * Provides context information to the validation that allows to introspect the scope in which\n+\t * the validation for unique names is supposed to happen.\n+\t * \n+\t * The term <code>clusterType</code> is used to denote a EClass (super-)type of the current object\n+\t * under validation. When checking the name for uniqueness, the objects that fulfil the given cluster\n+\t * type are considered. This can be used to define different namespaces. For example, a language that\n+\t * has the concepts of <code>Fields</code>, <code>Procedures</code> and \n+\t * <code>Functions</code> may provide two different cluster types. All fields must have a unique name\n+\t * and the executable <code>Procedures</code> and <code>Functions</code> use the same namespace and may\n+\t * not have duplicate names. \n+\t * \n+\t * @since 2.22\n+\t */\n+\tinterface Context {\n+\t\t/**\n+\t\t * Return a {@link ISelectable} that can be queried for elements with a given name to find duplicates.\n+\t\t * Depending on the type of objects that have to have unique names, different selectables must be returned.\n+\t\t * \n+\t\t * Some objects must be unique per project, others must be globally unique or only unique per file.\n+\t\t * This API allows to fine tune the scope of the validation. \n+\t\t * \n+\t\t * @param description the description of the validated object.\n+\t\t * @param clusterType the root type of the validated type hierarchy.\n+\t\t * @return the validation scope. \n+\t\t */\n+\t\tISelectable getValidationScope(IEObjectDescription description, EClass clusterType);\n+\t\t\n+\t\t/**\n+\t\t * Return the objects that should be checked for uniqueness in the context of their {@link #getValidationScope(EClass)}.\n+\t\t */\n+\t\tIterable<IEObjectDescription> getObjectsToValidate();\n+\t\t\n+\t\t/**\n+\t\t * The cancel-indicator that shall be used.\n+\t\t */\n+\t\tCancelIndicator cancelIndicator();\n+\t\t\n+\t\t/**\n+\t\t * Answers whether the names in the given cluster must be treated in a case\n+\t\t * sensistive or insensitive manner. \n+\t\t * \n+\t\t * @see ICaseInsensitivityHelper\n+\t\t */\n+\t\tdefault boolean isCaseSensitive(EObject object, EClass clusterType) {\n+\t\t\treturn true;\n+\t\t}\n+\t\t\n+\t\t/**\n+\t\t * Context implementations that do know from their construction if they will or won't \n+\t\t * contain any duplicates, can override {@link #isUnique()} to provide a more efficient means\n+\t\t * to validate all {@link #getObjectsToValidate() candidates} at once.\n+\t\t */\n+\t\tdefault boolean isUnique() {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\t\n \t/**\n \t * Create errors for objects that have the same name. Objects, that do not belong to\n \t * the same cluster will not get any errors.\n \t * @see INamesAreUniqueValidationHelper#checkUniqueNames(Iterable, CancelIndicator, ValidationMessageAcceptor)\n+\t * \n+\t * @deprecated Implementations should adhere to the context provided via {@link #checkUniqueNames(Iterable, Context, ValidationMessageAcceptor)}\n \t */\n-\tvoid checkUniqueNames(Iterable<IEObjectDescription> descriptions,  ValidationMessageAcceptor acceptor);\n+\t@Deprecated\n+\tdefault void checkUniqueNames(Iterable<IEObjectDescription> descriptions, ValidationMessageAcceptor acceptor) {\n+\t\tcheckUniqueNames(descriptions, (CancelIndicator) null, acceptor);\n+\t}\n \t\n \t/**\n \t * Create errors for objects that have the same name. Objects, that do not belong to\n \t * the same cluster will not get any errors. The cancel indicator may be used to interrupt \n \t * the validation.\n+\t * \n+\t * @deprecated Implementations should adhere to the context provided via {@link #checkUniqueNames(Iterable, Context, ValidationMessageAcceptor)}\n \t */\n+\t@Deprecated\n \tvoid checkUniqueNames(Iterable<IEObjectDescription> descriptions, CancelIndicator cancelIndicator, ValidationMessageAcceptor acceptor);\n+\t\n+\t/**\n+\t * Create errors for objects that have the same name. Objects, that do not belong to", "originalCommit": "27aed667b641dccbcc1038739c2e510282b0610d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzA1MzMzNw==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r423053337", "bodyText": "<p>", "author": "kthoms", "createdAt": "2020-05-11T13:49:52Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/UniqueInResourceContext.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.validation;\n+\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.scoping.impl.CaseInsensitivityHelper;\n+import org.eclipse.xtext.util.CancelIndicator;\n+\n+/**\n+ * Legacy case-sensitive, unique name validation context that ensures the exported names to be unique per resource.\n+ * \n+ * This is used to detect specializations that require fallback to the behavior prior to Xtext 2.22.", "originalCommit": "27aed667b641dccbcc1038739c2e510282b0610d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "83382243cee6f4c312d2b6feae43a940330bb5d5", "url": "https://github.com/eclipse/xtext-core/commit/83382243cee6f4c312d2b6feae43a940330bb5d5", "message": "[#1466] Review feedback: Improved JavaDoc", "committedDate": "2020-05-12T07:41:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzU0NDAxNQ==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r423544015", "bodyText": "double closing\nBTW: I placed the <p> remarks on the second paragraphs of the javadocs. The first paragraph does not need to be encapsulated, but it does not hurt and I'm fine with that.", "author": "kthoms", "createdAt": "2020-05-12T08:11:08Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/DefaultUniqueNameContext.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.validation;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtext.resource.IContainer;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.IResourceDescriptionsProvider;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.resource.impl.AbstractCompoundSelectable;\n+import org.eclipse.xtext.scoping.ICaseInsensitivityHelper;\n+import org.eclipse.xtext.scoping.impl.CaseInsensitivityHelper;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.INamesAreUniqueValidationHelper.Context;\n+\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * Standard implementation of a {@link INamesAreUniqueValidationHelper.Context}.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @since 2.22\n+ */\n+public class DefaultUniqueNameContext implements INamesAreUniqueValidationHelper.Context {\n+\n+\t/**\n+\t * Base class for {@link INamesAreUniqueValidationHelper.ContextProvider}.\n+\t */\n+\tpublic static abstract class BaseContextProvider implements INamesAreUniqueValidationHelper.ContextProvider {\n+\t\t@Inject\n+\t\tprivate IResourceServiceProvider.Registry resourceServiceProviderRegistry = IResourceServiceProvider.Registry.INSTANCE;\n+\t\t@Inject\n+\t\tprivate ICaseInsensitivityHelper caseInsensitivityHelper = new CaseInsensitivityHelper();\n+\n+\t\tprotected IResourceServiceProvider getResourceServiceProvider(Resource r) {\n+\t\t\treturn resourceServiceProviderRegistry.getResourceServiceProvider(r.getURI());\n+\t\t}\n+\n+\t\tprotected IResourceDescription getResourceDescription(Resource resource) {\n+\t\t\tIResourceDescription.Manager manager = getResourceDescriptionManager(resource);\n+\t\t\tif (manager != null) {\n+\t\t\t\treturn manager.getResourceDescription(resource);\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tprotected IResourceDescription.Manager getResourceDescriptionManager(Resource resource) {\n+\t\t\tIResourceServiceProvider resourceServiceProvider = getResourceServiceProvider(resource);\n+\t\t\tif (resourceServiceProvider == null)\n+\t\t\t\treturn null;\n+\t\t\treturn resourceServiceProvider.getResourceDescriptionManager();\n+\t\t}\n+\n+\t\tprotected ICaseInsensitivityHelper getCaseInsensitivityHelper() {\n+\t\t\treturn caseInsensitivityHelper;\n+\t\t}\n+\n+\t\tprotected void setResourceServiceProviderRegistry(\n+\t\t\t\tIResourceServiceProvider.Registry resourceServiceProviderRegistry) {\n+\t\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Base class for non-local unique name validation context providers.\n+\t */\n+\tpublic static abstract class BaseGlobalContextProvider extends BaseContextProvider {\n+\t\t@Inject\n+\t\tprivate IResourceDescriptionsProvider indexAccess;\n+\n+\t\tprotected IResourceDescriptions getIndex(Resource resource) {\n+\t\t\tResourceSet resourceSet = resource.getResourceSet();\n+\t\t\tif (resourceSet == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn indexAccess.getResourceDescriptions(resourceSet);\n+\t\t}\n+\n+\t\tprotected boolean intersects(IResourceDescription left, IResourceDescription right, boolean caseSensitive) {\n+\t\t\tfor (IEObjectDescription description : left.getExportedObjects()) {\n+\t\t\t\tIterable<IEObjectDescription> exportedObjects = right.getExportedObjects(EcorePackage.Literals.EOBJECT,\n+\t\t\t\t\t\tdescription.getName(), !caseSensitive);\n+\t\t\t\tif (!Iterables.isEmpty(exportedObjects)) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tprotected boolean isAffected(IResourceDescription.Delta delta, IResourceDescription candidate,\n+\t\t\t\tboolean caseSensitive) {\n+\t\t\tif (candidate.getURI().equals(delta.getUri())) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (delta.getNew() != null && intersects(delta.getNew(), candidate, caseSensitive)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tif (delta.getOld() != null && intersects(delta.getOld(), candidate, caseSensitive)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * <p>\n+\t * Provide a context for the entire index.\n+\t * </p></p>", "originalCommit": "83382243cee6f4c312d2b6feae43a940330bb5d5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk5NTY1NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r424995655", "bodyText": "Typo: in in", "author": "miklossy", "createdAt": "2020-05-14T09:24:13Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/LocalUniqueNameContext.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.validation;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.EObjectDescription;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.INamesAreUniqueValidationHelper.Context;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+\n+/**\n+ * <p>A case-sensitive, local validation context to check unique names in in the contents of ", "originalCommit": "9c98740dc7f70a0686c688f60d54439a6ba3e3c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAwNDM3MA==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r425004370", "bodyText": "Done", "author": "szarnekow", "createdAt": "2020-05-14T09:38:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk5NTY1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk5NzAxNg==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r424997016", "bodyText": "Typo: of -> if", "author": "miklossy", "createdAt": "2020-05-14T09:26:22Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/LocalUniqueNameContext.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.validation;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.EObjectDescription;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.INamesAreUniqueValidationHelper.Context;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+\n+/**\n+ * <p>A case-sensitive, local validation context to check unique names in in the contents of \n+ * a container {@link EObject} or within a list.\n+ * </p>\n+ * Sample usage in a validation:\n+ * \n+ * <pre>\n+ * class MyDslValidator extends AbstractDeclarativeValidator {\n+ * \t&#64;Inject\n+ * \tINamesAreUniqueValidationHelper helper;\n+ * \n+ * \t&#64;Check\n+ * \tpublic void checkUniqueNames(Model model) {\n+ * \t\thelper.checkUniqueNames(new LocalUniqueNameContext(model), this);\n+ * \t}\n+ * }\n+ * </pre>\n+ * \n+ * @see INamesAreUniqueValidationHelper#checkUniqueNames(Context, ValidationMessageAcceptor)\n+ * \n+ * @since 2.22\n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class LocalUniqueNameContext implements INamesAreUniqueValidationHelper.Context, ISelectable {\n+\n+\tprivate final List<IEObjectDescription> objectsToValidate;\n+\tprivate final Map<String, Object> index;\n+\tprivate final CancelIndicator ci;\n+\n+\tpublic LocalUniqueNameContext(EObject container, Function<EObject, String> nameFunction, CancelIndicator ci) {\n+\t\tthis(container, false, nameFunction, ci);\n+\t}\n+\n+\tpublic LocalUniqueNameContext(EObject container, CancelIndicator ci) {\n+\t\tthis(container, LocalUniqueNameContext::tryGetName, ci);\n+\t}\n+\n+\tpublic LocalUniqueNameContext(EObject container, boolean deep, CancelIndicator ci) {\n+\t\tthis(container, deep, LocalUniqueNameContext::tryGetName, ci);\n+\t}\n+\n+\tpublic LocalUniqueNameContext(EObject container, boolean deep, Function<EObject, String> nameFunction, CancelIndicator ci) {\n+\t\tthis(deep ? () -> container.eAllContents() : container.eContents(), nameFunction, ci);\n+\t}\n+\n+\tpublic <T extends EObject> LocalUniqueNameContext(Iterable<T> objects, Function<T, String> nameFunction, CancelIndicator ci) {\n+\t\tMap<String, Object> index = new HashMap<>();\n+\t\tList<IEObjectDescription> objectsToValidate = new ArrayList<>();\n+\t\tfor (T t : objects) {\n+\t\t\tString name = nameFunction.apply(t);\n+\t\t\tif (name != null) {\n+\t\t\t\tIEObjectDescription description = EObjectDescription.create(name, t);\n+\t\t\t\tobjectsToValidate.add(description);\n+\t\t\t\tindex.merge(name, description, (p, n)->{\n+\t\t\t\t\tif (p instanceof List<?>) {\n+\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n+\t\t\t\t\t\tList<Object> list = (List<Object>) p;\n+\t\t\t\t\t\tlist.add(n);\n+\t\t\t\t\t\treturn list;\n+\t\t\t\t\t}\n+\t\t\t\t\tList<Object> list = new ArrayList<>();\n+\t\t\t\t\tlist.add(p);\n+\t\t\t\t\tlist.add(n);\n+\t\t\t\t\treturn list;\n+\t\t\t\t});\n+\t\t\t}\n+\t\t}\n+\t\tthis.objectsToValidate = objectsToValidate;\n+\t\tthis.index = index;\n+\t\tthis.ci = ci;\n+\t}\n+\n+\tpublic LocalUniqueNameContext(List<? extends EObject> objects, CancelIndicator ci) {\n+\t\tthis(objects, LocalUniqueNameContext::tryGetName, ci);\n+\t}\n+\n+\t@Override\n+\tpublic boolean isUnique() {\n+\t\treturn objectsToValidate.size() == index.size();\n+\t}\n+\n+\t@Override\n+\tpublic final boolean isCaseSensitive(EObject candidate, EClass clusterType) {\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\tpublic ISelectable getValidationScope(IEObjectDescription description, EClass clusterType) {\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic List<IEObjectDescription> getObjectsToValidate() {\n+\t\treturn objectsToValidate;\n+\t}\n+\n+\t@Override\n+\tpublic CancelIndicator cancelIndicator() {\n+\t\treturn ci;\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<IEObjectDescription> getExportedObjects() {\n+\t\treturn getObjectsToValidate();\n+\t}\n+\n+\t@Override\n+\tpublic boolean isEmpty() {\n+\t\treturn index.isEmpty();\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<IEObjectDescription> getExportedObjects(EClass type, QualifiedName name, boolean ignoreCase) {\n+\t\tPreconditions.checkArgument(!ignoreCase);\n+\t\tObject result = index.get(name.getFirstSegment());\n+\t\tif (result == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tif (result instanceof IEObjectDescription) {\n+\t\t\tif (EcoreUtil2.isAssignableFrom(type, ((IEObjectDescription) result).getEClass())) {\n+\t\t\t\treturn Collections.singletonList((IEObjectDescription)result);\n+\t\t\t}\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tList<IEObjectDescription> casted = (List<IEObjectDescription>) result;\n+\t\tif (type == EcorePackage.Literals.EOBJECT) {\n+\t\t\treturn casted;\n+\t\t}\n+\t\treturn FluentIterable.from(casted).filter(it -> EcoreUtil2.isAssignableFrom(type, it.getEClass()));\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<IEObjectDescription> getExportedObjectsByObject(EObject object) {\n+\t\treturn FluentIterable.from(objectsToValidate).filter(it -> object == it.getEObjectOrProxy());\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<IEObjectDescription> getExportedObjectsByType(EClass type) {\n+\t\treturn FluentIterable.from(objectsToValidate).filter(it -> EcoreUtil2.isAssignableFrom(type, it.getEClass()));\n+\t}\n+\n+\t/**\n+\t * Read the value of an EAttribute 'name', if present. Returns null of the given object is null or does not have a", "originalCommit": "9c98740dc7f70a0686c688f60d54439a6ba3e3c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAwNDQxOA==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r425004418", "bodyText": "Done", "author": "szarnekow", "createdAt": "2020-05-14T09:38:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDk5NzAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAwNzA1OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r425007059", "bodyText": "Could we use SimpleAttributeResolver.NAME_RESOLVER.getAttribute(obj); here, as done in the AbstractRenameStrategy class?", "author": "miklossy", "createdAt": "2020-05-14T09:42:41Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/LocalUniqueNameContext.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.validation;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.EObjectDescription;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.INamesAreUniqueValidationHelper.Context;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+\n+/**\n+ * <p>A case-sensitive, local validation context to check unique names in in the contents of \n+ * a container {@link EObject} or within a list.\n+ * </p>\n+ * Sample usage in a validation:\n+ * \n+ * <pre>\n+ * class MyDslValidator extends AbstractDeclarativeValidator {\n+ * \t&#64;Inject\n+ * \tINamesAreUniqueValidationHelper helper;\n+ * \n+ * \t&#64;Check\n+ * \tpublic void checkUniqueNames(Model model) {\n+ * \t\thelper.checkUniqueNames(new LocalUniqueNameContext(model), this);\n+ * \t}\n+ * }\n+ * </pre>\n+ * \n+ * @see INamesAreUniqueValidationHelper#checkUniqueNames(Context, ValidationMessageAcceptor)\n+ * \n+ * @since 2.22\n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class LocalUniqueNameContext implements INamesAreUniqueValidationHelper.Context, ISelectable {\n+\n+\tprivate final List<IEObjectDescription> objectsToValidate;\n+\tprivate final Map<String, Object> index;\n+\tprivate final CancelIndicator ci;\n+\n+\tpublic LocalUniqueNameContext(EObject container, Function<EObject, String> nameFunction, CancelIndicator ci) {\n+\t\tthis(container, false, nameFunction, ci);\n+\t}\n+\n+\tpublic LocalUniqueNameContext(EObject container, CancelIndicator ci) {\n+\t\tthis(container, LocalUniqueNameContext::tryGetName, ci);\n+\t}\n+\n+\tpublic LocalUniqueNameContext(EObject container, boolean deep, CancelIndicator ci) {\n+\t\tthis(container, deep, LocalUniqueNameContext::tryGetName, ci);\n+\t}\n+\n+\tpublic LocalUniqueNameContext(EObject container, boolean deep, Function<EObject, String> nameFunction, CancelIndicator ci) {\n+\t\tthis(deep ? () -> container.eAllContents() : container.eContents(), nameFunction, ci);\n+\t}\n+\n+\tpublic <T extends EObject> LocalUniqueNameContext(Iterable<T> objects, Function<T, String> nameFunction, CancelIndicator ci) {\n+\t\tMap<String, Object> index = new HashMap<>();\n+\t\tList<IEObjectDescription> objectsToValidate = new ArrayList<>();\n+\t\tfor (T t : objects) {\n+\t\t\tString name = nameFunction.apply(t);\n+\t\t\tif (name != null) {\n+\t\t\t\tIEObjectDescription description = EObjectDescription.create(name, t);\n+\t\t\t\tobjectsToValidate.add(description);\n+\t\t\t\tindex.merge(name, description, (p, n)->{\n+\t\t\t\t\tif (p instanceof List<?>) {\n+\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n+\t\t\t\t\t\tList<Object> list = (List<Object>) p;\n+\t\t\t\t\t\tlist.add(n);\n+\t\t\t\t\t\treturn list;\n+\t\t\t\t\t}\n+\t\t\t\t\tList<Object> list = new ArrayList<>();\n+\t\t\t\t\tlist.add(p);\n+\t\t\t\t\tlist.add(n);\n+\t\t\t\t\treturn list;\n+\t\t\t\t});\n+\t\t\t}\n+\t\t}\n+\t\tthis.objectsToValidate = objectsToValidate;\n+\t\tthis.index = index;\n+\t\tthis.ci = ci;\n+\t}\n+\n+\tpublic LocalUniqueNameContext(List<? extends EObject> objects, CancelIndicator ci) {\n+\t\tthis(objects, LocalUniqueNameContext::tryGetName, ci);\n+\t}\n+\n+\t@Override\n+\tpublic boolean isUnique() {\n+\t\treturn objectsToValidate.size() == index.size();\n+\t}\n+\n+\t@Override\n+\tpublic final boolean isCaseSensitive(EObject candidate, EClass clusterType) {\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\tpublic ISelectable getValidationScope(IEObjectDescription description, EClass clusterType) {\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic List<IEObjectDescription> getObjectsToValidate() {\n+\t\treturn objectsToValidate;\n+\t}\n+\n+\t@Override\n+\tpublic CancelIndicator cancelIndicator() {\n+\t\treturn ci;\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<IEObjectDescription> getExportedObjects() {\n+\t\treturn getObjectsToValidate();\n+\t}\n+\n+\t@Override\n+\tpublic boolean isEmpty() {\n+\t\treturn index.isEmpty();\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<IEObjectDescription> getExportedObjects(EClass type, QualifiedName name, boolean ignoreCase) {\n+\t\tPreconditions.checkArgument(!ignoreCase);\n+\t\tObject result = index.get(name.getFirstSegment());\n+\t\tif (result == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tif (result instanceof IEObjectDescription) {\n+\t\t\tif (EcoreUtil2.isAssignableFrom(type, ((IEObjectDescription) result).getEClass())) {\n+\t\t\t\treturn Collections.singletonList((IEObjectDescription)result);\n+\t\t\t}\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tList<IEObjectDescription> casted = (List<IEObjectDescription>) result;\n+\t\tif (type == EcorePackage.Literals.EOBJECT) {\n+\t\t\treturn casted;\n+\t\t}\n+\t\treturn FluentIterable.from(casted).filter(it -> EcoreUtil2.isAssignableFrom(type, it.getEClass()));\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<IEObjectDescription> getExportedObjectsByObject(EObject object) {\n+\t\treturn FluentIterable.from(objectsToValidate).filter(it -> object == it.getEObjectOrProxy());\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<IEObjectDescription> getExportedObjectsByType(EClass type) {\n+\t\treturn FluentIterable.from(objectsToValidate).filter(it -> EcoreUtil2.isAssignableFrom(type, it.getEClass()));\n+\t}\n+\n+\t/**\n+\t * Read the value of an EAttribute 'name', if present. Returns null of the given object is null or does not have a\n+\t * name.\n+\t */\n+\tpublic static String tryGetName(EObject obj) {\n+\t\tif (obj == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tEStructuralFeature name = obj.eClass().getEStructuralFeature(\"name\");\n+\t\tif (name != null && name.getEType() == EcorePackage.Literals.ESTRING) {\n+\t\t\treturn (String) obj.eGet(name);\n+\t\t}\n+\t\treturn null;\n+\t}", "originalCommit": "9c98740dc7f70a0686c688f60d54439a6ba3e3c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAxMDg2Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r425010862", "bodyText": "The SimpleAttributeResolver uses all sorts of weird caching which requires locking etc. I'd rather like to get rid of that one.", "author": "szarnekow", "createdAt": "2020-05-14T09:48:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAwNzA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAxMTM5NQ==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r425011395", "bodyText": "It even installs adapters on the objects which is really worrisome.", "author": "szarnekow", "createdAt": "2020-05-14T09:49:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAwNzA1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAxMzEwOA==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r425013108", "bodyText": "I see, than it is ok for me.", "author": "miklossy", "createdAt": "2020-05-14T09:52:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAwNzA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAzMjQ2Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r425032463", "bodyText": "Could be private.", "author": "miklossy", "createdAt": "2020-05-14T10:25:03Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/LocalUniqueNameContext.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.validation;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.EObjectDescription;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.INamesAreUniqueValidationHelper.Context;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+\n+/**\n+ * <p>A case-sensitive, local validation context to check unique names in the contents of \n+ * a container {@link EObject} or within a list.\n+ * </p>\n+ * Sample usage in a validation:\n+ * \n+ * <pre>\n+ * class MyDslValidator extends AbstractDeclarativeValidator {\n+ * \t&#64;Inject\n+ * \tINamesAreUniqueValidationHelper helper;", "originalCommit": "db97a4da6d0fc932468bd41fa3070375ca04a6d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAzMzQ2Mg==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r425033462", "bodyText": "The sample code does not compile, the CancelIndicator parameter is missing as the second argument of the LocalUniqueNameContext constructor call.", "author": "miklossy", "createdAt": "2020-05-14T10:26:43Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/LocalUniqueNameContext.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.validation;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.EObjectDescription;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.INamesAreUniqueValidationHelper.Context;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+\n+/**\n+ * <p>A case-sensitive, local validation context to check unique names in the contents of \n+ * a container {@link EObject} or within a list.\n+ * </p>\n+ * Sample usage in a validation:\n+ * \n+ * <pre>\n+ * class MyDslValidator extends AbstractDeclarativeValidator {\n+ * \t&#64;Inject\n+ * \tINamesAreUniqueValidationHelper helper;\n+ * \n+ * \t&#64;Check\n+ * \tpublic void checkUniqueNames(Model model) {\n+ * \t\thelper.checkUniqueNames(new LocalUniqueNameContext(model), this);", "originalCommit": "db97a4da6d0fc932468bd41fa3070375ca04a6d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTEyMTIyMw==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r425121223", "bodyText": "\ud83d\udc4d", "author": "szarnekow", "createdAt": "2020-05-14T13:07:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTAzMzQ2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTMzNTI4OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r425335289", "bodyText": "I think plural form isAffectedDueToExtensions could be a better choice here, since this method operates on a list of IsAffectedExtension objects.", "author": "miklossy", "createdAt": "2020-05-14T18:08:25Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/impl/DefaultResourceDescriptionManager.java", "diffHunk": "@@ -113,44 +117,62 @@ protected void addExportedNames(Set<QualifiedName> names, IResourceDescription r\n \t\t}\n \t}\n \t\n-    @Override\n+\t@Override\n \tpublic boolean isAffected(Collection<Delta> deltas, IResourceDescription candidate, IResourceDescriptions context) {\n-        Set<URI> outgoingReferences = descriptionUtils.collectOutgoingReferences(candidate);\n-        if (!outgoingReferences.isEmpty()) {\n-\t        for (IResourceDescription.Delta delta : deltas)\n-\t            if (hasChanges(delta, candidate) && outgoingReferences.contains(delta.getUri()))\n-\t                return true;\n-        }\n-        // this is a tradeoff - we could either check whether a given delta uri is contained\n-        // in a reachable container and check for intersecting names afterwards, or we can do\n-        // the other way round\n-        // unfortunately there is no way to decide reliably which algorithm scales better\n-        // note that this method is called for each description so we have something like a \n-        // number of deltas x number of resources which is not really nice\n-        List<IContainer> containers = null;\n-        Collection<QualifiedName> importedNames = getImportedNames(candidate);\n-        for (IResourceDescription.Delta delta : deltas) {\n-\t\t\tif (hasChanges(delta, candidate)) {\n-\t\t\t\t// not a java resource - delta's resource should be contained in a visible container\n-\t\t\t\t// as long as we did not delete the resource\n-\t\t\t\tURI uri = delta.getUri();\n-\t\t\t\tif ((uri.isPlatform() || uri.isArchive()) && delta.getNew() != null) { \n-\t\t\t\t\tif (containers == null)\n-\t\t\t\t\t\tcontainers = containerManager.getVisibleContainers(candidate, context);\n-\t\t\t\t\tboolean descriptionIsContained = false;\n-\t\t\t\t\tfor(int i = 0; i < containers.size() && !descriptionIsContained; i++) {\n-\t\t\t\t\t\tdescriptionIsContained = containers.get(i).hasResourceDescription(uri);\n-\t\t\t\t\t}\n-\t\t\t\t\tif (!descriptionIsContained)\n-\t\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\t\t\t\tif (isAffected(importedNames, delta.getNew()) || isAffected(importedNames, delta.getOld())) {\n+\t\tSet<URI> outgoingReferences = descriptionUtils.collectOutgoingReferences(candidate);\n+\t\tif (!outgoingReferences.isEmpty()) {\n+\t\t\tfor (IResourceDescription.Delta delta : deltas)\n+\t\t\t\tif (hasChanges(delta, candidate) && outgoingReferences.contains(delta.getUri()))\n \t\t\t\t\treturn true;\n+\t\t}\n+\t\t// this is a tradeoff - we could either check whether a given delta uri is contained\n+\t\t// in a reachable container and check for intersecting names afterwards, or we can do\n+\t\t// the other way round\n+\t\t// unfortunately there is no way to decide reliably which algorithm scales better\n+\t\t// note that this method is called for each description so we have something like a\n+\t\t// number of deltas x number of resources which is not really nice\n+\t\tList<IContainer> containers = null;\n+\t\tCollection<QualifiedName> importedNames = getImportedNames(candidate);\n+\t\tif (!importedNames.isEmpty()) {\n+\t\t\tfor (IResourceDescription.Delta delta : deltas) {\n+\t\t\t\tif (hasChanges(delta, candidate)) {\n+\t\t\t\t\t// not a java resource - delta's resource should be contained in a visible container\n+\t\t\t\t\t// as long as we did not delete the resource\n+\t\t\t\t\tURI uri = delta.getUri();\n+\t\t\t\t\tif ((uri.isPlatform() || uri.isArchive()) && delta.getNew() != null) {\n+\t\t\t\t\t\tif (containers == null)\n+\t\t\t\t\t\t\tcontainers = containerManager.getVisibleContainers(candidate, context);\n+\t\t\t\t\t\tboolean descriptionIsContained = false;\n+\t\t\t\t\t\tfor (int i = 0; i < containers.size() && !descriptionIsContained; i++) {\n+\t\t\t\t\t\t\tdescriptionIsContained = containers.get(i).hasResourceDescription(uri);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tif (!descriptionIsContained) {\n+\t\t\t\t\t\t\treturn isAffectedDueToExtension(deltas, candidate, context);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (isAffected(importedNames, delta.getNew()) || isAffected(importedNames, delta.getOld())) {\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-        }\n-        return false;\n-    }\n+\t\t}\n+\t\treturn isAffectedDueToExtension(deltas, candidate, context);\n+\t}\n+\n+\t/**\n+\t * Query all registered extensions.\n+\t * \n+\t * @since 2.22\n+\t */\n+\tprotected boolean isAffectedDueToExtension(Collection<Delta> deltas, IResourceDescription candidate,", "originalCommit": "c5a39f9b1b386e85c5992eac9810f6cb3835a783", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM0MjcyNA==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r425342724", "bodyText": "Maybe some rewording to improve the readability: An extension that can be bound to compute resources beyond the default linking semantics as being affected by a change", "author": "miklossy", "createdAt": "2020-05-14T18:21:51Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/impl/IsAffectedExtension.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.resource.impl;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.IResourceDescription.Delta;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.inject.Binding;\n+import com.google.inject.Inject;\n+import com.google.inject.Injector;\n+import com.google.inject.Provider;\n+import com.google.inject.TypeLiteral;\n+\n+/**\n+ * An extension that can be bound to compute resources as being affected\n+ * by a change beyond the default linking semantics, e.g. some validations", "originalCommit": "c5a39f9b1b386e85c5992eac9810f6cb3835a783", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM0NTE2Nw==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r425345167", "bodyText": "I would enclose the block with { and } even if it contains only one statement.", "author": "miklossy", "createdAt": "2020-05-14T18:26:13Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/DefaultUniqueNameContext.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.validation;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtext.resource.IContainer;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.IResourceDescriptionsProvider;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.resource.impl.AbstractCompoundSelectable;\n+import org.eclipse.xtext.scoping.ICaseInsensitivityHelper;\n+import org.eclipse.xtext.scoping.impl.CaseInsensitivityHelper;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.INamesAreUniqueValidationHelper.Context;\n+\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * Standard implementation of a {@link INamesAreUniqueValidationHelper.Context}.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @since 2.22\n+ */\n+public class DefaultUniqueNameContext implements INamesAreUniqueValidationHelper.Context {\n+\n+\t/**\n+\t * Base class for {@link INamesAreUniqueValidationHelper.ContextProvider}.\n+\t */\n+\tpublic static abstract class BaseContextProvider implements INamesAreUniqueValidationHelper.ContextProvider {\n+\t\t@Inject\n+\t\tprivate IResourceServiceProvider.Registry resourceServiceProviderRegistry = IResourceServiceProvider.Registry.INSTANCE;\n+\t\t@Inject\n+\t\tprivate ICaseInsensitivityHelper caseInsensitivityHelper = new CaseInsensitivityHelper();\n+\n+\t\tprotected IResourceServiceProvider getResourceServiceProvider(Resource r) {\n+\t\t\treturn resourceServiceProviderRegistry.getResourceServiceProvider(r.getURI());\n+\t\t}\n+\n+\t\tprotected IResourceDescription getResourceDescription(Resource resource) {\n+\t\t\tIResourceDescription.Manager manager = getResourceDescriptionManager(resource);\n+\t\t\tif (manager != null) {\n+\t\t\t\treturn manager.getResourceDescription(resource);\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tprotected IResourceDescription.Manager getResourceDescriptionManager(Resource resource) {\n+\t\t\tIResourceServiceProvider resourceServiceProvider = getResourceServiceProvider(resource);\n+\t\t\tif (resourceServiceProvider == null)\n+\t\t\t\treturn null;", "originalCommit": "c5a39f9b1b386e85c5992eac9810f6cb3835a783", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM0OTk5NA==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r425349994", "bodyText": "I think cancelIndicator would be a more suitable name instead of ci. Occurs on several other places as well.", "author": "miklossy", "createdAt": "2020-05-14T18:34:51Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/DefaultUniqueNameContext.java", "diffHunk": "@@ -0,0 +1,320 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.validation;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+import org.eclipse.xtext.resource.IContainer;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.IResourceDescriptionsProvider;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.resource.impl.AbstractCompoundSelectable;\n+import org.eclipse.xtext.scoping.ICaseInsensitivityHelper;\n+import org.eclipse.xtext.scoping.impl.CaseInsensitivityHelper;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.INamesAreUniqueValidationHelper.Context;\n+\n+import com.google.common.collect.Iterables;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * Standard implementation of a {@link INamesAreUniqueValidationHelper.Context}.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @since 2.22\n+ */\n+public class DefaultUniqueNameContext implements INamesAreUniqueValidationHelper.Context {\n+\n+\t/**\n+\t * Base class for {@link INamesAreUniqueValidationHelper.ContextProvider}.\n+\t */\n+\tpublic static abstract class BaseContextProvider implements INamesAreUniqueValidationHelper.ContextProvider {\n+\t\t@Inject\n+\t\tprivate IResourceServiceProvider.Registry resourceServiceProviderRegistry = IResourceServiceProvider.Registry.INSTANCE;\n+\t\t@Inject\n+\t\tprivate ICaseInsensitivityHelper caseInsensitivityHelper = new CaseInsensitivityHelper();\n+\n+\t\tprotected IResourceServiceProvider getResourceServiceProvider(Resource r) {\n+\t\t\treturn resourceServiceProviderRegistry.getResourceServiceProvider(r.getURI());\n+\t\t}\n+\n+\t\tprotected IResourceDescription getResourceDescription(Resource resource) {\n+\t\t\tIResourceDescription.Manager manager = getResourceDescriptionManager(resource);\n+\t\t\tif (manager != null) {\n+\t\t\t\treturn manager.getResourceDescription(resource);\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\tprotected IResourceDescription.Manager getResourceDescriptionManager(Resource resource) {\n+\t\t\tIResourceServiceProvider resourceServiceProvider = getResourceServiceProvider(resource);\n+\t\t\tif (resourceServiceProvider == null)\n+\t\t\t\treturn null;\n+\t\t\treturn resourceServiceProvider.getResourceDescriptionManager();\n+\t\t}\n+\n+\t\tprotected ICaseInsensitivityHelper getCaseInsensitivityHelper() {\n+\t\t\treturn caseInsensitivityHelper;\n+\t\t}\n+\n+\t\tprotected void setResourceServiceProviderRegistry(\n+\t\t\t\tIResourceServiceProvider.Registry resourceServiceProviderRegistry) {\n+\t\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Base class for non-local unique name validation context providers.\n+\t */\n+\tpublic static abstract class BaseGlobalContextProvider extends BaseContextProvider {\n+\t\t@Inject\n+\t\tprivate IResourceDescriptionsProvider indexAccess;\n+\n+\t\tprotected IResourceDescriptions getIndex(Resource resource) {\n+\t\t\tResourceSet resourceSet = resource.getResourceSet();\n+\t\t\tif (resourceSet == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\treturn indexAccess.getResourceDescriptions(resourceSet);\n+\t\t}\n+\n+\t\tprotected boolean intersects(IResourceDescription left, IResourceDescription right, boolean caseSensitive) {\n+\t\t\tfor (IEObjectDescription description : left.getExportedObjects()) {\n+\t\t\t\tIterable<IEObjectDescription> exportedObjects = right.getExportedObjects(EcorePackage.Literals.EOBJECT,\n+\t\t\t\t\t\tdescription.getName(), !caseSensitive);\n+\t\t\t\tif (!Iterables.isEmpty(exportedObjects)) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tprotected boolean isAffected(IResourceDescription.Delta delta, IResourceDescription candidate,\n+\t\t\t\tboolean caseSensitive) {\n+\t\t\tif (candidate.getURI().equals(delta.getUri())) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (delta.getNew() != null && intersects(delta.getNew(), candidate, caseSensitive)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tif (delta.getOld() != null && intersects(delta.getOld(), candidate, caseSensitive)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * <p>\n+\t * Provide a context for the entire index.\n+\t * </p><p>\n+\t * Drawback: If a resoure in a project A introduces a duplication with a resource in project B, an incremental build\n+\t * of A may fail to notify B, if B is a dependency of A. Triggering a clean build in B will subsequently create the\n+\t * validation problem / fix the validation problem there, too but in Eclipse, the incremental build will not provide\n+\t * the same level of consistency.\n+\t * </p>\n+\t */\n+\t@Singleton\n+\tpublic static class Global extends BaseGlobalContextProvider {\n+\n+\t\t@Override\n+\t\tpublic Context tryGetContext(Resource resource, CancelIndicator cancelIndicator) {\n+\t\t\tIResourceDescriptions index = getIndex(resource);\n+\t\t\tif (index == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tIResourceDescription description = getResourceDescription(resource);\n+\t\t\tif (description != null) {\n+\t\t\t\treturn new DefaultUniqueNameContext(description, index, getCaseInsensitivityHelper(), cancelIndicator);\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isAffected(Collection<IResourceDescription.Delta> deltas, IResourceDescription candidate,\n+\t\t\t\tIResourceDescriptions context) {\n+\t\t\tfor (IResourceDescription.Delta delta : deltas) {\n+\t\t\t\tif (isAffected(delta, candidate, true)) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t}\n+\n+\t/**\n+\t * Provide a context for current {@link IContainer}.\n+\t */\n+\t@Singleton\n+\tpublic static class Container extends BaseGlobalContextProvider {\n+\n+\t\t@Inject\n+\t\tprivate IContainer.Manager containerManager;\n+\n+\t\t@Override\n+\t\tpublic Context tryGetContext(Resource resource, CancelIndicator cancelIndicator) {\n+\t\t\tIResourceDescriptions index = getIndex(resource);\n+\t\t\tif (index == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tIResourceDescription description = getResourceDescription(resource);\n+\t\t\tif (description == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tIContainer container = containerManager.getContainer(description, index);\n+\t\t\treturn new DefaultUniqueNameContext(description, container, getCaseInsensitivityHelper(), cancelIndicator);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isAffected(Collection<IResourceDescription.Delta> deltas, IResourceDescription candidate,\n+\t\t\t\tIResourceDescriptions context) {\n+\t\t\tIContainer container = containerManager.getContainer(candidate, context);\n+\t\t\tfor (IResourceDescription.Delta delta : deltas) {\n+\t\t\t\tif (delta.getNew() == null) {\n+\t\t\t\t\tif (intersects(delta.getOld(), candidate, true)) {\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\t\t\t\t} else if (container.getResourceDescription(delta.getUri()) != null) {\n+\t\t\t\t\tif (isAffected(delta, candidate, true)) {\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t}\n+\n+\t/**\n+\t * Provide a context for all visible {@link IContainer containers}.\n+\t */\n+\t@Singleton\n+\tpublic static class VisibleContainers extends BaseGlobalContextProvider {\n+\n+\t\tpublic static class Selectable extends AbstractCompoundSelectable {\n+\n+\t\t\tprivate final List<IContainer> containers;\n+\n+\t\t\tpublic Selectable(List<IContainer> containers) {\n+\t\t\t\tthis.containers = containers;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tprotected Iterable<? extends ISelectable> getSelectables() {\n+\t\t\t\treturn containers;\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\t@Inject\n+\t\tprivate IContainer.Manager containerManager;\n+\n+\t\t@Override\n+\t\tpublic Context tryGetContext(Resource resource, CancelIndicator cancelIndicator) {\n+\t\t\tIResourceDescriptions index = getIndex(resource);\n+\t\t\tif (index == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tIResourceDescription description = getResourceDescription(resource);\n+\t\t\tif (description == null) {\n+\t\t\t\treturn null;\n+\t\t\t}\n+\t\t\tList<IContainer> containers = containerManager.getVisibleContainers(description, index);\n+\t\t\treturn new DefaultUniqueNameContext(description, new Selectable(containers), getCaseInsensitivityHelper(),\n+\t\t\t\t\tcancelIndicator);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isAffected(Collection<IResourceDescription.Delta> deltas, IResourceDescription candidate,\n+\t\t\t\tIResourceDescriptions context) {\n+\t\t\tList<IContainer> containers = containerManager.getVisibleContainers(candidate, context);\n+\t\t\tfor (IResourceDescription.Delta delta : deltas) {\n+\t\t\t\tif (delta.getNew() == null) {\n+\t\t\t\t\tif (intersects(delta.getOld(), candidate, true)) {\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tcontainers: for (IContainer container : containers) {\n+\t\t\t\t\t\tif (container.getResourceDescription(delta.getUri()) != null) {\n+\t\t\t\t\t\t\tif (isAffected(delta, candidate, true)) {\n+\t\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tbreak containers;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t}\n+\n+\t/**\n+\t * A case sensitive validation context that ensures unique names among the exported names per single resource.\n+\t */\n+\t@Singleton\n+\tpublic static class ExportedFromResource extends BaseContextProvider {\n+\n+\t\t@SuppressWarnings(\"deprecation\")\n+\t\t@Override\n+\t\tpublic Context tryGetContext(Resource resource, CancelIndicator cancelIndicator) {\n+\t\t\tIResourceDescription description = getResourceDescription(resource);\n+\t\t\tif (description != null) {\n+\t\t\t\treturn new UniqueInResourceContext(description, cancelIndicator);\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t}\n+\n+\t}\n+\n+\tprivate final IResourceDescription resourceDescription;\n+\tprivate final ISelectable validationScope;\n+\tprivate final CancelIndicator ci;", "originalCommit": "c5a39f9b1b386e85c5992eac9810f6cb3835a783", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM1Mjc3OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r425352779", "bodyText": "procedure -> procedure/function to indicate that a field can have the same name as a procedure or function", "author": "miklossy", "createdAt": "2020-05-14T18:39:56Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/INamesAreUniqueValidationHelper.java", "diffHunk": "@@ -8,29 +8,154 @@\n  *******************************************************************************/\n package org.eclipse.xtext.validation;\n \n+import java.util.Collection;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.resource.Resource;\n import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.resource.IResourceDescription.Delta;\n+import org.eclipse.xtext.resource.impl.IsAffectedExtension;\n+import org.eclipse.xtext.scoping.ICaseInsensitivityHelper;\n import org.eclipse.xtext.util.CancelIndicator;\n \n import com.google.inject.ImplementedBy;\n+import com.google.inject.name.Named;\n \n /**\n+ * The helper can be used to validate unique names locally or across resource boundaries.\n+ * \n+ * @see LocalUniqueNameContext\n  * @author Sebastian Zarnekow - Initial contribution and API\n  */\n @ImplementedBy(NamesAreUniqueValidationHelper.class)\n public interface INamesAreUniqueValidationHelper {\n \n \t/**\n-\t * Create errors for objects that have the same name. Objects, that do not belong to\n+\t * Provide the context information for the unique name validation.\n+\t * \n+\t * Registered by default as a {@link IsAffectedExtension} as {@link Named @Named(\"IsAffectedExtension.UniqueNames\")}.\n+\t * \n+\t * @since 2.22\n+\t */\n+\t@ImplementedBy(DefaultUniqueNameContext.ExportedFromResource.class)\n+\tinterface ContextProvider extends IsAffectedExtension {\n+\t\t\n+\t\t/**\n+\t\t * Obtain the context of the unique name validation for the given resource.\n+\t\t * \n+\t\t * May return null.\n+\t\t */\n+\t\tContext tryGetContext(Resource resource, CancelIndicator cancelIndicator);\n+\t\t\n+\t\t@Override\n+\t\tdefault boolean isAffected(Collection<Delta> deltas, IResourceDescription candidate,\n+\t\t\t\tIResourceDescriptions context) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * <p>\n+\t * Provides context information to the validation that allows to introspect the scope in which the validation for\n+\t * unique names is supposed to happen.\n+\t * </p>\n+\t * <p>\n+\t * The term <code>clusterType</code> is used to denote a {@link EClass (super-)type} of the current object under\n+\t * validation. When checking the name for uniqueness, all objects that are instances of the given cluster type are\n+\t * considered. This can be used to define different namespaces. For example, a language that has the concepts of\n+\t * <code>Fields</code>, <code>Procedures</code> and <code>Functions</code> may provide 2 different cluster types.\n+\t * <ol>\n+\t * <li>All fields must have a unique name.</li>\n+\t * <li>The executable procedure and functions use the same namespace and may not have duplicate names.</li>\n+\t * </ol>\n+\t * This would allow a field to use the same name as a procedure but flag a duplication if a procedure has the same", "originalCommit": "c5a39f9b1b386e85c5992eac9810f6cb3835a783", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM1MzIyNw==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r425353227", "bodyText": "an ISelectable", "author": "miklossy", "createdAt": "2020-05-14T18:40:39Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/INamesAreUniqueValidationHelper.java", "diffHunk": "@@ -8,29 +8,154 @@\n  *******************************************************************************/\n package org.eclipse.xtext.validation;\n \n+import java.util.Collection;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.resource.Resource;\n import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.resource.IResourceDescription.Delta;\n+import org.eclipse.xtext.resource.impl.IsAffectedExtension;\n+import org.eclipse.xtext.scoping.ICaseInsensitivityHelper;\n import org.eclipse.xtext.util.CancelIndicator;\n \n import com.google.inject.ImplementedBy;\n+import com.google.inject.name.Named;\n \n /**\n+ * The helper can be used to validate unique names locally or across resource boundaries.\n+ * \n+ * @see LocalUniqueNameContext\n  * @author Sebastian Zarnekow - Initial contribution and API\n  */\n @ImplementedBy(NamesAreUniqueValidationHelper.class)\n public interface INamesAreUniqueValidationHelper {\n \n \t/**\n-\t * Create errors for objects that have the same name. Objects, that do not belong to\n+\t * Provide the context information for the unique name validation.\n+\t * \n+\t * Registered by default as a {@link IsAffectedExtension} as {@link Named @Named(\"IsAffectedExtension.UniqueNames\")}.\n+\t * \n+\t * @since 2.22\n+\t */\n+\t@ImplementedBy(DefaultUniqueNameContext.ExportedFromResource.class)\n+\tinterface ContextProvider extends IsAffectedExtension {\n+\t\t\n+\t\t/**\n+\t\t * Obtain the context of the unique name validation for the given resource.\n+\t\t * \n+\t\t * May return null.\n+\t\t */\n+\t\tContext tryGetContext(Resource resource, CancelIndicator cancelIndicator);\n+\t\t\n+\t\t@Override\n+\t\tdefault boolean isAffected(Collection<Delta> deltas, IResourceDescription candidate,\n+\t\t\t\tIResourceDescriptions context) {\n+\t\t\treturn false;\n+\t\t}\n+\t}\n+\t\n+\t/**\n+\t * <p>\n+\t * Provides context information to the validation that allows to introspect the scope in which the validation for\n+\t * unique names is supposed to happen.\n+\t * </p>\n+\t * <p>\n+\t * The term <code>clusterType</code> is used to denote a {@link EClass (super-)type} of the current object under\n+\t * validation. When checking the name for uniqueness, all objects that are instances of the given cluster type are\n+\t * considered. This can be used to define different namespaces. For example, a language that has the concepts of\n+\t * <code>Fields</code>, <code>Procedures</code> and <code>Functions</code> may provide 2 different cluster types.\n+\t * <ol>\n+\t * <li>All fields must have a unique name.</li>\n+\t * <li>The executable procedure and functions use the same namespace and may not have duplicate names.</li>\n+\t * </ol>\n+\t * This would allow a field to use the same name as a procedure but flag a duplication if a procedure has the same\n+\t * name as a function.\n+\t * </p>\n+\t * \n+\t * @since 2.22\n+\t */\n+\tinterface Context {\n+\t\t/**\n+\t\t * <p>\n+\t\t * Returns a {@link ISelectable} that can be queried for elements with a given name to find duplicates.", "originalCommit": "c5a39f9b1b386e85c5992eac9810f6cb3835a783", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM2NjE0Mw==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r425366143", "bodyText": "maybe: Sample usage in a validator:", "author": "miklossy", "createdAt": "2020-05-14T19:03:04Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/LocalUniqueNameContext.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.validation;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.EObjectDescription;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.INamesAreUniqueValidationHelper.Context;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+\n+/**\n+ * <p>A case-sensitive, local validation context to check unique names in the contents of \n+ * a container {@link EObject} or within a list.\n+ * </p>\n+ * Sample usage in a validation:", "originalCommit": "c5a39f9b1b386e85c5992eac9810f6cb3835a783", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM3MTU4Ng==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r425371586", "bodyText": "maybe: does not have a name with type ESTRING.", "author": "miklossy", "createdAt": "2020-05-14T19:13:28Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/LocalUniqueNameContext.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Sebastian Zarnekow and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.validation;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EStructuralFeature;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.EObjectDescription;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.ISelectable;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.INamesAreUniqueValidationHelper.Context;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.FluentIterable;\n+\n+/**\n+ * <p>A case-sensitive, local validation context to check unique names in the contents of \n+ * a container {@link EObject} or within a list.\n+ * </p>\n+ * Sample usage in a validation:\n+ * \n+ * <pre>\n+ * class MyDslValidator extends AbstractDeclarativeValidator {\n+ * \t&#64;Inject\n+ * \tprivate INamesAreUniqueValidationHelper helper;\n+ * \n+ * \t&#64;Check\n+ * \tpublic void checkUniqueNames(Model model) {\n+ * \t\thelper.checkUniqueNames(new LocalUniqueNameContext(model, getCancelIndicator()), this);\n+ * \t}\n+ * }\n+ * </pre>\n+ * \n+ * @see INamesAreUniqueValidationHelper#checkUniqueNames(Context, ValidationMessageAcceptor)\n+ * \n+ * @since 2.22\n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class LocalUniqueNameContext implements INamesAreUniqueValidationHelper.Context, ISelectable {\n+\n+\tprivate final List<IEObjectDescription> objectsToValidate;\n+\tprivate final Map<String, Object> index;\n+\tprivate final CancelIndicator ci;\n+\n+\tpublic LocalUniqueNameContext(EObject container, Function<EObject, String> nameFunction, CancelIndicator ci) {\n+\t\tthis(container, false, nameFunction, ci);\n+\t}\n+\n+\tpublic LocalUniqueNameContext(EObject container, CancelIndicator ci) {\n+\t\tthis(container, LocalUniqueNameContext::tryGetName, ci);\n+\t}\n+\n+\tpublic LocalUniqueNameContext(EObject container, boolean deep, CancelIndicator ci) {\n+\t\tthis(container, deep, LocalUniqueNameContext::tryGetName, ci);\n+\t}\n+\n+\tpublic LocalUniqueNameContext(EObject container, boolean deep, Function<EObject, String> nameFunction, CancelIndicator ci) {\n+\t\tthis(deep ? () -> container.eAllContents() : container.eContents(), nameFunction, ci);\n+\t}\n+\n+\tpublic <T extends EObject> LocalUniqueNameContext(Iterable<T> objects, Function<T, String> nameFunction, CancelIndicator ci) {\n+\t\tMap<String, Object> index = new HashMap<>();\n+\t\tList<IEObjectDescription> objectsToValidate = new ArrayList<>();\n+\t\tfor (T t : objects) {\n+\t\t\tString name = nameFunction.apply(t);\n+\t\t\tif (name != null) {\n+\t\t\t\tIEObjectDescription description = EObjectDescription.create(name, t);\n+\t\t\t\tobjectsToValidate.add(description);\n+\t\t\t\tindex.merge(name, description, (p, n)->{\n+\t\t\t\t\tif (p instanceof List<?>) {\n+\t\t\t\t\t\t@SuppressWarnings(\"unchecked\")\n+\t\t\t\t\t\tList<Object> list = (List<Object>) p;\n+\t\t\t\t\t\tlist.add(n);\n+\t\t\t\t\t\treturn list;\n+\t\t\t\t\t}\n+\t\t\t\t\tList<Object> list = new ArrayList<>();\n+\t\t\t\t\tlist.add(p);\n+\t\t\t\t\tlist.add(n);\n+\t\t\t\t\treturn list;\n+\t\t\t\t});\n+\t\t\t}\n+\t\t}\n+\t\tthis.objectsToValidate = objectsToValidate;\n+\t\tthis.index = index;\n+\t\tthis.ci = ci;\n+\t}\n+\n+\tpublic LocalUniqueNameContext(List<? extends EObject> objects, CancelIndicator ci) {\n+\t\tthis(objects, LocalUniqueNameContext::tryGetName, ci);\n+\t}\n+\n+\t@Override\n+\tpublic boolean isUnique() {\n+\t\treturn objectsToValidate.size() == index.size();\n+\t}\n+\n+\t@Override\n+\tpublic final boolean isCaseSensitive(EObject candidate, EClass clusterType) {\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\tpublic ISelectable getValidationScope(IEObjectDescription description, EClass clusterType) {\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic List<IEObjectDescription> getObjectsToValidate() {\n+\t\treturn objectsToValidate;\n+\t}\n+\n+\t@Override\n+\tpublic CancelIndicator cancelIndicator() {\n+\t\treturn ci;\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<IEObjectDescription> getExportedObjects() {\n+\t\treturn getObjectsToValidate();\n+\t}\n+\n+\t@Override\n+\tpublic boolean isEmpty() {\n+\t\treturn index.isEmpty();\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<IEObjectDescription> getExportedObjects(EClass type, QualifiedName name, boolean ignoreCase) {\n+\t\tPreconditions.checkArgument(!ignoreCase);\n+\t\tObject result = index.get(name.getFirstSegment());\n+\t\tif (result == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tif (result instanceof IEObjectDescription) {\n+\t\t\tif (EcoreUtil2.isAssignableFrom(type, ((IEObjectDescription) result).getEClass())) {\n+\t\t\t\treturn Collections.singletonList((IEObjectDescription)result);\n+\t\t\t}\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tList<IEObjectDescription> casted = (List<IEObjectDescription>) result;\n+\t\tif (type == EcorePackage.Literals.EOBJECT) {\n+\t\t\treturn casted;\n+\t\t}\n+\t\treturn FluentIterable.from(casted).filter(it -> EcoreUtil2.isAssignableFrom(type, it.getEClass()));\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<IEObjectDescription> getExportedObjectsByObject(EObject object) {\n+\t\treturn FluentIterable.from(objectsToValidate).filter(it -> object == it.getEObjectOrProxy());\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<IEObjectDescription> getExportedObjectsByType(EClass type) {\n+\t\treturn FluentIterable.from(objectsToValidate).filter(it -> EcoreUtil2.isAssignableFrom(type, it.getEClass()));\n+\t}\n+\n+\t/**\n+\t * Read the value of an EAttribute 'name', if present. Returns null if the given object is null or does not have a\n+\t * name.", "originalCommit": "c5a39f9b1b386e85c5992eac9810f6cb3835a783", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM3MzEzNw==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r425373137", "bodyText": "maybe we can place since 2.22 at the beginning of the sentence to better emphasize that. At the end it is very difficult to recognize. Occurs on other places as well.", "author": "miklossy", "createdAt": "2020-05-14T19:16:32Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/NamesAreUniqueValidationHelper.java", "diffHunk": "@@ -24,62 +21,152 @@\n import org.eclipse.emf.ecore.EcorePackage;\n import org.eclipse.xtext.naming.QualifiedName;\n import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.ISelectable;\n import org.eclipse.xtext.service.OperationCanceledManager;\n+import org.eclipse.xtext.util.CancelIndicator;\n \n+import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Maps;\n+import com.google.inject.Singleton;\n \n /**\n  * @author Sebastian Zarnekow - Initial contribution and API\n  */\n+@Singleton\n public class NamesAreUniqueValidationHelper implements INamesAreUniqueValidationHelper {\n \n \tprivate ImmutableSet<EClass> clusterTypes = getClusterTypes();\n-\t\n-\t@Inject \n+\n+\t@Inject\n \tprivate OperationCanceledManager operationCanceledManager = new OperationCanceledManager();\n-\t\n+\n \t/**\n-\t * <p>Initialize the set of clustering types. A type is considered to be clustering\n-\t * if any instance of that type has to have a unique name when\n-\t * it is transformed to an {@link org.eclipse.xtext.resource.IEObjectDescription}.\n-\t * Instances that do not belong to the same cluster may have the same exported name.</p>\n-\t * <p>A clustering type will often be some kind of root type in a type hierarchy.</p> \n+\t * <p>\n+\t * Initialize the set of clustering types. A type is considered to be clustering if any instance of that type has to\n+\t * have a unique name when it is transformed to an {@link org.eclipse.xtext.resource.IEObjectDescription}. Instances\n+\t * that do not belong to the same cluster may have the same exported name.\n+\t * </p>\n+\t * <p>\n+\t * A clustering type will often be some kind of root type in a type hierarchy.\n+\t * </p>\n \t */\n \tprotected ImmutableSet<EClass> getClusterTypes() {\n \t\treturn ImmutableSet.of(EcorePackage.Literals.EOBJECT);\n \t}\n-\t\n+\n+\t/**\n+\t * @deprecated Implementations should adhere to the context provided via\n+\t *             {@link #checkUniqueNames(Iterable, Context, ValidationMessageAcceptor)} since 2.22", "originalCommit": "c5a39f9b1b386e85c5992eac9810f6cb3835a783", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM3NzYwMw==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r425377603", "bodyText": "Typo: futher -> further", "author": "miklossy", "createdAt": "2020-05-14T19:25:05Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/NamesAreUniqueValidationHelper.java", "diffHunk": "@@ -24,62 +21,152 @@\n import org.eclipse.emf.ecore.EcorePackage;\n import org.eclipse.xtext.naming.QualifiedName;\n import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.ISelectable;\n import org.eclipse.xtext.service.OperationCanceledManager;\n+import org.eclipse.xtext.util.CancelIndicator;\n \n+import com.google.common.base.Preconditions;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Maps;\n+import com.google.inject.Singleton;\n \n /**\n  * @author Sebastian Zarnekow - Initial contribution and API\n  */\n+@Singleton\n public class NamesAreUniqueValidationHelper implements INamesAreUniqueValidationHelper {\n \n \tprivate ImmutableSet<EClass> clusterTypes = getClusterTypes();\n-\t\n-\t@Inject \n+\n+\t@Inject\n \tprivate OperationCanceledManager operationCanceledManager = new OperationCanceledManager();\n-\t\n+\n \t/**\n-\t * <p>Initialize the set of clustering types. A type is considered to be clustering\n-\t * if any instance of that type has to have a unique name when\n-\t * it is transformed to an {@link org.eclipse.xtext.resource.IEObjectDescription}.\n-\t * Instances that do not belong to the same cluster may have the same exported name.</p>\n-\t * <p>A clustering type will often be some kind of root type in a type hierarchy.</p> \n+\t * <p>\n+\t * Initialize the set of clustering types. A type is considered to be clustering if any instance of that type has to\n+\t * have a unique name when it is transformed to an {@link org.eclipse.xtext.resource.IEObjectDescription}. Instances\n+\t * that do not belong to the same cluster may have the same exported name.\n+\t * </p>\n+\t * <p>\n+\t * A clustering type will often be some kind of root type in a type hierarchy.\n+\t * </p>\n \t */\n \tprotected ImmutableSet<EClass> getClusterTypes() {\n \t\treturn ImmutableSet.of(EcorePackage.Literals.EOBJECT);\n \t}\n-\t\n+\n+\t/**\n+\t * @deprecated Implementations should adhere to the context provided via\n+\t *             {@link #checkUniqueNames(Iterable, Context, ValidationMessageAcceptor)} since 2.22\n+\t */\n+\t@Deprecated\n \t@Override\n-\tpublic void checkUniqueNames(Iterable<IEObjectDescription> descriptions, \n-\t\t\tValidationMessageAcceptor acceptor) {\n-\t\tcheckUniqueNames(descriptions, null, acceptor);\n+\tpublic void checkUniqueNames(Iterable<IEObjectDescription> descriptions, ValidationMessageAcceptor acceptor) {\n+\t\tcheckUniqueNames(descriptions, (CancelIndicator) null, acceptor);\n \t}\n-\t\n+\n \t/**\n \t * <p>\n \t * {@inheritDoc}\n \t * </p>\n-\t * The cancel indicator will be queried everytime a description has been processed.\n-\t * It should provide a fast answer about its canceled state.\n+\t * The cancel indicator will be queried everytime a description has been processed. It should provide a fast answer\n+\t * about its canceled state.\n+\t * \n+\t * @deprecated Implementations should adhere to the context provided via\n+\t *             {@link #checkUniqueNames(Iterable, Context, ValidationMessageAcceptor)} since 2.22\n \t */\n+\t@Deprecated\n \t@Override\n-\tpublic void checkUniqueNames(Iterable<IEObjectDescription> descriptions, \n-\t\t\tCancelIndicator cancelIndicator, \n+\tpublic void checkUniqueNames(Iterable<IEObjectDescription> descriptions, CancelIndicator cancelIndicator,\n \t\t\tValidationMessageAcceptor acceptor) {\n \t\tIterator<IEObjectDescription> iter = descriptions.iterator();\n \t\tif (!iter.hasNext())\n \t\t\treturn;\n \t\tMap<EClass, Map<QualifiedName, IEObjectDescription>> clusterToNames = Maps.newHashMap();\n-\t\twhile(iter.hasNext()) {\n+\t\twhile (iter.hasNext()) {\n \t\t\tIEObjectDescription description = iter.next();\n \t\t\tcheckDescriptionForDuplicatedName(description, clusterToNames, acceptor);\n \t\t\toperationCanceledManager.checkCanceled(cancelIndicator);\n \t\t}\n \t}\n-\t\n-\tprotected void checkDescriptionForDuplicatedName(\n-\t\t\tIEObjectDescription description,\n+\n+\t/**\n+\t * @since 2.22\n+\t */\n+\t@SuppressWarnings(\"deprecation\")\n+\t@Override\n+\tpublic void checkUniqueNames(Context context, ValidationMessageAcceptor acceptor) {\n+\t\tif (!NamesAreUniqueValidationHelper.class.equals(getClass()) && context instanceof UniqueInResourceContext) {\n+\t\t\tcheckUniqueNames(context.getObjectsToValidate(), context.cancelIndicator(), acceptor);\n+\t\t} else {\n+\t\t\tdoCheckUniqueNames(context, acceptor);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * @since 2.22\n+\t */\n+\tprotected void doCheckUniqueNames(Context context, ValidationMessageAcceptor acceptor) {\n+\t\tCancelIndicator cancelIndicator = context.cancelIndicator();\n+\t\tfor (IEObjectDescription description : context.getObjectsToValidate()) {\n+\t\t\toperationCanceledManager.checkCanceled(cancelIndicator);\n+\t\t\tdoCheckUniqueIn(description, context, acceptor);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * @since 2.22\n+\t */\n+\tprotected void doCheckUniqueIn(IEObjectDescription description, Context context,\n+\t\t\tValidationMessageAcceptor acceptor) {\n+\t\tEObject object = description.getEObjectOrProxy();\n+\t\tPreconditions.checkArgument(!object.eIsProxy());\n+\n+\t\tEClass clusterType = getClusterType(description);\n+\t\tif (clusterType == null) {\n+\t\t\treturn;\n+\t\t}\n+\t\tISelectable validationScope = context.getValidationScope(description, clusterType);\n+\t\tif (validationScope.isEmpty()) {\n+\t\t\treturn;\n+\t\t}\n+\t\tboolean caseSensitive = context.isCaseSensitive(object, clusterType);\n+\t\tIterable<IEObjectDescription> sameNames = validationScope.getExportedObjects(clusterType, description.getName(),\n+\t\t\t\t!caseSensitive);\n+\t\tif (sameNames instanceof Collection<?>) {\n+\t\t\tif (((Collection<?>) sameNames).size() <= 1) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tfor (IEObjectDescription candidate : sameNames) {\n+\t\t\tEObject otherObject = candidate.getEObjectOrProxy();\n+\t\t\tif (object != otherObject && getAssociatedClusterType(candidate.getEClass()) == clusterType\n+\t\t\t\t\t&& !otherObject.eIsProxy() || !candidate.getEObjectURI().equals(description.getEObjectURI())) {\n+\t\t\t\tif (isDuplicate(description, candidate)) {\n+\t\t\t\t\tcreateDuplicateNameError(description, clusterType, acceptor);\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Called with two descriptions that have the same name. May be specialized to consider futher information from the", "originalCommit": "c5a39f9b1b386e85c5992eac9810f6cb3835a783", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTM3ODc5OQ==", "url": "https://github.com/eclipse/xtext-core/pull/1483#discussion_r425378799", "bodyText": "Typo: will be build -> will be built", "author": "miklossy", "createdAt": "2020-05-14T19:27:24Z", "path": "org.eclipse.xtext/src/org/eclipse/xtext/validation/NamesAreUniqueValidationHelper.java", "diffHunk": "@@ -104,43 +191,42 @@ protected void checkDescriptionForDuplicatedName(\n \t\t\t}\n \t\t}\n \t}\n-\t\n-\tprotected void createDuplicateNameError(IEObjectDescription description, EClass clusterType, ValidationMessageAcceptor acceptor) {\n+\n+\tprotected void createDuplicateNameError(IEObjectDescription description, EClass clusterType,\n+\t\t\tValidationMessageAcceptor acceptor) {\n \t\tEObject object = description.getEObjectOrProxy();\n \t\tEStructuralFeature feature = getNameFeature(object);\n-\t\tacceptor.acceptError(\n-\t\t\t\tgetDuplicateNameErrorMessage(description, clusterType, feature), \n-\t\t\t\tobject, \n-\t\t\t\tfeature,\n-\t\t\t\tValidationMessageAcceptor.INSIGNIFICANT_INDEX,\n-\t\t\t\tgetErrorCode());\n+\t\tacceptor.acceptError(getDuplicateNameErrorMessage(description, clusterType, feature), object, feature,\n+\t\t\t\tValidationMessageAcceptor.INSIGNIFICANT_INDEX, getErrorCode());\n \t}\n \n \t/**\n-\t * Returns <code>null</code>. Clients may override if they desire to attach an error code to the created errors. \n+\t * Returns <code>null</code>. Clients may override if they desire to attach an error code to the created errors.\n \t */\n \tprotected String getErrorCode() {\n \t\t// TODO use built-in codes to allow generic quickfixes\n \t\treturn null;\n \t}\n \n \t/**\n-\t * Build the error message for duplicated names. The default implementation will provider error messages \n-\t * of this form:\n+\t * Build the error message for duplicated names. The default implementation will provide error messages of this\n+\t * form:\n \t * <ul>\n \t * <li>Duplicate Entity 'Sample'</li>\n \t * <li>Duplicate Property 'Sample' in Entity 'EntityName'</li>\n \t * </ul>\n-\t * If the container information will be helpful to locate the error or to understand the error\n-\t * it will be used, otherwise only the simple format will be build. Clients may override different\n-\t * methods that influence the error message.\n+\t * If the container information will be helpful to locate the error or to understand the error it will be used,\n+\t * otherwise only the simple format will be build. Clients may override different methods that influence the error", "originalCommit": "c5a39f9b1b386e85c5992eac9810f6cb3835a783", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e6bd79bf3927a62ca1d5977d38ff2ed9e73d04d9", "url": "https://github.com/eclipse/xtext-core/commit/e6bd79bf3927a62ca1d5977d38ff2ed9e73d04d9", "message": "[#1466] Global unique name validator", "committedDate": "2020-05-15T14:55:29Z", "type": "commit"}, {"oid": "2a1e7d48c5aad8ac934f6bb68d499bbb74e1a4ec", "url": "https://github.com/eclipse/xtext-core/commit/2a1e7d48c5aad8ac934f6bb68d499bbb74e1a4ec", "message": "[#1466] Review feedback: Add space after for keyword, format new code", "committedDate": "2020-05-15T14:55:29Z", "type": "commit"}, {"oid": "c636f24e020264eeb0573dfe795787d7b20a967c", "url": "https://github.com/eclipse/xtext-core/commit/c636f24e020264eeb0573dfe795787d7b20a967c", "message": "[#1466] Review feedback: Fixed mixed spaces / tabs in file", "committedDate": "2020-05-15T14:55:29Z", "type": "commit"}, {"oid": "b6a1fc9c41c3357264ee5c7a2dcaec98b7b6269c", "url": "https://github.com/eclipse/xtext-core/commit/b6a1fc9c41c3357264ee5c7a2dcaec98b7b6269c", "message": "[#1466] Review feedback: Improved JavaDoc", "committedDate": "2020-05-15T14:55:29Z", "type": "commit"}, {"oid": "eb5b6bac0f3072aa8b59ab1d1de9cf7bf12b340a", "url": "https://github.com/eclipse/xtext-core/commit/eb5b6bac0f3072aa8b59ab1d1de9cf7bf12b340a", "message": "[#1466] Review feedback: Fixed typo in method name", "committedDate": "2020-05-15T14:55:29Z", "type": "commit"}, {"oid": "de84ac54150243213e509450be0c8ceaa4ec6f7d", "url": "https://github.com/eclipse/xtext-core/commit/de84ac54150243213e509450be0c8ceaa4ec6f7d", "message": "[1466] Review feedback: Nest code differently", "committedDate": "2020-05-15T14:55:30Z", "type": "commit"}, {"oid": "ea02d90edbc2bc346232a5e211641c2c3446ee0b", "url": "https://github.com/eclipse/xtext-core/commit/ea02d90edbc2bc346232a5e211641c2c3446ee0b", "message": "[#1466] Review feedback: Improved JavaDoc", "committedDate": "2020-05-15T14:55:30Z", "type": "commit"}, {"oid": "70150d26d4cdced018ad1f58b560f59ecf00790d", "url": "https://github.com/eclipse/xtext-core/commit/70150d26d4cdced018ad1f58b560f59ecf00790d", "message": "[#1466] Review feedback: Misplaced html in JavaDoc", "committedDate": "2020-05-15T14:55:30Z", "type": "commit"}, {"oid": "f85e5ca9b143bb26b6edf7ebaa041695908c905f", "url": "https://github.com/eclipse/xtext-core/commit/f85e5ca9b143bb26b6edf7ebaa041695908c905f", "message": "[#1466] Review feedback: Update copyrights", "committedDate": "2020-05-15T14:55:30Z", "type": "commit"}, {"oid": "59f0d98542cc0a548df0fd62fc82651df620ef50", "url": "https://github.com/eclipse/xtext-core/commit/59f0d98542cc0a548df0fd62fc82651df620ef50", "message": "[#1466] Review feedback: Fixed typos in Javadoc", "committedDate": "2020-05-15T14:55:30Z", "type": "commit"}, {"oid": "ee91cfe3e6d6bbf07d69cb89f029e532d33b1335", "url": "https://github.com/eclipse/xtext-core/commit/ee91cfe3e6d6bbf07d69cb89f029e532d33b1335", "message": "[#1466] Review feedback: Fixed Javadoc", "committedDate": "2020-05-15T14:55:30Z", "type": "commit"}, {"oid": "f94575ae318396ea9a89bf2edb9805a1b0d94236", "url": "https://github.com/eclipse/xtext-core/commit/f94575ae318396ea9a89bf2edb9805a1b0d94236", "message": "[#1466] Review feedback: JavaDoc and naming improvements", "committedDate": "2020-05-15T14:55:31Z", "type": "commit"}, {"oid": "df5502b461a2359161effe1a39cc3b2b5603e542", "url": "https://github.com/eclipse/xtext-core/commit/df5502b461a2359161effe1a39cc3b2b5603e542", "message": "[#1466] Review feedback: Mark new types as Beta", "committedDate": "2020-05-15T14:55:31Z", "type": "commit"}, {"oid": "1849b9c91b02db22e6333aced237a944ad9c5a3a", "url": "https://github.com/eclipse/xtext-core/commit/1849b9c91b02db22e6333aced237a944ad9c5a3a", "message": "[#1466] Oversight: Mark more new types as Beta", "committedDate": "2020-05-15T14:55:31Z", "type": "forcePushed"}, {"oid": "49a5ab8869c39f50d605a344217e30d6fe7eb5c2", "url": "https://github.com/eclipse/xtext-core/commit/49a5ab8869c39f50d605a344217e30d6fe7eb5c2", "message": "[#1466] Oversight: Mark more new types as Beta", "committedDate": "2020-05-15T15:06:49Z", "type": "commit"}, {"oid": "49a5ab8869c39f50d605a344217e30d6fe7eb5c2", "url": "https://github.com/eclipse/xtext-core/commit/49a5ab8869c39f50d605a344217e30d6fe7eb5c2", "message": "[#1466] Oversight: Mark more new types as Beta", "committedDate": "2020-05-15T15:06:49Z", "type": "forcePushed"}]}