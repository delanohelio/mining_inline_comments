{"pr_number": 3221, "pr_title": "Feature/more trs hookup", "pr_createdAt": "2020-02-10T16:47:58Z", "pr_url": "https://github.com/dockstore/dockstore/pull/3221", "timeline": [{"oid": "5cccbae6e0ec8ba193e058eda2066b9c07c3bf6f", "url": "https://github.com/dockstore/dockstore/commit/5cccbae6e0ec8ba193e058eda2066b9c07c3bf6f", "message": "Clear LGTM alerts", "committedDate": "2020-02-06T16:36:16Z", "type": "commit"}, {"oid": "573216f7b300b18c058f3af714b8634ad384f828", "url": "https://github.com/dockstore/dockstore/commit/573216f7b300b18c058f3af714b8634ad384f828", "message": "Unit tests functional\n\n* Let's see how much is broken for integration tests", "committedDate": "2020-02-07T20:11:20Z", "type": "commit"}, {"oid": "b035265e90f337e2d08fd0bb66606c59dee947e7", "url": "https://github.com/dockstore/dockstore/commit/b035265e90f337e2d08fd0bb66606c59dee947e7", "message": "Merge branch 'develop' into feature/more_trs_hookup", "committedDate": "2020-02-07T20:19:50Z", "type": "commit"}, {"oid": "2e4b63449f24bad2b7f279fec5d889e045c46d61", "url": "https://github.com/dockstore/dockstore/commit/2e4b63449f24bad2b7f279fec5d889e045c46d61", "message": "seems to satisfy validator", "committedDate": "2020-02-07T21:07:59Z", "type": "commit"}, {"oid": "32849990863a2acb72513a51aa874e77e6b14809", "url": "https://github.com/dockstore/dockstore/commit/32849990863a2acb72513a51aa874e77e6b14809", "message": "Fix bunch of integration tests", "committedDate": "2020-02-07T22:54:19Z", "type": "commit"}, {"oid": "7dadf066f977a8576aecea0a55c625b4a7f15c7b", "url": "https://github.com/dockstore/dockstore/commit/7dadf066f977a8576aecea0a55c625b4a7f15c7b", "message": "Hook up basic tests and mock-out fields to pass\n\n* should pass basic validation with all required fields populated (with\nempty data\n* added lots of TODOs for where things should be hooked up for\nverification, checksums for Docker images, checksums for file\ndescriptors, etc.", "committedDate": "2020-02-10T16:45:42Z", "type": "commit"}, {"oid": "6ddf94369d1fbb45b41e711854cd063e61ca91d1", "url": "https://github.com/dockstore/dockstore/commit/6ddf94369d1fbb45b41e711854cd063e61ca91d1", "message": "Make codacy somewhat happier", "committedDate": "2020-02-10T19:58:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzY4MzIyMA==", "url": "https://github.com/dockstore/dockstore/pull/3221#discussion_r377683220", "bodyText": "\ud83e\udd14", "author": "agduncan94", "createdAt": "2020-02-11T14:52:35Z", "path": "dockstore-webservice/src/main/java/io/openapi/api/impl/ToolsApiServiceImpl.java", "diffHunk": "@@ -1,5 +1,5 @@\n /*\n- *    Copyright 2020 OICR\n+ *    Copyright 2017 OICR", "originalCommit": "6ddf94369d1fbb45b41e711854cd063e61ca91d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2b1d9adbdd1265ae97d904e10fb9ed17db5d69d3", "url": "https://github.com/dockstore/dockstore/commit/2b1d9adbdd1265ae97d904e10fb9ed17db5d69d3", "message": "PR feedback", "committedDate": "2020-02-11T15:47:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ1NDQwMw==", "url": "https://github.com/dockstore/dockstore/pull/3221#discussion_r377454403", "bodyText": "I'm confused by this comment -- was expecting some sort of registration check the next line but it just returns unauthorized.", "author": "coverbeck", "createdAt": "2020-02-11T05:49:14Z", "path": "dockstore-webservice/src/main/java/io/openapi/api/impl/ToolsApiServiceImpl.java", "diffHunk": "@@ -67,58 +117,705 @@ public static void setConfig(DockstoreWebserviceConfiguration config) {\n         ToolsApiServiceImpl.config = config;\n     }\n \n-\n-    @SuppressWarnings(\"checkstyle:ParameterNumber\")\n-    @Override\n-    public Response toolsGet(String id, String alias, String toolClass, String registry, String organization, String name, String toolname,\n-        String description, String author, Boolean checker, String offset, Integer limit, SecurityContext securityContext,\n-        ContainerRequestContext value, Optional<User> user) throws NotFoundException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n     @Override\n     public Response toolsIdGet(String id, SecurityContext securityContext, ContainerRequestContext value, Optional<User> user) {\n-        throw new UnsupportedOperationException();\n+        ParsedRegistryID parsedID = new ParsedRegistryID(id);\n+        Entry<?, ?> entry = getEntry(parsedID, user);\n+        return buildToolResponse(entry, null, false);\n     }\n \n     @Override\n     public Response toolsIdVersionsGet(String id, SecurityContext securityContext, ContainerRequestContext value, Optional<User> user) {\n-        throw new UnsupportedOperationException();\n+        ParsedRegistryID parsedID = new ParsedRegistryID(id);\n+        Entry<?, ?> entry = getEntry(parsedID, user);\n+        return buildToolResponse(entry, null, true);\n+    }\n+\n+    private Response buildToolResponse(Entry<?, ?> container, String version, boolean returnJustVersions) {\n+        Response response;\n+        if (container == null) {\n+            response = Response.status(Status.NOT_FOUND).build();\n+        } else if (!container.getIsPublished()) {\n+            // check whether this is registered", "originalCommit": "6ddf94369d1fbb45b41e711854cd063e61ca91d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ1NTQxMA==", "url": "https://github.com/dockstore/dockstore/pull/3221#discussion_r377455410", "bodyText": "Is it possible that more than one version can have the same name? If not, I feel it would a little simpler if if you just did a find on the version; it would be (insignificantly, probably) faster on average, and you wouldn't have to do the get(0) on line 150. OTOH, you'd have to deal with Optional.", "author": "coverbeck", "createdAt": "2020-02-11T05:55:07Z", "path": "dockstore-webservice/src/main/java/io/openapi/api/impl/ToolsApiServiceImpl.java", "diffHunk": "@@ -67,58 +117,705 @@ public static void setConfig(DockstoreWebserviceConfiguration config) {\n         ToolsApiServiceImpl.config = config;\n     }\n \n-\n-    @SuppressWarnings(\"checkstyle:ParameterNumber\")\n-    @Override\n-    public Response toolsGet(String id, String alias, String toolClass, String registry, String organization, String name, String toolname,\n-        String description, String author, Boolean checker, String offset, Integer limit, SecurityContext securityContext,\n-        ContainerRequestContext value, Optional<User> user) throws NotFoundException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n     @Override\n     public Response toolsIdGet(String id, SecurityContext securityContext, ContainerRequestContext value, Optional<User> user) {\n-        throw new UnsupportedOperationException();\n+        ParsedRegistryID parsedID = new ParsedRegistryID(id);\n+        Entry<?, ?> entry = getEntry(parsedID, user);\n+        return buildToolResponse(entry, null, false);\n     }\n \n     @Override\n     public Response toolsIdVersionsGet(String id, SecurityContext securityContext, ContainerRequestContext value, Optional<User> user) {\n-        throw new UnsupportedOperationException();\n+        ParsedRegistryID parsedID = new ParsedRegistryID(id);\n+        Entry<?, ?> entry = getEntry(parsedID, user);\n+        return buildToolResponse(entry, null, true);\n+    }\n+\n+    private Response buildToolResponse(Entry<?, ?> container, String version, boolean returnJustVersions) {\n+        Response response;\n+        if (container == null) {\n+            response = Response.status(Status.NOT_FOUND).build();\n+        } else if (!container.getIsPublished()) {\n+            // check whether this is registered\n+            response = Response.status(Status.UNAUTHORIZED).build();\n+        } else {\n+            io.openapi.model.Tool tool = ToolsImplCommon.convertEntryToTool(container, config);\n+            assert (tool != null);\n+            // filter out other versions if we're narrowing to a specific version\n+            if (version != null) {\n+                tool.getVersions().removeIf(v -> !v.getName().equals(version));", "originalCommit": "6ddf94369d1fbb45b41e711854cd063e61ca91d1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzg1ODU0Mg==", "url": "https://github.com/dockstore/dockstore/pull/3221#discussion_r377858542", "bodyText": "Added link in the optimization issue.\nIn general I agree, but I think there might be better bang for the buck for optimization.", "author": "denis-yuen", "createdAt": "2020-02-11T19:44:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ1NTQxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQ1NTc5Mw==", "url": "https://github.com/dockstore/dockstore/pull/3221#discussion_r377455793", "bodyText": "neither...nor", "author": "coverbeck", "createdAt": "2020-02-11T05:57:24Z", "path": "dockstore-webservice/src/main/java/io/openapi/api/impl/ToolsApiServiceImpl.java", "diffHunk": "@@ -67,58 +117,705 @@ public static void setConfig(DockstoreWebserviceConfiguration config) {\n         ToolsApiServiceImpl.config = config;\n     }\n \n-\n-    @SuppressWarnings(\"checkstyle:ParameterNumber\")\n-    @Override\n-    public Response toolsGet(String id, String alias, String toolClass, String registry, String organization, String name, String toolname,\n-        String description, String author, Boolean checker, String offset, Integer limit, SecurityContext securityContext,\n-        ContainerRequestContext value, Optional<User> user) throws NotFoundException {\n-        throw new UnsupportedOperationException();\n-    }\n-\n     @Override\n     public Response toolsIdGet(String id, SecurityContext securityContext, ContainerRequestContext value, Optional<User> user) {\n-        throw new UnsupportedOperationException();\n+        ParsedRegistryID parsedID = new ParsedRegistryID(id);\n+        Entry<?, ?> entry = getEntry(parsedID, user);\n+        return buildToolResponse(entry, null, false);\n     }\n \n     @Override\n     public Response toolsIdVersionsGet(String id, SecurityContext securityContext, ContainerRequestContext value, Optional<User> user) {\n-        throw new UnsupportedOperationException();\n+        ParsedRegistryID parsedID = new ParsedRegistryID(id);\n+        Entry<?, ?> entry = getEntry(parsedID, user);\n+        return buildToolResponse(entry, null, true);\n+    }\n+\n+    private Response buildToolResponse(Entry<?, ?> container, String version, boolean returnJustVersions) {\n+        Response response;\n+        if (container == null) {\n+            response = Response.status(Status.NOT_FOUND).build();\n+        } else if (!container.getIsPublished()) {\n+            // check whether this is registered\n+            response = Response.status(Status.UNAUTHORIZED).build();\n+        } else {\n+            io.openapi.model.Tool tool = ToolsImplCommon.convertEntryToTool(container, config);\n+            assert (tool != null);\n+            // filter out other versions if we're narrowing to a specific version\n+            if (version != null) {\n+                tool.getVersions().removeIf(v -> !v.getName().equals(version));\n+                if (tool.getVersions().size() != 1) {\n+                    response = Response.status(Status.NOT_FOUND).build();\n+                } else {\n+                    response = Response.ok(tool.getVersions().get(0)).build();\n+                }\n+            } else {\n+                if (returnJustVersions) {\n+                    response = Response.ok(tool.getVersions()).build();\n+                } else {\n+                    response = Response.ok(tool).build();\n+                }\n+            }\n+        }\n+        return response;\n     }\n \n     @Override\n     public Response toolsIdVersionsVersionIdGet(String id, String versionId, SecurityContext securityContext, ContainerRequestContext value,\n         Optional<User> user) {\n-        throw new UnsupportedOperationException();\n+        ParsedRegistryID parsedID = new ParsedRegistryID(id);\n+        String newVersionId;\n+        try {\n+            newVersionId = URLDecoder.decode(versionId, StandardCharsets.UTF_8.displayName());\n+        } catch (UnsupportedEncodingException e) {\n+            throw new RuntimeException(e);\n+        }\n+        Entry<?, ?> entry = getEntry(parsedID, user);\n+        return buildToolResponse(entry, newVersionId, false);\n+    }\n+\n+    public Entry<?, ?> getEntry(ParsedRegistryID parsedID, Optional<User> user) {\n+        Entry<?, ?> entry;\n+        String entryPath = parsedID.getPath();\n+        String entryName = parsedID.getToolName().isEmpty() ? null : parsedID.getToolName();\n+        if (entryName != null) {\n+            entryPath += \"/\" + parsedID.getToolName();\n+        }\n+        if (parsedID.toolType() == ParsedRegistryID.ToolType.TOOL) {\n+            entry = toolDAO.findByPath(entryPath, user.isEmpty());\n+        } else if (parsedID.toolType() == ParsedRegistryID.ToolType.WORKFLOW) {\n+            entry = workflowDAO.findByPath(entryPath, user.isEmpty(), BioWorkflow.class).orElse(null);\n+        } else if (parsedID.toolType() == ParsedRegistryID.ToolType.SERVICE) {\n+            entry = workflowDAO.findByPath(entryPath, user.isEmpty(), Service.class).orElse(null);\n+        } else {\n+            throw new UnsupportedOperationException(\"Tool type that should not be present found:\" + parsedID.toolType());\n+        }\n+        if (entry != null && entry.getIsPublished()) {\n+            return entry;\n+        }\n+        if (entry != null && user.isPresent()) {\n+            checkUser(user.get(), entry);\n+            return entry;\n+        }\n+        return null;\n     }\n \n     @Override\n     public Response toolsIdVersionsVersionIdTypeDescriptorGet(String type, String id, String versionId, SecurityContext securityContext,\n         ContainerRequestContext value, Optional<User> user) {\n-        throw new UnsupportedOperationException();\n+        final Optional<DescriptorLanguage.FileType> fileType = DescriptorLanguage.getFileType(type);\n+        if (fileType.isEmpty()) {\n+            return Response.status(Status.NOT_FOUND).build();\n+        }\n+        return getFileByToolVersionID(id, versionId, fileType.get(), null,\n+            contextContainsPlainText(value) || StringUtils.containsIgnoreCase(type, \"plain\"), user);\n     }\n \n     @Override\n     public Response toolsIdVersionsVersionIdTypeDescriptorRelativePathGet(String type, String id, String versionId, String relativePath,\n         SecurityContext securityContext, ContainerRequestContext value, Optional<User> user) {\n-        throw new UnsupportedOperationException();\n+        if (type == null) {\n+            return Response.status(Status.BAD_REQUEST).build();\n+        }\n+        final Optional<DescriptorLanguage.FileType> fileType = DescriptorLanguage.getFileType(type);\n+        if (fileType.isEmpty()) {\n+            return Response.status(Status.NOT_FOUND).build();\n+        }\n+        return getFileByToolVersionID(id, versionId, fileType.get(), relativePath,\n+            contextContainsPlainText(value) || StringUtils.containsIgnoreCase(type, \"plain\"), user);\n+    }\n+\n+    private boolean contextContainsPlainText(ContainerRequestContext value) {\n+        return value.getAcceptableMediaTypes().contains(MediaType.TEXT_PLAIN_TYPE);\n     }\n \n     @Override\n     public Response toolsIdVersionsVersionIdTypeTestsGet(String type, String id, String versionId, SecurityContext securityContext,\n         ContainerRequestContext value, Optional<User> user) {\n-        throw new UnsupportedOperationException();\n+        if (type == null) {\n+            return Response.status(Status.BAD_REQUEST).build();\n+        }\n+        final Optional<DescriptorLanguage.FileType> fileType = DescriptorLanguage.getFileType(type);\n+        if (fileType.isEmpty()) {\n+            return Response.status(Status.NOT_FOUND).build();\n+        }\n+\n+        // The getFileType version never returns *TEST_JSON filetypes.  Linking CWL_TEST_JSON with DOCKSTORE_CWL and etc until solved.\n+        boolean plainTextResponse = contextContainsPlainText(value) || type.toLowerCase().contains(\"plain\");\n+        switch (fileType.get()) {\n+        case CWL_TEST_JSON:\n+        case DOCKSTORE_CWL:\n+            return getFileByToolVersionID(id, versionId, CWL_TEST_JSON, null, plainTextResponse, user);\n+        case WDL_TEST_JSON:\n+        case DOCKSTORE_WDL:\n+            return getFileByToolVersionID(id, versionId, WDL_TEST_JSON, null, plainTextResponse, user);\n+        case NEXTFLOW:\n+        case NEXTFLOW_CONFIG:\n+        case NEXTFLOW_TEST_PARAMS:\n+            return getFileByToolVersionID(id, versionId, NEXTFLOW_TEST_PARAMS, null, plainTextResponse, user);\n+        default:\n+            return Response.status(Status.BAD_REQUEST).build();\n+        }\n     }\n \n     @Override\n     public Response toolsIdVersionsVersionIdContainerfileGet(String id, String versionId, SecurityContext securityContext,\n         ContainerRequestContext value, Optional<User> user) {\n-        throw new UnsupportedOperationException();\n+        // matching behaviour of the descriptor endpoint\n+        return getFileByToolVersionID(id, versionId, DOCKERFILE, null, contextContainsPlainText(value), user);\n+    }\n+\n+    @SuppressWarnings({\"checkstyle:ParameterNumber\", \"checkstyle:MethodLength\"})\n+    @Override\n+    public Response toolsGet(String id, String alias, String toolClass, String registry, String organization, String name, String toolname,\n+        String description, String author, Boolean checker, String offset, Integer limit, SecurityContext securityContext,\n+        ContainerRequestContext value, Optional<User> user) {\n+\n+        final Integer hashcode = new HashCodeBuilder().append(id).append(alias).append(registry).append(organization).append(name)\n+            .append(toolname).append(description).append(author).append(checker).append(offset).append(limit)\n+            .append(user.orElseGet(User::new).getId()).build();\n+        final Optional<Response.ResponseBuilder> trsResponses = trsListener.getTrsResponse(hashcode);\n+        if (trsResponses.isPresent()) {\n+            return trsResponses.get().build();\n+        }\n+\n+        final List<Entry<?, ?>> all = new ArrayList<>();\n+\n+        // short circuit id and alias filters, these are a bit weird because they have a max of one result\n+        if (id != null) {\n+            ParsedRegistryID parsedID = new ParsedRegistryID(id);\n+            Entry<?, ?> entry = getEntry(parsedID, user);\n+            all.add(entry);\n+        } else if (alias != null) {\n+            all.add(toolDAO.getGenericEntryByAlias(alias));\n+        } else {\n+            all.addAll(toolDAO.findAllPublished());\n+            all.addAll(workflowDAO.findAllPublished());\n+            all.sort(Comparator.comparing(Entry::getGitUrl));\n+        }\n+\n+        List<io.openapi.model.Tool> results = new ArrayList<>();\n+        for (Entry<?, ?> c : all) {\n+            // filters just for tools\n+            if (c instanceof Tool) {\n+                Tool tool = (Tool)c;\n+                // check each criteria. This sucks. Can we do this better with reflection? Or should we pre-convert?\n+                if (registry != null && tool.getRegistry() != null && !tool.getRegistry().contains(registry)) {\n+                    continue;\n+                }\n+                if (organization != null && tool.getNamespace() != null && !tool.getNamespace().contains(organization)) {\n+                    continue;\n+                }\n+                if (name != null && tool.getName() != null && !tool.getName().contains(name)) {\n+                    continue;\n+                }\n+                if (toolname != null && tool.getToolname() != null && !tool.getToolname().contains(toolname)) {\n+                    continue;\n+                }\n+                if (checker != null && checker) {\n+                    // tools are never checker workflows\n+                    continue;\n+                }\n+            }\n+            // filters just for tools\n+            if (c instanceof Workflow) {\n+                Workflow workflow = (Workflow)c;\n+                // check each criteria. This sucks. Can we do this better with reflection? Or should we pre-convert?\n+                if (registry != null && workflow.getSourceControl() != null && !workflow.getSourceControl().toString().contains(registry)) {\n+                    continue;\n+                }\n+                if (organization != null && workflow.getOrganization() != null && !workflow.getOrganization().contains(organization)) {\n+                    continue;\n+                }\n+                if (name != null && workflow.getRepository() != null && !workflow.getRepository().contains(name)) {\n+                    continue;\n+                }\n+                if (toolname != null && workflow.getWorkflowName() != null && !workflow.getWorkflowName().contains(toolname)) {\n+                    continue;\n+                }\n+                if (checker != null && workflow.isIsChecker() != checker) {\n+                    continue;\n+                }\n+            }\n+            // common filters between tools and workflows\n+            if (description != null && c.getDescription() != null && !c.getDescription().contains(description)) {\n+                continue;\n+            }\n+            if (author != null && c.getAuthor() != null && !c.getAuthor().contains(author)) {\n+                continue;\n+            }\n+            // if passing, for each container that matches the criteria, convert to standardised format and return\n+            io.openapi.model.Tool tool = ToolsImplCommon.convertEntryToTool(c, config);\n+            if (tool != null) {\n+                results.add(tool);\n+            }\n+        }\n+\n+        final int actualLimit = MoreObjects.firstNonNull(limit, DEFAULT_PAGE_SIZE);\n+\n+        List<List<io.openapi.model.Tool>> pagedResults = Lists.partition(results, actualLimit);\n+        int offsetInteger = 0;\n+        if (offset != null) {\n+            offsetInteger = Integer.parseInt(offset);\n+        }\n+        if (offsetInteger >= pagedResults.size()) {\n+            results = new ArrayList<>();\n+        } else {\n+            results = pagedResults.get(offsetInteger);\n+        }\n+        final Response.ResponseBuilder responseBuilder = Response.ok(results);\n+        responseBuilder.header(\"current_offset\", offset);\n+        responseBuilder.header(\"current_limit\", actualLimit);\n+        try {\n+            int port = config.getExternalConfig().getPort() == null ? -1 : Integer.parseInt(config.getExternalConfig().getPort());\n+            responseBuilder.header(\"self_link\",\n+                new URI(config.getExternalConfig().getScheme(), null, config.getExternalConfig().getHostname(), port,\n+                    ObjectUtils.firstNonNull(config.getExternalConfig().getBasePath(), \"\") + value.getUriInfo().getRequestUri().getPath(),\n+                    value.getUriInfo().getRequestUri().getQuery(), null).normalize().toURL().toString());\n+            // construct links to other pages\n+            List<String> filters = new ArrayList<>();\n+            handleParameter(id, \"id\", filters);\n+            handleParameter(organization, \"organization\", filters);\n+            handleParameter(name, \"name\", filters);\n+            handleParameter(toolname, \"toolname\", filters);\n+            handleParameter(description, \"description\", filters);\n+            handleParameter(author, \"author\", filters);\n+            handleParameter(registry, \"registry\", filters);\n+            handleParameter(String.valueOf(actualLimit), \"limit\", filters);\n+\n+            if (offsetInteger + 1 < pagedResults.size()) {\n+                URI nextPageURI = new URI(config.getExternalConfig().getScheme(), null, config.getExternalConfig().getHostname(), port,\n+                    ObjectUtils.firstNonNull(config.getExternalConfig().getBasePath(), \"\") + DockstoreWebserviceApplication.GA4GH_API_PATH_V2_BETA\n+                        + \"/tools\", Joiner.on('&').join(filters) + \"&offset=\" + (offsetInteger + 1), null).normalize();\n+                responseBuilder.header(\"next_page\", nextPageURI.toURL().toString());\n+            }\n+            URI lastPageURI = new URI(config.getExternalConfig().getScheme(), null, config.getExternalConfig().getHostname(), port,\n+                ObjectUtils.firstNonNull(config.getExternalConfig().getBasePath(), \"\") + DockstoreWebserviceApplication.GA4GH_API_PATH_V2_BETA\n+                    + \"/tools\", Joiner.on('&').join(filters) + \"&offset=\" + (pagedResults.size() - 1), null).normalize();\n+            responseBuilder.header(\"last_page\", lastPageURI.toURL().toString());\n+\n+        } catch (URISyntaxException | MalformedURLException e) {\n+            throw new CustomWebApplicationException(\"Could not construct page links\", HttpStatus.SC_BAD_REQUEST);\n+        }\n+        trsListener.loadTRSResponse(hashcode, responseBuilder);\n+        return responseBuilder.build();\n+    }\n+\n+    private void handleParameter(String parameter, String queryName, List<String> filters) {\n+        if (parameter != null) {\n+            filters.add(queryName + \"=\" + parameter);\n+        }\n+    }\n+\n+    /**\n+     * @param gitUrl       The git formatted url for the repo\n+     * @param reference    the git tag or branch\n+     * @param githubPrefix the prefix for the git formatted url to strip out\n+     * @param builtPrefix  the prefix to use to start the extracted prefix\n+     * @return the prefix to access these files\n+     */\n+    private static String extractHTTPPrefix(String gitUrl, String reference, String githubPrefix, String builtPrefix) {\n+        StringBuilder urlBuilder = new StringBuilder();\n+        urlBuilder.append(builtPrefix);\n+        final String substring = gitUrl.substring(githubPrefix.length(), gitUrl.lastIndexOf(\".git\"));\n+        urlBuilder.append(substring).append(builtPrefix.contains(\"bitbucket.org\") ? \"/raw/\" : '/').append(reference);\n+        return urlBuilder.toString();\n+    }\n+\n+    /**\n+     * @param registryId   registry id\n+     * @param versionIdParam    git reference\n+     * @param type         type of file\n+     * @param relativePath if null, return the primary descriptor, if not null, return a specific file\n+     * @param unwrap       unwrap the file and present the descriptor sans wrapper model\n+     * @return a specific file wrapped in a response\n+     */\n+    private Response getFileByToolVersionID(String registryId, String versionIdParam, DescriptorLanguage.FileType type, String relativePath,\n+        boolean unwrap, Optional<User> user) {\n+\n+        // if a version is provided, get that version, otherwise return the newest\n+        ParsedRegistryID parsedID = new ParsedRegistryID(registryId);\n+        String versionId;\n+        try {\n+            versionId = URLDecoder.decode(versionIdParam, StandardCharsets.UTF_8.displayName());\n+        } catch (UnsupportedEncodingException e) {\n+            throw new RuntimeException(e);\n+        }\n+        Entry<?, ?> entry = getEntry(parsedID, user);\n+\n+        // check whether this is registered\n+        if (entry == null) {\n+            Response.StatusType status = getExtendedStatus(Status.NOT_FOUND, \"incorrect id\");\n+            return Response.status(status).build();\n+        }\n+\n+        boolean showHiddenVersions = false;\n+        if (user.isPresent() && !AuthenticatedResourceInterface\n+                .userCannotRead(user.get(), entry)) {\n+            showHiddenVersions = true;\n+        }\n+\n+        final io.openapi.model.Tool convertedTool = ToolsImplCommon.convertEntryToTool(entry, config, showHiddenVersions);\n+\n+        String finalVersionId = versionId;\n+        if (convertedTool == null || convertedTool.getVersions() == null) {\n+            return Response.status(Status.NOT_FOUND).build();\n+        }\n+        final Optional<ToolVersion> convertedToolVersion = convertedTool.getVersions().stream()\n+            .filter(toolVersion -> toolVersion.getName().equalsIgnoreCase(finalVersionId)).findFirst();\n+        Optional<? extends Version<?>> entryVersion;\n+        if (entry instanceof Tool) {\n+            Tool toolEntry = (Tool)entry;\n+            entryVersion = toolEntry.getWorkflowVersions().stream().filter(toolVersion -> toolVersion.getName().equalsIgnoreCase(finalVersionId))\n+                .findFirst();\n+        } else {\n+            Workflow workflowEntry = (Workflow)entry;\n+            entryVersion = workflowEntry.getWorkflowVersions().stream()\n+                .filter(toolVersion -> toolVersion.getName().equalsIgnoreCase(finalVersionId)).findFirst();\n+        }\n+\n+        if (entryVersion.isEmpty()) {\n+            Response.StatusType status = getExtendedStatus(Status.NOT_FOUND, \"version not found\");\n+            return Response.status(status).build();\n+        }\n+\n+        String urlBuilt;\n+        String gitUrl = entry.getGitUrl();\n+        if (gitUrl.startsWith(GITHUB_PREFIX)) {\n+            urlBuilt = extractHTTPPrefix(gitUrl, entryVersion.get().getReference(), GITHUB_PREFIX, \"https://raw.githubusercontent.com/\");\n+        } else if (gitUrl.startsWith(BITBUCKET_PREFIX)) {\n+            urlBuilt = extractHTTPPrefix(gitUrl, entryVersion.get().getReference(), BITBUCKET_PREFIX, \"https://bitbucket.org/\");\n+        } else {\n+            LOG.error(\"Found a git url neither from BitBucket or GitHub \" + gitUrl);", "originalCommit": "6ddf94369d1fbb45b41e711854cd063e61ca91d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ac7a71d3f923d516556327d8ef8628d055727c95", "url": "https://github.com/dockstore/dockstore/commit/ac7a71d3f923d516556327d8ef8628d055727c95", "message": "More PR feedback", "committedDate": "2020-02-11T20:27:51Z", "type": "commit"}]}