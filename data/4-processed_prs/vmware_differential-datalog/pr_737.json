{"pr_number": 737, "pr_title": "D3log realization sinks api", "pr_createdAt": "2020-08-12T20:19:38Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/737", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTAzMjA4NA==", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r471032084", "bodyText": "why not implement Default to keep clippy happy?", "author": "ryzhyk", "createdAt": "2020-08-15T20:42:37Z", "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -316,20 +196,36 @@ where\n     >,\n     /// The transaction multiplexer as input to the DDLogServer\n     _txnmux: TxnMux<Update<DDValue>, String>,\n-    /// All sink accumulators of this realization to connect new nodes to\n-    _accumulators: HashMap<\n+    /// All sinks of this realization with their subscription\n+    _sinks: HashMap<\n         BTreeSet<RelId>,\n-        SharedObserver<DistributingAccumulator<Update<DDValue>, DDValue, String>>,\n+        (\n+            SharedObserver<DistributingAccumulator<Update<DDValue>, DDValue, String>>,\n+            UpdatesObservable<Update<DDValue>, String>,\n+            HashMap<Sink, (SinkRealization<P::Convert>, usize)>,\n+        ),\n     >,\n-    /// All sinks of this realization with their subscription\n-    _sinks: HashMap<BTreeSet<RelId>, Vec<(SinkRealization<P::Convert>, usize)>>,\n }\n \n impl<P> Realization<P>\n where\n     P: Send + DDlog + 'static,\n     P::Convert: Send + DDlogConvert,\n {\n+    /// Instantiates a new, default Realization.\n+    #[allow(clippy::new_without_default)]", "originalCommit": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEyMDc0MQ==", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r473120741", "bodyText": "I think this was a mental TODO that I forgot about... but you're totally right, will fix!", "author": "krs85", "createdAt": "2020-08-19T15:33:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTAzMjA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTAzMjQzNQ==", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r471032435", "bodyText": "A more accurate error message would indicate that the sink was not found and would also print the sink in question.", "author": "ryzhyk", "createdAt": "2020-08-15T20:47:23Z", "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -405,13 +301,218 @@ where\n         }\n     }\n \n+    /// Remove file sink or tcp sender from an existing Realization.\n+    /// Locate the entry in _sinks whose map contains the sink.\n+    /// Remove the entry from the sink map.\n+    /// Unsubscribe the accumulator from the sink.\n+    /// Return an error if unable to find a sink map containing the sink.\n+    pub fn remove_sink(&mut self, sink: &Sink) -> Result<(), String> {\n+        for (accumulator, _, sink_map) in self._sinks.values_mut() {\n+            if sink_map.contains_key(sink) {\n+                let (_, subscription) = sink_map.remove(sink).unwrap();\n+                let _ = accumulator.unsubscribe(&subscription);\n+                return Ok(());\n+            }\n+        }\n+        Err(\"failed to remove sink from realization\".to_string())", "originalCommit": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEyMTQ3Ng==", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r473121476", "bodyText": "Makes sense, will fix.", "author": "krs85", "createdAt": "2020-08-19T15:34:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTAzMjQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE0Mjg2Mg==", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r471142862", "bodyText": "file sink -> TCP sink", "author": "ryzhyk", "createdAt": "2020-08-16T18:20:47Z", "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -405,13 +301,218 @@ where\n         }\n     }\n \n+    /// Remove file sink or tcp sender from an existing Realization.\n+    /// Locate the entry in _sinks whose map contains the sink.\n+    /// Remove the entry from the sink map.\n+    /// Unsubscribe the accumulator from the sink.\n+    /// Return an error if unable to find a sink map containing the sink.\n+    pub fn remove_sink(&mut self, sink: &Sink) -> Result<(), String> {\n+        for (accumulator, _, sink_map) in self._sinks.values_mut() {\n+            if sink_map.contains_key(sink) {\n+                let (_, subscription) = sink_map.remove(sink).unwrap();\n+                let _ = accumulator.unsubscribe(&subscription);\n+                return Ok(());\n+            }\n+        }\n+        Err(\"failed to remove sink from realization\".to_string())\n+    }\n+\n+    /// Add file sink or tcp sender to an existing Realization.\n+    /// Creates and adds accumulator for this rel_ids to the Realization if needed.\n+    /// Subscribes the accumulator to the sink and adds the sink to\n+    /// the accumulator's map.\n+    pub fn add_sink(\n+        &mut self,\n+        sink: &Sink,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        // Add the accumulator to the realization if needed.\n+        self.add_sink_accumulator(rel_ids.clone(), server)?;\n+        let (accumulator, _, sink_map) = self._sinks.get_mut(&rel_ids).unwrap();\n+\n+        match sink {\n+            Sink::File(path) => {\n+                let file = File::create(path)\n+                    .map_err(|e| format!(\"failed to create file {}:, {}\", path.display(), e))?;\n+                let file_sink = Arc::new(Mutex::new(FileSink::<P::Convert>::new(file)));\n+\n+                // Subscribe the accumulator to this sink.\n+                let subscription = accumulator\n+                    .lock()\n+                    .unwrap()\n+                    .subscribe(Box::new(file_sink.clone()))\n+                    .map_err(|_| \"failed to subscribe file sink to accumulator\".to_string())?;\n+\n+                // Add sink to sink map for this accumulator.\n+                let _ = sink_map.insert(\n+                    sink.clone(),\n+                    (SinkRealization::File(file_sink), subscription),\n+                );\n+            }\n+            Sink::TcpSender(addr) => {\n+                match addr {\n+                    Addr::Ip(address) => {\n+                        let tcp_sender = TcpSender::new(*address)\n+                            .map_err(|e| format!(\"failed to create TcpSender socket: {}\", e))?;\n+                        let sink = Arc::new(Mutex::new(tcp_sender));\n+\n+                        // Subscribe the accumulator to this sink.\n+                        let subscription = accumulator\n+                            .lock()\n+                            .unwrap()\n+                            .subscribe(Box::new(sink.clone()))\n+                            .map_err(|_| \"failed to subscribe file sink to accumulator\")?;", "originalCommit": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzEyOTE0MQ==", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r473129141", "bodyText": "Makes sense, will fix.", "author": "krs85", "createdAt": "2020-08-19T15:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE0Mjg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE0Mzk0Mw==", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r471143943", "bodyText": "accum is the last reference to this accumulator, right? So shouldn't it clear itself internal state as it goes out of scope?", "author": "ryzhyk", "createdAt": "2020-08-16T18:32:10Z", "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -405,13 +301,218 @@ where\n         }\n     }\n \n+    /// Remove file sink or tcp sender from an existing Realization.\n+    /// Locate the entry in _sinks whose map contains the sink.\n+    /// Remove the entry from the sink map.\n+    /// Unsubscribe the accumulator from the sink.\n+    /// Return an error if unable to find a sink map containing the sink.\n+    pub fn remove_sink(&mut self, sink: &Sink) -> Result<(), String> {\n+        for (accumulator, _, sink_map) in self._sinks.values_mut() {\n+            if sink_map.contains_key(sink) {\n+                let (_, subscription) = sink_map.remove(sink).unwrap();\n+                let _ = accumulator.unsubscribe(&subscription);\n+                return Ok(());\n+            }\n+        }\n+        Err(\"failed to remove sink from realization\".to_string())\n+    }\n+\n+    /// Add file sink or tcp sender to an existing Realization.\n+    /// Creates and adds accumulator for this rel_ids to the Realization if needed.\n+    /// Subscribes the accumulator to the sink and adds the sink to\n+    /// the accumulator's map.\n+    pub fn add_sink(\n+        &mut self,\n+        sink: &Sink,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        // Add the accumulator to the realization if needed.\n+        self.add_sink_accumulator(rel_ids.clone(), server)?;\n+        let (accumulator, _, sink_map) = self._sinks.get_mut(&rel_ids).unwrap();\n+\n+        match sink {\n+            Sink::File(path) => {\n+                let file = File::create(path)\n+                    .map_err(|e| format!(\"failed to create file {}:, {}\", path.display(), e))?;\n+                let file_sink = Arc::new(Mutex::new(FileSink::<P::Convert>::new(file)));\n+\n+                // Subscribe the accumulator to this sink.\n+                let subscription = accumulator\n+                    .lock()\n+                    .unwrap()\n+                    .subscribe(Box::new(file_sink.clone()))\n+                    .map_err(|_| \"failed to subscribe file sink to accumulator\".to_string())?;\n+\n+                // Add sink to sink map for this accumulator.\n+                let _ = sink_map.insert(\n+                    sink.clone(),\n+                    (SinkRealization::File(file_sink), subscription),\n+                );\n+            }\n+            Sink::TcpSender(addr) => {\n+                match addr {\n+                    Addr::Ip(address) => {\n+                        let tcp_sender = TcpSender::new(*address)\n+                            .map_err(|e| format!(\"failed to create TcpSender socket: {}\", e))?;\n+                        let sink = Arc::new(Mutex::new(tcp_sender));\n+\n+                        // Subscribe the accumulator to this sink.\n+                        let subscription = accumulator\n+                            .lock()\n+                            .unwrap()\n+                            .subscribe(Box::new(sink.clone()))\n+                            .map_err(|_| \"failed to subscribe file sink to accumulator\")?;\n+\n+                        // Add sink to sink map for this accumulator.\n+                        let _ = sink_map.insert(\n+                            Sink::TcpSender(*addr),\n+                            (SinkRealization::Node(sink), subscription),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Remove the sink accumulator from the realization.\n+    /// Remove accumulator's entry (keyed by rel_ids) from _sinks.\n+    /// Disconnect accumulator from the server:\n+    /// - Unsubscribe the stream from the accumulator.\n+    /// - Remove the stream from the server.\n+    /// Clear the accumulator.\n+    pub fn remove_sink_accumulator(\n+        &mut self,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        if let Some(entry) = self._sinks.remove(&rel_ids) {\n+            let (accumulator, mut stream, sink_map) = entry;\n+            if sink_map.is_empty() {\n+                // Disconnect accumulator from server.\n+                // First, unsubscribe the stream from the accumulator.\n+                let _ = stream.unsubscribe(&());\n+                // Next, remove the stream from the server.\n+                server.remove_stream(stream);\n+\n+                let mut accum = accumulator.lock().unwrap();\n+                // Clear the accumulator.\n+                if accum.clear().is_ok() {", "originalCommit": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE0NDI3MA==", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r471144270", "bodyText": "Why is this a transaction-in-progress error as opposed to just accumulator still having sinks attached to it?", "author": "ryzhyk", "createdAt": "2020-08-16T18:35:30Z", "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -405,13 +301,218 @@ where\n         }\n     }\n \n+    /// Remove file sink or tcp sender from an existing Realization.\n+    /// Locate the entry in _sinks whose map contains the sink.\n+    /// Remove the entry from the sink map.\n+    /// Unsubscribe the accumulator from the sink.\n+    /// Return an error if unable to find a sink map containing the sink.\n+    pub fn remove_sink(&mut self, sink: &Sink) -> Result<(), String> {\n+        for (accumulator, _, sink_map) in self._sinks.values_mut() {\n+            if sink_map.contains_key(sink) {\n+                let (_, subscription) = sink_map.remove(sink).unwrap();\n+                let _ = accumulator.unsubscribe(&subscription);\n+                return Ok(());\n+            }\n+        }\n+        Err(\"failed to remove sink from realization\".to_string())\n+    }\n+\n+    /// Add file sink or tcp sender to an existing Realization.\n+    /// Creates and adds accumulator for this rel_ids to the Realization if needed.\n+    /// Subscribes the accumulator to the sink and adds the sink to\n+    /// the accumulator's map.\n+    pub fn add_sink(\n+        &mut self,\n+        sink: &Sink,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        // Add the accumulator to the realization if needed.\n+        self.add_sink_accumulator(rel_ids.clone(), server)?;\n+        let (accumulator, _, sink_map) = self._sinks.get_mut(&rel_ids).unwrap();\n+\n+        match sink {\n+            Sink::File(path) => {\n+                let file = File::create(path)\n+                    .map_err(|e| format!(\"failed to create file {}:, {}\", path.display(), e))?;\n+                let file_sink = Arc::new(Mutex::new(FileSink::<P::Convert>::new(file)));\n+\n+                // Subscribe the accumulator to this sink.\n+                let subscription = accumulator\n+                    .lock()\n+                    .unwrap()\n+                    .subscribe(Box::new(file_sink.clone()))\n+                    .map_err(|_| \"failed to subscribe file sink to accumulator\".to_string())?;\n+\n+                // Add sink to sink map for this accumulator.\n+                let _ = sink_map.insert(\n+                    sink.clone(),\n+                    (SinkRealization::File(file_sink), subscription),\n+                );\n+            }\n+            Sink::TcpSender(addr) => {\n+                match addr {\n+                    Addr::Ip(address) => {\n+                        let tcp_sender = TcpSender::new(*address)\n+                            .map_err(|e| format!(\"failed to create TcpSender socket: {}\", e))?;\n+                        let sink = Arc::new(Mutex::new(tcp_sender));\n+\n+                        // Subscribe the accumulator to this sink.\n+                        let subscription = accumulator\n+                            .lock()\n+                            .unwrap()\n+                            .subscribe(Box::new(sink.clone()))\n+                            .map_err(|_| \"failed to subscribe file sink to accumulator\")?;\n+\n+                        // Add sink to sink map for this accumulator.\n+                        let _ = sink_map.insert(\n+                            Sink::TcpSender(*addr),\n+                            (SinkRealization::Node(sink), subscription),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Remove the sink accumulator from the realization.\n+    /// Remove accumulator's entry (keyed by rel_ids) from _sinks.\n+    /// Disconnect accumulator from the server:\n+    /// - Unsubscribe the stream from the accumulator.\n+    /// - Remove the stream from the server.\n+    /// Clear the accumulator.\n+    pub fn remove_sink_accumulator(\n+        &mut self,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        if let Some(entry) = self._sinks.remove(&rel_ids) {\n+            let (accumulator, mut stream, sink_map) = entry;\n+            if sink_map.is_empty() {\n+                // Disconnect accumulator from server.\n+                // First, unsubscribe the stream from the accumulator.\n+                let _ = stream.unsubscribe(&());\n+                // Next, remove the stream from the server.\n+                server.remove_stream(stream);\n+\n+                let mut accum = accumulator.lock().unwrap();\n+                // Clear the accumulator.\n+                if accum.clear().is_ok() {\n+                    Ok(())\n+                } else {\n+                    Err(\"Cannot remove accumulator, failed to clear\".to_string())\n+                }\n+            } else {\n+                Err(\"Cannot remove accumulator, transaction in progress\".to_string())", "originalCommit": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE0NDU4MA==", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r471144580", "bodyText": "Please annotate all methods used for testing with #[cfg(test)].", "author": "ryzhyk", "createdAt": "2020-08-16T18:38:50Z", "path": "rust/template/distributed_datalog/src/instantiate.rs", "diffHunk": "@@ -405,13 +301,218 @@ where\n         }\n     }\n \n+    /// Remove file sink or tcp sender from an existing Realization.\n+    /// Locate the entry in _sinks whose map contains the sink.\n+    /// Remove the entry from the sink map.\n+    /// Unsubscribe the accumulator from the sink.\n+    /// Return an error if unable to find a sink map containing the sink.\n+    pub fn remove_sink(&mut self, sink: &Sink) -> Result<(), String> {\n+        for (accumulator, _, sink_map) in self._sinks.values_mut() {\n+            if sink_map.contains_key(sink) {\n+                let (_, subscription) = sink_map.remove(sink).unwrap();\n+                let _ = accumulator.unsubscribe(&subscription);\n+                return Ok(());\n+            }\n+        }\n+        Err(\"failed to remove sink from realization\".to_string())\n+    }\n+\n+    /// Add file sink or tcp sender to an existing Realization.\n+    /// Creates and adds accumulator for this rel_ids to the Realization if needed.\n+    /// Subscribes the accumulator to the sink and adds the sink to\n+    /// the accumulator's map.\n+    pub fn add_sink(\n+        &mut self,\n+        sink: &Sink,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        // Add the accumulator to the realization if needed.\n+        self.add_sink_accumulator(rel_ids.clone(), server)?;\n+        let (accumulator, _, sink_map) = self._sinks.get_mut(&rel_ids).unwrap();\n+\n+        match sink {\n+            Sink::File(path) => {\n+                let file = File::create(path)\n+                    .map_err(|e| format!(\"failed to create file {}:, {}\", path.display(), e))?;\n+                let file_sink = Arc::new(Mutex::new(FileSink::<P::Convert>::new(file)));\n+\n+                // Subscribe the accumulator to this sink.\n+                let subscription = accumulator\n+                    .lock()\n+                    .unwrap()\n+                    .subscribe(Box::new(file_sink.clone()))\n+                    .map_err(|_| \"failed to subscribe file sink to accumulator\".to_string())?;\n+\n+                // Add sink to sink map for this accumulator.\n+                let _ = sink_map.insert(\n+                    sink.clone(),\n+                    (SinkRealization::File(file_sink), subscription),\n+                );\n+            }\n+            Sink::TcpSender(addr) => {\n+                match addr {\n+                    Addr::Ip(address) => {\n+                        let tcp_sender = TcpSender::new(*address)\n+                            .map_err(|e| format!(\"failed to create TcpSender socket: {}\", e))?;\n+                        let sink = Arc::new(Mutex::new(tcp_sender));\n+\n+                        // Subscribe the accumulator to this sink.\n+                        let subscription = accumulator\n+                            .lock()\n+                            .unwrap()\n+                            .subscribe(Box::new(sink.clone()))\n+                            .map_err(|_| \"failed to subscribe file sink to accumulator\")?;\n+\n+                        // Add sink to sink map for this accumulator.\n+                        let _ = sink_map.insert(\n+                            Sink::TcpSender(*addr),\n+                            (SinkRealization::Node(sink), subscription),\n+                        );\n+                    }\n+                }\n+            }\n+        }\n+        Ok(())\n+    }\n+\n+    /// Remove the sink accumulator from the realization.\n+    /// Remove accumulator's entry (keyed by rel_ids) from _sinks.\n+    /// Disconnect accumulator from the server:\n+    /// - Unsubscribe the stream from the accumulator.\n+    /// - Remove the stream from the server.\n+    /// Clear the accumulator.\n+    pub fn remove_sink_accumulator(\n+        &mut self,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        if let Some(entry) = self._sinks.remove(&rel_ids) {\n+            let (accumulator, mut stream, sink_map) = entry;\n+            if sink_map.is_empty() {\n+                // Disconnect accumulator from server.\n+                // First, unsubscribe the stream from the accumulator.\n+                let _ = stream.unsubscribe(&());\n+                // Next, remove the stream from the server.\n+                server.remove_stream(stream);\n+\n+                let mut accum = accumulator.lock().unwrap();\n+                // Clear the accumulator.\n+                if accum.clear().is_ok() {\n+                    Ok(())\n+                } else {\n+                    Err(\"Cannot remove accumulator, failed to clear\".to_string())\n+                }\n+            } else {\n+                Err(\"Cannot remove accumulator, transaction in progress\".to_string())\n+            }\n+        } else {\n+            Err(\"Unable to locate accumulator to remove from _sinks\".to_string())\n+        }\n+    }\n+\n+    /// Creates and adds a sink accumulator to the existing Realization.\n+    /// Adds a stream to the server for the accumulator.\n+    /// Creates an entry in Realization _sinks for this rel_ids.\n+    pub fn add_sink_accumulator(\n+        &mut self,\n+        rel_ids: BTreeSet<RelId>,\n+        server: &mut DDlogServer<P>,\n+    ) -> Result<(), String> {\n+        if !self._sinks.contains_key(&rel_ids) {\n+            let accumulator = Arc::new(Mutex::new(DistributingAccumulator::new()));\n+            let mut update_observ = server.add_stream(rel_ids.clone());\n+            update_observ\n+                .subscribe(Box::new(accumulator.clone()))\n+                .map_err(|_| \"failed to subscribe accumulator to DDlogServer\".to_string())?;\n+\n+            let _ = self\n+                ._sinks\n+                .insert(rel_ids, (accumulator, update_observ, HashMap::new()));\n+        }\n+        Ok(())\n+    }\n+\n+    /// Checks that the given file source exists in the Realization.\n+    /// Used for testing.\n+    pub fn contains_file_source(&self, path: PathBuf) -> bool {\n+        self._sources.contains_key(&Source::File(path))\n+    }\n+\n+    /// Checks that a tcp receiver exists in the Realization.\n+    /// Used for testing.\n+    pub fn contains_tcp_receiver(&self) -> bool {\n+        self._sources.contains_key(&Source::TcpReceiver)\n+    }\n+\n+    /// Retrieves the id for the source (generated by the TxnMux).\n+    /// Used for testing.\n+    pub fn get_source_id(&self, path: PathBuf) -> usize {\n+        let (_, _, id) = self._sources.get(&Source::File(path)).unwrap();\n+        *id\n+    }\n+\n+    /// Retrieves the id for the TcpReceiver in the Realization.\n+    /// Used for testing.\n+    pub fn get_tcp_receiver_id(&self) -> usize {\n+        let (_, _, id) = self._sources.get(&Source::TcpReceiver).unwrap();\n+        *id\n+    }\n+\n+    /// Checks that the given source (checking by its id) is contained\n+    /// in the TxnMux's subscriptions.\n+    /// Used for testing.\n+    pub fn txn_subscription_exists(&self, id: usize) -> bool {\n+        self._txnmux.subscription_exists(id)\n+    }\n+\n+    /// Checks that the given sink both has an associated accumulator and\n+    /// that said accumulator is subscribed to the sink.\n+    /// Used for testing.\n+    pub fn accumulator_is_subscribed_to_sink(&self, rel_ids: BTreeSet<RelId>, sink: &Sink) -> bool {\n+        let (_, _, sink_map) = self._sinks.get(&rel_ids).unwrap();", "originalCommit": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE0NTQ0NQ==", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r471145445", "bodyText": "These tests look good, but we should also test the dataflow through the system, e.g., that connecting a new sink to an accumulatator brings it up to a correct state.\nLet's wrap up this PR and try to add more tests as a separate PR.", "author": "ryzhyk", "createdAt": "2020-08-16T18:48:57Z", "path": "test/datalog_tests/server_api/tests/realization_tests.rs", "diffHunk": "@@ -0,0 +1,154 @@\n+#[cfg(test)]\n+mod tests {\n+    use distributed_datalog::{Addr, DDlogServer, Realization, Sink, Source};\n+    use server_api_ddlog::api::HDDlog;\n+    use std::collections::{BTreeSet, HashMap};\n+    use std::net::{IpAddr, Ipv4Addr, SocketAddr};\n+    use std::path::PathBuf;\n+    use tempfile::NamedTempFile;\n+\n+    #[test]\n+    fn add_and_then_remove_file_source_from_realization() {\n+        let mut realization = Realization::<HDDlog>::new();\n+\n+        let file = NamedTempFile::new().unwrap();\n+        let path = file.path();\n+        // Check that adding the file succeeds.\n+        assert_eq!(realization.add_file_source(path), Ok(()));\n+\n+        let pathbuf = PathBuf::from(path);\n+        // Check that realization has the file as a source.\n+        assert!(realization.contains_file_source(pathbuf.clone()));\n+        let source_id = realization.get_source_id((&path).to_path_buf());\n+        // Check TxnMux has subscription to source.\n+        assert!(realization.txn_subscription_exists(source_id));\n+\n+        // Check that removing the file sink succeeds.\n+        assert_eq!(\n+            realization.remove_source(&Source::File(pathbuf.clone())),\n+            Ok(())\n+        );\n+        // Check that the realization no longer contains the file sink.\n+        assert!(!realization.contains_file_source(pathbuf));\n+    }\n+\n+    #[test]\n+    fn add_and_then_remove_tcp_receiver_from_realization() {\n+        let mut realization = Realization::<HDDlog>::new();\n+\n+        let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 5000);\n+        // Check that realization has tcp receiver.\n+        assert_eq!(realization.add_tcp_receiver(&addr), Ok(()));\n+\n+        let source_id = realization.get_tcp_receiver_id();\n+        // Check that TxnMux is subscribed to tcp receiver.\n+        assert!(realization.txn_subscription_exists(source_id));\n+        // Check that Realization contains the tcp receiver.\n+        assert!(realization.contains_tcp_receiver());\n+\n+        // Check that removing the tcp receiver succeeds.\n+        assert_eq!(realization.remove_source(&Source::TcpReceiver), Ok(()));\n+        // Check that the realization no longer contains the tcp receiver.\n+        assert!(!realization.contains_tcp_receiver());\n+    }\n+\n+    #[test]\n+    fn add_and_remove_tcp_sender_sink() {\n+        let mut realization = Realization::<HDDlog>::new();\n+\n+        // Set up dummy realization.\n+        let addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 5000);\n+        let mut rel_ids = BTreeSet::new();\n+        rel_ids.insert(1);\n+        rel_ids.insert(2);\n+        rel_ids.insert(3);\n+\n+        let mut server = DDlogServer::new(None, HashMap::new());\n+        let sink = Sink::TcpSender(Addr::Ip(addr));\n+\n+        // Check that realization successfully adds tcp sender sink.\n+        assert_eq!(\n+            realization.add_sink(&sink, rel_ids.clone(), &mut server),\n+            Ok(())\n+        );\n+        // Check that realization has an accumulator for the sink and that the\n+        // subscription exists.\n+        assert!(realization.accumulator_is_subscribed_to_sink(rel_ids.clone(), &sink));\n+\n+        // Check that realization successfully removes the tcp sender sink.\n+        assert_eq!(realization.remove_sink(&sink), Ok(()));\n+        assert!(!realization.accumulator_is_subscribed_to_sink(rel_ids.clone(), &sink));\n+\n+        // Check that the sink accumulator can be successfully removed.\n+        assert_eq!(\n+            realization.remove_sink_accumulator(rel_ids, &mut server),\n+            Ok(())\n+        );\n+    }\n+\n+    #[test]\n+    fn add_and_remove_file_sink() {\n+        // Set up dummy realization.\n+        let mut realization = Realization::<HDDlog>::new();\n+\n+        let file = NamedTempFile::new().unwrap();\n+        let path = file.path();\n+\n+        let mut rel_ids = BTreeSet::new();\n+        rel_ids.insert(1);\n+        rel_ids.insert(2);\n+        rel_ids.insert(3);\n+\n+        let pathbuf = PathBuf::from(path);\n+        let mut server = DDlogServer::new(None, HashMap::new());\n+        let sink = Sink::File(pathbuf);\n+\n+        // Check that realization successfully adds file sink.\n+        assert_eq!(\n+            realization.add_sink(&sink, rel_ids.clone(), &mut server),\n+            Ok(())\n+        );\n+        // Check that realization has an accumulator for the sink and that the\n+        // subscription exists.\n+        assert!(realization.accumulator_is_subscribed_to_sink(rel_ids.clone(), &sink));\n+\n+        // Check that realization successfully removes the file sink.\n+        assert_eq!(realization.remove_sink(&sink), Ok(()));\n+        assert!(!realization.accumulator_is_subscribed_to_sink(rel_ids.clone(), &sink));\n+\n+        // Check that the sink accumulator can be successfully removed.\n+        assert_eq!(\n+            realization.remove_sink_accumulator(rel_ids, &mut server),\n+            Ok(())\n+        );\n+    }\n+\n+    #[test]\n+    fn remove_sink_accumulator_prematurely() {\n+        // Should error if the accumulator to be removed still has sinks.\n+\n+        let mut realization = Realization::<HDDlog>::new();\n+\n+        let file = NamedTempFile::new().unwrap();\n+        let path = file.path();\n+\n+        let mut rel_ids = BTreeSet::new();\n+        rel_ids.insert(1);\n+        rel_ids.insert(2);\n+        rel_ids.insert(3);\n+\n+        let pathbuf = PathBuf::from(path);\n+        let mut server = DDlogServer::new(None, HashMap::new());\n+        let sink = Sink::File(pathbuf);\n+\n+        // Check that the sink is added successfully.\n+        assert_eq!(\n+            realization.add_sink(&sink, rel_ids.clone(), &mut server),\n+            Ok(())\n+        );\n+        // Check that removing the sink accumulator returns an error.\n+        assert!(realization\n+            .remove_sink_accumulator(rel_ids, &mut server)\n+            .is_err());\n+    }\n+}", "originalCommit": "5d11e192f5043ab1af92b1f7ad6a7d3804d550b8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE0MDM4Mg==", "url": "https://github.com/vmware/differential-datalog/pull/737#discussion_r473140382", "bodyText": "Sounds good to me.", "author": "krs85", "createdAt": "2020-08-19T16:02:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE0NTQ0NQ=="}], "type": "inlineReview"}, {"oid": "5aaf233dca622d3a5bca71ab2609b44df4180d56", "url": "https://github.com/vmware/differential-datalog/commit/5aaf233dca622d3a5bca71ab2609b44df4180d56", "message": "wip for add and removing sinks and sink accums", "committedDate": "2020-08-24T15:54:09Z", "type": "commit"}, {"oid": "1a65f06c540cb8c177a381f7acd3a1a4a585146e", "url": "https://github.com/vmware/differential-datalog/commit/1a65f06c540cb8c177a381f7acd3a1a4a585146e", "message": "wip still", "committedDate": "2020-08-24T15:54:09Z", "type": "commit"}, {"oid": "809250ac9e806ac5676e141dcae4a2e329ef3a03", "url": "https://github.com/vmware/differential-datalog/commit/809250ac9e806ac5676e141dcae4a2e329ef3a03", "message": "add_sink() and add_sink_accumulator()", "committedDate": "2020-08-24T15:54:09Z", "type": "commit"}, {"oid": "e58f59a1cc727a42ea9eb139f4c3e1ecc5fcaaf6", "url": "https://github.com/vmware/differential-datalog/commit/e58f59a1cc727a42ea9eb139f4c3e1ecc5fcaaf6", "message": "remove_sink()", "committedDate": "2020-08-24T15:54:09Z", "type": "commit"}, {"oid": "7716f9f0ff775467a6598150267cbc54d9d1e1c4", "url": "https://github.com/vmware/differential-datalog/commit/7716f9f0ff775467a6598150267cbc54d9d1e1c4", "message": "Changes _sinks entries to also contain the accumulator's stream, implements remove_sink_accumulator(), fixes add_sink_accumulator()", "committedDate": "2020-08-24T15:54:09Z", "type": "commit"}, {"oid": "4fa39a5e35434396cd6246b3b6dec2fff6ef6ee6", "url": "https://github.com/vmware/differential-datalog/commit/4fa39a5e35434396cd6246b3b6dec2fff6ef6ee6", "message": "small fix in comments", "committedDate": "2020-08-24T15:54:09Z", "type": "commit"}, {"oid": "069f7e2efa851c4aeca52799e568384278cd93d3", "url": "https://github.com/vmware/differential-datalog/commit/069f7e2efa851c4aeca52799e568384278cd93d3", "message": "Fix clippy errors, fix silly unwrap call", "committedDate": "2020-08-24T15:54:09Z", "type": "commit"}, {"oid": "3be2fcbeafbad2dd7b6c7dad0f52c42c1aea381a", "url": "https://github.com/vmware/differential-datalog/commit/3be2fcbeafbad2dd7b6c7dad0f52c42c1aea381a", "message": "Finishes up implementation of sink side of Realization API. Adds basic unit tests for the new API and updates old tests.", "committedDate": "2020-08-24T15:54:09Z", "type": "commit"}, {"oid": "0f9b1b0bac5d3fdd04958b22632318482329d4d3", "url": "https://github.com/vmware/differential-datalog/commit/0f9b1b0bac5d3fdd04958b22632318482329d4d3", "message": "Minor fixes for PR", "committedDate": "2020-08-24T15:54:09Z", "type": "commit"}, {"oid": "780211cab70c58b148d994d53b5170ff753bbf8f", "url": "https://github.com/vmware/differential-datalog/commit/780211cab70c58b148d994d53b5170ff753bbf8f", "message": "Small clippy fixes", "committedDate": "2020-08-24T15:54:09Z", "type": "commit"}, {"oid": "6eefb2aa59e4388fa856cb74823a50e60071365e", "url": "https://github.com/vmware/differential-datalog/commit/6eefb2aa59e4388fa856cb74823a50e60071365e", "message": "Remove unnecessary clear() for sink accumulator", "committedDate": "2020-08-24T15:54:09Z", "type": "commit"}, {"oid": "c6a94a4bdbb9597b2291e92e92f79364e15fd898", "url": "https://github.com/vmware/differential-datalog/commit/c6a94a4bdbb9597b2291e92e92f79364e15fd898", "message": "removing #cfg(test) annotations", "committedDate": "2020-08-24T15:54:09Z", "type": "commit"}, {"oid": "c6a94a4bdbb9597b2291e92e92f79364e15fd898", "url": "https://github.com/vmware/differential-datalog/commit/c6a94a4bdbb9597b2291e92e92f79364e15fd898", "message": "removing #cfg(test) annotations", "committedDate": "2020-08-24T15:54:09Z", "type": "forcePushed"}]}