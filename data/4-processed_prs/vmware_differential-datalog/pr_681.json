{"pr_number": 681, "pr_title": "Type inference, part 1.", "pr_createdAt": "2020-06-05T16:01:02Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/681", "timeline": [{"oid": "0b260279192d399c8b8402fedfdedbaa54b957c0", "url": "https://github.com/vmware/differential-datalog/commit/0b260279192d399c8b8402fedfdedbaa54b957c0", "message": "Type inference constraint generation.\n\nThis is the first part of the type inference engine that generates\ntype constraints for all variable and expressions in the program.\n\nThe design is described in detail here:\nhttps://github.com/vmware/differential-datalog/issues/668\n\nThis code is untested and is not yet used by the compiler.", "committedDate": "2020-06-05T02:40:18Z", "type": "commit"}, {"oid": "5cfc6cf9cb157f8bf8fef6e55dcf01ddb834931a", "url": "https://github.com/vmware/differential-datalog/commit/5cfc6cf9cb157f8bf8fef6e55dcf01ddb834931a", "message": "Var type.\n\nThis commit introduces `Var` type that uniquely identifies variable\ndeclaration in a program.  This is needed by the type inference\nframework, where we want to introduce a type variable per program\nvariable, and so need an unambiguous way to refer to the latter.\nHowever, this refactoring also leads to cleaner code in many places.\nIn particular, it consolidates all logic that computes variable type in\none place (eventually it will be replaced by the type inference logic).\n\nThis refactoring also has a positive side effect of reducing the number\nof different functions that scan expressions searching for used\nvariables: `atomVarTypes`, `atomVarOccurrences`, `atomVars`,\n`atomVarDecls` are now gone.  Instead we have a (hopefully) correct\nimplementation of:\n\n`exprVars` - all variables used in expression.\n`exprVarDecls` - all variables declared in an expression.\n`exprFreeVars` - variables used in expression declared outside of it\n\nwhich should work in all contexts.", "committedDate": "2020-06-05T02:40:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3MjY5MQ==", "url": "https://github.com/vmware/differential-datalog/pull/681#discussion_r436172691", "bodyText": "Can this be caused by an incorrect program? In that case you may want to use the nicer error message.", "author": "mbudiu-vmw", "createdAt": "2020-06-05T21:29:58Z", "path": "src/Language/DifferentialDatalog/Type.hs", "diffHunk": "@@ -869,3 +870,40 @@ checkIterable :: (MonadError String me, WithType a) => String -> Pos -> DatalogP\n checkIterable prefix p d x =\n     check d (typeIsIterable d x) p $\n           prefix ++ \" must have one of these types: \" ++ intercalate \", \" sET_TYPES ++ \", or \" ++ mAP_TYPE ++ \" but its type is \" ++ show (typ x)\n+\n+varTypeMaybe :: DatalogProgram -> Var -> Maybe Type\n+varTypeMaybe d (ExprVar ctx EVarDecl{})         = ctxExpectType d ctx\n+varTypeMaybe d (ExprVar ctx EVar{})             = ctxExpectType d ctx\n+varTypeMaybe _ v@ExprVar{}                      = error $ \"varTypeMaybe \" ++ show v\n+varTypeMaybe d (ForVar ctx e@EFor{..})          = fst <$> (typeIterType d =<< exprTypeMaybe d (CtxForIter e ctx) exprIter)\n+varTypeMaybe _ v@ForVar{}                       = error $ \"varTypeMaybe \" ++ show v\n+varTypeMaybe d (BindingVar ctx e@EBinding{..})  = exprTypeMaybe d (CtxBinding e ctx) exprPattern\n+varTypeMaybe _ v@BindingVar{}                   = error $ \"varTypeMaybe \" ++ show v\n+varTypeMaybe _ ArgVar{..}                       = Just $ typ $ fromJust $ find ((== varName) . name) $ funcArgs varFunc\n+varTypeMaybe _ KeyVar{..}                       = Just $ typ varRel\n+varTypeMaybe _ IdxVar{..}                       = Just $ typ $ fromJust $ find ((== varName) . name) $ idxVars varIndex\n+varTypeMaybe d (FlatMapVar rl i)                = case typ' d <$> exprTypeMaybe d (CtxRuleRFlatMap rl i) (rhsMapExpr $ ruleRHS rl !! i) of\n+                                                       Just (TOpaque _ _ [t'])     -> Just t'\n+                                                       Just (TOpaque _ tname [kt,vt]) | tname == mAP_TYPE\n+                                                                                   -> Just $ tTuple [kt,vt]\n+                                                       _                           -> Nothing\n+\n+varTypeMaybe d (AggregateVar rl i)              = let f = getFunc d (rhsAggFunc $ ruleRHS rl !! i)\n+                                                      tmap = ruleAggregateTypeParams d rl i\n+                                                  in Just $ typeSubstTypeArgs tmap $ funcType f\n+varTypeMaybe _ WeightVar                        = Just $ tUser wEIGHT_TYPE []\n+varTypeMaybe d (TSVar rl)                       = if ruleIsRecursive d rl\n+                                                  then Just $ tUser nESTED_TS_TYPE []\n+                                                  else Just $ tUser ePOCH_TYPE []\n+\n+varCheckType :: (MonadError String me) => DatalogProgram -> Var -> me Type\n+varCheckType d v =\n+    case varTypeMaybe d v of\n+         Nothing -> err d (pos v) $ \"Type of variable '\" ++ name v ++ \"' is unknown\"\n+         Just t  -> return t\n+\n+varType :: DatalogProgram -> Var -> Type\n+varType d v =\n+    case varTypeMaybe d v of\n+         Nothing -> error $ \"Type of variable '\" ++ name v ++ \"' is unknown\"", "originalCommit": "5cfc6cf9cb157f8bf8fef6e55dcf01ddb834931a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyOTY5Mg==", "url": "https://github.com/vmware/differential-datalog/pull/681#discussion_r436229692", "bodyText": "No, this is an internal error, it's only there for debugging.", "author": "ryzhyk", "createdAt": "2020-06-06T02:31:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3MjY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3NTM1MA==", "url": "https://github.com/vmware/differential-datalog/pull/681#discussion_r436175350", "bodyText": "typo in string", "author": "mbudiu-vmw", "createdAt": "2020-06-05T21:37:37Z", "path": "src/Language/DifferentialDatalog/Expr.hs", "diffHunk": "@@ -238,39 +240,54 @@ exprVarOccurrences ctx e = exprCollectCtx (\\ctx' e' ->\n                                           (++) ctx e\n \n -- enumerate all variables that occur in the expression\n-exprVars :: Expr -> [String]\n-exprVars e = nub $ exprCollect (\\case\n-                                EVar _ v -> [v]\n-                                _        -> [])\n-                               (++) e\n+exprVars :: DatalogProgram -> ECtx -> Expr -> [Var]\n+exprVars d ctx e = nub $ exprCollectCtx (\\ctx' e' ->\n+                                          case e' of\n+                                               EVar p v -> [case lookupVar d ctx' v of\n+                                                                 -- Variable declared inside a rule.\n+                                                                 Nothing -> ExprVar ctx' $ EVar p v\n+                                                                 Just var -> var]\n+                                               _        -> [])\n+                                        (++) ctx e\n \n -- | Free variables, i.e., variables that are used in the expression, but declared\n -- outside of it\n-exprFreeVars :: DatalogProgram -> ECtx -> Expr -> [String]\n+exprFreeVars :: DatalogProgram -> ECtx -> Expr -> [Var]\n exprFreeVars d ctx e = visible_vars `intersect` used_vars\n     where\n-    visible_vars = map name $ ctxAllVars d ctx\n-    used_vars = exprVars e\n+    visible_vars = ctxAllVars d ctx\n+    used_vars = exprVars d ctx e\n \n -- True if expression evaluates to a constant\n -- Note: this does not guarantee that the expression can be evaluated at compile\n -- time.  It may contain a call to an external function, which cannot be\n -- evaluated in Haskell.\n exprIsConst :: Expr -> Bool\n-exprIsConst = null . exprVars\n+exprIsConst e = null $ exprVars (error \"exprIsConst: ctx is undefined\") (error \"exprIsConst: ctx is undedined\") e", "originalCommit": "5cfc6cf9cb157f8bf8fef6e55dcf01ddb834931a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3NTkxOQ==", "url": "https://github.com/vmware/differential-datalog/pull/681#discussion_r436175919", "bodyText": "how come this wasn't here before?", "author": "mbudiu-vmw", "createdAt": "2020-06-05T21:39:21Z", "path": "src/Language/DifferentialDatalog/Expr.hs", "diffHunk": "@@ -238,39 +240,54 @@ exprVarOccurrences ctx e = exprCollectCtx (\\ctx' e' ->\n                                           (++) ctx e\n \n -- enumerate all variables that occur in the expression\n-exprVars :: Expr -> [String]\n-exprVars e = nub $ exprCollect (\\case\n-                                EVar _ v -> [v]\n-                                _        -> [])\n-                               (++) e\n+exprVars :: DatalogProgram -> ECtx -> Expr -> [Var]\n+exprVars d ctx e = nub $ exprCollectCtx (\\ctx' e' ->\n+                                          case e' of\n+                                               EVar p v -> [case lookupVar d ctx' v of\n+                                                                 -- Variable declared inside a rule.\n+                                                                 Nothing -> ExprVar ctx' $ EVar p v\n+                                                                 Just var -> var]\n+                                               _        -> [])\n+                                        (++) ctx e\n \n -- | Free variables, i.e., variables that are used in the expression, but declared\n -- outside of it\n-exprFreeVars :: DatalogProgram -> ECtx -> Expr -> [String]\n+exprFreeVars :: DatalogProgram -> ECtx -> Expr -> [Var]\n exprFreeVars d ctx e = visible_vars `intersect` used_vars\n     where\n-    visible_vars = map name $ ctxAllVars d ctx\n-    used_vars = exprVars e\n+    visible_vars = ctxAllVars d ctx\n+    used_vars = exprVars d ctx e\n \n -- True if expression evaluates to a constant\n -- Note: this does not guarantee that the expression can be evaluated at compile\n -- time.  It may contain a call to an external function, which cannot be\n -- evaluated in Haskell.\n exprIsConst :: Expr -> Bool\n-exprIsConst = null . exprVars\n+exprIsConst e = null $ exprVars (error \"exprIsConst: ctx is undefined\") (error \"exprIsConst: ctx is undedined\") e\n \n--- Variables declared inside expression, visible in the code that follows the expression\n-exprVarDecls :: ECtx -> Expr -> [(String, ECtx)]\n-exprVarDecls ctx e =\n+-- Variables declared inside expression, visible in the code that follows the expression.\n+exprVarDecls :: DatalogProgram -> ECtx -> Expr -> [Var]\n+exprVarDecls d ctx e =\n+    snd $\n     exprFoldCtx (\\ctx' e' ->\n-                  case e' of\n-                       EStruct _ _ fs   -> concatMap snd fs\n-                       ETuple _ fs      -> concat fs\n-                       EVarDecl _ v     -> [(v, ctx')]\n-                       ESet _ l _       -> l\n-                       EBinding _ v e'' -> (v, ctx') : e''\n-                       ETyped _ e'' _   -> e''\n-                       _                -> []) ctx e\n+                  let e_ = exprMap fst e' in\n+                  (E e_,\n+                   case e' of\n+                        EStruct _ _ fs   -> concatMap (snd . snd) fs\n+                        ETuple _ fs      -> concatMap snd fs\n+                        EVarDecl _ _     -> [ExprVar ctx' e_]\n+                        -- Inside positive literals, variables are declared", "originalCommit": "5cfc6cf9cb157f8bf8fef6e55dcf01ddb834931a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyOTkyNg==", "url": "https://github.com/vmware/differential-datalog/pull/681#discussion_r436229926", "bodyText": "Because we had separate functions that knew about variable declarations in rules. It was a mess.", "author": "ryzhyk", "createdAt": "2020-06-06T02:35:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3NTkxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3NzAxMA==", "url": "https://github.com/vmware/differential-datalog/pull/681#discussion_r436177010", "bodyText": "nicer error message possible?", "author": "mbudiu-vmw", "createdAt": "2020-06-05T21:42:34Z", "path": "src/Language/DifferentialDatalog/NS.hs", "diffHunk": "@@ -87,16 +81,17 @@ checkTransformer p d n = case lookupTransformer d n of\n getTransformer :: DatalogProgram -> String -> Transformer\n getTransformer d n = fromJust $ lookupTransformer d n\n \n-lookupVar :: DatalogProgram -> ECtx -> String -> Maybe Field\n+lookupVar :: DatalogProgram -> ECtx -> String -> Maybe Var\n lookupVar d ctx n = find ((==n) . name) $ ctxAllVars d ctx\n \n-checkVar :: (MonadError String me) => Pos -> DatalogProgram -> ECtx -> String -> me Field\n+checkVar :: (MonadError String me) => Pos -> DatalogProgram -> ECtx -> String -> me Var\n checkVar p d c n = case lookupVar d c n of\n                         Nothing -> err d p $ \"Unknown variable: \" ++ n -- ++ \". All known variables: \" ++ (show $ (\\(ls,vs) -> (map name ls, map name vs)) $ ctxVars d c)\n                         Just v  -> return v\n \n-getVar :: DatalogProgram -> ECtx -> String -> Field\n-getVar d c n = fromJust $ lookupVar d c n\n+getVar :: DatalogProgram -> ECtx -> String -> Var\n+getVar d c n = ", "originalCommit": "5cfc6cf9cb157f8bf8fef6e55dcf01ddb834931a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyOTk5OQ==", "url": "https://github.com/vmware/differential-datalog/pull/681#discussion_r436229999", "bodyText": "Same thing, this is only there to debug compiler crashes.", "author": "ryzhyk", "createdAt": "2020-06-06T02:35:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3NzAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3NzE4Nw==", "url": "https://github.com/vmware/differential-datalog/pull/681#discussion_r436177187", "bodyText": "I find this surprising, I thought Field and Var are quite different.", "author": "mbudiu-vmw", "createdAt": "2020-06-05T21:43:07Z", "path": "src/Language/DifferentialDatalog/NS.hs", "diffHunk": "@@ -87,16 +81,17 @@ checkTransformer p d n = case lookupTransformer d n of\n getTransformer :: DatalogProgram -> String -> Transformer\n getTransformer d n = fromJust $ lookupTransformer d n\n \n-lookupVar :: DatalogProgram -> ECtx -> String -> Maybe Field\n+lookupVar :: DatalogProgram -> ECtx -> String -> Maybe Var", "originalCommit": "5cfc6cf9cb157f8bf8fef6e55dcf01ddb834931a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMDEyNw==", "url": "https://github.com/vmware/differential-datalog/pull/681#discussion_r436230127", "bodyText": "Var is a new abstraction. Given a Var you can always find out its type. Field combines variable name and type.  Like I said, a mess...", "author": "ryzhyk", "createdAt": "2020-06-06T02:38:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3NzE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4MzA1OQ==", "url": "https://github.com/vmware/differential-datalog/pull/681#discussion_r436183059", "bodyText": "To give nice error messages you may also want to keep with each constraint lineage information - this can be either something that implements pos, or another constraint; this way, when a constraint fails you can indicate where it originated and finally point to the source-level position that caused the constraint to be generated. Look at the llvm error messages when type unification fails for an inspiration.", "author": "mbudiu-vmw", "createdAt": "2020-06-05T22:00:17Z", "path": "src/Language/DifferentialDatalog/TypeInference.hs", "diffHunk": "@@ -0,0 +1,637 @@\n+{-\n+Copyright (c) 2020 VMware, Inc.\n+SPDX-License-Identifier: MIT\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE.\n+-}\n+\n+{-# LANGUAGE FlexibleContexts, RecordWildCards, TupleSections, ImplicitParams #-}\n+\n+module Language.DifferentialDatalog.TypeInference(\n+    TypeInferenceResult(..),\n+    inferTypes\n+)\n+where\n+\n+import qualified Data.Map as M\n+import Control.Monad.State.Lazy\n+import Data.Maybe\n+\n+import Language.DifferentialDatalog.Attribute\n+import Language.DifferentialDatalog.ECtx\n+import Language.DifferentialDatalog.Expr\n+import Language.DifferentialDatalog.Name\n+import Language.DifferentialDatalog.NS\n+import Language.DifferentialDatalog.Ops\n+import Language.DifferentialDatalog.Rule\n+import Language.DifferentialDatalog.Syntax\n+import Language.DifferentialDatalog.Type\n+import Language.DifferentialDatalog.Util\n+import Language.DifferentialDatalog.Var\n+\n+data TypeInferenceResult = TypeInferenceOk (M.Map Var Type) (M.Map ECtx Type)\n+                         | TypeInferenceConflict\n+                         | TypeInferenceAmbiguity\n+\n+-- Uniquely identifies an expression in a DDlog program.\n+data DDExpr = DDExpr {ddexprCtx::ECtx, ddexprExpr::Expr}\n+\n+-- A type constraint is an atomic predicate or a disjuncion of conjuntions of\n+-- predicates.  We use a unification-based solver to resolv type constraints,\n+-- which does not handle arbitrary Boolean combination constraints, hence this\n+-- restricted structure.\n+data Constraint = CPredicate Predicate", "originalCommit": "5cfc6cf9cb157f8bf8fef6e55dcf01ddb834931a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMDI1MQ==", "url": "https://github.com/vmware/differential-datalog/pull/681#discussion_r436230251", "bodyText": "I plan to do this in the next PR. It will be clearer how to generate explanations and what state needs to be tracked as I make progress on the algorithm.", "author": "ryzhyk", "createdAt": "2020-06-06T02:40:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE4MzA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5MDY1Ng==", "url": "https://github.com/vmware/differential-datalog/pull/681#discussion_r436190656", "bodyText": "I find it a bit strange that you can lookup stuff in the program while creating constraints, but I don't see why this would not work.", "author": "mbudiu-vmw", "createdAt": "2020-06-05T22:23:29Z", "path": "src/Language/DifferentialDatalog/TypeInference.hs", "diffHunk": "@@ -0,0 +1,637 @@\n+{-\n+Copyright (c) 2020 VMware, Inc.\n+SPDX-License-Identifier: MIT\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE.\n+-}\n+\n+{-# LANGUAGE FlexibleContexts, RecordWildCards, TupleSections, ImplicitParams #-}\n+\n+module Language.DifferentialDatalog.TypeInference(\n+    TypeInferenceResult(..),\n+    inferTypes\n+)\n+where\n+\n+import qualified Data.Map as M\n+import Control.Monad.State.Lazy\n+import Data.Maybe\n+\n+import Language.DifferentialDatalog.Attribute\n+import Language.DifferentialDatalog.ECtx\n+import Language.DifferentialDatalog.Expr\n+import Language.DifferentialDatalog.Name\n+import Language.DifferentialDatalog.NS\n+import Language.DifferentialDatalog.Ops\n+import Language.DifferentialDatalog.Rule\n+import Language.DifferentialDatalog.Syntax\n+import Language.DifferentialDatalog.Type\n+import Language.DifferentialDatalog.Util\n+import Language.DifferentialDatalog.Var\n+\n+data TypeInferenceResult = TypeInferenceOk (M.Map Var Type) (M.Map ECtx Type)\n+                         | TypeInferenceConflict\n+                         | TypeInferenceAmbiguity\n+\n+-- Uniquely identifies an expression in a DDlog program.\n+data DDExpr = DDExpr {ddexprCtx::ECtx, ddexprExpr::Expr}\n+\n+-- A type constraint is an atomic predicate or a disjuncion of conjuntions of\n+-- predicates.  We use a unification-based solver to resolv type constraints,\n+-- which does not handle arbitrary Boolean combination constraints, hence this\n+-- restricted structure.\n+data Constraint = CPredicate Predicate\n+                  -- Disjunction of conjunctions.  The first condition in each\n+                  -- conjunction must not overlap with others, e.g.,\n+                  -- 'c11 && c12 && ... ||\n+                  --  ...\n+                  --  cn1 && cn2 && ...'\n+                  --  where 'c1i' are all mutually exclusive.\n+                | CDisj [[Predicate]]\n+\n+cdisj :: [[Predicate]] -> [Constraint]\n+cdisj [ps] = map CPredicate ps\n+cdisj pss  = [CDisj pss]\n+\n+-- Integer expressions represent widths of bit and signed types.\n+data IExpr = -- Integer constant.\n+             IConst Int\n+             -- Integer variable equal to the width of a DDExpr.\n+           | IWidthOfExpr DDExpr\n+             -- Sum of two widths.\n+           | IPlus IExpr IExpr\n+\n+-- Type expression: an expression that returns a value of 'Type' sort.\n+data TExpr = TEBool\n+           | TEString\n+           | TEBigInt\n+           | TEBit IExpr\n+           | TESigned IExpr\n+           | TEFloat\n+           | TEDouble\n+             -- Tuple type whose size and field types may be only partially known.\n+           | TETuple (Maybe Int) (M.Map Int TExpr)\n+             -- User-defined type.\n+           | TEUser String [TExpr]\n+             -- Extern type.\n+           | TEExtern String [TExpr]\n+             -- In a function context only, a type argument of the function (e.g., 'A).\n+           | TETArg String\n+             -- Type of a DDlog expression.\n+           | TETypeOfExpr DDExpr\n+             -- Type of a DDlog variable.\n+           | TETypeOfVar Var\n+             -- We sometimes need to introduce extra type variables to model\n+             -- unknown type arguments of function calls.  We could use\n+             -- arbitrary auto-generated names for them, but to avoid a state\n+             -- monad, we use context and type argument name to uniquely\n+             -- identify the variable.\n+           | TETVar ECtx String\n+\n+teTuple :: [TExpr] -> TExpr\n+teTuple [t] = t\n+teTuple ts  = TETuple (Just $ length ts) (M.fromList $ mapIdx (\\t i -> (i, t)) ts)\n+\n+-- Type congruence, e.g., '|e| = BigInt'.\n+data Predicate = PEq TExpr TExpr\n+\n+(===) :: TExpr -> TExpr -> Constraint\n+(===) t1 t2 = CPredicate $ PEq t1 t2\n+\n+-- Type expression is a struct of the specified user-defined type: 'is_MyStruct |e|'.\n+deIsStruct :: (?d::DatalogProgram) => DDExpr -> String -> Constraint\n+deIsStruct de n = CPredicate $ deIsStruct_ de n\n+\n+deIsStruct_ :: (?d::DatalogProgram) => DDExpr -> String -> Predicate\n+deIsStruct_ de@(DDExpr ctx _) n =\n+    PEq (TETypeOfExpr de) (TEUser n (map (\\a -> TETVar ctx $ name a) tdefArgs))\n+    where\n+    TypeDef{..} = getType ?d n\n+\n+deIsBool :: DDExpr -> Constraint\n+deIsBool de = TETypeOfExpr de === TEBool\n+\n+deIsString :: DDExpr -> Constraint\n+deIsString de = CPredicate $ deIsString_ de\n+\n+deIsString_ :: DDExpr -> Predicate\n+deIsString_ de = PEq (TETypeOfExpr de) TEString\n+\n+deIsBit :: DDExpr -> Constraint\n+deIsBit de = CPredicate $ deIsBit_ de\n+\n+deIsBit_ :: DDExpr -> Predicate\n+deIsBit_ de = PEq (TETypeOfExpr de) (TEBit (IWidthOfExpr de))\n+\n+deIsSigned_ :: DDExpr -> Predicate\n+deIsSigned_ de = PEq (TETypeOfExpr de) (TESigned (IWidthOfExpr de))\n+\n+deIsBigInt_ :: DDExpr -> Predicate\n+deIsBigInt_ de = PEq (TETypeOfExpr de) TEBigInt\n+\n+deIsFloat :: DDExpr -> Constraint\n+deIsFloat de = CPredicate $ deIsFloat_ de\n+\n+deIsFloat_ :: DDExpr -> Predicate\n+deIsFloat_ de = PEq (TETypeOfExpr de) TEFloat\n+\n+deIsDouble_ :: DDExpr -> Predicate\n+deIsDouble_ de = PEq (TETypeOfExpr de) TEDouble\n+\n+deIsFP :: DDExpr -> Constraint\n+deIsFP de = CDisj $ deIsFP_ de\n+\n+deIsFP_ :: DDExpr -> [[Predicate]]\n+deIsFP_ de = [[deIsFloat_ de], [deIsDouble_ de]]\n+\n+-- 'is_bits t = is_Bit t || is_Signed t'.\n+deIsBits :: DDExpr -> Constraint\n+deIsBits de = CDisj $ deIsBits_ de\n+\n+deIsBits_ :: DDExpr -> [[Predicate]]\n+deIsBits_ de = [[deIsBit_ de], [deIsSigned_ de]]\n+\n+-- 'is_int t = is_bits t || is_BigInt t'.\n+deIsInt :: DDExpr -> Constraint\n+deIsInt de = CDisj $ deIsInt_ de\n+\n+deIsInt_ :: DDExpr -> [[Predicate]]\n+deIsInt_ de = deIsBits_ de ++ [[deIsBigInt_ de]]\n+\n+-- 'is_num t = is_int t || is_fp t'.\n+deIsNum :: DDExpr -> Constraint\n+deIsNum de = CDisj $ deIsInt_ de ++ deIsFP_ de\n+\n+-- Type expression is a shared reference type with specified inner type.\n+deIsSharedRef :: (?d::DatalogProgram) => DDExpr -> TExpr -> [Constraint]\n+deIsSharedRef de t =\n+    cdisj $ map (\\tdef -> [PEq (TETypeOfExpr de) (TEExtern (name tdef) [t])]) sref_tdefs\n+    where\n+    -- All shared reference types.\n+    sref_tdefs = filter (tdefGetSharedRefAttr ?d)", "originalCommit": "5cfc6cf9cb157f8bf8fef6e55dcf01ddb834931a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5MTE5Mw==", "url": "https://github.com/vmware/differential-datalog/pull/681#discussion_r436191193", "bodyText": "\"these\" constants.\nCould the constants be just other type variables?\nThis can happen when analyzing a generic function calling another generic function.", "author": "mbudiu-vmw", "createdAt": "2020-06-05T22:25:27Z", "path": "src/Language/DifferentialDatalog/TypeInference.hs", "diffHunk": "@@ -0,0 +1,637 @@\n+{-\n+Copyright (c) 2020 VMware, Inc.\n+SPDX-License-Identifier: MIT\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE.\n+-}\n+\n+{-# LANGUAGE FlexibleContexts, RecordWildCards, TupleSections, ImplicitParams #-}\n+\n+module Language.DifferentialDatalog.TypeInference(\n+    TypeInferenceResult(..),\n+    inferTypes\n+)\n+where\n+\n+import qualified Data.Map as M\n+import Control.Monad.State.Lazy\n+import Data.Maybe\n+\n+import Language.DifferentialDatalog.Attribute\n+import Language.DifferentialDatalog.ECtx\n+import Language.DifferentialDatalog.Expr\n+import Language.DifferentialDatalog.Name\n+import Language.DifferentialDatalog.NS\n+import Language.DifferentialDatalog.Ops\n+import Language.DifferentialDatalog.Rule\n+import Language.DifferentialDatalog.Syntax\n+import Language.DifferentialDatalog.Type\n+import Language.DifferentialDatalog.Util\n+import Language.DifferentialDatalog.Var\n+\n+data TypeInferenceResult = TypeInferenceOk (M.Map Var Type) (M.Map ECtx Type)\n+                         | TypeInferenceConflict\n+                         | TypeInferenceAmbiguity\n+\n+-- Uniquely identifies an expression in a DDlog program.\n+data DDExpr = DDExpr {ddexprCtx::ECtx, ddexprExpr::Expr}\n+\n+-- A type constraint is an atomic predicate or a disjuncion of conjuntions of\n+-- predicates.  We use a unification-based solver to resolv type constraints,\n+-- which does not handle arbitrary Boolean combination constraints, hence this\n+-- restricted structure.\n+data Constraint = CPredicate Predicate\n+                  -- Disjunction of conjunctions.  The first condition in each\n+                  -- conjunction must not overlap with others, e.g.,\n+                  -- 'c11 && c12 && ... ||\n+                  --  ...\n+                  --  cn1 && cn2 && ...'\n+                  --  where 'c1i' are all mutually exclusive.\n+                | CDisj [[Predicate]]\n+\n+cdisj :: [[Predicate]] -> [Constraint]\n+cdisj [ps] = map CPredicate ps\n+cdisj pss  = [CDisj pss]\n+\n+-- Integer expressions represent widths of bit and signed types.\n+data IExpr = -- Integer constant.\n+             IConst Int\n+             -- Integer variable equal to the width of a DDExpr.\n+           | IWidthOfExpr DDExpr\n+             -- Sum of two widths.\n+           | IPlus IExpr IExpr\n+\n+-- Type expression: an expression that returns a value of 'Type' sort.\n+data TExpr = TEBool\n+           | TEString\n+           | TEBigInt\n+           | TEBit IExpr\n+           | TESigned IExpr\n+           | TEFloat\n+           | TEDouble\n+             -- Tuple type whose size and field types may be only partially known.\n+           | TETuple (Maybe Int) (M.Map Int TExpr)\n+             -- User-defined type.\n+           | TEUser String [TExpr]\n+             -- Extern type.\n+           | TEExtern String [TExpr]\n+             -- In a function context only, a type argument of the function (e.g., 'A).\n+           | TETArg String\n+             -- Type of a DDlog expression.\n+           | TETypeOfExpr DDExpr\n+             -- Type of a DDlog variable.\n+           | TETypeOfVar Var\n+             -- We sometimes need to introduce extra type variables to model\n+             -- unknown type arguments of function calls.  We could use\n+             -- arbitrary auto-generated names for them, but to avoid a state\n+             -- monad, we use context and type argument name to uniquely\n+             -- identify the variable.\n+           | TETVar ECtx String\n+\n+teTuple :: [TExpr] -> TExpr\n+teTuple [t] = t\n+teTuple ts  = TETuple (Just $ length ts) (M.fromList $ mapIdx (\\t i -> (i, t)) ts)\n+\n+-- Type congruence, e.g., '|e| = BigInt'.\n+data Predicate = PEq TExpr TExpr\n+\n+(===) :: TExpr -> TExpr -> Constraint\n+(===) t1 t2 = CPredicate $ PEq t1 t2\n+\n+-- Type expression is a struct of the specified user-defined type: 'is_MyStruct |e|'.\n+deIsStruct :: (?d::DatalogProgram) => DDExpr -> String -> Constraint\n+deIsStruct de n = CPredicate $ deIsStruct_ de n\n+\n+deIsStruct_ :: (?d::DatalogProgram) => DDExpr -> String -> Predicate\n+deIsStruct_ de@(DDExpr ctx _) n =\n+    PEq (TETypeOfExpr de) (TEUser n (map (\\a -> TETVar ctx $ name a) tdefArgs))\n+    where\n+    TypeDef{..} = getType ?d n\n+\n+deIsBool :: DDExpr -> Constraint\n+deIsBool de = TETypeOfExpr de === TEBool\n+\n+deIsString :: DDExpr -> Constraint\n+deIsString de = CPredicate $ deIsString_ de\n+\n+deIsString_ :: DDExpr -> Predicate\n+deIsString_ de = PEq (TETypeOfExpr de) TEString\n+\n+deIsBit :: DDExpr -> Constraint\n+deIsBit de = CPredicate $ deIsBit_ de\n+\n+deIsBit_ :: DDExpr -> Predicate\n+deIsBit_ de = PEq (TETypeOfExpr de) (TEBit (IWidthOfExpr de))\n+\n+deIsSigned_ :: DDExpr -> Predicate\n+deIsSigned_ de = PEq (TETypeOfExpr de) (TESigned (IWidthOfExpr de))\n+\n+deIsBigInt_ :: DDExpr -> Predicate\n+deIsBigInt_ de = PEq (TETypeOfExpr de) TEBigInt\n+\n+deIsFloat :: DDExpr -> Constraint\n+deIsFloat de = CPredicate $ deIsFloat_ de\n+\n+deIsFloat_ :: DDExpr -> Predicate\n+deIsFloat_ de = PEq (TETypeOfExpr de) TEFloat\n+\n+deIsDouble_ :: DDExpr -> Predicate\n+deIsDouble_ de = PEq (TETypeOfExpr de) TEDouble\n+\n+deIsFP :: DDExpr -> Constraint\n+deIsFP de = CDisj $ deIsFP_ de\n+\n+deIsFP_ :: DDExpr -> [[Predicate]]\n+deIsFP_ de = [[deIsFloat_ de], [deIsDouble_ de]]\n+\n+-- 'is_bits t = is_Bit t || is_Signed t'.\n+deIsBits :: DDExpr -> Constraint\n+deIsBits de = CDisj $ deIsBits_ de\n+\n+deIsBits_ :: DDExpr -> [[Predicate]]\n+deIsBits_ de = [[deIsBit_ de], [deIsSigned_ de]]\n+\n+-- 'is_int t = is_bits t || is_BigInt t'.\n+deIsInt :: DDExpr -> Constraint\n+deIsInt de = CDisj $ deIsInt_ de\n+\n+deIsInt_ :: DDExpr -> [[Predicate]]\n+deIsInt_ de = deIsBits_ de ++ [[deIsBigInt_ de]]\n+\n+-- 'is_num t = is_int t || is_fp t'.\n+deIsNum :: DDExpr -> Constraint\n+deIsNum de = CDisj $ deIsInt_ de ++ deIsFP_ de\n+\n+-- Type expression is a shared reference type with specified inner type.\n+deIsSharedRef :: (?d::DatalogProgram) => DDExpr -> TExpr -> [Constraint]\n+deIsSharedRef de t =\n+    cdisj $ map (\\tdef -> [PEq (TETypeOfExpr de) (TEExtern (name tdef) [t])]) sref_tdefs\n+    where\n+    -- All shared reference types.\n+    sref_tdefs = filter (tdefGetSharedRefAttr ?d)\n+                 $ M.elems $ progTypedefs ?d\n+\n+-- Expression is a set (Set, Tinyset, Vec, ..) with specified element type.\n+deIsSet :: (?d::DatalogProgram) => DDExpr -> TExpr -> Constraint\n+deIsSet de t = CDisj $ map (deIsSet_ de t) sET_TYPES\n+\n+-- Expression is a collection with specified element type (when iterating using\n+-- for-loop).\n+deIsIterable :: (?d::DatalogProgram) => DDExpr -> TExpr -> Constraint\n+deIsIterable de t =\n+    CDisj $\n+    deIsGroup_ de t :\n+    deIsMap_ de t :\n+    map (deIsSet_ de t) sET_TYPES\n+\n+deIsSet_ :: (?d::DatalogProgram) => DDExpr -> TExpr -> String -> [Predicate]\n+deIsSet_ de t set_type =\n+    [PEq (TETypeOfExpr de) (TEExtern set_type [t])]\n+    where\n+    TypeDef{tdefArgs=[_],..} = getType ?d set_type\n+\n+deIsGroup_ :: (?d::DatalogProgram) => DDExpr -> TExpr -> [Predicate]\n+deIsGroup_ de@DDExpr{..} t =\n+    [PEq (TETypeOfExpr de) (TEExtern gROUP_TYPE [TETVar ddexprCtx (name k), t])]\n+    where\n+    TypeDef{tdefArgs=[k,_],..} = getType ?d gROUP_TYPE\n+\n+deIsMap_ :: (?d::DatalogProgram) => DDExpr -> TExpr -> [Predicate]\n+deIsMap_ de@DDExpr{..} t =\n+    [ PEq (TETypeOfExpr de) (TEExtern mAP_TYPE [TETVar ddexprCtx (name k), TETVar ddexprCtx (name v)])\n+    , PEq t (TETuple (Just 2) $ M.fromList [(0, TETVar ddexprCtx (name k)), (1, TETVar ddexprCtx (name v))])]\n+    where\n+    TypeDef{tdefArgs=[k,v],..} = getType ?d mAP_TYPE\n+\n+-- Convert type to a type expression, replacing type arguments ('A, 'B, ...)\n+-- with type constants 'TETArg \"A\", TETArg \"B\", ...'.  For example, when\n+-- generating type inference in the body of a function, we treat its type\n+-- arguments as constants.  Inferred types for variables and expressions inside\n+-- the body of the function may depend on this constants.", "originalCommit": "5cfc6cf9cb157f8bf8fef6e55dcf01ddb834931a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMDUyNw==", "url": "https://github.com/vmware/differential-datalog/pull/681#discussion_r436230527", "bodyText": "This is a bit confusing, but when doing type inference inside a function, this functions type arguments are constants in the sense that in the resulting typing variable types can be expressed in terms of these constants and we don't expect to assign concrete types to these constants.  When we call another generic function, it's a completely different situation. That function's type arguments are variables that we actually want to assign to concrete types, and so we model them as variables (TETVar), not constants.", "author": "ryzhyk", "createdAt": "2020-06-06T02:44:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5MTE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5MzM1NQ==", "url": "https://github.com/vmware/differential-datalog/pull/681#discussion_r436193355", "bodyText": "I was expecting a constraint on the lengths for the bits, but if you go bottom up it's not necessary", "author": "mbudiu-vmw", "createdAt": "2020-06-05T22:33:39Z", "path": "src/Language/DifferentialDatalog/TypeInference.hs", "diffHunk": "@@ -0,0 +1,637 @@\n+{-\n+Copyright (c) 2020 VMware, Inc.\n+SPDX-License-Identifier: MIT\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE.\n+-}\n+\n+{-# LANGUAGE FlexibleContexts, RecordWildCards, TupleSections, ImplicitParams #-}\n+\n+module Language.DifferentialDatalog.TypeInference(\n+    TypeInferenceResult(..),\n+    inferTypes\n+)\n+where\n+\n+import qualified Data.Map as M\n+import Control.Monad.State.Lazy\n+import Data.Maybe\n+\n+import Language.DifferentialDatalog.Attribute\n+import Language.DifferentialDatalog.ECtx\n+import Language.DifferentialDatalog.Expr\n+import Language.DifferentialDatalog.Name\n+import Language.DifferentialDatalog.NS\n+import Language.DifferentialDatalog.Ops\n+import Language.DifferentialDatalog.Rule\n+import Language.DifferentialDatalog.Syntax\n+import Language.DifferentialDatalog.Type\n+import Language.DifferentialDatalog.Util\n+import Language.DifferentialDatalog.Var\n+\n+data TypeInferenceResult = TypeInferenceOk (M.Map Var Type) (M.Map ECtx Type)\n+                         | TypeInferenceConflict\n+                         | TypeInferenceAmbiguity\n+\n+-- Uniquely identifies an expression in a DDlog program.\n+data DDExpr = DDExpr {ddexprCtx::ECtx, ddexprExpr::Expr}\n+\n+-- A type constraint is an atomic predicate or a disjuncion of conjuntions of\n+-- predicates.  We use a unification-based solver to resolv type constraints,\n+-- which does not handle arbitrary Boolean combination constraints, hence this\n+-- restricted structure.\n+data Constraint = CPredicate Predicate\n+                  -- Disjunction of conjunctions.  The first condition in each\n+                  -- conjunction must not overlap with others, e.g.,\n+                  -- 'c11 && c12 && ... ||\n+                  --  ...\n+                  --  cn1 && cn2 && ...'\n+                  --  where 'c1i' are all mutually exclusive.\n+                | CDisj [[Predicate]]\n+\n+cdisj :: [[Predicate]] -> [Constraint]\n+cdisj [ps] = map CPredicate ps\n+cdisj pss  = [CDisj pss]\n+\n+-- Integer expressions represent widths of bit and signed types.\n+data IExpr = -- Integer constant.\n+             IConst Int\n+             -- Integer variable equal to the width of a DDExpr.\n+           | IWidthOfExpr DDExpr\n+             -- Sum of two widths.\n+           | IPlus IExpr IExpr\n+\n+-- Type expression: an expression that returns a value of 'Type' sort.\n+data TExpr = TEBool\n+           | TEString\n+           | TEBigInt\n+           | TEBit IExpr\n+           | TESigned IExpr\n+           | TEFloat\n+           | TEDouble\n+             -- Tuple type whose size and field types may be only partially known.\n+           | TETuple (Maybe Int) (M.Map Int TExpr)\n+             -- User-defined type.\n+           | TEUser String [TExpr]\n+             -- Extern type.\n+           | TEExtern String [TExpr]\n+             -- In a function context only, a type argument of the function (e.g., 'A).\n+           | TETArg String\n+             -- Type of a DDlog expression.\n+           | TETypeOfExpr DDExpr\n+             -- Type of a DDlog variable.\n+           | TETypeOfVar Var\n+             -- We sometimes need to introduce extra type variables to model\n+             -- unknown type arguments of function calls.  We could use\n+             -- arbitrary auto-generated names for them, but to avoid a state\n+             -- monad, we use context and type argument name to uniquely\n+             -- identify the variable.\n+           | TETVar ECtx String\n+\n+teTuple :: [TExpr] -> TExpr\n+teTuple [t] = t\n+teTuple ts  = TETuple (Just $ length ts) (M.fromList $ mapIdx (\\t i -> (i, t)) ts)\n+\n+-- Type congruence, e.g., '|e| = BigInt'.\n+data Predicate = PEq TExpr TExpr\n+\n+(===) :: TExpr -> TExpr -> Constraint\n+(===) t1 t2 = CPredicate $ PEq t1 t2\n+\n+-- Type expression is a struct of the specified user-defined type: 'is_MyStruct |e|'.\n+deIsStruct :: (?d::DatalogProgram) => DDExpr -> String -> Constraint\n+deIsStruct de n = CPredicate $ deIsStruct_ de n\n+\n+deIsStruct_ :: (?d::DatalogProgram) => DDExpr -> String -> Predicate\n+deIsStruct_ de@(DDExpr ctx _) n =\n+    PEq (TETypeOfExpr de) (TEUser n (map (\\a -> TETVar ctx $ name a) tdefArgs))\n+    where\n+    TypeDef{..} = getType ?d n\n+\n+deIsBool :: DDExpr -> Constraint\n+deIsBool de = TETypeOfExpr de === TEBool\n+\n+deIsString :: DDExpr -> Constraint\n+deIsString de = CPredicate $ deIsString_ de\n+\n+deIsString_ :: DDExpr -> Predicate\n+deIsString_ de = PEq (TETypeOfExpr de) TEString\n+\n+deIsBit :: DDExpr -> Constraint\n+deIsBit de = CPredicate $ deIsBit_ de\n+\n+deIsBit_ :: DDExpr -> Predicate\n+deIsBit_ de = PEq (TETypeOfExpr de) (TEBit (IWidthOfExpr de))\n+\n+deIsSigned_ :: DDExpr -> Predicate\n+deIsSigned_ de = PEq (TETypeOfExpr de) (TESigned (IWidthOfExpr de))\n+\n+deIsBigInt_ :: DDExpr -> Predicate\n+deIsBigInt_ de = PEq (TETypeOfExpr de) TEBigInt\n+\n+deIsFloat :: DDExpr -> Constraint\n+deIsFloat de = CPredicate $ deIsFloat_ de\n+\n+deIsFloat_ :: DDExpr -> Predicate\n+deIsFloat_ de = PEq (TETypeOfExpr de) TEFloat\n+\n+deIsDouble_ :: DDExpr -> Predicate\n+deIsDouble_ de = PEq (TETypeOfExpr de) TEDouble\n+\n+deIsFP :: DDExpr -> Constraint\n+deIsFP de = CDisj $ deIsFP_ de\n+\n+deIsFP_ :: DDExpr -> [[Predicate]]\n+deIsFP_ de = [[deIsFloat_ de], [deIsDouble_ de]]\n+\n+-- 'is_bits t = is_Bit t || is_Signed t'.\n+deIsBits :: DDExpr -> Constraint\n+deIsBits de = CDisj $ deIsBits_ de\n+\n+deIsBits_ :: DDExpr -> [[Predicate]]\n+deIsBits_ de = [[deIsBit_ de], [deIsSigned_ de]]\n+\n+-- 'is_int t = is_bits t || is_BigInt t'.\n+deIsInt :: DDExpr -> Constraint\n+deIsInt de = CDisj $ deIsInt_ de\n+\n+deIsInt_ :: DDExpr -> [[Predicate]]\n+deIsInt_ de = deIsBits_ de ++ [[deIsBigInt_ de]]\n+\n+-- 'is_num t = is_int t || is_fp t'.\n+deIsNum :: DDExpr -> Constraint\n+deIsNum de = CDisj $ deIsInt_ de ++ deIsFP_ de\n+\n+-- Type expression is a shared reference type with specified inner type.\n+deIsSharedRef :: (?d::DatalogProgram) => DDExpr -> TExpr -> [Constraint]\n+deIsSharedRef de t =\n+    cdisj $ map (\\tdef -> [PEq (TETypeOfExpr de) (TEExtern (name tdef) [t])]) sref_tdefs\n+    where\n+    -- All shared reference types.\n+    sref_tdefs = filter (tdefGetSharedRefAttr ?d)\n+                 $ M.elems $ progTypedefs ?d\n+\n+-- Expression is a set (Set, Tinyset, Vec, ..) with specified element type.\n+deIsSet :: (?d::DatalogProgram) => DDExpr -> TExpr -> Constraint\n+deIsSet de t = CDisj $ map (deIsSet_ de t) sET_TYPES\n+\n+-- Expression is a collection with specified element type (when iterating using\n+-- for-loop).\n+deIsIterable :: (?d::DatalogProgram) => DDExpr -> TExpr -> Constraint\n+deIsIterable de t =\n+    CDisj $\n+    deIsGroup_ de t :\n+    deIsMap_ de t :\n+    map (deIsSet_ de t) sET_TYPES\n+\n+deIsSet_ :: (?d::DatalogProgram) => DDExpr -> TExpr -> String -> [Predicate]\n+deIsSet_ de t set_type =\n+    [PEq (TETypeOfExpr de) (TEExtern set_type [t])]\n+    where\n+    TypeDef{tdefArgs=[_],..} = getType ?d set_type\n+\n+deIsGroup_ :: (?d::DatalogProgram) => DDExpr -> TExpr -> [Predicate]\n+deIsGroup_ de@DDExpr{..} t =\n+    [PEq (TETypeOfExpr de) (TEExtern gROUP_TYPE [TETVar ddexprCtx (name k), t])]\n+    where\n+    TypeDef{tdefArgs=[k,_],..} = getType ?d gROUP_TYPE\n+\n+deIsMap_ :: (?d::DatalogProgram) => DDExpr -> TExpr -> [Predicate]\n+deIsMap_ de@DDExpr{..} t =\n+    [ PEq (TETypeOfExpr de) (TEExtern mAP_TYPE [TETVar ddexprCtx (name k), TETVar ddexprCtx (name v)])\n+    , PEq t (TETuple (Just 2) $ M.fromList [(0, TETVar ddexprCtx (name k)), (1, TETVar ddexprCtx (name v))])]\n+    where\n+    TypeDef{tdefArgs=[k,v],..} = getType ?d mAP_TYPE\n+\n+-- Convert type to a type expression, replacing type arguments ('A, 'B, ...)\n+-- with type constants 'TETArg \"A\", TETArg \"B\", ...'.  For example, when\n+-- generating type inference in the body of a function, we treat its type\n+-- arguments as constants.  Inferred types for variables and expressions inside\n+-- the body of the function may depend on this constants.\n+typeToTExpr :: (?d::DatalogProgram) => Type -> TExpr\n+typeToTExpr t = typeToTExpr_ Nothing t\n+\n+-- Convert type to a type expression, replacing type arguments with fresh\n+-- variables.  The 'ctx' argument is used to generate unique type variable\n+-- identifiers.  For example, when doing type inference for a function call\n+-- expression, we introduce fresh type variables for type arguments of the\n+-- function.\n+typeToTExpr' :: (?d::DatalogProgram) => ECtx -> Type -> TExpr\n+typeToTExpr' ctx t = typeToTExpr_ (Just ctx) t\n+\n+typeToTExpr_ :: (?d::DatalogProgram) => Maybe ECtx -> Type -> TExpr\n+typeToTExpr_ mctx t = typeToTExpr__ mctx (typ'' ?d t)\n+\n+typeToTExpr__ :: (?d::DatalogProgram) => Maybe ECtx -> Type -> TExpr\n+typeToTExpr__ _         TBool{}      = TEBool\n+typeToTExpr__ _         TInt{}       = TEBigInt\n+typeToTExpr__ _         TString{}    = TEString\n+typeToTExpr__ _         TBit{..}     = TEBit $ IConst typeWidth\n+typeToTExpr__ _         TSigned{..}  = TESigned $ IConst typeWidth\n+typeToTExpr__ _         TFloat{}     = TEFloat\n+typeToTExpr__ _         TDouble{}    = TEDouble\n+typeToTExpr__ mctx      TTuple{..}   = TETuple (Just $ length typeTupArgs) (M.fromList $ mapIdx (\\a i -> (i, typeToTExpr_ mctx (typ a))) typeTupArgs)\n+typeToTExpr__ mctx      TUser{..}    = TEUser typeName $ map (typeToTExpr_ mctx) typeArgs\n+typeToTExpr__ Nothing   TVar{..}     = TETArg tvarName\n+typeToTExpr__ (Just c)  TVar{..}     = TETVar c tvarName\n+typeToTExpr__ mctx      TOpaque{..}  = TEExtern typeName $ map (typeToTExpr_ mctx) typeArgs\n+typeToTExpr__ _         t@TStruct{}  = error $ \"typeToTExpr__: unexpected '\" ++ show t ++ \"'\"\n+\n+-- Main type inference function.  Takes one or more expressions an tries to\n+-- infer types for all variables and subexpressions.\n+--\n+-- The input argument to this function is one of:\n+-- * The body of a function.\n+-- * Index expression.\n+-- * Primary key expression.\n+-- * All expressions in a rule, including RHS and LHS literals.\n+inferTypes :: DatalogProgram -> [DDExpr] -> TypeInferenceResult\n+inferTypes d es =\n+    let ?d = d in\n+    let ctx_constr = concatMap contextConstraints es\n+        expr_constr = concatMap exprConstraints es\n+        all_constr = ctx_constr ++ expr_constr\n+    in solveTypeConstraints all_constr\n+\n+solveTypeConstraints :: [Constraint] -> TypeInferenceResult\n+solveTypeConstraints _ = error \"solveTypeConstraints: not implemented\"\n+\n+{- Context-specific constraints. -}\n+\n+-- When evaluating the body of a function:\n+-- 'function f(arg1: t1, ..., argn: tn): t0 { e }'\n+-- the following type constraints are added:\n+-- '|e| = t0, |argi|=ti'.\n+contextConstraints :: (?d::DatalogProgram) => DDExpr -> [Constraint]\n+contextConstraints de@(DDExpr (CtxFunc f@Function{..}) _) =\n+    (TETypeOfExpr de === typeToTExpr funcType) :\n+    (map (\\a -> TETypeOfVar (ArgVar f (name a)) === typeToTExpr (typ a)) funcArgs)\n+\n+-- When evaluating index expression:\n+-- 'index I(v1: t1, .., vn: tn) on R[e]',\n+-- the following type constraints are added:\n+-- '|vi| = |ti|, |e| = reltype_R'.\n+contextConstraints de@(DDExpr (CtxIndex idx@Index{..}) _) =\n+    (TETypeOfExpr de === typeToTExpr (typ $ getRelation ?d $ atomRelation idxAtom)) :\n+    (map (\\v -> TETypeOfVar (IdxVar idx (name v)) === typeToTExpr (typ v)) idxVars)\n+\n+-- When evaluating primary key expression:\n+-- 'relation R(..) primary key (x) e',\n+-- the following type constraints are added:\n+-- '|x| = reltype_R.\n+contextConstraints (DDExpr (CtxKey rel) _) =\n+    [TETypeOfVar (KeyVar rel) === typeToTExpr (typ rel)]\n+\n+-- When evaluating expression e in a rule literal or the head of a rule:\n+-- R[e], the following type constraint is added:\n+-- '|e| = reltype_R'.\n+contextConstraints de@(DDExpr (CtxRuleRAtom rl i) _) =\n+    [TETypeOfExpr de === typeToTExpr (typ $ getRelation ?d $ atomRelation a)]\n+    where a = rhsAtom $ ruleRHS rl !! i\n+\n+contextConstraints de@(DDExpr (CtxRuleL rl i) _) =\n+    [TETypeOfExpr de === typeToTExpr (typ $ getRelation ?d $ atomRelation a)]\n+    where a = ruleLHS rl !! i\n+\n+-- When evaluating expression e in a filter clause of a rule: |e|=Bool.\n+contextConstraints de@(DDExpr (CtxRuleRCond rl i) _) | rhsIsFilterCondition $ ruleRHS rl !! i =\n+    [deIsBool de]\n+                                                     | otherwise = []\n+\n+-- When evaluating aggregate: 'var v = Aggregate((v1,..,vn), f(e))'\n+-- where 'function f<'A1,...,'Am>(g: Group<K,V>): T', where K,V,T may\n+-- depend on type arguments 'Ai', the following type constraints are\n+-- added:\n+-- (|v1|,...,|vn|)=K,\n+-- |e| = V,\n+-- |v| = T\n+contextConstraints de@(DDExpr ctx@(CtxRuleRAggregate rl i) _) =\n+    [ teTuple (map (\\v -> TETypeOfVar (getVar ?d ctx v)) rhsGroupBy) === typeToTExpr' ctx ktype\n+    , TETypeOfExpr de === typeToTExpr' ctx vtype\n+    , TETypeOfVar (AggregateVar rl i) === typeToTExpr' ctx ret_type]\n+    where\n+    RHSAggregate{..} = ruleRHS rl !! i\n+    Function{funcArgs = [grp_type], funcType = ret_type} = getFunc ?d rhsAggFunc\n+    TOpaque{typeArgs = [ktype, vtype]} = typ' ?d grp_type\n+\n+-- When evaluating 'var v = FlatMap(e)'\n+-- the following type constraints are added:\n+-- |v| = iterator_type(|e|)\n+contextConstraints de@(DDExpr (CtxRuleRFlatMap rl i) _) =\n+    [deIsSet de $ TETypeOfVar (FlatMapVar rl i)]\n+\n+-- When evaluating expression e in an Inspect clause of a rule:\n+-- |e| = Tuple0, |var ddlog_weight| = Bit 64, |var ddlog_iter| = ....\n+contextConstraints de@(DDExpr (CtxRuleRInspect rl _) _) =\n+    [ TETypeOfExpr de === TETuple (Just 0) M.empty\n+    , TETypeOfVar WeightVar === typeToTExpr (tUser wEIGHT_TYPE [])\n+    , if ruleIsRecursive ?d rl\n+         then TETypeOfVar (TSVar rl) === typeToTExpr (tUser nESTED_TS_TYPE [])\n+         else TETypeOfVar (TSVar rl) === typeToTExpr (tUser ePOCH_TYPE []) ]\n+\n+contextConstraints (DDExpr ctx _) =\n+    error $ \"contextConstraints called in unexpected context \" ++ show ctx\n+\n+{- Encode type constraints for an expression. -}\n+\n+exprConstraints :: (?d::DatalogProgram) => DDExpr -> [Constraint]\n+exprConstraints (DDExpr ctx e) =\n+    execState (exprTraverseCtxM exprConstraints' ctx e) []\n+\n+exprConstraints' :: (?d::DatalogProgram) => ECtx -> ENode -> State [Constraint] ()\n+exprConstraints' ctx e = do\n+    let ddexpr = DDExpr ctx $ E e\n+    let constr = exprConstraints_ ddexpr\n+    modify (++ constr)\n+\n+-- Variable reference expression has the same type as the variable.\n+exprConstraints_ :: (?d::DatalogProgram) => DDExpr -> [Constraint]\n+exprConstraints_ de@(DDExpr ctx (E (EVar _ v))) =\n+    [TETypeOfExpr de === TETypeOfVar (getVar ?d ctx v)]\n+\n+-- Boolean literal.\n+exprConstraints_ de@(DDExpr _ (E EBool{})) =\n+    [deIsBool de]\n+\n+-- String literal.\n+exprConstraints_ de@(DDExpr _ (E EString{})) =\n+    [deIsString de]\n+\n+-- Unsigned bitvector literal.\n+exprConstraints_ de@(DDExpr _ (E EBit{..})) =\n+    [TETypeOfExpr de === TEBit (IConst exprWidth)]\n+\n+-- Signed bitvector literal.\n+exprConstraints_ de@(DDExpr _ (E ESigned{..})) =\n+    [TETypeOfExpr de === TESigned (IConst exprWidth)]\n+\n+-- Integer expression with unspecified width can be a signed or unsigned\n+-- bitvector or a bigint.  All of these cases are captured by 'deIsInt'.\n+exprConstraints_ de@(DDExpr _ (E EInt{})) =\n+    [deIsInt de]\n+\n+-- 32-bit FP literal.\n+exprConstraints_ de@(DDExpr _ (E EFloat{})) =\n+    [deIsFloat de]\n+\n+-- 64-bit or unknown width FP literal.\n+exprConstraints_ de@(DDExpr _ (E EDouble{})) =\n+    [deIsFP de]\n+\n+-- f(e1,...,en)\n+--\n+-- |de|=f_ret |a1|...|aj| and\n+-- |e1|=f_arg_1 |a1|...|aj| and ... and |en|=f_arg_n |a1|...|aj|, where |a1|...|aj| are fresh type variables\n+exprConstraints_ de@(DDExpr ctx (E e@EApply{..})) =\n+    (TETypeOfExpr de === typeToTExpr' ctx funcType) :\n+    (mapIdx (\\(farg, earg) i -> TETypeOfExpr (DDExpr (CtxApply e ctx i) earg) === typeToTExpr' ctx (typ farg))\n+            $ zip funcArgs exprArgs)\n+    where\n+    Function{..} = getFunc ?d exprFunc\n+\n+-- Struct field access: 'e1.f', where field 'f' is present in user-defined\n+-- structs in 'S1',...,'Sn'.\n+--\n+-- 'is_S1 |e1| and |e| = |e1.f|\n+--  or .. or\n+--  is_Sn |e1| and |e| = |e1.f|'\n+exprConstraints_ de@(DDExpr ctx (E e@EField{..})) =\n+    cdisj\n+    $ map (\\TypeDef{tdefType = Just t,..} ->\n+            deIsStruct_ estruct tdefName : [PEq (TETypeOfExpr de) (typeToTExpr' ctx' (typ $ structGetField t exprField))])\n+      candidates\n+    where\n+    ctx' = CtxField e ctx\n+    estruct = DDExpr ctx' exprStruct\n+    -- All structs that have the field.\n+    candidates = filter (\\tdef -> isJust $ structLookupField (fromJust $ tdefType tdef) exprField)\n+               $ filter (isJust . tdefType)\n+               $ M.elems\n+               $ progTypedefs ?d\n+\n+-- Tuple field access: 'e.N'.\n+--\n+-- 'tuple_has_field_<i+1> |e1| and |e|=tupleFieldi |e1|'\n+exprConstraints_ de@(DDExpr ctx (E e@ETupField{..})) =\n+    [TETypeOfExpr etuple === TETuple Nothing (M.singleton exprTupField $ TETypeOfExpr de)]\n+    where\n+    etuple = DDExpr (CtxTupField e ctx) exprTuple\n+\n+-- Struct expression: 'Cons{.f1=e1,..,.fn=en}', where 'Cons' is a constructor of\n+-- type 'MyStruct'\n+--\n+-- 'is_MyStruct |de| and |e1|=MyStruct_f1 |e| and ... and |en| = MyStruct_fn |e|'\n+exprConstraints_ de@(DDExpr ctx (E e@EStruct{..})) =\n+    deIsStruct de tdefName :\n+    (map (\\(arg, efield) -> TETypeOfExpr (DDExpr (CtxStruct e ctx (name arg)) efield) === typeToTExpr' ctx (typ arg))\n+         $ zip consArgs $ map snd exprStructFields)\n+    where\n+    Constructor{..} = getConstructor ?d exprConstructor\n+    TypeDef{..} = consType ?d exprConstructor\n+\n+-- Tuple expression '(e1,..,en)'.\n+--\n+-- '|e| = (|e1|,...,|en|)'.\n+exprConstraints_ de@(DDExpr ctx (E e@ETuple{..})) =\n+    [TETypeOfExpr de === TETuple (Just $ length exprTupleFields) (M.fromList $ mapIdx (\\e' i -> (i, TETypeOfExpr (DDExpr (CtxTuple e ctx i) e'))) exprTupleFields)]\n+\n+-- Bit slice 'e1[h:l]'\n+--\n+-- 'is_Bit(|e1|) and |e|=Bit (h-l+1)'\n+--\n+-- TODO: additional constraint 'bitWidth |e1| >= h-l+1 and'\n+-- should be enforced outside of the type inference engine.\n+exprConstraints_ de@(DDExpr ctx (E e@ESlice{..})) =\n+    [ TETypeOfExpr de === TEBit (IConst w)\n+    , deIsBit ebits]\n+    where\n+    ebits = DDExpr (CtxSlice e ctx) exprOp\n+    w = exprH - exprL + 1\n+\n+-- Match 'match(e0) {e1->g1, .., en->gn}'\n+--\n+-- '|e0| =|e1|=..=|en| and |g1|=...=|gn|=|e|'\n+exprConstraints_ de@(DDExpr ctx (E e@EMatch{..})) =\n+    concat $ mapIdx (\\(ei, gi) i ->\n+                      [ TETypeOfExpr mexpr === TETypeOfExpr (DDExpr (CtxMatchPat e ctx i) ei)\n+                      , TETypeOfExpr de === TETypeOfExpr (DDExpr (CtxMatchVal e ctx i) gi) ])\n+                    exprCases\n+    where\n+    mexpr = DDExpr (CtxMatchExpr e ctx) exprMatchExpr\n+\n+-- Variable declaration: 'var v'\n+--\n+-- '|e|=|var v|'\n+exprConstraints_ de@(DDExpr ctx (E e@EVarDecl{})) =\n+    [TETypeOfExpr de === TETypeOfVar (ExprVar ctx e)]\n+\n+-- Sequence 'e1;e2'\n+--\n+-- '|e|=|e2|'\n+exprConstraints_ de@(DDExpr ctx (E e@ESeq{..})) =\n+    [TETypeOfExpr de === TETypeOfExpr (DDExpr (CtxSeq2 e ctx) exprRight) ]\n+\n+--- 'if (e1){e2}else{e3}'\n+--\n+-- '|e1|=Bool and |e2|=|e3|'\n+exprConstraints_ de@(DDExpr ctx (E e@EITE{..})) =\n+    [ TETypeOfExpr de === TEBool\n+    , TETypeOfExpr (DDExpr (CtxITEThen e ctx) exprThen) === TETypeOfExpr (DDExpr (CtxITEElse e ctx) exprElse) ]\n+\n+-- 'for (v in e1) {e2}'\n+--\n+-- 'is_iterable |e1| and |var v|=iterator_type |e1| and |e| = ()'\n+exprConstraints_ de@(DDExpr ctx (E e@EFor{..})) =\n+    [ deIsIterable (DDExpr (CtxForIter e ctx) exprIter) (TETypeOfVar $ ForVar ctx e)\n+    , TETypeOfExpr de === TETuple (Just 0) M.empty ]\n+\n+-- Assignment: 'e1=e2'.\n+--\n+-- '|e|=Tuple0 and |e1|=|e2|'.\n+exprConstraints_ de@(DDExpr ctx (E e@ESet{..})) =\n+    [ TETypeOfExpr de === TETuple (Just 0) M.empty\n+    , TETypeOfExpr (DDExpr (CtxSetL e ctx) exprLVal) === TETypeOfExpr (DDExpr (CtxSetR e ctx) exprRVal) ]\n+\n+-- 'return e1'\n+--\n+-- '|e1|=retType'\n+exprConstraints_ (DDExpr ctx (E e@EReturn{..})) =\n+    [TETypeOfExpr (DDExpr (CtxReturn e ctx) exprRetVal) === typeToTExpr funcType]\n+    where\n+    Just Function{..} = ctxInFunc ctx\n+\n+-- Binary operator 'e1 op e2', where `op` is one of '==, !=, <, >, <=, >='.\n+--\n+-- '|e1| = |e2| ans |e| = Bool'\n+exprConstraints_ de@(DDExpr ctx (E e@EBinOp{..})) | elem exprBOp [Eq, Neq, Lt, Lte, Gt, Gte] =\n+    [ TETypeOfExpr l === TETypeOfExpr r\n+    , TETypeOfExpr de === TEBool ]\n+\n+-- Binary operator 'e1 op e2', where `op` is one of '&&, ||, =>'.\n+--\n+-- '|e1| = |e2| = Bool and |e| == Bool'\n+                                                | elem exprBOp [And, Or, Impl] =\n+    [ TETypeOfExpr l === TETypeOfExpr (DDExpr (CtxBinOpR e ctx) exprRight)\n+    , TETypeOfExpr l === TEBool\n+    , TETypeOfExpr de === TEBool ]\n+\n+-- Binary operator 'e1 op e2', where `op` is one of '+, -, *. /'.\n+--\n+-- '|e| = |e1| = |e2| and is_num|e1|'\n+                                                | elem exprBOp [Plus, Minus, Times, Div] =\n+    [ TETypeOfExpr l === TETypeOfExpr r\n+    , TETypeOfExpr de === TETypeOfExpr l\n+    , deIsNum $ DDExpr (CtxBinOpL e ctx) exprLeft ]\n+\n+-- Binary operator 'e1 % e2'.\n+--\n+-- '|e1| = |e2| and is_int(|e1|) and |e| = |e1|'\n+                                                | exprBOp == Mod =\n+    [ TETypeOfExpr l === TETypeOfExpr r\n+    , deIsInt l\n+    , TETypeOfExpr de === TETypeOfExpr l ]\n+\n+-- Binary operator 'e1 op e2', where `op` is one of '<<, >>'.\n+--\n+-- 'is_int |e1| and is_int |e2| and |e| = |e1|'\n+                                                | elem exprBOp [Plus, Minus] =\n+    [ deIsInt l\n+    , deIsInt r\n+    , TETypeOfExpr de === TETypeOfExpr l ]\n+\n+-- Binary operator 'e1 op e2', where `op` is one of '|,&,^'.\n+--\n+-- '|e| = |e1| = |e2| and is_bits|e1|'\n+                                                | elem exprBOp [BOr, BAnd, BXor] =\n+    [ TETypeOfExpr l === TETypeOfExpr r\n+    , TETypeOfExpr de === TETypeOfExpr l\n+    , deIsBits l ]\n+\n+-- Binary operator 'e1 ++ e2'.\n+--\n+-- is_String(|e1|) and is_String(|e2|) or is_Bit |e1| and is_Bit |e2|", "originalCommit": "5cfc6cf9cb157f8bf8fef6e55dcf01ddb834931a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMDcxOQ==", "url": "https://github.com/vmware/differential-datalog/pull/681#discussion_r436230719", "bodyText": "you're right, and this is what the implementation actually does. I will update the comment.", "author": "ryzhyk", "createdAt": "2020-06-06T02:47:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5MzM1NQ=="}], "type": "inlineReview"}]}