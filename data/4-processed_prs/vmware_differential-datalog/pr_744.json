{"pr_number": 744, "pr_title": "Rust API test.", "pr_createdAt": "2020-08-21T06:01:59Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/744", "timeline": [{"oid": "68405e13637262bb6268d306556ead63063f413e", "url": "https://github.com/vmware/differential-datalog/commit/68405e13637262bb6268d306556ead63063f413e", "message": "Rust API test.\n\nA heavily commented Rust API client program that can be used as a\ntutorial for learning the Rust API as well as a template for other Rust\nclients.\n\nThe API is currently really clumsy and lacks any kind of ergonomisc.\nIt will hopefully improve in the future, but for now we at least\ndocument it as is, so that people can build their own Rust clients.", "committedDate": "2020-08-21T06:02:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg4NjAyMQ==", "url": "https://github.com/vmware/differential-datalog/pull/744#discussion_r474886021", "bodyText": "\"in execution\"", "author": "mbudiu-vmw", "createdAt": "2020-08-21T19:20:21Z", "path": "test/datalog_tests/rust_api_test/src/main.rs", "diffHunk": "@@ -0,0 +1,172 @@\n+use std::borrow::Cow;\n+\n+// The main auto-generated crate `<progname>_ddlog` declares\n+// `HDDlog` type that serves as a reference to a running DDlog program.\n+// `HDDlog` implements `trait differential_datalog::DDlog` (see below).\n+use tutorial_ddlog::api::HDDlog;\n+\n+// The differential_datalog crate contains the DDlog runtime that is\n+// the same for all DDlog programs and simply gets copied to each generated\n+// DDlog workspace unmodified (this will change in future releases).\n+use differential_datalog::DDlog; // Trait that must be implemented by an instance of a DDlog program.\n+use differential_datalog::DeltaMap; // Type that represents a set of changes to DDlog relations.\n+                                    // Returned by `DDlog::transaction_commit_dump_changes()`.\n+use differential_datalog::ddval::DDValue; // Generic type that wraps all DDlog value.\n+use differential_datalog::ddval::DDValConvert; // Trait to convert Rust types to/from DDValue.\n+                                               // All types in the `value::Value` module (see below)\n+                                               // implement this trait.\n+use differential_datalog::program::RelId; // Numeric relations id.\n+use differential_datalog::program::Update; // Type-safe representation of a DDlog command (insert/delete_val/delete_key/...)\n+\n+// The `record` module defines dynamically typed representation of DDlog values and commands.\n+use differential_datalog::record::Record; // Dynamically typed representation of DDlog values.\n+use differential_datalog::record::RelIdentifier; // Relation identifier: either `RelId` or `Cow<str>`g.\n+use differential_datalog::record::UpdCmd; // Dynamically typed representation of DDlog command.\n+\n+// The auto-generated `types` crate contains Rust types that correspond to user-defined DDlog\n+// types, one for each typedef and each relation in the DDlog program.\n+use types::*;\n+\n+// The auto-generated `value` crate contains\n+// * The `Value` model that define a wrapper type for each input and\n+//   output relation in the DDlog program, as well as\n+// * `enum Relations` that enumerates program relations\n+// * Several functions that convert between numeric relation id's and\n+//   symbolic names.\n+use value::relid2name;\n+use value::Relations;\n+use value::Value;\n+\n+fn main() -> Result<(), String> {\n+\n+    fn cb(_rel: usize, _rec: &Record, _w: isize) {}\n+\n+    // Instantiate a DDlog program.\n+    // Returns a handle to the program and initial contents of output relations.\n+    // Arguments\n+    // - number of worker threads (you typically want 1 or 2).\n+    // - Boolean flag that indicates whether DDlog will track the complete snapshot\n+    //   of output relations.  Should only be used if you plan to dump `dump_table`\n+    //   their contents using `HDDlog::dump_table()`.\n+    // - Callback - obsolete and will disappear in future releases.\n+    let (mut hddlog, init_state) = HDDlog::run(1, false, cb)?;\n+\n+    println!(\"Initial state\");\n+    dump_delta(&init_state);\n+\n+    /*\n+     * We perform two transactions that insert in the following two DDlog relations\n+     * (see `tutorial.dl`):\n+     *\n+     * ```\n+     * input relation Word1(word: string, cat: Category)\n+     * input relation Word2(word: string, cat: Category)\n+     * ```\n+     *\n+     * The first transactio uses the type-safe API, which should be preferred when\n+     * writing a client bound to a specific known DDlog program.\n+     *\n+     * The second transaction uses the dynamically typed record API.\n+     */\n+\n+    // There can be at most one transaction at a time.  Attempt to start anothe transaction", "originalCommit": "68405e13637262bb6268d306556ead63063f413e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg4NzA1NA==", "url": "https://github.com/vmware/differential-datalog/pull/744#discussion_r474887054", "bodyText": "how about a clear reference to the dl program that is being invoked by this rust program?\nInsert here the path to tutorial.dl", "author": "mbudiu-vmw", "createdAt": "2020-08-21T19:21:39Z", "path": "test/datalog_tests/rust_api_test/src/main.rs", "diffHunk": "@@ -0,0 +1,172 @@\n+use std::borrow::Cow;\n+\n+// The main auto-generated crate `<progname>_ddlog` declares", "originalCommit": "68405e13637262bb6268d306556ead63063f413e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg4NzM3MQ==", "url": "https://github.com/vmware/differential-datalog/pull/744#discussion_r474887371", "bodyText": "implements", "author": "mbudiu-vmw", "createdAt": "2020-08-21T19:22:02Z", "path": "test/datalog_tests/rust_api_test/src/main.rs", "diffHunk": "@@ -0,0 +1,172 @@\n+use std::borrow::Cow;\n+\n+// The main auto-generated crate `<progname>_ddlog` declares\n+// `HDDlog` type that serves as a reference to a running DDlog program.\n+// `HDDlog` implements `trait differential_datalog::DDlog` (see below).\n+use tutorial_ddlog::api::HDDlog;\n+\n+// The differential_datalog crate contains the DDlog runtime that is\n+// the same for all DDlog programs and simply gets copied to each generated\n+// DDlog workspace unmodified (this will change in future releases).\n+use differential_datalog::DDlog; // Trait that must be implemented by an instance of a DDlog program.\n+use differential_datalog::DeltaMap; // Type that represents a set of changes to DDlog relations.\n+                                    // Returned by `DDlog::transaction_commit_dump_changes()`.\n+use differential_datalog::ddval::DDValue; // Generic type that wraps all DDlog value.\n+use differential_datalog::ddval::DDValConvert; // Trait to convert Rust types to/from DDValue.\n+                                               // All types in the `value::Value` module (see below)\n+                                               // implement this trait.\n+use differential_datalog::program::RelId; // Numeric relations id.\n+use differential_datalog::program::Update; // Type-safe representation of a DDlog command (insert/delete_val/delete_key/...)\n+\n+// The `record` module defines dynamically typed representation of DDlog values and commands.\n+use differential_datalog::record::Record; // Dynamically typed representation of DDlog values.\n+use differential_datalog::record::RelIdentifier; // Relation identifier: either `RelId` or `Cow<str>`g.\n+use differential_datalog::record::UpdCmd; // Dynamically typed representation of DDlog command.\n+\n+// The auto-generated `types` crate contains Rust types that correspond to user-defined DDlog\n+// types, one for each typedef and each relation in the DDlog program.\n+use types::*;\n+\n+// The auto-generated `value` crate contains\n+// * The `Value` model that define a wrapper type for each input and\n+//   output relation in the DDlog program, as well as\n+// * `enum Relations` that enumerates program relations\n+// * Several functions that convert between numeric relation id's and\n+//   symbolic names.\n+use value::relid2name;\n+use value::Relations;\n+use value::Value;\n+\n+fn main() -> Result<(), String> {\n+\n+    fn cb(_rel: usize, _rec: &Record, _w: isize) {}\n+\n+    // Instantiate a DDlog program.\n+    // Returns a handle to the program and initial contents of output relations.\n+    // Arguments\n+    // - number of worker threads (you typically want 1 or 2).\n+    // - Boolean flag that indicates whether DDlog will track the complete snapshot\n+    //   of output relations.  Should only be used if you plan to dump `dump_table`\n+    //   their contents using `HDDlog::dump_table()`.\n+    // - Callback - obsolete and will disappear in future releases.\n+    let (mut hddlog, init_state) = HDDlog::run(1, false, cb)?;\n+\n+    println!(\"Initial state\");\n+    dump_delta(&init_state);\n+\n+    /*\n+     * We perform two transactions that insert in the following two DDlog relations\n+     * (see `tutorial.dl`):\n+     *\n+     * ```\n+     * input relation Word1(word: string, cat: Category)\n+     * input relation Word2(word: string, cat: Category)\n+     * ```\n+     *\n+     * The first transactio uses the type-safe API, which should be preferred when\n+     * writing a client bound to a specific known DDlog program.\n+     *\n+     * The second transaction uses the dynamically typed record API.\n+     */\n+\n+    // There can be at most one transaction at a time.  Attempt to start anothe transaction\n+    // when there is one in progress will return an error.\n+    hddlog.transaction_start()?;\n+\n+    // A transaction can consist of multiple `apply_valupdates()` calls, each taking\n+    // multiple updates.  An update inserts, deletes or modifies a record in a DDlog\n+    // relation.\n+    let updates = vec![\n+        Update::Insert { // We are going to insert..\n+            relid: Relations::Word1 as RelId, // .. into relation with this Id.\n+            // `Word1` type, declared in the `types` crate has the same fields as\n+            // the corresponding DDlog type.\n+            // `Value::Word1` from the `value` crate is a wrapper around this type\n+            // that implement `into_ddvalue()`", "originalCommit": "68405e13637262bb6268d306556ead63063f413e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg4NzY2OA==", "url": "https://github.com/vmware/differential-datalog/pull/744#discussion_r474887668", "bodyText": "some comment on the errors that could occur?", "author": "mbudiu-vmw", "createdAt": "2020-08-21T19:22:26Z", "path": "test/datalog_tests/rust_api_test/src/main.rs", "diffHunk": "@@ -0,0 +1,172 @@\n+use std::borrow::Cow;\n+\n+// The main auto-generated crate `<progname>_ddlog` declares\n+// `HDDlog` type that serves as a reference to a running DDlog program.\n+// `HDDlog` implements `trait differential_datalog::DDlog` (see below).\n+use tutorial_ddlog::api::HDDlog;\n+\n+// The differential_datalog crate contains the DDlog runtime that is\n+// the same for all DDlog programs and simply gets copied to each generated\n+// DDlog workspace unmodified (this will change in future releases).\n+use differential_datalog::DDlog; // Trait that must be implemented by an instance of a DDlog program.\n+use differential_datalog::DeltaMap; // Type that represents a set of changes to DDlog relations.\n+                                    // Returned by `DDlog::transaction_commit_dump_changes()`.\n+use differential_datalog::ddval::DDValue; // Generic type that wraps all DDlog value.\n+use differential_datalog::ddval::DDValConvert; // Trait to convert Rust types to/from DDValue.\n+                                               // All types in the `value::Value` module (see below)\n+                                               // implement this trait.\n+use differential_datalog::program::RelId; // Numeric relations id.\n+use differential_datalog::program::Update; // Type-safe representation of a DDlog command (insert/delete_val/delete_key/...)\n+\n+// The `record` module defines dynamically typed representation of DDlog values and commands.\n+use differential_datalog::record::Record; // Dynamically typed representation of DDlog values.\n+use differential_datalog::record::RelIdentifier; // Relation identifier: either `RelId` or `Cow<str>`g.\n+use differential_datalog::record::UpdCmd; // Dynamically typed representation of DDlog command.\n+\n+// The auto-generated `types` crate contains Rust types that correspond to user-defined DDlog\n+// types, one for each typedef and each relation in the DDlog program.\n+use types::*;\n+\n+// The auto-generated `value` crate contains\n+// * The `Value` model that define a wrapper type for each input and\n+//   output relation in the DDlog program, as well as\n+// * `enum Relations` that enumerates program relations\n+// * Several functions that convert between numeric relation id's and\n+//   symbolic names.\n+use value::relid2name;\n+use value::Relations;\n+use value::Value;\n+\n+fn main() -> Result<(), String> {\n+\n+    fn cb(_rel: usize, _rec: &Record, _w: isize) {}\n+\n+    // Instantiate a DDlog program.\n+    // Returns a handle to the program and initial contents of output relations.\n+    // Arguments\n+    // - number of worker threads (you typically want 1 or 2).\n+    // - Boolean flag that indicates whether DDlog will track the complete snapshot\n+    //   of output relations.  Should only be used if you plan to dump `dump_table`\n+    //   their contents using `HDDlog::dump_table()`.\n+    // - Callback - obsolete and will disappear in future releases.\n+    let (mut hddlog, init_state) = HDDlog::run(1, false, cb)?;\n+\n+    println!(\"Initial state\");\n+    dump_delta(&init_state);\n+\n+    /*\n+     * We perform two transactions that insert in the following two DDlog relations\n+     * (see `tutorial.dl`):\n+     *\n+     * ```\n+     * input relation Word1(word: string, cat: Category)\n+     * input relation Word2(word: string, cat: Category)\n+     * ```\n+     *\n+     * The first transactio uses the type-safe API, which should be preferred when\n+     * writing a client bound to a specific known DDlog program.\n+     *\n+     * The second transaction uses the dynamically typed record API.\n+     */\n+\n+    // There can be at most one transaction at a time.  Attempt to start anothe transaction\n+    // when there is one in progress will return an error.\n+    hddlog.transaction_start()?;\n+\n+    // A transaction can consist of multiple `apply_valupdates()` calls, each taking\n+    // multiple updates.  An update inserts, deletes or modifies a record in a DDlog\n+    // relation.\n+    let updates = vec![\n+        Update::Insert { // We are going to insert..\n+            relid: Relations::Word1 as RelId, // .. into relation with this Id.\n+            // `Word1` type, declared in the `types` crate has the same fields as\n+            // the corresponding DDlog type.\n+            // `Value::Word1` from the `value` crate is a wrapper around this type\n+            // that implement `into_ddvalue()`\n+            v: Value::Word1(Word1 {\n+                word: \"foo-\".to_string(),\n+                cat: Category::CategoryOther,\n+            })\n+            .into_ddvalue(),\n+        },\n+        Update::Insert {\n+            relid: Relations::Word2 as RelId,\n+            v: Value::Word2(Word2 {\n+                word: \"bar\".to_string(),\n+                cat: Category::CategoryOther,\n+            })\n+            .into_ddvalue(),\n+        },\n+    ];\n+    hddlog.apply_valupdates(updates.into_iter())?;", "originalCommit": "68405e13637262bb6268d306556ead63063f413e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg5MDAwMQ==", "url": "https://github.com/vmware/differential-datalog/pull/744#discussion_r474890001", "bodyText": "This is a pity. Is there a dynamically safe version? One would imagine that you can generate one. Perhaps val can have a set of generated methods?", "author": "mbudiu-vmw", "createdAt": "2020-08-21T19:25:18Z", "path": "test/datalog_tests/rust_api_test/src/main.rs", "diffHunk": "@@ -0,0 +1,172 @@\n+use std::borrow::Cow;\n+\n+// The main auto-generated crate `<progname>_ddlog` declares\n+// `HDDlog` type that serves as a reference to a running DDlog program.\n+// `HDDlog` implements `trait differential_datalog::DDlog` (see below).\n+use tutorial_ddlog::api::HDDlog;\n+\n+// The differential_datalog crate contains the DDlog runtime that is\n+// the same for all DDlog programs and simply gets copied to each generated\n+// DDlog workspace unmodified (this will change in future releases).\n+use differential_datalog::DDlog; // Trait that must be implemented by an instance of a DDlog program.\n+use differential_datalog::DeltaMap; // Type that represents a set of changes to DDlog relations.\n+                                    // Returned by `DDlog::transaction_commit_dump_changes()`.\n+use differential_datalog::ddval::DDValue; // Generic type that wraps all DDlog value.\n+use differential_datalog::ddval::DDValConvert; // Trait to convert Rust types to/from DDValue.\n+                                               // All types in the `value::Value` module (see below)\n+                                               // implement this trait.\n+use differential_datalog::program::RelId; // Numeric relations id.\n+use differential_datalog::program::Update; // Type-safe representation of a DDlog command (insert/delete_val/delete_key/...)\n+\n+// The `record` module defines dynamically typed representation of DDlog values and commands.\n+use differential_datalog::record::Record; // Dynamically typed representation of DDlog values.\n+use differential_datalog::record::RelIdentifier; // Relation identifier: either `RelId` or `Cow<str>`g.\n+use differential_datalog::record::UpdCmd; // Dynamically typed representation of DDlog command.\n+\n+// The auto-generated `types` crate contains Rust types that correspond to user-defined DDlog\n+// types, one for each typedef and each relation in the DDlog program.\n+use types::*;\n+\n+// The auto-generated `value` crate contains\n+// * The `Value` model that define a wrapper type for each input and\n+//   output relation in the DDlog program, as well as\n+// * `enum Relations` that enumerates program relations\n+// * Several functions that convert between numeric relation id's and\n+//   symbolic names.\n+use value::relid2name;\n+use value::Relations;\n+use value::Value;\n+\n+fn main() -> Result<(), String> {\n+\n+    fn cb(_rel: usize, _rec: &Record, _w: isize) {}\n+\n+    // Instantiate a DDlog program.\n+    // Returns a handle to the program and initial contents of output relations.\n+    // Arguments\n+    // - number of worker threads (you typically want 1 or 2).\n+    // - Boolean flag that indicates whether DDlog will track the complete snapshot\n+    //   of output relations.  Should only be used if you plan to dump `dump_table`\n+    //   their contents using `HDDlog::dump_table()`.\n+    // - Callback - obsolete and will disappear in future releases.\n+    let (mut hddlog, init_state) = HDDlog::run(1, false, cb)?;\n+\n+    println!(\"Initial state\");\n+    dump_delta(&init_state);\n+\n+    /*\n+     * We perform two transactions that insert in the following two DDlog relations\n+     * (see `tutorial.dl`):\n+     *\n+     * ```\n+     * input relation Word1(word: string, cat: Category)\n+     * input relation Word2(word: string, cat: Category)\n+     * ```\n+     *\n+     * The first transactio uses the type-safe API, which should be preferred when\n+     * writing a client bound to a specific known DDlog program.\n+     *\n+     * The second transaction uses the dynamically typed record API.\n+     */\n+\n+    // There can be at most one transaction at a time.  Attempt to start anothe transaction\n+    // when there is one in progress will return an error.\n+    hddlog.transaction_start()?;\n+\n+    // A transaction can consist of multiple `apply_valupdates()` calls, each taking\n+    // multiple updates.  An update inserts, deletes or modifies a record in a DDlog\n+    // relation.\n+    let updates = vec![\n+        Update::Insert { // We are going to insert..\n+            relid: Relations::Word1 as RelId, // .. into relation with this Id.\n+            // `Word1` type, declared in the `types` crate has the same fields as\n+            // the corresponding DDlog type.\n+            // `Value::Word1` from the `value` crate is a wrapper around this type\n+            // that implement `into_ddvalue()`\n+            v: Value::Word1(Word1 {\n+                word: \"foo-\".to_string(),\n+                cat: Category::CategoryOther,\n+            })\n+            .into_ddvalue(),\n+        },\n+        Update::Insert {\n+            relid: Relations::Word2 as RelId,\n+            v: Value::Word2(Word2 {\n+                word: \"bar\".to_string(),\n+                cat: Category::CategoryOther,\n+            })\n+            .into_ddvalue(),\n+        },\n+    ];\n+    hddlog.apply_valupdates(updates.into_iter())?;\n+\n+    // Commit the transaction; returns a `DeltaMap` object that contains the set\n+    // of changes to output relations produced by the transaction.\n+    let mut delta = hddlog.transaction_commit_dump_changes()?;\n+    //assert_eq!(delta, delta_expected);\n+\n+    println!(\"\\nState after transaction 1\");\n+    dump_delta(&delta);\n+    \n+    // This shows how to extract values from `DeltaMap`.\n+    println!(\"\\nEnumerating new phrases\");\n+\n+    // Retrieve the set of changes for a particular relation.\n+    let new_phrases = delta.get_rel(Relations::Phrases as RelId);\n+    for (val, weight) in new_phrases.iter() {\n+        // weight = 1 - insert.\n+        // weight = -1 - delete.\n+        assert_eq!(*weight, 1);\n+        // `val` has type `DDValue`; converting it to a concrete Rust\n+        // type is an unsafe operation: specifying the wrong Rust type\n+        // will lead to undefined behavior.\n+        let phrase: &Value::Phrases = unsafe { Value::Phrases::from_ddvalue_ref(val) };", "originalCommit": "68405e13637262bb6268d306556ead63063f413e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTAxMDk5Mw==", "url": "https://github.com/vmware/differential-datalog/pull/744#discussion_r475010993", "bodyText": "Yes, that's the plan.", "author": "ryzhyk", "createdAt": "2020-08-21T23:35:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDg5MDAwMQ=="}], "type": "inlineReview"}, {"oid": "181214f905599e7de0296246ffc5aa180a78eda9", "url": "https://github.com/vmware/differential-datalog/commit/181214f905599e7de0296246ffc5aa180a78eda9", "message": "Rust API test.\n\nA heavily commented Rust API client program that can be used as a\ntutorial for learning the Rust API as well as a template for other Rust\nclients.\n\nThe API is currently really clumsy and lacks any kind of ergonomisc.\nIt will hopefully improve in the future, but for now we at least\ndocument it as is, so that people can build their own Rust clients.", "committedDate": "2020-08-21T23:40:26Z", "type": "commit"}, {"oid": "181214f905599e7de0296246ffc5aa180a78eda9", "url": "https://github.com/vmware/differential-datalog/commit/181214f905599e7de0296246ffc5aa180a78eda9", "message": "Rust API test.\n\nA heavily commented Rust API client program that can be used as a\ntutorial for learning the Rust API as well as a template for other Rust\nclients.\n\nThe API is currently really clumsy and lacks any kind of ergonomisc.\nIt will hopefully improve in the future, but for now we at least\ndocument it as is, so that people can build their own Rust clients.", "committedDate": "2020-08-21T23:40:26Z", "type": "forcePushed"}]}