{"pr_number": 756, "pr_title": "Library + compiler improvements.", "pr_createdAt": "2020-08-28T18:40:36Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/756", "timeline": [{"oid": "b8cbe89ba4e94f8e5916f118bf147e3cf1c40c14", "url": "https://github.com/vmware/differential-datalog/commit/b8cbe89ba4e94f8e5916f118bf147e3cf1c40c14", "message": "std.dl: map_remove() returns removed value.\n\nChanged `map_remove()` signature from\n\n```\nfunction remove(m: mut Map<'K,'V>, k: 'K): ()\n```\n\nto\n\n```\nfunction remove(m: mut Map<'K,'V>, k: 'K): Option<'V>\n```\n\nOne use case is to remove, modify and re-insert an element without\ncopying.", "committedDate": "2020-08-28T18:31:21Z", "type": "commit"}, {"oid": "01614dcad24e704154c5647110c913d14d68ad8e", "url": "https://github.com/vmware/differential-datalog/commit/01614dcad24e704154c5647110c913d14d68ad8e", "message": "std.dl: New Vec<> functions.\n\n```\n/* Resize vector.  If `new_size` is greater than `v.len()`, then\n * all new slots are filled with `value`. */\nfunction resize(v: mut Vec<'X>, new_len: usize, value: 'X): () {\n    vec_resize(v, new_len, value)\n}\n\n/* Swap value at index `idx` for `value`.\n * Stores the old value at this index in `value` unless `idx` exceeds\n * the size of the vector (in which case the vector remains unmodified). */\nfunction swap_nth(v: mut Vec<'X>, idx: usize, value: mut 'X): () {\n    vec_swap_nth(v, idx, value)\n}\n\n/* Set value at index `idx` to `value`.\n * If `idx` exceeds the size of the vector (in which case the vector remains unmodified). */\nfunction update_nth(v: mut Vec<'X>, idx: usize, value: 'X): () {\n    vec_update_nth(v, idx, value)\n}\n```", "committedDate": "2020-08-28T18:31:21Z", "type": "commit"}, {"oid": "a42b06de0e1728354a572e9f2010dbb5f9d63f35", "url": "https://github.com/vmware/differential-datalog/commit/a42b06de0e1728354a572e9f2010dbb5f9d63f35", "message": "Enable write access to match pattern variables.\n\nThis was not previously allowed, as variables declared inside match\npatterns could not be modified.\n\n```\nmatch (jval) {\n    JsonObject{m} -> {\n        // ERROR: m is a read-only variable.\n        var old = m.remove(key);\n        ...\n    },\n    ...\n\n```\n\nThe restriction can be relaxed if the match expression is itself an L-value.", "committedDate": "2020-08-28T18:31:21Z", "type": "commit"}, {"oid": "37cb871bc35352f8bab767f03a3d379bcc778a8e", "url": "https://github.com/vmware/differential-datalog/commit/37cb871bc35352f8bab767f03a3d379bcc778a8e", "message": "json.dl: Json pointer.\n\nAdded functions for reading/writing JSON documents by pointer.\n\n```\n/* JsonPtr - points to a location withing a JSON document. */\ntypedef JsonPtr = Vec<JsonPtrItem>\n\ntypedef JsonPtrItem = JKeyPtr{ key: istring }\n                    | JIdxPtr{ idx: usize }\n\n/* Returns value at the given location or `None` if `ptr` does\n * not point to an existing location in the document. */\nfunction get_by_ptr(jval: JsonValue, ptr: JsonPtr): Option<JsonValue>\n\n/* Update value at the given location.  If the location specified by `ptr` does\n * not exist in the document, attempts to create it by inserting missing map keys\n * and expanding array sizes by padding them with nulls.\n *\n * Fails in one of two cases: (1) when attempting to modify the field of a value that is\n * not a map or a null, and (2) when attempting to modify an index of an object\n * that is not an array or null. */\nfunction set_by_ptr(jval: mut JsonValue, ptr: JsonPtr, v: JsonValue): Result<(), string>\n```", "committedDate": "2020-08-28T18:31:21Z", "type": "commit"}, {"oid": "3f966fcc0ace918b8dadd62abbe848c74df1d1f9", "url": "https://github.com/vmware/differential-datalog/commit/3f966fcc0ace918b8dadd62abbe848c74df1d1f9", "message": "Allow functions to return unit by default.\n\nAddresses #736.\n\nWe used to require every function declaration to specify an explicit\nreturn type.  There are quite a few functions that return `()` and\nmodify their arguments.\n\n```\nfunction do_something(int: mut u32): ()\n```\n\nThis is too verbose.  The new syntax allows skipping the unit return\ntype:\n\n```\nfunction do_something(int: mut u32)\n```", "committedDate": "2020-08-28T18:31:21Z", "type": "commit"}, {"oid": "9498f4299109388448ed77798f5a0a5c995975a7", "url": "https://github.com/vmware/differential-datalog/commit/9498f4299109388448ed77798f5a0a5c995975a7", "message": "Allow modifying variables in a match expression.\n\nWe used to disallow match expressions that modify variables, i.e.,\nin `match (e) {...}`, `e` can read but not modify variables.  This was\nmeant to help prevent errors, but it prevents perfectly valid\nexpressions like:\n\n```\njson.set_by_ptr(ptr, val)?\n```\n\nthat get expanded into a match.  We therefore relax this restriction.", "committedDate": "2020-08-28T20:55:46Z", "type": "commit"}, {"oid": "9498f4299109388448ed77798f5a0a5c995975a7", "url": "https://github.com/vmware/differential-datalog/commit/9498f4299109388448ed77798f5a0a5c995975a7", "message": "Allow modifying variables in a match expression.\n\nWe used to disallow match expressions that modify variables, i.e.,\nin `match (e) {...}`, `e` can read but not modify variables.  This was\nmeant to help prevent errors, but it prevents perfectly valid\nexpressions like:\n\n```\njson.set_by_ptr(ptr, val)?\n```\n\nthat get expanded into a match.  We therefore relax this restriction.", "committedDate": "2020-08-28T20:55:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU1NDYwOQ==", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479554609", "bodyText": "how about returning bool to indicate whether the move happened?", "author": "mbudiu-vmw", "createdAt": "2020-08-28T22:08:30Z", "path": "lib/std.dl", "diffHunk": "@@ -497,14 +497,32 @@ function to_set(s: Vec<'A>): Set<'A> {\n     vec_to_set(s)\n }\n \n-function sort(v: mut Vec<'X>): () {\n+function sort(v: mut Vec<'X>) {\n     vec_sort(v)\n }\n \n function sort_imm(v: Vec<'X>): Vec<'X> {\n     vec_sort_imm(v)\n }\n \n+/* Resize vector.  If `new_size` is greater than `v.len()`, then\n+ * all new slots are filled with `value`. */\n+function resize(v: mut Vec<'X>, new_len: usize, value: 'X) {\n+    vec_resize(v, new_len, value)\n+}\n+\n+/* Swap value at index `idx` for `value`.\n+ * Stores the old value at this index in `value` unless `idx` exceeds\n+ * the size of the vector (in which case the vector remains unmodified). */\n+function swap_nth(v: mut Vec<'X>, idx: usize, value: mut 'X) {", "originalCommit": "9498f4299109388448ed77798f5a0a5c995975a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4MjAyMw==", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479582023", "bodyText": "good idea", "author": "ryzhyk", "createdAt": "2020-08-29T00:18:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU1NDYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU1OTg4Ng==", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479559886", "bodyText": "typo in comment", "author": "mbudiu-vmw", "createdAt": "2020-08-28T22:28:09Z", "path": "src/Language/DifferentialDatalog/NS.hs", "diffHunk": "@@ -142,12 +142,24 @@ getRelation d n = fromJust $ lookupRelation d n\n arg2v :: Function -> FuncArg -> Var\n arg2v f a = ArgVar f (name a)\n \n+-- All variables visible in 'ctx'.  This function is safe to call before\n+-- type checking.\n ctxAllVars :: DatalogProgram -> ECtx -> [Var]\n-ctxAllVars d ctx = let (lvs, rvs) = ctxVars d ctx in lvs ++ rvs\n+ctxAllVars d ctx = let (lvs, rvs) = ctxVars' d ctx False in lvs ++ rvs\n \n--- All variables available in the scope: (l-vars, read-only vars).\n+-- All variables visible in the 'ctx', classified into (writable, read-only\n+-- varables).", "originalCommit": "9498f4299109388448ed77798f5a0a5c995975a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2MTM0MQ==", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479561341", "bodyText": "if it missclassifies what are the consequences? I don't understand what the caller is supposed to do in this case with the result. You must have some contract about it, which is not stated.", "author": "mbudiu-vmw", "createdAt": "2020-08-28T22:33:56Z", "path": "src/Language/DifferentialDatalog/NS.hs", "diffHunk": "@@ -142,12 +142,24 @@ getRelation d n = fromJust $ lookupRelation d n\n arg2v :: Function -> FuncArg -> Var\n arg2v f a = ArgVar f (name a)\n \n+-- All variables visible in 'ctx'.  This function is safe to call before\n+-- type checking.\n ctxAllVars :: DatalogProgram -> ECtx -> [Var]\n-ctxAllVars d ctx = let (lvs, rvs) = ctxVars d ctx in lvs ++ rvs\n+ctxAllVars d ctx = let (lvs, rvs) = ctxVars' d ctx False in lvs ++ rvs\n \n--- All variables available in the scope: (l-vars, read-only vars).\n+-- All variables visible in the 'ctx', classified into (writable, read-only\n+-- varables).\n+-- This function is _unsafe_ to use before type inference.\n ctxVars :: DatalogProgram -> ECtx -> ([Var], [Var])\n-ctxVars d ctx =\n+ctxVars d ctx = ctxVars' d ctx True\n+\n+-- All variables available in the scope: (l-vars, read-only vars).\n+--\n+-- The 'with_types' flag is true if 'd' contains enough type information\n+-- to determine variable types (i.e., it has been through type inference).\n+-- When false, `ctxVars` may misclassify", "originalCommit": "9498f4299109388448ed77798f5a0a5c995975a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4MzI0MA==", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479583240", "bodyText": "I clarified the contract.  This function is private to the module and is only called in a safe way there.", "author": "ryzhyk", "createdAt": "2020-08-29T00:26:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2MTM0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2MTg4MQ==", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479561881", "bodyText": "I guess that your contract is that you will return a conservative approximation of the writability - some writable variables may be misclassified as readable. But you still get all of them.", "author": "mbudiu-vmw", "createdAt": "2020-08-28T22:36:08Z", "path": "src/Language/DifferentialDatalog/NS.hs", "diffHunk": "@@ -161,33 +173,42 @@ ctxVars d ctx =\n          CtxRuleRGroupBy rl i     -> ([], ruleRHSVars d rl i)\n          CtxKey rel@Relation{..}  -> ([], [KeyVar rel])\n          CtxIndex idx@Index{..}   -> ([], map (\\v -> (IdxVar idx $ name v)) idxVars)\n-         CtxApply _ _ _           -> ([], plvars ++ prvars)\n+         CtxApply _ _ _           -> (plvars, prvars)\n          CtxField _ _             -> (plvars, prvars)\n          CtxTupField _ _          -> (plvars, prvars)\n          CtxStruct _ _ _          -> (plvars, prvars)\n          CtxTuple _ _ _           -> (plvars, prvars)\n          CtxSlice  _ _            -> ([], plvars ++ prvars)\n-         CtxMatchExpr _ _         -> ([], plvars ++ prvars)\n+         CtxMatchExpr _ _         -> (plvars, prvars)\n          CtxMatchPat _ _ _        -> ([], plvars ++ prvars)\n          CtxMatchVal e pctx i     -> let patternVars = exprVarDecls d (CtxMatchPat e pctx i)\n-                                                       $ fst $ (exprCases e) !! i in\n-                                     {-if exprIsVarOrFieldLVal d pctx $ exprMatchExpr e\n-                                        then (plvars ++ patternVars, prvars)\n-                                        else -}\n-                                     (plvars, patternVars ++ prvars)\n+                                                       $ fst $ (exprCases e) !! i\n+                                         patternVarNames = map name patternVars\n+                                         plvars' = filter (\\v -> notElem (name v) patternVarNames) plvars\n+                                         prvars' = filter (\\v -> notElem (name v) patternVarNames) prvars in\n+                                     -- 'exprIsVarOrFieldLVal' needs to determine the type of 'e' and\n+                                     -- may crash if called before type inference.\n+                                     if with_types && (exprIsVarOrFieldLVal d pctx $ exprMatchExpr e)\n+                                        then (patternVars ++ plvars', prvars')", "originalCommit": "9498f4299109388448ed77798f5a0a5c995975a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2MjI1Ng==", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479562256", "bodyText": "this stuff should probably be documented.", "author": "mbudiu-vmw", "createdAt": "2020-08-28T22:37:55Z", "path": "src/Language/DifferentialDatalog/NS.hs", "diffHunk": "@@ -161,33 +173,42 @@ ctxVars d ctx =\n          CtxRuleRGroupBy rl i     -> ([], ruleRHSVars d rl i)\n          CtxKey rel@Relation{..}  -> ([], [KeyVar rel])\n          CtxIndex idx@Index{..}   -> ([], map (\\v -> (IdxVar idx $ name v)) idxVars)\n-         CtxApply _ _ _           -> ([], plvars ++ prvars)\n+         CtxApply _ _ _           -> (plvars, prvars)\n          CtxField _ _             -> (plvars, prvars)\n          CtxTupField _ _          -> (plvars, prvars)\n          CtxStruct _ _ _          -> (plvars, prvars)\n          CtxTuple _ _ _           -> (plvars, prvars)\n          CtxSlice  _ _            -> ([], plvars ++ prvars)\n-         CtxMatchExpr _ _         -> ([], plvars ++ prvars)\n+         CtxMatchExpr _ _         -> (plvars, prvars)\n          CtxMatchPat _ _ _        -> ([], plvars ++ prvars)\n          CtxMatchVal e pctx i     -> let patternVars = exprVarDecls d (CtxMatchPat e pctx i)\n-                                                       $ fst $ (exprCases e) !! i in\n-                                     {-if exprIsVarOrFieldLVal d pctx $ exprMatchExpr e\n-                                        then (plvars ++ patternVars, prvars)\n-                                        else -}\n-                                     (plvars, patternVars ++ prvars)\n+                                                       $ fst $ (exprCases e) !! i\n+                                         patternVarNames = map name patternVars\n+                                         plvars' = filter (\\v -> notElem (name v) patternVarNames) plvars\n+                                         prvars' = filter (\\v -> notElem (name v) patternVarNames) prvars in\n+                                     -- 'exprIsVarOrFieldLVal' needs to determine the type of 'e' and\n+                                     -- may crash if called before type inference.\n+                                     if with_types && (exprIsVarOrFieldLVal d pctx $ exprMatchExpr e)\n+                                        then (patternVars ++ plvars', prvars')\n+                                        else (plvars', patternVars ++ prvars')\n          CtxSeq1 _ _              -> (plvars, prvars)\n          CtxSeq2 e pctx           -> let seq1vars = exprVarDecls d (CtxSeq1 e pctx) $ exprLeft e\n-                                     in (plvars ++ seq1vars, prvars)\n+                                         varNames = map name seq1vars\n+                                         plvars' = filter (\\v -> notElem (name v) varNames) plvars\n+                                         prvars' = filter (\\v -> notElem (name v) varNames) prvars\n+                                     in (plvars' ++ seq1vars, prvars')\n          CtxITEIf _ _             -> ([], plvars ++ prvars)\n          CtxITEThen _ _           -> (plvars, prvars)\n          CtxITEElse _ _           -> (plvars, prvars)\n          CtxForIter _ _           -> (plvars, prvars)\n          CtxForBody e@EFor{..} pctx -> let loopvar = ForVar pctx e\n+                                           prvars' = (filter ((/= name loopvar) . name) prvars)\n+                                           iterVarNames = map name $ exprVars d (CtxForIter e pctx) exprIter\n                                            -- variables that occur in the iterator expression cannot\n                                            -- be modified inside the loop\n-                                           plvars_not_iter = filter (\\v -> notElem v $ exprVars d (CtxForIter e pctx) exprIter) plvars\n-                                           plvars_iter = filter (\\v -> elem v $ exprVars d (CtxForIter e pctx) exprIter) plvars\n-                                       in (plvars_not_iter, prvars ++ plvars_iter ++ [loopvar])\n+                                           plvars_not_iter = filter (\\v -> name v /= (name loopvar) && notElem (name v) iterVarNames) plvars", "originalCommit": "9498f4299109388448ed77798f5a0a5c995975a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2MjQ4NQ==", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479562485", "bodyText": "how about giving a warning that this syntax is deprecated?\nwe should consider removing it in the future.", "author": "mbudiu-vmw", "createdAt": "2020-08-28T22:38:51Z", "path": "src/Language/DifferentialDatalog/Parse.hs", "diffHunk": "@@ -297,13 +297,13 @@ typeDef = (TypeDef nopos []) <$ reserved \"typedef\" <*> typeIdent <*>\n func = (Function nopos [] <$  (try $ reserved \"extern\" *> reserved \"function\")\n                          <*> funcIdent\n                          <*> (parens $ commaSep farg)\n-                         <*> (colon *> typeSpecSimple)\n+                         <*> (option (TTuple nopos []) (colon *> typeSpecSimple))\n                          <*> (return Nothing))\n        <|>\n        (Function nopos [] <$  reserved \"function\"\n                          <*> funcIdent\n                          <*> (parens $ commaSep farg)\n-                         <*> (colon *> typeSpecSimple)\n+                         <*> (option (TTuple nopos []) (colon *> typeSpecSimple))", "originalCommit": "9498f4299109388448ed77798f5a0a5c995975a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4MzQyMA==", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479583420", "bodyText": "That's the right thing to do, but we don't have the infrastructure for warning atm.  In particular, it should be possible to deprecate warnings or convert them to errors.", "author": "ryzhyk", "createdAt": "2020-08-29T00:27:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2MjQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2MzE4NA==", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479563184", "bodyText": "How about adding a function to convert a path like this into a vec of ptrs?\nWith a heuristic that numbers become indexes?", "author": "mbudiu-vmw", "createdAt": "2020-08-28T22:41:38Z", "path": "test/datalog_tests/json_test.dl", "diffHunk": "@@ -204,3 +204,34 @@ JsonTestValue(\"wrapped \" ++ wenum2(),\n          (from_json_string(wenum2()): Result<WrappedEnum, string>).to_json_value().unwrap_or_default().to_json_string_or_default()).\n JsonTestValue(\"wrapped \" ++ wenum3(),\n          (from_json_string(wenum3()): Result<WrappedEnum, string>).to_json_value().unwrap_or_default().to_json_string_or_default()).\n+\n+/* JsonPtr test. */\n+\n+JsonTest(\"set_by_ptr test\", mutilate_jval().to_json_string_or_default()).\n+\n+function mutilate_jval(): JsonValue {\n+    var jval: JsonValue = from_json_string(nestedStruct1()).unwrap_or_default();\n+    // replace existing field.\n+    jval.set_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"x\"}], from_json_string(boolStruct2()).unwrap_or_default());\n+    // create new field.\n+    jval.set_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"y\"}], from_json_string(boolStruct2()).unwrap_or_default());\n+    // replace z with array.\n+    jval.set_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"z\"}], JsonArray{[from_json_string(wenum1()).unwrap_or_default(), from_json_string(wenum2()).unwrap_or_default()]});\n+    // replace array element.\n+    jval.set_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"z\"}, JIdxPtr{1}], from_json_string(wenum3()).unwrap_or_default());\n+    // replace value inside array.\n+    jval.set_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"z\"}, JIdxPtr{1}, JKeyPtr{i\"b\"}], from_json_string(struct_with_map1()).unwrap_or_default());\n+    // extend array.\n+    jval.set_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"z\"}, JIdxPtr{10}, JKeyPtr{i\"b\"}], from_json_string(struct_with_map1()).unwrap_or_default());\n+    // convert null into map\n+    jval.set_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"z\"}, JIdxPtr{9}, JKeyPtr{i\"q\"}], from_json_string(struct_with_map1()).unwrap_or_default());\n+\n+    // this should be a no-op.\n+    jval.set_by_ptr([JKeyPtr{i\"t\"}, JKeyPtr{i\"z\"}], from_json_string(struct_with_map1()).unwrap_or_default());\n+\n+    jval\n+}\n+\n+JsonTest(\"get_by_ptr(nested/z/10/b)\", mutilate_jval().get_by_ptr([JKeyPtr{i\"nested\"}, JKeyPtr{i\"z\"}, JIdxPtr{10}, JKeyPtr{i\"b\"}]).to_json_string().unwrap_or_default()).", "originalCommit": "9498f4299109388448ed77798f5a0a5c995975a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU4MzU3Nw==", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479583577", "bodyText": "The only use-case I have uses non-standard syntax for pointers, so I am taking the lazy approach here.", "author": "ryzhyk", "createdAt": "2020-08-29T00:28:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2MzE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2MzQ5NA==", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479563494", "bodyText": "json literals are very hard to read as strings due to all the quotes being quoted.\nMakes me think we should add a syntax for Json literals... like interned strings.", "author": "mbudiu-vmw", "createdAt": "2020-08-28T22:42:58Z", "path": "test/datalog_tests/json_test.dump.expected", "diffHunk": "@@ -3,6 +3,10 @@ json_test::JsonTest{.description = \"-100\", .value = \"{\\\"std_Ok\\\":{\\\"res\\\":-100}}\n json_test::JsonTest{.description = \"100\", .value = \"{\\\"std_Ok\\\":{\\\"res\\\":100}}\"}\n json_test::JsonTest{.description = \"2.99792458e8\", .value = \"{\\\"std_Ok\\\":{\\\"res\\\":299792458.0}}\"}\n json_test::JsonTest{.description = \"[{\\\"b\\\":true}, {\\\"b\\\":false}, {\\\"b\\\":true}, {\\\"b\\\":false}]\", .value = \"{\\\"std_Ok\\\":{\\\"res\\\":[{\\\"b\\\":true},{\\\"b\\\":false},{\\\"b\\\":true},{\\\"b\\\":false}]}}\"}\n+json_test::JsonTest{.description = \"get_by_ptr([])\", .value = \"{\\\"id\\\":\\\"1001001001\\\",\\\"nested\\\":{\\\"x\\\":{\\\"b\\\":true,\\\"foo\\\":\\\"bar\\\"},\\\"y\\\":{\\\"b\\\":true,\\\"foo\\\":\\\"bar\\\"},\\\"z\\\":[{\\\"@type\\\":\\\"t.V1\\\",\\\"b\\\":true},{\\\"@type\\\":\\\"t.V2\\\",\\\"b\\\":{\\\"f\\\":[{\\\"key\\\":100,\\\"payload\\\":\\\"foo\\\"}]}},null,null,null,null,null,null,null,{\\\"q\\\":{\\\"f\\\":[{\\\"key\\\":100,\\\"payload\\\":\\\"foo\\\"}]}},{\\\"b\\\":{\\\"f\\\":[{\\\"key\\\":100,\\\"payload\\\":\\\"foo\\\"}]}}]},\\\"t\\\":\\\"foo\\\"}\"}", "originalCommit": "9498f4299109388448ed77798f5a0a5c995975a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2Nzc2NQ==", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479567765", "bodyText": "did you intend to have this double slash here?", "author": "mbudiu-vmw", "createdAt": "2020-08-28T23:01:18Z", "path": "test/datalog_tests/std_test.dump.expected", "diffHunk": "@@ -22,3 +22,15 @@ std_test::Pow{.descr = \"$pow32(2: u64, 32)\", .val = \"4294967296\"}\n std_test::Pow{.descr = \"pow32(2: u32, 32)\", .val = \"0\"}\n std_test::Default{.descr = \"DefaultEnum\", .val = \"DEnum1\"}\n std_test::Default{.descr = \"u32\", .val = \"0\"}\n+std_test::MapDelete{.descr = \"alphabet\", .m = [(0, \"a\"), (1, \"b\"), (2, \"c\"), (3, \"d\"), (4, \"e\")], .s = std::None{}}\n+std_test::MapDelete{.descr = \"alphabet\\\\4\", .m = [(0, \"a\"), (1, \"b\"), (2, \"c\"), (3, \"d\")], .s = std::Some{.x = \"e\"}}", "originalCommit": "9498f4299109388448ed77798f5a0a5c995975a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTU2Nzk5Ng==", "url": "https://github.com/vmware/differential-datalog/pull/756#discussion_r479567996", "bodyText": "should the string be resize(10, -100)?", "author": "mbudiu-vmw", "createdAt": "2020-08-28T23:02:18Z", "path": "test/datalog_tests/std_test.dl", "diffHunk": "@@ -14,6 +14,32 @@ SortedVectorInPlace(sorted) :-\n         v2\n     }.\n \n+output relation IntVecTest(descr: string, vec: Vec<s64>)\n+\n+IntVecTest(\"vec0\", vec0()).\n+IntVecTest(\"vec0.resize(10)\", {var v = vec0(); v.resize(10, -100); v}).", "originalCommit": "9498f4299109388448ed77798f5a0a5c995975a7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5576852273b107c9546b38ea1ad658109a76f2c0", "url": "https://github.com/vmware/differential-datalog/commit/5576852273b107c9546b38ea1ad658109a76f2c0", "message": "Address review comments.", "committedDate": "2020-08-29T00:40:25Z", "type": "commit"}, {"oid": "71ae0e42b1e897374dfd108bc7b70005f2d06fe6", "url": "https://github.com/vmware/differential-datalog/commit/71ae0e42b1e897374dfd108bc7b70005f2d06fe6", "message": "tutorial.md: Document variable mutability.\n\n- Added tutorial section summarizing variable mutability rules.\n- Added several positive and negative variable mutability tests.", "committedDate": "2020-08-29T07:19:45Z", "type": "commit"}]}