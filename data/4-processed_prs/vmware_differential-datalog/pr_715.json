{"pr_number": 715, "pr_title": "Vector and map literals.", "pr_createdAt": "2020-07-24T05:23:46Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/715", "timeline": [{"oid": "94b2767a8e5210bdd8938dbd1953ee28f4b78d93", "url": "https://github.com/vmware/differential-datalog/commit/94b2767a8e5210bdd8938dbd1953ee28f4b78d93", "message": "Vector and map literals.\n\nIntroduced syntactic sugar for vector and map literals.\n\nVector literals:\n===============\n\n```\nvar v = [0, x, f(y)];\n```\n\nis equivalent to:\n\n```\nvar v = vec_with_capacity(3);\nv.push(0);\nv.push(x);\nv.push(f(y));\n...\n```\n\nMap literals:\n=============\n\nLikewise, **map literals** can be used to create maps by listing their\nkey-value pairs:\n\n```\nvar m = [\"foo\" -> 0,\n         \"bar\" -> 1,\n         \"foobar\" -> 2];\n...\n```\n\nTo keep the implementation simple, map and vector literals are expanded\ninside the parser, so we don't need to introduce new kinds of\nnodes for them in the AST.  This may lead to less clear error messages.\nIn addition, this means that empty vector and map literals are not\nallowed, as the parser cannot tell a vector from a map.  One needs to\nwrite `vec_empty()` or `map_empty()` for empty vectors and maps\nrespectively.", "committedDate": "2020-07-24T02:33:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMDQ0OA==", "url": "https://github.com/vmware/differential-datalog/pull/715#discussion_r461210448", "bodyText": "I think you should allow empty vectors in this grammar.\nThe fact that the implementation may not is a bug.", "author": "mbudiu-vmw", "createdAt": "2020-07-27T22:39:01Z", "path": "doc/language_reference/language_reference.md", "diffHunk": "@@ -409,9 +411,11 @@ they produce results of type `string`, e.g.:\n Other terms:\n \n ```EBNF\n+vec_literal  :: \"[\" expr (\",\" expr)* \"]\"", "originalCommit": "94b2767a8e5210bdd8938dbd1953ee28f4b78d93", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMjA5NQ==", "url": "https://github.com/vmware/differential-datalog/pull/715#discussion_r461212095", "bodyText": "do you want to delete these?", "author": "mbudiu-vmw", "createdAt": "2020-07-27T22:43:29Z", "path": "src/Language/DifferentialDatalog/Validate.hs", "diffHunk": "@@ -583,13 +583,13 @@ exprValidate1 d _ _   (ESlice p _ h l)    =\n     check d (h >= l) p\n           $ \"Upper bound of the slice must be greater than lower bound\"\n exprValidate1 _ _ _   EMatch{}            = return ()\n-exprValidate1 d _ ctx (EVarDecl p v)      = do\n+exprValidate1 d _ ctx (EVarDecl p _)      = do\n     check d (ctxInSetL ctx || ctxInMatchPat ctx) p \"Variable declaration is not allowed in this context\"\n-    checkNoVar p d ctx v\n+    --checkNoVar p d ctx v", "originalCommit": "94b2767a8e5210bdd8938dbd1953ee28f4b78d93", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMjMyMQ==", "url": "https://github.com/vmware/differential-datalog/pull/715#discussion_r461212321", "bodyText": "should this be at least a warning?", "author": "mbudiu-vmw", "createdAt": "2020-07-27T22:44:08Z", "path": "test/datalog_tests/function.fail.ast.expected", "diffHunk": "@@ -18,10 +14,6 @@ expression '(var w: bool)'\n         C0{.x = w: bool} -> w,\n                 ^^^^^^^\n \n-error: ./test/datalog_tests/function.fail.dl:7:5-7:11: Variable v already defined in this scope", "originalCommit": "94b2767a8e5210bdd8938dbd1953ee28f4b78d93", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTIxMjc4Mw==", "url": "https://github.com/vmware/differential-datalog/pull/715#discussion_r461212783", "bodyText": "This looks quite ambiguous. It would be nicer if you required a var to always be used when introducing a new var. If you just use an identifier this could be an error.", "author": "mbudiu-vmw", "createdAt": "2020-07-27T22:45:16Z", "path": "test/datalog_tests/function.fail.dl", "diffHunk": "@@ -20,21 +20,6 @@ function vars(): () = {\n \n //---\n \n-typedef Alt = C0{x: bit<32>}\n-            | C1{x: bit<32>}\n-\n-// shadow argument name\n-function shadow(v: string): () = {\n-    var a: Alt = C0{1};\n-\n-    var i: bit<32> = match (a) {\n-        C0{.x = v} -> v,\n-        C1{v} -> v", "originalCommit": "94b2767a8e5210bdd8938dbd1953ee28f4b78d93", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}