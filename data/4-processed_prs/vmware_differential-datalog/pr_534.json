{"pr_number": 534, "pr_title": "Access fields of stucts & tuples wrapped in Ref's.", "pr_createdAt": "2020-02-25T01:44:53Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/534", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYxNjAzNw==", "url": "https://github.com/vmware/differential-datalog/pull/534#discussion_r383616037", "bodyText": "missing something here", "author": "mbudiu-vmw", "createdAt": "2020-02-25T01:47:07Z", "path": "doc/tutorial/tutorial.md", "diffHunk": "@@ -1393,6 +1393,17 @@ TopScore(school, top_score) :-\n \n We again use `&` to pattern match values stored by reference.\n \n+As another syntactic convenience, DDlog allows accessing fields of structs and\n+tuples wrapped in references directly using, without dereferencing them first.", "originalCommit": "8c29e94f587fb47d5685303dce04c5d28e3d85dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c3299dae32bc4066f8b214ff81b2789b592617df", "url": "https://github.com/vmware/differential-datalog/commit/c3299dae32bc4066f8b214ff81b2789b592617df", "message": "Access fields of stucts & tuples wrapped in Ref's.\n\nThis commit addresses one of the awkward aspects of working with complex\ntypes wrapped in `Ref<>`'s.  Ideally, we would like `Ref<>`'s to be as\ntransparent as possible, so that one could work with them as if they were\nobjects of the inner type wrapped in the `Ref`.  We're not quite there\nyet.  One issue is that Rust does not allow matching on the contents of\na `Ref`.  The other issue is that accessing fields of structs or tuples\nwrapped in a `Ref<>` requires either unwrapping it using `deref` or\nusing pattern matching syntax, as in:\n\n```\nrelation StudentInfo(student: Ref<Student>, school: Ref<School>)\n\nTopScore(school, top_score) :-\n    StudentInfo(&Student{.sat_score = sat}, &School{.name = school}),\n    // WE HAVE BOUND THE `.sat_score` FIELD OF Student TO `sat` AND CAN\n    // USE IT BELOW.\n    var top_score = Aggregate((school), group_max(sat)).\n```\n\nThis commit extends the field access syntax `s.field` to perform automatic\ndereferencing if `s` is a `Ref<>`, so the above rule can now be equivalently\nre-written as:\n\n```\nTopScore(school, top_score) :-\n    StudentInfo(student, &School{.name = school}),\n    var top_score = Aggregate((school), group_max(student.sat_score)).\n```", "committedDate": "2020-02-25T01:53:35Z", "type": "commit"}, {"oid": "c3299dae32bc4066f8b214ff81b2789b592617df", "url": "https://github.com/vmware/differential-datalog/commit/c3299dae32bc4066f8b214ff81b2789b592617df", "message": "Access fields of stucts & tuples wrapped in Ref's.\n\nThis commit addresses one of the awkward aspects of working with complex\ntypes wrapped in `Ref<>`'s.  Ideally, we would like `Ref<>`'s to be as\ntransparent as possible, so that one could work with them as if they were\nobjects of the inner type wrapped in the `Ref`.  We're not quite there\nyet.  One issue is that Rust does not allow matching on the contents of\na `Ref`.  The other issue is that accessing fields of structs or tuples\nwrapped in a `Ref<>` requires either unwrapping it using `deref` or\nusing pattern matching syntax, as in:\n\n```\nrelation StudentInfo(student: Ref<Student>, school: Ref<School>)\n\nTopScore(school, top_score) :-\n    StudentInfo(&Student{.sat_score = sat}, &School{.name = school}),\n    // WE HAVE BOUND THE `.sat_score` FIELD OF Student TO `sat` AND CAN\n    // USE IT BELOW.\n    var top_score = Aggregate((school), group_max(sat)).\n```\n\nThis commit extends the field access syntax `s.field` to perform automatic\ndereferencing if `s` is a `Ref<>`, so the above rule can now be equivalently\nre-written as:\n\n```\nTopScore(school, top_score) :-\n    StudentInfo(student, &School{.name = school}),\n    var top_score = Aggregate((school), group_max(student.sat_score)).\n```", "committedDate": "2020-02-25T01:53:35Z", "type": "forcePushed"}]}