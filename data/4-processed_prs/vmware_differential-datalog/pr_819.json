{"pr_number": 819, "pr_title": "Support SQL binding variables for inserts and deletes", "pr_createdAt": "2020-11-18T22:04:21Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/819", "timeline": [{"oid": "3cd0fd17ca2e06a3e44a019ce3e93f2ceb6bb518", "url": "https://github.com/vmware/differential-datalog/commit/3cd0fd17ca2e06a3e44a019ce3e93f2ceb6bb518", "message": "jooq-ddlog: propagate query context to pass bindings to QueryVisitor\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2020-11-18T18:43:57Z", "type": "commit"}, {"oid": "0f7319912f9942053c809962c64abc8cffb8a81f", "url": "https://github.com/vmware/differential-datalog/commit/0f7319912f9942053c809962c64abc8cffb8a81f", "message": "jooq-ddlog: refactor tests to have multiple smaller tests, all share the same connection\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2020-11-18T18:43:57Z", "type": "commit"}, {"oid": "547824d9ba532a6d1e51fd1f20e6771ec6793ae6", "url": "https://github.com/vmware/differential-datalog/commit/547824d9ba532a6d1e51fd1f20e6771ec6793ae6", "message": "jooq-ddlog: support parameter bindings for delete statements\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2020-11-18T21:01:26Z", "type": "commit"}, {"oid": "1dcd9cd9c1663a278cfc95bf855276f536cd48d5", "url": "https://github.com/vmware/differential-datalog/commit/1dcd9cd9c1663a278cfc95bf855276f536cd48d5", "message": "jooq-ddlog: refactor binding code\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2020-11-18T21:06:37Z", "type": "commit"}, {"oid": "b2009ff2eff1af5000621e15d57af430d32af358", "url": "https://github.com/vmware/differential-datalog/commit/b2009ff2eff1af5000621e15d57af430d32af358", "message": "jooq-ddlog: rector out record instances in tests\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2020-11-18T21:37:23Z", "type": "commit"}, {"oid": "e3f57ac05272203c5627b6b2de6beff2525f143a", "url": "https://github.com/vmware/differential-datalog/commit/e3f57ac05272203c5627b6b2de6beff2525f143a", "message": "jooq-ddlog: handle multi-row inserts\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2020-11-18T21:37:53Z", "type": "commit"}, {"oid": "8f93a5a3ee5c8fe1c497dc2c0489fd6e13bf6f59", "url": "https://github.com/vmware/differential-datalog/commit/8f93a5a3ee5c8fe1c497dc2c0489fd6e13bf6f59", "message": "jooq-ddlog: add test for inserting only with a subset of fields\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2020-11-18T21:53:42Z", "type": "commit"}, {"oid": "07917388cdfc409056e4253573c7be1fa70474a4", "url": "https://github.com/vmware/differential-datalog/commit/07917388cdfc409056e4253573c7be1fa70474a4", "message": "jooq-ddlog: use TestCase.fail() instead of Assert.fail()\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2020-11-18T21:56:51Z", "type": "commit"}, {"oid": "1b95fc4ac7b469d38e531be85c0cbed66342112d", "url": "https://github.com/vmware/differential-datalog/commit/1b95fc4ac7b469d38e531be85c0cbed66342112d", "message": "jooq-ddlog: use JOOQ's Field.getDataType() enums instead of class names to match type cases in toValue() and setValue()\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2020-11-18T22:21:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ2MDIwNA==", "url": "https://github.com/vmware/differential-datalog/pull/819#discussion_r526460204", "bodyText": "inconsistent indentation", "author": "mbudiu-vmw", "createdAt": "2020-11-18T22:17:33Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -130,11 +131,17 @@ public DDlogJooqProvider(final DDlogAPI dDlogAPI, final List<String> sqlStatemen\n         final String[] batchSql = ctx.batchSQL();\n         final MockResult[] mock = new MockResult[batchSql.length];\n         try {\n-            dDlogAPI.transactionStart();\n-            for (int i = 0; i < batchSql.length; i++) {\n-                mock[i] = executeOne(batchSql[i]);\n+            try {\n+                dDlogAPI.transactionStart();\n+                final Object[][] bindings = ctx.batchBindings();\n+                for (int i = 0; i < batchSql.length; i++) {\n+                    final Object[] binding = bindings != null && bindings.length > i ? bindings[i] : new Object[0];\n+                    final QueryContext context = new QueryContext(batchSql[i], binding);\n+                    mock[i] = executeOne(context);\n+                }\n+            } finally {\n+                    dDlogAPI.transactionCommitDumpChanges(this::onChange);", "originalCommit": "8f93a5a3ee5c8fe1c497dc2c0489fd6e13bf6f59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ2MDU4OA==", "url": "https://github.com/vmware/differential-datalog/pull/819#discussion_r526460588", "bodyText": "You can cache Object[0].", "author": "mbudiu-vmw", "createdAt": "2020-11-18T22:18:21Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -130,11 +131,17 @@ public DDlogJooqProvider(final DDlogAPI dDlogAPI, final List<String> sqlStatemen\n         final String[] batchSql = ctx.batchSQL();\n         final MockResult[] mock = new MockResult[batchSql.length];\n         try {\n-            dDlogAPI.transactionStart();\n-            for (int i = 0; i < batchSql.length; i++) {\n-                mock[i] = executeOne(batchSql[i]);\n+            try {\n+                dDlogAPI.transactionStart();\n+                final Object[][] bindings = ctx.batchBindings();\n+                for (int i = 0; i < batchSql.length; i++) {\n+                    final Object[] binding = bindings != null && bindings.length > i ? bindings[i] : new Object[0];", "originalCommit": "8f93a5a3ee5c8fe1c497dc2c0489fd6e13bf6f59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ2MTgzMg==", "url": "https://github.com/vmware/differential-datalog/pull/819#discussion_r526461832", "bodyText": "May be nice to figure out why this would happen.", "author": "mbudiu-vmw", "createdAt": "2020-11-18T22:20:46Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -164,68 +171,85 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final String sql) throws SQLException {\n-        final Statement statement = parser.createStatement(sql, options);\n-        final MockResult result = queryVisitor.process(statement, sql);\n+    private MockResult executeOne(final QueryContext context) throws SQLException {\n+        final Statement statement = parser.createStatement(context.sql(), options);\n+        final MockResult result = queryVisitor.process(statement, context);\n         if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + sql);\n+            throw new SQLException(\"Could not execute SQL statement \" + context);", "originalCommit": "8f93a5a3ee5c8fe1c497dc2c0489fd6e13bf6f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3NzkyNw==", "url": "https://github.com/vmware/differential-datalog/pull/819#discussion_r526477927", "bodyText": "This can only happen if we receive a statement type we can't support (something other than selects, inserts, or deletes, or queries with a shape different than what we can handle as listed in the class's Javadocs).", "author": "lalithsuresh", "createdAt": "2020-11-18T22:54:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ2MTgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ2MjI2NQ==", "url": "https://github.com/vmware/differential-datalog/pull/819#discussion_r526462265", "bodyText": "bound", "author": "mbudiu-vmw", "createdAt": "2020-11-18T22:21:40Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -164,68 +171,85 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final String sql) throws SQLException {\n-        final Statement statement = parser.createStatement(sql, options);\n-        final MockResult result = queryVisitor.process(statement, sql);\n+    private MockResult executeOne(final QueryContext context) throws SQLException {\n+        final Statement statement = parser.createStatement(context.sql(), options);\n+        final MockResult result = queryVisitor.process(statement, context);\n         if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + sql);\n+            throw new SQLException(\"Could not execute SQL statement \" + context);\n         }\n         return result;\n     }\n \n     /*\n      * Visits an SQL query and converts into a JOOQ MockResult type.\n      */\n-    private class QueryVisitor extends AstVisitor<MockResult, String> {\n+    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, String sql) {\n+        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n             // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n             final Select select = node.getSelect();\n             if (!(select.getSelectItems().size() == 1\n                     && select.getSelectItems().get(0) instanceof AllColumns\n                     && node.getFrom().isPresent()\n                     && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + sql);\n+                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n             }\n             final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n             final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n             if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName, sql));\n+                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n+                                           context.sql()));\n             }\n             final Result<Record> result = dslContext.newResult(fields);\n             result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n             return new MockResult(1, result);\n         }\n \n         @Override\n-        protected MockResult visitQuery(final Query node, final String context) {\n+        protected MockResult visitQuery(final Query node, final QueryContext context) {\n             final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n             return visitQuerySpecification(specification, context);\n         }\n \n         @Override\n-        protected MockResult visitInsert(final Insert node, final String sql) {\n+        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n             try {\n                 // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n                 if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + sql);\n+                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n                 }\n                 final Values values = (Values) node.getQuery().getQueryBody();\n                 final String tableName = node.getTarget().toString();\n                 final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n                 final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+                int bindingIndex = 0;\n                 for (final Expression row: values.getRows()) {\n                     if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + sql);\n+                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n                     }\n                     final List<Expression> items = ((Row) row).getItems();\n                     if (items.size() != fields.size()) {\n-                        throw new RuntimeException(\n-                                String.format(\"Incorrect row size for insertion into table %s: %s\", tableName, sql));\n+                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n+                                                   \"Please specify all the table's fields in their declared order: %s\",\n+                                                    tableName, context.sql());\n+                        throw new RuntimeException(error);\n                     }\n                     final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    for (int i = 0; i < items.size(); i++) {\n-                        recordsArray[i] = parseLiterals.process(items.get(i), fields.get(i).getDataType().nullable());\n+                    if (context.hasBinding()) {\n+                        // Is a statement with bind variables", "originalCommit": "8f93a5a3ee5c8fe1c497dc2c0489fd6e13bf6f59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ2MzU5Mg==", "url": "https://github.com/vmware/differential-datalog/pull/819#discussion_r526463592", "bodyText": "Should this counter be maintained in the context and provided by a context.nextBinding() method?", "author": "mbudiu-vmw", "createdAt": "2020-11-18T22:24:18Z", "path": "sql/src/main/java/com/vmware/ddlog/DDlogJooqProvider.java", "diffHunk": "@@ -164,68 +171,85 @@ private void onChange(final DDlogCommand<DDlogRecord> command) {\n         }\n     }\n \n-    private MockResult executeOne(final String sql) throws SQLException {\n-        final Statement statement = parser.createStatement(sql, options);\n-        final MockResult result = queryVisitor.process(statement, sql);\n+    private MockResult executeOne(final QueryContext context) throws SQLException {\n+        final Statement statement = parser.createStatement(context.sql(), options);\n+        final MockResult result = queryVisitor.process(statement, context);\n         if (result == null) {\n-            throw new SQLException(\"Could not execute SQL statement \" + sql);\n+            throw new SQLException(\"Could not execute SQL statement \" + context);\n         }\n         return result;\n     }\n \n     /*\n      * Visits an SQL query and converts into a JOOQ MockResult type.\n      */\n-    private class QueryVisitor extends AstVisitor<MockResult, String> {\n+    private class QueryVisitor extends AstVisitor<MockResult, QueryContext> {\n         @Override\n-        protected MockResult visitQuerySpecification(final QuerySpecification node, String sql) {\n+        protected MockResult visitQuerySpecification(final QuerySpecification node, final QueryContext context) {\n             // The checks below encode assumption A1 (see javadoc for the DDlogJooqProvider class)\n             final Select select = node.getSelect();\n             if (!(select.getSelectItems().size() == 1\n                     && select.getSelectItems().get(0) instanceof AllColumns\n                     && node.getFrom().isPresent()\n                     && node.getFrom().get() instanceof com.facebook.presto.sql.tree.Table)) {\n-                throw new RuntimeException(\"Statement not supported: \" + sql);\n+                throw new RuntimeException(\"Statement not supported: \" + context.sql());\n             }\n             final String tableName = ((com.facebook.presto.sql.tree.Table) node.getFrom().get()).getName().toString();\n             final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n             if (fields == null) {\n-                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName, sql));\n+                throw new RuntimeException(String.format(\"Unknown table %s queried in statement: %s\", tableName,\n+                                           context.sql()));\n             }\n             final Result<Record> result = dslContext.newResult(fields);\n             result.addAll(materializedViews.computeIfAbsent(tableName.toUpperCase(), (k) -> new LinkedHashSet<>()));\n             return new MockResult(1, result);\n         }\n \n         @Override\n-        protected MockResult visitQuery(final Query node, final String context) {\n+        protected MockResult visitQuery(final Query node, final QueryContext context) {\n             final QuerySpecification specification = (QuerySpecification) node.getQueryBody();\n             return visitQuerySpecification(specification, context);\n         }\n \n         @Override\n-        protected MockResult visitInsert(final Insert node, final String sql) {\n+        protected MockResult visitInsert(final Insert node, final QueryContext context) {\n             try {\n                 // The assertions below encode assumption A2 (see javadoc for the DDlogJooqProvider class)\n                 if (!(node.getQuery().getQueryBody() instanceof Values)) {\n-                    throw new RuntimeException(\"Statement not supported: \" + sql);\n+                    throw new RuntimeException(\"Statement not supported: \" + context.sql());\n                 }\n                 final Values values = (Values) node.getQuery().getQueryBody();\n                 final String tableName = node.getTarget().toString();\n                 final List<Field<?>> fields = tablesToFields.get(tableName.toUpperCase());\n                 final int tableId = dDlogAPI.getTableId(ddlogRelationName(tableName));\n+                int bindingIndex = 0;\n                 for (final Expression row: values.getRows()) {\n                     if (!(row instanceof Row)) {\n-                        throw new RuntimeException(\"Statement not supported: \" + sql);\n+                        throw new RuntimeException(\"Statement not supported: \" + context.sql());\n                     }\n                     final List<Expression> items = ((Row) row).getItems();\n                     if (items.size() != fields.size()) {\n-                        throw new RuntimeException(\n-                                String.format(\"Incorrect row size for insertion into table %s: %s\", tableName, sql));\n+                        final String error = String.format(\"Incorrect row size for insertion into table %s. \" +\n+                                                   \"Please specify all the table's fields in their declared order: %s\",\n+                                                    tableName, context.sql());\n+                        throw new RuntimeException(error);\n                     }\n                     final DDlogRecord[] recordsArray = new DDlogRecord[items.size()];\n-                    for (int i = 0; i < items.size(); i++) {\n-                        recordsArray[i] = parseLiterals.process(items.get(i), fields.get(i).getDataType().nullable());\n+                    if (context.hasBinding()) {\n+                        // Is a statement with bind variables\n+                        for (int i = 0; i < items.size(); i++) {\n+                            final boolean isNullableField = fields.get(i).getDataType().nullable();\n+                            final DDlogRecord record = toValue(fields.get(i), context.binding()[bindingIndex]);", "originalCommit": "8f93a5a3ee5c8fe1c497dc2c0489fd6e13bf6f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ3ODcwMQ==", "url": "https://github.com/vmware/differential-datalog/pull/819#discussion_r526478701", "bodyText": "That's a good idea. Every use of the binding seems to bump an index. So it's better to keep it behind the Context.", "author": "lalithsuresh", "createdAt": "2020-11-18T22:56:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ2MzU5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ4MDExMw==", "url": "https://github.com/vmware/differential-datalog/pull/819#discussion_r526480113", "bodyText": "Done.", "author": "lalithsuresh", "createdAt": "2020-11-18T23:00:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjQ2MzU5Mg=="}], "type": "inlineReview"}, {"oid": "cae023b0c26475e46dca87b643e1147d52598982", "url": "https://github.com/vmware/differential-datalog/commit/cae023b0c26475e46dca87b643e1147d52598982", "message": "jooq-ddlog: handle top-level DDlogExceptions with a transaction abort\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2020-11-18T22:45:00Z", "type": "commit"}, {"oid": "316ec4b28f1e050ac911b5c65a15f84a6236a5ff", "url": "https://github.com/vmware/differential-datalog/commit/316ec4b28f1e050ac911b5c65a15f84a6236a5ff", "message": "jooq-ddlog: rollback transactions even for RuntimeExceptions\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2020-11-18T22:48:32Z", "type": "commit"}, {"oid": "0b1eaa4029a30d8fbe3e80f05c1195352a8cd6fb", "url": "https://github.com/vmware/differential-datalog/commit/0b1eaa4029a30d8fbe3e80f05c1195352a8cd6fb", "message": "jooq-ddlog: keep bindingIndices behind QueryContext\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2020-11-18T22:59:08Z", "type": "commit"}, {"oid": "76743d53ae07a96ec777a3896647f2205fa43009", "url": "https://github.com/vmware/differential-datalog/commit/76743d53ae07a96ec777a3896647f2205fa43009", "message": "jooq-ddlog: remove QueryContext.binding()\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2020-11-18T22:59:48Z", "type": "commit"}, {"oid": "74ee6f55d2f86e77195ea3bee134fd01f9e8df05", "url": "https://github.com/vmware/differential-datalog/commit/74ee6f55d2f86e77195ea3bee134fd01f9e8df05", "message": "jooq-ddlog: cache new Object[0] as a default binding\n\nSigned-off-by: Lalith Suresh <lsuresh@vmware.com>", "committedDate": "2020-11-18T23:02:03Z", "type": "commit"}]}