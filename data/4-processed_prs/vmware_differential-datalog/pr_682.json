{"pr_number": 682, "pr_title": "Add Ddlog compiler for injecting debugging hooks", "pr_createdAt": "2020-06-09T21:53:52Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/682", "timeline": [{"oid": "369b860a251ada3c63e1895f4bbd48d2fd521d0e", "url": "https://github.com/vmware/differential-datalog/commit/369b860a251ada3c63e1895f4bbd48d2fd521d0e", "message": "Add option to enable injecting debuging hooks when compiling DDlog\n\nA \"-g\" option is introduced to mean that injection of\ndebugging hooks is enabled when compiling DDlog program.", "committedDate": "2020-06-08T05:54:43Z", "type": "commit"}, {"oid": "701f4379107a88f1107915c2c4befe8393c2aad4", "url": "https://github.com/vmware/differential-datalog/commit/701f4379107a88f1107915c2c4befe8393c2aad4", "message": "Add skeleton injectDebuggingHooks function\n\nWhen -g option is passed, ddlog will first apply injectDebuggingHooks\nfunction before passing it to the actual compilation process.", "committedDate": "2020-06-08T17:04:19Z", "type": "commit"}, {"oid": "12a75dbb4b51ac45fc5d68bf5a4a4df87791bf3e", "url": "https://github.com/vmware/differential-datalog/commit/12a75dbb4b51ac45fc5d68bf5a4a4df87791bf3e", "message": "Add support for aggregate operator when debug hook is enabled\n\nSince the inputs to the aggregate term is not visible after the\naggregation, the aggregate function is updated to use a compiler\ngenerated function that takes in both the inputs and the original\naggregate input variable and includes the set of inputs in the\noutput. An RHSCondition is also inserted after the aggregate term\nthat declares and sets the original return variable of the aggregate\noperator.", "committedDate": "2020-06-11T09:20:14Z", "type": "forcePushed"}, {"oid": "50c2381ae351acc548635a7e986d8f63bcde3e0f", "url": "https://github.com/vmware/differential-datalog/commit/50c2381ae351acc548635a7e986d8f63bcde3e0f", "message": "Add support for aggregate operator when debug hook is enabled\n\nSince the inputs to the aggregate term is not visible after the\naggregation, the aggregate function is updated to use a compiler\ngenerated function that takes in both the inputs and the original\naggregate input variable and includes the set of inputs in the\noutput. An RHSCondition is also inserted after the aggregate term\nthat declares and sets the original return variable of the aggregate\noperator.", "committedDate": "2020-06-11T16:04:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMzc2NA==", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439703764", "bodyText": "The compiler performs several source transformations. The help message should be clear as to which intermediate representation is being dumped.  In case we want to support dumping multiple intermediate representations in the future, the name of the flag should be more specific.", "author": "ryzhyk", "createdAt": "2020-06-13T03:10:52Z", "path": "app/Main.hs", "diffHunk": "@@ -75,6 +77,8 @@ options = [ Option ['h'] [\"help\"]             (NoArg Help)\n           , Option []    [\"no-dynlib\"]        (NoArg NoDynLib)                  \"Do not generate dynamic library (default).\"\n           , Option []    [\"staticlib\"]        (NoArg StaticLib)                 \"Generate static library (default).\"\n           , Option []    [\"no-staticlib\"]     (NoArg NoStaticLib)               \"Do not generate static library.\"\n+          , Option ['g'] []                   (NoArg DebugHooks)                \"Enable debugging hooks.\"\n+          , Option []    [\"pp\"]               (NoArg DumpSource)                \"Dump the transformed source into an ast file (FILE.ast).\"", "originalCommit": "8327f2c7a52ad61702434b97775ef7568a091860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzODM4Ng==", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r440438386", "bodyText": "Updated the help message. Let me know if it's ok now?", "author": "haroldlim", "createdAt": "2020-06-15T20:49:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwMzc2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNDE5Ng==", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439704196", "bodyText": "It might be helpful to run validation again after injectDebuggingHooks, at least during debugging, just to catch bugs.", "author": "ryzhyk", "createdAt": "2020-06-13T03:18:31Z", "path": "app/Main.hs", "diffHunk": "@@ -159,15 +169,22 @@ parseValidate Config{..} = do\n     d''' <- case confOutputInput of\n          \"\" -> return d''\n          x  ->  return $ progMirrorInputRelations d'' x\n-    d' <- case validate d''' of\n+    d'''' <- case validate d''' of\n                Left e   -> errorWithoutStackTrace $ \"error: \" ++ e\n-               Right d' -> return d'\n+               Right d'''' -> return d''''\n+    d' <- case confDebugHooks of\n+         False -> return d''''\n+         True  -> return $ injectDebuggingHooks d''''", "originalCommit": "8327f2c7a52ad61702434b97775ef7568a091860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzNzUwMg==", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r440437502", "bodyText": "Do you want me to add additional validation step as part of this PR (or just do it for testing purposes). I've added it locally but didn't include it in the commit.", "author": "haroldlim", "createdAt": "2020-06-15T20:47:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNDE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNDgyNA==", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439704824", "bodyText": "You should be able to do this as a one-liner using the write! macro. I can help with that. We should also figure out what is the best data format to use to communicate with the debugger.  For now, this looks good enough.", "author": "ryzhyk", "createdAt": "2020-06-13T03:28:55Z", "path": "lib/debug.rs", "diffHunk": "@@ -0,0 +1,61 @@\n+use std::fmt;\n+use std::fs::OpenOptions;\n+use std::io::Write;\n+use std::string::ToString;\n+\n+pub fn debug_debug_event<T1: ToString, A1: fmt::Debug, A2: fmt::Debug>(\n+    operator_id: &u32,\n+    w: &std_DDWeight,\n+    ts: &T1,\n+    input1: &A1,\n+    out: &A2,\n+) {\n+    let mut file = OpenOptions::new()\n+        .append(true)\n+        .create(true)\n+        .open(\"debug.log\".to_string())\n+        .unwrap();\n+    let mut owned_string: String = \"\".to_owned();", "originalCommit": "8327f2c7a52ad61702434b97775ef7568a091860", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNTA2Mg==", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439705062", "bodyText": "Shortcut: map atomVal $ ruleLHS rl", "author": "ryzhyk", "createdAt": "2020-06-13T03:33:20Z", "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -2736,3 +2737,23 @@ mkInt v | v <= (toInteger (maxBound::Word128)) && v >= (toInteger (minBound::Wor\n         = \"Int::from_i128(\" <> pp v <> \")\"\n         | otherwise\n         = \"Int::parse_bytes(b\\\"\" <> pp v <> \"\\\", 10)\"\n+\n+-- Compute the atom or tuple of variables after the prefix of length n.\n+-- If this is the last term, then it is an expression of the LHS variables for each head\n+-- of the rule.\n+-- If this is the first term, then it's the atom of the RHSLiteral.\n+-- Otherwise, this is the variables from rhsVarsAfter converted into an ETuple expression.\n+recordAfterPrefix :: DatalogProgram -> Rule -> Int -> [Expr]\n+recordAfterPrefix d rl i =\n+  if i == length (ruleRHS rl) - 1\n+     then  map (\\lhs -> atomVal lhs) $ ruleLHS rl", "originalCommit": "8327f2c7a52ad61702434b97775ef7568a091860", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNTIyMQ==", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439705221", "bodyText": "[eVar $ exprVar $ enode $ atomVal $ rhsAtom $ head $ ruleRHS rl]", "author": "ryzhyk", "createdAt": "2020-06-13T03:36:44Z", "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -2736,3 +2737,23 @@ mkInt v | v <= (toInteger (maxBound::Word128)) && v >= (toInteger (minBound::Wor\n         = \"Int::from_i128(\" <> pp v <> \")\"\n         | otherwise\n         = \"Int::parse_bytes(b\\\"\" <> pp v <> \"\\\", 10)\"\n+\n+-- Compute the atom or tuple of variables after the prefix of length n.\n+-- If this is the last term, then it is an expression of the LHS variables for each head\n+-- of the rule.\n+-- If this is the first term, then it's the atom of the RHSLiteral.\n+-- Otherwise, this is the variables from rhsVarsAfter converted into an ETuple expression.\n+recordAfterPrefix :: DatalogProgram -> Rule -> Int -> [Expr]\n+recordAfterPrefix d rl i =\n+  if i == length (ruleRHS rl) - 1\n+     then  map (\\lhs -> atomVal lhs) $ ruleLHS rl\n+     else if i == 0\n+             then [E EVar { exprPos = nopos,", "originalCommit": "8327f2c7a52ad61702434b97775ef7568a091860", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNTM4Mg==", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439705382", "bodyText": "You can use eTuple and eVar functions to shorten this.\nYou can also use the Haskell LambdaCase extension to abbreviate \\v -> case v of as just \\case.\nBetter yet, use name v to get the name of the variable without having to do case analysis.", "author": "ryzhyk", "createdAt": "2020-06-13T03:39:33Z", "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -2736,3 +2737,23 @@ mkInt v | v <= (toInteger (maxBound::Word128)) && v >= (toInteger (minBound::Wor\n         = \"Int::from_i128(\" <> pp v <> \")\"\n         | otherwise\n         = \"Int::parse_bytes(b\\\"\" <> pp v <> \"\\\", 10)\"\n+\n+-- Compute the atom or tuple of variables after the prefix of length n.\n+-- If this is the last term, then it is an expression of the LHS variables for each head\n+-- of the rule.\n+-- If this is the first term, then it's the atom of the RHSLiteral.\n+-- Otherwise, this is the variables from rhsVarsAfter converted into an ETuple expression.\n+recordAfterPrefix :: DatalogProgram -> Rule -> Int -> [Expr]\n+recordAfterPrefix d rl i =\n+  if i == length (ruleRHS rl) - 1\n+     then  map (\\lhs -> atomVal lhs) $ ruleLHS rl\n+     else if i == 0\n+             then [E EVar { exprPos = nopos,\n+                            exprVar = exprVar $ enode $ atomVal $ rhsAtom (ruleRHS rl !! i) }]\n+             else [E ETuple { exprPos = nopos,", "originalCommit": "8327f2c7a52ad61702434b97775ef7568a091860", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNjE1NA==", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439706154", "bodyText": "eBinding bindingName expr", "author": "ryzhyk", "createdAt": "2020-06-13T03:53:20Z", "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "diffHunk": "@@ -307,3 +311,221 @@ progMirrorInputRelations d prefix =\n     rules = map (\\(n,r) -> makeRule n r) inputRels\n   in d { progRelations = M.union (progRelations d) $ M.fromList relCopies,\n          progRules     = (progRules d) ++ rules }\n+\n+-- For RHSLiteral, a binding to the expression is inserted if it's not bound to a variable.\n+-- For example, R(a, b, z, _) gets transformed into __r0 in R(a, b, z, _),\n+addBindingToRHSLiteral :: (RuleRHS, Int) -> RuleRHS\n+addBindingToRHSLiteral (r@RHSLiteral{}, index) =\n+  let\n+    bindingName = \"__\" ++ (map toLower $ atomRelation $ rhsAtom r) ++ (show index)\n+    expr = atomVal $ rhsAtom r\n+    exprNode = enode expr\n+    updatedAtomVal = case exprNode of\n+                     EBinding{} -> expr\n+                     _          -> E $ EBinding { exprPos = exprPos exprNode,", "originalCommit": "8327f2c7a52ad61702434b97775ef7568a091860", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzg5MA==", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439707890", "bodyText": "head is a bit nicer than !! 0.\nAlso, please use eTuple, eSet,eVarDecl, eTupField, eVar to shorten this code.", "author": "ryzhyk", "createdAt": "2020-06-13T04:27:34Z", "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "diffHunk": "@@ -307,3 +311,221 @@ progMirrorInputRelations d prefix =\n     rules = map (\\(n,r) -> makeRule n r) inputRels\n   in d { progRelations = M.union (progRelations d) $ M.fromList relCopies,\n          progRules     = (progRules d) ++ rules }\n+\n+-- For RHSLiteral, a binding to the expression is inserted if it's not bound to a variable.\n+-- For example, R(a, b, z, _) gets transformed into __r0 in R(a, b, z, _),\n+addBindingToRHSLiteral :: (RuleRHS, Int) -> RuleRHS\n+addBindingToRHSLiteral (r@RHSLiteral{}, index) =\n+  let\n+    bindingName = \"__\" ++ (map toLower $ atomRelation $ rhsAtom r) ++ (show index)\n+    expr = atomVal $ rhsAtom r\n+    exprNode = enode expr\n+    updatedAtomVal = case exprNode of\n+                     EBinding{} -> expr\n+                     _          -> E $ EBinding { exprPos = exprPos exprNode,\n+                                                  exprVar = bindingName,\n+                                                  exprPattern = expr }\n+    updatedAtom = (rhsAtom r) { atomVal = updatedAtomVal }\n+  in r { rhsAtom = updatedAtom }\n+addBindingToRHSLiteral (rule, _) = rule\n+\n+-- For RHSAggregate, the aggregate function is prepended with __debug_\n+-- The input to the aggregate function is transformed into a tuple of\n+-- input to the aggregate operator and the original value.\n+-- The return variable is also prepended with __inputs_, which will now be\n+-- a tuple.\n+-- The corrddesponding compiler-generated function also outputs the set of\n+-- inputs, so that it is visible to the inspect operator.\n+-- an RHSCondition is also appended that declares and sets the original\n+-- return variable of the pre-updated aggregate operator.\n+updateRHSAggregate :: DatalogProgram -> Rule -> Int -> [RuleRHS]\n+updateRHSAggregate d rule index =\n+  let\n+     r = (ruleRHS rule) !! index\n+     funcName = \"__debug_\" ++ (rhsAggFunc r)\n+     varRet = \"__inputs_\" ++ (rhsVar r)\n+     input = E ETuple { exprPos = nopos,\n+                        exprTupleFields = [ (Compile.recordAfterPrefix d rule (index - 1)) !! 0,", "originalCommit": "8327f2c7a52ad61702434b97775ef7568a091860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzNzc2NA==", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r440437764", "bodyText": "Thanks. didn't realize we have those helper functions.", "author": "haroldlim", "createdAt": "2020-06-15T20:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwNzg5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODI5MQ==", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439708291", "bodyText": "Why not just make it a tuple?", "author": "ryzhyk", "createdAt": "2020-06-13T04:35:29Z", "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "diffHunk": "@@ -307,3 +311,221 @@ progMirrorInputRelations d prefix =\n     rules = map (\\(n,r) -> makeRule n r) inputRels\n   in d { progRelations = M.union (progRelations d) $ M.fromList relCopies,\n          progRules     = (progRules d) ++ rules }\n+\n+-- For RHSLiteral, a binding to the expression is inserted if it's not bound to a variable.\n+-- For example, R(a, b, z, _) gets transformed into __r0 in R(a, b, z, _),\n+addBindingToRHSLiteral :: (RuleRHS, Int) -> RuleRHS\n+addBindingToRHSLiteral (r@RHSLiteral{}, index) =\n+  let\n+    bindingName = \"__\" ++ (map toLower $ atomRelation $ rhsAtom r) ++ (show index)\n+    expr = atomVal $ rhsAtom r\n+    exprNode = enode expr\n+    updatedAtomVal = case exprNode of\n+                     EBinding{} -> expr\n+                     _          -> E $ EBinding { exprPos = exprPos exprNode,\n+                                                  exprVar = bindingName,\n+                                                  exprPattern = expr }\n+    updatedAtom = (rhsAtom r) { atomVal = updatedAtomVal }\n+  in r { rhsAtom = updatedAtom }\n+addBindingToRHSLiteral (rule, _) = rule\n+\n+-- For RHSAggregate, the aggregate function is prepended with __debug_\n+-- The input to the aggregate function is transformed into a tuple of\n+-- input to the aggregate operator and the original value.\n+-- The return variable is also prepended with __inputs_, which will now be\n+-- a tuple.\n+-- The corrddesponding compiler-generated function also outputs the set of\n+-- inputs, so that it is visible to the inspect operator.\n+-- an RHSCondition is also appended that declares and sets the original\n+-- return variable of the pre-updated aggregate operator.\n+updateRHSAggregate :: DatalogProgram -> Rule -> Int -> [RuleRHS]\n+updateRHSAggregate d rule index =\n+  let\n+     r = (ruleRHS rule) !! index\n+     funcName = \"__debug_\" ++ (rhsAggFunc r)\n+     varRet = \"__inputs_\" ++ (rhsVar r)\n+     input = E ETuple { exprPos = nopos,\n+                        exprTupleFields = [ (Compile.recordAfterPrefix d rule (index - 1)) !! 0,\n+                                            (rhsAggExpr r) ] }\n+     rAgg = RHSAggregate { rhsVar = varRet,\n+                           rhsGroupBy = rhsGroupBy r,\n+                           rhsAggFunc = funcName,\n+                           rhsAggExpr = input }\n+     rCond = RHSCondition { rhsExpr = E ESet { exprPos = nopos,\n+                                               exprLVal = E EVarDecl { exprPos = nopos,\n+                                                                       exprVName = rhsVar r },\n+                                               exprRVal = E ETupField { exprPos = nopos,\n+                                                                        exprTuple = E EVar { exprPos = nopos,\n+                                                                                             exprVar = varRet },\n+                                                                        exprTupField = 1 } } }\n+  in [ rAgg, rCond ]\n+\n+-- OperatorID is based on rule index, rhs index and head index\n+-- The 12 MSB are reserved for the rule index.\n+-- The next 16 bits are reserved for the rhs index.\n+-- The 4 LSB are reserved for the head index.\n+generateOperatorIdExpr :: Int -> Int -> Int -> Expr\n+generateOperatorIdExpr rlIdx rhsIdx headIdx =\n+  let\n+    operatorId = toInteger $ (shiftL (rlIdx .&. 4095) 20) .|. (shiftL (rhsIdx .&. 32767) 4) .|. (headIdx .&. 15)", "originalCommit": "8327f2c7a52ad61702434b97775ef7568a091860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc3MDY2Nw==", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439770667", "bodyText": "Brain fart. Forgot that I can use tuples.", "author": "haroldlim", "createdAt": "2020-06-13T21:26:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwODcxOQ==", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439708719", "bodyText": "eVar", "author": "ryzhyk", "createdAt": "2020-06-13T04:44:25Z", "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "diffHunk": "@@ -307,3 +311,221 @@ progMirrorInputRelations d prefix =\n     rules = map (\\(n,r) -> makeRule n r) inputRels\n   in d { progRelations = M.union (progRelations d) $ M.fromList relCopies,\n          progRules     = (progRules d) ++ rules }\n+\n+-- For RHSLiteral, a binding to the expression is inserted if it's not bound to a variable.\n+-- For example, R(a, b, z, _) gets transformed into __r0 in R(a, b, z, _),\n+addBindingToRHSLiteral :: (RuleRHS, Int) -> RuleRHS\n+addBindingToRHSLiteral (r@RHSLiteral{}, index) =\n+  let\n+    bindingName = \"__\" ++ (map toLower $ atomRelation $ rhsAtom r) ++ (show index)\n+    expr = atomVal $ rhsAtom r\n+    exprNode = enode expr\n+    updatedAtomVal = case exprNode of\n+                     EBinding{} -> expr\n+                     _          -> E $ EBinding { exprPos = exprPos exprNode,\n+                                                  exprVar = bindingName,\n+                                                  exprPattern = expr }\n+    updatedAtom = (rhsAtom r) { atomVal = updatedAtomVal }\n+  in r { rhsAtom = updatedAtom }\n+addBindingToRHSLiteral (rule, _) = rule\n+\n+-- For RHSAggregate, the aggregate function is prepended with __debug_\n+-- The input to the aggregate function is transformed into a tuple of\n+-- input to the aggregate operator and the original value.\n+-- The return variable is also prepended with __inputs_, which will now be\n+-- a tuple.\n+-- The corrddesponding compiler-generated function also outputs the set of\n+-- inputs, so that it is visible to the inspect operator.\n+-- an RHSCondition is also appended that declares and sets the original\n+-- return variable of the pre-updated aggregate operator.\n+updateRHSAggregate :: DatalogProgram -> Rule -> Int -> [RuleRHS]\n+updateRHSAggregate d rule index =\n+  let\n+     r = (ruleRHS rule) !! index\n+     funcName = \"__debug_\" ++ (rhsAggFunc r)\n+     varRet = \"__inputs_\" ++ (rhsVar r)\n+     input = E ETuple { exprPos = nopos,\n+                        exprTupleFields = [ (Compile.recordAfterPrefix d rule (index - 1)) !! 0,\n+                                            (rhsAggExpr r) ] }\n+     rAgg = RHSAggregate { rhsVar = varRet,\n+                           rhsGroupBy = rhsGroupBy r,\n+                           rhsAggFunc = funcName,\n+                           rhsAggExpr = input }\n+     rCond = RHSCondition { rhsExpr = E ESet { exprPos = nopos,\n+                                               exprLVal = E EVarDecl { exprPos = nopos,\n+                                                                       exprVName = rhsVar r },\n+                                               exprRVal = E ETupField { exprPos = nopos,\n+                                                                        exprTuple = E EVar { exprPos = nopos,\n+                                                                                             exprVar = varRet },\n+                                                                        exprTupField = 1 } } }\n+  in [ rAgg, rCond ]\n+\n+-- OperatorID is based on rule index, rhs index and head index\n+-- The 12 MSB are reserved for the rule index.\n+-- The next 16 bits are reserved for the rhs index.\n+-- The 4 LSB are reserved for the head index.\n+generateOperatorIdExpr :: Int -> Int -> Int -> Expr\n+generateOperatorIdExpr rlIdx rhsIdx headIdx =\n+  let\n+    operatorId = toInteger $ (shiftL (rlIdx .&. 4095) 20) .|. (shiftL (rhsIdx .&. 32767) 4) .|. (headIdx .&. 15)\n+  in E EBit { exprPos = nopos,\n+               exprWidth = 32,\n+               exprIVal = operatorId }\n+\n+ddlogWeightExpr :: Expr\n+ddlogWeightExpr =\n+  E EVar { exprPos = nopos,", "originalCommit": "8327f2c7a52ad61702434b97775ef7568a091860", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwOTI5OA==", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439709298", "bodyText": "Isn't the index==0 case covered by recordAfterPrefix?", "author": "ryzhyk", "createdAt": "2020-06-13T04:55:11Z", "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "diffHunk": "@@ -307,3 +311,221 @@ progMirrorInputRelations d prefix =\n     rules = map (\\(n,r) -> makeRule n r) inputRels\n   in d { progRelations = M.union (progRelations d) $ M.fromList relCopies,\n          progRules     = (progRules d) ++ rules }\n+\n+-- For RHSLiteral, a binding to the expression is inserted if it's not bound to a variable.\n+-- For example, R(a, b, z, _) gets transformed into __r0 in R(a, b, z, _),\n+addBindingToRHSLiteral :: (RuleRHS, Int) -> RuleRHS\n+addBindingToRHSLiteral (r@RHSLiteral{}, index) =\n+  let\n+    bindingName = \"__\" ++ (map toLower $ atomRelation $ rhsAtom r) ++ (show index)\n+    expr = atomVal $ rhsAtom r\n+    exprNode = enode expr\n+    updatedAtomVal = case exprNode of\n+                     EBinding{} -> expr\n+                     _          -> E $ EBinding { exprPos = exprPos exprNode,\n+                                                  exprVar = bindingName,\n+                                                  exprPattern = expr }\n+    updatedAtom = (rhsAtom r) { atomVal = updatedAtomVal }\n+  in r { rhsAtom = updatedAtom }\n+addBindingToRHSLiteral (rule, _) = rule\n+\n+-- For RHSAggregate, the aggregate function is prepended with __debug_\n+-- The input to the aggregate function is transformed into a tuple of\n+-- input to the aggregate operator and the original value.\n+-- The return variable is also prepended with __inputs_, which will now be\n+-- a tuple.\n+-- The corrddesponding compiler-generated function also outputs the set of\n+-- inputs, so that it is visible to the inspect operator.\n+-- an RHSCondition is also appended that declares and sets the original\n+-- return variable of the pre-updated aggregate operator.\n+updateRHSAggregate :: DatalogProgram -> Rule -> Int -> [RuleRHS]\n+updateRHSAggregate d rule index =\n+  let\n+     r = (ruleRHS rule) !! index\n+     funcName = \"__debug_\" ++ (rhsAggFunc r)\n+     varRet = \"__inputs_\" ++ (rhsVar r)\n+     input = E ETuple { exprPos = nopos,\n+                        exprTupleFields = [ (Compile.recordAfterPrefix d rule (index - 1)) !! 0,\n+                                            (rhsAggExpr r) ] }\n+     rAgg = RHSAggregate { rhsVar = varRet,\n+                           rhsGroupBy = rhsGroupBy r,\n+                           rhsAggFunc = funcName,\n+                           rhsAggExpr = input }\n+     rCond = RHSCondition { rhsExpr = E ESet { exprPos = nopos,\n+                                               exprLVal = E EVarDecl { exprPos = nopos,\n+                                                                       exprVName = rhsVar r },\n+                                               exprRVal = E ETupField { exprPos = nopos,\n+                                                                        exprTuple = E EVar { exprPos = nopos,\n+                                                                                             exprVar = varRet },\n+                                                                        exprTupField = 1 } } }\n+  in [ rAgg, rCond ]\n+\n+-- OperatorID is based on rule index, rhs index and head index\n+-- The 12 MSB are reserved for the rule index.\n+-- The next 16 bits are reserved for the rhs index.\n+-- The 4 LSB are reserved for the head index.\n+generateOperatorIdExpr :: Int -> Int -> Int -> Expr\n+generateOperatorIdExpr rlIdx rhsIdx headIdx =\n+  let\n+    operatorId = toInteger $ (shiftL (rlIdx .&. 4095) 20) .|. (shiftL (rhsIdx .&. 32767) 4) .|. (headIdx .&. 15)\n+  in E EBit { exprPos = nopos,\n+               exprWidth = 32,\n+               exprIVal = operatorId }\n+\n+ddlogWeightExpr :: Expr\n+ddlogWeightExpr =\n+  E EVar { exprPos = nopos,\n+           exprVar = \"ddlog_weight\" }\n+\n+ddlogTimestampExpr :: Expr\n+ddlogTimestampExpr =\n+  E EVar { exprPos = nopos,\n+           exprVar = \"ddlog_timestamp\" }\n+\n+generateInspectDebugJoin :: DatalogProgram -> Int -> Rule -> Int -> [RuleRHS]\n+generateInspectDebugJoin d ruleIdx rule index =\n+  let\n+    input1 = (Compile.recordAfterPrefix d rule (index - 1)) !! 0\n+    input2 = E EVar { exprPos = nopos,\n+                      exprVar = exprVar $ enode $ atomVal $ rhsAtom (ruleRHS rule !! index) }\n+    outputs = Compile.recordAfterPrefix d rule index\n+  in map (\\i -> RHSInspect {rhsInspectExpr = E $ EApply {exprPos = nopos,\n+                                                         exprFunc = \"debug.debug_event_join\",\n+                                                         exprArgs = [generateOperatorIdExpr ruleIdx index i,\n+                                                                     ddlogWeightExpr,\n+                                                                     ddlogTimestampExpr,\n+                                                                     input1,\n+                                                                     input2,\n+                                                                     outputs !! i]}}) [0..length outputs - 1]\n+\n+generateInspectDebug :: DatalogProgram -> Int -> Rule -> Int -> [RuleRHS]\n+generateInspectDebug d ruleIdx rule index =\n+  let\n+    input1 = if index == 0", "originalCommit": "8327f2c7a52ad61702434b97775ef7568a091860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgxMDQ5Mw==", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439810493", "bodyText": "I'm trying to handle the case where the rule only has a single literal.\nR5(a, b) :-\nr1 in R1(a, b, _, _).\nI want the call to debug_event to have (r1, R5{a, b})\nSo input is r1, and output is the R5.\nIf I use recordAfterPrefix  (index), it will return R5. So both input and output will be R5{a, b}. Or does it matter in this case?", "author": "haroldlim", "createdAt": "2020-06-14T09:37:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwOTI5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0ODEzNg==", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439848136", "bodyText": "My bad, your code makes sense!", "author": "ryzhyk", "createdAt": "2020-06-14T16:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcwOTI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTcxMTA0OQ==", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439711049", "bodyText": "An example generated function would be nice.", "author": "ryzhyk", "createdAt": "2020-06-13T05:28:35Z", "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "diffHunk": "@@ -307,3 +311,221 @@ progMirrorInputRelations d prefix =\n     rules = map (\\(n,r) -> makeRule n r) inputRels\n   in d { progRelations = M.union (progRelations d) $ M.fromList relCopies,\n          progRules     = (progRules d) ++ rules }\n+\n+-- For RHSLiteral, a binding to the expression is inserted if it's not bound to a variable.\n+-- For example, R(a, b, z, _) gets transformed into __r0 in R(a, b, z, _),\n+addBindingToRHSLiteral :: (RuleRHS, Int) -> RuleRHS\n+addBindingToRHSLiteral (r@RHSLiteral{}, index) =\n+  let\n+    bindingName = \"__\" ++ (map toLower $ atomRelation $ rhsAtom r) ++ (show index)\n+    expr = atomVal $ rhsAtom r\n+    exprNode = enode expr\n+    updatedAtomVal = case exprNode of\n+                     EBinding{} -> expr\n+                     _          -> E $ EBinding { exprPos = exprPos exprNode,\n+                                                  exprVar = bindingName,\n+                                                  exprPattern = expr }\n+    updatedAtom = (rhsAtom r) { atomVal = updatedAtomVal }\n+  in r { rhsAtom = updatedAtom }\n+addBindingToRHSLiteral (rule, _) = rule\n+\n+-- For RHSAggregate, the aggregate function is prepended with __debug_\n+-- The input to the aggregate function is transformed into a tuple of\n+-- input to the aggregate operator and the original value.\n+-- The return variable is also prepended with __inputs_, which will now be\n+-- a tuple.\n+-- The corrddesponding compiler-generated function also outputs the set of\n+-- inputs, so that it is visible to the inspect operator.\n+-- an RHSCondition is also appended that declares and sets the original\n+-- return variable of the pre-updated aggregate operator.\n+updateRHSAggregate :: DatalogProgram -> Rule -> Int -> [RuleRHS]\n+updateRHSAggregate d rule index =\n+  let\n+     r = (ruleRHS rule) !! index\n+     funcName = \"__debug_\" ++ (rhsAggFunc r)\n+     varRet = \"__inputs_\" ++ (rhsVar r)\n+     input = E ETuple { exprPos = nopos,\n+                        exprTupleFields = [ (Compile.recordAfterPrefix d rule (index - 1)) !! 0,\n+                                            (rhsAggExpr r) ] }\n+     rAgg = RHSAggregate { rhsVar = varRet,\n+                           rhsGroupBy = rhsGroupBy r,\n+                           rhsAggFunc = funcName,\n+                           rhsAggExpr = input }\n+     rCond = RHSCondition { rhsExpr = E ESet { exprPos = nopos,\n+                                               exprLVal = E EVarDecl { exprPos = nopos,\n+                                                                       exprVName = rhsVar r },\n+                                               exprRVal = E ETupField { exprPos = nopos,\n+                                                                        exprTuple = E EVar { exprPos = nopos,\n+                                                                                             exprVar = varRet },\n+                                                                        exprTupField = 1 } } }\n+  in [ rAgg, rCond ]\n+\n+-- OperatorID is based on rule index, rhs index and head index\n+-- The 12 MSB are reserved for the rule index.\n+-- The next 16 bits are reserved for the rhs index.\n+-- The 4 LSB are reserved for the head index.\n+generateOperatorIdExpr :: Int -> Int -> Int -> Expr\n+generateOperatorIdExpr rlIdx rhsIdx headIdx =\n+  let\n+    operatorId = toInteger $ (shiftL (rlIdx .&. 4095) 20) .|. (shiftL (rhsIdx .&. 32767) 4) .|. (headIdx .&. 15)\n+  in E EBit { exprPos = nopos,\n+               exprWidth = 32,\n+               exprIVal = operatorId }\n+\n+ddlogWeightExpr :: Expr\n+ddlogWeightExpr =\n+  E EVar { exprPos = nopos,\n+           exprVar = \"ddlog_weight\" }\n+\n+ddlogTimestampExpr :: Expr\n+ddlogTimestampExpr =\n+  E EVar { exprPos = nopos,\n+           exprVar = \"ddlog_timestamp\" }\n+\n+generateInspectDebugJoin :: DatalogProgram -> Int -> Rule -> Int -> [RuleRHS]\n+generateInspectDebugJoin d ruleIdx rule index =\n+  let\n+    input1 = (Compile.recordAfterPrefix d rule (index - 1)) !! 0\n+    input2 = E EVar { exprPos = nopos,\n+                      exprVar = exprVar $ enode $ atomVal $ rhsAtom (ruleRHS rule !! index) }\n+    outputs = Compile.recordAfterPrefix d rule index\n+  in map (\\i -> RHSInspect {rhsInspectExpr = E $ EApply {exprPos = nopos,\n+                                                         exprFunc = \"debug.debug_event_join\",\n+                                                         exprArgs = [generateOperatorIdExpr ruleIdx index i,\n+                                                                     ddlogWeightExpr,\n+                                                                     ddlogTimestampExpr,\n+                                                                     input1,\n+                                                                     input2,\n+                                                                     outputs !! i]}}) [0..length outputs - 1]\n+\n+generateInspectDebug :: DatalogProgram -> Int -> Rule -> Int -> [RuleRHS]\n+generateInspectDebug d ruleIdx rule index =\n+  let\n+    input1 = if index == 0\n+                then E EVar { exprPos = nopos,\n+                              exprVar = exprVar $ enode $ atomVal $ rhsAtom (ruleRHS rule !! index) }\n+                else (Compile.recordAfterPrefix d rule (index - 1)) !! 0\n+    outputs = Compile.recordAfterPrefix d rule index\n+  in map (\\i -> RHSInspect {rhsInspectExpr = E $ EApply {exprPos = nopos,\n+                                                         exprFunc = \"debug.debug_event\",\n+                                                         exprArgs = [generateOperatorIdExpr ruleIdx index i,\n+                                                                     ddlogWeightExpr,\n+                                                                     ddlogTimestampExpr,\n+                                                                     input1,\n+                                                                     outputs !! i]}}) [0..length outputs - 1]\n+\n+generateInspectDebugAggregate :: DatalogProgram -> Int -> Rule -> Int -> [RuleRHS]\n+generateInspectDebugAggregate d ruleIdx rule index =\n+  let\n+    input1 = E ETupField { exprPos = nopos,\n+                           exprTuple = E EVar { exprPos = nopos,\n+                                                exprVar = rhsVar $ (ruleRHS rule !! index) },\n+                           exprTupField = 0 }\n+    outputs = Compile.recordAfterPrefix d rule index\n+  in map (\\i -> RHSInspect {rhsInspectExpr = E $ EApply {exprPos = nopos,\n+                                                         exprFunc = \"debug.debug_event\",\n+                                                         exprArgs = [generateOperatorIdExpr ruleIdx index i,\n+                                                                     ddlogWeightExpr,\n+                                                                     ddlogTimestampExpr,\n+                                                                     input1,\n+                                                                     outputs !! i]}}) [0..length outputs -1]\n+\n+mkInspect :: DatalogProgram -> Int -> Rule -> Int -> Maybe [RuleRHS]\n+mkInspect d ruleIdx rule index =\n+  let rhsRule = ruleRHS rule\n+  in if index == 0 && index < length rhsRule - 1\n+        then Nothing\n+        else if rhsIsCondition (rhsRule !! index) && index /= length rhsRule - 1 && rhsIsCondition (rhsRule !! (index + 1))\n+                then Nothing\n+                else if index == 0\n+                     then Just $ generateInspectDebug d ruleIdx rule index -- single term rule\n+                     else case rhsRule !! index of\n+                          RHSLiteral{rhsPolarity=True} -> Just $ generateInspectDebugJoin d ruleIdx rule index -- join\n+                          RHSAggregate{} -> Just $ generateInspectDebugAggregate d ruleIdx rule index -- aggregate\n+                          _ -> Just $ generateInspectDebug d ruleIdx rule index -- antijoin, flatmap, filter/assignment, inspect\n+\n+-- Insert inspect debug hook after each RHS term, except for the following:\n+-- 1. If a group of conditions appear consecutively, inspect debug hook is only\n+-- inserted after the last condition in the group.\n+-- 2. Inspect debug hook is not inserted after the first term, unless the rule\n+-- only contains one literal.\n+-- 3. If a rule has multiple heads, then multiple inspect is inserted after the last\n+-- term corresponding to each head.\n+insertRHSInspectDebugHooks :: DatalogProgram -> Int -> Rule -> [RuleRHS]\n+insertRHSInspectDebugHooks d rlIdx rule =\n+  concatMap (\\i -> let inspect = concat $ maybeToList $ mkInspect d rlIdx rule i in\n+                   (ruleRHS rule !! i) : inspect) [0..length (ruleRHS rule) - 1]\n+\n+updateRHSRules :: DatalogProgram -> Int -> Rule -> [RuleRHS]\n+updateRHSRules d rlIdx rule =\n+  let\n+    -- First pass updates RHSLiteral without any binding with a binding.\n+    rhs =  map (\\r -> case r of\n+                      (RHSLiteral True _ , _) -> addBindingToRHSLiteral r\n+                      _                       -> fst r) $ zip (ruleRHS rule) [0..]\n+    -- Second pass updates RHSAggregate to use the debug function (so that inputs are not dropped).\n+    rhs' = concatMap (\\i -> case rhs !! i of\n+                            RHSAggregate{} -> updateRHSAggregate d rule {ruleRHS = rhs} i\n+                            _              -> [rhs !! i]) $ [0..length rhs - 1]\n+  in insertRHSInspectDebugHooks d rlIdx rule {ruleRHS = rhs'}\n+\n+-- Insert an aggregate function that wraps the original function used in the aggregate term.", "originalCommit": "8327f2c7a52ad61702434b97775ef7568a091860", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1d9206dfdda60227a79898018e059479fe16e508", "url": "https://github.com/vmware/differential-datalog/commit/1d9206dfdda60227a79898018e059479fe16e508", "message": "Add bindings to right hand side literals when debugging hooks is enabled", "committedDate": "2020-06-14T08:29:54Z", "type": "commit"}, {"oid": "2073a1c5f2eb14e0c8c316f3e0fed1a7528f31fa", "url": "https://github.com/vmware/differential-datalog/commit/2073a1c5f2eb14e0c8c316f3e0fed1a7528f31fa", "message": "Add dummy inspects after in the RuleRHS list of a Rule\n\nDummy inspect operator is added after each term, except for the\nfollowing cases:\n1. inspect is not inserted after the first term, unless the rule\n   only has 1 term.\n2. The term is a condition part of consecutive conditions. In this\n   case inspect is only added after the last condition term.\n3. If the rule has multiple heads, then the multiple inspect is\n   added after the last term, corresponding to each head.", "committedDate": "2020-06-14T08:29:58Z", "type": "commit"}, {"oid": "ad126e4b4a0f9b08c172e426e3ce91735181b33d", "url": "https://github.com/vmware/differential-datalog/commit/ad126e4b4a0f9b08c172e426e3ce91735181b33d", "message": "Add recordAfterPrefix function\n\nThis function computes the atom or tuple of variables after the\nprefix of length n. If this is the last term, then it is an\nexpression with the LHS variables of each head of the rule.\nIf this is the first term, then it's the atom of the RHSLiteral.\nOtherwise, this is the variables from rhsVarsAfter converted into\nan ETuple expression.", "committedDate": "2020-06-14T08:29:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0ODMxNw==", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439848317", "bodyText": "One more comment I missed in my initial review: I think all the logic related to injecting debugging hooks deserves a separate module: src/Language/DifferentialDatalog/Debug.hs.", "author": "ryzhyk", "createdAt": "2020-06-14T16:53:26Z", "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "diffHunk": "@@ -307,3 +311,221 @@ progMirrorInputRelations d prefix =\n     rules = map (\\(n,r) -> makeRule n r) inputRels\n   in d { progRelations = M.union (progRelations d) $ M.fromList relCopies,\n          progRules     = (progRules d) ++ rules }\n+\n+-- For RHSLiteral, a binding to the expression is inserted if it's not bound to a variable.\n+-- For example, R(a, b, z, _) gets transformed into __r0 in R(a, b, z, _),\n+addBindingToRHSLiteral :: (RuleRHS, Int) -> RuleRHS", "originalCommit": "8327f2c7a52ad61702434b97775ef7568a091860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzNzk0OA==", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r440437948", "bodyText": "Done.", "author": "haroldlim", "createdAt": "2020-06-15T20:48:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0ODMxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1MTQ0Ng==", "url": "https://github.com/vmware/differential-datalog/pull/682#discussion_r439851446", "bodyText": "I don't think you need a special case for 0; foldl will do the right thing if aggregates is empty.\nAlso, it is always recommended to use foldl' over foldl in Haskell.\nFinal nit: concatMap (\\rule -> ruleRHS rule) rules is just concatMap ruleRHS rules.", "author": "ryzhyk", "createdAt": "2020-06-14T17:32:31Z", "path": "src/Language/DifferentialDatalog/DatalogProgram.hs", "diffHunk": "@@ -307,3 +311,221 @@ progMirrorInputRelations d prefix =\n     rules = map (\\(n,r) -> makeRule n r) inputRels\n   in d { progRelations = M.union (progRelations d) $ M.fromList relCopies,\n          progRules     = (progRules d) ++ rules }\n+\n+-- For RHSLiteral, a binding to the expression is inserted if it's not bound to a variable.\n+-- For example, R(a, b, z, _) gets transformed into __r0 in R(a, b, z, _),\n+addBindingToRHSLiteral :: (RuleRHS, Int) -> RuleRHS\n+addBindingToRHSLiteral (r@RHSLiteral{}, index) =\n+  let\n+    bindingName = \"__\" ++ (map toLower $ atomRelation $ rhsAtom r) ++ (show index)\n+    expr = atomVal $ rhsAtom r\n+    exprNode = enode expr\n+    updatedAtomVal = case exprNode of\n+                     EBinding{} -> expr\n+                     _          -> E $ EBinding { exprPos = exprPos exprNode,\n+                                                  exprVar = bindingName,\n+                                                  exprPattern = expr }\n+    updatedAtom = (rhsAtom r) { atomVal = updatedAtomVal }\n+  in r { rhsAtom = updatedAtom }\n+addBindingToRHSLiteral (rule, _) = rule\n+\n+-- For RHSAggregate, the aggregate function is prepended with __debug_\n+-- The input to the aggregate function is transformed into a tuple of\n+-- input to the aggregate operator and the original value.\n+-- The return variable is also prepended with __inputs_, which will now be\n+-- a tuple.\n+-- The corrddesponding compiler-generated function also outputs the set of\n+-- inputs, so that it is visible to the inspect operator.\n+-- an RHSCondition is also appended that declares and sets the original\n+-- return variable of the pre-updated aggregate operator.\n+updateRHSAggregate :: DatalogProgram -> Rule -> Int -> [RuleRHS]\n+updateRHSAggregate d rule index =\n+  let\n+     r = (ruleRHS rule) !! index\n+     funcName = \"__debug_\" ++ (rhsAggFunc r)\n+     varRet = \"__inputs_\" ++ (rhsVar r)\n+     input = E ETuple { exprPos = nopos,\n+                        exprTupleFields = [ (Compile.recordAfterPrefix d rule (index - 1)) !! 0,\n+                                            (rhsAggExpr r) ] }\n+     rAgg = RHSAggregate { rhsVar = varRet,\n+                           rhsGroupBy = rhsGroupBy r,\n+                           rhsAggFunc = funcName,\n+                           rhsAggExpr = input }\n+     rCond = RHSCondition { rhsExpr = E ESet { exprPos = nopos,\n+                                               exprLVal = E EVarDecl { exprPos = nopos,\n+                                                                       exprVName = rhsVar r },\n+                                               exprRVal = E ETupField { exprPos = nopos,\n+                                                                        exprTuple = E EVar { exprPos = nopos,\n+                                                                                             exprVar = varRet },\n+                                                                        exprTupField = 1 } } }\n+  in [ rAgg, rCond ]\n+\n+-- OperatorID is based on rule index, rhs index and head index\n+-- The 12 MSB are reserved for the rule index.\n+-- The next 16 bits are reserved for the rhs index.\n+-- The 4 LSB are reserved for the head index.\n+generateOperatorIdExpr :: Int -> Int -> Int -> Expr\n+generateOperatorIdExpr rlIdx rhsIdx headIdx =\n+  let\n+    operatorId = toInteger $ (shiftL (rlIdx .&. 4095) 20) .|. (shiftL (rhsIdx .&. 32767) 4) .|. (headIdx .&. 15)\n+  in E EBit { exprPos = nopos,\n+               exprWidth = 32,\n+               exprIVal = operatorId }\n+\n+ddlogWeightExpr :: Expr\n+ddlogWeightExpr =\n+  E EVar { exprPos = nopos,\n+           exprVar = \"ddlog_weight\" }\n+\n+ddlogTimestampExpr :: Expr\n+ddlogTimestampExpr =\n+  E EVar { exprPos = nopos,\n+           exprVar = \"ddlog_timestamp\" }\n+\n+generateInspectDebugJoin :: DatalogProgram -> Int -> Rule -> Int -> [RuleRHS]\n+generateInspectDebugJoin d ruleIdx rule index =\n+  let\n+    input1 = (Compile.recordAfterPrefix d rule (index - 1)) !! 0\n+    input2 = E EVar { exprPos = nopos,\n+                      exprVar = exprVar $ enode $ atomVal $ rhsAtom (ruleRHS rule !! index) }\n+    outputs = Compile.recordAfterPrefix d rule index\n+  in map (\\i -> RHSInspect {rhsInspectExpr = E $ EApply {exprPos = nopos,\n+                                                         exprFunc = \"debug.debug_event_join\",\n+                                                         exprArgs = [generateOperatorIdExpr ruleIdx index i,\n+                                                                     ddlogWeightExpr,\n+                                                                     ddlogTimestampExpr,\n+                                                                     input1,\n+                                                                     input2,\n+                                                                     outputs !! i]}}) [0..length outputs - 1]\n+\n+generateInspectDebug :: DatalogProgram -> Int -> Rule -> Int -> [RuleRHS]\n+generateInspectDebug d ruleIdx rule index =\n+  let\n+    input1 = if index == 0\n+                then E EVar { exprPos = nopos,\n+                              exprVar = exprVar $ enode $ atomVal $ rhsAtom (ruleRHS rule !! index) }\n+                else (Compile.recordAfterPrefix d rule (index - 1)) !! 0\n+    outputs = Compile.recordAfterPrefix d rule index\n+  in map (\\i -> RHSInspect {rhsInspectExpr = E $ EApply {exprPos = nopos,\n+                                                         exprFunc = \"debug.debug_event\",\n+                                                         exprArgs = [generateOperatorIdExpr ruleIdx index i,\n+                                                                     ddlogWeightExpr,\n+                                                                     ddlogTimestampExpr,\n+                                                                     input1,\n+                                                                     outputs !! i]}}) [0..length outputs - 1]\n+\n+generateInspectDebugAggregate :: DatalogProgram -> Int -> Rule -> Int -> [RuleRHS]\n+generateInspectDebugAggregate d ruleIdx rule index =\n+  let\n+    input1 = E ETupField { exprPos = nopos,\n+                           exprTuple = E EVar { exprPos = nopos,\n+                                                exprVar = rhsVar $ (ruleRHS rule !! index) },\n+                           exprTupField = 0 }\n+    outputs = Compile.recordAfterPrefix d rule index\n+  in map (\\i -> RHSInspect {rhsInspectExpr = E $ EApply {exprPos = nopos,\n+                                                         exprFunc = \"debug.debug_event\",\n+                                                         exprArgs = [generateOperatorIdExpr ruleIdx index i,\n+                                                                     ddlogWeightExpr,\n+                                                                     ddlogTimestampExpr,\n+                                                                     input1,\n+                                                                     outputs !! i]}}) [0..length outputs -1]\n+\n+mkInspect :: DatalogProgram -> Int -> Rule -> Int -> Maybe [RuleRHS]\n+mkInspect d ruleIdx rule index =\n+  let rhsRule = ruleRHS rule\n+  in if index == 0 && index < length rhsRule - 1\n+        then Nothing\n+        else if rhsIsCondition (rhsRule !! index) && index /= length rhsRule - 1 && rhsIsCondition (rhsRule !! (index + 1))\n+                then Nothing\n+                else if index == 0\n+                     then Just $ generateInspectDebug d ruleIdx rule index -- single term rule\n+                     else case rhsRule !! index of\n+                          RHSLiteral{rhsPolarity=True} -> Just $ generateInspectDebugJoin d ruleIdx rule index -- join\n+                          RHSAggregate{} -> Just $ generateInspectDebugAggregate d ruleIdx rule index -- aggregate\n+                          _ -> Just $ generateInspectDebug d ruleIdx rule index -- antijoin, flatmap, filter/assignment, inspect\n+\n+-- Insert inspect debug hook after each RHS term, except for the following:\n+-- 1. If a group of conditions appear consecutively, inspect debug hook is only\n+-- inserted after the last condition in the group.\n+-- 2. Inspect debug hook is not inserted after the first term, unless the rule\n+-- only contains one literal.\n+-- 3. If a rule has multiple heads, then multiple inspect is inserted after the last\n+-- term corresponding to each head.\n+insertRHSInspectDebugHooks :: DatalogProgram -> Int -> Rule -> [RuleRHS]\n+insertRHSInspectDebugHooks d rlIdx rule =\n+  concatMap (\\i -> let inspect = concat $ maybeToList $ mkInspect d rlIdx rule i in\n+                   (ruleRHS rule !! i) : inspect) [0..length (ruleRHS rule) - 1]\n+\n+updateRHSRules :: DatalogProgram -> Int -> Rule -> [RuleRHS]\n+updateRHSRules d rlIdx rule =\n+  let\n+    -- First pass updates RHSLiteral without any binding with a binding.\n+    rhs =  map (\\r -> case r of\n+                      (RHSLiteral True _ , _) -> addBindingToRHSLiteral r\n+                      _                       -> fst r) $ zip (ruleRHS rule) [0..]\n+    -- Second pass updates RHSAggregate to use the debug function (so that inputs are not dropped).\n+    rhs' = concatMap (\\i -> case rhs !! i of\n+                            RHSAggregate{} -> updateRHSAggregate d rule {ruleRHS = rhs} i\n+                            _              -> [rhs !! i]) $ [0..length rhs - 1]\n+  in insertRHSInspectDebugHooks d rlIdx rule {ruleRHS = rhs'}\n+\n+-- Insert an aggregate function that wraps the original function used in the aggregate term.\n+insertDebugAggregateFunction :: M.Map String Function -> String -> String -> M.Map String Function\n+insertDebugAggregateFunction functions fname origFname=\n+  let\n+    funcBody = E ESeq { exprPos = nopos,\n+                        exprLeft = E ESet { exprPos = nopos,\n+                                            exprLVal = E ETuple { exprPos = nopos,\n+                                                                  exprTupleFields = [ E EVarDecl { exprPos = nopos,\n+                                                                                                   exprVName = \"inputs\" },\n+                                                                                      E EVarDecl { exprPos = nopos,\n+                                                                                                   exprVName = \"original_group\" } ] },\n+                                            exprRVal = E EApply { exprPos = nopos,\n+                                                                  exprFunc = \"debug.debug_split_group\",\n+                                                                  exprArgs = [ E EVar { exprPos = nopos,\n+                                                                                        exprVar = \"g\" } ] } },\n+                        exprRight = E ETuple { exprPos = nopos,\n+                                               exprTupleFields = [ E EVar { exprPos = nopos,\n+                                                                            exprVar = \"inputs\" },\n+                                                                   E EApply { exprPos = nopos,\n+                                                                              exprFunc = origFname,\n+                                                                              exprArgs = [ E EVar { exprPos = nopos,\n+                                                                                                    exprVar = \"original_group\" } ] } ] } }\n+    function = Function { funcPos = nopos,\n+                          funcAttrs = [],\n+                          funcName = fname,\n+                          funcArgs = [ FuncArg { argPos = nopos,\n+                                                 argName = \"g\",\n+                                                 argMut = False,\n+                                                 argType = TOpaque { typePos = nopos,\n+                                                                     typeName = \"std.Group\",\n+                                                                     typeArgs = [ TVar { typePos = nopos, tvarName = \"K\" },\n+                                                                                  TTuple { typePos = nopos,\n+                                                                                           typeTupArgs = [ TVar { typePos = nopos, tvarName = \"I\" },\n+                                                                                                           TVar { typePos = nopos, tvarName = \"V\" } ] } ] } } ],\n+                          funcType = TTuple { typePos = nopos,\n+                                              typeTupArgs = [ TOpaque { typePos = nopos,\n+                                                                        typeName = \"std.Set\",\n+                                                                        typeArgs = [ TVar { typePos = nopos, tvarName = \"I\" } ] },\n+                                                              TVar { typePos = nopos, tvarName = \"V\" } ] },\n+                          funcDef = Just funcBody }\n+  in M.insert fname function functions\n+\n+-- Generate and insert into the map of functions a wrapper aggregate function for\n+-- each aggregate function used in the rule.\n+updateFunctions :: [Rule] -> M.Map String Function -> M.Map String Function\n+updateFunctions rules functions =\n+  let\n+    aggregates = filter rhsIsAggregate $ concatMap (\\rule -> ruleRHS rule) rules\n+  in case length aggregates of\n+     0 -> functions", "originalCommit": "8327f2c7a52ad61702434b97775ef7568a091860", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "48ca1f36dfa22cc5f3773dc7a351004edd0008fc", "url": "https://github.com/vmware/differential-datalog/commit/48ca1f36dfa22cc5f3773dc7a351004edd0008fc", "message": "Move debug-hooks related functions to Debug.hs\n\nAlso prefixed functions exported by Debug.hs with debug and\nfunction exported by DatalogProgram.hs with prog.", "committedDate": "2020-06-15T06:03:42Z", "type": "forcePushed"}, {"oid": "9f2a6a35b8cab795a807d3a2ad80e5897cd7f374", "url": "https://github.com/vmware/differential-datalog/commit/9f2a6a35b8cab795a807d3a2ad80e5897cd7f374", "message": "Move debug-hooks related functions to Debug.hs\n\nAlso prefixed functions exported by Debug.hs with debug and\nfunction exported by DatalogProgram.hs with prog.", "committedDate": "2020-06-15T07:50:32Z", "type": "forcePushed"}, {"oid": "2e6452a9549e26623aa5f81a71fbeaa20f94d075", "url": "https://github.com/vmware/differential-datalog/commit/2e6452a9549e26623aa5f81a71fbeaa20f94d075", "message": "Move debug-hooks related functions to Debug.hs\n\nAlso prefixed functions exported by Debug.hs with debug and\nfunction exported by DatalogProgram.hs with prog.", "committedDate": "2020-06-15T22:54:23Z", "type": "forcePushed"}, {"oid": "177376cccb1961315008101a0164f6400b345d44", "url": "https://github.com/vmware/differential-datalog/commit/177376cccb1961315008101a0164f6400b345d44", "message": "Move debug-hooks related functions to Debug.hs\n\nAlso prefixed functions exported by Debug.hs with debug and\nfunction exported by DatalogProgram.hs with prog.", "committedDate": "2020-06-15T23:22:01Z", "type": "forcePushed"}, {"oid": "0235f7dc5ee7d666cd157d254529d9c6b7911c92", "url": "https://github.com/vmware/differential-datalog/commit/0235f7dc5ee7d666cd157d254529d9c6b7911c92", "message": "Add debugging hooks dl function declaration\n\ndebug.dl file is added containing declaration of\nextern functions debug_event and debug_event_join.\n\nA corresponding rust implementation for these functions\nis also added. It currently simply writes the received\nrecords to a file.", "committedDate": "2020-06-16T00:31:40Z", "type": "commit"}, {"oid": "6bd26d5260e3171cbd686557225fb146229e21a5", "url": "https://github.com/vmware/differential-datalog/commit/6bd26d5260e3171cbd686557225fb146229e21a5", "message": "Update debug injection function with correct inspect expression\n\nAdd function implementation for generating  inspect operator after\na join, antijoin, condition, flatmap.\n\nNote that inspect after aggregate is not yet implemented, since\nit requires pre-transforming the aggregate term to expose input.", "committedDate": "2020-06-16T00:31:54Z", "type": "commit"}, {"oid": "8ba1fdcd8fec39239758bcb07a01262754784144", "url": "https://github.com/vmware/differential-datalog/commit/8ba1fdcd8fec39239758bcb07a01262754784144", "message": "Add a pp option to dump the transformed souce into a file", "committedDate": "2020-06-16T00:31:54Z", "type": "commit"}, {"oid": "2dbe7082f20ed682e334d956d05c29c4ce6bf453", "url": "https://github.com/vmware/differential-datalog/commit/2dbe7082f20ed682e334d956d05c29c4ce6bf453", "message": "Add aggregate functions and operators when debug hook is enabled\n\nDefine an extern debug_split_group function that will\nbe used by the autogenerated aggregate functions used for\ndebugging. The aggregate function wraps the original\nfunction used in the ddlog program.\n\nThe actual implementation of debug_split_group is not yet\nimplemented.\n\nSince the inputs to the aggregate term is not visible after the\naggregation, the aggregate function is updated to use a compiler\ngenerated function that takes in both the inputs and the original\naggregate input variable and includes the set of inputs in the\noutput. An RHSCondition is also inserted after the aggregate term\nthat declares and sets the original return variable of the aggregate\noperator.", "committedDate": "2020-06-16T00:31:54Z", "type": "commit"}, {"oid": "0b28a1197dee7038243706242925916d469c00c6", "url": "https://github.com/vmware/differential-datalog/commit/0b28a1197dee7038243706242925916d469c00c6", "message": "Include operator id when injecting inspect operator debug event\n\noperator id is a tuple composed ofrule index, rhs index and head index.\nThis allows the debugger tool to uniquely identify which operator\ngenerated the event.", "committedDate": "2020-06-16T00:31:54Z", "type": "commit"}, {"oid": "0416a5cd9cc81f2fdf87637582e8f9c1800d6ee1", "url": "https://github.com/vmware/differential-datalog/commit/0416a5cd9cc81f2fdf87637582e8f9c1800d6ee1", "message": "Move debug-hooks related functions to Debug.hs\n\nAlso prefixed functions exported by Debug.hs with debug and\nfunction exported by DatalogProgram.hs with prog.", "committedDate": "2020-06-16T00:31:54Z", "type": "commit"}, {"oid": "0416a5cd9cc81f2fdf87637582e8f9c1800d6ee1", "url": "https://github.com/vmware/differential-datalog/commit/0416a5cd9cc81f2fdf87637582e8f9c1800d6ee1", "message": "Move debug-hooks related functions to Debug.hs\n\nAlso prefixed functions exported by Debug.hs with debug and\nfunction exported by DatalogProgram.hs with prog.", "committedDate": "2020-06-16T00:31:54Z", "type": "forcePushed"}, {"oid": "a1ee0f6a0effb611ef10a77facae57d93d169bf2", "url": "https://github.com/vmware/differential-datalog/commit/a1ee0f6a0effb611ef10a77facae57d93d169bf2", "message": "Change `std_Group.project` type to closure.\n\nThe `project` field of the `std_Group` type maps `DDValue` to the inner\ntype of the group.  It was originally defined as a function.  Here we\ngeneralize it to a closure.  The concrete use case we want to enable right\nnow came up when injecting debugging hooks in the program: given a group\nover a two-tuple, we want to transform it into a group over the second\nelement of the tuple by simply changing the projection function.", "committedDate": "2020-06-17T20:04:34Z", "type": "commit"}, {"oid": "ac45ebc99ca95be1318f9f92a72ef0197c4c702c", "url": "https://github.com/vmware/differential-datalog/commit/ac45ebc99ca95be1318f9f92a72ef0197c4c702c", "message": "debug.dl: debug_split_group implementation.\n\nChange `debug_split_group()` signature to return a vector instead of set;\nimplement the method in Rust by wrapping the original `Group.project`\nclosure.", "committedDate": "2020-06-17T20:04:34Z", "type": "commit"}, {"oid": "892a017f9623db55c4f0647602e30865bf1e22b9", "url": "https://github.com/vmware/differential-datalog/commit/892a017f9623db55c4f0647602e30865bf1e22b9", "message": "std.rs: Wrap ProjectFunc in Rc.\n\nWrap `ProjectFunc` closure in `Rc` so it can be clonned in\n`debug_split_group`.", "committedDate": "2020-06-17T20:04:34Z", "type": "commit"}, {"oid": "a9ee03b033a678504ac7202147800adbf4daf5ee", "url": "https://github.com/vmware/differential-datalog/commit/a9ee03b033a678504ac7202147800adbf4daf5ee", "message": "Support tuples with up to 30 values.\n\nDebugging hooks use some really long tuples.", "committedDate": "2020-06-17T20:04:34Z", "type": "commit"}, {"oid": "bfe24bb9c3aeed4f38764b7763c8636f7f446812", "url": "https://github.com/vmware/differential-datalog/commit/bfe24bb9c3aeed4f38764b7763c8636f7f446812", "message": "Add 'static lifetime to `trait Val`.\n\nRequired by `debug_split_group()`.", "committedDate": "2020-06-17T20:04:34Z", "type": "commit"}, {"oid": "267a176f4a53e5b9087bc3fcfc4045c32bc2f553", "url": "https://github.com/vmware/differential-datalog/commit/267a176f4a53e5b9087bc3fcfc4045c32bc2f553", "message": "Compile.hs: Dereference before cloning.\n\nCalling `.clone()` on a reference can be interpreted by Rust as cloning\nthe reference or the referenced value.  Make sure that we always to the\nlatter by explicitly dereferencing before cloning a value.", "committedDate": "2020-06-17T20:04:34Z", "type": "commit"}, {"oid": "8a5a39304732bc595aadbdb2673bec0bd198320c", "url": "https://github.com/vmware/differential-datalog/commit/8a5a39304732bc595aadbdb2673bec0bd198320c", "message": "Compile.hs: Clone variables in openAtom.\n\nWhen opening an atom, we bound its fields by reference.  A pattern of\nthe form `Rel[x @ y]` confused Rust's ownership checker.  As a\nworkaround we clone the fields of the atom.  This solves the problem,\nbut may introduce some overhead.", "committedDate": "2020-06-17T20:04:34Z", "type": "commit"}, {"oid": "32fdac5d96e4be9cadd3c6b10f3e8e9f65437248", "url": "https://github.com/vmware/differential-datalog/commit/32fdac5d96e4be9cadd3c6b10f3e8e9f65437248", "message": "Generate debug aggregate funcs per Aggregate operator.\n\nGenerating a debug aggregate per original aggregation function is not\nsufficient when the function is implemented in Rust and uses trait\nbounds that are not visible to DDlog.  This causes Rust compilation\nerrors since generic arguments to the generated function do not have the\nright traits.  The solution is to generate a debug aggregate for each\ncall site specialized to concrete types at this call site.", "committedDate": "2020-06-17T20:04:34Z", "type": "commit"}, {"oid": "1acf9d1ea4aff592adea96d6e6ed72935d5d37e6", "url": "https://github.com/vmware/differential-datalog/commit/1acf9d1ea4aff592adea96d6e6ed72935d5d37e6", "message": "Formatting.", "committedDate": "2020-06-17T20:04:34Z", "type": "commit"}, {"oid": "df66a0cac7aaacb7c4c3685214efb3b4de29d1e0", "url": "https://github.com/vmware/differential-datalog/commit/df66a0cac7aaacb7c4c3685214efb3b4de29d1e0", "message": "New clippy warnings.", "committedDate": "2020-06-17T20:04:34Z", "type": "commit"}, {"oid": "ca1885090462a3d19c28c3262fcafc0bf4ca167c", "url": "https://github.com/vmware/differential-datalog/commit/ca1885090462a3d19c28c3262fcafc0bf4ca167c", "message": "debug.rs: Rust warnings.", "committedDate": "2020-06-17T20:04:34Z", "type": "commit"}]}