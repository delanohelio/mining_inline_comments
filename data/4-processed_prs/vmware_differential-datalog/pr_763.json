{"pr_number": 763, "pr_title": "New Rust module structure.", "pr_createdAt": "2020-09-12T14:13:20Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/763", "timeline": [{"oid": "0b8ad6e79084ce1fda2aa662c1d6191b68fd95fe", "url": "https://github.com/vmware/differential-datalog/commit/0b8ad6e79084ce1fda2aa662c1d6191b68fd95fe", "message": "Module.hs: Drop support for #[macro_use].\n\nThis is in preparation for the new code generation model where each\nDDlog module maps into a separate Rust module.\n\nWe used to support extern libraries that import macros from other Rust\ncrates using `#[macro_use]`.  This introduced some extra complexity, as\nmacro_use imports had to be copied to the main module of a crate. The\ncomplexity was going to get worse as we move to the new compilation\nmodel.\n\n`#[macro_use] is now outdated in Rust, and so we simplify the compiler\nslightly by dropping support for it.", "committedDate": "2020-09-12T06:31:20Z", "type": "commit"}, {"oid": "e5d9c68b9e0735204b5e6b616618d63e86d58ac9", "url": "https://github.com/vmware/differential-datalog/commit/e5d9c68b9e0735204b5e6b616618d63e86d58ac9", "message": "New Rust module structure.\n\nThis commit changes the structure of the generated Rust project in order\nto improve ergonomics and speed up compilation.\n\nWe used to place all function and type declarations in a single module\nin `types/lib.rs`.  This was suboptimal for several reasons.  First,\nwe had to rely on name mangling for namespace isolation, e.g., `None`\nwould get compiled to `std_Some::std_None` (and even that was not\nguaranteed to avoid conflicts altogether).  This made writing extern\nfunctions and types, as well as using the Rust API cumbersome.  Second,\nsince all declarations were placed in the same module, it was very easy\nto run into name clashes with manually written Rust code.  Third,\nsince the entire module is re-generated and re-compiled every time, no\nincremental compilation was possible.\n\nWe change this structure by generating a Rust module hierarchy that\nprecisely matches the DDlog hierarchy, with one Rust module for each\nDDlog module containing all type and functiond declarations, as well as\nall extern Rust code for the module.\n\nThis addresses the first two problems above and makes a step towards\nsolving the third problem.  Compilation is not yet incremental; however\nit is not in principle possible to make the DDlog compiler incremental\nby only re-compiling affected modules.  In order to also compile Rust\ncode incrementally, we would have to further break up the generated code\ninto multiple crates, which will be much easier with the current\nstructure.\n\nOne side effect of this refactoring is that I had to rename the `std`\nlibrary to `ddlog_std` to avoid name clashes with the Rust `std` library\nthat gets automatically imported by all programs.  I tried different\ntechniques to avoid the clashes, but there does not seem to exist a\nrobust way.\n\n----------\n\nThis commit makes another change that helps speed up compilation.  This\nshould have been done in a separate commit, but the two ended up being\ntoo tangled to separate them.\n\nWe used to implement `Serialize` and `Deserialize` traits for the\n`DDValue` type using `serde_typetag` crate that uses some black magic to\nauto-generate serialization/deserialization code for trait objects.\nTurns out this magic is extremely expensive in terms of compilation time\nand generated code size.  It literally slows down compilation by a\nfactor or two for some of our programs.  I don't have an explanation and\nfiled an issue against typetag: https://github.com/dtolnay/typetag/issues/25.\n\nAs a workaround, we now generate serialization/deserialization code\nin the DDlog compiler, and it's much more lightweight.  Note that\n`DDValue` serialization/deserialization is only used by the\ndistributed-ddlog crate.  More specifically, it needs to\nserialize/deserialize `Update<DDValue>` objects.  Since these objects\ncontain relation id for each value, we can implement a custom\ndeserializer that first reads relations id and picks the value type to\ndeserialize based on that.  See details in\n`src/lib.rs/UpdateSerializer`.", "committedDate": "2020-09-12T14:19:22Z", "type": "forcePushed"}, {"oid": "69847dac257f12b4662e1d657ec06287f3eb993d", "url": "https://github.com/vmware/differential-datalog/commit/69847dac257f12b4662e1d657ec06287f3eb993d", "message": "New Rust module structure.\n\nThis commit changes the structure of the generated Rust project in order\nto improve ergonomics and speed up compilation.\n\nWe used to place all function and type declarations in a single module\nin `types/lib.rs`.  This was suboptimal for several reasons.  First,\nwe had to rely on name mangling for namespace isolation, e.g., `None`\nwould get compiled to `std_Some::std_None` (and even that was not\nguaranteed to avoid conflicts altogether).  This made writing extern\nfunctions and types, as well as using the Rust API cumbersome.  Second,\nsince all declarations were placed in the same module, it was very easy\nto run into name clashes with manually written Rust code.  Third,\nsince the entire module is re-generated and re-compiled every time, no\nincremental compilation was possible.\n\nWe change this structure by generating a Rust module hierarchy that\nprecisely matches the DDlog hierarchy, with one Rust module for each\nDDlog module containing all type and functiond declarations, as well as\nall extern Rust code for the module.\n\nThis addresses the first two problems above and makes a step towards\nsolving the third problem.  Compilation is not yet incremental; however\nit is not in principle possible to make the DDlog compiler incremental\nby only re-compiling affected modules.  In order to also compile Rust\ncode incrementally, we would have to further break up the generated code\ninto multiple crates, which will be much easier with the current\nstructure.\n\nOne side effect of this refactoring is that I had to rename the `std`\nlibrary to `ddlog_std` to avoid name clashes with the Rust `std` library\nthat gets automatically imported by all programs.  I tried different\ntechniques to avoid the clashes, but there does not seem to exist a\nrobust way.\n\n----------\n\nThis commit makes another change that helps speed up compilation.  This\nshould have been done in a separate commit, but the two ended up being\ntoo tangled to separate them.\n\nWe used to implement `Serialize` and `Deserialize` traits for the\n`DDValue` type using `serde_typetag` crate that uses some black magic to\nauto-generate serialization/deserialization code for trait objects.\nTurns out this magic is extremely expensive in terms of compilation time\nand generated code size.  It literally slows down compilation by a\nfactor or two for some of our programs.  I don't have an explanation and\nfiled an issue against typetag: https://github.com/dtolnay/typetag/issues/25.\n\nAs a workaround, we now generate serialization/deserialization code\nin the DDlog compiler, and it's much more lightweight.  Note that\n`DDValue` serialization/deserialization is only used by the\ndistributed-ddlog crate.  More specifically, it needs to\nserialize/deserialize `Update<DDValue>` objects.  Since these objects\ncontain relation id for each value, we can implement a custom\ndeserializer that first reads relations id and picks the value type to\ndeserialize based on that.  See details in\n`src/lib.rs/UpdateSerializer`.", "committedDate": "2020-09-13T17:44:59Z", "type": "commit"}, {"oid": "69847dac257f12b4662e1d657ec06287f3eb993d", "url": "https://github.com/vmware/differential-datalog/commit/69847dac257f12b4662e1d657ec06287f3eb993d", "message": "New Rust module structure.\n\nThis commit changes the structure of the generated Rust project in order\nto improve ergonomics and speed up compilation.\n\nWe used to place all function and type declarations in a single module\nin `types/lib.rs`.  This was suboptimal for several reasons.  First,\nwe had to rely on name mangling for namespace isolation, e.g., `None`\nwould get compiled to `std_Some::std_None` (and even that was not\nguaranteed to avoid conflicts altogether).  This made writing extern\nfunctions and types, as well as using the Rust API cumbersome.  Second,\nsince all declarations were placed in the same module, it was very easy\nto run into name clashes with manually written Rust code.  Third,\nsince the entire module is re-generated and re-compiled every time, no\nincremental compilation was possible.\n\nWe change this structure by generating a Rust module hierarchy that\nprecisely matches the DDlog hierarchy, with one Rust module for each\nDDlog module containing all type and functiond declarations, as well as\nall extern Rust code for the module.\n\nThis addresses the first two problems above and makes a step towards\nsolving the third problem.  Compilation is not yet incremental; however\nit is not in principle possible to make the DDlog compiler incremental\nby only re-compiling affected modules.  In order to also compile Rust\ncode incrementally, we would have to further break up the generated code\ninto multiple crates, which will be much easier with the current\nstructure.\n\nOne side effect of this refactoring is that I had to rename the `std`\nlibrary to `ddlog_std` to avoid name clashes with the Rust `std` library\nthat gets automatically imported by all programs.  I tried different\ntechniques to avoid the clashes, but there does not seem to exist a\nrobust way.\n\n----------\n\nThis commit makes another change that helps speed up compilation.  This\nshould have been done in a separate commit, but the two ended up being\ntoo tangled to separate them.\n\nWe used to implement `Serialize` and `Deserialize` traits for the\n`DDValue` type using `serde_typetag` crate that uses some black magic to\nauto-generate serialization/deserialization code for trait objects.\nTurns out this magic is extremely expensive in terms of compilation time\nand generated code size.  It literally slows down compilation by a\nfactor or two for some of our programs.  I don't have an explanation and\nfiled an issue against typetag: https://github.com/dtolnay/typetag/issues/25.\n\nAs a workaround, we now generate serialization/deserialization code\nin the DDlog compiler, and it's much more lightweight.  Note that\n`DDValue` serialization/deserialization is only used by the\ndistributed-ddlog crate.  More specifically, it needs to\nserialize/deserialize `Update<DDValue>` objects.  Since these objects\ncontain relation id for each value, we can implement a custom\ndeserializer that first reads relations id and picks the value type to\ndeserialize based on that.  See details in\n`src/lib.rs/UpdateSerializer`.", "committedDate": "2020-09-13T17:44:59Z", "type": "forcePushed"}, {"oid": "69847dac257f12b4662e1d657ec06287f3eb993d", "url": "https://github.com/vmware/differential-datalog/commit/69847dac257f12b4662e1d657ec06287f3eb993d", "message": "New Rust module structure.\n\nThis commit changes the structure of the generated Rust project in order\nto improve ergonomics and speed up compilation.\n\nWe used to place all function and type declarations in a single module\nin `types/lib.rs`.  This was suboptimal for several reasons.  First,\nwe had to rely on name mangling for namespace isolation, e.g., `None`\nwould get compiled to `std_Some::std_None` (and even that was not\nguaranteed to avoid conflicts altogether).  This made writing extern\nfunctions and types, as well as using the Rust API cumbersome.  Second,\nsince all declarations were placed in the same module, it was very easy\nto run into name clashes with manually written Rust code.  Third,\nsince the entire module is re-generated and re-compiled every time, no\nincremental compilation was possible.\n\nWe change this structure by generating a Rust module hierarchy that\nprecisely matches the DDlog hierarchy, with one Rust module for each\nDDlog module containing all type and functiond declarations, as well as\nall extern Rust code for the module.\n\nThis addresses the first two problems above and makes a step towards\nsolving the third problem.  Compilation is not yet incremental; however\nit is not in principle possible to make the DDlog compiler incremental\nby only re-compiling affected modules.  In order to also compile Rust\ncode incrementally, we would have to further break up the generated code\ninto multiple crates, which will be much easier with the current\nstructure.\n\nOne side effect of this refactoring is that I had to rename the `std`\nlibrary to `ddlog_std` to avoid name clashes with the Rust `std` library\nthat gets automatically imported by all programs.  I tried different\ntechniques to avoid the clashes, but there does not seem to exist a\nrobust way.\n\n----------\n\nThis commit makes another change that helps speed up compilation.  This\nshould have been done in a separate commit, but the two ended up being\ntoo tangled to separate them.\n\nWe used to implement `Serialize` and `Deserialize` traits for the\n`DDValue` type using `serde_typetag` crate that uses some black magic to\nauto-generate serialization/deserialization code for trait objects.\nTurns out this magic is extremely expensive in terms of compilation time\nand generated code size.  It literally slows down compilation by a\nfactor or two for some of our programs.  I don't have an explanation and\nfiled an issue against typetag: https://github.com/dtolnay/typetag/issues/25.\n\nAs a workaround, we now generate serialization/deserialization code\nin the DDlog compiler, and it's much more lightweight.  Note that\n`DDValue` serialization/deserialization is only used by the\ndistributed-ddlog crate.  More specifically, it needs to\nserialize/deserialize `Update<DDValue>` objects.  Since these objects\ncontain relation id for each value, we can implement a custom\ndeserializer that first reads relations id and picks the value type to\ndeserialize based on that.  See details in\n`src/lib.rs/UpdateSerializer`.", "committedDate": "2020-09-13T17:44:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA5MzYzMA==", "url": "https://github.com/vmware/differential-datalog/pull/763#discussion_r488093630", "bodyText": "I will file an issue to better document the constraints on recursive data types. This PR is big enough.", "author": "mbudiu-vmw", "createdAt": "2020-09-14T17:12:12Z", "path": "doc/language_reference/language_reference.md", "diffHunk": "@@ -174,7 +174,6 @@ arguments matching its declaration:\n         var x: type1<bigint> // error: not enough type arguments\n     }\n     ```\n-1. Recursive type definitions are not allowed.", "originalCommit": "69847dac257f12b4662e1d657ec06287f3eb993d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA5NjQyOA==", "url": "https://github.com/vmware/differential-datalog/pull/763#discussion_r488096428", "bodyText": "I think you could probably cut these vertical lines with no loss in precision, but with gains in readability.", "author": "mbudiu-vmw", "createdAt": "2020-09-14T17:16:41Z", "path": "doc/tutorial/tutorial.md", "diffHunk": "@@ -2318,12 +2326,120 @@ ddlog -i test.dl -L../modules\n \n Multiple `-L` options are allowed to access modules scattered across multiple directories.\n \n+\n+## Implementing extern functions and types in Rust\n+\n+We have encountered many examples of extern functions and types throughout the\n+tutorial.  Here we summarize the rules for integrating Rust code into your DDlog\n+program.\n+\n+Since the DDlog compiler generates Rust, external Rust code integrates with\n+DDlog seamlessly and efficiently.  At a high level, the compiler generates \n+several crates for a DDlog program `prog`: \n+\n+```\n+prog_ddlog\n+    |                           +-+\n+    +----+types                   |\n+    |       +                     |\n+    |       |                     |", "originalCommit": "69847dac257f12b4662e1d657ec06287f3eb993d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA5NzE1NQ==", "url": "https://github.com/vmware/differential-datalog/pull/763#discussion_r488097155", "bodyText": "Use the command tree to generate this picture; it generates a nice rendering.", "author": "mbudiu-vmw", "createdAt": "2020-09-14T17:17:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA5NjQyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA5ODQyNg==", "url": "https://github.com/vmware/differential-datalog/pull/763#discussion_r488098426", "bodyText": "using modules mod1, etc?", "author": "mbudiu-vmw", "createdAt": "2020-09-14T17:19:45Z", "path": "doc/tutorial/tutorial.md", "diffHunk": "@@ -2318,12 +2326,120 @@ ddlog -i test.dl -L../modules\n \n Multiple `-L` options are allowed to access modules scattered across multiple directories.\n \n+\n+## Implementing extern functions and types in Rust\n+\n+We have encountered many examples of extern functions and types throughout the\n+tutorial.  Here we summarize the rules for integrating Rust code into your DDlog\n+program.\n+\n+Since the DDlog compiler generates Rust, external Rust code integrates with\n+DDlog seamlessly and efficiently.  At a high level, the compiler generates \n+several crates for a DDlog program `prog`: ", "originalCommit": "69847dac257f12b4662e1d657ec06287f3eb993d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA5ODU1NA==", "url": "https://github.com/vmware/differential-datalog/pull/763#discussion_r488098554", "bodyText": "typo", "author": "mbudiu-vmw", "createdAt": "2020-09-14T17:19:57Z", "path": "doc/tutorial/tutorial.md", "diffHunk": "@@ -2318,12 +2326,120 @@ ddlog -i test.dl -L../modules\n \n Multiple `-L` options are allowed to access modules scattered across multiple directories.\n \n+\n+## Implementing extern functions and types in Rust\n+\n+We have encountered many examples of extern functions and types throughout the\n+tutorial.  Here we summarize the rules for integrating Rust code into your DDlog\n+program.\n+\n+Since the DDlog compiler generates Rust, external Rust code integrates with\n+DDlog seamlessly and efficiently.  At a high level, the compiler generates \n+several crates for a DDlog program `prog`: \n+\n+```\n+prog_ddlog\n+    |                           +-+\n+    +----+types                   |\n+    |       +                     |\n+    |       |                     |\n+    |       +--+Cargo.toml        |\n+    |       |                     |  types crate:\n+    |       +--+std_ddlog.rs      |  types, functions, external Rust code\n+    |       |                     |\n+    |       +--+mod1.dl           |\n+    |       |                     |\n+    |       +--+mod2              |\n+    |       |    +                |\n+    |       |    +--+lib.rs       |\n+    |       |    |                |\n+    |       |    +--+submod1.rs   |\n+    |       |    |                |\n+    |       |    +--+submod2.rs   |\n+    |       |                     |\n+    |       +--+lib.rs            |\n+    |                           +-+\n+    +----+value                 +-+\n+    |        +--+Cargo.toml       |  value crate:\n+    |        |                    |  wrapper types\n+    |        +--+lib.rs           |\n+    |                           +-+\n+    |                           +-+\n+    +----+Cargo.toml              |\n+    |                             |\n+    +----+src                     |  main crate:\n+           +                      |  Rust encoding of DDlog rules and relations.\n+           +--+lib.rs             |\n+           |                      |\n+           +--+main.rs            |\n+           |                      |\n+           +--+api.rs             |\n+                                +-+\n+```\n+\n+The `types` crate is the one relevant for the purposes of this section.  It\n+contains all function and type declaraions, including extern functions and", "originalCommit": "69847dac257f12b4662e1d657ec06287f3eb993d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA5OTY0MA==", "url": "https://github.com/vmware/differential-datalog/pull/763#discussion_r488099640", "bodyText": "submod1.rs", "author": "mbudiu-vmw", "createdAt": "2020-09-14T17:21:36Z", "path": "doc/tutorial/tutorial.md", "diffHunk": "@@ -2318,12 +2326,120 @@ ddlog -i test.dl -L../modules\n \n Multiple `-L` options are allowed to access modules scattered across multiple directories.\n \n+\n+## Implementing extern functions and types in Rust\n+\n+We have encountered many examples of extern functions and types throughout the\n+tutorial.  Here we summarize the rules for integrating Rust code into your DDlog\n+program.\n+\n+Since the DDlog compiler generates Rust, external Rust code integrates with\n+DDlog seamlessly and efficiently.  At a high level, the compiler generates \n+several crates for a DDlog program `prog`: \n+\n+```\n+prog_ddlog\n+    |                           +-+\n+    +----+types                   |\n+    |       +                     |\n+    |       |                     |\n+    |       +--+Cargo.toml        |\n+    |       |                     |  types crate:\n+    |       +--+std_ddlog.rs      |  types, functions, external Rust code\n+    |       |                     |\n+    |       +--+mod1.dl           |\n+    |       |                     |\n+    |       +--+mod2              |\n+    |       |    +                |\n+    |       |    +--+lib.rs       |\n+    |       |    |                |\n+    |       |    +--+submod1.rs   |\n+    |       |    |                |\n+    |       |    +--+submod2.rs   |\n+    |       |                     |\n+    |       +--+lib.rs            |\n+    |                           +-+\n+    +----+value                 +-+\n+    |        +--+Cargo.toml       |  value crate:\n+    |        |                    |  wrapper types\n+    |        +--+lib.rs           |\n+    |                           +-+\n+    |                           +-+\n+    +----+Cargo.toml              |\n+    |                             |\n+    +----+src                     |  main crate:\n+           +                      |  Rust encoding of DDlog rules and relations.\n+           +--+lib.rs             |\n+           |                      |\n+           +--+main.rs            |\n+           |                      |\n+           +--+api.rs             |\n+                                +-+\n+```\n+\n+The `types` crate is the one relevant for the purposes of this section.  It\n+contains all function and type declaraions, including extern functions and\n+types.  Its internal module structure mirrors the structure of the DDlog\n+program, with a separate Rust module for each DDlog module.  For example,\n+declarations from a DDlog module `mod2/submod1.dl` are placed in\n+`prog_ddlog/types/mod1/submod1.rs`.  Types and functions declared in the main\n+module of the program are placed in `types/lib.rs`.  If `submod1.dl` contains\n+extern function or type declarations, corresponding Rust declarations must be\n+placed in `mod2/submodule1.rs`.  This file is picked up by the DDlog compiler", "originalCommit": "69847dac257f12b4662e1d657ec06287f3eb993d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwMTM1Ng==", "url": "https://github.com/vmware/differential-datalog/pull/763#discussion_r488101356", "bodyText": "But where is this directory?\nPerhaps you can show a tree of both sources and generated code.", "author": "mbudiu-vmw", "createdAt": "2020-09-14T17:24:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA5OTY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwMTk4NA==", "url": "https://github.com/vmware/differential-datalog/pull/763#discussion_r488101984", "bodyText": "semicolon or period after \"namespace\".", "author": "mbudiu-vmw", "createdAt": "2020-09-14T17:25:30Z", "path": "doc/tutorial/tutorial.md", "diffHunk": "@@ -2318,12 +2326,120 @@ ddlog -i test.dl -L../modules\n \n Multiple `-L` options are allowed to access modules scattered across multiple directories.\n \n+\n+## Implementing extern functions and types in Rust\n+\n+We have encountered many examples of extern functions and types throughout the\n+tutorial.  Here we summarize the rules for integrating Rust code into your DDlog\n+program.\n+\n+Since the DDlog compiler generates Rust, external Rust code integrates with\n+DDlog seamlessly and efficiently.  At a high level, the compiler generates \n+several crates for a DDlog program `prog`: \n+\n+```\n+prog_ddlog\n+    |                           +-+\n+    +----+types                   |\n+    |       +                     |\n+    |       |                     |\n+    |       +--+Cargo.toml        |\n+    |       |                     |  types crate:\n+    |       +--+std_ddlog.rs      |  types, functions, external Rust code\n+    |       |                     |\n+    |       +--+mod1.dl           |\n+    |       |                     |\n+    |       +--+mod2              |\n+    |       |    +                |\n+    |       |    +--+lib.rs       |\n+    |       |    |                |\n+    |       |    +--+submod1.rs   |\n+    |       |    |                |\n+    |       |    +--+submod2.rs   |\n+    |       |                     |\n+    |       +--+lib.rs            |\n+    |                           +-+\n+    +----+value                 +-+\n+    |        +--+Cargo.toml       |  value crate:\n+    |        |                    |  wrapper types\n+    |        +--+lib.rs           |\n+    |                           +-+\n+    |                           +-+\n+    +----+Cargo.toml              |\n+    |                             |\n+    +----+src                     |  main crate:\n+           +                      |  Rust encoding of DDlog rules and relations.\n+           +--+lib.rs             |\n+           |                      |\n+           +--+main.rs            |\n+           |                      |\n+           +--+api.rs             |\n+                                +-+\n+```\n+\n+The `types` crate is the one relevant for the purposes of this section.  It\n+contains all function and type declaraions, including extern functions and\n+types.  Its internal module structure mirrors the structure of the DDlog\n+program, with a separate Rust module for each DDlog module.  For example,\n+declarations from a DDlog module `mod2/submod1.dl` are placed in\n+`prog_ddlog/types/mod1/submod1.rs`.  Types and functions declared in the main\n+module of the program are placed in `types/lib.rs`.  If `submod1.dl` contains\n+extern function or type declarations, corresponding Rust declarations must be\n+placed in `mod2/submodule1.rs`.  This file is picked up by the DDlog compiler\n+and its contents is appended verbatim to the generated\n+`prog_ddlog/types/mod1/submod1.rs` module.\n+\n+Extern type and function declarations must follow these rules:\n+\n+- Extern type and function names must match their DDlog declarations.\n+\n+- Extern types must implement a number of traits expected by DDlog.\n+  See the [section on extern types](#extern-types) for details.\n+\n+- Extern function signatures must match DDlog declarations.  Arguments are\n+  passed by reference, functions return results by value, unless labeled\n+  with [`return_by_ref` attribute](#return_by_ref).  DDlog generates\n+  commented out function prototypes in Rust to help the user come up with\n+  correct signatures.\n+  See the [section on extern functions](#extern-functions) for details.\n+\n+- Rust code can access function and type declarations in other program\n+  modules and libraries through the `crate::` namespace, e.g., to import", "originalCommit": "69847dac257f12b4662e1d657ec06287f3eb993d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwMjY5OA==", "url": "https://github.com/vmware/differential-datalog/pull/763#discussion_r488102698", "bodyText": "I wonder whether it wouldn't be simpler to actually give a complete toy example rather than describe this in words.\nThe toy example should have a corresponding source in the project source tree which people can just run.", "author": "mbudiu-vmw", "createdAt": "2020-09-14T17:26:45Z", "path": "doc/tutorial/tutorial.md", "diffHunk": "@@ -2318,12 +2326,120 @@ ddlog -i test.dl -L../modules\n \n Multiple `-L` options are allowed to access modules scattered across multiple directories.\n \n+\n+## Implementing extern functions and types in Rust\n+\n+We have encountered many examples of extern functions and types throughout the\n+tutorial.  Here we summarize the rules for integrating Rust code into your DDlog\n+program.\n+\n+Since the DDlog compiler generates Rust, external Rust code integrates with\n+DDlog seamlessly and efficiently.  At a high level, the compiler generates \n+several crates for a DDlog program `prog`: \n+\n+```\n+prog_ddlog\n+    |                           +-+\n+    +----+types                   |\n+    |       +                     |\n+    |       |                     |\n+    |       +--+Cargo.toml        |\n+    |       |                     |  types crate:\n+    |       +--+std_ddlog.rs      |  types, functions, external Rust code\n+    |       |                     |\n+    |       +--+mod1.dl           |\n+    |       |                     |\n+    |       +--+mod2              |\n+    |       |    +                |\n+    |       |    +--+lib.rs       |\n+    |       |    |                |\n+    |       |    +--+submod1.rs   |\n+    |       |    |                |\n+    |       |    +--+submod2.rs   |\n+    |       |                     |\n+    |       +--+lib.rs            |\n+    |                           +-+\n+    +----+value                 +-+\n+    |        +--+Cargo.toml       |  value crate:\n+    |        |                    |  wrapper types\n+    |        +--+lib.rs           |\n+    |                           +-+\n+    |                           +-+\n+    +----+Cargo.toml              |\n+    |                             |\n+    +----+src                     |  main crate:\n+           +                      |  Rust encoding of DDlog rules and relations.\n+           +--+lib.rs             |\n+           |                      |\n+           +--+main.rs            |\n+           |                      |\n+           +--+api.rs             |\n+                                +-+\n+```\n+\n+The `types` crate is the one relevant for the purposes of this section.  It\n+contains all function and type declaraions, including extern functions and\n+types.  Its internal module structure mirrors the structure of the DDlog\n+program, with a separate Rust module for each DDlog module.  For example,\n+declarations from a DDlog module `mod2/submod1.dl` are placed in\n+`prog_ddlog/types/mod1/submod1.rs`.  Types and functions declared in the main\n+module of the program are placed in `types/lib.rs`.  If `submod1.dl` contains\n+extern function or type declarations, corresponding Rust declarations must be\n+placed in `mod2/submodule1.rs`.  This file is picked up by the DDlog compiler\n+and its contents is appended verbatim to the generated\n+`prog_ddlog/types/mod1/submod1.rs` module.\n+\n+Extern type and function declarations must follow these rules:\n+\n+- Extern type and function names must match their DDlog declarations.\n+\n+- Extern types must implement a number of traits expected by DDlog.\n+  See the [section on extern types](#extern-types) for details.\n+\n+- Extern function signatures must match DDlog declarations.  Arguments are\n+  passed by reference, functions return results by value, unless labeled\n+  with [`return_by_ref` attribute](#return_by_ref).  DDlog generates\n+  commented out function prototypes in Rust to help the user come up with\n+  correct signatures.\n+  See the [section on extern functions](#extern-functions) for details.\n+\n+- Rust code can access function and type declarations in other program\n+  modules and libraries through the `crate::` namespace, e.g., to import\n+  the standard DDlog library:\n+\n+  ```\n+  use crate::ddlog_std;\n+  ```\n+\n+- Extern functions and types often contain dependencies on third-party crates.", "originalCommit": "69847dac257f12b4662e1d657ec06287f3eb993d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEwMzA0MQ==", "url": "https://github.com/vmware/differential-datalog/pull/763#discussion_r488103041", "bodyText": "missing backquote", "author": "mbudiu-vmw", "createdAt": "2020-09-14T17:27:20Z", "path": "doc/tutorial/tutorial.md", "diffHunk": "@@ -2318,12 +2326,120 @@ ddlog -i test.dl -L../modules\n \n Multiple `-L` options are allowed to access modules scattered across multiple directories.\n \n+\n+## Implementing extern functions and types in Rust\n+\n+We have encountered many examples of extern functions and types throughout the\n+tutorial.  Here we summarize the rules for integrating Rust code into your DDlog\n+program.\n+\n+Since the DDlog compiler generates Rust, external Rust code integrates with\n+DDlog seamlessly and efficiently.  At a high level, the compiler generates \n+several crates for a DDlog program `prog`: \n+\n+```\n+prog_ddlog\n+    |                           +-+\n+    +----+types                   |\n+    |       +                     |\n+    |       |                     |\n+    |       +--+Cargo.toml        |\n+    |       |                     |  types crate:\n+    |       +--+std_ddlog.rs      |  types, functions, external Rust code\n+    |       |                     |\n+    |       +--+mod1.dl           |\n+    |       |                     |\n+    |       +--+mod2              |\n+    |       |    +                |\n+    |       |    +--+lib.rs       |\n+    |       |    |                |\n+    |       |    +--+submod1.rs   |\n+    |       |    |                |\n+    |       |    +--+submod2.rs   |\n+    |       |                     |\n+    |       +--+lib.rs            |\n+    |                           +-+\n+    +----+value                 +-+\n+    |        +--+Cargo.toml       |  value crate:\n+    |        |                    |  wrapper types\n+    |        +--+lib.rs           |\n+    |                           +-+\n+    |                           +-+\n+    +----+Cargo.toml              |\n+    |                             |\n+    +----+src                     |  main crate:\n+           +                      |  Rust encoding of DDlog rules and relations.\n+           +--+lib.rs             |\n+           |                      |\n+           +--+main.rs            |\n+           |                      |\n+           +--+api.rs             |\n+                                +-+\n+```\n+\n+The `types` crate is the one relevant for the purposes of this section.  It\n+contains all function and type declaraions, including extern functions and\n+types.  Its internal module structure mirrors the structure of the DDlog\n+program, with a separate Rust module for each DDlog module.  For example,\n+declarations from a DDlog module `mod2/submod1.dl` are placed in\n+`prog_ddlog/types/mod1/submod1.rs`.  Types and functions declared in the main\n+module of the program are placed in `types/lib.rs`.  If `submod1.dl` contains\n+extern function or type declarations, corresponding Rust declarations must be\n+placed in `mod2/submodule1.rs`.  This file is picked up by the DDlog compiler\n+and its contents is appended verbatim to the generated\n+`prog_ddlog/types/mod1/submod1.rs` module.\n+\n+Extern type and function declarations must follow these rules:\n+\n+- Extern type and function names must match their DDlog declarations.\n+\n+- Extern types must implement a number of traits expected by DDlog.\n+  See the [section on extern types](#extern-types) for details.\n+\n+- Extern function signatures must match DDlog declarations.  Arguments are\n+  passed by reference, functions return results by value, unless labeled\n+  with [`return_by_ref` attribute](#return_by_ref).  DDlog generates\n+  commented out function prototypes in Rust to help the user come up with\n+  correct signatures.\n+  See the [section on extern functions](#extern-functions) for details.\n+\n+- Rust code can access function and type declarations in other program\n+  modules and libraries through the `crate::` namespace, e.g., to import\n+  the standard DDlog library:\n+\n+  ```\n+  use crate::ddlog_std;\n+  ```\n+\n+- Extern functions and types often contain dependencies on third-party crates.\n+  Such dependencies must be added to the generated `types/Cargo.toml` file.\n+  To this end, create a file with the same name and location as the DDlog module\n+  and `.toml` extension, containing dependency clauses in `Cargo.toml` format.\n+  As an example, the `lib/regex.dl` library that implements DDlog bindings to the\n+  regular expressions crate `regex` has an accompanying `lib/regex.toml` file\n+  with the following contents:\n+\n+  ```\n+  [dependencies.regex]\n+  version = \"1.1\"\n+  ```\n+\n+  There is an important caveat: only one module in your program can import any\n+  given external crate. As a workaround, we recommend creating a separate DDlog\n+  library for each extern crate and only list this crate as a dependency for this\n+  library, e.g., `lib/regex.dl for the `regex` crate, `lib/url.dl` for the url", "originalCommit": "69847dac257f12b4662e1d657ec06287f3eb993d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEyMjc3OQ==", "url": "https://github.com/vmware/differential-datalog/pull/763#discussion_r488122779", "bodyText": "is this documented? should users care?", "author": "mbudiu-vmw", "createdAt": "2020-09-14T18:02:42Z", "path": "lib/ddlog_std.dl", "diffHunk": "@@ -6,10 +6,15 @@\n import debug\n import log\n \n+#[alias]", "originalCommit": "69847dac257f12b4662e1d657ec06287f3eb993d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzMTk4Ng==", "url": "https://github.com/vmware/differential-datalog/pull/763#discussion_r488131986", "bodyText": "how come these are needed now but not before?", "author": "mbudiu-vmw", "createdAt": "2020-09-14T18:19:11Z", "path": "rust/template/types/flatbuf.rs", "diffHunk": "@@ -1,9 +1,11 @@\n //! Serialize DDlog types to/from FlatBuffers.\n \n use super::*;\n+use ::ordered_float::OrderedFloat;", "originalCommit": "69847dac257f12b4662e1d657ec06287f3eb993d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzMzM2MQ==", "url": "https://github.com/vmware/differential-datalog/pull/763#discussion_r488133361", "bodyText": "this may be useful for ddlog programmers too, so perhaps it should be documented.\nbut if it only applies to scalar types the value could be limited?", "author": "mbudiu-vmw", "createdAt": "2020-09-14T18:21:42Z", "path": "src/Language/DifferentialDatalog/Attribute.hs", "diffHunk": "@@ -197,6 +203,23 @@ tdefGetSharedRefAttr d tdef =\n          Left e  -> error e\n          Right b -> b\n \n+{- 'alias' attribute: Tells DDlog not to generate Rust declaration for the type", "originalCommit": "69847dac257f12b4662e1d657ec06287f3eb993d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODIzOTM1NQ==", "url": "https://github.com/vmware/differential-datalog/pull/763#discussion_r488239355", "bodyText": "I haven't thought the implications through, so it's probably better to reserve this for internal use only.  This is only needed for types that conflict with Rust builtins. There is a small and finite number of those.", "author": "ryzhyk", "createdAt": "2020-09-14T21:49:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzMzM2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzNDM1Ng==", "url": "https://github.com/vmware/differential-datalog/pull/763#discussion_r488134356", "bodyText": "flatten?", "author": "mbudiu-vmw", "createdAt": "2020-09-14T18:23:27Z", "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -343,26 +349,37 @@ emptyCompilerState = CompilerState {\n     cArrangements = M.empty\n }\n \n--- Convert name to a valid Rust identifier by replacing \"::\" with \"_\"\n-rname :: String -> Doc\n-rname = pp . replace \"::\" \"_\"\n+-- Relations, indexes, relation transformers and Value's are stored in the flat namespace.\n+-- Flatter a name by replacing \"::\" with \"_\"", "originalCommit": "69847dac257f12b4662e1d657ec06287f3eb993d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODIzODkxNg==", "url": "https://github.com/vmware/differential-datalog/pull/763#discussion_r488238916", "bodyText": "A bit of flattery cannot harm.", "author": "ryzhyk", "createdAt": "2020-09-14T21:47:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzNDM1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzNTQ5OA==", "url": "https://github.com/vmware/differential-datalog/pull/763#discussion_r488135498", "bodyText": "create a function localPrefix :: bool -> string for the expression in parenthesis?", "author": "mbudiu-vmw", "createdAt": "2020-09-14T18:25:24Z", "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -440,15 +457,20 @@ tuple :: [Doc] -> Doc\n tuple [x] = x\n tuple xs = parens $ hsep $ punctuate comma xs\n \n-tupleTypeName :: [a] -> Doc\n-tupleTypeName xs = \"tuple\" <> pp (length xs)\n+tupleTypeName :: Bool -> [a] -> Doc\n+tupleTypeName local xs =\n+    tupleTypeName' (if local then \"crate\" else \"::types\") xs", "originalCommit": "69847dac257f12b4662e1d657ec06287f3eb993d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzNjIxMg==", "url": "https://github.com/vmware/differential-datalog/pull/763#discussion_r488136212", "bodyText": "I don't understand this English, can you rephrase?", "author": "mbudiu-vmw", "createdAt": "2020-09-14T18:26:39Z", "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -457,27 +479,32 @@ isStructType TStruct{..} | length typeCons == 1 = True\n isStructType TStruct{..}                        = False\n isStructType t                                  = error $ \"Compile.isStructType \" ++ show t\n \n-mkConstructorName :: String -> Type -> String -> Doc\n-mkConstructorName tname t c =\n+-- 'local' is true iff the constructor is being used in the same crate where it was\n+-- declared, i.e., the 'types' crate.\n+mkConstructorName :: Bool -> String -> Type -> String -> Doc\n+mkConstructorName local tname t c =\n     if isStructType t\n-       then rname tname\n-       else rname tname <> \"::\" <> rname c\n+       then rnameScoped local tname\n+       else rnameScoped local tname <> \"::\" <> nameLocal c\n \n -- | Create a compilable Cargo crate.  If the crate already exists, only writes files\n -- modified by the recompilation.\n --\n -- 'specname' - will be used as Cargo package and library names\n --\n--- 'rs_code' - additional Rust code to be added to the generated program 'lib.rs'.\n+-- 'modules' - list of modules in the original DDlog program. This function", "originalCommit": "69847dac257f12b4662e1d657ec06287f3eb993d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzNjk0OA==", "url": "https://github.com/vmware/differential-datalog/pull/763#discussion_r488136948", "bodyText": "three? The first seems to be a map with one per module.", "author": "mbudiu-vmw", "createdAt": "2020-09-14T18:28:00Z", "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -540,28 +568,46 @@ compile d_unoptimized specname rs_code toml_code dir crate_types = do\n \n -- | Compile Datalog program into Rust code.\n --\n--- Returns Rust code for three crates that comp:\n+-- Returns Rust code for three crates:", "originalCommit": "69847dac257f12b4662e1d657ec06287f3eb993d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI0MDY0OQ==", "url": "https://github.com/vmware/differential-datalog/pull/763#discussion_r488240649", "bodyText": "There's one module per DDlog module, but all of them live in the same crate (for now).", "author": "ryzhyk", "createdAt": "2020-09-14T21:52:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEzNjk0OA=="}], "type": "inlineReview"}, {"oid": "1ea38f81778cc6a51fd94a3464e3786a610117d0", "url": "https://github.com/vmware/differential-datalog/commit/1ea38f81778cc6a51fd94a3464e3786a610117d0", "message": "Address review comments.", "committedDate": "2020-09-14T21:52:09Z", "type": "commit"}]}