{"pr_number": 875, "pr_title": "Added the FromRecord and IntoRecord derive macros", "pr_createdAt": "2020-12-18T00:07:19Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/875", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzODI0Mg==", "url": "https://github.com/vmware/differential-datalog/pull/875#discussion_r547538242", "bodyText": "Why does this have to be a separate crate?", "author": "ryzhyk", "createdAt": "2020-12-22T22:30:29Z", "path": "Cargo.toml", "diffHunk": "@@ -1,9 +1,11 @@\n [workspace]\n members = [\n     \"rust/template\",\n+    \"rust/template/ovsdb\",\n     \"rust/template/cmd_parser\",\n-    \"rust/template/differential_datalog\",\n+    \"rust/template/ddlog_derive\",", "originalCommit": "ca6f41baf1cbe9bef71ac895a2b46d4157b46a0e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODM2NDI3MQ==", "url": "https://github.com/vmware/differential-datalog/pull/875#discussion_r548364271", "bodyText": "Procedural macros have to be separate crates (that can only export proc/derive macros) since they're compiled and ran at compile time", "author": "Kixiron", "createdAt": "2020-12-24T03:18:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzODI0Mg=="}], "type": "inlineReview"}, {"oid": "875539091e01274155d8a18ed6acfee4a5dfe863", "url": "https://github.com/vmware/differential-datalog/commit/875539091e01274155d8a18ed6acfee4a5dfe863", "message": "Added IntoRecord derive macro and derive compile testing", "committedDate": "2020-12-24T03:15:00Z", "type": "forcePushed"}, {"oid": "2fce9091c656edb374752aa9f8593997175ae925", "url": "https://github.com/vmware/differential-datalog/commit/2fce9091c656edb374752aa9f8593997175ae925", "message": "Added IntoRecord derive macro and derive compile testing", "committedDate": "2020-12-24T22:45:27Z", "type": "forcePushed"}, {"oid": "cecd315fafe36a4285f54c0c2db604306a3593b4", "url": "https://github.com/vmware/differential-datalog/commit/cecd315fafe36a4285f54c0c2db604306a3593b4", "message": "Finished Mutator derive", "committedDate": "2020-12-26T16:28:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkwNDM1Ng==", "url": "https://github.com/vmware/differential-datalog/pull/875#discussion_r549904356", "bodyText": "The error message is not correct if self is a struct with >0 fields.", "author": "ryzhyk", "createdAt": "2020-12-30T01:19:25Z", "path": "rust/template/ddlog_derive/src/mutator.rs", "diffHunk": "@@ -0,0 +1,250 @@\n+use super::{add_trait_bounds, get_rename};\n+use proc_macro2::TokenStream;\n+use quote::{format_ident, quote};\n+use syn::{\n+    parse_quote, spanned::Spanned, Data, DataEnum, DataStruct, DeriveInput, Error, Fields,\n+    FieldsNamed, FieldsUnnamed, Ident, ImplGenerics, Index, Result, TypeGenerics, WhereClause,\n+};\n+\n+pub fn mutator_inner(mut input: DeriveInput) -> Result<TokenStream> {\n+    // The name of the struct\n+    let struct_ident = input.ident;\n+\n+    // Make sure every generic is able to be mutated by `Record`\n+    // The redundant clone circumvents mutating the collection we're iterating over\n+    #[allow(clippy::redundant_clone)]\n+    for generic in input\n+        .generics\n+        .clone()\n+        .type_params()\n+        .map(|param| &param.ident)\n+    {\n+        input\n+            .generics\n+            .make_where_clause()\n+            .predicates\n+            .push(parse_quote! {\n+                differential_datalog::record::Record: differential_datalog::record::Mutator<#generic>\n+            });\n+    }\n+\n+    // Add the required trait bounds\n+    let generics = add_trait_bounds(\n+        input.generics,\n+        vec![parse_quote!(differential_datalog::record::FromRecord)],\n+    );\n+    let generics = generics.split_for_impl();\n+\n+    match input.data {\n+        // Derive for structs\n+        Data::Struct(derive_struct) => mutator_struct(struct_ident, derive_struct, generics),\n+\n+        // Derive for enums\n+        Data::Enum(derive_enum) => mutator_enum(struct_ident, derive_enum, generics),\n+\n+        // Unions can't safely/soundly be automatically implemented over,\n+        // the user will have to manually enforce invariants on it\n+        Data::Union(union) => Err(Error::new_spanned(\n+            union.union_token,\n+            \"`Mutator` is not able to be automatically implemented on unions\",\n+        )),\n+    }\n+}\n+\n+/// Unit structs have nothing to mutate, so make sure the constructor is correct and that\n+/// there's no fields on the record\n+fn unit_struct_mutator() -> TokenStream {\n+    quote! {\n+        match self {\n+            differential_datalog::record::Record::PosStruct(constructor, args)\n+                if args.is_empty() => {},\n+\n+            differential_datalog::record::Record::NamedStruct(constructor, args)\n+                if args.is_empty() => {},\n+\n+            error => {\n+                return std::result::Result::Err(std::format!(\"not a struct {:?}\", error));", "originalCommit": "bdbf02b7ddb4b5912ba9f3aa52286ea83065a0ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTkwNDQ1MQ==", "url": "https://github.com/vmware/differential-datalog/pull/875#discussion_r549904451", "bodyText": "same issue here", "author": "ryzhyk", "createdAt": "2020-12-30T01:19:56Z", "path": "rust/template/ddlog_derive/src/mutator.rs", "diffHunk": "@@ -0,0 +1,250 @@\n+use super::{add_trait_bounds, get_rename};\n+use proc_macro2::TokenStream;\n+use quote::{format_ident, quote};\n+use syn::{\n+    parse_quote, spanned::Spanned, Data, DataEnum, DataStruct, DeriveInput, Error, Fields,\n+    FieldsNamed, FieldsUnnamed, Ident, ImplGenerics, Index, Result, TypeGenerics, WhereClause,\n+};\n+\n+pub fn mutator_inner(mut input: DeriveInput) -> Result<TokenStream> {\n+    // The name of the struct\n+    let struct_ident = input.ident;\n+\n+    // Make sure every generic is able to be mutated by `Record`\n+    // The redundant clone circumvents mutating the collection we're iterating over\n+    #[allow(clippy::redundant_clone)]\n+    for generic in input\n+        .generics\n+        .clone()\n+        .type_params()\n+        .map(|param| &param.ident)\n+    {\n+        input\n+            .generics\n+            .make_where_clause()\n+            .predicates\n+            .push(parse_quote! {\n+                differential_datalog::record::Record: differential_datalog::record::Mutator<#generic>\n+            });\n+    }\n+\n+    // Add the required trait bounds\n+    let generics = add_trait_bounds(\n+        input.generics,\n+        vec![parse_quote!(differential_datalog::record::FromRecord)],\n+    );\n+    let generics = generics.split_for_impl();\n+\n+    match input.data {\n+        // Derive for structs\n+        Data::Struct(derive_struct) => mutator_struct(struct_ident, derive_struct, generics),\n+\n+        // Derive for enums\n+        Data::Enum(derive_enum) => mutator_enum(struct_ident, derive_enum, generics),\n+\n+        // Unions can't safely/soundly be automatically implemented over,\n+        // the user will have to manually enforce invariants on it\n+        Data::Union(union) => Err(Error::new_spanned(\n+            union.union_token,\n+            \"`Mutator` is not able to be automatically implemented on unions\",\n+        )),\n+    }\n+}\n+\n+/// Unit structs have nothing to mutate, so make sure the constructor is correct and that\n+/// there's no fields on the record\n+fn unit_struct_mutator() -> TokenStream {\n+    quote! {\n+        match self {\n+            differential_datalog::record::Record::PosStruct(constructor, args)\n+                if args.is_empty() => {},\n+\n+            differential_datalog::record::Record::NamedStruct(constructor, args)\n+                if args.is_empty() => {},\n+\n+            error => {\n+                return std::result::Result::Err(std::format!(\"not a struct {:?}\", error));\n+            },\n+        }\n+    }\n+}\n+\n+fn tuple_struct_mutator<'a>(\n+    tuple_struct: &'a FieldsUnnamed,\n+) -> (TokenStream, impl Iterator<Item = Ident> + 'a) {\n+    let num_fields = tuple_struct.unnamed.len();\n+\n+    let indices = tuple_struct.unnamed.iter().enumerate().map(|(idx, field)| {\n+        let index = Index {\n+            index: idx as u32,\n+            span: field.span(),\n+        };\n+\n+        format_ident!(\"_{}\", index)\n+    });\n+\n+    let field_mutations = tuple_struct\n+        .unnamed\n+        .iter()\n+        .zip(indices.clone())\n+        .enumerate()\n+        .map(|(idx, (field, index))| {\n+            let field_ty = &field.ty;\n+\n+            quote! {\n+                <dyn differential_datalog::record::Mutator<#field_ty>>::mutate(&args[#idx], #index)?;\n+            }\n+        });\n+\n+    let mutator = quote! {\n+        match self {\n+            differential_datalog::record::Record::PosStruct(constructor, args)\n+                if args.len() == #num_fields => {\n+                    #( #field_mutations )*\n+                },\n+\n+            error => {\n+                return std::result::Result::Err(std::format!(\"not a struct {:?}\", error));", "originalCommit": "bdbf02b7ddb4b5912ba9f3aa52286ea83065a0ae", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3f533fa85027112a7eec04334cc37b3883ecdc2d", "url": "https://github.com/vmware/differential-datalog/commit/3f533fa85027112a7eec04334cc37b3883ecdc2d", "message": "Started on derive macros", "committedDate": "2020-12-30T08:50:42Z", "type": "commit"}, {"oid": "7e73fc32544cbd059cee3340da18be417fa98241", "url": "https://github.com/vmware/differential-datalog/commit/7e73fc32544cbd059cee3340da18be417fa98241", "message": "Finished FromRecord derive macro", "committedDate": "2020-12-30T08:50:42Z", "type": "commit"}, {"oid": "05e3db5ad2909aa772c5b8f34f04a3b6c1ef7720", "url": "https://github.com/vmware/differential-datalog/commit/05e3db5ad2909aa772c5b8f34f04a3b6c1ef7720", "message": "Refactored FromRecord a bit", "committedDate": "2020-12-30T08:50:42Z", "type": "commit"}, {"oid": "ff10f0dbd3142d1680473b90b2323728d01d1dba", "url": "https://github.com/vmware/differential-datalog/commit/ff10f0dbd3142d1680473b90b2323728d01d1dba", "message": "Added IntoRecord derive macro and derive compile testing", "committedDate": "2020-12-30T08:50:42Z", "type": "commit"}, {"oid": "85ea65e8542c25966107d0f9115ed3e2009b91eb", "url": "https://github.com/vmware/differential-datalog/commit/85ea65e8542c25966107d0f9115ed3e2009b91eb", "message": "Simplified IntoRecord", "committedDate": "2020-12-30T08:50:42Z", "type": "commit"}, {"oid": "9dd96f064eb62ec4d31a9f2a00f82bcf0b14b242", "url": "https://github.com/vmware/differential-datalog/commit/9dd96f064eb62ec4d31a9f2a00f82bcf0b14b242", "message": "Updated Changelog with ddlog_derive changes", "committedDate": "2020-12-30T08:51:26Z", "type": "commit"}, {"oid": "a4960217994832b05a6fa364f3f1b0d9ae6460d5", "url": "https://github.com/vmware/differential-datalog/commit/a4960217994832b05a6fa364f3f1b0d9ae6460d5", "message": "Added Record::positional_struct_fields() and fixed derive tests", "committedDate": "2020-12-30T08:51:26Z", "type": "commit"}, {"oid": "3f58c5ba05dbcc73f35ee1b2bf38588f757ef5b9", "url": "https://github.com/vmware/differential-datalog/commit/3f58c5ba05dbcc73f35ee1b2bf38588f757ef5b9", "message": "Added Record::Serialized FromRecord code", "committedDate": "2020-12-30T08:51:26Z", "type": "commit"}, {"oid": "85c8ea0d1f5b140f502556a41e07494847835a93", "url": "https://github.com/vmware/differential-datalog/commit/85c8ea0d1f5b140f502556a41e07494847835a93", "message": "Finished Mutator derive", "committedDate": "2020-12-30T08:51:26Z", "type": "commit"}, {"oid": "9521fdc0e49b106fdc07d8316317c056dbca7225", "url": "https://github.com/vmware/differential-datalog/commit/9521fdc0e49b106fdc07d8316317c056dbca7225", "message": "Implemented nomial typing and added tests for it", "committedDate": "2020-12-30T08:51:26Z", "type": "commit"}, {"oid": "c848c6c4ba0d9eed56455316afb0c517050c5f6e", "url": "https://github.com/vmware/differential-datalog/commit/c848c6c4ba0d9eed56455316afb0c517050c5f6e", "message": "Improved error messages for Mutator derive macro", "committedDate": "2020-12-30T08:51:26Z", "type": "commit"}, {"oid": "24cf93fd2a475f7f002de899d9a9cf5ca7c5e173", "url": "https://github.com/vmware/differential-datalog/commit/24cf93fd2a475f7f002de899d9a9cf5ca7c5e173", "message": "into_record.rs: Use qualified name std::vec::Vec.\n\nAvoid name clash with `ddlog_std::Vec`.", "committedDate": "2020-12-30T08:51:26Z", "type": "commit"}, {"oid": "9c0b596c30d91b85c4792ede7d081ba9b352f0a8", "url": "https://github.com/vmware/differential-datalog/commit/9c0b596c30d91b85c4792ede7d081ba9b352f0a8", "message": "mutator.rs: Strengthen trait bounds.\n\nIn addition to requiring that generic arguments implement `FromRecord`,\nadd `Default`, `Deserialize`, and `Sized` bounds required by\n`FromRecord`.", "committedDate": "2020-12-30T08:51:26Z", "type": "commit"}, {"oid": "3475db2da818edbaf1283268e8e83ce610959eb6", "url": "https://github.com/vmware/differential-datalog/commit/3475db2da818edbaf1283268e8e83ce610959eb6", "message": "Change semantics of `rename` for enum variants.\n\nIn DDlog, enum variants live in the module name space.  We therefore want\nto be able to rename them in the compiler so that the constructor name\nin the `Record` representation does not include enum name.", "committedDate": "2020-12-30T08:51:26Z", "type": "commit"}, {"oid": "ee278c822bbc94eafd55371372f58b523703d8cb", "url": "https://github.com/vmware/differential-datalog/commit/ee278c822bbc94eafd55371372f58b523703d8cb", "message": "Use `ddlog_derive` in the compiler.\n\nGet rid of the old macros that generate `FromRecord`, `IntoRecord` and\n`Mutator` implementations, along with a bunch of code in `Compile.hs`\nthat invokes these macros.", "committedDate": "2020-12-30T22:44:50Z", "type": "commit"}, {"oid": "c59345744fbd0325853555d45567d199a6605be1", "url": "https://github.com/vmware/differential-datalog/commit/c59345744fbd0325853555d45567d199a6605be1", "message": "test.sh: Add `ddlog_dev` tests to the test suite.", "committedDate": "2020-12-30T22:44:50Z", "type": "commit"}, {"oid": "041df634a064d47069b41855c9072c01473821e1", "url": "https://github.com/vmware/differential-datalog/commit/041df634a064d47069b41855c9072c01473821e1", "message": "New clippy lints in Rust 1.48.", "committedDate": "2020-12-30T22:44:50Z", "type": "commit"}, {"oid": "7b30543549fee60abb96107abd17d3e0d975f693", "url": "https://github.com/vmware/differential-datalog/commit/7b30543549fee60abb96107abd17d3e0d975f693", "message": "into_record.rs: Convert unit struct to NamedStruct.\n\nChange the behavior of IntoRecord to serialize unit structs as\n`NamedStruct` with zero arguments instead of `PosStruct` with zero\narguments.  Technically, this makes no difference, but named struct is\ngenerally a more expressive representation, e.g., it can be converted to\nJSON, and there is some code out there, e.g., in OVN that refuses to\ndeal with positional structs.\n\nIn the future, we should probablyh extend the IntoRecord trait to\nprovide separate methods for conversion to `PosStruct` and\n`NamedStruct`, as the former representation is more memory-efficient,\nwhile the latter contain more information about the type, that is\nnecessary in certain situations.", "committedDate": "2020-12-30T22:44:50Z", "type": "commit"}, {"oid": "7b30543549fee60abb96107abd17d3e0d975f693", "url": "https://github.com/vmware/differential-datalog/commit/7b30543549fee60abb96107abd17d3e0d975f693", "message": "into_record.rs: Convert unit struct to NamedStruct.\n\nChange the behavior of IntoRecord to serialize unit structs as\n`NamedStruct` with zero arguments instead of `PosStruct` with zero\narguments.  Technically, this makes no difference, but named struct is\ngenerally a more expressive representation, e.g., it can be converted to\nJSON, and there is some code out there, e.g., in OVN that refuses to\ndeal with positional structs.\n\nIn the future, we should probablyh extend the IntoRecord trait to\nprovide separate methods for conversion to `PosStruct` and\n`NamedStruct`, as the former representation is more memory-efficient,\nwhile the latter contain more information about the type, that is\nnecessary in certain situations.", "committedDate": "2020-12-30T22:44:50Z", "type": "forcePushed"}]}