{"pr_number": 677, "pr_title": "ovsdb2ddlog: Encode optional columns as Option<>.", "pr_createdAt": "2020-05-24T23:39:28Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/677", "timeline": [{"oid": "44e6e977c16036c97600f889cccd525c6008e0a5", "url": "https://github.com/vmware/differential-datalog/commit/44e6e977c16036c97600f889cccd525c6008e0a5", "message": "All OVN tests pass with the latest fixes to northd.", "committedDate": "2020-05-22T22:36:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEyODE2Mg==", "url": "https://github.com/vmware/differential-datalog/pull/677#discussion_r430128162", "bodyText": "it would be nice if the signature of this implementation was documented someplace.", "author": "mbudiu-vmw", "createdAt": "2020-05-26T02:38:02Z", "path": "src/Language/DifferentialDatalog/Attribute.hs", "diffHunk": "@@ -157,6 +164,23 @@ tdefGetCustomSerdeAttr d tdef =\n          Left e  -> error e\n          Right b -> b\n \n+{- 'custom_from_record' attribute: Tells DDlog not to generate `FromRecord`\n+ - implementation for a type.  The user must write their own implementations in", "originalCommit": "3619726f603f1ecb4439bf0b256d64107d23e3e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ3NDQ3MA==", "url": "https://github.com/vmware/differential-datalog/pull/677#discussion_r430474470", "bodyText": "I don't think users should be writing these annotations. This is an ugly workaround for the OVSDB problem that I could not solve properly without a major type system overhaul.", "author": "ryzhyk", "createdAt": "2020-05-26T14:52:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEyODE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEyODM0NQ==", "url": "https://github.com/vmware/differential-datalog/pull/677#discussion_r430128345", "bodyText": "I would add here a comment indicating what this means: the implementation must be given in the corresponding rust file, and it must have two functions with some signatures.", "author": "mbudiu-vmw", "createdAt": "2020-05-26T02:39:07Z", "path": "lib/std.dl", "diffHunk": "@@ -80,6 +80,7 @@ extern function pow32(base:'A, exp: bit<32>): 'A\n  */\n \n #[rust=\"serde(from=\\\"Option<A>\\\", into=\\\"Option<A>\\\", bound(serialize=\\\"A: Clone+Serialize\\\"))\"]\n+#[custom_from_record]", "originalCommit": "3619726f603f1ecb4439bf0b256d64107d23e3e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEyODUxNw==", "url": "https://github.com/vmware/differential-datalog/pull/677#discussion_r430128517", "bodyText": "it's in fact trickier, because the implementation has to know about this Record type. So then that has to be documented someplace.", "author": "mbudiu-vmw", "createdAt": "2020-05-26T02:40:07Z", "path": "lib/std.rs", "diffHunk": "@@ -145,6 +145,62 @@ impl<T> From<std_Option<T>> for Option<T> {\n     }\n }\n \n+impl<A: record::FromRecord + serde::de::DeserializeOwned + Default> record::FromRecord\n+    for std_Option<A>\n+{\n+    fn from_record(val: &record::Record) -> result::Result<Self, String> {", "originalCommit": "3619726f603f1ecb4439bf0b256d64107d23e3e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEyODcyNQ==", "url": "https://github.com/vmware/differential-datalog/pull/677#discussion_r430128725", "bodyText": "what about other collections?", "author": "mbudiu-vmw", "createdAt": "2020-05-26T02:41:07Z", "path": "lib/std.rs", "diffHunk": "@@ -145,6 +145,62 @@ impl<T> From<std_Option<T>> for Option<T> {\n     }\n }\n \n+impl<A: record::FromRecord + serde::de::DeserializeOwned + Default> record::FromRecord\n+    for std_Option<A>\n+{\n+    fn from_record(val: &record::Record) -> result::Result<Self, String> {\n+        match val {\n+            record::Record::PosStruct(constr, args) => match constr.as_ref() {\n+                \"std.None\" if args.len() == 0 => Ok(std_Option::std_None {}),\n+                \"std.Some\" if args.len() == 1 => Ok(std_Option::std_Some {\n+                    x: <A>::from_record(&args[0])?,\n+                }),\n+                c => result::Result::Err(format!(\n+                    \"unknown constructor {} of type std_Option in {:?}\",\n+                    c, *val\n+                )),\n+            },\n+            record::Record::NamedStruct(constr, args) => match constr.as_ref() {\n+                \"std.None\" => Ok(std_Option::std_None {}),\n+                \"std.Some\" => Ok(std_Option::std_Some {\n+                    x: record::arg_extract::<A>(args, \"x\")?,\n+                }),\n+                c => result::Result::Err(format!(\n+                    \"unknown constructor {} of type std_Option in {:?}\",\n+                    c, *val\n+                )),\n+            },\n+            /* `Option` encoded as an array of size 0 or 1.  This is, for instance, useful when\n+             * interfacing with OVSDB. */\n+            record::Record::Array(kind, records) => match (records.len()) {", "originalCommit": "3619726f603f1ecb4439bf0b256d64107d23e3e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDQ3NTQzNA==", "url": "https://github.com/vmware/differential-datalog/pull/677#discussion_r430475434", "bodyText": "sets, maps, etc., are extern types and already have their own manual implementations of FromRecord that support arrays.", "author": "ryzhyk", "createdAt": "2020-05-26T14:54:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDEyODcyNQ=="}], "type": "inlineReview"}, {"oid": "09094a30089f30b9ab99a8ceed57beb99cecfbbb", "url": "https://github.com/vmware/differential-datalog/commit/09094a30089f30b9ab99a8ceed57beb99cecfbbb", "message": "ovsdb2ddlog: Encode optional columns as Option<>.\n\nResolves #676.\n\nOVSDB columns representing sets are normally encoded as a DDlog sets.\nHowever in the special case where column's multiplicity bounds are min: 0 an\nmax: 1, `Option<>` is a more natural representation.  This commit\nimplements this optimization.\n\nBut now we have to deal with the complication that the Rust code that\nconverts OVSDB JSON to DDlog records must correctly deserialize\narrays into `Option<>`.  This code is agnostic of the OVSDB schema and\ncannot easily tell what the target type is.  We therefore change the\n`FromRecord` implementation for `Option<>` to handle this case.  This in\nturn required adding a new attributes `#[custom_from_record]` to\noverride the autogenerated implementation of `FromRecord` created by\nDDlog.", "committedDate": "2020-05-26T14:54:30Z", "type": "commit"}, {"oid": "09094a30089f30b9ab99a8ceed57beb99cecfbbb", "url": "https://github.com/vmware/differential-datalog/commit/09094a30089f30b9ab99a8ceed57beb99cecfbbb", "message": "ovsdb2ddlog: Encode optional columns as Option<>.\n\nResolves #676.\n\nOVSDB columns representing sets are normally encoded as a DDlog sets.\nHowever in the special case where column's multiplicity bounds are min: 0 an\nmax: 1, `Option<>` is a more natural representation.  This commit\nimplements this optimization.\n\nBut now we have to deal with the complication that the Rust code that\nconverts OVSDB JSON to DDlog records must correctly deserialize\narrays into `Option<>`.  This code is agnostic of the OVSDB schema and\ncannot easily tell what the target type is.  We therefore change the\n`FromRecord` implementation for `Option<>` to handle this case.  This in\nturn required adding a new attributes `#[custom_from_record]` to\noverride the autogenerated implementation of `FromRecord` created by\nDDlog.", "committedDate": "2020-05-26T14:54:30Z", "type": "forcePushed"}]}