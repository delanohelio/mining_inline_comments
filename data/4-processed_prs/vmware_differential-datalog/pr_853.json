{"pr_number": 853, "pr_title": "Work-in-Progress: C Tutorial", "pr_createdAt": "2020-12-10T18:03:39Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/853", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyNDQyMA==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540524420", "bodyText": "I would suggest a less casual title: writing a C-DDlog mixed application.", "author": "mbudiu-vmw", "createdAt": "2020-12-10T21:54:19Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+********************************\r\n+WIP: How to befriend DDlog and C\r", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyNTE1OQ==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540525159", "bodyText": "\"Futhermore, we will also\"", "author": "mbudiu-vmw", "createdAt": "2020-12-10T21:55:28Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+********************************\r\n+WIP: How to befriend DDlog and C\r\n+********************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog__ from the official repository, which contains instructions how to install and set it up. There is also an expectation that you are familiar with DDlog syntax and commands, i.e., read the tutorial or at least skim through it.\r\n+\r\n+__\r\n+.. _DDlog DDlog repository on GitHub:\r\n+    https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog and learn how to befriend DDlog program with C program. To do that we are going to build several simple yet functional applications as it is more fun to build real programs. Furthermore, it will also demonstrate that DDlog is not limited to a particular domain, but rather can be used to solve different problems.\r", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyNjIzMA==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540526230", "bodyText": "You didn't say what the domain is, perhaps you can be more specific.", "author": "mbudiu-vmw", "createdAt": "2020-12-10T21:57:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyNTE1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyNjYxOQ==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540526619", "bodyText": "The program is actually completely general, you are testing it with an input that has 4 nodes.", "author": "mbudiu-vmw", "createdAt": "2020-12-10T21:57:53Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+********************************\r\n+WIP: How to befriend DDlog and C\r\n+********************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog__ from the official repository, which contains instructions how to install and set it up. There is also an expectation that you are familiar with DDlog syntax and commands, i.e., read the tutorial or at least skim through it.\r\n+\r\n+__\r\n+.. _DDlog DDlog repository on GitHub:\r\n+    https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog and learn how to befriend DDlog program with C program. To do that we are going to build several simple yet functional applications as it is more fun to build real programs. Furthermore, it will also demonstrate that DDlog is not limited to a particular domain, but rather can be used to solve different problems.\r\n+\r\n+Tutorial #1 - Reachibility Monitor\r\n+==================================\r\n+\r\n+In our first tutorial we are going to build a program that will store the reachibility information in the network of four nodes: Menlo Park, Santa Barbara, Los Angeles, and Salt Lake City. User will update link status between nodes through CLI and our program will calculate the rest. The purpose of this program is to provide a simple interface to a network operator and return information regarding which node can reach which. Thus, the only concern of network operator is to update link status without having to worry about doing those calculations themself. While, this task can be relatively easy done in our example of four nodes, in a more realistic scenario, the number of nodes can be in the order of hundreds and link status updates can be streamed into the monitoring application.\r", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyODExNA==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540528114", "bodyText": "I think you are using tabs. does .rst do something special to tabs? Otherwise I would suggest using spaces to get a predictable layout.", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:00:24Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+********************************\r\n+WIP: How to befriend DDlog and C\r\n+********************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog__ from the official repository, which contains instructions how to install and set it up. There is also an expectation that you are familiar with DDlog syntax and commands, i.e., read the tutorial or at least skim through it.\r\n+\r\n+__\r\n+.. _DDlog DDlog repository on GitHub:\r\n+    https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog and learn how to befriend DDlog program with C program. To do that we are going to build several simple yet functional applications as it is more fun to build real programs. Furthermore, it will also demonstrate that DDlog is not limited to a particular domain, but rather can be used to solve different problems.\r\n+\r\n+Tutorial #1 - Reachibility Monitor\r\n+==================================\r\n+\r\n+In our first tutorial we are going to build a program that will store the reachibility information in the network of four nodes: Menlo Park, Santa Barbara, Los Angeles, and Salt Lake City. User will update link status between nodes through CLI and our program will calculate the rest. The purpose of this program is to provide a simple interface to a network operator and return information regarding which node can reach which. Thus, the only concern of network operator is to update link status without having to worry about doing those calculations themself. While, this task can be relatively easy done in our example of four nodes, in a more realistic scenario, the number of nodes can be in the order of hundreds and link status updates can be streamed into the monitoring application.\r\n+\r\n+Let's start with defining our program in the DDlog language. In our program we need to supply source node, destination node, and a link status between them. Now we are ready to define our input relation :code:`Links`. Let's create a file called :code:`t1_reachibility_monitor.dl` and add there a following line representing input relation for our reachibility monitor:\r\n+\r\n+.. code-block::\r\n+    \r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\r\n+However, for the reachibility monitor to be useful it also should provide some output and not just ingest the data. We want our program to output a list of nodes that are currently reachable based on the information in the relation :code:`Links`. Thus, let's add an output relation :code:`ConnectedNodes` and provide a rule to calculate records in this relation. To do that we are going to add few more lines to the :code:`t1_reachibility_monitor.dl` so it will looks as follows:\r\n+\r\n+.. code-block::\r\n+\r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyODM1Mg==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540528352", "bodyText": "Is there a way to number lines and refer to them by number?", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:00:50Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+********************************\r\n+WIP: How to befriend DDlog and C\r\n+********************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog__ from the official repository, which contains instructions how to install and set it up. There is also an expectation that you are familiar with DDlog syntax and commands, i.e., read the tutorial or at least skim through it.\r\n+\r\n+__\r\n+.. _DDlog DDlog repository on GitHub:\r\n+    https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog and learn how to befriend DDlog program with C program. To do that we are going to build several simple yet functional applications as it is more fun to build real programs. Furthermore, it will also demonstrate that DDlog is not limited to a particular domain, but rather can be used to solve different problems.\r\n+\r\n+Tutorial #1 - Reachibility Monitor\r\n+==================================\r\n+\r\n+In our first tutorial we are going to build a program that will store the reachibility information in the network of four nodes: Menlo Park, Santa Barbara, Los Angeles, and Salt Lake City. User will update link status between nodes through CLI and our program will calculate the rest. The purpose of this program is to provide a simple interface to a network operator and return information regarding which node can reach which. Thus, the only concern of network operator is to update link status without having to worry about doing those calculations themself. While, this task can be relatively easy done in our example of four nodes, in a more realistic scenario, the number of nodes can be in the order of hundreds and link status updates can be streamed into the monitoring application.\r\n+\r\n+Let's start with defining our program in the DDlog language. In our program we need to supply source node, destination node, and a link status between them. Now we are ready to define our input relation :code:`Links`. Let's create a file called :code:`t1_reachibility_monitor.dl` and add there a following line representing input relation for our reachibility monitor:\r\n+\r\n+.. code-block::\r\n+    \r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\r\n+However, for the reachibility monitor to be useful it also should provide some output and not just ingest the data. We want our program to output a list of nodes that are currently reachable based on the information in the relation :code:`Links`. Thus, let's add an output relation :code:`ConnectedNodes` and provide a rule to calculate records in this relation. To do that we are going to add few more lines to the :code:`t1_reachibility_monitor.dl` so it will looks as follows:\r\n+\r\n+.. code-block::\r\n+\r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\toutput relation ConnectedNodes(str: string, dst: string)\r\n+\r\n+\tConnectedNodes(src, dst) :- Links(src, dst, true).\r\n+\tConnectedNodes(src, dst) :- ConnectedNodes(src, intermediate_node),\r\n+\t\t\t\tLinks(intermediate_node, dst, true).\r\n+\r\n+Let's briefly discuss the rule to calculate :code:`ConnectedNodes` relation. First, we say that any directly connected nodes such that the :code:`link_status` between them is :code:`true` belong to :code:`ConnectedNodes` relation. Furthermore, any two nodes are considered connected if there is path from the source node to the destination node such that all directly connected nodes along the path are also connected. Take a minute here to realize how easy is it to write such rule in DDlog. Isn't is amazing?\r", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyOTcwMA==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540529700", "bodyText": "Writing such a rule isn't any harder in other programming languages. What is much harder is computing it incrementally.", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:03:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyODM1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUyOTExNQ==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540529115", "bodyText": "your lines are long, so it's difficult to add git comments for a specific position.", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:02:09Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+********************************\r\n+WIP: How to befriend DDlog and C\r\n+********************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog__ from the official repository, which contains instructions how to install and set it up. There is also an expectation that you are familiar with DDlog syntax and commands, i.e., read the tutorial or at least skim through it.\r\n+\r\n+__\r\n+.. _DDlog DDlog repository on GitHub:\r\n+    https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog and learn how to befriend DDlog program with C program. To do that we are going to build several simple yet functional applications as it is more fun to build real programs. Furthermore, it will also demonstrate that DDlog is not limited to a particular domain, but rather can be used to solve different problems.\r\n+\r\n+Tutorial #1 - Reachibility Monitor\r\n+==================================\r\n+\r\n+In our first tutorial we are going to build a program that will store the reachibility information in the network of four nodes: Menlo Park, Santa Barbara, Los Angeles, and Salt Lake City. User will update link status between nodes through CLI and our program will calculate the rest. The purpose of this program is to provide a simple interface to a network operator and return information regarding which node can reach which. Thus, the only concern of network operator is to update link status without having to worry about doing those calculations themself. While, this task can be relatively easy done in our example of four nodes, in a more realistic scenario, the number of nodes can be in the order of hundreds and link status updates can be streamed into the monitoring application.\r\n+\r\n+Let's start with defining our program in the DDlog language. In our program we need to supply source node, destination node, and a link status between them. Now we are ready to define our input relation :code:`Links`. Let's create a file called :code:`t1_reachibility_monitor.dl` and add there a following line representing input relation for our reachibility monitor:\r\n+\r\n+.. code-block::\r\n+    \r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\r\n+However, for the reachibility monitor to be useful it also should provide some output and not just ingest the data. We want our program to output a list of nodes that are currently reachable based on the information in the relation :code:`Links`. Thus, let's add an output relation :code:`ConnectedNodes` and provide a rule to calculate records in this relation. To do that we are going to add few more lines to the :code:`t1_reachibility_monitor.dl` so it will looks as follows:\r", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzMDExOQ==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540530119", "bodyText": "maybe you can say that the _ddlog directory is generated by the compiler", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:03:57Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+********************************\r\n+WIP: How to befriend DDlog and C\r\n+********************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog__ from the official repository, which contains instructions how to install and set it up. There is also an expectation that you are familiar with DDlog syntax and commands, i.e., read the tutorial or at least skim through it.\r\n+\r\n+__\r\n+.. _DDlog DDlog repository on GitHub:\r\n+    https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog and learn how to befriend DDlog program with C program. To do that we are going to build several simple yet functional applications as it is more fun to build real programs. Furthermore, it will also demonstrate that DDlog is not limited to a particular domain, but rather can be used to solve different problems.\r\n+\r\n+Tutorial #1 - Reachibility Monitor\r\n+==================================\r\n+\r\n+In our first tutorial we are going to build a program that will store the reachibility information in the network of four nodes: Menlo Park, Santa Barbara, Los Angeles, and Salt Lake City. User will update link status between nodes through CLI and our program will calculate the rest. The purpose of this program is to provide a simple interface to a network operator and return information regarding which node can reach which. Thus, the only concern of network operator is to update link status without having to worry about doing those calculations themself. While, this task can be relatively easy done in our example of four nodes, in a more realistic scenario, the number of nodes can be in the order of hundreds and link status updates can be streamed into the monitoring application.\r\n+\r\n+Let's start with defining our program in the DDlog language. In our program we need to supply source node, destination node, and a link status between them. Now we are ready to define our input relation :code:`Links`. Let's create a file called :code:`t1_reachibility_monitor.dl` and add there a following line representing input relation for our reachibility monitor:\r\n+\r\n+.. code-block::\r\n+    \r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\r\n+However, for the reachibility monitor to be useful it also should provide some output and not just ingest the data. We want our program to output a list of nodes that are currently reachable based on the information in the relation :code:`Links`. Thus, let's add an output relation :code:`ConnectedNodes` and provide a rule to calculate records in this relation. To do that we are going to add few more lines to the :code:`t1_reachibility_monitor.dl` so it will looks as follows:\r\n+\r\n+.. code-block::\r\n+\r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\toutput relation ConnectedNodes(str: string, dst: string)\r\n+\r\n+\tConnectedNodes(src, dst) :- Links(src, dst, true).\r\n+\tConnectedNodes(src, dst) :- ConnectedNodes(src, intermediate_node),\r\n+\t\t\t\tLinks(intermediate_node, dst, true).\r\n+\r\n+Let's briefly discuss the rule to calculate :code:`ConnectedNodes` relation. First, we say that any directly connected nodes such that the :code:`link_status` between them is :code:`true` belong to :code:`ConnectedNodes` relation. Furthermore, any two nodes are considered connected if there is path from the source node to the destination node such that all directly connected nodes along the path are also connected. Take a minute here to realize how easy is it to write such rule in DDlog. Isn't is amazing?\r\n+\r\n+With that done, let's compile and start out program.\r\n+\r\n+.. code-block::\r\n+\r\n+\t$ ddlog -i t1_reachibility_monitor.dl\r\n+\t$ cd t1_reachibility_monitor_ddlog/ && cargo build --release\r", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzNTY4MA==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540535680", "bodyText": "Do you want to say something about the fact that this will take a while the first time, but be much faster later?", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzMDExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzMDQ4MA==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540530480", "bodyText": "you can probably say that this starts a command-line program that lets you interact with the ddlog program currently running.", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:04:34Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+********************************\r\n+WIP: How to befriend DDlog and C\r\n+********************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog__ from the official repository, which contains instructions how to install and set it up. There is also an expectation that you are familiar with DDlog syntax and commands, i.e., read the tutorial or at least skim through it.\r\n+\r\n+__\r\n+.. _DDlog DDlog repository on GitHub:\r\n+    https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog and learn how to befriend DDlog program with C program. To do that we are going to build several simple yet functional applications as it is more fun to build real programs. Furthermore, it will also demonstrate that DDlog is not limited to a particular domain, but rather can be used to solve different problems.\r\n+\r\n+Tutorial #1 - Reachibility Monitor\r\n+==================================\r\n+\r\n+In our first tutorial we are going to build a program that will store the reachibility information in the network of four nodes: Menlo Park, Santa Barbara, Los Angeles, and Salt Lake City. User will update link status between nodes through CLI and our program will calculate the rest. The purpose of this program is to provide a simple interface to a network operator and return information regarding which node can reach which. Thus, the only concern of network operator is to update link status without having to worry about doing those calculations themself. While, this task can be relatively easy done in our example of four nodes, in a more realistic scenario, the number of nodes can be in the order of hundreds and link status updates can be streamed into the monitoring application.\r\n+\r\n+Let's start with defining our program in the DDlog language. In our program we need to supply source node, destination node, and a link status between them. Now we are ready to define our input relation :code:`Links`. Let's create a file called :code:`t1_reachibility_monitor.dl` and add there a following line representing input relation for our reachibility monitor:\r\n+\r\n+.. code-block::\r\n+    \r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\r\n+However, for the reachibility monitor to be useful it also should provide some output and not just ingest the data. We want our program to output a list of nodes that are currently reachable based on the information in the relation :code:`Links`. Thus, let's add an output relation :code:`ConnectedNodes` and provide a rule to calculate records in this relation. To do that we are going to add few more lines to the :code:`t1_reachibility_monitor.dl` so it will looks as follows:\r\n+\r\n+.. code-block::\r\n+\r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\toutput relation ConnectedNodes(str: string, dst: string)\r\n+\r\n+\tConnectedNodes(src, dst) :- Links(src, dst, true).\r\n+\tConnectedNodes(src, dst) :- ConnectedNodes(src, intermediate_node),\r\n+\t\t\t\tLinks(intermediate_node, dst, true).\r\n+\r\n+Let's briefly discuss the rule to calculate :code:`ConnectedNodes` relation. First, we say that any directly connected nodes such that the :code:`link_status` between them is :code:`true` belong to :code:`ConnectedNodes` relation. Furthermore, any two nodes are considered connected if there is path from the source node to the destination node such that all directly connected nodes along the path are also connected. Take a minute here to realize how easy is it to write such rule in DDlog. Isn't is amazing?\r\n+\r\n+With that done, let's compile and start out program.\r\n+\r\n+.. code-block::\r\n+\r\n+\t$ ddlog -i t1_reachibility_monitor.dl\r\n+\t$ cd t1_reachibility_monitor_ddlog/ && cargo build --release\r\n+\t$ ./target/release/t1_reachibility_monitor_cli\r", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzMDU4Mg==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540530582", "bodyText": "check -> display the contents?", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:04:47Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+********************************\r\n+WIP: How to befriend DDlog and C\r\n+********************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog__ from the official repository, which contains instructions how to install and set it up. There is also an expectation that you are familiar with DDlog syntax and commands, i.e., read the tutorial or at least skim through it.\r\n+\r\n+__\r\n+.. _DDlog DDlog repository on GitHub:\r\n+    https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog and learn how to befriend DDlog program with C program. To do that we are going to build several simple yet functional applications as it is more fun to build real programs. Furthermore, it will also demonstrate that DDlog is not limited to a particular domain, but rather can be used to solve different problems.\r\n+\r\n+Tutorial #1 - Reachibility Monitor\r\n+==================================\r\n+\r\n+In our first tutorial we are going to build a program that will store the reachibility information in the network of four nodes: Menlo Park, Santa Barbara, Los Angeles, and Salt Lake City. User will update link status between nodes through CLI and our program will calculate the rest. The purpose of this program is to provide a simple interface to a network operator and return information regarding which node can reach which. Thus, the only concern of network operator is to update link status without having to worry about doing those calculations themself. While, this task can be relatively easy done in our example of four nodes, in a more realistic scenario, the number of nodes can be in the order of hundreds and link status updates can be streamed into the monitoring application.\r\n+\r\n+Let's start with defining our program in the DDlog language. In our program we need to supply source node, destination node, and a link status between them. Now we are ready to define our input relation :code:`Links`. Let's create a file called :code:`t1_reachibility_monitor.dl` and add there a following line representing input relation for our reachibility monitor:\r\n+\r\n+.. code-block::\r\n+    \r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\r\n+However, for the reachibility monitor to be useful it also should provide some output and not just ingest the data. We want our program to output a list of nodes that are currently reachable based on the information in the relation :code:`Links`. Thus, let's add an output relation :code:`ConnectedNodes` and provide a rule to calculate records in this relation. To do that we are going to add few more lines to the :code:`t1_reachibility_monitor.dl` so it will looks as follows:\r\n+\r\n+.. code-block::\r\n+\r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\toutput relation ConnectedNodes(str: string, dst: string)\r\n+\r\n+\tConnectedNodes(src, dst) :- Links(src, dst, true).\r\n+\tConnectedNodes(src, dst) :- ConnectedNodes(src, intermediate_node),\r\n+\t\t\t\tLinks(intermediate_node, dst, true).\r\n+\r\n+Let's briefly discuss the rule to calculate :code:`ConnectedNodes` relation. First, we say that any directly connected nodes such that the :code:`link_status` between them is :code:`true` belong to :code:`ConnectedNodes` relation. Furthermore, any two nodes are considered connected if there is path from the source node to the destination node such that all directly connected nodes along the path are also connected. Take a minute here to realize how easy is it to write such rule in DDlog. Isn't is amazing?\r\n+\r\n+With that done, let's compile and start out program.\r\n+\r\n+.. code-block::\r\n+\r\n+\t$ ddlog -i t1_reachibility_monitor.dl\r\n+\t$ cd t1_reachibility_monitor_ddlog/ && cargo build --release\r\n+\t$ ./target/release/t1_reachibility_monitor_cli\r\n+\r\n+If we check :code:`ConnectedNodes` we will see that this relation is empty, which make sense as we haven't populated relation :code:`Links` with anything yet:\r", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzMDkyMQ==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540530921", "bodyText": "you are not really fixing the program, you are supplying input data.", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:05:27Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+********************************\r\n+WIP: How to befriend DDlog and C\r\n+********************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog__ from the official repository, which contains instructions how to install and set it up. There is also an expectation that you are familiar with DDlog syntax and commands, i.e., read the tutorial or at least skim through it.\r\n+\r\n+__\r\n+.. _DDlog DDlog repository on GitHub:\r\n+    https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog and learn how to befriend DDlog program with C program. To do that we are going to build several simple yet functional applications as it is more fun to build real programs. Furthermore, it will also demonstrate that DDlog is not limited to a particular domain, but rather can be used to solve different problems.\r\n+\r\n+Tutorial #1 - Reachibility Monitor\r\n+==================================\r\n+\r\n+In our first tutorial we are going to build a program that will store the reachibility information in the network of four nodes: Menlo Park, Santa Barbara, Los Angeles, and Salt Lake City. User will update link status between nodes through CLI and our program will calculate the rest. The purpose of this program is to provide a simple interface to a network operator and return information regarding which node can reach which. Thus, the only concern of network operator is to update link status without having to worry about doing those calculations themself. While, this task can be relatively easy done in our example of four nodes, in a more realistic scenario, the number of nodes can be in the order of hundreds and link status updates can be streamed into the monitoring application.\r\n+\r\n+Let's start with defining our program in the DDlog language. In our program we need to supply source node, destination node, and a link status between them. Now we are ready to define our input relation :code:`Links`. Let's create a file called :code:`t1_reachibility_monitor.dl` and add there a following line representing input relation for our reachibility monitor:\r\n+\r\n+.. code-block::\r\n+    \r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\r\n+However, for the reachibility monitor to be useful it also should provide some output and not just ingest the data. We want our program to output a list of nodes that are currently reachable based on the information in the relation :code:`Links`. Thus, let's add an output relation :code:`ConnectedNodes` and provide a rule to calculate records in this relation. To do that we are going to add few more lines to the :code:`t1_reachibility_monitor.dl` so it will looks as follows:\r\n+\r\n+.. code-block::\r\n+\r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\toutput relation ConnectedNodes(str: string, dst: string)\r\n+\r\n+\tConnectedNodes(src, dst) :- Links(src, dst, true).\r\n+\tConnectedNodes(src, dst) :- ConnectedNodes(src, intermediate_node),\r\n+\t\t\t\tLinks(intermediate_node, dst, true).\r\n+\r\n+Let's briefly discuss the rule to calculate :code:`ConnectedNodes` relation. First, we say that any directly connected nodes such that the :code:`link_status` between them is :code:`true` belong to :code:`ConnectedNodes` relation. Furthermore, any two nodes are considered connected if there is path from the source node to the destination node such that all directly connected nodes along the path are also connected. Take a minute here to realize how easy is it to write such rule in DDlog. Isn't is amazing?\r\n+\r\n+With that done, let's compile and start out program.\r\n+\r\n+.. code-block::\r\n+\r\n+\t$ ddlog -i t1_reachibility_monitor.dl\r\n+\t$ cd t1_reachibility_monitor_ddlog/ && cargo build --release\r\n+\t$ ./target/release/t1_reachibility_monitor_cli\r\n+\r\n+If we check :code:`ConnectedNodes` we will see that this relation is empty, which make sense as we haven't populated relation :code:`Links` with anything yet:\r\n+\r\n+.. code-block::\r\n+\r\n+\t>> dump ConnectedNodes;\r\n+\r\n+To exit DDlog shell press `[CTRL+d]`. If you are using `Windows Terminal` do not press `[CTRL+D]` (note capital `D`, `[CTRL+SHIFT+d]`) as it will open new tab.\r\n+\r\n+Let's fix it. We are going to insert several records into :code:`Links` relation. But first let's define a simple network topology that we are going to work through. To make our life more interesting (and just slightly more complicated) the links between nodes will not be bidirectional by default.\r", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzMTI5MA==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540531290", "bodyText": "before noticing that something is off you could say something about this containing the expected output.", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:06:05Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+********************************\r\n+WIP: How to befriend DDlog and C\r\n+********************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog__ from the official repository, which contains instructions how to install and set it up. There is also an expectation that you are familiar with DDlog syntax and commands, i.e., read the tutorial or at least skim through it.\r\n+\r\n+__\r\n+.. _DDlog DDlog repository on GitHub:\r\n+    https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog and learn how to befriend DDlog program with C program. To do that we are going to build several simple yet functional applications as it is more fun to build real programs. Furthermore, it will also demonstrate that DDlog is not limited to a particular domain, but rather can be used to solve different problems.\r\n+\r\n+Tutorial #1 - Reachibility Monitor\r\n+==================================\r\n+\r\n+In our first tutorial we are going to build a program that will store the reachibility information in the network of four nodes: Menlo Park, Santa Barbara, Los Angeles, and Salt Lake City. User will update link status between nodes through CLI and our program will calculate the rest. The purpose of this program is to provide a simple interface to a network operator and return information regarding which node can reach which. Thus, the only concern of network operator is to update link status without having to worry about doing those calculations themself. While, this task can be relatively easy done in our example of four nodes, in a more realistic scenario, the number of nodes can be in the order of hundreds and link status updates can be streamed into the monitoring application.\r\n+\r\n+Let's start with defining our program in the DDlog language. In our program we need to supply source node, destination node, and a link status between them. Now we are ready to define our input relation :code:`Links`. Let's create a file called :code:`t1_reachibility_monitor.dl` and add there a following line representing input relation for our reachibility monitor:\r\n+\r\n+.. code-block::\r\n+    \r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\r\n+However, for the reachibility monitor to be useful it also should provide some output and not just ingest the data. We want our program to output a list of nodes that are currently reachable based on the information in the relation :code:`Links`. Thus, let's add an output relation :code:`ConnectedNodes` and provide a rule to calculate records in this relation. To do that we are going to add few more lines to the :code:`t1_reachibility_monitor.dl` so it will looks as follows:\r\n+\r\n+.. code-block::\r\n+\r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\toutput relation ConnectedNodes(str: string, dst: string)\r\n+\r\n+\tConnectedNodes(src, dst) :- Links(src, dst, true).\r\n+\tConnectedNodes(src, dst) :- ConnectedNodes(src, intermediate_node),\r\n+\t\t\t\tLinks(intermediate_node, dst, true).\r\n+\r\n+Let's briefly discuss the rule to calculate :code:`ConnectedNodes` relation. First, we say that any directly connected nodes such that the :code:`link_status` between them is :code:`true` belong to :code:`ConnectedNodes` relation. Furthermore, any two nodes are considered connected if there is path from the source node to the destination node such that all directly connected nodes along the path are also connected. Take a minute here to realize how easy is it to write such rule in DDlog. Isn't is amazing?\r\n+\r\n+With that done, let's compile and start out program.\r\n+\r\n+.. code-block::\r\n+\r\n+\t$ ddlog -i t1_reachibility_monitor.dl\r\n+\t$ cd t1_reachibility_monitor_ddlog/ && cargo build --release\r\n+\t$ ./target/release/t1_reachibility_monitor_cli\r\n+\r\n+If we check :code:`ConnectedNodes` we will see that this relation is empty, which make sense as we haven't populated relation :code:`Links` with anything yet:\r\n+\r\n+.. code-block::\r\n+\r\n+\t>> dump ConnectedNodes;\r\n+\r\n+To exit DDlog shell press `[CTRL+d]`. If you are using `Windows Terminal` do not press `[CTRL+D]` (note capital `D`, `[CTRL+SHIFT+d]`) as it will open new tab.\r\n+\r\n+Let's fix it. We are going to insert several records into :code:`Links` relation. But first let's define a simple network topology that we are going to work through. To make our life more interesting (and just slightly more complicated) the links between nodes will not be bidirectional by default.\r\n+\r\n+.. image:: ./images/topology.jpg\r\n+\r\n+Let's start again DDlog shell and insert records to recreate the network topology above:\r\n+\r\n+.. code-block::\r\n+\r\n+\t$ ./target/release/t1_reachibility_monitor_cli\r\n+\t>> start;\r\n+\t>> insert Links(\"Menlo Park\", \"Santa Barbara\", true);\r\n+\t>> insert Links(\"Menlo Park\", \"Salt Lake City\", true);\r\n+\t>> insert Links(\"Santa Barbara\", \"Los Angeles\", true);\r\n+\t>> insert Links(\"Los Angeles\", \"Santa Barbara\", true);\r\n+\t>> insert Links(\"Los Angeles\", \"Salt Lake City\", true);\r\n+\t>> insert Links(\"Salt Lake City\", \"Los Angeles\", true);\r\n+\t>> commit;\r\n+\t>> dump ConnectedNodes;\r\n+\tConnectedNodes{.src = \"Los Angeles\", .dst = \"Los Angeles\"}\r\n+\tConnectedNodes{.src = \"Los Angeles\", .dst = \"Salt Lake City\"}\r\n+\tConnectedNodes{.src = \"Los Angeles\", .dst = \"Santa Barbara\"}\r\n+\tConnectedNodes{.src = \"Menlo Park\", .dst = \"Los Angeles\"}\r\n+\tConnectedNodes{.src = \"Menlo Park\", .dst = \"Salt Lake City\"}\r\n+\tConnectedNodes{.src = \"Menlo Park\", .dst = \"Santa Barbara\"}\r\n+\tConnectedNodes{.src = \"Salt Lake City\", .dst = \"Los Angeles\"}\r\n+\tConnectedNodes{.src = \"Salt Lake City\", .dst = \"Salt Lake City\"}\r\n+\tConnectedNodes{.src = \"Salt Lake City\", .dst = \"Santa Barbara\"}\r\n+\tConnectedNodes{.src = \"Santa Barbara\", .dst = \"Los Angeles\"}\r\n+\tConnectedNodes{.src = \"Santa Barbara\", .dst = \"Salt Lake City\"}\r\n+\tConnectedNodes{.src = \"Santa Barbara\", .dst = \"Santa Barbara\"}\r\n+\r\n+Something is off - some nodes are connected to themselves. But why this happened? If we take a closer look at our rule we can notice that this phenomenon actually make sense. For example, Santa Barbara is reachable from Santa Barbara through Los Angeles. While it is not necessarily horrible or wrong we may want to avoid it as it clutters the relation and the output. More notably, we definitely don't want the network traffic go to Santa Barbara from Santa Barbara through Los Angeles (in real world this actually may happen but this is completely different topic). Let's fix it by adding a filtering condition to the rule that disallows source and destination match each other. Now, the rules for calculating :code:`ConnectedNodes` look as below and see how simple it is to do that in DDlog (note that only second rule was modified, the first stay intact):\r", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzNDc0MQ==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540534741", "bodyText": "do you want to use src here instead of str?", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:12:00Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+********************************\r\n+WIP: How to befriend DDlog and C\r\n+********************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog__ from the official repository, which contains instructions how to install and set it up. There is also an expectation that you are familiar with DDlog syntax and commands, i.e., read the tutorial or at least skim through it.\r\n+\r\n+__\r\n+.. _DDlog DDlog repository on GitHub:\r\n+    https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog and learn how to befriend DDlog program with C program. To do that we are going to build several simple yet functional applications as it is more fun to build real programs. Furthermore, it will also demonstrate that DDlog is not limited to a particular domain, but rather can be used to solve different problems.\r\n+\r\n+Tutorial #1 - Reachibility Monitor\r\n+==================================\r\n+\r\n+In our first tutorial we are going to build a program that will store the reachibility information in the network of four nodes: Menlo Park, Santa Barbara, Los Angeles, and Salt Lake City. User will update link status between nodes through CLI and our program will calculate the rest. The purpose of this program is to provide a simple interface to a network operator and return information regarding which node can reach which. Thus, the only concern of network operator is to update link status without having to worry about doing those calculations themself. While, this task can be relatively easy done in our example of four nodes, in a more realistic scenario, the number of nodes can be in the order of hundreds and link status updates can be streamed into the monitoring application.\r\n+\r\n+Let's start with defining our program in the DDlog language. In our program we need to supply source node, destination node, and a link status between them. Now we are ready to define our input relation :code:`Links`. Let's create a file called :code:`t1_reachibility_monitor.dl` and add there a following line representing input relation for our reachibility monitor:\r\n+\r\n+.. code-block::\r\n+    \r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\r\n+However, for the reachibility monitor to be useful it also should provide some output and not just ingest the data. We want our program to output a list of nodes that are currently reachable based on the information in the relation :code:`Links`. Thus, let's add an output relation :code:`ConnectedNodes` and provide a rule to calculate records in this relation. To do that we are going to add few more lines to the :code:`t1_reachibility_monitor.dl` so it will looks as follows:\r\n+\r\n+.. code-block::\r\n+\r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\toutput relation ConnectedNodes(str: string, dst: string)\r", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzNTE5MQ==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540535191", "bodyText": "this output is correct only if you used .src for ConnectedNodes", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:12:40Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+********************************\r\n+WIP: How to befriend DDlog and C\r\n+********************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog__ from the official repository, which contains instructions how to install and set it up. There is also an expectation that you are familiar with DDlog syntax and commands, i.e., read the tutorial or at least skim through it.\r\n+\r\n+__\r\n+.. _DDlog DDlog repository on GitHub:\r\n+    https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog and learn how to befriend DDlog program with C program. To do that we are going to build several simple yet functional applications as it is more fun to build real programs. Furthermore, it will also demonstrate that DDlog is not limited to a particular domain, but rather can be used to solve different problems.\r\n+\r\n+Tutorial #1 - Reachibility Monitor\r\n+==================================\r\n+\r\n+In our first tutorial we are going to build a program that will store the reachibility information in the network of four nodes: Menlo Park, Santa Barbara, Los Angeles, and Salt Lake City. User will update link status between nodes through CLI and our program will calculate the rest. The purpose of this program is to provide a simple interface to a network operator and return information regarding which node can reach which. Thus, the only concern of network operator is to update link status without having to worry about doing those calculations themself. While, this task can be relatively easy done in our example of four nodes, in a more realistic scenario, the number of nodes can be in the order of hundreds and link status updates can be streamed into the monitoring application.\r\n+\r\n+Let's start with defining our program in the DDlog language. In our program we need to supply source node, destination node, and a link status between them. Now we are ready to define our input relation :code:`Links`. Let's create a file called :code:`t1_reachibility_monitor.dl` and add there a following line representing input relation for our reachibility monitor:\r\n+\r\n+.. code-block::\r\n+    \r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\r\n+However, for the reachibility monitor to be useful it also should provide some output and not just ingest the data. We want our program to output a list of nodes that are currently reachable based on the information in the relation :code:`Links`. Thus, let's add an output relation :code:`ConnectedNodes` and provide a rule to calculate records in this relation. To do that we are going to add few more lines to the :code:`t1_reachibility_monitor.dl` so it will looks as follows:\r\n+\r\n+.. code-block::\r\n+\r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\toutput relation ConnectedNodes(str: string, dst: string)\r\n+\r\n+\tConnectedNodes(src, dst) :- Links(src, dst, true).\r\n+\tConnectedNodes(src, dst) :- ConnectedNodes(src, intermediate_node),\r\n+\t\t\t\tLinks(intermediate_node, dst, true).\r\n+\r\n+Let's briefly discuss the rule to calculate :code:`ConnectedNodes` relation. First, we say that any directly connected nodes such that the :code:`link_status` between them is :code:`true` belong to :code:`ConnectedNodes` relation. Furthermore, any two nodes are considered connected if there is path from the source node to the destination node such that all directly connected nodes along the path are also connected. Take a minute here to realize how easy is it to write such rule in DDlog. Isn't is amazing?\r\n+\r\n+With that done, let's compile and start out program.\r\n+\r\n+.. code-block::\r\n+\r\n+\t$ ddlog -i t1_reachibility_monitor.dl\r\n+\t$ cd t1_reachibility_monitor_ddlog/ && cargo build --release\r\n+\t$ ./target/release/t1_reachibility_monitor_cli\r\n+\r\n+If we check :code:`ConnectedNodes` we will see that this relation is empty, which make sense as we haven't populated relation :code:`Links` with anything yet:\r\n+\r\n+.. code-block::\r\n+\r\n+\t>> dump ConnectedNodes;\r\n+\r\n+To exit DDlog shell press `[CTRL+d]`. If you are using `Windows Terminal` do not press `[CTRL+D]` (note capital `D`, `[CTRL+SHIFT+d]`) as it will open new tab.\r\n+\r\n+Let's fix it. We are going to insert several records into :code:`Links` relation. But first let's define a simple network topology that we are going to work through. To make our life more interesting (and just slightly more complicated) the links between nodes will not be bidirectional by default.\r\n+\r\n+.. image:: ./images/topology.jpg\r\n+\r\n+Let's start again DDlog shell and insert records to recreate the network topology above:\r\n+\r\n+.. code-block::\r\n+\r\n+\t$ ./target/release/t1_reachibility_monitor_cli\r\n+\t>> start;\r\n+\t>> insert Links(\"Menlo Park\", \"Santa Barbara\", true);\r\n+\t>> insert Links(\"Menlo Park\", \"Salt Lake City\", true);\r\n+\t>> insert Links(\"Santa Barbara\", \"Los Angeles\", true);\r\n+\t>> insert Links(\"Los Angeles\", \"Santa Barbara\", true);\r\n+\t>> insert Links(\"Los Angeles\", \"Salt Lake City\", true);\r\n+\t>> insert Links(\"Salt Lake City\", \"Los Angeles\", true);\r\n+\t>> commit;\r\n+\t>> dump ConnectedNodes;\r\n+\tConnectedNodes{.src = \"Los Angeles\", .dst = \"Los Angeles\"}\r", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzNjc0NA==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540536744", "bodyText": "src?", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:15:23Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+********************************\r\n+WIP: How to befriend DDlog and C\r\n+********************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog__ from the official repository, which contains instructions how to install and set it up. There is also an expectation that you are familiar with DDlog syntax and commands, i.e., read the tutorial or at least skim through it.\r\n+\r\n+__\r\n+.. _DDlog DDlog repository on GitHub:\r\n+    https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog and learn how to befriend DDlog program with C program. To do that we are going to build several simple yet functional applications as it is more fun to build real programs. Furthermore, it will also demonstrate that DDlog is not limited to a particular domain, but rather can be used to solve different problems.\r\n+\r\n+Tutorial #1 - Reachibility Monitor\r\n+==================================\r\n+\r\n+In our first tutorial we are going to build a program that will store the reachibility information in the network of four nodes: Menlo Park, Santa Barbara, Los Angeles, and Salt Lake City. User will update link status between nodes through CLI and our program will calculate the rest. The purpose of this program is to provide a simple interface to a network operator and return information regarding which node can reach which. Thus, the only concern of network operator is to update link status without having to worry about doing those calculations themself. While, this task can be relatively easy done in our example of four nodes, in a more realistic scenario, the number of nodes can be in the order of hundreds and link status updates can be streamed into the monitoring application.\r\n+\r\n+Let's start with defining our program in the DDlog language. In our program we need to supply source node, destination node, and a link status between them. Now we are ready to define our input relation :code:`Links`. Let's create a file called :code:`t1_reachibility_monitor.dl` and add there a following line representing input relation for our reachibility monitor:\r\n+\r\n+.. code-block::\r\n+    \r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\r\n+However, for the reachibility monitor to be useful it also should provide some output and not just ingest the data. We want our program to output a list of nodes that are currently reachable based on the information in the relation :code:`Links`. Thus, let's add an output relation :code:`ConnectedNodes` and provide a rule to calculate records in this relation. To do that we are going to add few more lines to the :code:`t1_reachibility_monitor.dl` so it will looks as follows:\r\n+\r\n+.. code-block::\r\n+\r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\toutput relation ConnectedNodes(str: string, dst: string)\r\n+\r\n+\tConnectedNodes(src, dst) :- Links(src, dst, true).\r\n+\tConnectedNodes(src, dst) :- ConnectedNodes(src, intermediate_node),\r\n+\t\t\t\tLinks(intermediate_node, dst, true).\r\n+\r\n+Let's briefly discuss the rule to calculate :code:`ConnectedNodes` relation. First, we say that any directly connected nodes such that the :code:`link_status` between them is :code:`true` belong to :code:`ConnectedNodes` relation. Furthermore, any two nodes are considered connected if there is path from the source node to the destination node such that all directly connected nodes along the path are also connected. Take a minute here to realize how easy is it to write such rule in DDlog. Isn't is amazing?\r\n+\r\n+With that done, let's compile and start out program.\r\n+\r\n+.. code-block::\r\n+\r\n+\t$ ddlog -i t1_reachibility_monitor.dl\r\n+\t$ cd t1_reachibility_monitor_ddlog/ && cargo build --release\r\n+\t$ ./target/release/t1_reachibility_monitor_cli\r\n+\r\n+If we check :code:`ConnectedNodes` we will see that this relation is empty, which make sense as we haven't populated relation :code:`Links` with anything yet:\r\n+\r\n+.. code-block::\r\n+\r\n+\t>> dump ConnectedNodes;\r\n+\r\n+To exit DDlog shell press `[CTRL+d]`. If you are using `Windows Terminal` do not press `[CTRL+D]` (note capital `D`, `[CTRL+SHIFT+d]`) as it will open new tab.\r\n+\r\n+Let's fix it. We are going to insert several records into :code:`Links` relation. But first let's define a simple network topology that we are going to work through. To make our life more interesting (and just slightly more complicated) the links between nodes will not be bidirectional by default.\r\n+\r\n+.. image:: ./images/topology.jpg\r\n+\r\n+Let's start again DDlog shell and insert records to recreate the network topology above:\r\n+\r\n+.. code-block::\r\n+\r\n+\t$ ./target/release/t1_reachibility_monitor_cli\r\n+\t>> start;\r\n+\t>> insert Links(\"Menlo Park\", \"Santa Barbara\", true);\r\n+\t>> insert Links(\"Menlo Park\", \"Salt Lake City\", true);\r\n+\t>> insert Links(\"Santa Barbara\", \"Los Angeles\", true);\r\n+\t>> insert Links(\"Los Angeles\", \"Santa Barbara\", true);\r\n+\t>> insert Links(\"Los Angeles\", \"Salt Lake City\", true);\r\n+\t>> insert Links(\"Salt Lake City\", \"Los Angeles\", true);\r\n+\t>> commit;\r\n+\t>> dump ConnectedNodes;\r\n+\tConnectedNodes{.src = \"Los Angeles\", .dst = \"Los Angeles\"}\r\n+\tConnectedNodes{.src = \"Los Angeles\", .dst = \"Salt Lake City\"}\r\n+\tConnectedNodes{.src = \"Los Angeles\", .dst = \"Santa Barbara\"}\r\n+\tConnectedNodes{.src = \"Menlo Park\", .dst = \"Los Angeles\"}\r\n+\tConnectedNodes{.src = \"Menlo Park\", .dst = \"Salt Lake City\"}\r\n+\tConnectedNodes{.src = \"Menlo Park\", .dst = \"Santa Barbara\"}\r\n+\tConnectedNodes{.src = \"Salt Lake City\", .dst = \"Los Angeles\"}\r\n+\tConnectedNodes{.src = \"Salt Lake City\", .dst = \"Salt Lake City\"}\r\n+\tConnectedNodes{.src = \"Salt Lake City\", .dst = \"Santa Barbara\"}\r\n+\tConnectedNodes{.src = \"Santa Barbara\", .dst = \"Los Angeles\"}\r\n+\tConnectedNodes{.src = \"Santa Barbara\", .dst = \"Salt Lake City\"}\r\n+\tConnectedNodes{.src = \"Santa Barbara\", .dst = \"Santa Barbara\"}\r\n+\r\n+Something is off - some nodes are connected to themselves. But why this happened? If we take a closer look at our rule we can notice that this phenomenon actually make sense. For example, Santa Barbara is reachable from Santa Barbara through Los Angeles. While it is not necessarily horrible or wrong we may want to avoid it as it clutters the relation and the output. More notably, we definitely don't want the network traffic go to Santa Barbara from Santa Barbara through Los Angeles (in real world this actually may happen but this is completely different topic). Let's fix it by adding a filtering condition to the rule that disallows source and destination match each other. Now, the rules for calculating :code:`ConnectedNodes` look as below and see how simple it is to do that in DDlog (note that only second rule was modified, the first stay intact):\r\n+\r\n+.. code-block::\r\n+\r\n+\tConnectedNodes(src, dst) :- Links(src, dst, true).\r\n+\tConnectedNodes(src, dst) :- ConnectedNodes(src, intermediate_node),\r\n+\t\t\t\tLinks(intermediate_node, dst, true), (src != dst).\r\n+\r\n+As we have changed the DDlog program we need to recompile it. However, it would be annoying to run commands that populate :code:`Links` relation every time we change our DDlog program. To resolve this nuisance we can embed some records into the DDlog program itself to serve as ground truth or initial state. Let's do all of that.\r\n+\r\n+.. code-block::\r\n+\r\n+\t$ cd ../ && cat t1_reachibility_monitor.dl\r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\toutput relation ConnectedNodes(str: string, dst: string)\r", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzNzM1NQ==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540537355", "bodyText": "\"as we expected?\"", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:16:27Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+********************************\r\n+WIP: How to befriend DDlog and C\r\n+********************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog__ from the official repository, which contains instructions how to install and set it up. There is also an expectation that you are familiar with DDlog syntax and commands, i.e., read the tutorial or at least skim through it.\r\n+\r\n+__\r\n+.. _DDlog DDlog repository on GitHub:\r\n+    https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog and learn how to befriend DDlog program with C program. To do that we are going to build several simple yet functional applications as it is more fun to build real programs. Furthermore, it will also demonstrate that DDlog is not limited to a particular domain, but rather can be used to solve different problems.\r\n+\r\n+Tutorial #1 - Reachibility Monitor\r\n+==================================\r\n+\r\n+In our first tutorial we are going to build a program that will store the reachibility information in the network of four nodes: Menlo Park, Santa Barbara, Los Angeles, and Salt Lake City. User will update link status between nodes through CLI and our program will calculate the rest. The purpose of this program is to provide a simple interface to a network operator and return information regarding which node can reach which. Thus, the only concern of network operator is to update link status without having to worry about doing those calculations themself. While, this task can be relatively easy done in our example of four nodes, in a more realistic scenario, the number of nodes can be in the order of hundreds and link status updates can be streamed into the monitoring application.\r\n+\r\n+Let's start with defining our program in the DDlog language. In our program we need to supply source node, destination node, and a link status between them. Now we are ready to define our input relation :code:`Links`. Let's create a file called :code:`t1_reachibility_monitor.dl` and add there a following line representing input relation for our reachibility monitor:\r\n+\r\n+.. code-block::\r\n+    \r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\r\n+However, for the reachibility monitor to be useful it also should provide some output and not just ingest the data. We want our program to output a list of nodes that are currently reachable based on the information in the relation :code:`Links`. Thus, let's add an output relation :code:`ConnectedNodes` and provide a rule to calculate records in this relation. To do that we are going to add few more lines to the :code:`t1_reachibility_monitor.dl` so it will looks as follows:\r\n+\r\n+.. code-block::\r\n+\r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\toutput relation ConnectedNodes(str: string, dst: string)\r\n+\r\n+\tConnectedNodes(src, dst) :- Links(src, dst, true).\r\n+\tConnectedNodes(src, dst) :- ConnectedNodes(src, intermediate_node),\r\n+\t\t\t\tLinks(intermediate_node, dst, true).\r\n+\r\n+Let's briefly discuss the rule to calculate :code:`ConnectedNodes` relation. First, we say that any directly connected nodes such that the :code:`link_status` between them is :code:`true` belong to :code:`ConnectedNodes` relation. Furthermore, any two nodes are considered connected if there is path from the source node to the destination node such that all directly connected nodes along the path are also connected. Take a minute here to realize how easy is it to write such rule in DDlog. Isn't is amazing?\r\n+\r\n+With that done, let's compile and start out program.\r\n+\r\n+.. code-block::\r\n+\r\n+\t$ ddlog -i t1_reachibility_monitor.dl\r\n+\t$ cd t1_reachibility_monitor_ddlog/ && cargo build --release\r\n+\t$ ./target/release/t1_reachibility_monitor_cli\r\n+\r\n+If we check :code:`ConnectedNodes` we will see that this relation is empty, which make sense as we haven't populated relation :code:`Links` with anything yet:\r\n+\r\n+.. code-block::\r\n+\r\n+\t>> dump ConnectedNodes;\r\n+\r\n+To exit DDlog shell press `[CTRL+d]`. If you are using `Windows Terminal` do not press `[CTRL+D]` (note capital `D`, `[CTRL+SHIFT+d]`) as it will open new tab.\r\n+\r\n+Let's fix it. We are going to insert several records into :code:`Links` relation. But first let's define a simple network topology that we are going to work through. To make our life more interesting (and just slightly more complicated) the links between nodes will not be bidirectional by default.\r\n+\r\n+.. image:: ./images/topology.jpg\r\n+\r\n+Let's start again DDlog shell and insert records to recreate the network topology above:\r\n+\r\n+.. code-block::\r\n+\r\n+\t$ ./target/release/t1_reachibility_monitor_cli\r\n+\t>> start;\r\n+\t>> insert Links(\"Menlo Park\", \"Santa Barbara\", true);\r\n+\t>> insert Links(\"Menlo Park\", \"Salt Lake City\", true);\r\n+\t>> insert Links(\"Santa Barbara\", \"Los Angeles\", true);\r\n+\t>> insert Links(\"Los Angeles\", \"Santa Barbara\", true);\r\n+\t>> insert Links(\"Los Angeles\", \"Salt Lake City\", true);\r\n+\t>> insert Links(\"Salt Lake City\", \"Los Angeles\", true);\r\n+\t>> commit;\r\n+\t>> dump ConnectedNodes;\r\n+\tConnectedNodes{.src = \"Los Angeles\", .dst = \"Los Angeles\"}\r\n+\tConnectedNodes{.src = \"Los Angeles\", .dst = \"Salt Lake City\"}\r\n+\tConnectedNodes{.src = \"Los Angeles\", .dst = \"Santa Barbara\"}\r\n+\tConnectedNodes{.src = \"Menlo Park\", .dst = \"Los Angeles\"}\r\n+\tConnectedNodes{.src = \"Menlo Park\", .dst = \"Salt Lake City\"}\r\n+\tConnectedNodes{.src = \"Menlo Park\", .dst = \"Santa Barbara\"}\r\n+\tConnectedNodes{.src = \"Salt Lake City\", .dst = \"Los Angeles\"}\r\n+\tConnectedNodes{.src = \"Salt Lake City\", .dst = \"Salt Lake City\"}\r\n+\tConnectedNodes{.src = \"Salt Lake City\", .dst = \"Santa Barbara\"}\r\n+\tConnectedNodes{.src = \"Santa Barbara\", .dst = \"Los Angeles\"}\r\n+\tConnectedNodes{.src = \"Santa Barbara\", .dst = \"Salt Lake City\"}\r\n+\tConnectedNodes{.src = \"Santa Barbara\", .dst = \"Santa Barbara\"}\r\n+\r\n+Something is off - some nodes are connected to themselves. But why this happened? If we take a closer look at our rule we can notice that this phenomenon actually make sense. For example, Santa Barbara is reachable from Santa Barbara through Los Angeles. While it is not necessarily horrible or wrong we may want to avoid it as it clutters the relation and the output. More notably, we definitely don't want the network traffic go to Santa Barbara from Santa Barbara through Los Angeles (in real world this actually may happen but this is completely different topic). Let's fix it by adding a filtering condition to the rule that disallows source and destination match each other. Now, the rules for calculating :code:`ConnectedNodes` look as below and see how simple it is to do that in DDlog (note that only second rule was modified, the first stay intact):\r\n+\r\n+.. code-block::\r\n+\r\n+\tConnectedNodes(src, dst) :- Links(src, dst, true).\r\n+\tConnectedNodes(src, dst) :- ConnectedNodes(src, intermediate_node),\r\n+\t\t\t\tLinks(intermediate_node, dst, true), (src != dst).\r\n+\r\n+As we have changed the DDlog program we need to recompile it. However, it would be annoying to run commands that populate :code:`Links` relation every time we change our DDlog program. To resolve this nuisance we can embed some records into the DDlog program itself to serve as ground truth or initial state. Let's do all of that.\r\n+\r\n+.. code-block::\r\n+\r\n+\t$ cd ../ && cat t1_reachibility_monitor.dl\r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\toutput relation ConnectedNodes(str: string, dst: string)\r\n+\r\n+\tConnectedNodes(src, dst) :- Links(src, dst, true).\r\n+\tConnectedNodes(src, dst) :- ConnectedNodes(src, intermediate_node),\r\n+\t\t\t\tLinks(intermediate_node, dst, true), (src != dst).\r\n+\t\r\n+\tLinks(\"Menlo Park\", \"Santa Barbara\", true).\r\n+\tLinks(\"Menlo Park\", \"Salt Lake City\", true).\r\n+\tLinks(\"Santa Barbara\", \"Los Angeles\", true).\r\n+\tLinks(\"Los Angeles\", \"Santa Barbara\", true).\r\n+\tLinks(\"Los Angeles\", \"Salt Lake City\", true).\r\n+\tLinks(\"Salt Lake City\", \"Los Angeles\", true).\r\n+\r\n+\t$ ddlog -i t1_reachibility_monitor.dl\r\n+\t$ cd t1_reachibility_monitor_ddlog/ && cargo build --release\r\n+\t$ ./target/release/t1_reachibility_monitor_cli\r\n+\t<clip>\r\n+\t>> dump ConnectedNodes;\r\n+\tConnectedNodes{.src = \"Los Angeles\", .dst = \"Salt Lake City\"}\r\n+\tConnectedNodes{.src = \"Los Angeles\", .dst = \"Santa Barbara\"}\r\n+\tConnectedNodes{.src = \"Menlo Park\", .dst = \"Los Angeles\"}\r\n+\tConnectedNodes{.src = \"Menlo Park\", .dst = \"Salt Lake City\"}\r\n+\tConnectedNodes{.src = \"Menlo Park\", .dst = \"Santa Barbara\"}\r\n+\tConnectedNodes{.src = \"Salt Lake City\", .dst = \"Los Angeles\"}\r\n+\tConnectedNodes{.src = \"Salt Lake City\", .dst = \"Santa Barbara\"}\r\n+\tConnectedNodes{.src = \"Santa Barbara\", .dst = \"Los Angeles\"}\r\n+\tConnectedNodes{.src = \"Santa Barbara\", .dst = \"Salt Lake City\"}\r\n+\r\n+Perfect! Now it looks exactly as what we expected! This is a good time to start doing what this tutorial promised and start writing some C code! We are going to start with something simple yet important. Our initial C program will connect with DDlog program, insert one additional record to :code:`Links` relation, and print the content of :code:`ConnectedNodes` relation. Let's create :code:`reachibility_monitor.c` next to our DDlog program's code. The code is available in the provided :code:`reachibility_monitor_p1.c` file. The further discussion will refer to specific lines in that code.\r", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzODI1OA==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540538258", "bodyText": "Before doing that do you want to show the incremental nature of DDlog by changing a link status in the CLI?", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:17:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzNzM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzODgxNQ==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540538815", "bodyText": "this file also has a mix of spaces and tabs", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:19:07Z", "path": "doc/tutorial/c_tutorial/reachibility_monitor_p1.c", "diffHunk": "@@ -0,0 +1,119 @@\n+#include <stdio.h>", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDUzOTk3NQ==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540539975", "bodyText": "typo: reachability. This has to be fixed everywhere.", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:21:19Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+********************************\r\n+WIP: How to befriend DDlog and C\r\n+********************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog__ from the official repository, which contains instructions how to install and set it up. There is also an expectation that you are familiar with DDlog syntax and commands, i.e., read the tutorial or at least skim through it.\r\n+\r\n+__\r\n+.. _DDlog DDlog repository on GitHub:\r\n+    https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog and learn how to befriend DDlog program with C program. To do that we are going to build several simple yet functional applications as it is more fun to build real programs. Furthermore, it will also demonstrate that DDlog is not limited to a particular domain, but rather can be used to solve different problems.\r\n+\r\n+Tutorial #1 - Reachibility Monitor\r", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU0MDkwNg==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540540906", "bodyText": "This is generated by the compiler in the _ddlog directory.", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:23:02Z", "path": "doc/tutorial/c_tutorial/reachibility_monitor_p1.c", "diffHunk": "@@ -0,0 +1,119 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdbool.h>\n+\n+#include <string.h> // required for strncmp()\n+#include <errno.h>  // required for error code identifiers\n+\n+#include \"ddlog.h\"", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU1MjQ4OQ==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540552489", "bodyText": "I would point at it explicitly, it has lots of comments and it really defines the API between DDlog and C.", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:44:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU0MDkwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU0MTk4OQ==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540541989", "bodyText": "is this supposed to be before the concludes?\nYou have to explain a lot of stuff about the code: ddog_record, the callback api, the notion of transaction (you could explain transactions even earlier in the cli section).", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:25:11Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,148 @@\n+********************************\r\n+WIP: How to befriend DDlog and C\r\n+********************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog__ from the official repository, which contains instructions how to install and set it up. There is also an expectation that you are familiar with DDlog syntax and commands, i.e., read the tutorial or at least skim through it.\r\n+\r\n+__\r\n+.. _DDlog DDlog repository on GitHub:\r\n+    https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog and learn how to befriend DDlog program with C program. To do that we are going to build several simple yet functional applications as it is more fun to build real programs. Furthermore, it will also demonstrate that DDlog is not limited to a particular domain, but rather can be used to solve different problems.\r\n+\r\n+Tutorial #1 - Reachibility Monitor\r\n+==================================\r\n+\r\n+In our first tutorial we are going to build a program that will store the reachibility information in the network of four nodes: Menlo Park, Santa Barbara, Los Angeles, and Salt Lake City. User will update link status between nodes through CLI and our program will calculate the rest. The purpose of this program is to provide a simple interface to a network operator and return information regarding which node can reach which. Thus, the only concern of network operator is to update link status without having to worry about doing those calculations themself. While, this task can be relatively easy done in our example of four nodes, in a more realistic scenario, the number of nodes can be in the order of hundreds and link status updates can be streamed into the monitoring application.\r\n+\r\n+Let's start with defining our program in the DDlog language. In our program we need to supply source node, destination node, and a link status between them. Now we are ready to define our input relation :code:`Links`. Let's create a file called :code:`t1_reachibility_monitor.dl` and add there a following line representing input relation for our reachibility monitor:\r\n+\r\n+.. code-block::\r\n+    \r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\r\n+However, for the reachibility monitor to be useful it also should provide some output and not just ingest the data. We want our program to output a list of nodes that are currently reachable based on the information in the relation :code:`Links`. Thus, let's add an output relation :code:`ConnectedNodes` and provide a rule to calculate records in this relation. To do that we are going to add few more lines to the :code:`t1_reachibility_monitor.dl` so it will looks as follows:\r\n+\r\n+.. code-block::\r\n+\r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\toutput relation ConnectedNodes(str: string, dst: string)\r\n+\r\n+\tConnectedNodes(src, dst) :- Links(src, dst, true).\r\n+\tConnectedNodes(src, dst) :- ConnectedNodes(src, intermediate_node),\r\n+\t\t\t\tLinks(intermediate_node, dst, true).\r\n+\r\n+Let's briefly discuss the rule to calculate :code:`ConnectedNodes` relation. First, we say that any directly connected nodes such that the :code:`link_status` between them is :code:`true` belong to :code:`ConnectedNodes` relation. Furthermore, any two nodes are considered connected if there is path from the source node to the destination node such that all directly connected nodes along the path are also connected. Take a minute here to realize how easy is it to write such rule in DDlog. Isn't is amazing?\r\n+\r\n+With that done, let's compile and start out program.\r\n+\r\n+.. code-block::\r\n+\r\n+\t$ ddlog -i t1_reachibility_monitor.dl\r\n+\t$ cd t1_reachibility_monitor_ddlog/ && cargo build --release\r\n+\t$ ./target/release/t1_reachibility_monitor_cli\r\n+\r\n+If we check :code:`ConnectedNodes` we will see that this relation is empty, which make sense as we haven't populated relation :code:`Links` with anything yet:\r\n+\r\n+.. code-block::\r\n+\r\n+\t>> dump ConnectedNodes;\r\n+\r\n+To exit DDlog shell press `[CTRL+d]`. If you are using `Windows Terminal` do not press `[CTRL+D]` (note capital `D`, `[CTRL+SHIFT+d]`) as it will open new tab.\r\n+\r\n+Let's fix it. We are going to insert several records into :code:`Links` relation. But first let's define a simple network topology that we are going to work through. To make our life more interesting (and just slightly more complicated) the links between nodes will not be bidirectional by default.\r\n+\r\n+.. image:: ./images/topology.jpg\r\n+\r\n+Let's start again DDlog shell and insert records to recreate the network topology above:\r\n+\r\n+.. code-block::\r\n+\r\n+\t$ ./target/release/t1_reachibility_monitor_cli\r\n+\t>> start;\r\n+\t>> insert Links(\"Menlo Park\", \"Santa Barbara\", true);\r\n+\t>> insert Links(\"Menlo Park\", \"Salt Lake City\", true);\r\n+\t>> insert Links(\"Santa Barbara\", \"Los Angeles\", true);\r\n+\t>> insert Links(\"Los Angeles\", \"Santa Barbara\", true);\r\n+\t>> insert Links(\"Los Angeles\", \"Salt Lake City\", true);\r\n+\t>> insert Links(\"Salt Lake City\", \"Los Angeles\", true);\r\n+\t>> commit;\r\n+\t>> dump ConnectedNodes;\r\n+\tConnectedNodes{.src = \"Los Angeles\", .dst = \"Los Angeles\"}\r\n+\tConnectedNodes{.src = \"Los Angeles\", .dst = \"Salt Lake City\"}\r\n+\tConnectedNodes{.src = \"Los Angeles\", .dst = \"Santa Barbara\"}\r\n+\tConnectedNodes{.src = \"Menlo Park\", .dst = \"Los Angeles\"}\r\n+\tConnectedNodes{.src = \"Menlo Park\", .dst = \"Salt Lake City\"}\r\n+\tConnectedNodes{.src = \"Menlo Park\", .dst = \"Santa Barbara\"}\r\n+\tConnectedNodes{.src = \"Salt Lake City\", .dst = \"Los Angeles\"}\r\n+\tConnectedNodes{.src = \"Salt Lake City\", .dst = \"Salt Lake City\"}\r\n+\tConnectedNodes{.src = \"Salt Lake City\", .dst = \"Santa Barbara\"}\r\n+\tConnectedNodes{.src = \"Santa Barbara\", .dst = \"Los Angeles\"}\r\n+\tConnectedNodes{.src = \"Santa Barbara\", .dst = \"Salt Lake City\"}\r\n+\tConnectedNodes{.src = \"Santa Barbara\", .dst = \"Santa Barbara\"}\r\n+\r\n+Something is off - some nodes are connected to themselves. But why this happened? If we take a closer look at our rule we can notice that this phenomenon actually make sense. For example, Santa Barbara is reachable from Santa Barbara through Los Angeles. While it is not necessarily horrible or wrong we may want to avoid it as it clutters the relation and the output. More notably, we definitely don't want the network traffic go to Santa Barbara from Santa Barbara through Los Angeles (in real world this actually may happen but this is completely different topic). Let's fix it by adding a filtering condition to the rule that disallows source and destination match each other. Now, the rules for calculating :code:`ConnectedNodes` look as below and see how simple it is to do that in DDlog (note that only second rule was modified, the first stay intact):\r\n+\r\n+.. code-block::\r\n+\r\n+\tConnectedNodes(src, dst) :- Links(src, dst, true).\r\n+\tConnectedNodes(src, dst) :- ConnectedNodes(src, intermediate_node),\r\n+\t\t\t\tLinks(intermediate_node, dst, true), (src != dst).\r\n+\r\n+As we have changed the DDlog program we need to recompile it. However, it would be annoying to run commands that populate :code:`Links` relation every time we change our DDlog program. To resolve this nuisance we can embed some records into the DDlog program itself to serve as ground truth or initial state. Let's do all of that.\r\n+\r\n+.. code-block::\r\n+\r\n+\t$ cd ../ && cat t1_reachibility_monitor.dl\r\n+\tinput relation Links(src: string, dst: string, link_status: bool)\r\n+\toutput relation ConnectedNodes(str: string, dst: string)\r\n+\r\n+\tConnectedNodes(src, dst) :- Links(src, dst, true).\r\n+\tConnectedNodes(src, dst) :- ConnectedNodes(src, intermediate_node),\r\n+\t\t\t\tLinks(intermediate_node, dst, true), (src != dst).\r\n+\t\r\n+\tLinks(\"Menlo Park\", \"Santa Barbara\", true).\r\n+\tLinks(\"Menlo Park\", \"Salt Lake City\", true).\r\n+\tLinks(\"Santa Barbara\", \"Los Angeles\", true).\r\n+\tLinks(\"Los Angeles\", \"Santa Barbara\", true).\r\n+\tLinks(\"Los Angeles\", \"Salt Lake City\", true).\r\n+\tLinks(\"Salt Lake City\", \"Los Angeles\", true).\r\n+\r\n+\t$ ddlog -i t1_reachibility_monitor.dl\r\n+\t$ cd t1_reachibility_monitor_ddlog/ && cargo build --release\r\n+\t$ ./target/release/t1_reachibility_monitor_cli\r\n+\t<clip>\r\n+\t>> dump ConnectedNodes;\r\n+\tConnectedNodes{.src = \"Los Angeles\", .dst = \"Salt Lake City\"}\r\n+\tConnectedNodes{.src = \"Los Angeles\", .dst = \"Santa Barbara\"}\r\n+\tConnectedNodes{.src = \"Menlo Park\", .dst = \"Los Angeles\"}\r\n+\tConnectedNodes{.src = \"Menlo Park\", .dst = \"Salt Lake City\"}\r\n+\tConnectedNodes{.src = \"Menlo Park\", .dst = \"Santa Barbara\"}\r\n+\tConnectedNodes{.src = \"Salt Lake City\", .dst = \"Los Angeles\"}\r\n+\tConnectedNodes{.src = \"Salt Lake City\", .dst = \"Santa Barbara\"}\r\n+\tConnectedNodes{.src = \"Santa Barbara\", .dst = \"Los Angeles\"}\r\n+\tConnectedNodes{.src = \"Santa Barbara\", .dst = \"Salt Lake City\"}\r\n+\r\n+Perfect! Now it looks exactly as what we expected! This is a good time to start doing what this tutorial promised and start writing some C code! We are going to start with something simple yet important. Our initial C program will connect with DDlog program, insert one additional record to :code:`Links` relation, and print the content of :code:`ConnectedNodes` relation. Let's create :code:`reachibility_monitor.c` next to our DDlog program's code. The code is available in the provided :code:`reachibility_monitor_p1.c` file. The further discussion will refer to specific lines in that code.\r\n+\r\n+Let's compile the code first and then delve into discussion of the code and compilation.\r\n+\r\n+.. code-block::\r\n+\r\n+\tgcc reachibility_monitor.c t1_reachibility_monitor_ddlog/target/release/libt1_reachibility_monitor_ddlog.a -It1_reachibility_monitor_ddlog/ -lpthread -ldl -lm\r\n+\r\n+\r\n+This concludes the first part of this tutorial. In the next part we are going to modify our program to allow for not only execution of a single command but also being to update existing records using primary key, insert multiple records in a single transaction, and use the `delta` feature of DDlog for a convenient tracking of changes in the output relations.\r\n+\r\n+* add the discussion of the code\r", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU0MjczNQ==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540542735", "bodyText": "you have to call ddlog_string_free(record_str);", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:26:41Z", "path": "doc/tutorial/c_tutorial/reachibility_monitor_p1.c", "diffHunk": "@@ -0,0 +1,119 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdbool.h>\n+\n+#include <string.h> // required for strncmp()\n+#include <errno.h>  // required for error code identifiers\n+\n+#include \"ddlog.h\"\n+\n+bool print_records_callback(uintptr_t arg, const ddlog_record *rec, ssize_t weight) {\n+    if (rec == NULL) {\n+        return false;\n+    }\n+\n+    char* record_str = ddlog_dump_record(rec);\n+    if (record_str == NULL) {\n+        fprintf(stderr, \"failed to dump record\\n\");\n+        exit(EXIT_FAILURE);\n+    }\n+    printf(\"Record: %s\\n\", record_str);\n+", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU0NjIwOQ==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540546209", "bodyText": "don't you have to reset n to 0?", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:33:15Z", "path": "doc/tutorial/c_tutorial/reachibility_monitor_p1.c", "diffHunk": "@@ -0,0 +1,119 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdbool.h>\n+\n+#include <string.h> // required for strncmp()\n+#include <errno.h>  // required for error code identifiers\n+\n+#include \"ddlog.h\"\n+\n+bool print_records_callback(uintptr_t arg, const ddlog_record *rec, ssize_t weight) {\n+    if (rec == NULL) {\n+        return false;\n+    }\n+\n+    char* record_str = ddlog_dump_record(rec);\n+    if (record_str == NULL) {\n+        fprintf(stderr, \"failed to dump record\\n\");\n+        exit(EXIT_FAILURE);\n+    }\n+    printf(\"Record: %s\\n\", record_str);\n+\n+    return true;\n+}\n+\n+int main(int args, char **argv)\n+{\n+    // Start the DDlog program and connect to it\n+\tddlog_prog prog = ddlog_run(1, true, NULL, 0, NULL, NULL);\n+\tif (prog == NULL) {\n+\t\tfprintf(stderr, \"failed to initialize DDlog program\\n\");\n+\t\treturn EXIT_FAILURE;\n+\t};\n+\n+    // Print IDs of tables corresponding to `Links` and `ConnectedNodes` relations\n+    printf(\"Links table id: %lu\\n\", ddlog_get_table_id(\"Links\"));\n+    printf(\"ConnectedNodes table id: %lu\\n\", ddlog_get_table_id(\"ConnectedNodes\"));\n+\n+    char *src_line_ptr = NULL;\n+    char *dst_line_ptr = NULL;\n+    char *link_status_line_ptr = NULL;\n+    size_t n = 0;\n+    bool link_status = false;\n+\n+    // Getting new record values from standard input\n+    printf(\"Please enter source name > \");\n+    if (getline(&src_line_ptr, &n, stdin) < 0) {\n+        return -EINVAL;\n+    }\n+    printf(\"Please enter destination name > \");\n+    if (getline(&dst_line_ptr, &n, stdin) < 0) {", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU1MDUzNQ==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540550535", "bodyText": "You probably don't need this one, you can just use &cmd.", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:40:33Z", "path": "doc/tutorial/c_tutorial/reachibility_monitor_p1.c", "diffHunk": "@@ -0,0 +1,119 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdbool.h>\n+\n+#include <string.h> // required for strncmp()\n+#include <errno.h>  // required for error code identifiers\n+\n+#include \"ddlog.h\"\n+\n+bool print_records_callback(uintptr_t arg, const ddlog_record *rec, ssize_t weight) {\n+    if (rec == NULL) {\n+        return false;\n+    }\n+\n+    char* record_str = ddlog_dump_record(rec);\n+    if (record_str == NULL) {\n+        fprintf(stderr, \"failed to dump record\\n\");\n+        exit(EXIT_FAILURE);\n+    }\n+    printf(\"Record: %s\\n\", record_str);\n+\n+    return true;\n+}\n+\n+int main(int args, char **argv)\n+{\n+    // Start the DDlog program and connect to it\n+\tddlog_prog prog = ddlog_run(1, true, NULL, 0, NULL, NULL);\n+\tif (prog == NULL) {\n+\t\tfprintf(stderr, \"failed to initialize DDlog program\\n\");\n+\t\treturn EXIT_FAILURE;\n+\t};\n+\n+    // Print IDs of tables corresponding to `Links` and `ConnectedNodes` relations\n+    printf(\"Links table id: %lu\\n\", ddlog_get_table_id(\"Links\"));\n+    printf(\"ConnectedNodes table id: %lu\\n\", ddlog_get_table_id(\"ConnectedNodes\"));\n+\n+    char *src_line_ptr = NULL;\n+    char *dst_line_ptr = NULL;\n+    char *link_status_line_ptr = NULL;\n+    size_t n = 0;\n+    bool link_status = false;\n+\n+    // Getting new record values from standard input\n+    printf(\"Please enter source name > \");\n+    if (getline(&src_line_ptr, &n, stdin) < 0) {\n+        return -EINVAL;\n+    }\n+    printf(\"Please enter destination name > \");\n+    if (getline(&dst_line_ptr, &n, stdin) < 0) {\n+        return -EINVAL;\n+    }\n+    printf(\"Please enter the link status between source and destination > \");\n+    if (getline(&link_status_line_ptr, &n, stdin) < 0) {\n+        return -EINVAL;\n+    }\n+\n+    // Trimming newline characters\n+    src_line_ptr[strlen(src_line_ptr) - 1] = '\\0';\n+    dst_line_ptr[strlen(dst_line_ptr) - 1] = '\\0';\n+    // Parsing value for the link status\n+    link_status = (strncmp(\"true\", link_status_line_ptr, 4) == 0) ? true : false;\n+\n+    // Creating record values in DDlog format\n+    ddlog_record* src = ddlog_string(src_line_ptr);\n+    ddlog_record* dst = ddlog_string(dst_line_ptr);\n+    ddlog_record* lstatus = ddlog_bool(link_status);\n+\n+    // Placing new record values in one struct to become a single record\n+    ddlog_record *struct_args[3];\n+    struct_args[0] = src;\n+    struct_args[1] = dst;\n+    struct_args[2] = lstatus;\n+    ddlog_record* new_record = ddlog_struct(\"Links\", struct_args, 3);\n+\n+    printf(\"Inserting the following record: %s\\n\", ddlog_dump_record(new_record));\n+\n+    // Start transaction\n+    if (ddlog_transaction_start(prog) < 0) {\n+        fprintf(stderr, \"failed to start transaction\\n\");\n+        return EXIT_FAILURE;\n+    };\n+\n+    // apply updates\n+    ddlog_cmd *cmds[1];", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU1MTY5MQ==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540551691", "bodyText": "why is the id 0 hardwired here?", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:42:48Z", "path": "doc/tutorial/c_tutorial/reachibility_monitor_p1.c", "diffHunk": "@@ -0,0 +1,119 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdbool.h>\n+\n+#include <string.h> // required for strncmp()\n+#include <errno.h>  // required for error code identifiers\n+\n+#include \"ddlog.h\"\n+\n+bool print_records_callback(uintptr_t arg, const ddlog_record *rec, ssize_t weight) {\n+    if (rec == NULL) {\n+        return false;\n+    }\n+\n+    char* record_str = ddlog_dump_record(rec);\n+    if (record_str == NULL) {\n+        fprintf(stderr, \"failed to dump record\\n\");\n+        exit(EXIT_FAILURE);\n+    }\n+    printf(\"Record: %s\\n\", record_str);\n+\n+    return true;\n+}\n+\n+int main(int args, char **argv)\n+{\n+    // Start the DDlog program and connect to it\n+\tddlog_prog prog = ddlog_run(1, true, NULL, 0, NULL, NULL);\n+\tif (prog == NULL) {\n+\t\tfprintf(stderr, \"failed to initialize DDlog program\\n\");\n+\t\treturn EXIT_FAILURE;\n+\t};\n+\n+    // Print IDs of tables corresponding to `Links` and `ConnectedNodes` relations\n+    printf(\"Links table id: %lu\\n\", ddlog_get_table_id(\"Links\"));\n+    printf(\"ConnectedNodes table id: %lu\\n\", ddlog_get_table_id(\"ConnectedNodes\"));\n+\n+    char *src_line_ptr = NULL;\n+    char *dst_line_ptr = NULL;\n+    char *link_status_line_ptr = NULL;\n+    size_t n = 0;\n+    bool link_status = false;\n+\n+    // Getting new record values from standard input\n+    printf(\"Please enter source name > \");\n+    if (getline(&src_line_ptr, &n, stdin) < 0) {\n+        return -EINVAL;\n+    }\n+    printf(\"Please enter destination name > \");\n+    if (getline(&dst_line_ptr, &n, stdin) < 0) {\n+        return -EINVAL;\n+    }\n+    printf(\"Please enter the link status between source and destination > \");\n+    if (getline(&link_status_line_ptr, &n, stdin) < 0) {\n+        return -EINVAL;\n+    }\n+\n+    // Trimming newline characters\n+    src_line_ptr[strlen(src_line_ptr) - 1] = '\\0';\n+    dst_line_ptr[strlen(dst_line_ptr) - 1] = '\\0';\n+    // Parsing value for the link status\n+    link_status = (strncmp(\"true\", link_status_line_ptr, 4) == 0) ? true : false;\n+\n+    // Creating record values in DDlog format\n+    ddlog_record* src = ddlog_string(src_line_ptr);\n+    ddlog_record* dst = ddlog_string(dst_line_ptr);\n+    ddlog_record* lstatus = ddlog_bool(link_status);\n+\n+    // Placing new record values in one struct to become a single record\n+    ddlog_record *struct_args[3];\n+    struct_args[0] = src;\n+    struct_args[1] = dst;\n+    struct_args[2] = lstatus;\n+    ddlog_record* new_record = ddlog_struct(\"Links\", struct_args, 3);\n+\n+    printf(\"Inserting the following record: %s\\n\", ddlog_dump_record(new_record));\n+\n+    // Start transaction\n+    if (ddlog_transaction_start(prog) < 0) {\n+        fprintf(stderr, \"failed to start transaction\\n\");\n+        return EXIT_FAILURE;\n+    };\n+\n+    // apply updates\n+    ddlog_cmd *cmds[1];\n+    ddlog_cmd* cmd = ddlog_insert_cmd(1, new_record);\n+    cmds[0] = cmd;\n+    if (cmd == NULL) {\n+        fprintf(stderr, \"failed to create insert command\\n\");\n+        return EXIT_FAILURE;\n+    }\n+    if (ddlog_apply_updates(prog, cmds, 1) < 0) {\n+        fprintf(stderr, \"failed to apply updates\\n\");\n+        return EXIT_FAILURE;\n+    };\n+    printf(\"Applied update.\\n\");\n+\n+    // Free'ing memory\n+    free(src_line_ptr);\n+    free(dst_line_ptr);\n+    free(link_status_line_ptr);\n+\n+    // Commit transaction\n+    if (ddlog_transaction_commit(prog) < 0) {\n+        fprintf(stderr, \"failed to commit transaction\\n\");\n+        return EXIT_FAILURE;\n+    };\n+\n+    // Printing records in the `ConnectedNodes` relation\n+    ddlog_dump_table(prog, 0, &print_records_callback, 1);", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU1MTg3Nw==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540551877", "bodyText": "why is the last argument 1? it is a pointer...", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:43:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU1MTY5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU1MjE1NA==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540552154", "bodyText": "you probably want to show something about the weight too.", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:43:51Z", "path": "doc/tutorial/c_tutorial/reachibility_monitor_p1.c", "diffHunk": "@@ -0,0 +1,119 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdbool.h>\n+\n+#include <string.h> // required for strncmp()\n+#include <errno.h>  // required for error code identifiers\n+\n+#include \"ddlog.h\"\n+\n+bool print_records_callback(uintptr_t arg, const ddlog_record *rec, ssize_t weight) {\n+    if (rec == NULL) {\n+        return false;\n+    }\n+\n+    char* record_str = ddlog_dump_record(rec);\n+    if (record_str == NULL) {\n+        fprintf(stderr, \"failed to dump record\\n\");\n+        exit(EXIT_FAILURE);\n+    }\n+    printf(\"Record: %s\\n\", record_str);", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU1MzQwMA==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540553400", "bodyText": "you may want to point out that the records do not have to be deleted: they will be consumed by the command.", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:46:13Z", "path": "doc/tutorial/c_tutorial/reachibility_monitor_p1.c", "diffHunk": "@@ -0,0 +1,119 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdbool.h>\n+\n+#include <string.h> // required for strncmp()\n+#include <errno.h>  // required for error code identifiers\n+\n+#include \"ddlog.h\"\n+\n+bool print_records_callback(uintptr_t arg, const ddlog_record *rec, ssize_t weight) {\n+    if (rec == NULL) {\n+        return false;\n+    }\n+\n+    char* record_str = ddlog_dump_record(rec);\n+    if (record_str == NULL) {\n+        fprintf(stderr, \"failed to dump record\\n\");\n+        exit(EXIT_FAILURE);\n+    }\n+    printf(\"Record: %s\\n\", record_str);\n+\n+    return true;\n+}\n+\n+int main(int args, char **argv)\n+{\n+    // Start the DDlog program and connect to it\n+\tddlog_prog prog = ddlog_run(1, true, NULL, 0, NULL, NULL);\n+\tif (prog == NULL) {\n+\t\tfprintf(stderr, \"failed to initialize DDlog program\\n\");\n+\t\treturn EXIT_FAILURE;\n+\t};\n+\n+    // Print IDs of tables corresponding to `Links` and `ConnectedNodes` relations\n+    printf(\"Links table id: %lu\\n\", ddlog_get_table_id(\"Links\"));\n+    printf(\"ConnectedNodes table id: %lu\\n\", ddlog_get_table_id(\"ConnectedNodes\"));\n+\n+    char *src_line_ptr = NULL;\n+    char *dst_line_ptr = NULL;\n+    char *link_status_line_ptr = NULL;\n+    size_t n = 0;\n+    bool link_status = false;\n+\n+    // Getting new record values from standard input\n+    printf(\"Please enter source name > \");\n+    if (getline(&src_line_ptr, &n, stdin) < 0) {\n+        return -EINVAL;\n+    }\n+    printf(\"Please enter destination name > \");\n+    if (getline(&dst_line_ptr, &n, stdin) < 0) {\n+        return -EINVAL;\n+    }\n+    printf(\"Please enter the link status between source and destination > \");\n+    if (getline(&link_status_line_ptr, &n, stdin) < 0) {\n+        return -EINVAL;\n+    }\n+\n+    // Trimming newline characters\n+    src_line_ptr[strlen(src_line_ptr) - 1] = '\\0';\n+    dst_line_ptr[strlen(dst_line_ptr) - 1] = '\\0';\n+    // Parsing value for the link status\n+    link_status = (strncmp(\"true\", link_status_line_ptr, 4) == 0) ? true : false;\n+\n+    // Creating record values in DDlog format\n+    ddlog_record* src = ddlog_string(src_line_ptr);\n+    ddlog_record* dst = ddlog_string(dst_line_ptr);\n+    ddlog_record* lstatus = ddlog_bool(link_status);\n+\n+    // Placing new record values in one struct to become a single record\n+    ddlog_record *struct_args[3];\n+    struct_args[0] = src;\n+    struct_args[1] = dst;\n+    struct_args[2] = lstatus;\n+    ddlog_record* new_record = ddlog_struct(\"Links\", struct_args, 3);", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU1MzU5OA==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540553598", "bodyText": "you may also want to say that the command does not have to be deallocated.", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:46:38Z", "path": "doc/tutorial/c_tutorial/reachibility_monitor_p1.c", "diffHunk": "@@ -0,0 +1,119 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdbool.h>\n+\n+#include <string.h> // required for strncmp()\n+#include <errno.h>  // required for error code identifiers\n+\n+#include \"ddlog.h\"\n+\n+bool print_records_callback(uintptr_t arg, const ddlog_record *rec, ssize_t weight) {\n+    if (rec == NULL) {\n+        return false;\n+    }\n+\n+    char* record_str = ddlog_dump_record(rec);\n+    if (record_str == NULL) {\n+        fprintf(stderr, \"failed to dump record\\n\");\n+        exit(EXIT_FAILURE);\n+    }\n+    printf(\"Record: %s\\n\", record_str);\n+\n+    return true;\n+}\n+\n+int main(int args, char **argv)\n+{\n+    // Start the DDlog program and connect to it\n+\tddlog_prog prog = ddlog_run(1, true, NULL, 0, NULL, NULL);\n+\tif (prog == NULL) {\n+\t\tfprintf(stderr, \"failed to initialize DDlog program\\n\");\n+\t\treturn EXIT_FAILURE;\n+\t};\n+\n+    // Print IDs of tables corresponding to `Links` and `ConnectedNodes` relations\n+    printf(\"Links table id: %lu\\n\", ddlog_get_table_id(\"Links\"));\n+    printf(\"ConnectedNodes table id: %lu\\n\", ddlog_get_table_id(\"ConnectedNodes\"));\n+\n+    char *src_line_ptr = NULL;\n+    char *dst_line_ptr = NULL;\n+    char *link_status_line_ptr = NULL;\n+    size_t n = 0;\n+    bool link_status = false;\n+\n+    // Getting new record values from standard input\n+    printf(\"Please enter source name > \");\n+    if (getline(&src_line_ptr, &n, stdin) < 0) {\n+        return -EINVAL;\n+    }\n+    printf(\"Please enter destination name > \");\n+    if (getline(&dst_line_ptr, &n, stdin) < 0) {\n+        return -EINVAL;\n+    }\n+    printf(\"Please enter the link status between source and destination > \");\n+    if (getline(&link_status_line_ptr, &n, stdin) < 0) {\n+        return -EINVAL;\n+    }\n+\n+    // Trimming newline characters\n+    src_line_ptr[strlen(src_line_ptr) - 1] = '\\0';\n+    dst_line_ptr[strlen(dst_line_ptr) - 1] = '\\0';\n+    // Parsing value for the link status\n+    link_status = (strncmp(\"true\", link_status_line_ptr, 4) == 0) ? true : false;\n+\n+    // Creating record values in DDlog format\n+    ddlog_record* src = ddlog_string(src_line_ptr);\n+    ddlog_record* dst = ddlog_string(dst_line_ptr);\n+    ddlog_record* lstatus = ddlog_bool(link_status);\n+\n+    // Placing new record values in one struct to become a single record\n+    ddlog_record *struct_args[3];\n+    struct_args[0] = src;\n+    struct_args[1] = dst;\n+    struct_args[2] = lstatus;\n+    ddlog_record* new_record = ddlog_struct(\"Links\", struct_args, 3);\n+\n+    printf(\"Inserting the following record: %s\\n\", ddlog_dump_record(new_record));\n+\n+    // Start transaction\n+    if (ddlog_transaction_start(prog) < 0) {\n+        fprintf(stderr, \"failed to start transaction\\n\");\n+        return EXIT_FAILURE;\n+    };\n+\n+    // apply updates\n+    ddlog_cmd *cmds[1];\n+    ddlog_cmd* cmd = ddlog_insert_cmd(1, new_record);", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU1Mzc1MA==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r540553750", "bodyText": "why is the table id hardwired?", "author": "mbudiu-vmw", "createdAt": "2020-12-10T22:46:53Z", "path": "doc/tutorial/c_tutorial/reachibility_monitor_p1.c", "diffHunk": "@@ -0,0 +1,119 @@\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <stdbool.h>\n+\n+#include <string.h> // required for strncmp()\n+#include <errno.h>  // required for error code identifiers\n+\n+#include \"ddlog.h\"\n+\n+bool print_records_callback(uintptr_t arg, const ddlog_record *rec, ssize_t weight) {\n+    if (rec == NULL) {\n+        return false;\n+    }\n+\n+    char* record_str = ddlog_dump_record(rec);\n+    if (record_str == NULL) {\n+        fprintf(stderr, \"failed to dump record\\n\");\n+        exit(EXIT_FAILURE);\n+    }\n+    printf(\"Record: %s\\n\", record_str);\n+\n+    return true;\n+}\n+\n+int main(int args, char **argv)\n+{\n+    // Start the DDlog program and connect to it\n+\tddlog_prog prog = ddlog_run(1, true, NULL, 0, NULL, NULL);\n+\tif (prog == NULL) {\n+\t\tfprintf(stderr, \"failed to initialize DDlog program\\n\");\n+\t\treturn EXIT_FAILURE;\n+\t};\n+\n+    // Print IDs of tables corresponding to `Links` and `ConnectedNodes` relations\n+    printf(\"Links table id: %lu\\n\", ddlog_get_table_id(\"Links\"));\n+    printf(\"ConnectedNodes table id: %lu\\n\", ddlog_get_table_id(\"ConnectedNodes\"));\n+\n+    char *src_line_ptr = NULL;\n+    char *dst_line_ptr = NULL;\n+    char *link_status_line_ptr = NULL;\n+    size_t n = 0;\n+    bool link_status = false;\n+\n+    // Getting new record values from standard input\n+    printf(\"Please enter source name > \");\n+    if (getline(&src_line_ptr, &n, stdin) < 0) {\n+        return -EINVAL;\n+    }\n+    printf(\"Please enter destination name > \");\n+    if (getline(&dst_line_ptr, &n, stdin) < 0) {\n+        return -EINVAL;\n+    }\n+    printf(\"Please enter the link status between source and destination > \");\n+    if (getline(&link_status_line_ptr, &n, stdin) < 0) {\n+        return -EINVAL;\n+    }\n+\n+    // Trimming newline characters\n+    src_line_ptr[strlen(src_line_ptr) - 1] = '\\0';\n+    dst_line_ptr[strlen(dst_line_ptr) - 1] = '\\0';\n+    // Parsing value for the link status\n+    link_status = (strncmp(\"true\", link_status_line_ptr, 4) == 0) ? true : false;\n+\n+    // Creating record values in DDlog format\n+    ddlog_record* src = ddlog_string(src_line_ptr);\n+    ddlog_record* dst = ddlog_string(dst_line_ptr);\n+    ddlog_record* lstatus = ddlog_bool(link_status);\n+\n+    // Placing new record values in one struct to become a single record\n+    ddlog_record *struct_args[3];\n+    struct_args[0] = src;\n+    struct_args[1] = dst;\n+    struct_args[2] = lstatus;\n+    ddlog_record* new_record = ddlog_struct(\"Links\", struct_args, 3);\n+\n+    printf(\"Inserting the following record: %s\\n\", ddlog_dump_record(new_record));\n+\n+    // Start transaction\n+    if (ddlog_transaction_start(prog) < 0) {\n+        fprintf(stderr, \"failed to start transaction\\n\");\n+        return EXIT_FAILURE;\n+    };\n+\n+    // apply updates\n+    ddlog_cmd *cmds[1];\n+    ddlog_cmd* cmd = ddlog_insert_cmd(1, new_record);", "originalCommit": "dcd2d66ec87f22b3524426e1393f03856e766f94", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDY0MDMyNg==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r570640326", "bodyText": "\"a DDlog program into a C program\"", "author": "mbudiu-vmw", "createdAt": "2021-02-05T00:33:19Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,487 @@\n+************************\r\n+Integrating C with DDlog\r\n+************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog_ from the official repository, which contains instructions how to install and set it up.\r\n+There is also an expectation that you are familiar with DDlog syntax and commands, i.e., you have read the tutorial or at least skimmed through it.\r\n+\r\n+.. _DDlog: https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog programming language and learn how to integrate DDlog program into C program.\r", "originalCommit": "56e119846ee6463c1625a8d748648dd7215bed8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDY0MDg2Ng==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r570640866", "bodyText": "\"in a network composed of nodes connected by links.\"\nYou are using nodes and links in the next phrase without having defined them.", "author": "mbudiu-vmw", "createdAt": "2021-02-05T00:34:45Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,487 @@\n+************************\r\n+Integrating C with DDlog\r\n+************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog_ from the official repository, which contains instructions how to install and set it up.\r\n+There is also an expectation that you are familiar with DDlog syntax and commands, i.e., you have read the tutorial or at least skimmed through it.\r\n+\r\n+.. _DDlog: https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog programming language and learn how to integrate DDlog program into C program.\r\n+To do that we are going to build a simple yet functional application as it is more fun to build real programs.\r\n+We will start by writing a simple program with a limited functionality to get familiar with the basics of DDlog.\r\n+Afterwards, over the course of this set of tutorials, we will gradually improve our application by applying more advanced techniques offered by DDlog.\r\n+\r\n+Tutorial #1 - Reachability Monitor\r\n+==================================\r\n+\r\n+In our first tutorial we are going to build a program that will calculate the reachability information in the network.\r", "originalCommit": "56e119846ee6463c1625a8d748648dd7215bed8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDY0MTQ1NQ==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r570641455", "bodyText": "I would move these two lines a little lower, when you actually show how to insert the data.", "author": "mbudiu-vmw", "createdAt": "2021-02-05T00:36:26Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,487 @@\n+************************\r\n+Integrating C with DDlog\r\n+************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog_ from the official repository, which contains instructions how to install and set it up.\r\n+There is also an expectation that you are familiar with DDlog syntax and commands, i.e., you have read the tutorial or at least skimmed through it.\r\n+\r\n+.. _DDlog: https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog programming language and learn how to integrate DDlog program into C program.\r\n+To do that we are going to build a simple yet functional application as it is more fun to build real programs.\r\n+We will start by writing a simple program with a limited functionality to get familiar with the basics of DDlog.\r\n+Afterwards, over the course of this set of tutorials, we will gradually improve our application by applying more advanced techniques offered by DDlog.\r\n+\r\n+Tutorial #1 - Reachability Monitor\r\n+==================================\r\n+\r\n+In our first tutorial we are going to build a program that will calculate the reachability information in the network.\r\n+User will update link status between nodes through CLI and our program will calculate the rest.\r\n+The purpose of this program is to provide a simple interface to a network operator and return information regarding which node can reach which.\r\n+Thus, the only concern of network operator is to update link status without having to worry about doing those calculations themself.\r\n+We are going to test our program with the network consisting of four nodes: Menlo Park, Santa Barbara, Los Angeles, and Salt Lake City.\r", "originalCommit": "56e119846ee6463c1625a8d748648dd7215bed8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDY0MTg4MQ==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r570641881", "bodyText": "I would delete this line. Note that you are dealing with 2 programs: one is the DDlog program, and the other one is the .dat file with inputs. This text line seems more applicable to the latter really.", "author": "mbudiu-vmw", "createdAt": "2021-02-05T00:37:34Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,487 @@\n+************************\r\n+Integrating C with DDlog\r\n+************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog_ from the official repository, which contains instructions how to install and set it up.\r\n+There is also an expectation that you are familiar with DDlog syntax and commands, i.e., you have read the tutorial or at least skimmed through it.\r\n+\r\n+.. _DDlog: https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog programming language and learn how to integrate DDlog program into C program.\r\n+To do that we are going to build a simple yet functional application as it is more fun to build real programs.\r\n+We will start by writing a simple program with a limited functionality to get familiar with the basics of DDlog.\r\n+Afterwards, over the course of this set of tutorials, we will gradually improve our application by applying more advanced techniques offered by DDlog.\r\n+\r\n+Tutorial #1 - Reachability Monitor\r\n+==================================\r\n+\r\n+In our first tutorial we are going to build a program that will calculate the reachability information in the network.\r\n+User will update link status between nodes through CLI and our program will calculate the rest.\r\n+The purpose of this program is to provide a simple interface to a network operator and return information regarding which node can reach which.\r\n+Thus, the only concern of network operator is to update link status without having to worry about doing those calculations themself.\r\n+We are going to test our program with the network consisting of four nodes: Menlo Park, Santa Barbara, Los Angeles, and Salt Lake City.\r\n+However, nothing prevents us from using the network comprised of hundreds of nodes.\r\n+\r\n+Let's start with defining our program in the DDlog language.\r\n+In our program we need to supply source node, destination node, and a link status between them.\r", "originalCommit": "56e119846ee6463c1625a8d748648dd7215bed8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDY0Mjk1OQ==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r570642959", "bodyText": "Your users haven't seen yet how the incremental aspect works, so I don't know if they will appreciate it at this point.", "author": "mbudiu-vmw", "createdAt": "2021-02-05T00:40:42Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,487 @@\n+************************\r\n+Integrating C with DDlog\r\n+************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog_ from the official repository, which contains instructions how to install and set it up.\r\n+There is also an expectation that you are familiar with DDlog syntax and commands, i.e., you have read the tutorial or at least skimmed through it.\r\n+\r\n+.. _DDlog: https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog programming language and learn how to integrate DDlog program into C program.\r\n+To do that we are going to build a simple yet functional application as it is more fun to build real programs.\r\n+We will start by writing a simple program with a limited functionality to get familiar with the basics of DDlog.\r\n+Afterwards, over the course of this set of tutorials, we will gradually improve our application by applying more advanced techniques offered by DDlog.\r\n+\r\n+Tutorial #1 - Reachability Monitor\r\n+==================================\r\n+\r\n+In our first tutorial we are going to build a program that will calculate the reachability information in the network.\r\n+User will update link status between nodes through CLI and our program will calculate the rest.\r\n+The purpose of this program is to provide a simple interface to a network operator and return information regarding which node can reach which.\r\n+Thus, the only concern of network operator is to update link status without having to worry about doing those calculations themself.\r\n+We are going to test our program with the network consisting of four nodes: Menlo Park, Santa Barbara, Los Angeles, and Salt Lake City.\r\n+However, nothing prevents us from using the network comprised of hundreds of nodes.\r\n+\r\n+Let's start with defining our program in the DDlog language.\r\n+In our program we need to supply source node, destination node, and a link status between them.\r\n+Now we are ready to define our input relation :code:`Links`.\r\n+Let's create a file called :code:`t1_reachability_monitor.dl` and add there a following line representing input relation for our reachability monitor:\r\n+\r\n+.. code-block::\r\n+    \r\n+    input relation Links(src: string, dst: string, link_status: bool)\r\n+\r\n+However, for the reachability monitor to be useful it also should provide some output and not just ingest the data.\r\n+We want our program to output a list of nodes that are currently reachable based on the information in the relation :code:`Links`.\r\n+Thus, let's add an output relation :code:`ConnectedNodes` and provide rules how to calculate records in this relation *(mind the presence of the dot at the end of each rule)*.\r\n+To do that we are going to add few more lines to the :code:`t1_reachability_monitor.dl` so it will look as follows:\r\n+\r\n+.. code-block::\r\n+\r\n+    input relation Links(src: string, dst: string, link_status: bool)\r\n+    output relation ConnectedNodes(src: string, dst: string)\r\n+\r\n+    ConnectedNodes(src, dst) :- Links(src, dst, true).\r\n+    ConnectedNodes(src, dst) :- ConnectedNodes(src, intermediate_node),\r\n+                                Links(intermediate_node, dst, true).\r\n+\r\n+Let's briefly discuss the rule to calculate :code:`ConnectedNodes` relation.\r\n+First, we say that any two directly connected nodes such that the :code:`link_status` between them is :code:`true` belong to the :code:`ConnectedNodes` relation.\r\n+Furthermore, any two nodes are considered connected if there is path from the source node to the destination node such that all directly connected nodes along the path also have the :code:`link_status` between them to be :code:`true`.\r\n+Take a minute here to realize how easy it is to write such rule in DDlog.\r\n+While these rules may not require much effort in other programming languages, the distinct feature of DDlog is that the computing is done incrementally!\r\n+Isn't is amazing?\r", "originalCommit": "56e119846ee6463c1625a8d748648dd7215bed8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDY0MzcyMQ==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r570643721", "bodyText": "You should probably be more precise here: there are really no transactions in the *.dl file, but when you supply inputs you do it using transactions; the outputs are also associated to transactions.", "author": "mbudiu-vmw", "createdAt": "2021-02-05T00:43:02Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,487 @@\n+************************\r\n+Integrating C with DDlog\r\n+************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog_ from the official repository, which contains instructions how to install and set it up.\r\n+There is also an expectation that you are familiar with DDlog syntax and commands, i.e., you have read the tutorial or at least skimmed through it.\r\n+\r\n+.. _DDlog: https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog programming language and learn how to integrate DDlog program into C program.\r\n+To do that we are going to build a simple yet functional application as it is more fun to build real programs.\r\n+We will start by writing a simple program with a limited functionality to get familiar with the basics of DDlog.\r\n+Afterwards, over the course of this set of tutorials, we will gradually improve our application by applying more advanced techniques offered by DDlog.\r\n+\r\n+Tutorial #1 - Reachability Monitor\r\n+==================================\r\n+\r\n+In our first tutorial we are going to build a program that will calculate the reachability information in the network.\r\n+User will update link status between nodes through CLI and our program will calculate the rest.\r\n+The purpose of this program is to provide a simple interface to a network operator and return information regarding which node can reach which.\r\n+Thus, the only concern of network operator is to update link status without having to worry about doing those calculations themself.\r\n+We are going to test our program with the network consisting of four nodes: Menlo Park, Santa Barbara, Los Angeles, and Salt Lake City.\r\n+However, nothing prevents us from using the network comprised of hundreds of nodes.\r\n+\r\n+Let's start with defining our program in the DDlog language.\r\n+In our program we need to supply source node, destination node, and a link status between them.\r\n+Now we are ready to define our input relation :code:`Links`.\r\n+Let's create a file called :code:`t1_reachability_monitor.dl` and add there a following line representing input relation for our reachability monitor:\r\n+\r\n+.. code-block::\r\n+    \r\n+    input relation Links(src: string, dst: string, link_status: bool)\r\n+\r\n+However, for the reachability monitor to be useful it also should provide some output and not just ingest the data.\r\n+We want our program to output a list of nodes that are currently reachable based on the information in the relation :code:`Links`.\r\n+Thus, let's add an output relation :code:`ConnectedNodes` and provide rules how to calculate records in this relation *(mind the presence of the dot at the end of each rule)*.\r\n+To do that we are going to add few more lines to the :code:`t1_reachability_monitor.dl` so it will look as follows:\r\n+\r\n+.. code-block::\r\n+\r\n+    input relation Links(src: string, dst: string, link_status: bool)\r\n+    output relation ConnectedNodes(src: string, dst: string)\r\n+\r\n+    ConnectedNodes(src, dst) :- Links(src, dst, true).\r\n+    ConnectedNodes(src, dst) :- ConnectedNodes(src, intermediate_node),\r\n+                                Links(intermediate_node, dst, true).\r\n+\r\n+Let's briefly discuss the rule to calculate :code:`ConnectedNodes` relation.\r\n+First, we say that any two directly connected nodes such that the :code:`link_status` between them is :code:`true` belong to the :code:`ConnectedNodes` relation.\r\n+Furthermore, any two nodes are considered connected if there is path from the source node to the destination node such that all directly connected nodes along the path also have the :code:`link_status` between them to be :code:`true`.\r\n+Take a minute here to realize how easy it is to write such rule in DDlog.\r\n+While these rules may not require much effort in other programming languages, the distinct feature of DDlog is that the computing is done incrementally!\r\n+Isn't is amazing?\r\n+\r\n+With that done, let's compile and start our program.\r\n+We will feed our DDlog code to the DDlog compiler and it will generate a new folder.\r\n+This folder contains CLI so we can run our program as well as a library that we will need later for our C program.\r\n+Note, that on the first run it will take a while, but will be signifanctly faster afterwards.\r\n+After the code is compiled let's start a command-line so we can start playing with our program.\r\n+\r\n+.. code-block::\r\n+\r\n+    $ ddlog -i t1_reachability_monitor.dl\r\n+    $ cd t1_reachability_monitor_ddlog/ && cargo build --release\r\n+    $ ./target/release/t1_reachability_monitor_cli\r\n+\r\n+If we display the contents of the :code:`ConnectedNodes` relation we will see that this it is empty, which make sense as we haven't populated :code:`Links` relation with anything yet:\r\n+\r\n+.. code-block::\r\n+\r\n+    >> dump ConnectedNodes;\r\n+\r\n+To exit DDlog shell press `[CTRL+d]`.\r\n+If you are using `Windows Terminal` do not press `[CTRL+D]` (note capital `D`, i.e., `[CTRL+SHIFT+d]`) as it will open a new tab.\r\n+\r\n+Let's supply some input data.\r\n+We are going to insert several records into :code:`Links` relation.\r\n+But first let's define a simple network topology that we are going to work through.\r\n+To make our life more interesting (and just slightly more complicated) the links between nodes will not be bidirectional by default.\r\n+\r\n+.. image:: ./images/topology.jpg\r\n+\r\n+Note that DDlog is a `transaction-based`_ programming language.\r", "originalCommit": "56e119846ee6463c1625a8d748648dd7215bed8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDY0MzkzNg==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r570643936", "bodyText": "why has this", "author": "mbudiu-vmw", "createdAt": "2021-02-05T00:43:38Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,487 @@\n+************************\r\n+Integrating C with DDlog\r\n+************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog_ from the official repository, which contains instructions how to install and set it up.\r\n+There is also an expectation that you are familiar with DDlog syntax and commands, i.e., you have read the tutorial or at least skimmed through it.\r\n+\r\n+.. _DDlog: https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog programming language and learn how to integrate DDlog program into C program.\r\n+To do that we are going to build a simple yet functional application as it is more fun to build real programs.\r\n+We will start by writing a simple program with a limited functionality to get familiar with the basics of DDlog.\r\n+Afterwards, over the course of this set of tutorials, we will gradually improve our application by applying more advanced techniques offered by DDlog.\r\n+\r\n+Tutorial #1 - Reachability Monitor\r\n+==================================\r\n+\r\n+In our first tutorial we are going to build a program that will calculate the reachability information in the network.\r\n+User will update link status between nodes through CLI and our program will calculate the rest.\r\n+The purpose of this program is to provide a simple interface to a network operator and return information regarding which node can reach which.\r\n+Thus, the only concern of network operator is to update link status without having to worry about doing those calculations themself.\r\n+We are going to test our program with the network consisting of four nodes: Menlo Park, Santa Barbara, Los Angeles, and Salt Lake City.\r\n+However, nothing prevents us from using the network comprised of hundreds of nodes.\r\n+\r\n+Let's start with defining our program in the DDlog language.\r\n+In our program we need to supply source node, destination node, and a link status between them.\r\n+Now we are ready to define our input relation :code:`Links`.\r\n+Let's create a file called :code:`t1_reachability_monitor.dl` and add there a following line representing input relation for our reachability monitor:\r\n+\r\n+.. code-block::\r\n+    \r\n+    input relation Links(src: string, dst: string, link_status: bool)\r\n+\r\n+However, for the reachability monitor to be useful it also should provide some output and not just ingest the data.\r\n+We want our program to output a list of nodes that are currently reachable based on the information in the relation :code:`Links`.\r\n+Thus, let's add an output relation :code:`ConnectedNodes` and provide rules how to calculate records in this relation *(mind the presence of the dot at the end of each rule)*.\r\n+To do that we are going to add few more lines to the :code:`t1_reachability_monitor.dl` so it will look as follows:\r\n+\r\n+.. code-block::\r\n+\r\n+    input relation Links(src: string, dst: string, link_status: bool)\r\n+    output relation ConnectedNodes(src: string, dst: string)\r\n+\r\n+    ConnectedNodes(src, dst) :- Links(src, dst, true).\r\n+    ConnectedNodes(src, dst) :- ConnectedNodes(src, intermediate_node),\r\n+                                Links(intermediate_node, dst, true).\r\n+\r\n+Let's briefly discuss the rule to calculate :code:`ConnectedNodes` relation.\r\n+First, we say that any two directly connected nodes such that the :code:`link_status` between them is :code:`true` belong to the :code:`ConnectedNodes` relation.\r\n+Furthermore, any two nodes are considered connected if there is path from the source node to the destination node such that all directly connected nodes along the path also have the :code:`link_status` between them to be :code:`true`.\r\n+Take a minute here to realize how easy it is to write such rule in DDlog.\r\n+While these rules may not require much effort in other programming languages, the distinct feature of DDlog is that the computing is done incrementally!\r\n+Isn't is amazing?\r\n+\r\n+With that done, let's compile and start our program.\r\n+We will feed our DDlog code to the DDlog compiler and it will generate a new folder.\r\n+This folder contains CLI so we can run our program as well as a library that we will need later for our C program.\r\n+Note, that on the first run it will take a while, but will be signifanctly faster afterwards.\r\n+After the code is compiled let's start a command-line so we can start playing with our program.\r\n+\r\n+.. code-block::\r\n+\r\n+    $ ddlog -i t1_reachability_monitor.dl\r\n+    $ cd t1_reachability_monitor_ddlog/ && cargo build --release\r\n+    $ ./target/release/t1_reachability_monitor_cli\r\n+\r\n+If we display the contents of the :code:`ConnectedNodes` relation we will see that this it is empty, which make sense as we haven't populated :code:`Links` relation with anything yet:\r\n+\r\n+.. code-block::\r\n+\r\n+    >> dump ConnectedNodes;\r\n+\r\n+To exit DDlog shell press `[CTRL+d]`.\r\n+If you are using `Windows Terminal` do not press `[CTRL+D]` (note capital `D`, i.e., `[CTRL+SHIFT+d]`) as it will open a new tab.\r\n+\r\n+Let's supply some input data.\r\n+We are going to insert several records into :code:`Links` relation.\r\n+But first let's define a simple network topology that we are going to work through.\r\n+To make our life more interesting (and just slightly more complicated) the links between nodes will not be bidirectional by default.\r\n+\r\n+.. image:: ./images/topology.jpg\r\n+\r\n+Note that DDlog is a `transaction-based`_ programming language.\r\n+Each transaction begins with a :code:`start` command and ends with a :code:`commit` command.\r\n+Let's start DDlog shell again and insert records to recreate the network topology above:\r\n+\r\n+.. _transaction-based: https://en.wikipedia.org/wiki/Transaction_processing\r\n+\r\n+.. code-block::\r\n+\r\n+    $ ./target/release/t1_reachability_monitor_cli\r\n+    >> start;\r\n+    >> insert Links(\"Menlo Park\", \"Santa Barbara\", true);\r\n+    >> insert Links(\"Menlo Park\", \"Salt Lake City\", true);\r\n+    >> insert Links(\"Santa Barbara\", \"Los Angeles\", true);\r\n+    >> insert Links(\"Los Angeles\", \"Santa Barbara\", true);\r\n+    >> insert Links(\"Los Angeles\", \"Salt Lake City\", true);\r\n+    >> insert Links(\"Salt Lake City\", \"Los Angeles\", true);\r\n+    >> commit;\r\n+    >> dump ConnectedNodes;\r\n+    ConnectedNodes{.src = \"Los Angeles\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Los Angeles\", .dst = \"Salt Lake City\"}\r\n+    ConnectedNodes{.src = \"Los Angeles\", .dst = \"Santa Barbara\"}\r\n+    ConnectedNodes{.src = \"Menlo Park\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Menlo Park\", .dst = \"Salt Lake City\"}\r\n+    ConnectedNodes{.src = \"Menlo Park\", .dst = \"Santa Barbara\"}\r\n+    ConnectedNodes{.src = \"Salt Lake City\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Salt Lake City\", .dst = \"Salt Lake City\"}\r\n+    ConnectedNodes{.src = \"Salt Lake City\", .dst = \"Santa Barbara\"}\r\n+    ConnectedNodes{.src = \"Santa Barbara\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Santa Barbara\", .dst = \"Salt Lake City\"}\r\n+    ConnectedNodes{.src = \"Santa Barbara\", .dst = \"Santa Barbara\"}\r\n+\r\n+In the output we can see all cities with direct links between them are connected.\r\n+Furthermore, as we specified in our DDlog code, if there is a path between two cities then they are also connected, e.g., Menlo Park is connected to Los Angeles.\r\n+However, some nodes are connected to themselves.\r\n+But why this happened?\r", "originalCommit": "56e119846ee6463c1625a8d748648dd7215bed8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDY0NDY2MQ==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r570644661", "bodyText": "why not make the text up to here the first tutorial and this one the second one?\nYou really have two tutorials: first is how to compile and run the CLI, second is how to integrate into a C program.\nNo additional work required.", "author": "mbudiu-vmw", "createdAt": "2021-02-05T00:45:46Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,487 @@\n+************************\r\n+Integrating C with DDlog\r\n+************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog_ from the official repository, which contains instructions how to install and set it up.\r\n+There is also an expectation that you are familiar with DDlog syntax and commands, i.e., you have read the tutorial or at least skimmed through it.\r\n+\r\n+.. _DDlog: https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog programming language and learn how to integrate DDlog program into C program.\r\n+To do that we are going to build a simple yet functional application as it is more fun to build real programs.\r\n+We will start by writing a simple program with a limited functionality to get familiar with the basics of DDlog.\r\n+Afterwards, over the course of this set of tutorials, we will gradually improve our application by applying more advanced techniques offered by DDlog.\r\n+\r\n+Tutorial #1 - Reachability Monitor\r\n+==================================\r\n+\r\n+In our first tutorial we are going to build a program that will calculate the reachability information in the network.\r\n+User will update link status between nodes through CLI and our program will calculate the rest.\r\n+The purpose of this program is to provide a simple interface to a network operator and return information regarding which node can reach which.\r\n+Thus, the only concern of network operator is to update link status without having to worry about doing those calculations themself.\r\n+We are going to test our program with the network consisting of four nodes: Menlo Park, Santa Barbara, Los Angeles, and Salt Lake City.\r\n+However, nothing prevents us from using the network comprised of hundreds of nodes.\r\n+\r\n+Let's start with defining our program in the DDlog language.\r\n+In our program we need to supply source node, destination node, and a link status between them.\r\n+Now we are ready to define our input relation :code:`Links`.\r\n+Let's create a file called :code:`t1_reachability_monitor.dl` and add there a following line representing input relation for our reachability monitor:\r\n+\r\n+.. code-block::\r\n+    \r\n+    input relation Links(src: string, dst: string, link_status: bool)\r\n+\r\n+However, for the reachability monitor to be useful it also should provide some output and not just ingest the data.\r\n+We want our program to output a list of nodes that are currently reachable based on the information in the relation :code:`Links`.\r\n+Thus, let's add an output relation :code:`ConnectedNodes` and provide rules how to calculate records in this relation *(mind the presence of the dot at the end of each rule)*.\r\n+To do that we are going to add few more lines to the :code:`t1_reachability_monitor.dl` so it will look as follows:\r\n+\r\n+.. code-block::\r\n+\r\n+    input relation Links(src: string, dst: string, link_status: bool)\r\n+    output relation ConnectedNodes(src: string, dst: string)\r\n+\r\n+    ConnectedNodes(src, dst) :- Links(src, dst, true).\r\n+    ConnectedNodes(src, dst) :- ConnectedNodes(src, intermediate_node),\r\n+                                Links(intermediate_node, dst, true).\r\n+\r\n+Let's briefly discuss the rule to calculate :code:`ConnectedNodes` relation.\r\n+First, we say that any two directly connected nodes such that the :code:`link_status` between them is :code:`true` belong to the :code:`ConnectedNodes` relation.\r\n+Furthermore, any two nodes are considered connected if there is path from the source node to the destination node such that all directly connected nodes along the path also have the :code:`link_status` between them to be :code:`true`.\r\n+Take a minute here to realize how easy it is to write such rule in DDlog.\r\n+While these rules may not require much effort in other programming languages, the distinct feature of DDlog is that the computing is done incrementally!\r\n+Isn't is amazing?\r\n+\r\n+With that done, let's compile and start our program.\r\n+We will feed our DDlog code to the DDlog compiler and it will generate a new folder.\r\n+This folder contains CLI so we can run our program as well as a library that we will need later for our C program.\r\n+Note, that on the first run it will take a while, but will be signifanctly faster afterwards.\r\n+After the code is compiled let's start a command-line so we can start playing with our program.\r\n+\r\n+.. code-block::\r\n+\r\n+    $ ddlog -i t1_reachability_monitor.dl\r\n+    $ cd t1_reachability_monitor_ddlog/ && cargo build --release\r\n+    $ ./target/release/t1_reachability_monitor_cli\r\n+\r\n+If we display the contents of the :code:`ConnectedNodes` relation we will see that this it is empty, which make sense as we haven't populated :code:`Links` relation with anything yet:\r\n+\r\n+.. code-block::\r\n+\r\n+    >> dump ConnectedNodes;\r\n+\r\n+To exit DDlog shell press `[CTRL+d]`.\r\n+If you are using `Windows Terminal` do not press `[CTRL+D]` (note capital `D`, i.e., `[CTRL+SHIFT+d]`) as it will open a new tab.\r\n+\r\n+Let's supply some input data.\r\n+We are going to insert several records into :code:`Links` relation.\r\n+But first let's define a simple network topology that we are going to work through.\r\n+To make our life more interesting (and just slightly more complicated) the links between nodes will not be bidirectional by default.\r\n+\r\n+.. image:: ./images/topology.jpg\r\n+\r\n+Note that DDlog is a `transaction-based`_ programming language.\r\n+Each transaction begins with a :code:`start` command and ends with a :code:`commit` command.\r\n+Let's start DDlog shell again and insert records to recreate the network topology above:\r\n+\r\n+.. _transaction-based: https://en.wikipedia.org/wiki/Transaction_processing\r\n+\r\n+.. code-block::\r\n+\r\n+    $ ./target/release/t1_reachability_monitor_cli\r\n+    >> start;\r\n+    >> insert Links(\"Menlo Park\", \"Santa Barbara\", true);\r\n+    >> insert Links(\"Menlo Park\", \"Salt Lake City\", true);\r\n+    >> insert Links(\"Santa Barbara\", \"Los Angeles\", true);\r\n+    >> insert Links(\"Los Angeles\", \"Santa Barbara\", true);\r\n+    >> insert Links(\"Los Angeles\", \"Salt Lake City\", true);\r\n+    >> insert Links(\"Salt Lake City\", \"Los Angeles\", true);\r\n+    >> commit;\r\n+    >> dump ConnectedNodes;\r\n+    ConnectedNodes{.src = \"Los Angeles\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Los Angeles\", .dst = \"Salt Lake City\"}\r\n+    ConnectedNodes{.src = \"Los Angeles\", .dst = \"Santa Barbara\"}\r\n+    ConnectedNodes{.src = \"Menlo Park\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Menlo Park\", .dst = \"Salt Lake City\"}\r\n+    ConnectedNodes{.src = \"Menlo Park\", .dst = \"Santa Barbara\"}\r\n+    ConnectedNodes{.src = \"Salt Lake City\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Salt Lake City\", .dst = \"Salt Lake City\"}\r\n+    ConnectedNodes{.src = \"Salt Lake City\", .dst = \"Santa Barbara\"}\r\n+    ConnectedNodes{.src = \"Santa Barbara\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Santa Barbara\", .dst = \"Salt Lake City\"}\r\n+    ConnectedNodes{.src = \"Santa Barbara\", .dst = \"Santa Barbara\"}\r\n+\r\n+In the output we can see all cities with direct links between them are connected.\r\n+Furthermore, as we specified in our DDlog code, if there is a path between two cities then they are also connected, e.g., Menlo Park is connected to Los Angeles.\r\n+However, some nodes are connected to themselves.\r\n+But why this happened?\r\n+If we take a closer look at our rules we can notice that this phenomenon actually make sense.\r\n+For example, Santa Barbara is reachable from Santa Barbara through Los Angeles.\r\n+While it is not necessarily horrible or wrong we may want to avoid it as it clutters the relation and the output.\r\n+More notably, we definitely don't want the network traffic go to Santa Barbara from Santa Barbara through Los Angeles (in the real world this actually may happen but this is a completely different topic).\r\n+Let's fix it by adding a filtering condition to the rule that disallows source and destination match each other.\r\n+Now, the rules for calculating :code:`ConnectedNodes` look as below and see how simple it is to do that in DDlog (note that only second rule was modified, the first stays intact):\r\n+\r\n+.. code-block::\r\n+\r\n+    $ cd ../ && cat t1_reachability_monitor.dl\r\n+    // Input relations\r\n+    input relation Links(src: string, dst: string, link_status: bool)\r\n+\r\n+    // Output relations\r\n+    output relation ConnectedNodes(src: string, dst: string)\r\n+\r\n+    /*\r\n+     * Rules to calculate `ConnectedNodes` relation\r\n+     */\r\n+    ConnectedNodes(src, dst) :- Links(src, dst, true).\r\n+    ConnectedNodes(src, dst) :- ConnectedNodes(src, intermediate_node),\r\n+                                Links(intermediate_node, dst, true), (src != dst).\r\n+\r\n+.. tip:: This is a tip on DDlog syntax concerning comments in the code.\r\n+\r\n+    DDlog supports C-style comments as you can see in the example above.\r\n+\r\n+As we have changed the DDlog program we need to recompile it.\r\n+\r\n+.. code-block::\r\n+\r\n+    $ ddlog -i t1_reachability_monitor.dl\r\n+    $ cd t1_reachability_monitor_ddlog/ && cargo build --release\r\n+    $ ./target/release/t1_reachability_monitor_cli\r\n+    <clip>\r\n+    >> dump ConnectedNodes;\r\n+    ConnectedNodes{.src = \"Los Angeles\", .dst = \"Salt Lake City\"}\r\n+    ConnectedNodes{.src = \"Los Angeles\", .dst = \"Santa Barbara\"}\r\n+    ConnectedNodes{.src = \"Menlo Park\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Menlo Park\", .dst = \"Salt Lake City\"}\r\n+    ConnectedNodes{.src = \"Menlo Park\", .dst = \"Santa Barbara\"}\r\n+    ConnectedNodes{.src = \"Salt Lake City\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Salt Lake City\", .dst = \"Santa Barbara\"}\r\n+    ConnectedNodes{.src = \"Santa Barbara\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Santa Barbara\", .dst = \"Salt Lake City\"}\r\n+\r\n+Perfect!\r\n+Now it looks exactly as we expected!\r\n+Rigth before we jump to what this tutorial promised let's look at one more example that demonstrates incremental nature of DDlog.\r\n+\r\n+.. code-block::\r\n+\r\n+    $ ./target/release/t1_reachability_monitor_cli\r\n+    >> start;\r\n+    >> insert Links(\"Menlo Park\", \"Santa Barbara\", true);\r\n+    >> insert Links(\"Menlo Park\", \"Salt Lake City\", true);\r\n+    >> insert Links(\"Santa Barbara\", \"Los Angeles\", true);\r\n+    >> insert Links(\"Los Angeles\", \"Santa Barbara\", true);\r\n+    >> insert Links(\"Los Angeles\", \"Salt Lake City\", true);\r\n+    >> insert Links(\"Salt Lake City\", \"Los Angeles\", true);\r\n+    >> commit;\r\n+    >> dump ConnectedNodes;\r\n+    ConnectedNodes{.src = \"Los Angeles\", .dst = \"Salt Lake City\"}\r\n+    ConnectedNodes{.src = \"Los Angeles\", .dst = \"Santa Barbara\"}\r\n+    ConnectedNodes{.src = \"Menlo Park\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Menlo Park\", .dst = \"Salt Lake City\"}\r\n+    ConnectedNodes{.src = \"Menlo Park\", .dst = \"Santa Barbara\"}\r\n+    ConnectedNodes{.src = \"Salt Lake City\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Salt Lake City\", .dst = \"Santa Barbara\"}\r\n+    ConnectedNodes{.src = \"Santa Barbara\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Santa Barbara\", .dst = \"Salt Lake City\"}\r\n+    >> start;\r\n+    >> delete Links(\"Santa Barbara\", \"Los Angeles\", true);\r\n+    >> commit dump_changes;\r\n+    ConnectedNodes:\r\n+    ConnectedNodes{.src = \"Santa Barbara\", .dst = \"Los Angeles\"}: -1\r\n+    ConnectedNodes{.src = \"Santa Barbara\", .dst = \"Salt Lake City\"}: -1\r\n+\r\n+DDlog incrementally computed only changes that happened and printed them.\r\n+The \"minus one\" here is called :code:`weight` and indicates that the respective record was deleted.\r\n+While the benefits of incremental computation ain't noticeable in our small example, they manifest themselves on a large scale and can make a substantial difference.\r\n+\r\n+Now we are finally realdy to start writing some C code!\r", "originalCommit": "56e119846ee6463c1625a8d748648dd7215bed8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3MDY0NjcyNA==", "url": "https://github.com/vmware/differential-datalog/pull/853#discussion_r570646724", "bodyText": "I would actually say that often applying multiple commands in a single transaction can be more efficient (batching).", "author": "mbudiu-vmw", "createdAt": "2021-02-05T00:51:31Z", "path": "doc/tutorial/c_tutorial/c_tutorial.rst", "diffHunk": "@@ -0,0 +1,487 @@\n+************************\r\n+Integrating C with DDlog\r\n+************************\r\n+\r\n+.. contents::\r\n+\r\n+Prerequisites\r\n+=============\r\n+\r\n+First, you need to obtain DDlog_ from the official repository, which contains instructions how to install and set it up.\r\n+There is also an expectation that you are familiar with DDlog syntax and commands, i.e., you have read the tutorial or at least skimmed through it.\r\n+\r\n+.. _DDlog: https://github.com/vmware/differential-datalog\r\n+\r\n+Introduction\r\n+============\r\n+\r\n+In this set of tutorials we are going to explore various features of DDlog programming language and learn how to integrate DDlog program into C program.\r\n+To do that we are going to build a simple yet functional application as it is more fun to build real programs.\r\n+We will start by writing a simple program with a limited functionality to get familiar with the basics of DDlog.\r\n+Afterwards, over the course of this set of tutorials, we will gradually improve our application by applying more advanced techniques offered by DDlog.\r\n+\r\n+Tutorial #1 - Reachability Monitor\r\n+==================================\r\n+\r\n+In our first tutorial we are going to build a program that will calculate the reachability information in the network.\r\n+User will update link status between nodes through CLI and our program will calculate the rest.\r\n+The purpose of this program is to provide a simple interface to a network operator and return information regarding which node can reach which.\r\n+Thus, the only concern of network operator is to update link status without having to worry about doing those calculations themself.\r\n+We are going to test our program with the network consisting of four nodes: Menlo Park, Santa Barbara, Los Angeles, and Salt Lake City.\r\n+However, nothing prevents us from using the network comprised of hundreds of nodes.\r\n+\r\n+Let's start with defining our program in the DDlog language.\r\n+In our program we need to supply source node, destination node, and a link status between them.\r\n+Now we are ready to define our input relation :code:`Links`.\r\n+Let's create a file called :code:`t1_reachability_monitor.dl` and add there a following line representing input relation for our reachability monitor:\r\n+\r\n+.. code-block::\r\n+    \r\n+    input relation Links(src: string, dst: string, link_status: bool)\r\n+\r\n+However, for the reachability monitor to be useful it also should provide some output and not just ingest the data.\r\n+We want our program to output a list of nodes that are currently reachable based on the information in the relation :code:`Links`.\r\n+Thus, let's add an output relation :code:`ConnectedNodes` and provide rules how to calculate records in this relation *(mind the presence of the dot at the end of each rule)*.\r\n+To do that we are going to add few more lines to the :code:`t1_reachability_monitor.dl` so it will look as follows:\r\n+\r\n+.. code-block::\r\n+\r\n+    input relation Links(src: string, dst: string, link_status: bool)\r\n+    output relation ConnectedNodes(src: string, dst: string)\r\n+\r\n+    ConnectedNodes(src, dst) :- Links(src, dst, true).\r\n+    ConnectedNodes(src, dst) :- ConnectedNodes(src, intermediate_node),\r\n+                                Links(intermediate_node, dst, true).\r\n+\r\n+Let's briefly discuss the rule to calculate :code:`ConnectedNodes` relation.\r\n+First, we say that any two directly connected nodes such that the :code:`link_status` between them is :code:`true` belong to the :code:`ConnectedNodes` relation.\r\n+Furthermore, any two nodes are considered connected if there is path from the source node to the destination node such that all directly connected nodes along the path also have the :code:`link_status` between them to be :code:`true`.\r\n+Take a minute here to realize how easy it is to write such rule in DDlog.\r\n+While these rules may not require much effort in other programming languages, the distinct feature of DDlog is that the computing is done incrementally!\r\n+Isn't is amazing?\r\n+\r\n+With that done, let's compile and start our program.\r\n+We will feed our DDlog code to the DDlog compiler and it will generate a new folder.\r\n+This folder contains CLI so we can run our program as well as a library that we will need later for our C program.\r\n+Note, that on the first run it will take a while, but will be signifanctly faster afterwards.\r\n+After the code is compiled let's start a command-line so we can start playing with our program.\r\n+\r\n+.. code-block::\r\n+\r\n+    $ ddlog -i t1_reachability_monitor.dl\r\n+    $ cd t1_reachability_monitor_ddlog/ && cargo build --release\r\n+    $ ./target/release/t1_reachability_monitor_cli\r\n+\r\n+If we display the contents of the :code:`ConnectedNodes` relation we will see that this it is empty, which make sense as we haven't populated :code:`Links` relation with anything yet:\r\n+\r\n+.. code-block::\r\n+\r\n+    >> dump ConnectedNodes;\r\n+\r\n+To exit DDlog shell press `[CTRL+d]`.\r\n+If you are using `Windows Terminal` do not press `[CTRL+D]` (note capital `D`, i.e., `[CTRL+SHIFT+d]`) as it will open a new tab.\r\n+\r\n+Let's supply some input data.\r\n+We are going to insert several records into :code:`Links` relation.\r\n+But first let's define a simple network topology that we are going to work through.\r\n+To make our life more interesting (and just slightly more complicated) the links between nodes will not be bidirectional by default.\r\n+\r\n+.. image:: ./images/topology.jpg\r\n+\r\n+Note that DDlog is a `transaction-based`_ programming language.\r\n+Each transaction begins with a :code:`start` command and ends with a :code:`commit` command.\r\n+Let's start DDlog shell again and insert records to recreate the network topology above:\r\n+\r\n+.. _transaction-based: https://en.wikipedia.org/wiki/Transaction_processing\r\n+\r\n+.. code-block::\r\n+\r\n+    $ ./target/release/t1_reachability_monitor_cli\r\n+    >> start;\r\n+    >> insert Links(\"Menlo Park\", \"Santa Barbara\", true);\r\n+    >> insert Links(\"Menlo Park\", \"Salt Lake City\", true);\r\n+    >> insert Links(\"Santa Barbara\", \"Los Angeles\", true);\r\n+    >> insert Links(\"Los Angeles\", \"Santa Barbara\", true);\r\n+    >> insert Links(\"Los Angeles\", \"Salt Lake City\", true);\r\n+    >> insert Links(\"Salt Lake City\", \"Los Angeles\", true);\r\n+    >> commit;\r\n+    >> dump ConnectedNodes;\r\n+    ConnectedNodes{.src = \"Los Angeles\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Los Angeles\", .dst = \"Salt Lake City\"}\r\n+    ConnectedNodes{.src = \"Los Angeles\", .dst = \"Santa Barbara\"}\r\n+    ConnectedNodes{.src = \"Menlo Park\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Menlo Park\", .dst = \"Salt Lake City\"}\r\n+    ConnectedNodes{.src = \"Menlo Park\", .dst = \"Santa Barbara\"}\r\n+    ConnectedNodes{.src = \"Salt Lake City\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Salt Lake City\", .dst = \"Salt Lake City\"}\r\n+    ConnectedNodes{.src = \"Salt Lake City\", .dst = \"Santa Barbara\"}\r\n+    ConnectedNodes{.src = \"Santa Barbara\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Santa Barbara\", .dst = \"Salt Lake City\"}\r\n+    ConnectedNodes{.src = \"Santa Barbara\", .dst = \"Santa Barbara\"}\r\n+\r\n+In the output we can see all cities with direct links between them are connected.\r\n+Furthermore, as we specified in our DDlog code, if there is a path between two cities then they are also connected, e.g., Menlo Park is connected to Los Angeles.\r\n+However, some nodes are connected to themselves.\r\n+But why this happened?\r\n+If we take a closer look at our rules we can notice that this phenomenon actually make sense.\r\n+For example, Santa Barbara is reachable from Santa Barbara through Los Angeles.\r\n+While it is not necessarily horrible or wrong we may want to avoid it as it clutters the relation and the output.\r\n+More notably, we definitely don't want the network traffic go to Santa Barbara from Santa Barbara through Los Angeles (in the real world this actually may happen but this is a completely different topic).\r\n+Let's fix it by adding a filtering condition to the rule that disallows source and destination match each other.\r\n+Now, the rules for calculating :code:`ConnectedNodes` look as below and see how simple it is to do that in DDlog (note that only second rule was modified, the first stays intact):\r\n+\r\n+.. code-block::\r\n+\r\n+    $ cd ../ && cat t1_reachability_monitor.dl\r\n+    // Input relations\r\n+    input relation Links(src: string, dst: string, link_status: bool)\r\n+\r\n+    // Output relations\r\n+    output relation ConnectedNodes(src: string, dst: string)\r\n+\r\n+    /*\r\n+     * Rules to calculate `ConnectedNodes` relation\r\n+     */\r\n+    ConnectedNodes(src, dst) :- Links(src, dst, true).\r\n+    ConnectedNodes(src, dst) :- ConnectedNodes(src, intermediate_node),\r\n+                                Links(intermediate_node, dst, true), (src != dst).\r\n+\r\n+.. tip:: This is a tip on DDlog syntax concerning comments in the code.\r\n+\r\n+    DDlog supports C-style comments as you can see in the example above.\r\n+\r\n+As we have changed the DDlog program we need to recompile it.\r\n+\r\n+.. code-block::\r\n+\r\n+    $ ddlog -i t1_reachability_monitor.dl\r\n+    $ cd t1_reachability_monitor_ddlog/ && cargo build --release\r\n+    $ ./target/release/t1_reachability_monitor_cli\r\n+    <clip>\r\n+    >> dump ConnectedNodes;\r\n+    ConnectedNodes{.src = \"Los Angeles\", .dst = \"Salt Lake City\"}\r\n+    ConnectedNodes{.src = \"Los Angeles\", .dst = \"Santa Barbara\"}\r\n+    ConnectedNodes{.src = \"Menlo Park\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Menlo Park\", .dst = \"Salt Lake City\"}\r\n+    ConnectedNodes{.src = \"Menlo Park\", .dst = \"Santa Barbara\"}\r\n+    ConnectedNodes{.src = \"Salt Lake City\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Salt Lake City\", .dst = \"Santa Barbara\"}\r\n+    ConnectedNodes{.src = \"Santa Barbara\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Santa Barbara\", .dst = \"Salt Lake City\"}\r\n+\r\n+Perfect!\r\n+Now it looks exactly as we expected!\r\n+Rigth before we jump to what this tutorial promised let's look at one more example that demonstrates incremental nature of DDlog.\r\n+\r\n+.. code-block::\r\n+\r\n+    $ ./target/release/t1_reachability_monitor_cli\r\n+    >> start;\r\n+    >> insert Links(\"Menlo Park\", \"Santa Barbara\", true);\r\n+    >> insert Links(\"Menlo Park\", \"Salt Lake City\", true);\r\n+    >> insert Links(\"Santa Barbara\", \"Los Angeles\", true);\r\n+    >> insert Links(\"Los Angeles\", \"Santa Barbara\", true);\r\n+    >> insert Links(\"Los Angeles\", \"Salt Lake City\", true);\r\n+    >> insert Links(\"Salt Lake City\", \"Los Angeles\", true);\r\n+    >> commit;\r\n+    >> dump ConnectedNodes;\r\n+    ConnectedNodes{.src = \"Los Angeles\", .dst = \"Salt Lake City\"}\r\n+    ConnectedNodes{.src = \"Los Angeles\", .dst = \"Santa Barbara\"}\r\n+    ConnectedNodes{.src = \"Menlo Park\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Menlo Park\", .dst = \"Salt Lake City\"}\r\n+    ConnectedNodes{.src = \"Menlo Park\", .dst = \"Santa Barbara\"}\r\n+    ConnectedNodes{.src = \"Salt Lake City\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Salt Lake City\", .dst = \"Santa Barbara\"}\r\n+    ConnectedNodes{.src = \"Santa Barbara\", .dst = \"Los Angeles\"}\r\n+    ConnectedNodes{.src = \"Santa Barbara\", .dst = \"Salt Lake City\"}\r\n+    >> start;\r\n+    >> delete Links(\"Santa Barbara\", \"Los Angeles\", true);\r\n+    >> commit dump_changes;\r\n+    ConnectedNodes:\r\n+    ConnectedNodes{.src = \"Santa Barbara\", .dst = \"Los Angeles\"}: -1\r\n+    ConnectedNodes{.src = \"Santa Barbara\", .dst = \"Salt Lake City\"}: -1\r\n+\r\n+DDlog incrementally computed only changes that happened and printed them.\r\n+The \"minus one\" here is called :code:`weight` and indicates that the respective record was deleted.\r\n+While the benefits of incremental computation ain't noticeable in our small example, they manifest themselves on a large scale and can make a substantial difference.\r\n+\r\n+Now we are finally realdy to start writing some C code!\r\n+We are going to start with something simple yet important.\r\n+Our initial C program will connect to DDlog program, insert one additional record to :code:`Links` relation, and print the content of :code:`ConnectedNodes` relation.\r\n+Let's create :code:`reachability_monitor.c` file next to our DDlog program's code.\r\n+The full source code is available in the provided :code:`t1_reachability_monitor.c` file.\r\n+The further discussion will refer to specific lines in that code.\r\n+\r\n+Let's compile the code first and then delve into the discussion of compilation and the code.\r\n+\r\n+.. code-block::\r\n+\r\n+    $ cd ../\r\n+    $ gcc reachability_monitor.c t1_reachability_monitor_ddlog/target/release/libt1_reachability_monitor_ddlog.a -It1_reachability_monitor_ddlog/ -lpthread -ldl -lm\r\n+\r\n+\r\n+.. tip:: This is a tip on a compilation failure caused by a missing package.\r\n+\r\n+    If the compilation fails, you may want to make sure that you have :code:`libc6-dev` package installed.\r\n+    This is the package name for Ubuntu 18.04.\r\n+    For other releases and operating systems you may need to refer the respective documentation (or Google Search).\r\n+\r\n+When we compiled our DDlog program, DDlog compiler automatically generated a static library that contains DDlog API for C.\r\n+Thus, we need to link it with our program.\r\n+This API is defined in the :code:`ddlog.h` header file generated by the DDlog compiler and we provide the path to it using the :code:`-I` flag.\r\n+Furthermore, :code:`ddlog.h` is heavily documented and is worth going through as it explains API in great details.\r\n+\r\n+Let's run the compiled code, provide an input, and see what happens:\r\n+\r\n+.. code-block::\r\n+\r\n+    $ ./a.out\r\n+    Links table ID: 1\r\n+    ConnectedNodes table ID: 0\r\n+    Please enter source name > Menlo Park\r\n+    Please enter destination name > Santa Barbara\r\n+    Please enter the link status between source and destination > true\r\n+    Inserting the following record: Links{\"Menlo Park\", \"Santa Barbara\", true}\r\n+    Content of the ConnectedNodes relation:\r\n+    Inserted record: ConnectedNodes{.src = \"Menlo Park\", .dst = \"Santa Barbara\"}\r\n+\r\n+We just executed our first DDlog-C application!\r\n+It asked us for some input (that we, of course, provided) and then produced an output.\r\n+More specifically, this application printed the content of the :code:`ConnectedNodes` relation.\r\n+\r\n+With that, let's take a closer look on the code in the provided file and go over it.\r\n+To make this process easier, we put comments in the code, which should also help to navigate the code (just search for the respective text).\r\n+We will go through the code in small snippets and will skip some minor parts, which are purely related to the C code and are self-explanatory.\r\n+\r\n+.. code-block:: c\r\n+\r\n+    // Start the DDlog program and connect to it\r\n+    ddlog_prog prog = ddlog_run(1, true, NULL, NULL);\r\n+    if (prog == NULL) {\r\n+        fprintf(stderr, \"failed to initialize DDlog program\\n\");\r\n+        exit(EXIT_FAILURE);\r\n+    };\r\n+\r\n+We begin with starting the DDlog program and connecting to it using :code:`ddlog_run()` function.\r\n+Note that it returns a pointer that stored in :code:`prog` variable, which we will use later in the code.\r\n+We need to supply four arguments to this function:\r\n+\r\n+#. Number of worker threads for the DDlog program. In our case, one worker thread is more than sufficient.\r\n+#. Flag to specify that we want to store the copy of output tables in the DDlog so we can use :code:`ddlog_dump_table()` function. If you have an application of streaming nature then you may want to set this flag to :code:`false` to avoid imposed memory and CPU overheads.\r\n+#. A pointer to store the initial state of the program, i.e., content of the output relations. As we start from a clean slate we set this pointer to :code:`NULL`.\r\n+#. A callback to use for redirecting diagnostic messages from DDlog to it. We currently don't need that so we set this one to :code:`NULL`.\r\n+\r\n+.. code-block:: c\r\n+\r\n+    // Get table IDs for `Links` and `ConnectedNodes` relations\r\n+    table_id LinksTableID = ddlog_get_table_id(\"Links\");\r\n+    table_id ConnectedNodesTableID = ddlog_get_table_id(\"ConnectedNodes\");\r\n+\r\n+DDlog stores relations in tables.\r\n+Thus, to work with those tables we will need their IDs.\r\n+\r\n+.. code-block:: c\r\n+\r\n+    // Prompt user to enter record values\r\n+    // and collect them from the standard input\r\n+    printf(\"Please enter source name > \");\r\n+    if (getline(&src_line_ptr, &n_src, stdin) < 0) {\r\n+        if (src_line_ptr != NULL) free(src_line_ptr);\r\n+        return -EINVAL;\r\n+    }\r\n+    printf(\"Please enter destination name > \");\r\n+    if (getline(&dst_line_ptr, &n_dst, stdin) < 0) {\r\n+        free(src_line_ptr);\r\n+        if (dst_line_ptr != NULL) free(dst_line_ptr);\r\n+        return -EINVAL;\r\n+    }\r\n+    printf(\"Please enter the link status between source and destination > \");\r\n+    if (getline(&link_status_line_ptr, &n_link_status, stdin) < 0) {\r\n+        free(src_line_ptr);\r\n+        free(dst_line_ptr);\r\n+        if (link_status_line_ptr != NULL) free(link_status_line_ptr);\r\n+        return -EINVAL;\r\n+    }\r\n+\r\n+In this tutorial, application will prompt user to enter values for the record and collect them.\r\n+\r\n+.. code-block:: c\r\n+\r\n+    // Parsing value for the link status\r\n+    // Anything different from `true` will be considered as `false`\r\n+    if (strlen(link_status_line_ptr) == 5) {\r\n+        link_status = (strncmp(\"true\", link_status_line_ptr, 4) == 0) ? true : false;\r\n+    }\r\n+\r\n+For the sake of simplicity, we will view any input entered by the user that differs from :code:`true` as :code:`false`.\r\n+\r\n+.. code-block:: c\r\n+\r\n+    // Creating record values in the DDlog format\r\n+    ddlog_record *src = ddlog_string(src_line_ptr);\r\n+    ddlog_record *dst = ddlog_string(dst_line_ptr);\r\n+    ddlog_record *lstatus = ddlog_bool(link_status);\r\n+\r\n+One of the features of the DDlog is being a `strongly-typed language`_.\r\n+Partially, due to that reason we cannot just pass anything to our DDlog program.\r\n+So we have to convert C objects to the DDlog objects first.\r\n+\r\n+.. _strongly-typed language: https://en.wikipedia.org/wiki/Strong_and_weak_typing\r\n+\r\n+.. code-block:: c\r\n+\r\n+    // Constructing a single record from separate values\r\n+    ddlog_record **struct_args;\r\n+    struct_args = (ddlog_record**)malloc(3 * sizeof(ddlog_record*));\r\n+    struct_args[0] = src;\r\n+    struct_args[1] = dst;\r\n+    struct_args[2] = lstatus;\r\n+    ddlog_record *new_record = ddlog_struct(\"Links\", struct_args, 3);\r\n+\r\n+Once, we have DDlog values in place we need to construct a record that we will insert into the :code:`Links` relation.\r\n+For that purpose we can use :code:`ddlog_struct()` function.\r\n+It takes three arguments:\r\n+\r\n+#. Name of the relation, which this record belongs to.\r\n+#. A pointer to an array of :code:`ddlog_record`'s.\r\n+#. Length of the aformentioned array.\r\n+\r\n+You don't have to dynamically allocate memory for the :code:`struct_args` in this example.\r\n+As we know exactly how many elements this array contains we can simply put it on the stack.\r\n+\r\n+.. code-block:: c\r\n+\r\n+    // Let's print the record that we are about to insert\r\n+    // to the `Links` relation\r\n+    char *record_to_insert_as_string = ddlog_dump_record(new_record);\r\n+    printf(\"Inserting the following record: %s\\n\", record_to_insert_as_string);\r\n+    ddlog_string_free(record_to_insert_as_string);\r\n+\r\n+Using the :code:`ddlog_dump_record()` function from DDlog API we can retrieve the record as a string and print it to make sure everything looks right.\r\n+Note, that this function will allocate some memory on a heap and we are responsible for freeing it.\r\n+\r\n+.. code-block:: c\r\n+\r\n+    // Start transaction\r\n+    if (ddlog_transaction_start(prog) < 0) {\r\n+        fprintf(stderr, \"failed to start transaction\\n\");\r\n+        exit(EXIT_FAILURE);\r\n+    };\r\n+\r\n+As mentioned before, DDlog is a transaction-based programming language.\r\n+Thus, before inserting a new record into a relation we need to start transaction.\r\n+\r\n+.. code-block:: c\r\n+\r\n+    // Create `insert` command\r\n+    ddlog_cmd *cmd = ddlog_insert_cmd(LinksTableID, new_record);\r\n+    if (cmd == NULL) {\r\n+        fprintf(stderr, \"failed to create insert command\\n\");\r\n+        exit(EXIT_FAILURE);\r\n+    }\r\n+\r\n+Next step is to create an insertion DDlog command using :code:`ddlog_insert_cmd()` function.\r\n+We need to provide this function with the table ID of a target relation and a record that we want to insert into that relation.\r\n+\r\n+.. code-block:: c\r\n+\r\n+    // Apply updates to the relation with records\r\n+    // specified in the provided command `cmd`\r\n+    if (ddlog_apply_updates(prog, &cmd, 1) < 0) {\r\n+        fprintf(stderr, \"failed to apply updates\\n\");\r\n+        exit(EXIT_FAILURE);\r\n+    };\r\n+\r\n+Once we have command ready we can apply it to our DDlog program using :code:`ddlog_apply_updates()` function.\r\n+We need to supply program handle, array of commands to be applied, and the length of this array.\r\n+In our case, we only have a single command to apply.\r\n+However, it is possible to pass multiple commands to a single call to the :code:`ddlog_apply_update()` function.\r\n+It helps avoiding cluttering code if you want to apply multiple commands.\r", "originalCommit": "56e119846ee6463c1625a8d748648dd7215bed8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "25440c49fdaa543b754741c230b846c6554ce987", "url": "https://github.com/vmware/differential-datalog/commit/25440c49fdaa543b754741c230b846c6554ce987", "message": "[WIP] adding initial files for the C tutorial.", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "933d7e0dbf201674eb62b9a92e730518cf5c53de", "url": "https://github.com/vmware/differential-datalog/commit/933d7e0dbf201674eb62b9a92e730518cf5c53de", "message": "added an image for the topology and made a respective change in the text", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "e747c9ffb3a96e07576eaec763d9499a290d556d", "url": "https://github.com/vmware/differential-datalog/commit/e747c9ffb3a96e07576eaec763d9499a290d556d", "message": "[typo] renamed files as their names had typos", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "654bef1db45322355dace2e7f170c896426e36b2", "url": "https://github.com/vmware/differential-datalog/commit/654bef1db45322355dace2e7f170c896426e36b2", "message": "[refactor] replacing tabs with four spaces; there was a mix of both actually", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "32222ca722c30723ad4861b8c2aef0ae07c905e8", "url": "https://github.com/vmware/differential-datalog/commit/32222ca722c30723ad4861b8c2aef0ae07c905e8", "message": "[fix|refactor] using a better name for the record variable; deallocating string used for the record representation", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "abca7cde488f92e145b4858edc98c1cc840a88b1", "url": "https://github.com/vmware/differential-datalog/commit/abca7cde488f92e145b4858edc98c1cc840a88b1", "message": "[fix|refactor] with updated ddlog c api there were some minor changes to ddlog_run(); resetting n for the getline() as it getline() will dynamically allocate space for the buffer when not only buffer points to null but also n is 0; minor refactoring to have separate variables for n for getline() functions; when getline() fails - space for buffer was still possible allocated so checking it and deallocating memory; while not a huge issue but still freeing pointers when subsequent getline() invokations fail", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "b162722f4b2844b8b9f9fe6e6ff27b6301cee321", "url": "https://github.com/vmware/differential-datalog/commit/b162722f4b2844b8b9f9fe6e6ff27b6301cee321", "message": "[refactor|fix] removing hard-coded table ID; also ddlog_dump_record() needs the string it returs to be deallocated so handling that now", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "b34ed93264bee1cdc9eaa577798e89991119d3cd", "url": "https://github.com/vmware/differential-datalog/commit/b34ed93264bee1cdc9eaa577798e89991119d3cd", "message": "[typo|refactor] forgot to capitalize word in the comment; no need to have separate arrays for commands when there is only one command", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "7fe81d07393589fd4853776d527a017b5c41a742", "url": "https://github.com/vmware/differential-datalog/commit/7fe81d07393589fd4853776d527a017b5c41a742", "message": "[fix] I had just an integer when it should be  but as I don't need to pass any arguments to the callback function, I extract value of the null pointer and use it as an argument", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "f91eb013f1b7cbbc440dbeb599392aa86bdf9313", "url": "https://github.com/vmware/differential-datalog/commit/f91eb013f1b7cbbc440dbeb599392aa86bdf9313", "message": "[refactor] removing hard-coded value for the table id", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "bd8216c64543d77b2a69f283ade0c576b36f6189", "url": "https://github.com/vmware/differential-datalog/commit/bd8216c64543d77b2a69f283ade0c576b36f6189", "message": "[refactor] forgot to remove include that I used for testing", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "3085592039b5713842a289377f72cb9b79f449a8", "url": "https://github.com/vmware/differential-datalog/commit/3085592039b5713842a289377f72cb9b79f449a8", "message": "[refactor] being consistent in pointer variable declarations", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "08f43247f16a1302cd8616f06e080c475c714b34", "url": "https://github.com/vmware/differential-datalog/commit/08f43247f16a1302cd8616f06e080c475c714b34", "message": "[fix] making code more secure; while the buffer we get from getline() is supposed to be null-terminated, being a bit more defensive won't hurt", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "409c1690c86dee6941aaca5a9817aa616730769e", "url": "https://github.com/vmware/differential-datalog/commit/409c1690c86dee6941aaca5a9817aa616730769e", "message": "[bug] first, the Links relation is input relation so we can't print its contents using ddlog_dump_table() as I understand but we don't need it now; then 'do_store' should be set to 'true' so ddlog will store the contents and will allow to print us them, otherwise, the output of  is empty", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "8d20e73bd52464891cefbbacb95a581ed9f9b282", "url": "https://github.com/vmware/differential-datalog/commit/8d20e73bd52464891cefbbacb95a581ed9f9b282", "message": "[refactor] more consistency with pointer variable declaration", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "026a1b26f679d1e070ad87a99c3cbfde1ed26b3e", "url": "https://github.com/vmware/differential-datalog/commit/026a1b26f679d1e070ad87a99c3cbfde1ed26b3e", "message": "[doc] incorporated most of the Mihai's comments", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "ee2ef5a179f32fdfcc27a6b360473290cb0e26c1", "url": "https://github.com/vmware/differential-datalog/commit/ee2ef5a179f32fdfcc27a6b360473290cb0e26c1", "message": "[refactor] checking if GitHub can process line numbers", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "4a0123121073e22f0b6f8f5a15188a922cda8bd5", "url": "https://github.com/vmware/differential-datalog/commit/4a0123121073e22f0b6f8f5a15188a922cda8bd5", "message": "Update c_tutorial.rst\n\nwill having the same indentation for options as text help?", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "3f34efb9c68c7f0b0f1d257fa377d1fc6eaf5e35", "url": "https://github.com/vmware/differential-datalog/commit/3f34efb9c68c7f0b0f1d257fa377d1fc6eaf5e35", "message": "[bug] no...github does not seem to support :linenos: too...", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "231cdab45009d8ba669212f7db9a7c4ef2da8102", "url": "https://github.com/vmware/differential-datalog/commit/231cdab45009d8ba669212f7db9a7c4ef2da8102", "message": "[bug] removing the ground facts from the ddlog program as they won't be changeable", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "32b8bf22a85f66633cbefaf3c1eb248267a59692", "url": "https://github.com/vmware/differential-datalog/commit/32b8bf22a85f66633cbefaf3c1eb248267a59692", "message": "[refactor] replacing single line comment with a multi line comment for example purposes", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "fcefe6b7b007b7d159dc5c56218ca6756e50c6f7", "url": "https://github.com/vmware/differential-datalog/commit/fcefe6b7b007b7d159dc5c56218ca6756e50c6f7", "message": "[refactor] renaming C file for consistency purposes", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "69998804e83262052c64c8c3e30c406f37eb66f9", "url": "https://github.com/vmware/differential-datalog/commit/69998804e83262052c64c8c3e30c406f37eb66f9", "message": "[refactor] being more consistent with the code - for exit_failure using exit() instead of return, which is also is in the cppreferences examples", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "6f88af362875c88820974787201772e75611170f", "url": "https://github.com/vmware/differential-datalog/commit/6f88af362875c88820974787201772e75611170f", "message": "[refactor] minor text/comment improvements", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "bcf834af9f10735b9cf8acfaf9bec4fcfd4f4ea7", "url": "https://github.com/vmware/differential-datalog/commit/bcf834af9f10735b9cf8acfaf9bec4fcfd4f4ea7", "message": "[refactor] minor improvement in comments' text; also dynamically allocated memory for the", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "8b66b6216d45c82000106896a2f615e77ab2cc52", "url": "https://github.com/vmware/differential-datalog/commit/8b66b6216d45c82000106896a2f615e77ab2cc52", "message": "[refactor] changed comments to better reflect what is happening; moved freeing the memory outside of the transaction for a bit more consistency (we created/populated those variables also outside of the transaction)", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "464b60f85f36ba66bd1377b5d1e5d2853e73bd56", "url": "https://github.com/vmware/differential-datalog/commit/464b60f85f36ba66bd1377b5d1e5d2853e73bd56", "message": "[bugfix] removed the check for the record to be not NULL as it does not really do anything useful; slightly cleaned the code - removed comment; a  should be used for freeing memory for  and not ddlog_free()", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "ed343596b5b141e40436b0d7fbc575c17115d2fa", "url": "https://github.com/vmware/differential-datalog/commit/ed343596b5b141e40436b0d7fbc575c17115d2fa", "message": "[doc] added discussion of the C code; some minor language changes", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "4f09f521c77b3fa73a6148f780b60f645948812a", "url": "https://github.com/vmware/differential-datalog/commit/4f09f521c77b3fa73a6148f780b60f645948812a", "message": "[doc|bugfix] trying to fix links as they are not properly showing up in GitHub", "committedDate": "2021-02-18T18:28:18Z", "type": "commit"}, {"oid": "8f1eab58f092f10f2b6e90a2c00eb05a34c22a7c", "url": "https://github.com/vmware/differential-datalog/commit/8f1eab58f092f10f2b6e90a2c00eb05a34c22a7c", "message": "c_tutorial.rs: Typo.", "committedDate": "2021-02-18T18:37:04Z", "type": "commit"}, {"oid": "15760e2320a33c238b46c076c25b94c626752360", "url": "https://github.com/vmware/differential-datalog/commit/15760e2320a33c238b46c076c25b94c626752360", "message": "Add links to the C tutorial.\n\nMoved the C tutorial to the `doc` directory, added links to it from the\nREADME and the main DDlog tutorial.", "committedDate": "2021-02-18T18:41:52Z", "type": "commit"}, {"oid": "72b6d2a745452412fa3d0dd0e74bdbbd07e3167c", "url": "https://github.com/vmware/differential-datalog/commit/72b6d2a745452412fa3d0dd0e74bdbbd07e3167c", "message": "c_tutorial.rst: Incorporate review comments.", "committedDate": "2021-02-18T18:55:54Z", "type": "commit"}, {"oid": "6f341a3eb79f588a979b263309a127a7778acfc7", "url": "https://github.com/vmware/differential-datalog/commit/6f341a3eb79f588a979b263309a127a7778acfc7", "message": "Add C tutorial to the test suite.\n\n- Added a script to run the C tutorial.\n- Added the tutorial to the main DDlog test suite.\n- Run C tutorial as a CI job", "committedDate": "2021-02-18T19:38:22Z", "type": "forcePushed"}, {"oid": "82d8f8327a3f09d50a8b488875504801cfdedf1d", "url": "https://github.com/vmware/differential-datalog/commit/82d8f8327a3f09d50a8b488875504801cfdedf1d", "message": "Add C tutorial to the test suite.\n\n- Added a script to run the C tutorial.\n- Added the tutorial to the main DDlog test suite.\n- Run C tutorial as a CI job", "committedDate": "2021-02-18T20:20:38Z", "type": "commit"}, {"oid": "82d8f8327a3f09d50a8b488875504801cfdedf1d", "url": "https://github.com/vmware/differential-datalog/commit/82d8f8327a3f09d50a8b488875504801cfdedf1d", "message": "Add C tutorial to the test suite.\n\n- Added a script to run the C tutorial.\n- Added the tutorial to the main DDlog test suite.\n- Run C tutorial as a CI job", "committedDate": "2021-02-18T20:20:38Z", "type": "forcePushed"}]}