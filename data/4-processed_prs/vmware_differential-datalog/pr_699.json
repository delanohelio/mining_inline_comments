{"pr_number": 699, "pr_title": "Streams and multisets.", "pr_createdAt": "2020-07-09T07:11:09Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/699", "timeline": [{"oid": "914f4a435bdbc4a5e5c2d001219fce638f859bb2", "url": "https://github.com/vmware/differential-datalog/commit/914f4a435bdbc4a5e5c2d001219fce638f859bb2", "message": "Test for #593.\n\nAdded test for #593, which is resolved with the introduction of type inference\nengine.", "committedDate": "2020-07-07T05:48:02Z", "type": "commit"}, {"oid": "ba43e716823139cf30de0fcff8351f1432e776a7", "url": "https://github.com/vmware/differential-datalog/commit/ba43e716823139cf30de0fcff8351f1432e776a7", "message": "Streams and multisets.\n\nSo far, all DDlog relations implemented set semantics.  A set can\ncontain at most one instance of each value.  If the same value is\ninserted in the relation multiple times, all but the last insertion are\nignored (or fail if the relation has a primary key).  Likewise, repeated\ndeletions are ignored or fail.  Similarly, DDlog ensures that output\nrelations behave as sets, e.g., the same value cannot be inserted\nmultiple times, unless it is deleted in between.  While this behavior\nmatches the requirements of most applications, there are cases when\nrelations with non-unit multiplicities are useful.  Consider, for\nexample, an input relation that receives inputs from two sources, that\ncan both produce the same value (at which point its multiplicity is 2).\nThe value should only be removed from the relation once it has been\nremoved from both sources, i.e., its multiplicity drops to 0.  In other\nwords, we would like the relation to have *multiset*, rather than set\nsemantics.\n\nThis commit introduces support for multisets that are declared using the\n`multiset` keyword instead of `relation`:\n\n```\ninput multiset MSetIn(x: u32)\n```\n\nValues in a multiset relation can have both positive and negative\nmultiplicities: deleting a non-existent value introduces the value with\nmultiplicity `-1`.  Therefore, such relations can be more precisely\ndescribed as *generalized*, rather than ordinary *multisets*.  An output\nrelation can also be declared as `multiset`, in which case DDlog can\nderive the same output value multiple times, so that `dump` and `commit\ndump_changes` commands will output records with non-unit multiplicities:\n\n```\noutput multiset MSetOut(x: u32)\nMSetOut(x) :- MSetIn(x).\n```\n\nThe following scenario illustrates the semantics of multisets:\n\n```\n start;\n insert MSetIn(0),\n # appear twice in MSetOut.\n insert MSetIn(1),\n insert MSetIn(1),\n commit dump_changes;\n # expected output:\n # MSetOut:\n # MSetOut{.x = 0}: +1\n # MSetOut{.x = 1}: +2\n start;\n # Add one more instance of the same record.\n insert MSetIn(1), commit dump_changes;\n # expected output:\n # MSetOut:\n # MSetOut{.x = 1}: +1\n start;\n # Delete one instance of the record; we're down to 2.\n delete MSetIn(1),\n commit dump_changes;\n # expected output:\n # MSetOut:\n # MSetOut{.x = 1}: -1\n dump MSetOut;\n # expected output:\n # MSetOut{.x = 0} +1\n # MSetOut{.x = 1} +2\n ```\n\nOutput `multiset`s are more memory-efficient than `relation`s.  DDlog enforces\nset semantics by using the Differential Dataflow `distinct` operator, which\ninternally maintains an indexed representation of the output relation.\nMultisets avoid this overhead.\n\nStreams are yet another new kind of relation that are similar to multisets\nwith one additional optimization.  Normally, DDlog stores a copy of the entire\ncontents of an `input relation` or `input multiset`.  This copy is used to\nimplement the `clear` command, which removes everything from the relation.  In\naddition, it is necessary to enforce the set semantics on `relation`s.  A stream\nis a multiset, whose contents is not cached by DDlog, thus reducing the memory\nfootprint of the program.  As a result, it is illegal to use the `clear` command\non a stream.\n\n```\n// Declare an input stream.\ninput stream StreamIn(x: u32)\n```\n\nThis change affects all language APIs, as all API callbacks (on-commit,\non-commit-dump-changes, relation-dump) can observe records with non-unit\nmultiplicities, so we replace Boolean polarity with weight of type `ssize_t`.", "committedDate": "2020-07-09T06:48:38Z", "type": "commit"}, {"oid": "e164e836b5ed0a8c6027d88b2b7e0af3138df666", "url": "https://github.com/vmware/differential-datalog/commit/e164e836b5ed0a8c6027d88b2b7e0af3138df666", "message": "tutorial.md: Document type inference.\n\n- Added a couple of paragraphs on type inference and type annotations.\n- Added a \"pro tip\" to use `bigint` sparingly, as I keep seeing DDlog\n  code that uses bigint's for no good reason.", "committedDate": "2020-07-09T06:48:38Z", "type": "commit"}, {"oid": "b9b1a3d24ccd6d9514dc9d284caf565c7a29f50b", "url": "https://github.com/vmware/differential-datalog/commit/b9b1a3d24ccd6d9514dc9d284caf565c7a29f50b", "message": "Tutorial section on multisets and streams.", "committedDate": "2020-07-09T06:48:38Z", "type": "commit"}, {"oid": "84d22e271466d221b613c16af8121b3562863798", "url": "https://github.com/vmware/differential-datalog/commit/84d22e271466d221b613c16af8121b3562863798", "message": "Don't run souffle tests in Travis.\n\nThe test no longer works on MacOS, as subversion installation fails in\nTravis.  Since these tests run in gitlab anyway, there is no hard in\ndisabling them.", "committedDate": "2020-07-09T07:05:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM0NTE1Mg==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452345152", "bodyText": "I hope you are still running this in the other pipeline", "author": "mbudiu-vmw", "createdAt": "2020-07-09T16:32:54Z", "path": ".travis.yml", "diffHunk": "@@ -43,7 +43,7 @@ cache:\n \n env:\n    - TOOL=stack TEST_SUITE='-p tutorial' BUILD_BINARY=1\n-   - TOOL=run_souffle_tests\n+   # - TOOL=run_souffle_tests", "originalCommit": "84d22e271466d221b613c16af8121b3562863798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM0NjMxNg==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452346316", "bodyText": "I would be more explicit about the semantics of deletions.", "author": "mbudiu-vmw", "createdAt": "2020-07-09T16:34:59Z", "path": "doc/tutorial/tutorial.md", "diffHunk": "@@ -1208,6 +1249,99 @@ multiple times for different input/output relations).\n Several useful graph transformers are declared in `lib/graph.dl` and implemented in\n `lib/graph.rs`\n \n+## Multisets and streams\n+\n+All DDlog relations considered so far implement set semantics.  A set can contain\n+at most one instance of each value.  If the same value is inserted in the relation\n+multiple times, all but the last insertion are ignored (or fail if the relation\n+has a primary key).  Likewise, repeated deletions are ignored or fail.  Similarly,\n+DDlog ensures that output relations behave as sets, e.g., the same value cannot", "originalCommit": "84d22e271466d221b613c16af8121b3562863798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM0OTc4NA==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452349784", "bodyText": "I would refrain from introducing more terminology; one name is enough. Just say that multisets can contain a negative count as well, and that one can accurately think of them as maps from elements to integer counts.", "author": "mbudiu-vmw", "createdAt": "2020-07-09T16:40:32Z", "path": "doc/tutorial/tutorial.md", "diffHunk": "@@ -1208,6 +1249,99 @@ multiple times for different input/output relations).\n Several useful graph transformers are declared in `lib/graph.dl` and implemented in\n `lib/graph.rs`\n \n+## Multisets and streams\n+\n+All DDlog relations considered so far implement set semantics.  A set can contain\n+at most one instance of each value.  If the same value is inserted in the relation\n+multiple times, all but the last insertion are ignored (or fail if the relation\n+has a primary key).  Likewise, repeated deletions are ignored or fail.  Similarly,\n+DDlog ensures that output relations behave as sets, e.g., the same value cannot\n+be inserted multiple times, unless it is deleted in between.\n+\n+While this behavior matches the requirements of most applications, there are\n+cases when relations with non-unit multiplicities are useful.  Consider, for\n+example, an input relation that receives inputs from two sources, that can both\n+produce the same value (at which point its multiplicity is 2).  The value should only be\n+removed from the relation once it has been removed from both sources, i.e., its\n+multiplicity drops to 0.  In other words, we would like the relation to have\n+*multiset*, rather than set semantics.  Such a relation can be declared by using\n+the `multiset` keyword instead of `relation`:\n+\n+```\n+input multiset MSetIn(x: u32)\n+```\n+\n+Values in a multiset relation can have both positive and negative\n+multiplicities: deleting a non-existent value introduces the value with\n+multiplicity `-1`.  Therefore, such relations can be more precisely described", "originalCommit": "84d22e271466d221b613c16af8121b3562863798", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1MDQwNA==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452350404", "bodyText": "BTW: I don't know how much people have to worry about overflow of these counts. Ideally the implementation would switch to bigint if a counter is too large...", "author": "mbudiu-vmw", "createdAt": "2020-07-09T16:41:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM0OTc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1MDc2Mw==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452350763", "bodyText": "Shouldn't you instead say that all relations can be multisets?", "author": "mbudiu-vmw", "createdAt": "2020-07-09T16:42:08Z", "path": "doc/tutorial/tutorial.md", "diffHunk": "@@ -1208,6 +1249,99 @@ multiple times for different input/output relations).\n Several useful graph transformers are declared in `lib/graph.dl` and implemented in\n `lib/graph.rs`\n \n+## Multisets and streams\n+\n+All DDlog relations considered so far implement set semantics.  A set can contain\n+at most one instance of each value.  If the same value is inserted in the relation\n+multiple times, all but the last insertion are ignored (or fail if the relation\n+has a primary key).  Likewise, repeated deletions are ignored or fail.  Similarly,\n+DDlog ensures that output relations behave as sets, e.g., the same value cannot\n+be inserted multiple times, unless it is deleted in between.\n+\n+While this behavior matches the requirements of most applications, there are\n+cases when relations with non-unit multiplicities are useful.  Consider, for\n+example, an input relation that receives inputs from two sources, that can both\n+produce the same value (at which point its multiplicity is 2).  The value should only be\n+removed from the relation once it has been removed from both sources, i.e., its\n+multiplicity drops to 0.  In other words, we would like the relation to have\n+*multiset*, rather than set semantics.  Such a relation can be declared by using\n+the `multiset` keyword instead of `relation`:\n+\n+```\n+input multiset MSetIn(x: u32)\n+```\n+\n+Values in a multiset relation can have both positive and negative\n+multiplicities: deleting a non-existent value introduces the value with\n+multiplicity `-1`.  Therefore, such relations can be more precisely described\n+as *generalized*, rather than ordinary *multisets*.\n+\n+An output relation can also be declared as `multiset`, in which case DDlog", "originalCommit": "84d22e271466d221b613c16af8121b3562863798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1MTk0MQ==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452351941", "bodyText": "I would say that \"Perhaps surprisingly, programs using multisets are more efficient than programs sets; internally the implementation uses only multisets, and converts them to sets when needed using an expensive \"distinct\" operator\".", "author": "mbudiu-vmw", "createdAt": "2020-07-09T16:44:09Z", "path": "doc/tutorial/tutorial.md", "diffHunk": "@@ -1208,6 +1249,99 @@ multiple times for different input/output relations).\n Several useful graph transformers are declared in `lib/graph.dl` and implemented in\n `lib/graph.rs`\n \n+## Multisets and streams\n+\n+All DDlog relations considered so far implement set semantics.  A set can contain\n+at most one instance of each value.  If the same value is inserted in the relation\n+multiple times, all but the last insertion are ignored (or fail if the relation\n+has a primary key).  Likewise, repeated deletions are ignored or fail.  Similarly,\n+DDlog ensures that output relations behave as sets, e.g., the same value cannot\n+be inserted multiple times, unless it is deleted in between.\n+\n+While this behavior matches the requirements of most applications, there are\n+cases when relations with non-unit multiplicities are useful.  Consider, for\n+example, an input relation that receives inputs from two sources, that can both\n+produce the same value (at which point its multiplicity is 2).  The value should only be\n+removed from the relation once it has been removed from both sources, i.e., its\n+multiplicity drops to 0.  In other words, we would like the relation to have\n+*multiset*, rather than set semantics.  Such a relation can be declared by using\n+the `multiset` keyword instead of `relation`:\n+\n+```\n+input multiset MSetIn(x: u32)\n+```\n+\n+Values in a multiset relation can have both positive and negative\n+multiplicities: deleting a non-existent value introduces the value with\n+multiplicity `-1`.  Therefore, such relations can be more precisely described\n+as *generalized*, rather than ordinary *multisets*.\n+\n+An output relation can also be declared as `multiset`, in which case DDlog\n+can derive the same output value multiple times, so that `dump` and\n+`commit dump_changes` commands will output records with non-unit multiplicities:\n+\n+```\n+output multiset MSetOut(x: u32)\n+MSetOut(x) :- MSetIn(x).\n+```\n+\n+The following scenario illustrates the semantics of multisets:\n+\n+```\n+start;\n+\n+insert MSetIn(0),\n+# Insert the same value twice; due to the multiset semantics, it will appear twice in MSetOut.\n+insert MSetIn(1),\n+insert MSetIn(1),\n+commit dump_changes;\n+# expected output:\n+# MSetOut:\n+# MSetOut{.x = 0}: +1\n+# MSetOut{.x = 1}: +2\n+\n+start;\n+# Add one more instance of the same record.\n+insert MSetIn(1),\n+commit dump_changes;\n+\n+# expected output:\n+# MSetOut:\n+# MSetOut{.x = 1}: +1\n+\n+start;\n+# Delete one instance of the record; we're down to 2.\n+delete MSetIn(1),\n+commit dump_changes;\n+# expected output:\n+# MSetOut:\n+# MSetOut{.x = 1}: -1\n+\n+dump MSetOut;\n+# expected output:\n+# MSetOut{.x = 0} +1\n+# MSetOut{.x = 1} +2\n+```\n+\n+Output `multiset`s are more memory-efficient than `relation`s.  DDlog enforces", "originalCommit": "84d22e271466d221b613c16af8121b3562863798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1MjkzOA==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452352938", "bodyText": "This deserves a new heading.\nAlso, this is not an \"optimization\"; the difference between a stream and a multiset is that you cannot use the runtime API \"clear\" operation on a stream.", "author": "mbudiu-vmw", "createdAt": "2020-07-09T16:45:51Z", "path": "doc/tutorial/tutorial.md", "diffHunk": "@@ -1208,6 +1249,99 @@ multiple times for different input/output relations).\n Several useful graph transformers are declared in `lib/graph.dl` and implemented in\n `lib/graph.rs`\n \n+## Multisets and streams\n+\n+All DDlog relations considered so far implement set semantics.  A set can contain\n+at most one instance of each value.  If the same value is inserted in the relation\n+multiple times, all but the last insertion are ignored (or fail if the relation\n+has a primary key).  Likewise, repeated deletions are ignored or fail.  Similarly,\n+DDlog ensures that output relations behave as sets, e.g., the same value cannot\n+be inserted multiple times, unless it is deleted in between.\n+\n+While this behavior matches the requirements of most applications, there are\n+cases when relations with non-unit multiplicities are useful.  Consider, for\n+example, an input relation that receives inputs from two sources, that can both\n+produce the same value (at which point its multiplicity is 2).  The value should only be\n+removed from the relation once it has been removed from both sources, i.e., its\n+multiplicity drops to 0.  In other words, we would like the relation to have\n+*multiset*, rather than set semantics.  Such a relation can be declared by using\n+the `multiset` keyword instead of `relation`:\n+\n+```\n+input multiset MSetIn(x: u32)\n+```\n+\n+Values in a multiset relation can have both positive and negative\n+multiplicities: deleting a non-existent value introduces the value with\n+multiplicity `-1`.  Therefore, such relations can be more precisely described\n+as *generalized*, rather than ordinary *multisets*.\n+\n+An output relation can also be declared as `multiset`, in which case DDlog\n+can derive the same output value multiple times, so that `dump` and\n+`commit dump_changes` commands will output records with non-unit multiplicities:\n+\n+```\n+output multiset MSetOut(x: u32)\n+MSetOut(x) :- MSetIn(x).\n+```\n+\n+The following scenario illustrates the semantics of multisets:\n+\n+```\n+start;\n+\n+insert MSetIn(0),\n+# Insert the same value twice; due to the multiset semantics, it will appear twice in MSetOut.\n+insert MSetIn(1),\n+insert MSetIn(1),\n+commit dump_changes;\n+# expected output:\n+# MSetOut:\n+# MSetOut{.x = 0}: +1\n+# MSetOut{.x = 1}: +2\n+\n+start;\n+# Add one more instance of the same record.\n+insert MSetIn(1),\n+commit dump_changes;\n+\n+# expected output:\n+# MSetOut:\n+# MSetOut{.x = 1}: +1\n+\n+start;\n+# Delete one instance of the record; we're down to 2.\n+delete MSetIn(1),\n+commit dump_changes;\n+# expected output:\n+# MSetOut:\n+# MSetOut{.x = 1}: -1\n+\n+dump MSetOut;\n+# expected output:\n+# MSetOut{.x = 0} +1\n+# MSetOut{.x = 1} +2\n+```\n+\n+Output `multiset`s are more memory-efficient than `relation`s.  DDlog enforces\n+set semantics by using the Differential Dataflow `distinct` operator, which\n+internally maintains an indexed representation of the output relation.\n+Multisets avoid this overhead.\n+\n+Streams are yet another kind of relation in DDlog that are similar to multisets", "originalCommit": "84d22e271466d221b613c16af8121b3562863798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1MzIxNw==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452353217", "bodyText": "won't this break user programs?", "author": "mbudiu-vmw", "createdAt": "2020-07-09T16:46:20Z", "path": "go/pkg/ddlog/ddlog.go", "diffHunk": "@@ -22,10 +22,10 @@ static void freeCmdArray(ddlog_cmd **ca) {\n     free(ca);\n }\n \n-extern void handleOutRecord(uintptr_t progIdx, table_id table, ddlog_record *rec, bool polarity);\n+extern void handleOutRecord(uintptr_t progIdx, table_id table, ddlog_record *rec, ssize_t weight);", "originalCommit": "84d22e271466d221b613c16af8121b3562863798", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0MDM1Nw==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452440357", "bodyText": "It will; but at least the breakage will manifest at compile time.", "author": "ryzhyk", "createdAt": "2020-07-09T19:25:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1MzIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1NDU5Mg==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452354592", "bodyText": "You should give a headsup to the users of this API that they may need to change their programs.\nProbably it's fine to break the programs now, but in the future this may need adding an additional api call and keeping the old one.", "author": "mbudiu-vmw", "createdAt": "2020-07-09T16:48:36Z", "path": "java/ddlogapi.c", "diffHunk": "@@ -303,14 +303,14 @@ JNIEXPORT void JNICALL Java_ddlogapi_DDlogAPI_ddlog_1transaction_1commit(\n     }\n }\n \n-void commit_dump_callback(uintptr_t callbackInfo, table_id tableid, const ddlog_record* rec, bool polarity) {\n+void commit_dump_callback(uintptr_t callbackInfo, table_id tableid, const ddlog_record* rec, ssize_t weight) {", "originalCommit": "84d22e271466d221b613c16af8121b3562863798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1NTM3MA==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452355370", "bodyText": "Now you wonder why you need two different commands...\nI think that it should be just the opposite: convert Delete to a negative insertion.", "author": "mbudiu-vmw", "createdAt": "2020-07-09T16:49:53Z", "path": "java/ddlogapi/DDlogAPI.java", "diffHunk": "@@ -359,11 +358,11 @@ public int clearRelation(int relid) throws DDlogException {\n     }\n \n     // Callback invoked from commit_dump_changes.\n-    void onDelta(int tableid, long handle, boolean polarity) {\n+    void onDelta(int tableid, long handle, long weight) {\n         if (this.deltaCallback != null) {\n-            DDlogCommand.Kind kind = polarity ? DDlogCommand.Kind.Insert : DDlogCommand.Kind.DeleteVal;\n+            DDlogCommand.Kind kind = weight > 0 ? DDlogCommand.Kind.Insert : DDlogCommand.Kind.DeleteVal;", "originalCommit": "84d22e271466d221b613c16af8121b3562863798", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0MDgwNQ==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452440805", "bodyText": "I tried that, but then realized that I still need a way to distinguish DeleteVal and DeleteKey, and potentially other commands in the future, so we need both weight and kind.", "author": "ryzhyk", "createdAt": "2020-07-09T19:26:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1NTM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1NTYyMQ==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452355621", "bodyText": "Is the new Long necesary? I think that boxing will do this for you automatically.", "author": "mbudiu-vmw", "createdAt": "2020-07-09T16:50:17Z", "path": "java/ddlogapi/DDlogAPI.java", "diffHunk": "@@ -476,10 +475,10 @@ public void dumpIndexToFlatBuf(long idxid, FlatBufDescr resfb) throws DDlogExcep\n     }\n \n     /// Callback invoked from dump.\n-    boolean dumpCallback(long handle) {\n+    boolean dumpCallback(long handle, long weight) {\n         if (this.dumpCallback != null) {\n             DDlogRecord record = DDlogRecord.fromSharedHandle(handle);\n-            this.dumpCallback.accept(record);\n+            this.dumpCallback.accept(record, new Long(weight));", "originalCommit": "84d22e271466d221b613c16af8121b3562863798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1NjY4Ng==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452356686", "bodyText": "you could also assert that w is 1.", "author": "mbudiu-vmw", "createdAt": "2020-07-09T16:52:10Z", "path": "java/test/SpanTest.java", "diffHunk": "@@ -403,11 +403,11 @@ void parseLine(String line)\n                     } else {\n                         System.out.println(\"ContainerSpan:\");\n                         this.api.dumpTable(\"ContainerSpan\",\n-                                r -> System.out.println(new ContainerSpan(r)));\n+                                (r, w) -> System.out.println(new ContainerSpan(r)));", "originalCommit": "84d22e271466d221b613c16af8121b3562863798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1Njk2MA==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452356960", "bodyText": "I think this should be signed.", "author": "mbudiu-vmw", "createdAt": "2020-07-09T16:52:38Z", "path": "rust/template/ddlog.h", "diffHunk": "@@ -110,7 +110,7 @@ typedef void ddlog_record;\n typedef struct {\n     table_id table;\n     ddlog_record *rec;\n-    bool polarity;\n+    ssize_t weight;", "originalCommit": "84d22e271466d221b613c16af8121b3562863798", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0MjY4OA==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452442688", "bodyText": "ssize_t is a signed type.", "author": "ryzhyk", "createdAt": "2020-07-09T19:30:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1Njk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1NzY2Nw==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452357667", "bodyText": "This is more than just a caching mode. RelationSemantics?", "author": "mbudiu-vmw", "createdAt": "2020-07-09T16:53:52Z", "path": "rust/template/differential_datalog/program.rs", "diffHunk": "@@ -280,6 +280,20 @@ impl Clone for Box<dyn CBFn> {\n     }\n }\n \n+/// Caching mode for input relations only:\n+/// `NoCache` - don't cache the contents of the relation.\n+/// `CacheSet` - cache relation as a set.  Duplicate inserts are\n+///     ignored (for relations without a key) or fail (for relations\n+///     with key).\n+/// `CacheMultiset` - cache relation as a generalized multiset with\n+///     integer weights.\n+#[derive(Clone)]\n+pub enum CachingMode {", "originalCommit": "84d22e271466d221b613c16af8121b3562863798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjM1ODIxMQ==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452358211", "bodyText": "this assertion should still be somewhere else in the code I expect.", "author": "mbudiu-vmw", "createdAt": "2020-07-09T16:54:49Z", "path": "rust/template/differential_datalog/program.rs", "diffHunk": "@@ -1337,7 +1370,7 @@ impl Program {\n                             if let Some(cb) = &prog.get_relation(relid).change_cb {\n                                 let mut cb = cb.lock().unwrap().clone();\n                                 collection.consolidate().inspect(move |x| {\n-                                    assert!(x.2 == 1 || x.2 == -1, \"x: {:?}\", x);\n+                                    //assert!(x.2 == 1 || x.2 == -1, \"x: {:?}\", x);", "originalCommit": "84d22e271466d221b613c16af8121b3562863798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwMTM0OA==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452401348", "bodyText": "I think that what you are saying here is that we don't have a semantics for operations that combine sets and multisets. This is the most important thing to figure out. Ideally we would be very explicit about this, giving users control by using either distinct or a conversion in the other way, that casts a set to a multiset preserving weights. I was a little uncomfortable about implementing sets with multisets even previously, because we never had a proof that we achieve the expected datalog semantics by inserting distinct in some places. Is this something that the Vienna guys would be interested in working on?", "author": "mbudiu-vmw", "createdAt": "2020-07-09T18:12:15Z", "path": "rust/template/differential_datalog/program.rs", "diffHunk": "@@ -1662,8 +1716,12 @@ impl Program {\n                     while cursor.val_valid(&storage) && *cursor.key(&storage) == k {\n                         let mut weight = 0;\n                         cursor.map_times(&storage, |_, diff| weight += diff);\n-                        assert!(weight >= 0);\n-                        if weight > 0 {\n+                        //assert!(weight >= 0);", "originalCommit": "84d22e271466d221b613c16af8121b3562863798", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0NDIwMw==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452444203", "bodyText": "Actually, I don't see how this combination is problematic.  Inputs are always multisets, it's just that sometimes we force them to have unit multiplicities (before feeding data to differential).\nThis particular code is just me being unwilling to change the semantics of indexes from sets to multisets.", "author": "ryzhyk", "createdAt": "2020-07-09T19:33:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwMTM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwMjk0OQ==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452402949", "bodyText": "is there any opportunity for code reuse by inheriting the behavior?", "author": "mbudiu-vmw", "createdAt": "2020-07-09T18:15:10Z", "path": "rust/template/differential_datalog/program.rs", "diffHunk": "@@ -2359,16 +2436,104 @@ impl RunningProgram {\n     fn delta_dec(ds: &mut DeltaSet, key: &DDValue) {\n         let e = ds.entry(key.clone());\n         match e {\n-            hash_map::Entry::Occupied(oe) => {\n-                debug_assert!(*oe.get());\n-                oe.remove_entry();\n+            hash_map::Entry::Occupied(mut oe) => {\n+                //debug_assert!(*oe.get());\n+                let v = oe.get_mut();\n+                if *v == 1 {\n+                    oe.remove_entry();\n+                } else {\n+                    *v -= 1;\n+                }\n             }\n             hash_map::Entry::Vacant(ve) => {\n-                ve.insert(false);\n+                ve.insert(-1);\n             }\n         }\n     }\n \n+    /* Update delta set of an input stream relation before performing an update.\n+     * `ds` is delta since start of transaction.\n+     * `x` is the value being inserted or deleted.\n+     * `insert` indicates type of update (`true` for insert, `false` for delete) */\n+    fn stream_update(", "originalCommit": "84d22e271466d221b613c16af8121b3562863798", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwNDA4OQ==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452404089", "bodyText": "this looks inefficient; weights could potentially be very large", "author": "mbudiu-vmw", "createdAt": "2020-07-09T18:17:11Z", "path": "rust/template/differential_datalog/program.rs", "diffHunk": "@@ -2594,29 +2769,37 @@ impl RunningProgram {\n         Ok(())\n     }\n \n-    /* Reverse all changes recorded in delta sets to rollback the transaction. */\n-    fn delta_undo(&mut self) -> Response<()> {\n-        let mut updates = vec![];\n-        for (relid, rel) in &self.relations {\n-            // first delete, then insert to avoid duplicate key\n-            // errors in `apply_updates()`\n-            for (k, w) in rel.delta() {\n-                if *w {\n+    fn delta_undo_updates(relid: RelId, ds: &DeltaSet, updates: &mut Vec<Update<DDValue>>) {\n+        // first delete, then insert to avoid duplicate key\n+        // errors in `apply_updates()`\n+        for (k, w) in ds {\n+            if *w >= 0 {\n+                for _ in 0..*w {", "originalCommit": "84d22e271466d221b613c16af8121b3562863798", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0NTIyMg==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452445222", "bodyText": "I know what you mean but in this particular place it's not too bad, as there will be at most one compensation command for each input command from the user.", "author": "ryzhyk", "createdAt": "2020-07-09T19:35:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwNDA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwNDczOQ==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452404739", "bodyText": "Doesn't this case make life harder for everyone involved?", "author": "mbudiu-vmw", "createdAt": "2020-07-09T18:18:23Z", "path": "rust/template/differential_datalog/valmap.rs", "diffHunk": "@@ -90,8 +90,12 @@ impl<V: Display + Ord + Clone> DeltaMap<V> {\n         for (relid, map) in &self.map {\n             w.write_fmt(format_args!(\"{}:\\n\", R::relid2name(*relid).unwrap()))?;\n             for (val, weight) in map {\n-                w.write_fmt(format_args!(\"{}\\n\", *val))?;\n-                assert_eq!(*weight, 1, \"val={}, weight={}\", *val, *weight);\n+                if *weight == 1 {\n+                    w.write_fmt(format_args!(\"{}\\n\", *val))?;", "originalCommit": "84d22e271466d221b613c16af8121b3562863798", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQ0NTg1Nw==", "url": "https://github.com/vmware/differential-datalog/pull/699#discussion_r452445857", "bodyText": "This makes sure that output sets are always be printed without multiplicities, which are always \"+1\".", "author": "ryzhyk", "createdAt": "2020-07-09T19:37:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjQwNDczOQ=="}], "type": "inlineReview"}, {"oid": "93c68c0455a6f7ad3ff424765a3823f8a33800ee", "url": "https://github.com/vmware/differential-datalog/commit/93c68c0455a6f7ad3ff424765a3823f8a33800ee", "message": "Address review comments.", "committedDate": "2020-07-09T19:37:55Z", "type": "commit"}]}