{"pr_number": 527, "pr_title": "Introduce insert-or-update command in the C API.", "pr_createdAt": "2020-02-17T04:39:56Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/527", "timeline": [{"oid": "60f187324885e10d7beb158f432462aec3966e57", "url": "https://github.com/vmware/differential-datalog/commit/60f187324885e10d7beb158f432462aec3966e57", "message": "Introduce insert-or-update command.\n\nThe new command is useful when working with DDlog input relations with\nprimary keys.  Operations available on such relations so far are:\n\n- insert - fails if a record with the same key exists\n- delete-by-value, delete-by-key - fail if a record with the specified\n  key does not exist\n- modify - fails if a record with the specified key does not exist.\n\nThe new command is similar to insert, except that, if a record with the\nsame key as the one being inserted already exists, it replaces this\nrecord with the new one instead of failing.  This is convenient in\nscenarios where the client does not know if the key exists or cannot\neasily issue a delete command.\n\nThe insert-or-update command is only applicable to input relations with\na primary key.\n\nThe CLI syntax for the new command is the same as for the `insert`\ncommand, but using the `insert_ord_update` keyword:\n\n```\ninsert_or_update WithKey(1, \"bar3\");\n```\n\nC API:\n\n```\nextern ddlog_cmd* ddlog_insert_or_update_cmd(table_id table, ddlog_record *rec);\n```", "committedDate": "2020-02-17T04:15:09Z", "type": "commit"}, {"oid": "66c3d18d705402989396928e2e7393f4ae56a124", "url": "https://github.com/vmware/differential-datalog/commit/66c3d18d705402989396928e2e7393f4ae56a124", "message": "Antrea: add primary keys to input relations.\n\nAdd primary keys to Antrea input tables, so we can delete records\nby key, as well as overwrite or modify existing records.", "committedDate": "2020-02-17T04:22:16Z", "type": "commit"}, {"oid": "a0456f0123488dd6d30466b6c14d627a625602c7", "url": "https://github.com/vmware/differential-datalog/commit/a0456f0123488dd6d30466b6c14d627a625602c7", "message": "ddlog.h: Improve command API documentation.\n\nMore detailed comments for `ddlog_XXXX_cmd()` APIs, specifically better\ndocument when each command fails.\n\nAlso, better document the `ddlog_apply_updates()` API, namely the fact\nthat it fails non-atomically.  Admittedly, this is not the most\nuser-friendly semantics, but this is how things work at the moment.", "committedDate": "2020-02-17T04:22:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI2NDYyOA==", "url": "https://github.com/vmware/differential-datalog/pull/527#discussion_r380264628", "bodyText": "I think we had an issue for this behavior not documented at the time", "author": "mbudiu-vmw", "createdAt": "2020-02-17T16:05:07Z", "path": "rust/template/ddlog.h", "diffHunk": "@@ -342,6 +341,13 @@ extern void ddlog_free_json(char *json);\n  * Whether the function succeeds or fails, it consumes all commands in\n  * the `upds` array (but not the array itself), so they can no longer be\n  * accessed by the caller after the function returns.\n+ *\n+ * This function fails non-atomically: upon a failure, it may have applied\n+ * a _subset_ of input commands (one exception is when `ddlog_apply_updates`\n+ * is called with a single command, in which case it leaves the database\n+ * unmodified in case of a failure).  Use `ddlog_transaction_rollback()` to\n+ * bring the database back to a known state, specifically the state where it\n+ * was before the start of the transaction.", "originalCommit": "a0456f0123488dd6d30466b6c14d627a625602c7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI2NTUzNQ==", "url": "https://github.com/vmware/differential-datalog/pull/527#discussion_r380265535", "bodyText": "This sounds wrong", "author": "mbudiu-vmw", "createdAt": "2020-02-17T16:06:48Z", "path": "rust/template/ddlog.h", "diffHunk": "@@ -1053,35 +1059,73 @@ extern const ddlog_record* ddlog_get_struct_field(const ddlog_record* rec,\n /*\n  * Create an insert command.\n  *\n- * `table` is the table to insert to.  `rec` is the record to insert.\n- * The function takes ownership of this record.\n+ * `table` - input table to insert to.\n+ * `rec` - record to insert.  The function takes ownership of this record.\n  *\n  * Returns pointer to a new command, which can be sent to DDlog by calling\n  * `ddlog_apply_updates()`.\n+ *\n+ * This function never fails; however the command it creates may fail to\n+ * execute, causing `ddlog_apply_updates()` to return an error if:\n+ * - `table` is not a valid input table id\n+ * - `rec` does not match the record type of `table`\n+ * - The table has a primary key and there exists a record with the same key\n+ *   as `rec` in the table.\n  */\n extern ddlog_cmd* ddlog_insert_cmd(table_id table, ddlog_record *rec);\n \n /*\n- * Create delete-by-value command.\n+ * Create an insert-or-update command that inserts a new record, deleting\n+ * an existing record with the same primary key, if there is one.\n+ *\n+ * `table` - input table to insert to.\n+ * `rec` - record to insert.  The function takes ownership of this record.\n+ *\n+ * Returns pointer to a new command, which can be sent to DDlog by calling\n+ * `ddlog_apply_updates()`.\n+ *\n+ * This function never fails; however the command it creates may fail to\n+ * execute, causing `ddlog_apply_updates()` to return an error if:\n+ * - `table` is not a valid input table id\n+ * - `table` does not have a primary key\n+ * - `rec` does not match the record type of `table`\n+ */\n+extern ddlog_cmd* ddlog_insert_or_update_cmd(table_id table, ddlog_record *rec);\n+\n+/*\n+ * Create a delete-by-value command.\n  *\n- * `table` is the table to delete from. `rec` is the record to delete.\n- * The function takes ownership of this record.\n+ * `table` - input table to delete from.\n+ * `rec` - record to delete.  The function takes ownership of this record.\n  *\n  * Returns pointer to a new command, which can be sent to DDlog by calling\n  * `ddlog_apply_updates()`.\n+ *\n+ * This function never fails; however the command it creates may fail to\n+ * execute, causing `ddlog_apply_updates()` to return an error if:\n+ * - `table` is not a valid input table id\n+ * - `rec` does not match the record type of `table`\n+ * - `table` has a primary key and record `rec` does not exist in `table`\n+ *   (NOTE: for tables without a primary key, the command succeeds even if", "originalCommit": "a0456f0123488dd6d30466b6c14d627a625602c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM4NTY4OQ==", "url": "https://github.com/vmware/differential-datalog/pull/527#discussion_r380385689", "bodyText": "Agreed, but at least this documents how things are working right now.", "author": "ryzhyk", "createdAt": "2020-02-17T22:30:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDI2NTUzNQ=="}], "type": "inlineReview"}]}