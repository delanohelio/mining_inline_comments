{"pr_number": 877, "pr_title": "Speed-up compilation.", "pr_createdAt": "2020-12-19T09:22:49Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/877", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg4MjUxNw==", "url": "https://github.com/vmware/differential-datalog/pull/877#discussion_r546882517", "bodyText": "Maybe you want to add a few entries for previous releases; at least the first release should be here.\nWhat is OOM?", "author": "mbudiu-vmw", "createdAt": "2020-12-21T19:13:18Z", "path": "CHANGELOG.md", "diffHunk": "@@ -0,0 +1,10 @@\n+# Changelog\n+All notable changes to this project will be documented in this file.\n+\n+The format is based on [Keep a Changelog](https://keepachangelog.com/en/1.0.0/).\n+\n+## [Unreleased]", "originalCommit": "6d185be838ae146ae16a943dafefee800863d059", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjkxNTg2Mw==", "url": "https://github.com/vmware/differential-datalog/pull/877#discussion_r546915863", "bodyText": "order-of-magnitude. I'll convert this into a release entry when creating a release.", "author": "ryzhyk", "createdAt": "2020-12-21T20:31:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg4MjUxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg4MzA1MQ==", "url": "https://github.com/vmware/differential-datalog/pull/877#discussion_r546883051", "bodyText": "Make the output conditional on some option (-verbose?).", "author": "mbudiu-vmw", "createdAt": "2020-12-21T19:14:35Z", "path": "app/Main.hs", "diffHunk": "@@ -155,13 +158,26 @@ main = do\n             putStrLn $ \"DDlog \" ++ dDLOG_VERSION ++ \" (\" ++ gitHash ++ \")\"\n             putStrLn $ \"Copyright (c) 2019-2020 VMware, Inc. (MIT License)\"\n         ActionValidate -> do\n-            _ <- parseValidate config'\n-            return ()\n+            timeAction (\"validating \" ++ show (confDatalogFile config)) $ do\n+                _ <- parseValidate config'\n+                return ()\n         ActionCompile -> do\n-            compileProg config'\n-            -- Run rustfmt on the generated code if it's enabled\n-            when (confRunRustfmt config') $\n-                runCommandReportingErr \"rustfmt\" \"cargo\" [\"fmt\", \"--all\"] $ Just (confOutputDir config')\n+            timeAction (\"compiling \" ++ show (confDatalogFile config)) $ do\n+                compileProg config'\n+                -- Run rustfmt on the generated code if it's enabled\n+                when (confRunRustfmt config') $\n+                    runCommandReportingErr \"rustfmt\" \"cargo\" [\"fmt\", \"--all\"] $ Just (confOutputDir config')\n+\n+-- Perform IO action and measure its duration.\n+timeAction :: String -> IO () -> IO ()", "originalCommit": "6d185be838ae146ae16a943dafefee800863d059", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjkwMzk4MA==", "url": "https://github.com/vmware/differential-datalog/pull/877#discussion_r546903980", "bodyText": "What's wrong with always printing it?  Rust compiler does this bu default, and I find it useful, also as explicit indication that compilation succeeded.", "author": "ryzhyk", "createdAt": "2020-12-21T20:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg4MzA1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjkwNTA5OQ==", "url": "https://github.com/vmware/differential-datalog/pull/877#discussion_r546905099", "bodyText": "The Unix philosophy is to print nothing on success.\nIf you write tools that consume the output of the compiler you may expect that there is no output if there are no errors or warnings. But this is certainly a low priority item; we can wait until someone asks for a -quiet flag.", "author": "mbudiu-vmw", "createdAt": "2020-12-21T20:04:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg4MzA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg4NTM0OQ==", "url": "https://github.com/vmware/differential-datalog/pull/877#discussion_r546885349", "bodyText": "typo in comment", "author": "mbudiu-vmw", "createdAt": "2020-12-21T19:19:48Z", "path": "src/Language/DifferentialDatalog/Expr.hs", "diffHunk": "@@ -586,3 +589,144 @@ exprInjectStringConversion d e t = do\n                         [E e]\n     where mk2string_func cs = scoped scope \"to_string\"\n               where scope = nameScope cs\n+\n+-- A descriptor that uniquely identifies a sub-expression within\n+-- a given context as a path from the root of the context to the\n+-- sub-expression.\n+data ELocator = ELocator {elocatorPath :: [Int]} deriving (Eq, Ord)\n+\n+-- depth-first fold of an expression\n+exprFoldWithLocatorM :: (Monad m) => (ELocator -> ExprNode b -> m b) -> ELocator -> Expr -> m b\n+exprFoldWithLocatorM f loc (E n) = exprFoldWithLocatorM' f loc n\n+\n+exprFoldWithLocatorM' :: (Monad m) => (ELocator -> ExprNode b -> m b) -> ELocator -> ENode -> m b\n+exprFoldWithLocatorM' f loc                 (EVar p v)              = f loc $ EVar p v\n+exprFoldWithLocatorM' f loc@(ELocator path) (EApply p fun as)       = \n+    -- 0: function expression\n+    -- 1..n: argument expression\n+    f loc =<< EApply p <$> exprFoldWithLocatorM f (ELocator $ 0:path) fun\n+                                  <*> (mapIdxM (\\a i -> exprFoldWithLocatorM f (ELocator $ (1+i) : path) a) as)\n+exprFoldWithLocatorM' f loc@(ELocator path) (EField p s fl)         =\n+    do s' <- exprFoldWithLocatorM f (ELocator $ 0:path) s\n+       f loc $ EField p s' fl\n+exprFoldWithLocatorM' f loc@(ELocator path) (ETupField p s fl)      = do\n+    s' <- exprFoldWithLocatorM f (ELocator $ 0:path) s\n+    f loc $ ETupField p s' fl\n+exprFoldWithLocatorM' f loc                   (EBool p b)             = f loc $ EBool p b\n+exprFoldWithLocatorM' f loc                   (EInt p i)              = f loc $ EInt p i\n+exprFoldWithLocatorM' f loc                   (EDouble p i)           = f loc $ EDouble p i\n+exprFoldWithLocatorM' f loc                   (EFloat p i)            = f loc $ EFloat p i\n+exprFoldWithLocatorM' f loc                   (EString p s)           = f loc $ EString p s\n+exprFoldWithLocatorM' f loc                   (EBit p w v)            = f loc $ EBit p w v\n+exprFoldWithLocatorM' f loc                   (ESigned p w v)         = f loc $ ESigned p w v\n+exprFoldWithLocatorM' f loc@(ELocator path) (EStruct p c fs)        =\n+    f loc =<< EStruct p c <$> (mapIdxM (\\(fname, fl) i -> (fname,) <$> exprFoldWithLocatorM f (ELocator $ i : path) fl) fs)\n+exprFoldWithLocatorM' f loc@(ELocator path) (ETuple p fs)           =\n+    f loc =<< ETuple p <$> (mapIdxM (\\fl i -> exprFoldWithLocatorM f (ELocator $ i : path) fl) fs)\n+exprFoldWithLocatorM' f loc@(ELocator path) (ESlice p v h l)        = do\n+    v' <- exprFoldWithLocatorM f (ELocator $ 0 : path) v\n+    f loc $ ESlice p v' h l\n+exprFoldWithLocatorM' f loc@(ELocator path) (EMatch p m cs)         = do\n+    -- 0 - match expression\n+    -- 1,3,5,..,2n-1 - match patterns\n+    -- 2,4,6,..,2n   - match values\n+    m' <- exprFoldWithLocatorM f (ELocator $ 0:path) m\n+    cs' <- mapIdxM (\\(e1, e2) i -> (,) <$> (exprFoldWithLocatorM f (ELocator $ (1+2*i):path) e1) <*>\n+                                           (exprFoldWithLocatorM f (ELocator $ (2+2*i):path) e2)) cs\n+    f loc $ EMatch p m' cs'\n+exprFoldWithLocatorM' f loc                   (EVarDecl p v)          = f loc $ EVarDecl p v\n+exprFoldWithLocatorM' f loc@(ELocator path) (ESeq p l r)            =\n+    f loc =<< ESeq p <$> exprFoldWithLocatorM f (ELocator $ 0:path) l <*>\n+                         exprFoldWithLocatorM f (ELocator $ 1:path) r\n+exprFoldWithLocatorM' f loc@(ELocator path) (EITE p i t el)         =\n+    -- 0: if-confition", "originalCommit": "6d185be838ae146ae16a943dafefee800863d059", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg4NTk4MQ==", "url": "https://github.com/vmware/differential-datalog/pull/877#discussion_r546885981", "bodyText": "these linear scans are something that you should perhaps keep an eye for.", "author": "mbudiu-vmw", "createdAt": "2020-12-21T19:21:28Z", "path": "src/Language/DifferentialDatalog/NS.hs", "diffHunk": "@@ -150,7 +151,9 @@ getRelation :: DatalogProgram -> String -> Relation\n getRelation d n = fromJust $ lookupRelation d n\n \n arg2v :: Function -> FuncArg -> Var\n-arg2v f a = ArgVar f (name a)\n+arg2v f a = ArgVar f i (name a)\n+    where\n+    i = fromJust $ findIndex ((== name a) . name) $ funcArgs f", "originalCommit": "6d185be838ae146ae16a943dafefee800863d059", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg4NzI1Mg==", "url": "https://github.com/vmware/differential-datalog/pull/877#discussion_r546887252", "bodyText": "delete?", "author": "mbudiu-vmw", "createdAt": "2020-12-21T19:24:40Z", "path": "src/Language/DifferentialDatalog/TypeInference.hs", "diffHunk": "@@ -866,9 +895,9 @@ exprConstraints_ de@(DDExpr ctx (E e@EBinOp{..})) | elem exprBOp [Eq, Neq, Lt, L\n                                                 | elem exprBOp [ShiftL, ShiftR] = do\n     addConstraint =<< deIsInt l\n     -- If the type of 'r' cannot be inferred, default to 'u32'\n-    isbits <- deIsBits r\n-    def <- tvarTypeOfExpr r <==== TEBit (IConst 32)\n-    addConstraint $ isbits {cDefault = Just [def]}\n+    --isbits <- deIsBits r", "originalCommit": "6d185be838ae146ae16a943dafefee800863d059", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg5MDUyOA==", "url": "https://github.com/vmware/differential-datalog/pull/877#discussion_r546890528", "bodyText": "isn't it interesting that this program is both shorter and faster?", "author": "mbudiu-vmw", "createdAt": "2020-12-21T19:32:31Z", "path": "src/Language/DifferentialDatalog/Unification.hs", "diffHunk": "@@ -50,11 +50,10 @@ module Language.DifferentialDatalog.Unification(\n where\n \n import Control.Monad.Except\n-import Control.Monad.State\n import Data.List\n import qualified Data.Map as M\n import Data.Maybe\n---import Debug.Trace\n+-- import Debug.Trace", "originalCommit": "6d185be838ae146ae16a943dafefee800863d059", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njg5OTI1Mw==", "url": "https://github.com/vmware/differential-datalog/pull/877#discussion_r546899253", "bodyText": "I don't understand where this embedded comment comes from.\nAre you showing a list of candidate functions that match?\nThe comment syntax is not the most appropriate.\nPerhaps something like One of [ddlog_std::split, internment::split]", "author": "mbudiu-vmw", "createdAt": "2020-12-21T19:51:06Z", "path": "test/datalog_tests/function.fail.ast.expected", "diffHunk": "@@ -111,9 +111,16 @@ Only non-extern functions can be overloaded.\n extern function foo(x: u32): ()\n ^\n \n-error: ./test/datalog_tests/function.fail.dl:8:21-8:39: expression '(ddlog_std::nth(components, 1))' must be of type 'Result<>', but its type is 'ddlog_std::Option<string>'\n-    var last_name = components.nth(1)?;\n-                    ^^^^^^^^^^^^^^^^^^\n+error: ./test/datalog_tests/function.fail.dl:6:5-10:1: Type mismatch:\n+expected type: ddlog_std::Result<(string,string),string>\n+actual type: ddlog_std::Option<('a17,'a28)>\n+in\n+expression '{(var components = (/*ddlog_std::split, internment::split*/(name, \" \")));", "originalCommit": "6d185be838ae146ae16a943dafefee800863d059", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4f8341825a2b62001d76d502357c312242fa2e25", "url": "https://github.com/vmware/differential-datalog/commit/4f8341825a2b62001d76d502357c312242fa2e25", "message": "Report compilation time.\n\nOutputing compilation time on success.  This is the first step towards\nimproving compilation speed.", "committedDate": "2020-12-22T05:54:00Z", "type": "commit"}, {"oid": "ce2ff4ec078402606ce195cf3d79ca4cc9ba6b92", "url": "https://github.com/vmware/differential-datalog/commit/ce2ff4ec078402606ce195cf3d79ca4cc9ba6b92", "message": "Enable -O2 optimization level.", "committedDate": "2020-12-22T05:54:00Z", "type": "commit"}, {"oid": "403ca364f25f88e334692268d80ecff07d864f39", "url": "https://github.com/vmware/differential-datalog/commit/403ca364f25f88e334692268d80ecff07d864f39", "message": "Optimize variable id assignment in type inference.\n\nProfiling showed that the biggest cost center in terms of CPU\nutilization is the algorithm that encodes the type inference problem as\na set of constraints; in particular the part of this algorithm that\nassigns unique ids to each subexpression and variable in the program.\nThese ids are necessary to speedup variable comparison in the\nunification solver.  Ids are kept in maps indexed by the actual value of\nthe expression and its contexts.  The use of such giant keys makes\nkey comparison very expensive.  We need a more compact id to uniquely\nidentify expressions and variables.\n\nThis patch introduces such ids.  We use a list of integers that\nuniquely specify the path from a top-level context (rule, function, or\nindex) to the expression or variable declaration, e.g, we encode the\nif-clause of an if-then-else statement with 0, the then-clause as 1, and\nthe else clause as 2, etc.\n\nThis representation dramatically speeds up the algorithm, eliminating\nthis particular bottleneck.", "committedDate": "2020-12-22T05:54:00Z", "type": "commit"}, {"oid": "15d01b1f97641e7c185b17a8af02d8769e7a4c05", "url": "https://github.com/vmware/differential-datalog/commit/15d01b1f97641e7c185b17a8af02d8769e7a4c05", "message": "Type inference: Fast indexing of `IntVars`.\n\nUse efficient indexing for integer variables.  This is a similar\noptimization to the one in the previous commit, but applied to integer\nvariables (used, e.g., to encode width of bit-vector expressions) rather\nthan type variables.  We use the new `ELocator` data type to identify\ninteger expressions instead of the actual expression and it context.", "committedDate": "2020-12-22T05:54:00Z", "type": "commit"}, {"oid": "d87349095a9f31f3b33205c0cc47cdb092473fcd", "url": "https://github.com/vmware/differential-datalog/commit/d87349095a9f31f3b33205c0cc47cdb092473fcd", "message": "TypeInference.hs: Optimize add_types.\n\nThis is another optimization using the `ELocator` type to index type\nvariables instead of their context.  This one is applied after all types\nhave been inferred, in order to annotate the program with types.  We\nextract a map from expression context to type from the solver and then\nuse it to add type annotations where needed.  We replace `ELocator`\ninstead of `ECtx` as the key in the map to accelerate read and write\naccesses to it.", "committedDate": "2020-12-22T05:54:00Z", "type": "commit"}, {"oid": "ed39d1a1ed4dffdfb8082e6bd8bacfcbd06b1821", "url": "https://github.com/vmware/differential-datalog/commit/ed39d1a1ed4dffdfb8082e6bd8bacfcbd06b1821", "message": "Compile.hs: Optimize `crateDependencies`.\n\nWhen compiling a program with many modules, the compiler spent a\nsurprising amount of time computing crate dependencies.  We optimize\nthis computation by using numeric crate index instead of its actual\ncontents (list of module names) in the algorithm.", "committedDate": "2020-12-22T05:54:00Z", "type": "commit"}, {"oid": "ba5adfef14b913b4b2557439f6fadb5a357fdbf9", "url": "https://github.com/vmware/differential-datalog/commit/ba5adfef14b913b4b2557439f6fadb5a357fdbf9", "message": "Cache edges of the crate dependency graph.\n\nFurther optimize the computation of crate dependencies by caching them\nin the crate graph as the last step of the crate decomposition algorithm.", "committedDate": "2020-12-22T05:54:00Z", "type": "commit"}, {"oid": "31e7d6cb73a06463e2bfb2db1c644c0946d00fe5", "url": "https://github.com/vmware/differential-datalog/commit/31e7d6cb73a06463e2bfb2db1c644c0946d00fe5", "message": "Unification: Lazy type variable substitution.\n\nWhenever the unification algorithm finds a variable substitution, it\napplies it to all constraints known to the solver.  This requires a\ncomplete scan of the state on each substitution, which adds up to 40%\nof the compilation time.\n\nThis patch changes the algorithm to simply record substitutions and\napply them lazily when reading a constraint, e.g., during the scan for\nthe next substitution.", "committedDate": "2020-12-22T05:54:00Z", "type": "commit"}, {"oid": "a9a154b22ca58e1c979d33b8bdb3e0593be71bbc", "url": "https://github.com/vmware/differential-datalog/commit/a9a154b22ca58e1c979d33b8bdb3e0593be71bbc", "message": "Lazy substitution for integer constraints.\n\nSimilar to the previous commit, but this time we implement lazy\nsubstitution for integer constraints.", "committedDate": "2020-12-22T05:54:00Z", "type": "commit"}, {"oid": "2287bc43d21ccb8c2bf121c892725b2f8f9c00fa", "url": "https://github.com/vmware/differential-datalog/commit/2287bc43d21ccb8c2bf121c892725b2f8f9c00fa", "message": "Unify.hs: Refactor unification-based solver.\n\nA faster impementation of the unification algorithm that should be\nfunctionally equivalent to the old one, but converge much faster.\n\nOld algorithm:\n- Scan constraint list to find the first constraint in solved form;\n  apply substitution derived from this constraint.\n- If no such constraint found, find and unify any predicate constraint\n- Otherwise find and expand a lazy constraint with a default clause\n- Fail if none of the above works.\n\nThis algoithm requires a separate scan of the constraint list for each\nvariable substitution.\n\nThe new algorithm scans the constraint list extracting as much\ninformation as possible from each constraint, learning substitutions\nfrom all solved constraints, unifying all other predicate constraints,\nexpanding lazy constraints if possible, etc.  Substitutions learned from\nthe prefix of the list are applied to constraints in the remainder of\nthe list.  Each scan constructs a new list of constraints passed to the\nnew scan.", "committedDate": "2020-12-22T05:54:00Z", "type": "commit"}, {"oid": "f0dedd7dddb8039c2bf07e677c9ad9c92adcd896", "url": "https://github.com/vmware/differential-datalog/commit/f0dedd7dddb8039c2bf07e677c9ad9c92adcd896", "message": "Changelog.\n\nSerious projects have changelogs.  Here's one for DDlog.", "committedDate": "2020-12-22T05:54:00Z", "type": "commit"}, {"oid": "9888b3accfe01ae5f163d5336fd008df6d798334", "url": "https://github.com/vmware/differential-datalog/commit/9888b3accfe01ae5f163d5336fd008df6d798334", "message": "Address review comments.", "committedDate": "2020-12-22T05:54:00Z", "type": "commit"}, {"oid": "f4de6625609a7985717ddd947bac6a525c08eff0", "url": "https://github.com/vmware/differential-datalog/commit/f4de6625609a7985717ddd947bac6a525c08eff0", "message": "Use private docker repo in CI.\n\nSince Dockerhub is no longer usable from private runners, we are now\nhosting the docker image used to run DDlog tests in gitlab in a\nVMware-internal registry.", "committedDate": "2020-12-22T05:57:54Z", "type": "commit"}, {"oid": "f4de6625609a7985717ddd947bac6a525c08eff0", "url": "https://github.com/vmware/differential-datalog/commit/f4de6625609a7985717ddd947bac6a525c08eff0", "message": "Use private docker repo in CI.\n\nSince Dockerhub is no longer usable from private runners, we are now\nhosting the docker image used to run DDlog tests in gitlab in a\nVMware-internal registry.", "committedDate": "2020-12-22T05:57:54Z", "type": "forcePushed"}]}