{"pr_number": 509, "pr_title": "Antrea todos", "pr_createdAt": "2020-02-07T23:49:45Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/509", "timeline": [{"oid": "5628429d9b66c9d63893dee746e811848ce20636", "url": "https://github.com/vmware/differential-datalog/commit/5628429d9b66c9d63893dee746e811848ce20636", "message": "lib/uuid.dl: A library for working with UUIDs.\n\nDDlog bindings for the `uuid` Rust crate.  Defined `extern type Uuid`\nalong with functions to parse and format UUIDs using three different\nformats:\n\n- hyphenated: 936DA01F-9ABD-4D9D-80C7-02AF85C822A8\n- simple: 936da01f9abd4d9d80c702af85c822a8\n- urn: urn:uuid:936da01f-9abd-4d9d-80c7-02af85c822a8", "committedDate": "2020-02-07T00:23:08Z", "type": "commit"}, {"oid": "51a0dd7a5bc3d7cb11cdbdb7e9cf42eb9267eb91", "url": "https://github.com/vmware/differential-datalog/commit/51a0dd7a5bc3d7cb11cdbdb7e9cf42eb9267eb91", "message": "Parse.hs: Forbid the use of `self` as identifier.\n\nIt clashes with Rust keyword.\n\nIdeally, we should be renaming such identifiers, but we don't have\nthe infrastructure to do this at the moment.", "committedDate": "2020-02-07T00:23:08Z", "type": "commit"}, {"oid": "f1960576337d254d7b02031a3b89c93f4746f086", "url": "https://github.com/vmware/differential-datalog/commit/f1960576337d254d7b02031a3b89c93f4746f086", "message": "IP address manipulation library.\n\nThree new library types:\n`net.IpAddr`   - IPv4 or IPv6 address\n`net.Ipv4Addr` - IPv4 address\n`net.Ipv6Addr` - IPv6 address", "committedDate": "2020-02-07T23:47:39Z", "type": "commit"}, {"oid": "c716115fb095446c5af18f8fef6f2fc48d2d099e", "url": "https://github.com/vmware/differential-datalog/commit/c716115fb095446c5af18f8fef6f2fc48d2d099e", "message": "Minimal antrea test data.", "committedDate": "2020-02-08T00:25:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2NDc3MA==", "url": "https://github.com/vmware/differential-datalog/pull/509#discussion_r376664770", "bodyText": "this is strange.", "author": "mbudiu-vmw", "createdAt": "2020-02-08T00:17:35Z", "path": "lib/net/ipv4.dl", "diffHunk": "@@ -0,0 +1,126 @@\n+/* An IPv4 address.\n+ *\n+ * IPv4 addresses are defined as 32-bit integers in IETF RFC 791. They are\n+ * usually represented as four octets.\n+ *\n+ * See IpAddr for a type encompassing both IPv4 and IPv6 addresses.\n+ *\n+ * The size of an Ipv4Addr struct may vary depending on the target operating\n+ * system.\n+ */\n+\n+import net.ipv6", "originalCommit": "f1960576337d254d7b02031a3b89c93f4746f086", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2NTA1NA==", "url": "https://github.com/vmware/differential-datalog/pull/509#discussion_r376665054", "bodyText": "I guess that's why you need that module.", "author": "mbudiu-vmw", "createdAt": "2020-02-08T00:19:06Z", "path": "lib/net/ipv4.dl", "diffHunk": "@@ -0,0 +1,126 @@\n+/* An IPv4 address.\n+ *\n+ * IPv4 addresses are defined as 32-bit integers in IETF RFC 791. They are\n+ * usually represented as four octets.\n+ *\n+ * See IpAddr for a type encompassing both IPv4 and IPv6 addresses.\n+ *\n+ * The size of an Ipv4Addr struct may vary depending on the target operating\n+ * system.\n+ */\n+\n+import net.ipv6\n+\n+extern type Ipv4Addr\n+\n+/* Creates a new IPv4 address from four eight-bit octets.\n+ *\n+ * The result will represent the IP address a.b.c.d.\n+ */\n+extern function ipv4_new(a: u8, b: u8, c: u8, d: u8): Ipv4Addr\n+\n+/* Creates a new IPv4 address from a vector of octets.\n+ *\n+ * Returns None if the length of `octets` is not 4.\n+ */\n+extern function ipv4_from_octet_vec(octets: Vec<u8>): Option<Ipv4Addr>\n+\n+/* Converts a host byte order u32 into an Ipv4Addr.\n+ */\n+extern function ipv4_from_u32(ip: u32): Ipv4Addr\n+\n+/* Parse IPv4 address string in decimal notation, divided by .\n+ * (this is called \"dot-decimal notation\").\n+ */\n+extern function ipv4_from_str(s: string): Result<Ipv4Addr, string>\n+\n+/* Format IPv4 address using dot-decimal notation.\n+ */\n+extern function ipv4Addr2string(addr: Ipv4Addr): string\n+\n+/* An IPv4 address with the address pointing to localhost: 127.0.0.1.\n+ */\n+extern function iPV4_LOCALHOST(): Ipv4Addr\n+\n+/* An IPv4 address representing an unspecified address: 0.0.0.0.\n+ */\n+extern function iPV4_UNSPECIFIED(): Ipv4Addr\n+\n+/* An IPv4 address representing the broadcast address: 255.255.255.255.\n+ */\n+extern function iPV4_BROADCAST(): Ipv4Addr\n+\n+/* Returns the four eight-bit integers that make up this address.\n+ */\n+extern function ipv4_octets(addr: Ipv4Addr): (u8, u8, u8, u8)\n+\n+/* Returns a vector of four eight-bit integers the IPv4 address consists of.\n+ */\n+extern function ipv4_octet_vec(addr: Ipv4Addr): Vec<u8>\n+\n+/* Returns true for the special 'unspecified' address (0.0.0.0).\n+ *\n+ * This property is defined in UNIX Network Programming, Second Edition,\n+ * W. Richard Stevens, p. 891; see also ip7.\n+ */\n+extern function ipv4_is_unspecified(addr: Ipv4Addr): bool\n+\n+/* Returns true if this is a loopback address (127.0.0.0/8).\n+ *\n+ * This property is defined by IETF RFC 1122.\n+ */ \n+extern function ipv4_is_loopback(addr: Ipv4Addr): bool\n+\n+/* Returns true if this is a private address.\n+ *\n+ * The private address ranges are defined in IETF RFC 1918 and include:\n+ * - 10.0.0.0/8\n+ * - 172.16.0.0/12\n+ * - 192.168.0.0/16\n+ */\n+extern function ipv4_is_private(addr: Ipv4Addr): bool\n+\n+/* Returns true if the address is link-local (169.254.0.0/16).\n+ *\n+ * This property is defined by IETF RFC 3927.\n+ */\n+extern function ipv4_is_link_local(addr: Ipv4Addr): bool\n+\n+/* Returns true if this is a multicast address (224.0.0.0/4).\n+ *\n+ * Multicast addresses have a most significant octet between 224 and 239, and\n+ * is defined by IETF RFC 5771.\n+ */\n+extern function ipv4_is_multicast(addr: Ipv4Addr): bool\n+\n+/* Returns true if this is a broadcast address (255.255.255.255).\n+ *\n+ * A broadcast address has all octets set to 255 as defined in IETF RFC 919.\n+ */\n+extern function ipv4_is_broadcast(addr: Ipv4Addr): bool\n+\n+/* Returns true if this address is in a range designated for documentation.\n+ *\n+ * This is defined in IETF RFC 5737:\n+ *\n+ * - 192.0.2.0/24 (TEST-NET-1)\n+ * - 198.51.100.0/24 (TEST-NET-2)\n+ * - 203.0.113.0/24 (TEST-NET-3)\n+ */\n+extern function ipv4_is_documentation(addr: Ipv4Addr): bool\n+\n+/* Converts this address to an IPv4-compatible IPv6 address.\n+ *\n+ * a.b.c.d becomes ::a.b.c.d\n+ */\n+extern function ipv4_to_ipv6_compatible(addr: Ipv4Addr): Ipv6Addr", "originalCommit": "f1960576337d254d7b02031a3b89c93f4746f086", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2ODU3MQ==", "url": "https://github.com/vmware/differential-datalog/pull/509#discussion_r376668571", "bodyText": "Yep, fortunately we allow circular dependencies between modules.", "author": "ryzhyk", "createdAt": "2020-02-08T00:40:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2NTA1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjY2NTM5Mw==", "url": "https://github.com/vmware/differential-datalog/pull/509#discussion_r376665393", "bodyText": "I didn't know you could have mutually recursive modules.", "author": "mbudiu-vmw", "createdAt": "2020-02-08T00:21:18Z", "path": "lib/net/ipv6.dl", "diffHunk": "@@ -0,0 +1,134 @@\n+/* An IPv6 address.\n+ *\n+ * IPv6 addresses are defined as 128-bit integers in IETF RFC 4291. They are\n+ * usually represented as eight 16-bit segments.\n+ *\n+ * See IpAddr for a type encompassing both IPv4 and IPv6 addresses.\n+ *\n+ * The size of an Ipv6Addr struct may vary depending on the target operating\n+ * system.\n+ */\n+\n+import net.ipv4", "originalCommit": "f1960576337d254d7b02031a3b89c93f4746f086", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}