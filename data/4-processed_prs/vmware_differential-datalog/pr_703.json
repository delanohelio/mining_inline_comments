{"pr_number": 703, "pr_title": "Ad hoc polymorphism", "pr_createdAt": "2020-07-15T20:00:00Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/703", "timeline": [{"oid": "c07fbe3b45c5791a0198ab66e0e21fd83661821f", "url": "https://github.com/vmware/differential-datalog/commit/c07fbe3b45c5791a0198ab66e0e21fd83661821f", "message": "Type inference: Generalize lazy constraints.\n\nWe make the lazy constraint mechanism more powerful by having the solver\nattempt to expand a lazy constraint every time it learns something new\nabout the type of its trigger expression, not just when the type becomes\nfully concretized.  For example, a constraint that checks that a\nvariable is of a container type can be expanded as soon as the top-level\ndefinition has been resolved (i.e., we know whether it is a set or a\nvector) even if the element type of the container is not yet known.\n\nThis change is in preparation for the ad hoc polymorphism feature that\nwill require expanding the first argument of a function call just enough\nto disambiguate amoing all functions with the same name.", "committedDate": "2020-07-15T18:20:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMwOTM5OQ==", "url": "https://github.com/vmware/differential-datalog/pull/703#discussion_r455309399", "bodyText": "This seems inconsistent, before you said that non-extern functions cannot have side-effects. So what annotations are inferred?", "author": "mbudiu-vmw", "createdAt": "2020-07-15T20:03:57Z", "path": "doc/tutorial/tutorial.md", "diffHunk": "@@ -815,6 +842,23 @@ pub fn string_slice(x: &String, from: &u64, to: &u64) -> String {\n DDlog will automatically pickup this file and inline its contents in the\n generated `lib.rs`.\n \n+#### Functions with side effects\n+\n+Functions implemented completely in DDlog are pure (side-effect-free) computations.\n+It is however possible to declare extern functions with side effects.  The DDlog\n+compiler needs to know about these side effects, as they may interfere with its\n+optimizations.  The programmer is responsible for labeling such functions with\n+the `#[has_side_effects]` attribute, e.g., the following function is defined in\n+the `log.dl` library:\n+\n+```\n+#[has_side_effects]\n+extern function log(module: module_t, level: log_level_t, msg: string): ()\n+```\n+\n+The compiler automatically infers these annotations for non-extern functions, so", "originalCommit": "2eee92649fbf28e85fc3b2748a190f927c6713f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTM0Mzc0NQ==", "url": "https://github.com/vmware/differential-datalog/pull/703#discussion_r455343745", "bodyText": "non-extern functions can invoke extern functions with side effects.  I will clarify.", "author": "ryzhyk", "createdAt": "2020-07-15T21:04:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMwOTM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxNTQ1OQ==", "url": "https://github.com/vmware/differential-datalog/pull/703#discussion_r455315459", "bodyText": "why can't this go out of bounds?", "author": "mbudiu-vmw", "createdAt": "2020-07-15T20:15:31Z", "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -2592,6 +2596,15 @@ mkExpr' d ctx EAs{..} | bothIntegers && narrow_from && narrow_to && width_cmp /=\n \n mkExpr' _ _ e = error $ \"Compile.mkExpr': unexpected expression at \" ++ show (pos e)\n \n+mkFuncName :: DatalogProgram -> Function -> Doc\n+mkFuncName d f | length namesakes == 1 = rname $ name f\n+               | otherwise =\n+    (rname $ name f) <> \"_\" <> targ0 <> \"_\" <> pp (length $ funcArgs f)\n+    where\n+    arg0 = funcArgs f !! 0", "originalCommit": "2eee92649fbf28e85fc3b2748a190f927c6713f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTM0NTUwNg==", "url": "https://github.com/vmware/differential-datalog/pull/703#discussion_r455345506", "bodyText": "arg0 is only evaluated if this is a polymorphic function.  Polymorphic functions must take at least one argument (enforced in Validate.hs)", "author": "ryzhyk", "createdAt": "2020-07-15T21:06:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxNTQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxODM5Mw==", "url": "https://github.com/vmware/differential-datalog/pull/703#discussion_r455318393", "bodyText": "what happened to recursive functions?", "author": "mbudiu-vmw", "createdAt": "2020-07-15T20:20:53Z", "path": "src/Language/DifferentialDatalog/Expr.hs", "diffHunk": "@@ -433,18 +451,22 @@ exprIsVarOrField' _                = False\n -- to distinct outputs.\n exprIsInjective :: DatalogProgram -> ECtx -> S.Set Var -> Expr -> Bool\n exprIsInjective d ctx vs e =\n+    exprIsInjective_ d ctx vs e &&\n+    all (\\f -> case funcDef f of\n+                    Nothing -> False\n+                    Just e' -> exprIsInjective_ d (CtxFunc f) (S.fromList $ map (ArgVar f . name) $ funcArgs f) e')\n+        (exprFuncsRec d ctx e)\n+\n+-- Non-recursive part of exprIsInjective\n+exprIsInjective_ :: DatalogProgram -> ECtx -> S.Set Var -> Expr -> Bool\n+exprIsInjective_ d ctx vs e =\n     S.fromList (exprVars d ctx e) == vs &&\n     exprFold (exprIsInjective' d) e\n \n -- No clever analysis here; just the obvious cases.\n exprIsInjective' :: DatalogProgram -> ExprNode Bool -> Bool\n exprIsInjective' _ EVar{}        = True\n-exprIsInjective' d EApply{..}    =\n-    -- FIXME: once we add support for recursive functions, be careful to avoid\n-    -- infinite recursion.  The simple thing to do is just to return False for\n-    -- recursive functions, as reasoning about them seems tricky otherwise.\n-    and exprArgs && (maybe False (exprIsInjective d (CtxFunc f) (S.fromList $ map (\\a -> ArgVar f $ name a) funcArgs)) $ funcDef)\n-    where f@Function{..} = getFunc d exprFunc\n+exprIsInjective' _ EApply{..}    = and exprArgs", "originalCommit": "2eee92649fbf28e85fc3b2748a190f927c6713f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTM0Njk0NQ==", "url": "https://github.com/vmware/differential-datalog/pull/703#discussion_r455346945", "bodyText": "oops. I actually implemented support for them but forgot to use it here.", "author": "ryzhyk", "createdAt": "2020-07-15T21:08:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxODM5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTM1NDg3Mg==", "url": "https://github.com/vmware/differential-datalog/pull/703#discussion_r455354872", "bodyText": "no, we're good, that check just moved above.", "author": "ryzhyk", "createdAt": "2020-07-15T21:16:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMxODM5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyMzA0OA==", "url": "https://github.com/vmware/differential-datalog/pull/703#discussion_r455323048", "bodyText": "typo in error message", "author": "mbudiu-vmw", "createdAt": "2020-07-15T20:29:47Z", "path": "src/Language/DifferentialDatalog/Type.hs", "diffHunk": "@@ -257,10 +258,12 @@ exprNodeType' d ctx (EVar p v)            =\n                  -> varType d $ ExprVar ctx $ EVar p v\n          _       -> error $ \"exprNodeType': unknown variable \" ++ v ++ \" at \" ++ show p\n \n-exprNodeType' d ctx (EApply _ f _) | -- Type inference engine annotates calls to functions whose return type is polymorphic.\n-                                     typeIsPolymorphic t  = ctxExpectType ctx\n-                                   | otherwise            = t\n-    where t = funcType $ getFunc d f\n+exprNodeType' d ctx (EApply _ [f] ts) | -- Type inference engine annotates calls to functions whose return type is polymorphic.\n+                                      typeIsPolymorphic t  = ctxExpectType ctx\n+                                      | otherwise            = t\n+    where t = funcType $ getFunc d f ts\n+\n+exprNodeType' _ _   e@EApply{} = error $ \"exprNodeType' called with unresolved functio name: \" ++ show e", "originalCommit": "2eee92649fbf28e85fc3b2748a190f927c6713f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyOTMyMQ==", "url": "https://github.com/vmware/differential-datalog/pull/703#discussion_r455329321", "bodyText": "are you still doing this someplace else?", "author": "mbudiu-vmw", "createdAt": "2020-07-15T20:41:45Z", "path": "src/Language/DifferentialDatalog/Validate.hs", "diffHunk": "@@ -80,22 +81,27 @@ validate d = do\n                  }\n     -- Validate dependency graph\n     depGraphValidate d''\n+    {-\n     -- This check must be done after 'depGraphValidate', which may\n     -- introduce recursion\n     checkNoRecursion d''\n+    -}\n     -- Attributes do not affect the semantics of the program and can therefore\n     -- be validated last.\n     progValidateAttributes d''\n     return d''\n \n+{-", "originalCommit": "2eee92649fbf28e85fc3b2748a190f927c6713f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTM0ODI5OA==", "url": "https://github.com/vmware/differential-datalog/pull/703#discussion_r455348298", "bodyText": "no, recursive functions are now allowed", "author": "ryzhyk", "createdAt": "2020-07-15T21:09:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMyOTMyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTMzMTMxMg==", "url": "https://github.com/vmware/differential-datalog/pull/703#discussion_r455331312", "bodyText": "typo in comment?", "author": "mbudiu-vmw", "createdAt": "2020-07-15T20:45:33Z", "path": "test/antrea/networkpolicy_controller.dl", "diffHunk": "@@ -558,12 +558,12 @@ AppliedToGroupPod(appliedToGroup, k8s.PodReference{pod.name, pod.namespace}, pod\n \n AppliedToGroupPodsByNode(appliedToGroup, nodeName, pods) :-\n     AppliedToGroupPod(appliedToGroup, pod, nodeName),\n-    var pods = Aggregate((appliedToGroup, nodeName), group2set(pod)).\n+    var pods = Aggregate((appliedToGroup, nodeName), group_to_set(pod)).\n     //var podsByNode = Aggregate((appliedToGroup), group2map((nodeName, podsOnNode))).\n \n AppliedToGroupSpan(appliedToGroup, nodeName) :-\n     AppliedToGroupPod(appliedToGroup, _, nodeName).\n-//    var span = Aggregate((appliedToGroup), group2set(nodeName)).\n+//    var span = Aggregate((appliedToGroup), group`/2set(nodeName)).", "originalCommit": "2eee92649fbf28e85fc3b2748a190f927c6713f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a5cdc35d76dd2663985a3cb409e7d5e4fcdfaf7a", "url": "https://github.com/vmware/differential-datalog/commit/a5cdc35d76dd2663985a3cb409e7d5e4fcdfaf7a", "message": "Ad hoc polymorphism.\n\nThis commit implements RFC #670.\n\nWe already have support for argument polymorphism, e.g.:\n\n```\nfunction vec_length(v: Vec<'X>): usize\n```\n\nHere we introduce ad hoc polymorphism, that additionally allows defining\nfunctions with the same name for different types, e.g.,:\n\n```\nfunction size(v: Set<'X>): usize {...}\nfunction size(v: Map<'X>): usize {...}\n```\n\nThe compier uses the number of arguments and the type of the _first_ argument to\ndisambiguate the callee:\n\n```\n// (1)\nfunction size(v: Vec<'X>): usize {...}\n\n// OK: different number of arguments\nfunction size(v: Vec<'X>, foo: 'Y): usize {...}\n\n// OK: different type of the first argument.\nfunction size(v: Set<'X>): usize {...}\n\n// ERROR: conflicts with (1)\nfunction size(v: Vec<bool>): usize {...}\n```\n\nThis improves DDlog code in a coupe of ways:\n- We no longer need to prefix function names with type or module names\n- Once we support object-oriented function call notation, it will be\n  nicer to write `x.length()` vs `x.vec_length()`\n- We will be able to get rid of the horrible hack with string\n  conversions functions where the function name is computed by\n  addint `2string` to the type name, and just name all of them\n  `to_string()`.\n\nImplementation details:\n\n- Within a module, we always report conflicts regardless of whether\nconflicting functions are invoked anywhere in the program.  When\nconflicting declarations appear in different modules, we postpone the\ncheck until the user makes a function call that cannot be unambiguously\nresolved to one of the candidates, i.e., we won't complain even if the\nuser imports both modules unqualified unless they try calling the\nfunction.\n\n- Rust does not allow functions with the same name unless they appear\ninside different modules or impl blocks. Both options don't work well\nfor us. Instead the compiler mangles names of polymorphic functions by\nadding the type of the first argument and the number of arguments to the\nname. This is invisible to the user, except in extern functions, which\nmust be named-mangled manually. This is ugly and fragile; hence the\npreferred solution is to make sure that extern function names are\nunique, and define aliases to them in DDlog. E.g, in std.dl we keep old\nfunction names like string_substr and add new functions, e.g.,\nsubstr(string,...) that invoke them.\n\nThis commit also adds support for recursive functions.", "committedDate": "2020-07-15T21:24:03Z", "type": "commit"}, {"oid": "a5cdc35d76dd2663985a3cb409e7d5e4fcdfaf7a", "url": "https://github.com/vmware/differential-datalog/commit/a5cdc35d76dd2663985a3cb409e7d5e4fcdfaf7a", "message": "Ad hoc polymorphism.\n\nThis commit implements RFC #670.\n\nWe already have support for argument polymorphism, e.g.:\n\n```\nfunction vec_length(v: Vec<'X>): usize\n```\n\nHere we introduce ad hoc polymorphism, that additionally allows defining\nfunctions with the same name for different types, e.g.,:\n\n```\nfunction size(v: Set<'X>): usize {...}\nfunction size(v: Map<'X>): usize {...}\n```\n\nThe compier uses the number of arguments and the type of the _first_ argument to\ndisambiguate the callee:\n\n```\n// (1)\nfunction size(v: Vec<'X>): usize {...}\n\n// OK: different number of arguments\nfunction size(v: Vec<'X>, foo: 'Y): usize {...}\n\n// OK: different type of the first argument.\nfunction size(v: Set<'X>): usize {...}\n\n// ERROR: conflicts with (1)\nfunction size(v: Vec<bool>): usize {...}\n```\n\nThis improves DDlog code in a coupe of ways:\n- We no longer need to prefix function names with type or module names\n- Once we support object-oriented function call notation, it will be\n  nicer to write `x.length()` vs `x.vec_length()`\n- We will be able to get rid of the horrible hack with string\n  conversions functions where the function name is computed by\n  addint `2string` to the type name, and just name all of them\n  `to_string()`.\n\nImplementation details:\n\n- Within a module, we always report conflicts regardless of whether\nconflicting functions are invoked anywhere in the program.  When\nconflicting declarations appear in different modules, we postpone the\ncheck until the user makes a function call that cannot be unambiguously\nresolved to one of the candidates, i.e., we won't complain even if the\nuser imports both modules unqualified unless they try calling the\nfunction.\n\n- Rust does not allow functions with the same name unless they appear\ninside different modules or impl blocks. Both options don't work well\nfor us. Instead the compiler mangles names of polymorphic functions by\nadding the type of the first argument and the number of arguments to the\nname. This is invisible to the user, except in extern functions, which\nmust be named-mangled manually. This is ugly and fragile; hence the\npreferred solution is to make sure that extern function names are\nunique, and define aliases to them in DDlog. E.g, in std.dl we keep old\nfunction names like string_substr and add new functions, e.g.,\nsubstr(string,...) that invoke them.\n\nThis commit also adds support for recursive functions.", "committedDate": "2020-07-15T21:24:03Z", "type": "forcePushed"}]}