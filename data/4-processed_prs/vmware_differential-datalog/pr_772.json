{"pr_number": 772, "pr_title": "Support for lambda expressions and closures.", "pr_createdAt": "2020-10-02T23:30:33Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/772", "timeline": [{"oid": "b3ef7e8b588d7460564c9f3c5ed76b6a6a8c2c9d", "url": "https://github.com/vmware/differential-datalog/commit/b3ef7e8b588d7460564c9f3c5ed76b6a6a8c2c9d", "message": "First steps towards adding support for closures.\n\nFirst steps towards adding support for closures:\n- Extend the type system with function types.\n- Extend expression syntax with lambda expression.\n\nWe do not yet support parsing or type inference of closures.  There is\nalso no support for actually calling a closure.", "committedDate": "2020-09-16T02:10:57Z", "type": "commit"}, {"oid": "ae2dacdfe3b1d87f79f7e682e40b1e78a15bbd54", "url": "https://github.com/vmware/differential-datalog/commit/ae2dacdfe3b1d87f79f7e682e40b1e78a15bbd54", "message": "disable failing souffle test.", "committedDate": "2020-10-02T22:37:52Z", "type": "commit"}, {"oid": "b4476bdf778b75ad0e9ddf841021b25fb270b113", "url": "https://github.com/vmware/differential-datalog/commit/b4476bdf778b75ad0e9ddf841021b25fb270b113", "message": "disable another souffle test.", "committedDate": "2020-10-02T22:37:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NjA2NQ==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499096065", "bodyText": "no braces required here?", "author": "mbudiu-vmw", "createdAt": "2020-10-03T00:21:18Z", "path": "doc/language_reference/language_reference.md", "diffHunk": "@@ -426,6 +432,9 @@ vardecl_term ::= \"var\" var_name\n \n match_term   ::= \"match\" \"(\" expr \")\" \"{\" match_clause (,match_clause)*\"}\"\n match_clause ::= pattern \"->\" expr\n+\n+lambda_term  ::= \"function\" \"(\" [expr (\",\" expr)*] \")\" [\":\" simple_type_spec] expr", "originalCommit": "5cf0c6b188a7c1e4ecb33b44fce7df6400fd3594", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI2ODY3MQ==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499268671", "bodyText": "Good point. I don't think they are strictly necessary, but we may want to requite them for consistency.", "author": "ryzhyk", "createdAt": "2020-10-04T17:22:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NjA2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3MTg0Mw==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499971843", "bodyText": "fixed this", "author": "ryzhyk", "createdAt": "2020-10-06T02:29:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NjA2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NzE1Mw==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499097153", "bodyText": "how about a constructor with size hint?", "author": "mbudiu-vmw", "createdAt": "2020-10-03T00:29:40Z", "path": "lib/map.dl", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Functions for working with maps (see basic map operations defined in\n+ * `ddlog_std.dl`).\n+ */\n+\n+/* Applies closure `f` to each value in the map. */\n+function map(m: Map<'K,'V1>, f: function('V1): 'V2): Map<'K,'V2> {\n+    var res = map_empty();", "originalCommit": "5cf0c6b188a7c1e4ecb33b44fce7df6400fd3594", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI2ODcwOA==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499268708", "bodyText": "Maps and sets don't have one. Only vectors do.", "author": "ryzhyk", "createdAt": "2020-10-04T17:22:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NzE1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4Nzc1MA==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499787750", "bodyText": "that seems a misdesign.", "author": "mbudiu-vmw", "createdAt": "2020-10-05T18:22:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NzE1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc5NTg1Ng==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499795856", "bodyText": "You cannot easily pre-allocate memory for a map or set as they are backed by trees.  I don't think I've ever seen a library in any language that does that.", "author": "ryzhyk", "createdAt": "2020-10-05T18:38:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NzE1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NzYyNg==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499097626", "bodyText": "Do we document somewhere the relationship between ddlog types and rust types for extern function writers?", "author": "mbudiu-vmw", "createdAt": "2020-10-03T00:33:10Z", "path": "lib/map.rs", "diffHunk": "@@ -0,0 +1,11 @@\n+use crate::closure::Closure;\n+use crate::ddlog_std;\n+\n+pub fn map_map_in_place<K: Ord, V>(\n+    m: &mut ddlog_std::Map<K, V>,\n+    f: &Box<dyn Closure<(*const K, *mut V), ()>>,", "originalCommit": "5cf0c6b188a7c1e4ecb33b44fce7df6400fd3594", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI2ODczMQ==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499268731", "bodyText": "Not at the moment, but we should.", "author": "ryzhyk", "createdAt": "2020-10-04T17:23:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NzYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NzkwNA==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499097904", "bodyText": "arg_min?", "author": "mbudiu-vmw", "createdAt": "2020-10-03T00:35:32Z", "path": "lib/vec.dl", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Functions for working with vectors (see basic vector operations defined in\n+ * `ddlog_std.dl`).\n+ */\n+\n+/* Applies closure `f` to each element of the vector. */\n+function map(v: Vec<'A>, f: function('A): 'B): Vec<'B> {\n+    var res = vec_with_capacity(v.len());\n+    for (x in v) {\n+        res.push(f(x))\n+    };\n+    res\n+}\n+\n+/* Applies closure `f` to each element of the vector and concatenates the\n+ * resulting vectors, returning a flat vector. */\n+function flatmap(v: Vec<'A>, f: function('A): Vec<'B>): Vec<'B> {\n+    var res = vec_empty();\n+    for (x in v) {\n+        res.append(f(x))\n+    };\n+    res\n+}\n+\n+/* Sorts the vector with a key extraction function, but may not preserve the\n+ * order of equal elements. */\n+function sort_by(v: mut Vec<'A>, f: function('A): 'B) {\n+    vec_sort_by(v, f)\n+}\n+\n+/* Returns the element that gives the minimum value from the specified function.\n+ * If several elements are equally minimum, the first element is returned.\n+ * If the vector is empty, `None` is returned. */\n+function min_by(v: Vec<'A>, f: function('A): 'B): Option<'A> {", "originalCommit": "5cf0c6b188a7c1e4ecb33b44fce7df6400fd3594", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3Mjc4Mw==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499972783", "bodyText": "arg_min is more standard math terminology, but min_by is going to be easier to locate for someone who is not familiar with the terminology.  Ok, I guess I'll change to arg_min", "author": "ryzhyk", "createdAt": "2020-10-06T02:33:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5NzkwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5ODE5Mw==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499098193", "bodyText": "in the future we'll just have an Iterable trait...", "author": "mbudiu-vmw", "createdAt": "2020-10-03T00:37:49Z", "path": "lib/vec.dl", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Functions for working with vectors (see basic vector operations defined in\n+ * `ddlog_std.dl`).\n+ */\n+\n+/* Applies closure `f` to each element of the vector. */\n+function map(v: Vec<'A>, f: function('A): 'B): Vec<'B> {\n+    var res = vec_with_capacity(v.len());\n+    for (x in v) {\n+        res.push(f(x))\n+    };\n+    res\n+}\n+\n+/* Applies closure `f` to each element of the vector and concatenates the\n+ * resulting vectors, returning a flat vector. */\n+function flatmap(v: Vec<'A>, f: function('A): Vec<'B>): Vec<'B> {\n+    var res = vec_empty();\n+    for (x in v) {\n+        res.append(f(x))\n+    };\n+    res\n+}\n+\n+/* Sorts the vector with a key extraction function, but may not preserve the\n+ * order of equal elements. */\n+function sort_by(v: mut Vec<'A>, f: function('A): 'B) {\n+    vec_sort_by(v, f)\n+}\n+\n+/* Returns the element that gives the minimum value from the specified function.\n+ * If several elements are equally minimum, the first element is returned.\n+ * If the vector is empty, `None` is returned. */\n+function min_by(v: Vec<'A>, f: function('A): 'B): Option<'A> {\n+    vec_min_by(v, f)\n+}\n+\n+/* Returns the element that gives the maximum value from the specified function.\n+ * If several elements are equally maximum, the first element is returned.\n+ * If the vector is empty, `None` is returned. */\n+function max_by(v: Vec<'A>, f: function('A): 'B): Option<'A> {\n+    vec_max_by(v, f)\n+}\n+\n+/* Returns the first element of the vector that satisfies predicate `f` or\n+ * `None` if none of the elements satisfy the predicate. */\n+function find(v: Vec<'A>, f: function('A): bool): Option<'A> {\n+    for (x in v) {\n+        if (f(x)) {\n+            return Some{x}\n+        }\n+    };\n+    None\n+}\n+\n+/* Returns a vector containing only those elements in `v` that satisfy predicate `f`,\n+ * preserving the order of the elements in the original vector. */\n+function filter(v: Vec<'A>, f: function('A): bool): Vec<'A> {\n+    var res = vec_empty();\n+    for (x in v) {\n+        if (f(x)) {\n+            res.push(x)\n+        }\n+    };\n+    res\n+}\n+\n+/* Both filters and maps the vector.\n+ *\n+ * Calls the closure on each element of the vector.  If the closure returns\n+ * `Some{element}`, then that element is returned. */\n+function filter_map(v: Vec<'A>, f: function('A): Option<'B>): Vec<'B> {\n+    var res = vec_empty();\n+    for (x in v) {\n+        match (f(x)) {\n+            None -> (),\n+            Some{y} -> res.push(y)\n+        }\n+    };\n+    res\n+}\n+\n+\n+/* Retains only the elements specified by the predicate.\n+ * In other words, remove all elements `e` such that `f(e)` returns `false`.\n+ * This method operates in place, visiting each element exactly once in the\n+ * original order, and preserves the order of the retained elements. */\n+function retain(v: mut Vec<'A>, f: function('A): bool) {\n+    var del: s64 = 0;\n+    var len = v.len();\n+\n+    for (i in range(0, (len as isize) - 1, 1)) {\n+        var x = v.nth(i as usize).unwrap_or_default();\n+        if (not f(x)) {\n+            del = del + 1\n+        } else if (del > 0) {\n+            v.update_nth((i - del) as usize, x);\n+        }\n+    };\n+    if (del > 0) {\n+        v.truncate(len - (del as usize));\n+    }\n+}\n+\n+/* Returns `true` iff all elements of the vector satisfy predicate `f`. */\n+function all(v: Vec<'A>, f: function('A): bool): bool {\n+    for (x in v) {", "originalCommit": "5cf0c6b188a7c1e4ecb33b44fce7df6400fd3594", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI2OTIzNw==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499269237", "bodyText": "Speaking of which, we don't have a way to implement lazy iterators at the moment (as they require either lifetimes or reference counting), so for example, if we have  e.filter(..).all(..), then filter will iterate to the end of the collection even if all can terminate early.", "author": "ryzhyk", "createdAt": "2020-10-04T17:28:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5ODE5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTc4ODUzOQ==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499788539", "bodyText": "I think it should be possible to do that, but I don't know enough about Rust to see the potential difficulties.\nEach element should have a reference in exactly one iterator, so I imagine it should be possible to do that.", "author": "mbudiu-vmw", "createdAt": "2020-10-05T18:24:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5ODE5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwNTY0MQ==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499805641", "bodyText": "Example: v.map(...).find(..)\nThe return value of map is Vec.  DDlog returns by-value, so we need to create a fully populated vector before passing it to the next transformer (find).\nLet's say, we change map to return Iterator<> instead. The iterator object would internally hold a reference to the original vector v.  This is safe as long as the iterator is destroyed before anyone tries to modify or destroy v, which is the case here. But not in this code:\nvar iter = v.map();\nv.push(x);\niter.find(...);\n\nIn Rust this cannot happen thanks to the borrow checker.  In fact, the above code will be rejected by the Rust compiler.  But DDlog does not currently have a way to track ownership.", "author": "ryzhyk", "createdAt": "2020-10-05T18:56:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5ODE5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwNzE0NA==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499807144", "bodyText": "perhaps you should be able to obtain an iterator only from an immutable vector. this is a reasonable constraint.", "author": "mbudiu-vmw", "createdAt": "2020-10-05T18:59:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5ODE5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgwOTY2MA==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499809660", "bodyText": "We'll need to add a concept of mutable variables  for that, but this still does not address the lifetime issue.  The iterator can outlive the vector it was create from. Without reference counting or a borrow checker we cannot support this safely.", "author": "ryzhyk", "createdAt": "2020-10-05T19:03:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5ODE5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgxMDMzNQ==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499810335", "bodyText": "how about an iterator that actually consumes the vector?", "author": "mbudiu-vmw", "createdAt": "2020-10-05T19:05:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5ODE5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTgzMTUzMQ==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499831531", "bodyText": "That might work, but again this is a pretty big change to the language (we'd have to annotate functions to consume their arguments and enforce that they are not used afterwards). And then you don't always want to consume the argument.  Point is, you cannot easily retrofit a new ownership model in the language.  There is a lot of complexity in Rust that takes care of that.", "author": "ryzhyk", "createdAt": "2020-10-05T19:46:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5ODE5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5ODI3NQ==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499098275", "bodyText": "if there is a stable sort, why not expose that one too?", "author": "mbudiu-vmw", "createdAt": "2020-10-03T00:38:31Z", "path": "lib/vec.rs", "diffHunk": "@@ -0,0 +1,20 @@\n+use crate::closure::Closure;\n+use crate::ddlog_std;\n+\n+pub fn vec_sort_by<A, B: Ord>(v: &mut ddlog_std::Vec<A>, f: &Box<dyn Closure<*const A, B>>) {\n+    v.x.sort_unstable_by_key(|x| f.call(x))", "originalCommit": "5cf0c6b188a7c1e4ecb33b44fce7df6400fd3594", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI2OTI4MQ==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499269281", "bodyText": "We can also have vec_sort_by_stable.  Stable sort is less efficient though.", "author": "ryzhyk", "createdAt": "2020-10-04T17:28:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5ODI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5ODg0OQ==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499098849", "bodyText": "So you compare pointer values?\nIsn't there a safe way to do this?", "author": "mbudiu-vmw", "createdAt": "2020-10-03T00:42:54Z", "path": "rust/template/types/closure.rs", "diffHunk": "@@ -0,0 +1,412 @@\n+#![allow(\n+    clippy::trivially_copy_pass_by_ref\n+)]\n+\n+//! Runtime support for DDlog closures.\n+\n+use ::std::cmp::Ordering;\n+use ::std::fmt::Debug;\n+use ::std::fmt::Display;\n+use ::std::fmt::Formatter;\n+use ::std::hash::Hash;\n+use ::std::hash::Hasher;\n+use ::std::result::Result;\n+\n+use ::serde::de::Error;\n+use ::serde::Deserialize;\n+use ::serde::Deserializer;\n+use ::serde::Serialize;\n+use ::serde::Serializer;\n+\n+use crate::Val;\n+\n+#[cfg(feature = \"flatbuf\")]\n+use flatbuffers as fbrt;\n+\n+#[cfg(feature = \"flatbuf\")]\n+use crate::flatbuf;\n+\n+#[cfg(feature = \"flatbuf\")]\n+use crate::flatbuf::ToFlatBuffer;\n+\n+#[cfg(feature = \"flatbuf\")]\n+use crate::flatbuf::fb;\n+\n+use ::differential_datalog::record::FromRecord;\n+use ::differential_datalog::record::IntoRecord;\n+use ::differential_datalog::record::Mutator;\n+use ::differential_datalog::record::Record;\n+\n+use ::abomonation::Abomonation;\n+\n+/* DDlog's equivalent of Rust's `Fn` trait.  This is necessary, as Rust does not allow manual\n+ * implementations of `Fn` trait (until `unboxed_closures` and `fn_traits` features are\n+ * stabilized).  Otherwise, we would just derive `Fn` and add methods for comparison and hashing.\n+ */\n+pub trait Closure<Args, Output> {\n+    fn call(&self, args: Args) -> Output;\n+    /* Returns pointers to function and captured arguments, for use in comparison methods. */\n+    fn internals(&self) -> (usize, usize);\n+    fn clone_dyn(&self) -> Box<dyn Closure<Args, Output>>;\n+    fn eq_dyn(&self, other: &dyn Closure<Args, Output>) -> bool;\n+    fn cmp_dyn(&self, other: &dyn Closure<Args, Output>) -> Ordering;\n+    fn hash_dyn(&self, state: &mut dyn Hasher);\n+    fn into_record_dyn(&self) -> Record;\n+    fn fmt_debug_dyn(&self, f: &mut Formatter) -> std::fmt::Result;\n+    fn fmt_display_dyn(&self, f: &mut Formatter) -> std::fmt::Result;\n+    fn serialize_dyn(&self) -> &dyn erased_serde::Serialize;\n+}\n+\n+#[derive(Clone)]\n+pub struct ClosureImpl<Args, Output, Captured: Val> {\n+    pub description: &'static str,\n+    pub captured: Captured,\n+    pub f: fn(args: Args, captured: &Captured) -> Output,\n+}\n+\n+impl<Args, Output, Captured: Debug + Val> Serialize for ClosureImpl<Args, Output, Captured> {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        serializer.serialize_str(&format!(\n+            \"<closure: {}, captured_args: {:?}>\",\n+            self.description, self.captured\n+        ))\n+    }\n+}\n+\n+/* Rust forces 'static trait bound on `Args` and `Output`, as the borrow checker is not smart\n+ * enough to realize that they are only used as arguments to `f`.\n+ */\n+impl<Args: Clone + 'static, Output: Clone + 'static, Captured: Debug + Val> Closure<Args, Output>\n+    for ClosureImpl<Args, Output, Captured>\n+{\n+    fn call(&self, args: Args) -> Output {\n+        (self.f)(args, &self.captured)\n+    }\n+\n+    fn clone_dyn(&self) -> Box<dyn Closure<Args, Output>> {\n+        Box::new((*self).clone()) as Box<dyn Closure<Args, Output>>\n+    }\n+\n+    fn internals(&self) -> (usize, usize) {\n+        (\n+            self.f as *const (fn(Args, &Captured) -> Output) as usize,\n+            &self.captured as *const Captured as usize,\n+        )\n+    }\n+\n+    fn eq_dyn(&self, other: &dyn Closure<Args, Output>) -> bool {\n+        /* Compare function pointers.  If equal, it is safe to compare captured variables. */\n+        let (other_f, other_captured) = other.internals();\n+        if (other_f == (self.f as *const (fn(Args, &Captured) -> Output) as usize)) {\n+            unsafe { *(other_captured as *const Captured) == self.captured }", "originalCommit": "5cf0c6b188a7c1e4ecb33b44fce7df6400fd3594", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5OTIyNg==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499099226", "bodyText": "I wonder whether this will cause problems in a distributed settings. I think that we have an invariant so far that the ordering/hash/equality of values on different machines is the same.", "author": "mbudiu-vmw", "createdAt": "2020-10-03T00:45:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5ODg0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI3MDA4Mw==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499270083", "bodyText": "Isn't there a safe way to do this?\nNot if pointers can point to functions of different types, which is the case here, because even closures of the same type can differ in the type of their captured values.\n\n\nI wonder whether this will cause problems in a distributed settings. I think that we have an invariant so far that the ordering/hash/equality of values on different machines is the same.\n\nIt's not a problem for closures, as closures cannot be sent across the network atm (we'd have to parse and compile DDlog code on the fly).  But this may be a problem, e.g., for interned values whose order will definitely change as you send them across the network. #663 would address this problem.", "author": "ryzhyk", "createdAt": "2020-10-04T17:37:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5ODg0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTA5OTc1NQ==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499099755", "bodyText": "I guess we won't worry about moving closures between machines then.", "author": "mbudiu-vmw", "createdAt": "2020-10-03T00:49:53Z", "path": "rust/template/types/closure.rs", "diffHunk": "@@ -0,0 +1,412 @@\n+#![allow(\n+    clippy::trivially_copy_pass_by_ref\n+)]\n+\n+//! Runtime support for DDlog closures.\n+\n+use ::std::cmp::Ordering;\n+use ::std::fmt::Debug;\n+use ::std::fmt::Display;\n+use ::std::fmt::Formatter;\n+use ::std::hash::Hash;\n+use ::std::hash::Hasher;\n+use ::std::result::Result;\n+\n+use ::serde::de::Error;\n+use ::serde::Deserialize;\n+use ::serde::Deserializer;\n+use ::serde::Serialize;\n+use ::serde::Serializer;\n+\n+use crate::Val;\n+\n+#[cfg(feature = \"flatbuf\")]\n+use flatbuffers as fbrt;\n+\n+#[cfg(feature = \"flatbuf\")]\n+use crate::flatbuf;\n+\n+#[cfg(feature = \"flatbuf\")]\n+use crate::flatbuf::ToFlatBuffer;\n+\n+#[cfg(feature = \"flatbuf\")]\n+use crate::flatbuf::fb;\n+\n+use ::differential_datalog::record::FromRecord;\n+use ::differential_datalog::record::IntoRecord;\n+use ::differential_datalog::record::Mutator;\n+use ::differential_datalog::record::Record;\n+\n+use ::abomonation::Abomonation;\n+\n+/* DDlog's equivalent of Rust's `Fn` trait.  This is necessary, as Rust does not allow manual\n+ * implementations of `Fn` trait (until `unboxed_closures` and `fn_traits` features are\n+ * stabilized).  Otherwise, we would just derive `Fn` and add methods for comparison and hashing.\n+ */\n+pub trait Closure<Args, Output> {\n+    fn call(&self, args: Args) -> Output;\n+    /* Returns pointers to function and captured arguments, for use in comparison methods. */\n+    fn internals(&self) -> (usize, usize);\n+    fn clone_dyn(&self) -> Box<dyn Closure<Args, Output>>;\n+    fn eq_dyn(&self, other: &dyn Closure<Args, Output>) -> bool;\n+    fn cmp_dyn(&self, other: &dyn Closure<Args, Output>) -> Ordering;\n+    fn hash_dyn(&self, state: &mut dyn Hasher);\n+    fn into_record_dyn(&self) -> Record;\n+    fn fmt_debug_dyn(&self, f: &mut Formatter) -> std::fmt::Result;\n+    fn fmt_display_dyn(&self, f: &mut Formatter) -> std::fmt::Result;\n+    fn serialize_dyn(&self) -> &dyn erased_serde::Serialize;\n+}\n+\n+#[derive(Clone)]\n+pub struct ClosureImpl<Args, Output, Captured: Val> {\n+    pub description: &'static str,\n+    pub captured: Captured,\n+    pub f: fn(args: Args, captured: &Captured) -> Output,\n+}\n+\n+impl<Args, Output, Captured: Debug + Val> Serialize for ClosureImpl<Args, Output, Captured> {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        serializer.serialize_str(&format!(\n+            \"<closure: {}, captured_args: {:?}>\",\n+            self.description, self.captured\n+        ))\n+    }\n+}\n+\n+/* Rust forces 'static trait bound on `Args` and `Output`, as the borrow checker is not smart\n+ * enough to realize that they are only used as arguments to `f`.\n+ */\n+impl<Args: Clone + 'static, Output: Clone + 'static, Captured: Debug + Val> Closure<Args, Output>\n+    for ClosureImpl<Args, Output, Captured>\n+{\n+    fn call(&self, args: Args) -> Output {\n+        (self.f)(args, &self.captured)\n+    }\n+\n+    fn clone_dyn(&self) -> Box<dyn Closure<Args, Output>> {\n+        Box::new((*self).clone()) as Box<dyn Closure<Args, Output>>\n+    }\n+\n+    fn internals(&self) -> (usize, usize) {\n+        (\n+            self.f as *const (fn(Args, &Captured) -> Output) as usize,\n+            &self.captured as *const Captured as usize,\n+        )\n+    }\n+\n+    fn eq_dyn(&self, other: &dyn Closure<Args, Output>) -> bool {\n+        /* Compare function pointers.  If equal, it is safe to compare captured variables. */\n+        let (other_f, other_captured) = other.internals();\n+        if (other_f == (self.f as *const (fn(Args, &Captured) -> Output) as usize)) {\n+            unsafe { *(other_captured as *const Captured) == self.captured }\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn cmp_dyn(&self, other: &dyn Closure<Args, Output>) -> Ordering {\n+        let (other_f, other_captured) = other.internals();\n+        match ((self.f as *const (fn(Args, &Captured) -> Output) as usize).cmp(&other_f)) {\n+            Ordering::Equal => self\n+                .captured\n+                .cmp(unsafe { &*(other_captured as *const Captured) }),\n+            ord => ord,\n+        }\n+    }\n+\n+    fn hash_dyn(&self, mut state: &mut dyn Hasher) {\n+        self.captured.hash(&mut state);\n+        (self.f as *const (fn(Args, &Captured) -> Output) as usize).hash(&mut state);\n+    }\n+\n+    fn into_record_dyn(&self) -> Record {\n+        Record::String(format!(\n+            \"<closure: {}, captured_args: {:?}>\",\n+            self.description, self.captured\n+        ))\n+    }\n+\n+    fn fmt_debug_dyn(&self, f: &mut Formatter) -> std::fmt::Result {\n+        f.write_fmt(format_args!(\n+            \"<closure: {}, captured_args: {:?}>\",\n+            self.description, self.captured\n+        ))\n+    }\n+\n+    fn fmt_display_dyn(&self, f: &mut Formatter) -> std::fmt::Result {\n+        f.write_fmt(format_args!(\n+            \"<closure: {}, captured_args: {:?}>\",\n+            self.description, self.captured\n+        ))\n+    }\n+\n+    fn serialize_dyn(&self) -> &dyn erased_serde::Serialize {\n+        self as &dyn erased_serde::Serialize\n+    }\n+}\n+\n+impl<Args: Clone + 'static, Output: Clone + 'static> Display for Box<dyn Closure<Args, Output>> {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n+        self.fmt_display_dyn(f)\n+    }\n+}\n+\n+impl<Args: Clone + 'static, Output: Clone + 'static> Debug for Box<dyn Closure<Args, Output>> {\n+    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {\n+        self.fmt_debug_dyn(f)\n+    }\n+}\n+\n+impl<Args: Clone + 'static, Output: Clone + 'static> PartialEq<&Self>\n+    for Box<dyn Closure<Args, Output>>\n+{\n+    fn eq(&self, other: &&Self) -> bool {\n+        self.eq_dyn(&***other)\n+    }\n+}\n+\n+/* This extra impl is a workaround for compiler bug that fails to derive `PartialEq` for\n+ * structs that contain fields of type `Box<dyn Closure<>>`. See:\n+ * https://github.com/rust-lang/rust/issues/31740#issuecomment-700950186 */\n+impl<Args: Clone + 'static, Output: Clone + 'static> PartialEq for Box<dyn Closure<Args, Output>> {\n+    fn eq(&self, other: &Self) -> bool {\n+        self.eq_dyn(&**other)\n+    }\n+}\n+impl<Args: Clone + 'static, Output: Clone + 'static> Eq for Box<dyn Closure<Args, Output>> {}\n+\n+impl<Args: Clone + 'static, Output: Clone + 'static> PartialOrd for Box<dyn Closure<Args, Output>> {\n+    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n+        Some(self.cmp_dyn(&**other))\n+    }\n+}\n+impl<Args: Clone + 'static, Output: Clone + 'static> Ord for Box<dyn Closure<Args, Output>> {\n+    fn cmp(&self, other: &Self) -> Ordering {\n+        self.cmp_dyn(&**other)\n+    }\n+}\n+\n+impl<Args: Clone + 'static, Output: Clone + 'static> Clone for Box<dyn Closure<Args, Output>> {\n+    fn clone(&self) -> Self {\n+        self.clone_dyn()\n+    }\n+}\n+\n+impl<Args: 'static + Clone, Output: 'static + Clone + Default> Default\n+    for Box<dyn Closure<Args, Output>>\n+{\n+    fn default() -> Self {\n+        Box::new(ClosureImpl {\n+            description: \"default closure\",\n+            captured: (),\n+            f: {\n+                fn __f<A, O: Default>(args: A, captured: &()) -> O {\n+                    O::default()\n+                };\n+                __f\n+            },\n+        })\n+    }\n+}\n+\n+impl<Args: 'static + Clone, Output: 'static + Clone> Hash for Box<dyn Closure<Args, Output>> {\n+    fn hash<H>(&self, state: &mut H)\n+    where\n+        H: Hasher,\n+    {\n+        self.hash_dyn(state);\n+    }\n+}\n+\n+impl<Args: 'static + Clone, Output: 'static + Clone> Serialize for Box<dyn Closure<Args, Output>> {\n+    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>\n+    where\n+        S: Serializer,\n+    {\n+        erased_serde::serialize((self.serialize_dyn()), serializer)\n+    }\n+}\n+\n+impl<'de, Args: 'static + Clone, Output: 'static + Clone> Deserialize<'de>\n+    for Box<dyn Closure<Args, Output>>\n+{\n+    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>\n+    where\n+        D: Deserializer<'de>,\n+    {\n+        Err(D::Error::custom(\n+            \"Deserialization of closures is not implemented.\",", "originalCommit": "5cf0c6b188a7c1e4ecb33b44fce7df6400fd3594", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "15b0f7dd5500213a6765ad5b1130129cc32995f4", "url": "https://github.com/vmware/differential-datalog/commit/15b0f7dd5500213a6765ad5b1130129cc32995f4", "message": "Support for lambda expressions and closures.\n\nThis commit implements RFC #669.\nIt also fixes #768 along the way.\n\nLanguage extensions\n-------------------\n\n* Extended the type system with function types:\n  ```\n  typedef usize_to_string: function(x: usize): tring\n  ```\n\n* Lambda expressions\n  ```\n  var captured = 10;\n  var f = |x: usize| x * captured;\n  ```\n  A lambda expression returns a closute at runtime (note the use of a captured variable).\n\n* Function application syntax.  We used to parse function invocations as\n  `<function_name>(<expr>*)`.  This has been changed to `<expr>(<expr*>)`,\n  where the first expression must return a value of function type and\n  can be (1) function name, (2) lambda expression, (3) any other\n  expression that returns closure.\n\n  ```\n  // function call.\n  f(x);\n\n  // invoke a closure.\n  var closure = |a| a * a;\n  closure(x);\n  ```\n\n* Generalized polymorphic functions.  Although this is not strictly\n  required for the above features, this PR also improves support for\n  ad hoc polymorphism.  Instead of using the first argument to\n  disambiguate functions with the same name, we now use the combination\n  of all arguments and the return type.\n\nLibraries\n---------\n\nNow that we have closures, we can implement various standard\nhigher-order functions over containers: map, filter, flatmap, find, all,\netc.  These now live in three new libraries that will keep growing.\n\n* `vec.dl`\n\n* `set.dl`\n\n* `map.dl`\n\nSee tutorial section on closures for more details.", "committedDate": "2020-10-04T19:27:24Z", "type": "commit"}, {"oid": "0094e064e0ab8f8b82dbc376740e9f76403dcaed", "url": "https://github.com/vmware/differential-datalog/commit/0094e064e0ab8f8b82dbc376740e9f76403dcaed", "message": "Removed .ast.expected files.\n\nThey may test writing unnecessarily tedious.  Worse, the must be updated\nwhenever libraries change. Overall, lots of pain with minimal benefit.", "committedDate": "2020-10-04T19:27:24Z", "type": "commit"}, {"oid": "250b6a8f421e3ef022c286528419d96f5727d684", "url": "https://github.com/vmware/differential-datalog/commit/250b6a8f421e3ef022c286528419d96f5727d684", "message": "Syntax.hs: Format non-term expressions in parens.\n\nChange the implementation of `PP Expr` to make sure that expressions\nthat do not represent a single `term`, e.g., function application, are\nprinted in parens, so that they parse correctly in contexts that require\na term, e.g., if-then-else expressions and for-loops.", "committedDate": "2020-10-04T19:27:24Z", "type": "forcePushed"}, {"oid": "3a79ce773028afa89fee44d8cd482e4d621e8d30", "url": "https://github.com/vmware/differential-datalog/commit/3a79ce773028afa89fee44d8cd482e4d621e8d30", "message": "Syntax.hs: Format non-term expressions in parens.\n\nChange the implementation of `PP Expr` to make sure that expressions\nthat do not represent a single `term`, e.g., function application, are\nprinted in parens, so that they parse correctly in contexts that require\na term, e.g., if-then-else expressions and for-loops.", "committedDate": "2020-10-04T21:41:47Z", "type": "commit"}, {"oid": "3a79ce773028afa89fee44d8cd482e4d621e8d30", "url": "https://github.com/vmware/differential-datalog/commit/3a79ce773028afa89fee44d8cd482e4d621e8d30", "message": "Syntax.hs: Format non-term expressions in parens.\n\nChange the implementation of `PP Expr` to make sure that expressions\nthat do not represent a single `term`, e.g., function application, are\nprinted in parens, so that they parse correctly in contexts that require\na term, e.g., if-then-else expressions and for-loops.", "committedDate": "2020-10-04T21:41:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk0NTE4Mg==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499945182", "bodyText": "alternatively, you can look at the priority of the enclosing context and decide whether you need parens.\nIt's always safe with parens.", "author": "mbudiu-vmw", "createdAt": "2020-10-06T00:39:32Z", "path": "src/Language/DifferentialDatalog/Syntax.hs", "diffHunk": "@@ -766,18 +833,21 @@ instance Ord e => Ord (ExprNode e) where\n     compare (EAs _ e1 t1)            (EAs _ e2 t2)              = compare (e1, t1) (e2, t2)\n     compare (ERef _ p1)              (ERef _ p2)                = compare p1 p2\n     compare (ETry _ e1)              (ETry _ e2)                = compare e1 e2\n+    compare (EClosure _ as1 r1 e1)   (EClosure _ as2 r2 e2)     = compare (as1, r1, e1) (as2, r2, e2)\n+    compare (EFunc _ f1)              (EFunc _ f2)              = compare f1 f2\n     compare e1                       e2                         = compare (erank e1) (erank e2)\n \n instance WithPos (ExprNode e) where\n     pos = exprPos\n     atPos e p = e{exprPos = p}\n \n+-- Expressions that do not represent a single `term` must be printed in parens, so that", "originalCommit": "3a79ce773028afa89fee44d8cd482e4d621e8d30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NzEyMg==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499957122", "bodyText": "why isn't this checked anymore?", "author": "mbudiu-vmw", "createdAt": "2020-10-06T01:27:16Z", "path": "src/Language/DifferentialDatalog/Validate.hs", "diffHunk": "@@ -557,11 +557,9 @@ exprValidate1 _ _ ctx EVar{..} | ctxInRuleRHSPositivePattern ctx\n                                           = return ()\n exprValidate1 d _ ctx (EVar p v)          = do _ <- checkVar p d ctx v\n                                                return ()\n-exprValidate1 d _ _   (EApply p fnames as) = do\n-    fs <- concat <$> mapM (\\fname -> checkFuncs p d fname (length as)) fnames\n-    check d (length fs > 0) p $ \"Unknown function '\" ++ (nameLocalStr $ head fnames) ++ \"'\"\n-    check d (length fs == 1 || (not $ null as)) p $ \"Ambiguous function name '\" ++ (nameLocalStr $ head fnames) ++ \"' may refer to:\\n  \" ++\n-                                                    (intercalate \"\\n  \" $ map (\\f -> name f ++ \" at \" ++ spos f) fs)\n+exprValidate1 _ _ _   EApply{}            = return ()", "originalCommit": "3a79ce773028afa89fee44d8cd482e4d621e8d30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NzI1Mg==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499957252", "bodyText": "I am guessing this moved to typechecking", "author": "mbudiu-vmw", "createdAt": "2020-10-06T01:27:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NzEyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3MzExNQ==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499973115", "bodyText": "yes, and also to exprValidate1 EFunc{}", "author": "ryzhyk", "createdAt": "2020-10-06T02:35:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NzEyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk1NzM3MA==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499957370", "bodyText": "how about adding a warning function and then calling it?", "author": "mbudiu-vmw", "createdAt": "2020-10-06T01:28:19Z", "path": "src/Language/DifferentialDatalog/Validate.hs", "diffHunk": "@@ -684,9 +680,22 @@ exprValidate3 d ctx e@(EMatch _ x cs) = do\n                 ct0 (map fst cs)\n     check d (consTreeEmpty ct) (pos x) \"Non-exhaustive match patterns\"\n exprValidate3 d ctx (ESet _ l _)         = checkLExpr d ctx l\n-exprValidate3 d ctx e@(EApply _ _ as)      = do\n-    let fun = applyExprGetFunc d ctx e\n-    mapM_ (\\(a, mut) -> when mut $ checkLExpr d ctx a)\n-          $ zip as (map argMut $ funcArgs fun)\n+exprValidate3 d ctx e@(EApply _ f as)    = do\n+    let ft = exprType' d (CtxApplyFunc e ctx) f\n+    mapIdxM_ (\\(a, mut) i -> when mut $ checkLExpr d (CtxApplyArg e ctx i) a)\n+             $ zip as (map atypeMut $ typeFuncArgs ft)\n \n+{-\n+-- We currently allow converting functions that return values by-reference into", "originalCommit": "3a79ce773028afa89fee44d8cd482e4d621e8d30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk2MjE3NA==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499962174", "bodyText": "typo", "author": "mbudiu-vmw", "createdAt": "2020-10-06T01:48:15Z", "path": "test/datalog_tests/vec_test.dl", "diffHunk": "@@ -0,0 +1,125 @@\n+import vec\n+\n+function int_vec(): Vec<s64> {\n+    range(-10, 10, 1)\n+}\n+\n+output relation IntVecTransforms(description: string, v: Vec<s64>)\n+\n+// filter.\n+IntVecTransforms(\"odds\", int_vec().filter(|x| x % 2 != 0)).\n+\n+function is_even(x: s64): bool {\n+    x % 2 == 0\n+}\n+\n+IntVecTransforms(\"evens\", int_vec().filter(is_even)).\n+// map.\n+IntVecTransforms(\"+100\", int_vec().map(|x|x+100)).\n+\n+// retain.\n+IntVecTransforms(\"(0,5]\", {\n+                     var res = int_vec();\n+                     res.retain(|x|: bool { x > 0 and x <= 5 });\n+                     res\n+                 }).\n+\n+IntVecTransforms(\">3\", {\n+                     var res = int_vec();\n+                     var threshold = 3;\n+                     res.retain(|x: s64| x > threshold);\n+                     res\n+                 }).\n+\n+// find.\n+IntVecTransforms(\"not in [-5, 0, 7]\", {\n+                     var res = int_vec();\n+                     var exclude = [-5, 0];\n+                     exclude.push(7);\n+                     res.retain(|x| is_none(exclude.find(|y| y==x )));\n+                     res\n+                 }).\n+\n+// all.\n+IntVecTransforms(\"not in [-5, 0, 100] uaing 'all'\", {", "originalCommit": "3a79ce773028afa89fee44d8cd482e4d621e8d30", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk2MjY0Mg==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499962642", "bodyText": "you will have to delete these if you merge the other pr", "author": "mbudiu-vmw", "createdAt": "2020-10-06T01:50:13Z", "path": "test/run-souffle-tests.py", "diffHunk": "@@ -98,7 +98,9 @@\n     \"sort\",             # 202\n     \"tak\",              # 197\n     \"tic-tac-toe\",      # 197\n-    \"weighted_distances\" # 197\n+    \"weighted_distances\", # 197\n+    \"multiple_inequalities\",", "originalCommit": "3a79ce773028afa89fee44d8cd482e4d621e8d30", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk3MzUwOQ==", "url": "https://github.com/vmware/differential-datalog/pull/772#discussion_r499973509", "bodyText": "Ok, will make sure to remember this when rebasing the other PR.", "author": "ryzhyk", "createdAt": "2020-10-06T02:36:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTk2MjY0Mg=="}], "type": "inlineReview"}, {"oid": "a77c5a406e69b29e130e7aeb2e46e91bd2532d3d", "url": "https://github.com/vmware/differential-datalog/commit/a77c5a406e69b29e130e7aeb2e46e91bd2532d3d", "message": "Rename `min_by`, `max_by` -> `arg_min`, `arg_max`.\n\nUse more standard names for these operations.", "committedDate": "2020-10-06T02:51:22Z", "type": "commit"}]}