{"pr_number": 511, "pr_title": "Pass group-by variables to aggregation functions.", "pr_createdAt": "2020-02-08T08:55:25Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/511", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIxMDczMA==", "url": "https://github.com/vmware/differential-datalog/pull/511#discussion_r377210730", "bodyText": "Frankly I find this quite confusing. The signature of the function is not the same in the declaration and in the call.\nIs backwards compatibility so important? If you want to make changes to the language you should do them while it still has few users. You can provide a good diagnostic to help people migrate their code.\nI think it's cleaner if the Group object just has a key field. Group should be templated on two types, the key type and the value type. If you really want backwards compatibility you can have the for operate directly on the group. In LINQ this is done by the group implementing the IEnumerable<Value> interface.", "author": "mbudiu-vmw", "createdAt": "2020-02-10T17:34:38Z", "path": "doc/tutorial/tutorial.md", "diffHunk": "@@ -987,6 +987,34 @@ BestPricePerVendor(item, vendor, best_price) :-\n     var best_price = Aggregate((item, vendor), group_min(price)).\n ```\n \n+The aggregation function can take group-by variables in addition to\n+the group.  The following custom aggregation function computes the cheapest\n+vendor for each item and returns a string containing item name, vendor,\n+and price:\n+\n+```\n+function best_vendor_string(item: string, g: Group<(string, bit<64>)>): string =", "originalCommit": "cf63c748cf7a079ae3d9ff1efc277e8e294cc900", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIxNDIzMA==", "url": "https://github.com/vmware/differential-datalog/pull/511#discussion_r377214230", "bodyText": "Let's run this by Ben, he has very good taste in software design.", "author": "mbudiu-vmw", "createdAt": "2020-02-10T17:41:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzIxMDczMA=="}], "type": "inlineReview"}, {"oid": "55ea96dba5aac34e4321f231e9d70b92132ddf3d", "url": "https://github.com/vmware/differential-datalog/commit/55ea96dba5aac34e4321f231e9d70b92132ddf3d", "message": "Pass group-by variables to aggregation functions.\n\nAggregation functions previously took the contents of the group as the\nonly argument. In some cases, e.g., in the SQL converter, it is helpful\nto pass the group key as well.  We add this capability without changing\nexisting syntax.  The only change is that the `Group` type is now\nparameterized with both key and value types.  A program can iterate over\ngroup values as before; in addition, the `group_key(Group<'K,'V>): 'K`\nfunction extracts the group key.\n\nExample:\n\n```\n// Custom aggregation function that group of (vendor, price) tuples and\n// uses item name as key, and returns a string containing item name, along\n// with the lowest price and matching vendor for this item.\nfunction best_vendor_string(g: Group<string, (string, bit<64>)>): string =\n{\n    var min_vendor = \"\";\n    var min_price: bit<64> = 'hffffffffffffffff;\n    for (vendor_price in g) {\n        if (vendor_price.1 < min_price) {\n            min_vendor = vendor_price.0;\n            min_price = vendor_price.1\n        }\n    };\n    \"Best deal for ${group_key(g)}: ${min_vendor}, $${min_price}\"\n}\n\noutput relation BestDeal(best: string)\nBestDeal(best) :-\n    Price(item, vendor, price),\n    var best = Aggregate((item), best_vendor_string((vendor, price))).\n```", "committedDate": "2020-02-11T23:35:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk2Njg1MQ==", "url": "https://github.com/vmware/differential-datalog/pull/511#discussion_r377966851", "bodyText": "this is actually very nice.", "author": "mbudiu-vmw", "createdAt": "2020-02-11T23:47:17Z", "path": "lib/std.dl", "diffHunk": "@@ -131,32 +131,37 @@ extern function hash128(x: 'X): bit<128>\n \n /* The `Group` type is used exclusively in aggregation operations.  It\n  * represents a non-empty list of objects sorted in ascending order.\n+ * `'K` is the type of group key, and `'V` is the type of value in the group.\n  */\n-extern type Group<'A>\n+extern type Group<'K,'V>", "originalCommit": "55ea96dba5aac34e4321f231e9d70b92132ddf3d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzk2NzI1Mw==", "url": "https://github.com/vmware/differential-datalog/pull/511#discussion_r377967253", "bodyText": "is this comment still accurate?", "author": "mbudiu-vmw", "createdAt": "2020-02-11T23:48:36Z", "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -1502,9 +1502,12 @@ mkAggregate d filters input_val rl@Rule{..} idx = do\n     -- - compute aggregate\n     -- - return variables still in scope after this term\n     let tmap = ruleAggregateTypeParams d rl idx\n-    let tparams = commaSep $ map (\\tvar -> mkType (tmap M.! tvar)) $ funcTypeVars $ getFunc d rhsAggFunc\n+    let agg_func = getFunc d rhsAggFunc\n+    -- Pass group-by variable to the aggregate function if it accepts them.", "originalCommit": "55ea96dba5aac34e4321f231e9d70b92132ddf3d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "761b2ac1ef3056010be908fcc3d5a6c65a9f5a7f", "url": "https://github.com/vmware/differential-datalog/commit/761b2ac1ef3056010be908fcc3d5a6c65a9f5a7f", "message": "Pass group-by variables to aggregation functions.\n\nAggregation functions previously took the contents of the group as the\nonly argument. In some cases, e.g., in the SQL converter, it is helpful\nto pass the group key as well.  We add this capability without changing\nexisting syntax.  The only change is that the `Group` type is now\nparameterized with both key and value types.  A program can iterate over\ngroup values as before; in addition, the `group_key(Group<'K,'V>): 'K`\nfunction extracts the group key.\n\nExample:\n\n```\n// Custom aggregation function that group of (vendor, price) tuples and\n// uses item name as key, and returns a string containing item name, along\n// with the lowest price and matching vendor for this item.\nfunction best_vendor_string(g: Group<string, (string, bit<64>)>): string =\n{\n    var min_vendor = \"\";\n    var min_price: bit<64> = 'hffffffffffffffff;\n    for (vendor_price in g) {\n        if (vendor_price.1 < min_price) {\n            min_vendor = vendor_price.0;\n            min_price = vendor_price.1\n        }\n    };\n    \"Best deal for ${group_key(g)}: ${min_vendor}, $${min_price}\"\n}\n\noutput relation BestDeal(best: string)\nBestDeal(best) :-\n    Price(item, vendor, price),\n    var best = Aggregate((item), best_vendor_string((vendor, price))).\n```", "committedDate": "2020-02-12T06:49:43Z", "type": "forcePushed"}, {"oid": "a66079840211a5a5120a02a11892fa838c428557", "url": "https://github.com/vmware/differential-datalog/commit/a66079840211a5a5120a02a11892fa838c428557", "message": "Pass group-by variables to aggregation functions.\n\nAggregation functions previously took the contents of the group as the\nonly argument. In some cases, e.g., in the SQL converter, it is helpful\nto pass the group key as well.  We add this capability without changing\nexisting syntax.  The only change is that the `Group` type is now\nparameterized with both key and value types.  A program can iterate over\ngroup values as before; in addition, the `group_key(Group<'K,'V>): 'K`\nfunction extracts the group key.\n\nExample:\n\n```\n// Custom aggregation function that group of (vendor, price) tuples and\n// uses item name as key, and returns a string containing item name, along\n// with the lowest price and matching vendor for this item.\nfunction best_vendor_string(g: Group<string, (string, bit<64>)>): string =\n{\n    var min_vendor = \"\";\n    var min_price: bit<64> = 'hffffffffffffffff;\n    for (vendor_price in g) {\n        if (vendor_price.1 < min_price) {\n            min_vendor = vendor_price.0;\n            min_price = vendor_price.1\n        }\n    };\n    \"Best deal for ${group_key(g)}: ${min_vendor}, $${min_price}\"\n}\n\noutput relation BestDeal(best: string)\nBestDeal(best) :-\n    Price(item, vendor, price),\n    var best = Aggregate((item), best_vendor_string((vendor, price))).\n```", "committedDate": "2020-02-12T07:27:41Z", "type": "forcePushed"}, {"oid": "9f286ca19db22687187963f3972a14e03580fa40", "url": "https://github.com/vmware/differential-datalog/commit/9f286ca19db22687187963f3972a14e03580fa40", "message": "Pass group-by variables to aggregation functions.\n\nAggregation functions previously took the contents of the group as the\nonly argument. In some cases, e.g., in the SQL converter, it is helpful\nto pass the group key as well.  We add this capability without changing\nexisting syntax.  The only change is that the `Group` type is now\nparameterized with both key and value types.  A program can iterate over\ngroup values as before; in addition, the `group_key(Group<'K,'V>): 'K`\nfunction extracts the group key.\n\nExample:\n\n```\n// Custom aggregation function that group of (vendor, price) tuples and\n// uses item name as key, and returns a string containing item name, along\n// with the lowest price and matching vendor for this item.\nfunction best_vendor_string(g: Group<string, (string, bit<64>)>): string =\n{\n    var min_vendor = \"\";\n    var min_price: bit<64> = 'hffffffffffffffff;\n    for (vendor_price in g) {\n        if (vendor_price.1 < min_price) {\n            min_vendor = vendor_price.0;\n            min_price = vendor_price.1\n        }\n    };\n    \"Best deal for ${group_key(g)}: ${min_vendor}, $${min_price}\"\n}\n\noutput relation BestDeal(best: string)\nBestDeal(best) :-\n    Price(item, vendor, price),\n    var best = Aggregate((item), best_vendor_string((vendor, price))).\n```", "committedDate": "2020-02-12T07:51:14Z", "type": "forcePushed"}, {"oid": "ab8f2f47047e09aae532bcbef02b442e06bff27e", "url": "https://github.com/vmware/differential-datalog/commit/ab8f2f47047e09aae532bcbef02b442e06bff27e", "message": "Pass group-by variables to aggregation functions.\n\nAggregation functions previously took the contents of the group as the\nonly argument. In some cases, e.g., in the SQL converter, it is helpful\nto pass the group key as well.  We add this capability without changing\nexisting syntax.  The only change is that the `Group` type is now\nparameterized with both key and value types.  A program can iterate over\ngroup values as before; in addition, the `group_key(Group<'K,'V>): 'K`\nfunction extracts the group key.\n\nExample:\n\n```\n// Custom aggregation function that group of (vendor, price) tuples and\n// uses item name as key, and returns a string containing item name, along\n// with the lowest price and matching vendor for this item.\nfunction best_vendor_string(g: Group<string, (string, bit<64>)>): string =\n{\n    var min_vendor = \"\";\n    var min_price: bit<64> = 'hffffffffffffffff;\n    for (vendor_price in g) {\n        if (vendor_price.1 < min_price) {\n            min_vendor = vendor_price.0;\n            min_price = vendor_price.1\n        }\n    };\n    \"Best deal for ${group_key(g)}: ${min_vendor}, $${min_price}\"\n}\n\noutput relation BestDeal(best: string)\nBestDeal(best) :-\n    Price(item, vendor, price),\n    var best = Aggregate((item), best_vendor_string((vendor, price))).\n```", "committedDate": "2020-02-12T08:20:24Z", "type": "commit"}, {"oid": "ab8f2f47047e09aae532bcbef02b442e06bff27e", "url": "https://github.com/vmware/differential-datalog/commit/ab8f2f47047e09aae532bcbef02b442e06bff27e", "message": "Pass group-by variables to aggregation functions.\n\nAggregation functions previously took the contents of the group as the\nonly argument. In some cases, e.g., in the SQL converter, it is helpful\nto pass the group key as well.  We add this capability without changing\nexisting syntax.  The only change is that the `Group` type is now\nparameterized with both key and value types.  A program can iterate over\ngroup values as before; in addition, the `group_key(Group<'K,'V>): 'K`\nfunction extracts the group key.\n\nExample:\n\n```\n// Custom aggregation function that group of (vendor, price) tuples and\n// uses item name as key, and returns a string containing item name, along\n// with the lowest price and matching vendor for this item.\nfunction best_vendor_string(g: Group<string, (string, bit<64>)>): string =\n{\n    var min_vendor = \"\";\n    var min_price: bit<64> = 'hffffffffffffffff;\n    for (vendor_price in g) {\n        if (vendor_price.1 < min_price) {\n            min_vendor = vendor_price.0;\n            min_price = vendor_price.1\n        }\n    };\n    \"Best deal for ${group_key(g)}: ${min_vendor}, $${min_price}\"\n}\n\noutput relation BestDeal(best: string)\nBestDeal(best) :-\n    Price(item, vendor, price),\n    var best = Aggregate((item), best_vendor_string((vendor, price))).\n```", "committedDate": "2020-02-12T08:20:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM5NzI4Nw==", "url": "https://github.com/vmware/differential-datalog/pull/511#discussion_r378397287", "bodyText": "We will probably generate only concrete types here instead of a type variable, but this should work for now.", "author": "mbudiu-vmw", "createdAt": "2020-02-12T17:20:41Z", "path": "sql/src/test/java/ddlog/QueriesTest.java", "diffHunk": "@@ -126,7 +126,7 @@ public void testTwoAggregations() {\n         String query = \"create view v1 as SELECT MIN(column1) + MAX(column1) FROM t1\";\n         String program = this.header(false) +\n                 \"typedef Ttmp0 = Ttmp0{col4:signed<64>}\\n\" +\n-                \"function agg1(g1: Group<(Tt1)>):Ttmp0 =\\n\" +\n+                \"function agg1(g1: Group<'K, (Tt1)>):Ttmp0 =\\n\" +", "originalCommit": "ab8f2f47047e09aae532bcbef02b442e06bff27e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}