{"pr_number": 850, "pr_title": "Decompose generated Rust project into crates. ", "pr_createdAt": "2020-12-09T02:00:23Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/850", "timeline": [{"oid": "df3aa44233b071cc6a161a33b6b4b11847671a72", "url": "https://github.com/vmware/differential-datalog/commit/df3aa44233b071cc6a161a33b6b4b11847671a72", "message": ".gitlab-ci.yml: Add Docker authentication.\n\nDocker is now throttling downloads from unpaid accounts.  I added a\nread-only service account called `ddlogci` to the `ddlog` dockerhub org\nand modified `.gitlab-ci.yml` to authenticate as `ddlogci` user.\n\nOnce we've added a paid subscription for this account, docker should\nstop throttling.", "committedDate": "2020-12-09T01:58:19Z", "type": "commit"}, {"oid": "cdada5a2c2cbe8eafaa1fe3a53aee7e237ea3b73", "url": "https://github.com/vmware/differential-datalog/commit/cdada5a2c2cbe8eafaa1fe3a53aee7e237ea3b73", "message": "Refactoring: store `.toml` code per module.\n\nRefactoring in preparation to decomposing generated code into crates.\n\n`Module.parseDatalogProgram` used to return a single piece of toml code\nobtained as concatenation of all per-module `.toml` files.  This code\nwas appended to `Cargo.toml` in the `types` crate. As we are moving\ntowards a different code structure with `types` crate decomposed into\nmany crates, we change this function to return `.toml` code per module,\nso that it can placed in the same crate as the module during code\ngeneration.", "committedDate": "2020-12-09T01:58:19Z", "type": "commit"}, {"oid": "437c590e8e15c30c2a870e6f272ac91f32d25bdb", "url": "https://github.com/vmware/differential-datalog/commit/437c590e8e15c30c2a870e6f272ac91f32d25bdb", "message": "Refactoring: move DDValConvert into `types` crate.\n\nRefactoring in preparation to decomposing generated code into crates.\n\nThis refactoring addresses the problem of orphan `DDValConvert`\ninstances that will arise once we decompose DDlog type declarations into\nmultiple crates.  Previously, `DDValConvert` was declared in the\n`differential_datalog` crate.  Trait implementations for\nbuiltin Rust types lived in the same crate, whereas impls for all\nDDlog types where declared in the `types` crate where these types\nwere declared.  This scheme falls apart when `types` gets decomposed\ninto many crates, as for many types, e.g., `tupleN<...>`, there is\nno good location to implement the trait to satisfy orphan rules while\nmaking the implementation available to all users.\n\nThe new solution that will be implemented in future commits is to\nbreak up `types` into multiple crates, each implementing a subset\nof DDlog modules, plus an additional crate whose sole purpose\nwill be to declare `DDValConvert` trait and implement it for all\ntypes that need such an implementation (i.e., all types that are\nstored in relations).\n\nMoving `DDValConvert` out of `differential_datalog` breaks a few things.\nFirst, `differential_datalog` tests rely on this trait.  Second,\n`distributed_datalog` crate also uses this trait, as well as the\n`test_value` module that implements the trait for several test types.\nThis commit refactors the Rust code to move `DDValConvert` out of\n`differential_datalog`, while fixing the above issues:\n\n* Move `DDValConvert` and the `decl_ddval_convert` macro to a separate\n  module in the `types` crate.  It can be later easily moved to\n  a separate crates when we're ready for this change.\n* Move `test_value` and `differential_datalog` tests into a separate crate\n  `differential_datalog_test` that depends on `types`.", "committedDate": "2020-12-09T01:58:19Z", "type": "commit"}, {"oid": "d1d5a9b5b7f4e2b41fb16fa26e9527fbe76e8e4d", "url": "https://github.com/vmware/differential-datalog/commit/d1d5a9b5b7f4e2b41fb16fa26e9527fbe76e8e4d", "message": "test-antrea.sh: Don't install the compiler in CI.\n\nWhen running in CI, use the `ddlog` compiler install by the build stage\nof the pipeline.", "committedDate": "2020-12-09T01:58:19Z", "type": "commit"}, {"oid": "dd5270e25bdf4ba4a0177e2311c33d1b4bbb65b4", "url": "https://github.com/vmware/differential-datalog/commit/dd5270e25bdf4ba4a0177e2311c33d1b4bbb65b4", "message": "Crate decomposition algorithm (untested).", "committedDate": "2020-12-09T01:58:19Z", "type": "commit"}, {"oid": "695f1b72f06533e8b882e627200be7d47fb3620d", "url": "https://github.com/vmware/differential-datalog/commit/695f1b72f06533e8b882e627200be7d47fb3620d", "message": "Refactoring: Break up DDlog runtime into libs.\n\nAnother step towards breaking generated Rust code into crates.\nSpecifically we deal with Rust declarations that must be available\nacross all generated code and thus form the DDlog runtime:\n\n- `Int` and `Uint` types that implement `bigint` and `bit<N>`, N>128 types.\n- `Closure` type used to implement closures.\n- `Val` trait.\n- `DDValConvert` trait.\n- String concatenation functions used to implement `++`.\n- Logging support.\n\nSince these declarations will have to be made available in all generated\ncrates, they must themselves live in a separate crate or crates that\nall generated code would depend on.  Instead of implementing an ad hoc\nmechanism to achieve this, we simply convert this code into DDlog\nlibraries and rely on the general-purpose mechanism for decomposing\ngenerated code into crates and managing crate dependencies that we will\nhave to implement anyway.  We introduce three new libraries that are\nautomatically imported into all other DDlog libraries, similar to\n`ddlog_std`:\n\n- `ddlog_rt` - `trait DDValConvert`, `trait Val`, `Closure`, `++`.\n- `ddlog_bigint` - `Int`, `Uint` types.\n- `ddlog_log` - `log()` function.\n\nThese libraries are unusual in that they only contain Rust code, and no\nDDlog declarations.", "committedDate": "2020-12-09T01:58:19Z", "type": "commit"}, {"oid": "a9ccb8c56d484029be9cfcd3d42d1ccbd39bc791", "url": "https://github.com/vmware/differential-datalog/commit/a9ccb8c56d484029be9cfcd3d42d1ccbd39bc791", "message": "Instructions for configuring docker mirrors.\n\nSince docker hub is now throttling pulls, I had to setup docker mirrors\non CI servers.  This commit documents mirror config.", "committedDate": "2020-12-09T01:58:19Z", "type": "commit"}, {"oid": "b219163d3880a5128813b72599ff241065825f2d", "url": "https://github.com/vmware/differential-datalog/commit/b219163d3880a5128813b72599ff241065825f2d", "message": "Refactor: Move flatbuf impls into separate files.", "committedDate": "2020-12-09T01:58:19Z", "type": "commit"}, {"oid": "342ea2391a8c483c2aa391afbc1b004627e7be62", "url": "https://github.com/vmware/differential-datalog/commit/342ea2391a8c483c2aa391afbc1b004627e7be62", "message": "Decompose generated Rust project into crates.\n\nLarge DDlog projects get compiled to Rust projects that can take a long\ntime to compile to binary code.  One way to remediate this is to make\nsure that small changes to DDlog code produce small changes to Rust code\nthat can be quickly re-compiled by only re-compiling the affected\nmodules.  Unfortunately, Rust's incremental compilation only really\nworks at the granularity of a whole crate (there is also some amount\nincremental intra-crate compilation going on, but it is quite\nunpredictable and fragile).  So we need to break up the generated\nproject into crates to achieve incremental compilation.\n\nThe crate decomposition algorithm preserves the structure of the DDlog\nproject, so that each declaration can be found at the same path in the\nRust code as in the DDlog code.  It starts with placing each module in\na separate crate and then merges crates with circular depencies (induced\nby `import` statements).  In addition, if two modules belong to the same\ncrate, then the subtree of the project containing these modules and\ntheir ancestors up to the lowest common ancestor must be in the same\ncrate.\n\nEach generated module contains the following Rust declarations:\n- Functions and types declared in the corresponding DDlog module\n- Arrangements and keys for relations declared in the corresponding\n  DDlog module.\n- Rules, facts, transformer applications declared in the corresponding\n  DDlog module.\n- The main program crate (that gets recompiled every time) only\n  assembles all of the above into a dataflow graph to be passed to the\n  `differential-datalog` crate.\n\nThe rest of this patch adjusts the generated code to correctly\ncross-reference various declarations across generated crates.\n\nOne side effect of the new Rust project structure is that Rust type\ndeclarations are scattered across crates, which are generated\nautomatically and whose boundaries can change.  To expose a stable Rust\ninterface to the DDlog program, the main crate reexports all function\nand type declarations precisely mirroring the structure of the DDlog\nprogram.", "committedDate": "2020-12-09T01:58:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM2ODIyOQ==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539368229", "bodyText": "I'd probably just stick to naming these functions in snake case, e.g. from_uint() even though it's not the exact name of the type", "author": "Kixiron", "createdAt": "2020-12-09T14:48:45Z", "path": "lib/ddlog_bigint.rs", "diffHunk": "@@ -69,7 +73,7 @@ impl Int {\n     pub fn from_i128(v: i128) -> Int {\n         Int { x: BigInt::from(v) }\n     }\n-    pub fn from_Uint(v: uint::Uint) -> Int {\n+    pub fn from_Uint(v: Uint) -> Int {", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5MTg3Ng==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539491876", "bodyText": "Turns out, we rely on from_<typename> functions in generated code. Sure, we could use something like to_snake_case, but I prefer to keep things simple.  I will add a comment before the impl block to clarify the choice of naming.", "author": "ryzhyk", "createdAt": "2020-12-09T17:14:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM2ODIyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM2OTEwOA==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539369108", "bodyText": "I'd implement From<Uint> in addition to this", "author": "Kixiron", "createdAt": "2020-12-09T14:49:39Z", "path": "lib/ddlog_bigint.rs", "diffHunk": "@@ -69,7 +73,7 @@ impl Int {\n     pub fn from_i128(v: i128) -> Int {\n         Int { x: BigInt::from(v) }\n     }\n-    pub fn from_Uint(v: uint::Uint) -> Int {\n+    pub fn from_Uint(v: Uint) -> Int {", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3MDQ2MQ==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539370461", "bodyText": "A lot of paths throughout the ddlog modules are fully qualified, would simply importing them work?", "author": "Kixiron", "createdAt": "2020-12-09T14:51:16Z", "path": "lib/allocate.rs", "diffHunk": "@@ -3,11 +3,11 @@ use std::collections::BTreeSet;\n use std::ops;\n \n pub fn allocate<B: Ord + Clone, N: num::Num + ops::Add + cmp::Ord + Copy>(\n-    allocated: &crate::ddlog_std::Set<N>,\n-    toallocate: &crate::ddlog_std::Vec<B>,\n+    allocated: &ddlog_std::Set<N>,", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ1MDE3OA==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539450178", "bodyText": "Thanks for reviewing, this is really valuable!\nAll Rust code, including libraries used to live in the same namespace.  Fortunately, this is no longer the case, so yes, at least as far as native library code goes, imports should work. I sometimes prefer qualified names, especially when the actual type or function name is too generic.  I noticed that you feel different about these things :)\nI'll fix this library as you suggest.  Overall, I feel that our native library code has been tortured to death by all the refactorings and looks terrible in many ways, including those identified in your review.", "author": "ryzhyk", "createdAt": "2020-12-09T16:23:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3MDQ2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ2NTA5NQ==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539465095", "bodyText": "I generally prefer importing things since it becomes nicer to work within, for overtly generic names (such as Vec) I'd just alias it to DDlogVec or something", "author": "Kixiron", "createdAt": "2020-12-09T16:40:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3MDQ2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ3MjU2OA==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539472568", "bodyText": "Heh, we can agree to disagree.  In case of our native libraries, though, any consistent style would be an improvement :)", "author": "ryzhyk", "createdAt": "2020-12-09T16:49:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3MDQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3MTM3MA==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539371370", "bodyText": "Maybe put the c api under a module & feature gate to mirror the other c_api feature gated items", "author": "Kixiron", "createdAt": "2020-12-09T14:52:15Z", "path": "lib/ddlog_bigint.rs", "diffHunk": "@@ -323,3 +327,263 @@ impl num::Zero for Int {\n         self.x == BigInt::zero()\n     }\n }\n+\n+#[derive(Eq, PartialOrd, PartialEq, Ord, Clone, Hash)]\n+pub struct Uint {\n+    x: BigUint,\n+}\n+\n+impl Default for Uint {\n+    fn default() -> Uint {\n+        Uint {\n+            x: BigUint::default(),\n+        }\n+    }\n+}\n+\n+impl Abomonation for Uint {}\n+\n+impl Uint {\n+    pub fn from_biguint(v: BigUint) -> Uint {\n+        Uint { x: v }\n+    }\n+    pub fn from_bigint(v: BigInt) -> Uint {\n+        Uint {\n+            x: v.to_biguint().unwrap(),\n+        }\n+    }\n+    pub fn from_Int(v: Int) -> Uint {\n+        v.to_Uint().unwrap()\n+    }\n+    pub fn from_u8(v: u8) -> Uint {\n+        Uint {\n+            x: BigUint::from(v),\n+        }\n+    }\n+    pub fn from_u16(v: u16) -> Uint {\n+        Uint {\n+            x: BigUint::from(v),\n+        }\n+    }\n+    pub fn from_u32(v: u32) -> Uint {\n+        Uint {\n+            x: BigUint::from(v),\n+        }\n+    }\n+    pub fn from_u64(v: u64) -> Uint {\n+        Uint {\n+            x: BigUint::from(v),\n+        }\n+    }\n+    pub fn from_u128(v: u128) -> Uint {\n+        Uint {\n+            x: BigUint::from(v),\n+        }\n+    }\n+    pub fn from_bytes_be(bytes: &[u8]) -> Uint {\n+        Uint {\n+            x: BigUint::from_bytes_be(bytes),\n+        }\n+    }\n+    pub fn to_bytes_be(&self) -> Vec<u8> {\n+        self.x.to_bytes_be()\n+    }\n+    pub fn to_u8(&self) -> Option<u8> {\n+        self.x.to_u8()\n+    }\n+    pub fn to_u16(&self) -> Option<u16> {\n+        self.x.to_u16()\n+    }\n+    pub fn to_u32(&self) -> Option<u32> {\n+        self.x.to_u32()\n+    }\n+    pub fn to_u64(&self) -> Option<u64> {\n+        self.x.to_u64()\n+    }\n+    pub fn to_u128(&self) -> Option<u128> {\n+        self.x.to_u128()\n+    }\n+    pub fn to_Int(&self) -> Option<Int> {\n+        self.x.to_bigint().map(Int::from_bigint)\n+    }\n+    pub fn to_float(&self) -> OrderedFloat<f32> {\n+        match self.x.to_f32() {\n+            None => OrderedFloat::<f32>(std::f32::NAN),\n+            Some(x) => OrderedFloat::<f32>(x),\n+        }\n+    }\n+    pub fn to_double(&self) -> OrderedFloat<f64> {\n+        match self.x.to_f64() {\n+            None => OrderedFloat::<f64>(std::f64::NAN),\n+            Some(x) => OrderedFloat::<f64>(x),\n+        }\n+    }\n+    pub fn parse_bytes(buf: &[u8], radix: u32) -> Uint {\n+        Uint {\n+            x: BigUint::parse_bytes(buf, radix).unwrap(),\n+        }\n+    }\n+}\n+\n+#[no_mangle]", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ0ODMxNA==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539448314", "bodyText": "Good idea!", "author": "ryzhyk", "createdAt": "2020-12-09T16:21:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3MTM3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3Mjg5Nw==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539372897", "bodyText": "Tangential, but it would be nice to figure out a way to allow ddlog functions to take &str/&[T] over &String/&Vec<T> along with coped arguments", "author": "Kixiron", "createdAt": "2020-12-09T14:53:59Z", "path": "lib/ddlog_log.rs", "diffHunk": "@@ -32,6 +31,7 @@ static LOG_CONFIG: Lazy<sync::RwLock<LogConfig>> =\n \n /// Logging API exposed to the DDlog program.\n /// (see detailed documentation in `log.dl`)\n+#[allow(clippy::ptr_arg, clippy::trivially_copy_pass_by_ref)]", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ1Mjc3Ng==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539452776", "bodyText": "This is probably doable at least for read-only function arguments, but will probably require changes to the code generator. Definitely not in this PR.", "author": "ryzhyk", "createdAt": "2020-12-09T16:26:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3Mjg5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ1OTE3NQ==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539459175", "bodyText": "Yes, that's definitely out of scope for this pr", "author": "Kixiron", "createdAt": "2020-12-09T16:34:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3Mjg5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3Mzk1Nw==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539373957", "bodyText": "Very minor style nit, but I'd probably put the trait bounds in a where clause", "author": "Kixiron", "createdAt": "2020-12-09T14:55:12Z", "path": "lib/ddlog_rt.flatbuf.rs", "diffHunk": "@@ -0,0 +1,47 @@\n+impl<'a, Args: 'static + Clone, Output: 'static + Clone> FromFlatBuffer<&'a str>", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3NTQ5MA==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539375490", "bodyText": "I don't think this function is needed, any &String should automatically coerce into a &str unless there's a missing Deref implementation on ddlog strings", "author": "Kixiron", "createdAt": "2020-12-09T14:56:54Z", "path": "lib/ddlog_rt.rs", "diffHunk": "@@ -1,41 +1,102 @@\n-#![allow(clippy::trivially_copy_pass_by_ref)]\n-\n-//! Runtime support for DDlog closures.\n-\n-use ::std::cmp::Ordering;\n-use ::std::fmt::Debug;\n-use ::std::fmt::Display;\n-use ::std::fmt::Formatter;\n-use ::std::hash::Hash;\n-use ::std::hash::Hasher;\n-use ::std::result::Result;\n-\n-use ::serde::de::Error;\n-use ::serde::Deserialize;\n-use ::serde::Deserializer;\n-use ::serde::Serialize;\n-use ::serde::Serializer;\n-\n-use crate::Val;\n-\n-#[cfg(feature = \"flatbuf\")]\n-use flatbuffers as fbrt;\n+use std::cmp::Ordering;\n+use std::fmt::Debug;\n+use std::fmt::Display;\n+use std::fmt::Formatter;\n+use std::hash::Hash;\n+use std::hash::Hasher;\n+use std::result::Result;\n+\n+use serde::de::Error;\n+use serde::Deserializer;\n+use serde::Serializer;\n+\n+/* This module is designed to be imported both as a standard DDlog library and as a normal Rust\n+ * module, e.g., from `differential_datalog_test`.  We therefore need to import thit trait\n+ * so that it is available in the latter case and rename it so that it doesn't cause duplicate\n+ * import error in the former case. */\n+use differential_datalog::record::IntoRecord as IntoRec;\n+use differential_datalog::record::Record;\n+use ordered_float::OrderedFloat;\n+\n+use abomonation::Abomonation;\n+\n+/// All DDlog types are expected to implement this trait.  In particular, it is used as a type\n+/// bound on all type variables.\n+pub trait Val:\n+    Default\n+    + Eq\n+    + Ord\n+    + Clone\n+    + Hash\n+    + PartialEq\n+    + PartialOrd\n+    + serde::Serialize\n+    + ::serde::de::DeserializeOwned\n+    + 'static\n+{\n+}\n \n-#[cfg(feature = \"flatbuf\")]\n-use crate::flatbuf;\n+impl<T> Val for T where\n+    T: Default\n+        + Eq\n+        + Ord\n+        + Clone\n+        + Hash\n+        + PartialEq\n+        + PartialOrd\n+        + serde::Serialize\n+        + ::serde::de::DeserializeOwned\n+        + 'static\n+{\n+}\n \n-#[cfg(feature = \"flatbuf\")]\n-use crate::flatbuf::ToFlatBuffer;\n+/// Use in generated Rust code to implement string concatenation (`++`)\n+pub fn string_append_str(mut s1: String, s2: &str) -> String {\n+    s1.push_str(s2);\n+    s1\n+}\n \n-#[cfg(feature = \"flatbuf\")]\n-use crate::flatbuf::fb;\n+/// Use in generated Rust code to implement string concatenation (`++`)\n+#[allow(clippy::ptr_arg)]\n+pub fn string_append(mut s1: String, s2: &String) -> String {", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM3NjQwNg==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539376406", "bodyText": "An explanation on how to use the macro and its syntax would be helpful", "author": "Kixiron", "createdAt": "2020-12-09T14:57:54Z", "path": "lib/ddlog_rt.rs", "diffHunk": "@@ -1,41 +1,102 @@\n-#![allow(clippy::trivially_copy_pass_by_ref)]\n-\n-//! Runtime support for DDlog closures.\n-\n-use ::std::cmp::Ordering;\n-use ::std::fmt::Debug;\n-use ::std::fmt::Display;\n-use ::std::fmt::Formatter;\n-use ::std::hash::Hash;\n-use ::std::hash::Hasher;\n-use ::std::result::Result;\n-\n-use ::serde::de::Error;\n-use ::serde::Deserialize;\n-use ::serde::Deserializer;\n-use ::serde::Serialize;\n-use ::serde::Serializer;\n-\n-use crate::Val;\n-\n-#[cfg(feature = \"flatbuf\")]\n-use flatbuffers as fbrt;\n+use std::cmp::Ordering;\n+use std::fmt::Debug;\n+use std::fmt::Display;\n+use std::fmt::Formatter;\n+use std::hash::Hash;\n+use std::hash::Hasher;\n+use std::result::Result;\n+\n+use serde::de::Error;\n+use serde::Deserializer;\n+use serde::Serializer;\n+\n+/* This module is designed to be imported both as a standard DDlog library and as a normal Rust\n+ * module, e.g., from `differential_datalog_test`.  We therefore need to import thit trait\n+ * so that it is available in the latter case and rename it so that it doesn't cause duplicate\n+ * import error in the former case. */\n+use differential_datalog::record::IntoRecord as IntoRec;\n+use differential_datalog::record::Record;\n+use ordered_float::OrderedFloat;\n+\n+use abomonation::Abomonation;\n+\n+/// All DDlog types are expected to implement this trait.  In particular, it is used as a type\n+/// bound on all type variables.\n+pub trait Val:\n+    Default\n+    + Eq\n+    + Ord\n+    + Clone\n+    + Hash\n+    + PartialEq\n+    + PartialOrd\n+    + serde::Serialize\n+    + ::serde::de::DeserializeOwned\n+    + 'static\n+{\n+}\n \n-#[cfg(feature = \"flatbuf\")]\n-use crate::flatbuf;\n+impl<T> Val for T where\n+    T: Default\n+        + Eq\n+        + Ord\n+        + Clone\n+        + Hash\n+        + PartialEq\n+        + PartialOrd\n+        + serde::Serialize\n+        + ::serde::de::DeserializeOwned\n+        + 'static\n+{\n+}\n \n-#[cfg(feature = \"flatbuf\")]\n-use crate::flatbuf::ToFlatBuffer;\n+/// Use in generated Rust code to implement string concatenation (`++`)\n+pub fn string_append_str(mut s1: String, s2: &str) -> String {\n+    s1.push_str(s2);\n+    s1\n+}\n \n-#[cfg(feature = \"flatbuf\")]\n-use crate::flatbuf::fb;\n+/// Use in generated Rust code to implement string concatenation (`++`)\n+#[allow(clippy::ptr_arg)]\n+pub fn string_append(mut s1: String, s2: &String) -> String {\n+    s1.push_str(s2.as_str());\n+    s1\n+}\n \n-use ::differential_datalog::record::FromRecord;\n-use ::differential_datalog::record::IntoRecord;\n-use ::differential_datalog::record::Mutator;\n-use ::differential_datalog::record::Record;\n+/// Used to implement fields with `deserialize_from_array` attributed.", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwMTg4Mg==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539401882", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                use super::Closure;\n          \n          \n            \n                use super::ClosureImpl;\n          \n          \n            \n                use serde::Deserialize;\n          \n          \n            \n                use serde::Serialize;\n          \n          \n            \n                use super::{Closure, ClosureImpl};\n          \n          \n            \n                use serde::{Deserialize, Serialize};", "author": "Kixiron", "createdAt": "2020-12-09T15:27:08Z", "path": "lib/ddlog_rt.rs", "diffHunk": "@@ -275,65 +343,12 @@ impl<Args: 'static + Clone, Output: 'static + Clone> Abomonation\n     }\n }\n \n-#[cfg(feature = \"flatbuf\")]\n-impl<'a, Args: 'static + Clone, Output: 'static + Clone> flatbuf::FromFlatBuffer<&'a str>\n-    for Box<dyn Closure<Args, Output>>\n-{\n-    fn from_flatbuf(s: &'a str) -> Result<Self, String> {\n-        Err(format!(\"'from_flatbuf' not implemented for closures.\"))\n-    }\n-}\n-\n-#[cfg(feature = \"flatbuf\")]\n-impl<'a, Args: 'static + Clone, Output: 'static + Clone> flatbuf::FromFlatBuffer<fb::__String<'a>>\n-    for Box<dyn Closure<Args, Output>>\n-{\n-    fn from_flatbuf(v: fb::__String<'a>) -> Result<Self, String> {\n-        Err(format!(\"'from_flatbuf' not implemented for closures.\"))\n-    }\n-}\n-\n-#[cfg(feature = \"flatbuf\")]\n-impl<'b, Args: 'static + Clone, Output: 'static + Clone> ToFlatBuffer<'b>\n-    for Box<dyn Closure<Args, Output>>\n-{\n-    type Target = fbrt::WIPOffset<&'b str>;\n-    fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {\n-        fbb.create_string(&format!(\"{}\", self))\n-    }\n-}\n-\n-#[cfg(feature = \"flatbuf\")]\n-impl<'b, Args: 'static + Clone, Output: 'static + Clone> flatbuf::ToFlatBufferTable<'b>\n-    for Box<dyn Closure<Args, Output>>\n-{\n-    type Target = fb::__String<'b>;\n-    fn to_flatbuf_table(\n-        &self,\n-        fbb: &mut fbrt::FlatBufferBuilder<'b>,\n-    ) -> fbrt::WIPOffset<Self::Target> {\n-        let v = self.to_flatbuf(fbb);\n-        fb::__String::create(fbb, &fb::__StringArgs { v: Some(v) })\n-    }\n-}\n-\n-#[cfg(feature = \"flatbuf\")]\n-impl<'b, Args: 'static + Clone, Output: 'static + Clone> flatbuf::ToFlatBufferVectorElement<'b>\n-    for Box<dyn Closure<Args, Output>>\n-{\n-    type Target = <Self as flatbuf::ToFlatBuffer<'b>>::Target;\n-\n-    fn to_flatbuf_vector_element(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {\n-        self.to_flatbuf(fbb)\n-    }\n-}\n-\n #[cfg(test)]\n mod tests {\n-    use crate::closure::Closure;\n-    use crate::closure::ClosureImpl;\n-    use ::serde::Deserialize;\n-    use ::serde::Serialize;\n+    use super::Closure;\n+    use super::ClosureImpl;\n+    use serde::Deserialize;\n+    use serde::Serialize;", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwMzc2OQ==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539403769", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            pub fn istring_join(strings: &ddlog_std::Vec<istring>, sep: &String) -> String {\n          \n          \n            \n            pub fn istring_join(strings: &[istring], sep: &str) -> String {\n          \n      \n    \n    \n  \n\nDeref coercion should allow &String -> &str and &ddlog_std::Vec<T> -> &[T], may need to implement Deref<Target = Vec<T>> and Deref<Target = [T]> for ddlog_std::Vec<T> though", "author": "Kixiron", "createdAt": "2020-12-09T15:29:21Z", "path": "lib/internment.rs", "diffHunk": "@@ -138,66 +126,7 @@ where\n     }\n }\n \n-#[cfg(feature = \"flatbuf\")]\n-impl<A, FB> FromFlatBuffer<FB> for Intern<A>\n-where\n-    A: Eq + Hash + Send + Sync + 'static,\n-    A: FromFlatBuffer<FB>,\n-{\n-    fn from_flatbuf(fb: FB) -> Result<Self, String> {\n-        Ok(Intern::new(A::from_flatbuf(fb)?))\n-    }\n-}\n-\n-#[cfg(feature = \"flatbuf\")]\n-impl<'b, A, T> ToFlatBuffer<'b> for Intern<A>\n-where\n-    T: 'b,\n-    A: Eq + Send + Sync + Hash + ToFlatBuffer<'b, Target = T>,\n-{\n-    type Target = T;\n-\n-    fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {\n-        self.as_ref().to_flatbuf(fbb)\n-    }\n-}\n-\n-/*#[cfg(feature = \"flatbuf\")]\n-impl<'a> FromFlatBuffer<fb::__String<'a>> for intern_istring {\n-    fn from_flatbuf(v: fb::__String<'a>) -> Response<Self> {\n-        Ok(intern_string_intern(&String::from_flatbuf(v)?))\n-    }\n-}*/\n-\n-#[cfg(feature = \"flatbuf\")]\n-impl<'b, A, T> ToFlatBufferTable<'b> for Intern<A>\n-where\n-    T: 'b,\n-    A: Eq + Send + Sync + Hash + ToFlatBufferTable<'b, Target = T>,\n-{\n-    type Target = T;\n-    fn to_flatbuf_table(\n-        &self,\n-        fbb: &mut fbrt::FlatBufferBuilder<'b>,\n-    ) -> fbrt::WIPOffset<Self::Target> {\n-        self.as_ref().to_flatbuf_table(fbb)\n-    }\n-}\n-\n-#[cfg(feature = \"flatbuf\")]\n-impl<'b, A, T> ToFlatBufferVectorElement<'b> for Intern<A>\n-where\n-    T: 'b + fbrt::Push + Copy,\n-    A: Eq + Send + Sync + Hash + ToFlatBufferVectorElement<'b, Target = T>,\n-{\n-    type Target = T;\n-\n-    fn to_flatbuf_vector_element(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {\n-        self.as_ref().to_flatbuf_vector_element(fbb)\n-    }\n-}\n-\n-pub fn istring_join(strings: &crate::ddlog_std::Vec<istring>, sep: &String) -> String {\n+pub fn istring_join(strings: &ddlog_std::Vec<istring>, sep: &String) -> String {", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwODg3MQ==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539408871", "bodyText": "Implementing Deref<Target = BigInt> would add to ergonomics a lot (Same with Uint)", "author": "Kixiron", "createdAt": "2020-12-09T15:35:21Z", "path": "lib/ddlog_bigint.rs", "diffHunk": "@@ -20,6 +16,14 @@ use std::ops::*;\n use std::os::raw::c_char;\n use std::str::FromStr;\n \n+/* This module is designed to be imported both as a standard DDlog library and as a normal Rust\n+ * module, e.g., from `differential_datalog_test`.  We therefore need to import these traits\n+ * so that they are available in the latter case and rename them so that they don't cause duplicate\n+ * import error in the former case. */\n+use differential_datalog::record::FromRecord as FromRec;\n+use differential_datalog::record::IntoRecord as IntoRec;\n+use differential_datalog::record::Record;\n+\n #[derive(Eq, PartialOrd, PartialEq, Ord, Clone, Hash)]\n pub struct Int {", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ2NzcxMw==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539467713", "bodyText": "As long as it doesn't mess up the generated code. There's a bit of a tension here between ergonomics and surprising side effects in automatically generated code where fewer magic conversions is better. The same is true for many other library types. I don't think we have a consistent approach here. I'll try implementing these Deref and see if anything breaks.", "author": "ryzhyk", "createdAt": "2020-12-09T16:43:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwODg3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQ5MDk5Nw==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539490997", "bodyText": "If it ends up that there's a multitude of unwanted behavior happening, we can delay that and I can make a pr that makes you ye generated code use more qualified function calls, but hopefully it doesn't come to that", "author": "Kixiron", "createdAt": "2020-12-09T17:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQwODg3MQ=="}], "type": "inlineReview"}, {"oid": "e25d62aa4a2022ecea3c6a10cea55c646f638806", "url": "https://github.com/vmware/differential-datalog/commit/e25d62aa4a2022ecea3c6a10cea55c646f638806", "message": "ddlog_bigint.rs: Remove `Uint::from_Int` method.\n\nRemoved unsafe and, hopefully, unused `Int` -> `Uint` conversion.", "committedDate": "2020-12-09T17:37:21Z", "type": "commit"}, {"oid": "935ea955810bab8d802896ae4500545d73cd14e6", "url": "https://github.com/vmware/differential-datalog/commit/935ea955810bab8d802896ae4500545d73cd14e6", "message": "ddlog_bigint.rs: `impl From<Uint> for Int`.", "committedDate": "2020-12-09T17:46:32Z", "type": "commit"}, {"oid": "13a8677aa3b6a52a6618ad4e661a837bc63560d3", "url": "https://github.com/vmware/differential-datalog/commit/13a8677aa3b6a52a6618ad4e661a837bc63560d3", "message": "ddlog_bigint.rs: Move C API into a module.", "committedDate": "2020-12-09T17:58:01Z", "type": "commit"}, {"oid": "1063b9413038ba1ee7f535b495a6c8a35f9946d3", "url": "https://github.com/vmware/differential-datalog/commit/1063b9413038ba1ee7f535b495a6c8a35f9946d3", "message": "ddlog_rt.flatbuf: Trait bounds inside `where`.", "committedDate": "2020-12-09T17:58:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1Mjg2NQ==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r538952865", "bodyText": "what's wrong with this function? If you don't want it, why not just delete it?", "author": "mbudiu-vmw", "createdAt": "2020-12-09T02:17:11Z", "path": "lib/ddlog_std.dl", "diffHunk": "@@ -291,7 +288,7 @@ function map_err(res: Result<'V, 'E1>, f: function('E1): 'E2): Result<'V, 'E2> {\n  * Range; all values starting at 'from' and ending at 'to'\n  * inclusively, in steps of 'step'.  'step' must be positive.\n  */\n-extern function range(from: 'A, to: 'A, step: 'A): Vec<'A>\n+//extern function range(from: 'A, to: 'A, step: 'A): Vec<'A>", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2NDM5NQ==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539564395", "bodyText": "DDlog no longer allows unimplemented extern functions (as it reexports them in the Rust API, which does not compile if the function isn't actually there).  Some time ago we decided to keep it there to make it explicit that it is now deprecated. I can remove it.", "author": "ryzhyk", "createdAt": "2020-12-09T18:56:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1Mjg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1MzA5Mg==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r538953092", "bodyText": "this one isn't useful?", "author": "mbudiu-vmw", "createdAt": "2020-12-09T02:17:48Z", "path": "lib/ddlog_std.dl", "diffHunk": "@@ -806,7 +803,6 @@ extern function vec_push_imm(v: Vec<'X>, x: 'X): Vec<'X>\n extern function vec_contains(v: Vec<'X>, x: 'X): bool\n extern function vec_is_empty(v: Vec<'X>): bool\n extern function vec_nth(v: Vec<'X>, n: usize): Option<'X>\n-extern function vec_set_nth(v: Vec<'X>, n: usize, value: 'X)", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2NjQ1NQ==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539566455", "bodyText": "I think it lacked the implementation and shouldn't have been there in the first place. There's  a vec_update_nth.", "author": "ryzhyk", "createdAt": "2020-12-09T18:59:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1MzA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1NDAwOQ==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r538954009", "bodyText": "delete?", "author": "mbudiu-vmw", "createdAt": "2020-12-09T02:20:16Z", "path": "lib/internment.flatbuf.rs", "diffHunk": "@@ -0,0 +1,54 @@\n+impl<A, FB> FromFlatBuffer<FB> for internment::Intern<A>\n+where\n+    A: Eq + std::hash::Hash + Send + Sync + 'static,\n+    A: FromFlatBuffer<FB>,\n+{\n+    fn from_flatbuf(fb: FB) -> Result<Self, String> {\n+        Ok(internment::Intern::new(A::from_flatbuf(fb)?))\n+    }\n+}\n+\n+impl<'b, A, T> ToFlatBuffer<'b> for internment::Intern<A>\n+where\n+    T: 'b,\n+    A: Eq + Send + Sync + std::hash::Hash + ToFlatBuffer<'b, Target = T>,\n+{\n+    type Target = T;\n+\n+    fn to_flatbuf(&self, fbb: &mut fbrt::FlatBufferBuilder<'b>) -> Self::Target {\n+        self.as_ref().to_flatbuf(fbb)\n+    }\n+}\n+\n+/*#[cfg(feature = \"flatbuf\")]", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk1ODgwNg==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r538958806", "bodyText": "delete?", "author": "mbudiu-vmw", "createdAt": "2020-12-09T02:33:11Z", "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -369,36 +398,42 @@ emptyCompilerState = CompilerState {\n rnameFlat :: String -> Doc\n rnameFlat = pp . replace \"::\" \"_\"\n \n--- Types and functions are stored in Rust modules that mirror the DDlog\n--- module hierarchy.\n--- 'local' is true iff the name is being used in the same crate where it was\n--- declared, i.e., the 'types' crate.\n-rnameScoped :: Bool -> String -> Doc\n-rnameScoped local n = rnameScoped' (if local then \"crate\" else \"::types\") n\n-\n-rnameScoped' :: String -> String -> Doc\n-rnameScoped' scope n = pp scope <> \"::\" <> pp n\n+-- Types, functions, rules, etc., are stored in Rust modules that mirror the DDlog\n+-- module hierarchy.  This function generates a qualified Rust identifier (e.g.,\n+-- 'crate_name::module_name::name') that refers to entity whose fully qualified\n+-- DDlog identifier is 'n'.\n+-- 'local_module' - module accessing the identifier or 'Nothing' if it's accessed\n+-- from an external crate.\n+-- 'n' - fully qualified DDlog identifier\n+rnameScoped :: (?crate_graph::CrateGraph, ?specname::String) => Maybe ModuleName -> String -> Doc\n+rnameScoped local_module n =\n+    ridentScoped local_module (nameScope n) (nameLocalStr n)\n+\n+-- Generate a qualified Rust identifier that refers to variable 'n' declared in\n+-- 'target_module' from 'local_module'.\n+ridentScoped :: (?crate_graph::CrateGraph, ?specname::String) => Maybe ModuleName -> ModuleName -> String -> Doc\n+ridentScoped Nothing target_module n =\n+    pp $ intercalate \"::\" $ absolutePath target_module ++ [n]\n+ridentScoped (Just local_module) target_module n =\n+    pp $ intercalate \"::\" $ relativePath local_module target_module ++ [n]\n \n mkRelEnum :: DatalogProgram -> Doc\n mkRelEnum d =\n-    \"#[derive(Copy,Clone,Debug,PartialEq,Eq,Hash)]\"                                                                                       $$\n-    \"pub enum Relations {\"                                                                                                                $$\n-    (nest' $ vcat $ punctuate comma $ map (\\rel -> rnameFlat (name rel) <+> \"=\" <+> pp (relIdentifier d rel)) $ M.elems $ progRelations d)    $$\n+    \"#[derive(Copy,Clone,Debug,PartialEq,Eq,Hash)]\"                                                                                        $$\n+    \"pub enum Relations {\"                                                                                                                 $$\n+    (nest' $ vcat $ punctuate comma $ map (\\rel -> rnameFlat (name rel) <+> \"=\" <+> pp (relIdentifier d rel)) $ M.elems $ progRelations d) $$\n     \"}\"\n \n mkIdxEnum :: DatalogProgram -> Doc\n mkIdxEnum d =\n     \"#[derive(Copy,Clone,Debug,PartialEq,Eq,Hash)]\"                                                                                       $$\n     \"pub enum Indexes {\"                                                                                                                  $$\n-    (nest' $ vcat $ punctuate comma $ map (\\idx -> rnameFlat (name idx) <+> \"=\" <+> pp (idxIdentifier d idx)) $ M.elems $ progIndexes d)      $$\n+    (nest' $ vcat $ punctuate comma $ map (\\idx -> rnameFlat (name idx) <+> \"=\" <+> pp (idxIdentifier d idx)) $ M.elems $ progIndexes d)  $$\n     \"}\"\n \n-relId :: String -> Doc\n-relId rel = \"Relations::\" <> rnameFlat rel <+> \"as RelId\"\n-\n--- t must be normalized\n-addType :: Type -> CompilerMonad ()\n-addType t = modify $ \\s -> s{cTypes = S.insert t $ cTypes s}\n+relId :: DatalogProgram -> String -> Doc\n+--relId rel = \"Relations::\" <> rnameFlat rel <+> \"as RelId\"", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MDA1OA==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r538960058", "bodyText": "2018?", "author": "mbudiu-vmw", "createdAt": "2020-12-09T02:36:42Z", "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -568,87 +601,316 @@ compile d_unoptimized specname modules rs_code toml_code dir crate_types = do\n                         ++ \"members = [\\n\"\n                         ++ \"    \\\"cmd_parser\\\",\\n\"\n                         ++ \"    \\\"differential_datalog\\\",\\n\"\n-                        ++ \"    \\\"distributed_datalog\\\",\\n\"\n                         ++ \"    \\\"ovsdb\\\",\\n\"\n-                        ++ \"    \\\"types\\\",\\n\"\n                         ++ \"]\\n\"\n                 )\n-    updateFile (dir </> rustProjectDir specname </> \"Cargo.toml\")       (render $ mainCargo specname crate_types toml_footer)\n-    updateFile (dir </> rustProjectDir specname </> \"src/lib.rs\")       (render main)\n+    updateFile (dir </> rustProjectDir </> \"Cargo.toml\")       (render $ mainCargo rs_code crate_types toml_footer)\n+    updateFile (dir </> rustProjectDir </> \"src/lib.rs\")       (render main)\n     return ()\n \n--- | Compile Datalog program into Rust code.\n---\n--- Returns Rust code for three crates:\n--- * 'types' crate containing DDlog type declarations, functions, and all imported\n---   Rust library code.\n--- * 'value' crate that declares relations and value types.\n--- * 'main' crate that contains rule definitions in Rust and imports the other two.\n---\n-compileLib :: (?cfg::Config) => DatalogProgram -> String -> [DatalogModule] -> M.Map ModuleName Doc -> (M.Map ModuleName Doc, Doc)\n-compileLib d specname modules rs_code = (typeLib, mainLib)\n+\n+compileLib :: (?cfg::Config, ?specname::String, ?crate_graph::CrateGraph, ?modules::[DatalogModule]) => DatalogProgram -> M.Map ModuleName (Doc, Doc, Doc) -> (M.Map FilePath Doc, Doc)\n+compileLib d rs_code =\n+    (crates, main_lib)\n     where\n-    modules' = addMissingModules modules\n     statics = collectStatics d\n-    -- Start with empty modules, except the main module that contains static declarations.\n-    typeLib0 = M.fromList $ map (\\m -> if moduleName m == mainModuleName\n-                                       then (moduleName m, typesLibHeader specname $+$ mkStatics d statics)\n-                                       else (moduleName m, typesModuleHeader specname)) modules'\n-    -- Add submodule lists.\n-    typeLibMods = M.mapWithKey (\\mname mtext ->\n-                                 let children = filter (\\other_mod -> other_mod `moduleIsChildOf` mname)\n-                                                $ map moduleName modules'\n-                                 in mtext $+$ vcat (map (\\(ModuleName c) -> \"pub mod\" <+> pp (last c) <> \";\") children))\n-                               typeLib0\n-    -- Add Rust code.\n-    typeLibRs = foldl' (\\libs (mname, rs) -> M.adjust ($+$ rs) mname libs) typeLibMods $ M.toList rs_code\n-    -- Add typedefs\n-    typeLibTdefs = foldl' (\\libs tdef -> M.adjust ($+$ mkTypedef d tdef) (nameScope tdef) libs) typeLibRs $ progTypedefs d\n-    -- Add functions\n-    typeLibExternFuncs = let ?statics = statics in\n-                         foldl' (\\libs func -> M.adjust ($+$ mkFunc d func) (nameScope func) libs) typeLibTdefs fextern\n-    typeLibAllFuncs = let ?statics = statics in\n-                       foldl' (\\libs func -> M.adjust ($+$ mkFunc d func) (nameScope func) libs) typeLibExternFuncs fdef\n-    -- Add 'DDValConvert' impls to 'types' crate.\n-    -- Since multiple DDlog types can map to the same Rust type, we convert\n-    -- types to Rust and fold over the resulting set.\n-    typeLib = S.foldl (\\libs _ -> M.adjust ($+$ \"\") mainModuleName libs) typeLibAllFuncs\n-                      $ S.map (render . mkType d True) $ S.filter (typeNeedsDDValConvert d) $ cTypes cstate\n-    mainLib = mainHeader specname           $+$\n-              mkUpdateDeserializer d        $+$\n-              mkDDValueFromRecord d         $+$ -- Function to convert cmd_parser::Record to Value\n-              mkIndexesIntoArrId d cstate   $+$\n-              mkRelEnum d                   $+$ -- 'enum Relations'\n-              mkIdxEnum d                   $+$ -- 'enum Indexes'\n-              prog\n+    -- First pass: Compile DDlog rules, generate arrangements.\n+    (nodes, cstate) = compileRules d statics\n+    -- Second pass: Populate Rust crates with compiled code in `nodes`.\n+    crates = M.unions $ map (compileCrate d statics nodes rs_code) $ cgCrates ?crate_graph\n+    -- Generate the main library file.\n+    main_lib = compileMainLib d nodes cstate\n+\n+compileRules :: (?cfg::Config, ?specname::String, ?modules::[DatalogModule], ?crate_graph::CrateGraph) => DatalogProgram -> Statics -> ([ProgNode], CompilerState)\n+compileRules d statics =\n+    runState (do -- First pass: compute arrangements\n+                 createArrangements d\n+                 -- Second pass: compile relations\n+                 mapIdxM (\\scc i -> compileSCC d statics depgraph i scc) sccs)\n+             $ emptyCompilerState { cArrangements = arrs }\n+    where\n     -- Compute ordered SCCs of the dependency graph.  These will define the\n     -- structure of the program.\n     depgraph = progDependencyGraph d\n     sccs = G.topsort' $ G.condensation depgraph\n     -- Initialize arrangements map\n     arrs = M.fromList $ map (, []) $ M.keys $ progRelations d\n-    -- Initialize types\n-    -- Make sure that empty tuple is always in Value, so it can be\n-    -- used to implement Value::default()\n-    types = S.fromList $ (tTuple []) : (map (typeNormalize d . relType) $ M.elems $ progRelations d)\n-    -- Compile SCCs\n-    (prog, cstate) = let ?statics = statics in\n-                     runState (do -- First pass: compute arrangements\n-                                  createArrangements d\n-                                  -- Second pass: compile relations\n-                                  nodes <- mapM (compileSCC d depgraph) sccs\n-                                  mkProg nodes)\n-                              $ emptyCompilerState { cArrangements = arrs\n-                                                   , cTypes        = types }\n-    -- Functions\n-    (fdef, fextern) = partition (isJust . funcDef) $ concat $ M.elems $ progFunctions d\n+\n+compileCrate :: (?cfg::Config, ?specname::String, ?crate_graph::CrateGraph, ?modules::[DatalogModule])\n+    => DatalogProgram -> Statics -> [ProgNode] -> M.Map ModuleName (Doc, Doc, Doc) -> Crate -> M.Map FilePath Doc\n+compileCrate d statics nodes rs_code crate =\n+    M.fromList $ toml:modules\n+    where\n+    -- Generate 'Cargo.toml'.\n+    toml = mkCargoToml rs_code crate\n+    -- Generate individual modules.\n+    modules = map (compileModule d statics nodes rs_code crate) $ S.toList crate\n+\n+mkCargoToml :: (?cfg::Config, ?specname::String, ?crate_graph::CrateGraph, ?modules::[DatalogModule])\n+    => M.Map ModuleName (Doc, Doc, Doc) -> Crate -> (FilePath, Doc)\n+mkCargoToml rs_code crate =\n+    (filepath, code)\n+    where\n+    filepath = \"types\" </> (crateDirPath crate) </> \"Cargo.toml\"\n+    code = \"[package]\"                                                                     $$\n+           \"name = \\\"\" <> pp crate_name <> \"\\\"\"                                            $$\n+           \"version = \\\"0.1.0\\\"\"                                                           $$\n+           \"edition = \\\"2018\\\"\"                                                            $$", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2ODMyMQ==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539568321", "bodyText": "Yes, we are on the 2018 Rust edition, which is currently the latest.", "author": "ryzhyk", "createdAt": "2020-12-09T19:02:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MDA1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MDQ5MA==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r538960490", "bodyText": "shouldn't this be actually concatenated from some file rather than be here inline?", "author": "mbudiu-vmw", "createdAt": "2020-12-09T02:37:51Z", "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -568,87 +601,316 @@ compile d_unoptimized specname modules rs_code toml_code dir crate_types = do\n                         ++ \"members = [\\n\"\n                         ++ \"    \\\"cmd_parser\\\",\\n\"\n                         ++ \"    \\\"differential_datalog\\\",\\n\"\n-                        ++ \"    \\\"distributed_datalog\\\",\\n\"\n                         ++ \"    \\\"ovsdb\\\",\\n\"\n-                        ++ \"    \\\"types\\\",\\n\"\n                         ++ \"]\\n\"\n                 )\n-    updateFile (dir </> rustProjectDir specname </> \"Cargo.toml\")       (render $ mainCargo specname crate_types toml_footer)\n-    updateFile (dir </> rustProjectDir specname </> \"src/lib.rs\")       (render main)\n+    updateFile (dir </> rustProjectDir </> \"Cargo.toml\")       (render $ mainCargo rs_code crate_types toml_footer)\n+    updateFile (dir </> rustProjectDir </> \"src/lib.rs\")       (render main)\n     return ()\n \n--- | Compile Datalog program into Rust code.\n---\n--- Returns Rust code for three crates:\n--- * 'types' crate containing DDlog type declarations, functions, and all imported\n---   Rust library code.\n--- * 'value' crate that declares relations and value types.\n--- * 'main' crate that contains rule definitions in Rust and imports the other two.\n---\n-compileLib :: (?cfg::Config) => DatalogProgram -> String -> [DatalogModule] -> M.Map ModuleName Doc -> (M.Map ModuleName Doc, Doc)\n-compileLib d specname modules rs_code = (typeLib, mainLib)\n+\n+compileLib :: (?cfg::Config, ?specname::String, ?crate_graph::CrateGraph, ?modules::[DatalogModule]) => DatalogProgram -> M.Map ModuleName (Doc, Doc, Doc) -> (M.Map FilePath Doc, Doc)\n+compileLib d rs_code =\n+    (crates, main_lib)\n     where\n-    modules' = addMissingModules modules\n     statics = collectStatics d\n-    -- Start with empty modules, except the main module that contains static declarations.\n-    typeLib0 = M.fromList $ map (\\m -> if moduleName m == mainModuleName\n-                                       then (moduleName m, typesLibHeader specname $+$ mkStatics d statics)\n-                                       else (moduleName m, typesModuleHeader specname)) modules'\n-    -- Add submodule lists.\n-    typeLibMods = M.mapWithKey (\\mname mtext ->\n-                                 let children = filter (\\other_mod -> other_mod `moduleIsChildOf` mname)\n-                                                $ map moduleName modules'\n-                                 in mtext $+$ vcat (map (\\(ModuleName c) -> \"pub mod\" <+> pp (last c) <> \";\") children))\n-                               typeLib0\n-    -- Add Rust code.\n-    typeLibRs = foldl' (\\libs (mname, rs) -> M.adjust ($+$ rs) mname libs) typeLibMods $ M.toList rs_code\n-    -- Add typedefs\n-    typeLibTdefs = foldl' (\\libs tdef -> M.adjust ($+$ mkTypedef d tdef) (nameScope tdef) libs) typeLibRs $ progTypedefs d\n-    -- Add functions\n-    typeLibExternFuncs = let ?statics = statics in\n-                         foldl' (\\libs func -> M.adjust ($+$ mkFunc d func) (nameScope func) libs) typeLibTdefs fextern\n-    typeLibAllFuncs = let ?statics = statics in\n-                       foldl' (\\libs func -> M.adjust ($+$ mkFunc d func) (nameScope func) libs) typeLibExternFuncs fdef\n-    -- Add 'DDValConvert' impls to 'types' crate.\n-    -- Since multiple DDlog types can map to the same Rust type, we convert\n-    -- types to Rust and fold over the resulting set.\n-    typeLib = S.foldl (\\libs _ -> M.adjust ($+$ \"\") mainModuleName libs) typeLibAllFuncs\n-                      $ S.map (render . mkType d True) $ S.filter (typeNeedsDDValConvert d) $ cTypes cstate\n-    mainLib = mainHeader specname           $+$\n-              mkUpdateDeserializer d        $+$\n-              mkDDValueFromRecord d         $+$ -- Function to convert cmd_parser::Record to Value\n-              mkIndexesIntoArrId d cstate   $+$\n-              mkRelEnum d                   $+$ -- 'enum Relations'\n-              mkIdxEnum d                   $+$ -- 'enum Indexes'\n-              prog\n+    -- First pass: Compile DDlog rules, generate arrangements.\n+    (nodes, cstate) = compileRules d statics\n+    -- Second pass: Populate Rust crates with compiled code in `nodes`.\n+    crates = M.unions $ map (compileCrate d statics nodes rs_code) $ cgCrates ?crate_graph\n+    -- Generate the main library file.\n+    main_lib = compileMainLib d nodes cstate\n+\n+compileRules :: (?cfg::Config, ?specname::String, ?modules::[DatalogModule], ?crate_graph::CrateGraph) => DatalogProgram -> Statics -> ([ProgNode], CompilerState)\n+compileRules d statics =\n+    runState (do -- First pass: compute arrangements\n+                 createArrangements d\n+                 -- Second pass: compile relations\n+                 mapIdxM (\\scc i -> compileSCC d statics depgraph i scc) sccs)\n+             $ emptyCompilerState { cArrangements = arrs }\n+    where\n     -- Compute ordered SCCs of the dependency graph.  These will define the\n     -- structure of the program.\n     depgraph = progDependencyGraph d\n     sccs = G.topsort' $ G.condensation depgraph\n     -- Initialize arrangements map\n     arrs = M.fromList $ map (, []) $ M.keys $ progRelations d\n-    -- Initialize types\n-    -- Make sure that empty tuple is always in Value, so it can be\n-    -- used to implement Value::default()\n-    types = S.fromList $ (tTuple []) : (map (typeNormalize d . relType) $ M.elems $ progRelations d)\n-    -- Compile SCCs\n-    (prog, cstate) = let ?statics = statics in\n-                     runState (do -- First pass: compute arrangements\n-                                  createArrangements d\n-                                  -- Second pass: compile relations\n-                                  nodes <- mapM (compileSCC d depgraph) sccs\n-                                  mkProg nodes)\n-                              $ emptyCompilerState { cArrangements = arrs\n-                                                   , cTypes        = types }\n-    -- Functions\n-    (fdef, fextern) = partition (isJust . funcDef) $ concat $ M.elems $ progFunctions d\n+\n+compileCrate :: (?cfg::Config, ?specname::String, ?crate_graph::CrateGraph, ?modules::[DatalogModule])\n+    => DatalogProgram -> Statics -> [ProgNode] -> M.Map ModuleName (Doc, Doc, Doc) -> Crate -> M.Map FilePath Doc\n+compileCrate d statics nodes rs_code crate =\n+    M.fromList $ toml:modules\n+    where\n+    -- Generate 'Cargo.toml'.\n+    toml = mkCargoToml rs_code crate\n+    -- Generate individual modules.\n+    modules = map (compileModule d statics nodes rs_code crate) $ S.toList crate\n+\n+mkCargoToml :: (?cfg::Config, ?specname::String, ?crate_graph::CrateGraph, ?modules::[DatalogModule])\n+    => M.Map ModuleName (Doc, Doc, Doc) -> Crate -> (FilePath, Doc)\n+mkCargoToml rs_code crate =\n+    (filepath, code)\n+    where\n+    filepath = \"types\" </> (crateDirPath crate) </> \"Cargo.toml\"\n+    code = \"[package]\"                                                                     $$\n+           \"name = \\\"\" <> pp crate_name <> \"\\\"\"                                            $$\n+           \"version = \\\"0.1.0\\\"\"                                                           $$\n+           \"edition = \\\"2018\\\"\"                                                            $$\n+           \"\"                                                                              $$\n+           \"[features]\"                                                                    $$", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2OTE2NQ==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539569165", "bodyText": "Problem is, this is a function of the output of the crate decomposition algorithm and must be generated.", "author": "ryzhyk", "createdAt": "2020-12-09T19:03:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MDQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODk2MTY0OA==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r538961648", "bodyText": "how about this? is it needed?", "author": "mbudiu-vmw", "createdAt": "2020-12-09T02:41:24Z", "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -658,6 +920,7 @@ mkUpdateDeserializer d =\n -- on the other hand is strict in this sense.  This function injects\n -- intermediate empty modules before generating Rust code to keep the Rust\n -- compiler happy.\n+{-", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU0MzcyOQ==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539543729", "bodyText": "typo?", "author": "mbudiu-vmw", "createdAt": "2020-12-09T18:26:10Z", "path": "src/Language/DifferentialDatalog/Crate.hs", "diffHunk": "@@ -0,0 +1,235 @@\n+{-\n+Copyright (c) 2020 VMware, Inc.\n+SPDX-License-Identifier: MIT\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE.\n+-}\n+\n+{- |\n+Module     : Crate\n+Description: Decompose generated Rust project into crates.\n+-}\n+\n+{-# LANGUAGE RecordWildCards, FlexibleContexts, TupleSections, LambdaCase, ImplicitParams, ScopedTypeVariables #-}\n+\n+module Language.DifferentialDatalog.Crate(\n+    Crate,\n+    CrateGraph(..),\n+    partitionIntoCrates,\n+    crateMainModule,\n+    crateName,\n+    cgModuleCrate,\n+    cgLookupCrate\n+) where\n+\n+import Data.List\n+import Data.Maybe\n+import qualified Data.Map as M\n+import qualified Data.Set as S\n+import qualified Data.Graph.Inductive as G\n+--import Debug.Trace\n+\n+import Language.DifferentialDatalog.Module\n+import Language.DifferentialDatalog.Syntax\n+import Language.DifferentialDatalog.Util\n+\n+-- A crate is a set of modules.\n+type Crate = S.Set ModuleName\n+\n+-- Returns the top-level module of a crate.  This is well-defined, as by\n+-- construction crate modules form a crate with a unique root.", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU0ODg4NQ==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539548885", "bodyText": "these could be utility functions in some library, but I don't know if it's worth moving them", "author": "mbudiu-vmw", "createdAt": "2020-12-09T18:33:35Z", "path": "src/Language/DifferentialDatalog/Crate.hs", "diffHunk": "@@ -0,0 +1,235 @@\n+{-\n+Copyright (c) 2020 VMware, Inc.\n+SPDX-License-Identifier: MIT\n+\n+Permission is hereby granted, free of charge, to any person obtaining a copy\n+of this software and associated documentation files (the \"Software\"), to deal\n+in the Software without restriction, including without limitation the rights\n+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+copies of the Software, and to permit persons to whom the Software is\n+furnished to do so, subject to the following conditions:\n+\n+The above copyright notice and this permission notice shall be included in all\n+copies or substantial portions of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+SOFTWARE.\n+-}\n+\n+{- |\n+Module     : Crate\n+Description: Decompose generated Rust project into crates.\n+-}\n+\n+{-# LANGUAGE RecordWildCards, FlexibleContexts, TupleSections, LambdaCase, ImplicitParams, ScopedTypeVariables #-}\n+\n+module Language.DifferentialDatalog.Crate(\n+    Crate,\n+    CrateGraph(..),\n+    partitionIntoCrates,\n+    crateMainModule,\n+    crateName,\n+    cgModuleCrate,\n+    cgLookupCrate\n+) where\n+\n+import Data.List\n+import Data.Maybe\n+import qualified Data.Map as M\n+import qualified Data.Set as S\n+import qualified Data.Graph.Inductive as G\n+--import Debug.Trace\n+\n+import Language.DifferentialDatalog.Module\n+import Language.DifferentialDatalog.Syntax\n+import Language.DifferentialDatalog.Util\n+\n+-- A crate is a set of modules.\n+type Crate = S.Set ModuleName\n+\n+-- Returns the top-level module of a crate.  This is well-defined, as by\n+-- construction crate modules form a crate with a unique root.\n+crateMainModule :: Crate -> ModuleName\n+crateMainModule crate =\n+    minimumBy (\\m1 m2 -> (length $ modulePath m1) `compare` (length $ modulePath m2)) crate\n+\n+-- Crate name as the path to its main module.\n+-- Prepend \"types__\" to crate names to avoid name clashes with other Rust\n+-- crates (from 'crates.io'), except standard library crates, whose names\n+-- we don't want to obfuscate.\n+-- FIXME: this naming schema does not exclude name clashes.\n+crateName :: Crate -> String\n+crateName crate | elem (crateMainModule crate) stdLibs =\n+    intercalate \"__\" $ (modulePath $ crateMainModule crate)\n+                | otherwise =\n+    intercalate \"__\" $ \"types\" : (modulePath $ crateMainModule crate)\n+\n+-- A crate graph is a graph with crates as vertices and with two\n+-- types of edges:\n+-- * Dependency edges represent module dependencies.  Two crates are connected\n+--   by a dependency edge iff there is a dependency between a pair of modules\n+--   inside these crates.\n+-- * Parent edges represent the DDlog module hierarchy.\n+data CrateGraph = CrateGraph {\n+    -- Crates.\n+    cgCrates    :: [Crate],\n+    -- Map from module names to index of the crate the module belongs to.\n+    cgMod2Crate :: M.Map ModuleName Int\n+} deriving (Eq, Show)\n+\n+cgEmpty :: CrateGraph\n+cgEmpty =\n+    CrateGraph {\n+        cgCrates       = [],\n+        cgMod2Crate    = M.empty\n+    }\n+\n+cgAddCrate :: CrateGraph -> Crate -> CrateGraph\n+cgAddCrate cg@CrateGraph{..} crate | elem crate cgCrates = cg\n+                                   | otherwise =\n+    CrateGraph {\n+        cgCrates = cgCrates ++ [crate],\n+        cgMod2Crate = foldl' (\\modCrates m -> M.insert m (length cgCrates) modCrates)\n+                             cgMod2Crate (S.toList crate)\n+    }\n+\n+cgLookupCrate :: CrateGraph -> String -> Maybe Crate\n+cgLookupCrate cg crate_name = find ((== crate_name) . crateName) $ cgCrates cg\n+\n+cgModuleCrate :: CrateGraph -> ModuleName -> Crate\n+cgModuleCrate CrateGraph{..} mod_name = cgCrates !! (cgMod2Crate M.! mod_name)\n+\n+-- Module dependencies.  Currently just the list of module imports, but\n+-- we may want to use a more accurate method based on actual dependencies\n+-- used by types and functions in the module.\n+moduleDeps :: (?mmap :: M.Map ModuleName DatalogModule) => ModuleName -> [ModuleName]\n+moduleDeps m = fromMaybe [] $ ((map importModule) . progImports . moduleDefs) <$> ?mmap M.!? m\n+\n+-- Expand crate so that modules in the crate form a single connected\n+-- subtree of the module graph:\n+-- Find the lowest common ancestor of all modules in the crate and add\n+-- modules along all branches from the ancestor to modules in the crate to\n+-- the crate.\n+--\n+-- Example:\n+-- Module hirarchy:\n+-- top\n+--  |\n+--  |-m1\n+--    |-m2\n+--    |-m3\n+--    |  |-m4\n+--    |  |-m5\n+--    |\n+--    |-m6\n+--       |-m7\n+--       |-m8\n+--\n+-- crate1 = {m8, m4}.\n+-- The lowest common ancestor of m8 and m4 is m1.  We therefore\n+-- extend the crate with m1 and all modules down the path from m1\n+-- to m8 and m4:\n+-- crate1' = {m1, m3, m4, m6, m8}.\n+addLowestCommonAncestor :: Crate -> Crate\n+addLowestCommonAncestor crate =\n+    S.foldl (\\mods m -> foldl' (\\mods' mname -> S.insert (ModuleName mname) mods') (S.insert m mods)\n+                               $ drop lca_len $ inits $ modulePath m)\n+            S.empty crate\n+    where\n+    -- Lowest common ancestor path length.\n+    lca_len = length $ lcp $ map modulePath $ S.toList crate\n+    -- Longest common prefix.", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1MjIzOQ==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539552239", "bodyText": "aren't literals in this category too? or constant expressions?", "author": "mbudiu-vmw", "createdAt": "2020-12-09T18:38:25Z", "path": "src/Language/DifferentialDatalog/Expr.hs", "diffHunk": "@@ -527,6 +528,14 @@ exprIsPure d ctx e | isNothing funcs = False\n                    | otherwise = all (\\f -> not $ funcGetSideEffectAttr d f) $ fromJust funcs\n     where funcs = exprFuncsRec d ctx e\n \n+-- | Expression can be evaluated statically.", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU3NTI3Mg==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539575272", "bodyText": "For now we only convert function calls to statics.  Most literals and constant expressions are statically evaluated anyway by the Rust compiler.", "author": "ryzhyk", "createdAt": "2020-12-09T19:13:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1MjIzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1NDkxNw==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539554917", "bodyText": "Could this be read from ddlog_std.dl?", "author": "mbudiu-vmw", "createdAt": "2020-12-09T18:42:19Z", "path": "src/Language/DifferentialDatalog/Module.hs", "diffHunk": "@@ -109,9 +115,14 @@ emptyModule mname = DatalogModule {\n     moduleDefs = emptyDatalogProgram\n }\n \n--- Standard library module name.\n+-- Standard library module names.\n stdLibs :: [ModuleName]\n-stdLibs = [ModuleName [mOD_STD], ModuleName [\"internment\"]]\n+stdLibs = [ ModuleName [mOD_RT]", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1NTQ1NQ==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539555455", "bodyText": "common subexpression (dropExresion $ moduleFile mod)", "author": "mbudiu-vmw", "createdAt": "2020-12-09T18:43:13Z", "path": "src/Language/DifferentialDatalog/Module.hs", "diffHunk": "@@ -121,57 +132,59 @@ stdImports :: [Import]\n stdImports = map stdImport stdLibs\n \n -- | Parse a datalog program along with all its imports; returns a \"flat\"\n--- program without imports and the list of Rust files associated with each\n--- module in the program.\n+-- program without imports.  In addition, returns `.rs` and `.toml` code\n+-- for each module.\n --\n -- 'roots' is the list of directories to search for imports\n --\n -- if 'import_std' is true, imports the standard libraries\n -- to each module.\n-parseDatalogProgram :: [FilePath] -> Bool -> String -> FilePath -> IO ([DatalogModule], DatalogProgram, M.Map ModuleName Doc, Doc)\n+parseDatalogProgram :: [FilePath] -> Bool -> String -> FilePath -> IO ([DatalogModule], DatalogProgram, M.Map ModuleName (Doc, Doc, Doc))\n parseDatalogProgram roots import_std fdata fname = do\n     roots' <- nub <$> mapM canonicalizePath roots\n     prog <- parseDatalogString fdata fname\n     let prog' = if import_std\n                    then prog { progImports = stdImports ++ progImports prog }\n                    else prog\n     let main_mod = DatalogModule (ModuleName []) fname prog'\n+    let ?specname = takeBaseName fname\n     imports <- evalStateT (parseImports roots' main_mod) []\n     let all_modules = main_mod : imports\n     prog'' <- flattenNamespace all_modules\n-    -- Collect Rust files associated with each module.\n-    rs <- (M.fromList . catMaybes) <$>\n-          mapM ((\\mod -> do\n-                    let rsfile = addExtension (dropExtension $ moduleFile mod) \"rs\"\n-                    rs_exists <- doesFileExist rsfile\n-                    if rs_exists\n-                       then do rs_code <- readFile rsfile\n-                               return $ Just (moduleName mod, pp rs_code)\n-                       else return Nothing))\n-               all_modules\n-    -- collect .toml files associated with modules\n-    toml <- (vcat . catMaybes) <$>\n-          mapM ((\\mod -> do let tomlfile = addExtension (dropExtension $ moduleFile mod) \"toml\"\n-                            exists <- doesFileExist tomlfile\n-                            if exists\n-                               then do toml_code <- readFile tomlfile\n-                                       return $ Just $ pp toml_code\n-                               else return Nothing))\n+    -- Collect '.rs' and '.toml' files associated with each module.\n+    rs <- M.fromList <$>\n+          mapM (\\mod -> do\n+                   let rsfile = addExtension (dropExtension $ moduleFile mod) \"rs\"", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1NTgxNA==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539555814", "bodyText": "this also looks like a little function", "author": "mbudiu-vmw", "createdAt": "2020-12-09T18:43:44Z", "path": "src/Language/DifferentialDatalog/Module.hs", "diffHunk": "@@ -121,57 +132,59 @@ stdImports :: [Import]\n stdImports = map stdImport stdLibs\n \n -- | Parse a datalog program along with all its imports; returns a \"flat\"\n--- program without imports and the list of Rust files associated with each\n--- module in the program.\n+-- program without imports.  In addition, returns `.rs` and `.toml` code\n+-- for each module.\n --\n -- 'roots' is the list of directories to search for imports\n --\n -- if 'import_std' is true, imports the standard libraries\n -- to each module.\n-parseDatalogProgram :: [FilePath] -> Bool -> String -> FilePath -> IO ([DatalogModule], DatalogProgram, M.Map ModuleName Doc, Doc)\n+parseDatalogProgram :: [FilePath] -> Bool -> String -> FilePath -> IO ([DatalogModule], DatalogProgram, M.Map ModuleName (Doc, Doc, Doc))\n parseDatalogProgram roots import_std fdata fname = do\n     roots' <- nub <$> mapM canonicalizePath roots\n     prog <- parseDatalogString fdata fname\n     let prog' = if import_std\n                    then prog { progImports = stdImports ++ progImports prog }\n                    else prog\n     let main_mod = DatalogModule (ModuleName []) fname prog'\n+    let ?specname = takeBaseName fname\n     imports <- evalStateT (parseImports roots' main_mod) []\n     let all_modules = main_mod : imports\n     prog'' <- flattenNamespace all_modules\n-    -- Collect Rust files associated with each module.\n-    rs <- (M.fromList . catMaybes) <$>\n-          mapM ((\\mod -> do\n-                    let rsfile = addExtension (dropExtension $ moduleFile mod) \"rs\"\n-                    rs_exists <- doesFileExist rsfile\n-                    if rs_exists\n-                       then do rs_code <- readFile rsfile\n-                               return $ Just (moduleName mod, pp rs_code)\n-                       else return Nothing))\n-               all_modules\n-    -- collect .toml files associated with modules\n-    toml <- (vcat . catMaybes) <$>\n-          mapM ((\\mod -> do let tomlfile = addExtension (dropExtension $ moduleFile mod) \"toml\"\n-                            exists <- doesFileExist tomlfile\n-                            if exists\n-                               then do toml_code <- readFile tomlfile\n-                                       return $ Just $ pp toml_code\n-                               else return Nothing))\n+    -- Collect '.rs' and '.toml' files associated with each module.\n+    rs <- M.fromList <$>\n+          mapM (\\mod -> do\n+                   let rsfile = addExtension (dropExtension $ moduleFile mod) \"rs\"\n+                   let fbfile = addExtension (dropExtension $ moduleFile mod) \".flatbuf.rs\"\n+                   let tomlfile = addExtension (dropExtension $ moduleFile mod) \"toml\"\n+                   rs_exists <- doesFileExist rsfile\n+                   flatbuf_exists <- doesFileExist fbfile\n+                   toml_exists <- doesFileExist tomlfile\n+                   rs_code <- if rs_exists", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1OTA1Mw==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539559053", "bodyText": "does this save much?", "author": "mbudiu-vmw", "createdAt": "2020-12-09T18:48:20Z", "path": "test/antrea/test-antrea.sh", "diffHunk": "@@ -4,7 +4,15 @@\n \n set -e\n \n-stack install\n+# When running in CI, the DDlog compiler should be preinstalled by the build stage.", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU5NzU4Nw==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539597587", "bodyText": "Big time!", "author": "ryzhyk", "createdAt": "2020-12-09T19:47:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU1OTA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTU2MDYzNQ==", "url": "https://github.com/vmware/differential-datalog/pull/850#discussion_r539560635", "bodyText": "this is a subtle user-facing change. I wonder where this has to be documented.", "author": "mbudiu-vmw", "createdAt": "2020-12-09T18:50:40Z", "path": "test/datalog_tests/json_test.dl", "diffHunk": "@@ -163,7 +163,7 @@ JsonTest(struct_with_map1(),\n \n typedef U64FromString = U64FromString {\n     x: string,\n-    #[rust=\"serde(with=\\\"crate::json::serde_string\\\")\"]\n+    #[rust=\"serde(with=\\\"types__json::serde_string\\\")\"]", "originalCommit": "342ea2391a8c483c2aa391afbc1b004627e7be62", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ba82757a2c728813f9750095e615df7be82d7d4f", "url": "https://github.com/vmware/differential-datalog/commit/ba82757a2c728813f9750095e615df7be82d7d4f", "message": "ddlog_rt.rs: Document deserialize_map_from_array.", "committedDate": "2020-12-09T18:54:25Z", "type": "commit"}, {"oid": "7d15723c4d0f419b208d2995fbe10fbd6a77c4df", "url": "https://github.com/vmware/differential-datalog/commit/7d15723c4d0f419b208d2995fbe10fbd6a77c4df", "message": "Review comments.\n\nSeveral small fixes based on review comments.", "committedDate": "2020-12-09T19:53:43Z", "type": "commit"}]}