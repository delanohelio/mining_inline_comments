{"pr_number": 636, "pr_title": "Static evaluation of constant expressions.", "pr_createdAt": "2020-04-19T04:31:38Z", "pr_url": "https://github.com/vmware/differential-datalog/pull/636", "timeline": [{"oid": "98f9cd6952193de2376758255d69432cc4236748", "url": "https://github.com/vmware/differential-datalog/commit/98f9cd6952193de2376758255d69432cc4236748", "message": "Static evaluation of constant expressions.\n\nImplements RFC #633\n\nThis feature was proposed by @mbudiu-vmw\n\nRationale\n--------\n\nWe would like to evaluate constant expressions, including complex ones\ncontaining function calls, once, either at the start of the program or\neven during compilation.  This commit addresses the former.  We may add\ncompile-time evaluation as a further optimization later, but it will be\napplicable in restricted contexts, as, e.g., calls to extern functions\nare difficult to evaluate in the compiler.\n\nThis feature is a prerequisite for several other useful features,\nincluding efficient interning of string literals and support for\nconstants.\n\nDesign\n---------\n\n- The first question is: what expressions should be evaluated\n  statically? For instance, given an expression `f1(C1) + f2(C2)`, the\n  options are: 1. `f1(C1)` and `f2(C2)` are evaluated statically; the sum\n  is evaluated dynamically 2. `f1(C1) + f2(C2)` is evaluated statically 3.\n  `f1(C1)`, `f2(C2)`, `f1(C1)+f2(C2)` are all evaluated statically, with\n  the sum expression being built out of statically computed results for\n  `f1` and `f2`.\n\n  Given that accessing a static expression is not free (see below), we\n  go with option 1, i.e., statically pre-evaluate function\n  calls on constant arguments.\n\n  How about `f1(f2(C))`?  In this example, `f2(C)` and `f1(f2(C))` are both\n  statics, with the latter referencing the former. There is a potential caveat:\n  rust's lazy static evaluation can deadlock when evaluating mutually dependent\n  statics, but as far as I can tell this can only occur in situations that would\n  cause infinite recursion otherwise.\n\n- Detecting constant sub-expressions is relatively straightforward.  The only\n  caveat is that some extern functions, most notably logging functions, can have\n  side effects and should not be evaluated statically. We handle this by introducing\n  a new annotation: `#[has_side_effects]`.  Functions with this annotation as well\n  as any functions that call them are not evaluated statically.\n\n- Constant subexpressions are compiled to Rust lazy statics, which is the only Rust\n  construct (a library, actually) that allows statically evaluating complex expressions\n  with function calls. This introduces a bit of overhead on each access (checking an\n  atomic variable).", "committedDate": "2020-04-19T02:35:25Z", "type": "commit"}, {"oid": "9b784413cf9d647f5fecfd11074c336f51726a6e", "url": "https://github.com/vmware/differential-datalog/commit/9b784413cf9d647f5fecfd11074c336f51726a6e", "message": "Make `internment.dl` part of the standard library.\n\nThis is in preparation for adding compiler support for interned\ntypes to make it more convenient to work with them.  This requires that\nthe content of `internment.dl` is imported by all modules.  This could\nbe achieved by simply moving it to `std.dl`, but rather than bloat\nthat module, we extend the module system to support multiple \"standard\nlibrary modules\" auto-imported by all DDlog programs.", "committedDate": "2020-04-19T06:13:25Z", "type": "commit"}, {"oid": "c9a7397c008d6468c6e333680990174ab7471e05", "url": "https://github.com/vmware/differential-datalog/commit/c9a7397c008d6468c6e333680990174ab7471e05", "message": "return_by_ref attribute.\n\nThe new attribute labels functions that return values by reference.\nDDlog functions are compiled into Rust functions that take arguments by\nreference and return results by value.  DDlog assumes the same calling\nconvention for extern functions.  However it can be more efficient to\nreturn values by reference.  We only had hardwired support for one such\nfunction (`deref`) so far.  As I was about to add another such function\n(`ival`), I generalized this mechanism to allow library developers to\nannotate extern functions to tell the compiler that they return a\nreference rather than value:\n\n```\nextern function deref(x: Ref<'A>): 'A\n```\n\nThis commit also renames `internment.IString` -> `internment.istring` to\navoid conflicts with the `intern` library and by analogy with he\nbuilt-in `string` type (since `IString` is also noe treated as a\nbuilt-in).", "committedDate": "2020-04-19T07:07:49Z", "type": "commit"}, {"oid": "21b9027bd06b7786150841e5ed211d319a607f11", "url": "https://github.com/vmware/differential-datalog/commit/21b9027bd06b7786150841e5ed211d319a607f11", "message": "Interned string literals.\n\nAnother step towards simplifying interned string manipulation.\nPrepending `i` to a string literal of any kind generates an interned\nstring, e.t.,\n\n- `i\"ifoo\"`  <-> `intern(\"ifoo\")`\n- `i[|ibar|]` <-> `intern([|ibar|])`\n- `i\"ifoo${25}\"` <-> `intern(\"ifoo${25}\")`\n- `i\"ifoo${25}\" \"!\"` <-> `intern(\"ifoo${25}\" \"!\")`\n- `i$[|ibar${2+2}|]` <-> `intern($[|ibar${2+2}|])`", "committedDate": "2020-04-19T17:51:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk4MDk4MQ==", "url": "https://github.com/vmware/differential-datalog/pull/636#discussion_r410980981", "bodyText": "These are not really tutorial items, they are highly technical.\nThe tutorial should only describe the core language, and should be ideally short and easy to read.", "author": "mbudiu-vmw", "createdAt": "2020-04-19T20:08:04Z", "path": "doc/tutorial/tutorial.md", "diffHunk": "@@ -1706,6 +1706,33 @@ to optimize data structures layout:\n extern type IObj<'A>\n ```\n \n+### `#[has_side_effects]`", "originalCommit": "21b9027bd06b7786150841e5ed211d319a607f11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwNTI0OQ==", "url": "https://github.com/vmware/differential-datalog/pull/636#discussion_r411105249", "bodyText": "I think there's nothing wrong about having advanced topics covered in the tutorial. Maybe we should break it up into several chapters for easier navigation and to have all the basic stuff in one smaller document.", "author": "ryzhyk", "createdAt": "2020-04-20T05:37:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk4MDk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk4MTY2Mw==", "url": "https://github.com/vmware/differential-datalog/pull/636#discussion_r410981663", "bodyText": "One solution would be to have an earlier pass which annotates all polymorphic functions with their type.", "author": "mbudiu-vmw", "createdAt": "2020-04-19T20:12:13Z", "path": "src/Language/DifferentialDatalog/Compile.hs", "diffHunk": "@@ -547,7 +544,51 @@ compileLib d specname rs_code = (typesLib, valueLib, mainLib)\n     typedefs = vcat $ map (mkTypedef d) $ M.elems $ progTypedefs d\n     -- Functions\n     (fdef, fextern) = partition (isJust . funcDef) $ M.elems $ progFunctions d\n-    funcs = vcat $ (map (mkFunc d) fextern ++ map (mkFunc d) fdef)\n+    funcs = let ?statics = statics in vcat $ (map (mkFunc d) fextern ++ map (mkFunc d) fdef)\n+\n+-- This type stores the set of statically evaluated constant sub-expressions.\n+-- We need to track the type of each expression, as generic functions like\n+-- 'set_empty()' can have different types in different contexts.", "originalCommit": "21b9027bd06b7786150841e5ed211d319a607f11", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk4MjU2Nw==", "url": "https://github.com/vmware/differential-datalog/pull/636#discussion_r410982567", "bodyText": "this should probably be documented too, because users need to know this.", "author": "mbudiu-vmw", "createdAt": "2020-04-19T20:17:41Z", "path": "src/Language/DifferentialDatalog/Module.hs", "diffHunk": "@@ -64,28 +64,31 @@ data DatalogModule = DatalogModule {\n     moduleDefs :: DatalogProgram\n }\n \n--- standard library module name\n-stdname :: ModuleName\n-stdname = ModuleName [\"std\"]\n+-- Standard library module name.\n+stdLibs :: [ModuleName]\n+stdLibs = [ModuleName [\"std\"], ModuleName [\"internment\"]]", "originalCommit": "21b9027bd06b7786150841e5ed211d319a607f11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwNTM0Mw==", "url": "https://github.com/vmware/differential-datalog/pull/636#discussion_r411105343", "bodyText": "Documentation is on its way...", "author": "ryzhyk", "createdAt": "2020-04-20T05:37:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk4MjU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk4MjkwMQ==", "url": "https://github.com/vmware/differential-datalog/pull/636#discussion_r410982901", "bodyText": "Why didn't we need to do this previously?", "author": "mbudiu-vmw", "createdAt": "2020-04-19T20:19:15Z", "path": "src/Language/DifferentialDatalog/Syntax.hs", "diffHunk": "@@ -656,6 +656,72 @@ instance Eq e => Eq (ExprNode e) where\n     (==) (ERef _ p1)              (ERef _ p2)                = p1 == p2\n     (==) _                        _                          = False\n \n+-- Assign rank to constructors; used in the implementation of Ord.", "originalCommit": "21b9027bd06b7786150841e5ed211d319a607f11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEwNTU0MA==", "url": "https://github.com/vmware/differential-datalog/pull/636#discussion_r411105540", "bodyText": "We never used expressions as keys in a map and so never had to implement Ord for them.", "author": "ryzhyk", "createdAt": "2020-04-20T05:38:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk4MjkwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk4MzE1OA==", "url": "https://github.com/vmware/differential-datalog/pull/636#discussion_r410983158", "bodyText": "I don't recall seeing the i\"\" syntax in the documentation.", "author": "mbudiu-vmw", "createdAt": "2020-04-19T20:20:30Z", "path": "test/datalog_tests/internment_test.dl", "diffHunk": "@@ -1,12 +1,22 @@\n-import internment\n+input relation IInternedString(ix: istring)\n+relation StaticInternedString(ix: istring)\n \n-input relation IInternedString(ix: IString)\n+StaticInternedString(intern(\"static foo\")).\n+StaticInternedString(i\"ifoo\").", "originalCommit": "21b9027bd06b7786150841e5ed211d319a607f11", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDk4MzU2Mw==", "url": "https://github.com/vmware/differential-datalog/pull/636#discussion_r410983563", "bodyText": "no tests with other constant expressions?", "author": "mbudiu-vmw", "createdAt": "2020-04-19T20:22:35Z", "path": "test/datalog_tests/simple2.dl", "diffHunk": "@@ -95,3 +95,14 @@ SumsOfDoubles(x, y, z) :-\n     Doubles(ys),\n     var y = FlatMap(ys),\n     var z = x + y.\n+", "originalCommit": "21b9027bd06b7786150841e5ed211d319a607f11", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6e7312f3fc5148f400b1f7f61f6bc33534e240cf", "url": "https://github.com/vmware/differential-datalog/commit/6e7312f3fc5148f400b1f7f61f6bc33534e240cf", "message": "json.dl: Use interned strings in JsonVal.\n\nThe JsonVal type represents dynamically typed JSON.  When used to store\nlarge JSON objects, it tends to take a lot of memory, much of which is\nwasted to store many copies of the same strings in field names, and\nvalues.  This commit eliminates this waste by using interned strings to\nstore JSON strings.", "committedDate": "2020-04-20T00:52:20Z", "type": "commit"}, {"oid": "41b1612143030f55feef7ec9b0f8724a22b19760", "url": "https://github.com/vmware/differential-datalog/commit/41b1612143030f55feef7ec9b0f8724a22b19760", "message": "Documentation updates.\n\nDocumentation updates:\n\n- Document the `$DDLOG_HOME` variable.\n- Add information about string library functions to the tutorial.\n- Document `uN`, `sN`, and `usize` types in the tutorial.\n- Add a section about interned values.\n\nAlso added an example of interning a non-string type as part of the\ntutorial.", "committedDate": "2020-04-20T17:27:55Z", "type": "commit"}]}