{"pr_number": 601, "pr_title": "Add support for Kafka's ConsumerRebalanceListener", "pr_createdAt": "2020-06-11T08:25:06Z", "pr_url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYzMzYxNQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r438633615", "bodyText": "Can use use javax.inject.Named and io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener (purely cosmetic comment)", "author": "cescoffier", "createdAt": "2020-06-11T08:43:17Z", "path": "documentation/src/main/doc/modules/connectors/partials/META-INF/connector/smallrye-kafka-incoming.adoc", "diffHunk": "@@ -65,4 +65,8 @@ Type: _string_ | false |\n \n Type: _string_ | false | \n \n+| *consumer-rebalance-listener.name* | The name set in javax.inject.Named of a bean that implements io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener. If set the listener will be applied to the consumer.", "originalCommit": "9129f94ea4e9bd60c5e655d70373ee2c77884cec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYzMzgxOQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r438633819", "bodyText": "The change must be done in the connector class.", "author": "cescoffier", "createdAt": "2020-06-11T08:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYzMzYxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzNTEzMw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439935133", "bodyText": "done", "author": "pcasaes", "createdAt": "2020-06-15T05:19:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYzMzYxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYzNDk2MA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r438634960", "bodyText": "You can also use an Instance<KafkaConsumerRebalanceListener> - the API is a bit simpler.\nSee https://github.com/smallrye/smallrye-reactive-messaging/blob/master/smallrye-reactive-messaging-amqp/src/main/java/io/smallrye/reactive/messaging/amqp/AmqpConnector.java#L79 and \n  \n    \n      smallrye-reactive-messaging/smallrye-reactive-messaging-amqp/src/main/java/io/smallrye/reactive/messaging/amqp/AmqpClientHelper.java\n    \n    \n         Line 21\n      in\n      a9b33e2\n    \n    \n    \n    \n\n        \n          \n           static AmqpClient createClient(AmqpConnector connector, AmqpConnectorCommonConfiguration config, \n        \n    \n  \n\n as an example.", "author": "cescoffier", "createdAt": "2020-06-11T08:45:30Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/KafkaConnector.java", "diffHunk": "@@ -61,13 +62,17 @@\n @ConnectorAttribute(name = \"partition\", type = \"int\", direction = Direction.OUTGOING, description = \"The target partition id. -1 to let the client determine the partition\", defaultValue = \"-1\")\n @ConnectorAttribute(name = \"waitForWriteCompletion\", type = \"boolean\", direction = Direction.OUTGOING, description = \"Whether the client waits for Kafka to acknowledge the written record before acknowledging the message\", defaultValue = \"true\")\n @ConnectorAttribute(name = \"max-inflight-messages\", type = \"int\", direction = Direction.OUTGOING, description = \"The maximum number of messages to be written to Kafka concurrently - The default value is the value from the `max.in.flight.requests.per.connection` Kafka property. It configures the maximum number of unacknowledged requests the client before blocking. Note that if this setting is set to be greater than 1 and there are failed sends, there is a risk of message re-ordering due to retries.\", defaultValue = \"5\")\n+@ConnectorAttribute(name = \"consumer-rebalance-listener.name\", type = \"string\", direction = Direction.INCOMING, description = \"The name set in javax.inject.Named of a bean that implements io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener. If set the listener will be applied to the consumer.\")\n public class KafkaConnector implements IncomingConnectorFactory, OutgoingConnectorFactory {\n \n     public static final String CONNECTOR_NAME = \"smallrye-kafka\";\n \n     @Inject\n     private ExecutionHolder executionHolder;\n \n+    @Inject\n+    private BeanManager beanManager;", "originalCommit": "9129f94ea4e9bd60c5e655d70373ee2c77884cec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg0NTY2MQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r438845661", "bodyText": "Sure thing!", "author": "pcasaes", "createdAt": "2020-06-11T14:53:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYzNDk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYzNTY3NQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r438635675", "bodyText": "What's the reason for not using org.apache.kafka.clients.consumer.ConsumerRebalanceListener directly?", "author": "cescoffier", "createdAt": "2020-06-11T08:46:49Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/KafkaConsumerRebalanceListener.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package io.smallrye.reactive.messaging.kafka;\n+\n+import java.util.Set;\n+\n+import io.vertx.kafka.client.common.TopicPartition;\n+import io.vertx.mutiny.kafka.client.consumer.KafkaConsumer;\n+\n+/**\n+ *\n+ * When implemented by a managed bean annotated with {@link javax.inject.Named} and\n+ * configured against a consumer, ex:\n+ * mp.messaging.incoming.example.consumer-rebalance-listener.name=ExampleConsumerRebalanceListener\n+ *\n+ * Will be applied as a consumer rebalance listener to the consumer.\n+ *\n+ * For more details\n+ *\n+ * @see org.apache.kafka.clients.consumer.ConsumerRebalanceListener\n+ */\n+public interface KafkaConsumerRebalanceListener {", "originalCommit": "9129f94ea4e9bd60c5e655d70373ee2c77884cec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYzNjE5Mw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r438636193", "bodyText": "And then I read the next file and understood it. Sorry!", "author": "cescoffier", "createdAt": "2020-06-11T08:47:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYzNTY3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1MTQ3OA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r438851478", "bodyText": "For documentation's sake it's because most of the time you'll want to manipulate the consumer object (like seeking to an offset). The original listener interface is designed with an imperative synchronous style in mind https://kafka.apache.org/0100/javadoc/org/apache/kafka/clients/consumer/ConsumerRebalanceListener.html\nI originally wrote it with the the vanilla listener interface then saw the problem \ud83d\ude06\nWith an example in the docs it'll be clearer.", "author": "pcasaes", "createdAt": "2020-06-11T15:01:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYzNTY3NQ=="}], "type": "inlineReview"}, {"oid": "b638dc44c2483b357b0a8a177e238456004e2669", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/b638dc44c2483b357b0a8a177e238456004e2669", "message": "Add support for Kafka's ConsumerRebalanceListener", "committedDate": "2020-06-11T20:52:29Z", "type": "forcePushed"}, {"oid": "af2a5bc6869c94deaa759275424789614c2da453", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/af2a5bc6869c94deaa759275424789614c2da453", "message": "Add support for Kafka's ConsumerRebalanceListener", "committedDate": "2020-06-11T22:08:56Z", "type": "forcePushed"}, {"oid": "30f6247ad752f4944c684f40c75cebe675ed3699", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/30f6247ad752f4944c684f40c75cebe675ed3699", "message": "Add support for Kafka's ConsumerRebalanceListener", "committedDate": "2020-06-11T22:47:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0Nzg1OQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439247859", "bodyText": "Instead of \"void\" should it returns a Uni<Void> indicating when the action has completed?", "author": "cescoffier", "createdAt": "2020-06-12T07:13:59Z", "path": "documentation/src/main/doc/modules/kafka/examples/inbound/KafkaRebalancedConsumerRebalanceListener.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package inbound;\n+\n+import io.smallrye.reactive.messaging.kafka.IncomingKafkaRecord;\n+import io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener;\n+import io.vertx.kafka.client.common.TopicPartition;\n+import io.vertx.mutiny.kafka.client.consumer.KafkaConsumer;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Named;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.logging.Logger;\n+\n+@ApplicationScoped\n+@Named(\"rebalanced-example.rebalancer\")\n+public class KafkaRebalancedConsumerRebalanceListener implements KafkaConsumerRebalanceListener {\n+\n+    private static final Logger LOGGER = Logger.getLogger(KafkaRebalancedConsumerRebalanceListener.class.getName());\n+\n+    /**\n+     * With this mapping we can keep track of which partitions have been set-up properly.\n+     */\n+    private final List<Long> offsetMap = new CopyOnWriteArrayList<>();\n+\n+    /**\n+     * When receiving a list of partitions will search for the earliest offset within 10 minutes\n+     * and seek the consumer to it. These operations are asynchronous so the inbound connector\n+     * WILL continue to receive messages from the subscribed topic that MIGHT be older than 10 minutes.\n+     *\n+     * @param consumer underlying consumer\n+     * @param topicPartitions set of assigned topic partitions\n+     */\n+    @Override\n+    public void onPartitionsAssigned(KafkaConsumer<?, ?> consumer, Set<TopicPartition> topicPartitions) {", "originalCommit": "30f6247ad752f4944c684f40c75cebe675ed3699", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzNTI1MQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439935251", "bodyText": "done", "author": "pcasaes", "createdAt": "2020-06-15T05:20:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0Nzg1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0ODA4Mg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439248082", "bodyText": "Returning Uni would remove the need for this method.", "author": "cescoffier", "createdAt": "2020-06-12T07:14:33Z", "path": "documentation/src/main/doc/modules/kafka/examples/inbound/KafkaRebalancedConsumerRebalanceListener.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package inbound;\n+\n+import io.smallrye.reactive.messaging.kafka.IncomingKafkaRecord;\n+import io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener;\n+import io.vertx.kafka.client.common.TopicPartition;\n+import io.vertx.mutiny.kafka.client.consumer.KafkaConsumer;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Named;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.logging.Logger;\n+\n+@ApplicationScoped\n+@Named(\"rebalanced-example.rebalancer\")\n+public class KafkaRebalancedConsumerRebalanceListener implements KafkaConsumerRebalanceListener {\n+\n+    private static final Logger LOGGER = Logger.getLogger(KafkaRebalancedConsumerRebalanceListener.class.getName());\n+\n+    /**\n+     * With this mapping we can keep track of which partitions have been set-up properly.\n+     */\n+    private final List<Long> offsetMap = new CopyOnWriteArrayList<>();\n+\n+    /**\n+     * When receiving a list of partitions will search for the earliest offset within 10 minutes\n+     * and seek the consumer to it. These operations are asynchronous so the inbound connector\n+     * WILL continue to receive messages from the subscribed topic that MIGHT be older than 10 minutes.\n+     *\n+     * @param consumer underlying consumer\n+     * @param topicPartitions set of assigned topic partitions\n+     */\n+    @Override\n+    public void onPartitionsAssigned(KafkaConsumer<?, ?> consumer, Set<TopicPartition> topicPartitions) {\n+        long now = System.currentTimeMillis();\n+        long shouldStartAt = now - 600_000L; //10 minute ago\n+\n+        topicPartitions\n+            .forEach(topicPartition -> {\n+                LOGGER.info(\"Assigned \" + topicPartition);\n+                final int partition = topicPartition.getPartition();\n+\n+                //clean the local offset map\n+                this.offsetMap.add(partition, null);\n+                consumer.offsetsForTimes(topicPartition, shouldStartAt)\n+                    .subscribe()\n+                    .with(offsetAndTimestamp -> {\n+                        LOGGER.info(\"Seeking to \" + offsetAndTimestamp);\n+                        if (offsetAndTimestamp == null) {\n+                            // no messages found in the request time period found so set\n+                            // local offset map to the 0th offset\n+                            this.offsetMap.add(partition, 0L);\n+                        } else {\n+                            this.offsetMap.add(partition, offsetAndTimestamp.getOffset());\n+                            consumer\n+                                .seek(topicPartition, offsetAndTimestamp.getOffset())\n+                                .subscribe()\n+                                .with(v -> LOGGER.info(\"Seeked to \" + offsetAndTimestamp));\n+                        }\n+                    });\n+            });\n+    }\n+\n+    @Override\n+    public void onPartitionsRevoked(KafkaConsumer<?, ?> consumer, Set<TopicPartition> topicPartitions) {\n+        // nothing to do here\n+    }\n+\n+    /**\n+     * Because the operations in {@link #onPartitionsAssigned(KafkaConsumer, Set)} are asynchronous we\n+     * MIGHT need a way to inform the inbound connector to ignore incoming messages until this listener\n+     * has done its job.\n+     *\n+     * @param message\n+     * @return true if the consumer has been properly set-up for the messages partition\n+     */\n+    public boolean isConsumerReady(IncomingKafkaRecord<?, ?> message) {", "originalCommit": "30f6247ad752f4944c684f40c75cebe675ed3699", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzNTIwOQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439935209", "bodyText": "done", "author": "pcasaes", "createdAt": "2020-06-15T05:19:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0ODA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0ODIwMw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439248203", "bodyText": "Same, here, should it return a Uni<Void>?", "author": "cescoffier", "createdAt": "2020-06-12T07:14:51Z", "path": "documentation/src/main/doc/modules/kafka/examples/inbound/KafkaRebalancedConsumerRebalanceListener.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package inbound;\n+\n+import io.smallrye.reactive.messaging.kafka.IncomingKafkaRecord;\n+import io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener;\n+import io.vertx.kafka.client.common.TopicPartition;\n+import io.vertx.mutiny.kafka.client.consumer.KafkaConsumer;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Named;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.logging.Logger;\n+\n+@ApplicationScoped\n+@Named(\"rebalanced-example.rebalancer\")\n+public class KafkaRebalancedConsumerRebalanceListener implements KafkaConsumerRebalanceListener {\n+\n+    private static final Logger LOGGER = Logger.getLogger(KafkaRebalancedConsumerRebalanceListener.class.getName());\n+\n+    /**\n+     * With this mapping we can keep track of which partitions have been set-up properly.\n+     */\n+    private final List<Long> offsetMap = new CopyOnWriteArrayList<>();\n+\n+    /**\n+     * When receiving a list of partitions will search for the earliest offset within 10 minutes\n+     * and seek the consumer to it. These operations are asynchronous so the inbound connector\n+     * WILL continue to receive messages from the subscribed topic that MIGHT be older than 10 minutes.\n+     *\n+     * @param consumer underlying consumer\n+     * @param topicPartitions set of assigned topic partitions\n+     */\n+    @Override\n+    public void onPartitionsAssigned(KafkaConsumer<?, ?> consumer, Set<TopicPartition> topicPartitions) {\n+        long now = System.currentTimeMillis();\n+        long shouldStartAt = now - 600_000L; //10 minute ago\n+\n+        topicPartitions\n+            .forEach(topicPartition -> {\n+                LOGGER.info(\"Assigned \" + topicPartition);\n+                final int partition = topicPartition.getPartition();\n+\n+                //clean the local offset map\n+                this.offsetMap.add(partition, null);\n+                consumer.offsetsForTimes(topicPartition, shouldStartAt)\n+                    .subscribe()\n+                    .with(offsetAndTimestamp -> {\n+                        LOGGER.info(\"Seeking to \" + offsetAndTimestamp);\n+                        if (offsetAndTimestamp == null) {\n+                            // no messages found in the request time period found so set\n+                            // local offset map to the 0th offset\n+                            this.offsetMap.add(partition, 0L);\n+                        } else {\n+                            this.offsetMap.add(partition, offsetAndTimestamp.getOffset());\n+                            consumer\n+                                .seek(topicPartition, offsetAndTimestamp.getOffset())\n+                                .subscribe()\n+                                .with(v -> LOGGER.info(\"Seeked to \" + offsetAndTimestamp));\n+                        }\n+                    });\n+            });\n+    }\n+\n+    @Override\n+    public void onPartitionsRevoked(KafkaConsumer<?, ?> consumer, Set<TopicPartition> topicPartitions) {", "originalCommit": "30f6247ad752f4944c684f40c75cebe675ed3699", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkzNTIzMA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439935230", "bodyText": "done", "author": "pcasaes", "createdAt": "2020-06-15T05:20:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI0ODIwMw=="}], "type": "inlineReview"}, {"oid": "fe091ae53ad8180b86a20373a68fbd17160df05a", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/fe091ae53ad8180b86a20373a68fbd17160df05a", "message": "Add support for Kafka's ConsumerRebalanceListener", "committedDate": "2020-06-13T19:55:44Z", "type": "forcePushed"}, {"oid": "48c43d1b42b9e1ceee0143f1d7113b87f714deef", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/48c43d1b42b9e1ceee0143f1d7113b87f714deef", "message": "Add support for Kafka's ConsumerRebalanceListener", "committedDate": "2020-06-13T20:14:37Z", "type": "forcePushed"}, {"oid": "b0d6ac5e1d1d240a11741b384e1cd491264f2858", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/b0d6ac5e1d1d240a11741b384e1cd491264f2858", "message": "Add support for Kafka's ConsumerRebalanceListener", "committedDate": "2020-06-14T01:15:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgwMDUzMg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439800532", "bodyText": "Do you want to resume on failure?", "author": "cescoffier", "createdAt": "2020-06-14T07:27:58Z", "path": "documentation/src/main/doc/modules/kafka/examples/inbound/KafkaRebalancedConsumerRebalanceListener.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package inbound;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener;\n+import io.vertx.kafka.client.common.TopicPartition;\n+import io.vertx.mutiny.kafka.client.consumer.KafkaConsumer;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Named;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+@ApplicationScoped\n+@Named(\"rebalanced-example.rebalancer\")\n+public class KafkaRebalancedConsumerRebalanceListener implements KafkaConsumerRebalanceListener {\n+\n+    private static final Logger LOGGER = Logger.getLogger(KafkaRebalancedConsumerRebalanceListener.class.getName());\n+\n+    /**\n+     * When receiving a list of partitions will search for the earliest offset within 10 minutes\n+     * and seek the consumer to it. These operations are asynchronous so the inbound connector's\n+     * consumer WILL be paused until they are complete.\n+     *\n+     * @param consumer        underlying consumer\n+     * @param topicPartitions set of assigned topic partitions\n+     * @return An observable\n+     */\n+    @Override\n+    public Uni<Void> onPartitionsAssigned(KafkaConsumer<?, ?> consumer, Set<TopicPartition> topicPartitions) {\n+        // we must pause the consumer otherwise the inbound connector will continue to receive messages\n+        // while we seek to the correct offset.\n+        consumer.pause();\n+\n+        long now = System.currentTimeMillis();\n+        long shouldStartAt = now - 600_000L; //10 minute ago\n+\n+        return Uni\n+            .combine()\n+            .all()\n+            .unis(topicPartitions\n+                .stream()\n+                .map(topicPartition -> {\n+                    LOGGER.info(\"Assigned \" + topicPartition);\n+                    return consumer.offsetsForTimes(topicPartition, shouldStartAt)\n+                        .onItem()\n+                        .invoke(o -> LOGGER.info(\"Seeking to \" + o))\n+                        .onItem()\n+                        .produceUni(o -> consumer\n+                            .seek(topicPartition, o == null ? 0L : o.getOffset())\n+                            .onItem()\n+                            .invoke(v -> LOGGER.info(\"Seeked to \" + o))\n+                        );\n+                })\n+                .collect(Collectors.toList()))\n+            .combinedWith(a -> null)\n+            .onItemOrFailure()\n+            .apply((a, t) -> {\n+                // once the seek is complete let's resume the consumer\n+                consumer.resume();", "originalCommit": "b0d6ac5e1d1d240a11741b384e1cd491264f2858", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0NDk2NA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439844964", "bodyText": "That's up to the user really.", "author": "pcasaes", "createdAt": "2020-06-14T16:13:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgwMDUzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgwMDU5Ng==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439800596", "bodyText": "Question: should it be done by the connector, or by the implementation of theKafkaConsumerRebalanceListener?", "author": "cescoffier", "createdAt": "2020-06-14T07:29:00Z", "path": "documentation/src/main/doc/modules/kafka/examples/inbound/KafkaRebalancedConsumerRebalanceListener.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package inbound;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.smallrye.reactive.messaging.kafka.KafkaConsumerRebalanceListener;\n+import io.vertx.kafka.client.common.TopicPartition;\n+import io.vertx.mutiny.kafka.client.consumer.KafkaConsumer;\n+\n+import javax.enterprise.context.ApplicationScoped;\n+import javax.inject.Named;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+import java.util.stream.Collectors;\n+\n+@ApplicationScoped\n+@Named(\"rebalanced-example.rebalancer\")\n+public class KafkaRebalancedConsumerRebalanceListener implements KafkaConsumerRebalanceListener {\n+\n+    private static final Logger LOGGER = Logger.getLogger(KafkaRebalancedConsumerRebalanceListener.class.getName());\n+\n+    /**\n+     * When receiving a list of partitions will search for the earliest offset within 10 minutes\n+     * and seek the consumer to it. These operations are asynchronous so the inbound connector's\n+     * consumer WILL be paused until they are complete.\n+     *\n+     * @param consumer        underlying consumer\n+     * @param topicPartitions set of assigned topic partitions\n+     * @return An observable\n+     */\n+    @Override\n+    public Uni<Void> onPartitionsAssigned(KafkaConsumer<?, ?> consumer, Set<TopicPartition> topicPartitions) {\n+        // we must pause the consumer otherwise the inbound connector will continue to receive messages\n+        // while we seek to the correct offset.\n+        consumer.pause();", "originalCommit": "b0d6ac5e1d1d240a11741b384e1cd491264f2858", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0NTExMw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439845113", "bodyText": "I thought about this. The listener isn't always used to seek to separate offset, so it's really up to the user.", "author": "pcasaes", "createdAt": "2020-06-14T16:15:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgwMDU5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0NzA4MQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439847081", "bodyText": "On further thought. It does make sense to do it. By the kafka documentation it is expected that the operations in the listener are completed before receiving events. If the user wishes to override they can resume from withing their implementation.", "author": "pcasaes", "createdAt": "2020-06-14T16:38:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgwMDU5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0Nzc1OQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439847759", "bodyText": "Agreed.", "author": "cescoffier", "createdAt": "2020-06-14T16:47:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgwMDU5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0NzgwNw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439847807", "bodyText": "So it needs to be changed in this example and explained in the doc.", "author": "cescoffier", "createdAt": "2020-06-14T16:47:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgwMDU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgwMDYyMg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439800622", "bodyText": "so, it's not an observable, it's a Uni indicating when the operation has completed.", "author": "cescoffier", "createdAt": "2020-06-14T07:29:39Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/KafkaConsumerRebalanceListener.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package io.smallrye.reactive.messaging.kafka;\n+\n+import java.util.Set;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.kafka.client.common.TopicPartition;\n+import io.vertx.mutiny.kafka.client.consumer.KafkaConsumer;\n+\n+/**\n+ *\n+ * When implemented by a managed bean annotated with {@link javax.inject.Named} and\n+ * configured against a consumer, ex:\n+ * mp.messaging.incoming.example.consumer-rebalance-listener.name=ExampleConsumerRebalanceListener\n+ *\n+ * Will be applied as a consumer rebalance listener to the inbound connector's consumer.\n+ *\n+ * For more details:\n+ * \n+ * @see org.apache.kafka.clients.consumer.ConsumerRebalanceListener\n+ */\n+public interface KafkaConsumerRebalanceListener {\n+\n+    /**\n+     * Called when the consumer is assigned topic partitions\n+     * This method might be called for each consumer available to the connector\n+     *\n+     * @param consumer underlying consumer\n+     * @param topicPartitions set of assigned topic partitions\n+     * @return An observable", "originalCommit": "b0d6ac5e1d1d240a11741b384e1cd491264f2858", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgwMDY2Mw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439800663", "bodyText": "or failed :-)", "author": "cescoffier", "createdAt": "2020-06-14T07:30:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgwMDYyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgwMDYzMw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439800633", "bodyText": "so, it's not an observable, it's a Uni indicating when the operation has completed.", "author": "cescoffier", "createdAt": "2020-06-14T07:29:48Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/KafkaConsumerRebalanceListener.java", "diffHunk": "@@ -0,0 +1,42 @@\n+package io.smallrye.reactive.messaging.kafka;\n+\n+import java.util.Set;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.kafka.client.common.TopicPartition;\n+import io.vertx.mutiny.kafka.client.consumer.KafkaConsumer;\n+\n+/**\n+ *\n+ * When implemented by a managed bean annotated with {@link javax.inject.Named} and\n+ * configured against a consumer, ex:\n+ * mp.messaging.incoming.example.consumer-rebalance-listener.name=ExampleConsumerRebalanceListener\n+ *\n+ * Will be applied as a consumer rebalance listener to the inbound connector's consumer.\n+ *\n+ * For more details:\n+ * \n+ * @see org.apache.kafka.clients.consumer.ConsumerRebalanceListener\n+ */\n+public interface KafkaConsumerRebalanceListener {\n+\n+    /**\n+     * Called when the consumer is assigned topic partitions\n+     * This method might be called for each consumer available to the connector\n+     *\n+     * @param consumer underlying consumer\n+     * @param topicPartitions set of assigned topic partitions\n+     * @return An observable\n+     */\n+    Uni<Void> onPartitionsAssigned(KafkaConsumer<?, ?> consumer, Set<TopicPartition> topicPartitions);\n+\n+    /**\n+     * Called when the consumer is revoked topic partitions\n+     * This method might be called for each consumer available to the connector\n+     *\n+     * @param consumer underlying consumer\n+     * @param topicPartitions set of revoked topic partitions\n+     * @return An observable", "originalCommit": "b0d6ac5e1d1d240a11741b384e1cd491264f2858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgwMDcwNw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439800707", "bodyText": "Great! You already use the new logging system!", "author": "cescoffier", "createdAt": "2020-06-14T07:30:29Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/i18n/KafkaLogging.java", "diffHunk": "@@ -93,4 +93,12 @@\n     @LogMessage(level = Logger.Level.DEBUG)\n     @Message(id = 18218, value = \"An exception has been caught while closing the Kafka consumer\")\n     void exceptionOnClose(@Cause Throwable t);\n+\n+    @LogMessage(level = Logger.Level.ERROR)\n+    @Message(id = 18219, value = \"Unable to execute consumer rebalance listener for group '%s'\")\n+    void unableToExecuteConsumerReblanceListener(String consumerGroup, @Cause Throwable t);", "originalCommit": "b0d6ac5e1d1d240a11741b384e1cd491264f2858", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgwMDg4MQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439800881", "bodyText": "Do we want to handle the case with multiple listeners for a single topic?", "author": "cescoffier", "createdAt": "2020-06-14T07:32:43Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -59,14 +68,47 @@ public KafkaSource(Vertx vertx, KafkaConnectorIncomingConfiguration config) {\n         kafkaConfiguration.remove(\"broadcast\");\n         kafkaConfiguration.remove(\"partitions\");\n \n-        this.consumer = KafkaConsumer.create(vertx, kafkaConfiguration);\n+        final KafkaConsumer<K, V> kafkaConsumer = KafkaConsumer.create(vertx, kafkaConfiguration);\n+        final List<Publisher<KafkaConsumerRecord<K, V>>> multis = new ArrayList<>();\n+        config\n+                .getConsumerRebalanceListenerName()\n+                .map(name -> {\n+                    log.info(\"Loading KafkaConsumerRebalanceListener \" + name);\n+                    return NamedLiteral.of(name);\n+                })\n+                .map(consumerRebalanceListeners::select)\n+                .map(Instance::get)\n+                .ifPresent(listener -> multis.add(Multi", "originalCommit": "b0d6ac5e1d1d240a11741b384e1cd491264f2858", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0NDg0Ng==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439844846", "bodyText": "There won't be multiple listeners. But the listener is called whenever there's a rebalance not just during startup.", "author": "pcasaes", "createdAt": "2020-06-14T16:12:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgwMDg4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg0Nzg4OA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439847888", "bodyText": "Got it!", "author": "cescoffier", "createdAt": "2020-06-14T16:48:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTgwMDg4MQ=="}], "type": "inlineReview"}, {"oid": "a3a1168bdafb4343f09a27e6178854b408b0d45a", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/a3a1168bdafb4343f09a27e6178854b408b0d45a", "message": "Add support for Kafka's ConsumerRebalanceListener", "committedDate": "2020-06-14T15:36:44Z", "type": "forcePushed"}, {"oid": "52c3697f98c4bae72fe4ff041136b316270cae7b", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/52c3697f98c4bae72fe4ff041136b316270cae7b", "message": "Add support for Kafka's ConsumerRebalanceListener", "committedDate": "2020-06-14T16:18:21Z", "type": "forcePushed"}, {"oid": "8f35f9fb4a85fbe3c5598f140f38859c90d13c49", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/8f35f9fb4a85fbe3c5598f140f38859c90d13c49", "message": "Add support for Kafka's ConsumerRebalanceListener", "committedDate": "2020-06-14T16:57:56Z", "type": "forcePushed"}, {"oid": "846fce6e3d60ce874e3979f76f563f8d321baae3", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/846fce6e3d60ce874e3979f76f563f8d321baae3", "message": "Add support for Kafka's ConsumerRebalanceListener", "committedDate": "2020-06-14T18:47:08Z", "type": "forcePushed"}, {"oid": "23f49168e2a854d004105ec3428ed38856c249fb", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/23f49168e2a854d004105ec3428ed38856c249fb", "message": "Add support for Kafka's ConsumerRebalanceListener", "committedDate": "2020-06-14T19:18:06Z", "type": "forcePushed"}, {"oid": "8504e830d0213b1588c2633dc42022c548e75ef7", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/8504e830d0213b1588c2633dc42022c548e75ef7", "message": "Add support for Kafka's ConsumerRebalanceListener", "committedDate": "2020-06-14T20:44:05Z", "type": "forcePushed"}, {"oid": "927f7bc51666503daf80206e6c8c830f097c0d76", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/927f7bc51666503daf80206e6c8c830f097c0d76", "message": "Add support for Kafka's ConsumerRebalanceListener", "committedDate": "2020-06-14T21:46:28Z", "type": "forcePushed"}, {"oid": "aab7c92c9ccd496f4780667a158e69e6e76a109d", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/aab7c92c9ccd496f4780667a158e69e6e76a109d", "message": "Add support for Kafka's ConsumerRebalanceListener", "committedDate": "2020-06-15T04:30:58Z", "type": "forcePushed"}, {"oid": "c2d1571f5305c9de2095e4a6e6582e6be0645df2", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/c2d1571f5305c9de2095e4a6e6582e6be0645df2", "message": "Add support for Kafka's ConsumerRebalanceListener", "committedDate": "2020-06-15T04:41:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0NDE2MQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439944161", "bodyText": "Could you add a line telling that no messages will be received while the operation is in progress (and mention the pause/resume trick).", "author": "cescoffier", "createdAt": "2020-06-15T05:56:00Z", "path": "documentation/src/main/doc/modules/kafka/pages/consumer-rebalance-listener.adoc", "diffHunk": "@@ -0,0 +1,32 @@\n+[#kafka-consumer-rebalance-listener]\n+=== Consumer Rebalance Listener\n+\n+An implementation of the consumer re-balance listener can be provided which affords us fine grain controls of the assigned\n+offset. Common uses are storing offsets in a separate store to enable deliver exactly-once semantics, and starting from\n+a specific time window.", "originalCommit": "c2d1571f5305c9de2095e4a6e6582e6be0645df2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI0NDI2NQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r440244265", "bodyText": "done", "author": "pcasaes", "createdAt": "2020-06-15T15:06:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0NDE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0NDU1MA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439944550", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * To configure set the name in the inbound connector's consumer re-balance listener, ex:\n          \n          \n            \n             * To configure which listener you want to use, set the name in the inbound connector's consumer re-balance listener attribute, ex:", "author": "cescoffier", "createdAt": "2020-06-15T05:57:18Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/KafkaConsumerRebalanceListener.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package io.smallrye.reactive.messaging.kafka;\n+\n+import java.util.Set;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.kafka.client.common.TopicPartition;\n+import io.vertx.mutiny.kafka.client.consumer.KafkaConsumer;\n+\n+/**\n+ *\n+ * When implemented by a managed bean annotated with {@link javax.inject.Named} and\n+ * configured against an inbound connector will be applied as a consumer re-balance listener\n+ * to that inbound connector's consumer.\n+ *\n+ *\n+ * To configure set the name in the inbound connector's consumer re-balance listener, ex:", "originalCommit": "c2d1571f5305c9de2095e4a6e6582e6be0645df2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI0NDM1MQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r440244351", "bodyText": "done", "author": "pcasaes", "createdAt": "2020-06-15T15:06:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0NDU1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0NDg0Nw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439944847", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Or set the name to be the same as the group id, ex:\n          \n          \n            \n             * Alternatively, name your listened (using the {@code @Named} annotation) to be group id used by the connector, ex:", "author": "cescoffier", "createdAt": "2020-06-15T05:58:18Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/KafkaConsumerRebalanceListener.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package io.smallrye.reactive.messaging.kafka;\n+\n+import java.util.Set;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.kafka.client.common.TopicPartition;\n+import io.vertx.mutiny.kafka.client.consumer.KafkaConsumer;\n+\n+/**\n+ *\n+ * When implemented by a managed bean annotated with {@link javax.inject.Named} and\n+ * configured against an inbound connector will be applied as a consumer re-balance listener\n+ * to that inbound connector's consumer.\n+ *\n+ *\n+ * To configure set the name in the inbound connector's consumer re-balance listener, ex:\n+ * mp.messaging.incoming.example.consumer-rebalance-listener.name=ExampleConsumerRebalanceListener\n+ * @Named(\"ExampleConsumerRebalanceListener\")\n+ *\n+ * Or set the name to be the same as the group id, ex:", "originalCommit": "c2d1571f5305c9de2095e4a6e6582e6be0645df2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI0NDQxMg==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r440244412", "bodyText": "done", "author": "pcasaes", "createdAt": "2020-06-15T15:06:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0NDg0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0NTEzNQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439945135", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * mp.messaging.incoming.example.consumer-rebalance-listener.name=ExampleConsumerRebalanceListener\n          \n          \n            \n            {@code\n          \n          \n            \n             mp.messaging.incoming.example.consumer-rebalance- listener.name=ExampleConsumerRebalanceListener\n          \n          \n            \n            }\n          \n          \n            \n            \n          \n          \n            \n            {@code @Named(\"ExampleConsumerRebalanceListener\")}", "author": "cescoffier", "createdAt": "2020-06-15T05:59:17Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/KafkaConsumerRebalanceListener.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package io.smallrye.reactive.messaging.kafka;\n+\n+import java.util.Set;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.kafka.client.common.TopicPartition;\n+import io.vertx.mutiny.kafka.client.consumer.KafkaConsumer;\n+\n+/**\n+ *\n+ * When implemented by a managed bean annotated with {@link javax.inject.Named} and\n+ * configured against an inbound connector will be applied as a consumer re-balance listener\n+ * to that inbound connector's consumer.\n+ *\n+ *\n+ * To configure set the name in the inbound connector's consumer re-balance listener, ex:\n+ * mp.messaging.incoming.example.consumer-rebalance-listener.name=ExampleConsumerRebalanceListener", "originalCommit": "c2d1571f5305c9de2095e4a6e6582e6be0645df2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI0NDk1NA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r440244954", "bodyText": "done", "author": "pcasaes", "createdAt": "2020-06-15T15:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0NTEzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0NTI3MA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439945270", "bodyText": "Same code trick (or the javadoc will be wrong)", "author": "cescoffier", "createdAt": "2020-06-15T05:59:47Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/KafkaConsumerRebalanceListener.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package io.smallrye.reactive.messaging.kafka;\n+\n+import java.util.Set;\n+\n+import io.smallrye.mutiny.Uni;\n+import io.vertx.kafka.client.common.TopicPartition;\n+import io.vertx.mutiny.kafka.client.consumer.KafkaConsumer;\n+\n+/**\n+ *\n+ * When implemented by a managed bean annotated with {@link javax.inject.Named} and\n+ * configured against an inbound connector will be applied as a consumer re-balance listener\n+ * to that inbound connector's consumer.\n+ *\n+ *\n+ * To configure set the name in the inbound connector's consumer re-balance listener, ex:\n+ * mp.messaging.incoming.example.consumer-rebalance-listener.name=ExampleConsumerRebalanceListener\n+ * @Named(\"ExampleConsumerRebalanceListener\")\n+ *\n+ * Or set the name to be the same as the group id, ex:\n+ * mp.messaging.incoming.example.group.id=my-group", "originalCommit": "c2d1571f5305c9de2095e4a6e6582e6be0645df2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI0NTA5Nw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r440245097", "bodyText": "done", "author": "pcasaes", "createdAt": "2020-06-15T15:07:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0NTI3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0NTU0Mw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439945543", "bodyText": "The new attribute need to be removed from the kafkaConfiguration map. It avoids a warning.", "author": "cescoffier", "createdAt": "2020-06-15T06:00:37Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -59,7 +66,74 @@ public KafkaSource(Vertx vertx, KafkaConnectorIncomingConfiguration config) {\n         kafkaConfiguration.remove(\"broadcast\");\n         kafkaConfiguration.remove(\"partitions\");", "originalCommit": "c2d1571f5305c9de2095e4a6e6582e6be0645df2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI0NTAzMw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r440245033", "bodyText": "done", "author": "pcasaes", "createdAt": "2020-06-15T15:07:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0NTU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0NjA2NA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439946064", "bodyText": "You may resume twice (not sure if it's harmful). I would recommend moving the onFailure and onItem in the subscribe part.", "author": "cescoffier", "createdAt": "2020-06-15T06:02:18Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -59,7 +66,74 @@ public KafkaSource(Vertx vertx, KafkaConnectorIncomingConfiguration config) {\n         kafkaConfiguration.remove(\"broadcast\");\n         kafkaConfiguration.remove(\"partitions\");\n \n-        this.consumer = KafkaConsumer.create(vertx, kafkaConfiguration);\n+        final KafkaConsumer<K, V> kafkaConsumer = KafkaConsumer.create(vertx, kafkaConfiguration);\n+        config\n+                .getConsumerRebalanceListenerName()\n+                .map(name -> {\n+                    log.loadingConsumerRebalanceListenerFromConfiguredName(name);\n+                    return NamedLiteral.of(name);\n+                })\n+                .map(consumerRebalanceListeners::select)\n+                .map(Instance::get)\n+                .map(Optional::of)\n+                .orElseGet(() -> {\n+                    Instance<KafkaConsumerRebalanceListener> rebalanceFromGroupListeners = consumerRebalanceListeners\n+                            .select(NamedLiteral.of(group));\n+\n+                    if (!rebalanceFromGroupListeners.isUnsatisfied()) {\n+                        log.loadingConsumerRebalanceListenerFromGroupId(group);\n+                        return Optional.of(rebalanceFromGroupListeners.get());\n+                    }\n+                    return Optional.empty();\n+                })\n+                .ifPresent(listener -> {\n+                    // If the re-balance assign fails we must resume the consumer in order to force a consumer group\n+                    // re-balance. To do so we must wait until after the poll interval time or\n+                    // poll interval time + session timeout if group instance id is not null.\n+                    final long consumerReEnableWaitTime = Long.parseLong(\n+                            kafkaConfiguration.getOrDefault(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, \"300000\"))\n+                            + (kafkaConfiguration.get(ConsumerConfig.GROUP_INSTANCE_ID_CONFIG) == null ? 0L\n+                                    : Long.parseLong(\n+                                            kafkaConfiguration.getOrDefault(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG,\n+                                                    \"10000\")));\n+\n+                    // We will retry the re-balance consumer listener on failure using an exponential backoff until\n+                    // we can allow the kafka consumer to do it on its own. We do this because by default it would take\n+                    // 5 minutes for kafka to do this which is too long. With defaults consumerReEnableWaitTime would be\n+                    // 500000 millis. We also can't simply retry indefinitely because once the consumer has been paused\n+                    // for consumerReEnableWaitTime kafka will force a re-balance once resumed.\n+                    // We are doing retries using the time intervals 2s, 4s, 8s, 10s, 10s, 10s, 10s...\n+                    // The following formula will give us a reasonable number for retry attempt that is just greater\n+                    // than consumerReEnableWaitTime\n+                    final long consumerReEnableRetryMaxAttempts = 1\n+                            + Math.max(0, 3 + (consumerReEnableWaitTime - 14_000) / 10_000);\n+\n+                    kafkaConsumer.partitionsAssignedHandler(set -> {\n+                        kafkaConsumer.pause();\n+                        log.executingConsumerAssignedRebalanceListener(group);\n+                        listener.onPartitionsAssigned(kafkaConsumer, set)\n+                                .onFailure().invoke(t -> log.unableToExecuteConsumerAssignedRebalanceListener(group, t))\n+                                .onFailure().retry().withBackOff(Duration.ofSeconds(1), Duration.ofSeconds(10)).withJitter(0.0)\n+                                .atMost(consumerReEnableRetryMaxAttempts)\n+                                .onFailure().invoke(t -> {\n+                                    log.reEnablingConsumerforGroup(group);\n+                                    kafkaConsumer.resume();\n+                                })\n+                                .onItem().invoke(a -> kafkaConsumer.resume())", "originalCommit": "c2d1571f5305c9de2095e4a6e6582e6be0645df2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI0NTQ1MQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r440245451", "bodyText": "done", "author": "pcasaes", "createdAt": "2020-06-15T15:08:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0NjA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0NjE5NQ==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439946195", "bodyText": "Should we remove the jitter?", "author": "cescoffier", "createdAt": "2020-06-15T06:02:48Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -59,7 +66,74 @@ public KafkaSource(Vertx vertx, KafkaConnectorIncomingConfiguration config) {\n         kafkaConfiguration.remove(\"broadcast\");\n         kafkaConfiguration.remove(\"partitions\");\n \n-        this.consumer = KafkaConsumer.create(vertx, kafkaConfiguration);\n+        final KafkaConsumer<K, V> kafkaConsumer = KafkaConsumer.create(vertx, kafkaConfiguration);\n+        config\n+                .getConsumerRebalanceListenerName()\n+                .map(name -> {\n+                    log.loadingConsumerRebalanceListenerFromConfiguredName(name);\n+                    return NamedLiteral.of(name);\n+                })\n+                .map(consumerRebalanceListeners::select)\n+                .map(Instance::get)\n+                .map(Optional::of)\n+                .orElseGet(() -> {\n+                    Instance<KafkaConsumerRebalanceListener> rebalanceFromGroupListeners = consumerRebalanceListeners\n+                            .select(NamedLiteral.of(group));\n+\n+                    if (!rebalanceFromGroupListeners.isUnsatisfied()) {\n+                        log.loadingConsumerRebalanceListenerFromGroupId(group);\n+                        return Optional.of(rebalanceFromGroupListeners.get());\n+                    }\n+                    return Optional.empty();\n+                })\n+                .ifPresent(listener -> {\n+                    // If the re-balance assign fails we must resume the consumer in order to force a consumer group\n+                    // re-balance. To do so we must wait until after the poll interval time or\n+                    // poll interval time + session timeout if group instance id is not null.\n+                    final long consumerReEnableWaitTime = Long.parseLong(\n+                            kafkaConfiguration.getOrDefault(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, \"300000\"))\n+                            + (kafkaConfiguration.get(ConsumerConfig.GROUP_INSTANCE_ID_CONFIG) == null ? 0L\n+                                    : Long.parseLong(\n+                                            kafkaConfiguration.getOrDefault(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG,\n+                                                    \"10000\")));\n+\n+                    // We will retry the re-balance consumer listener on failure using an exponential backoff until\n+                    // we can allow the kafka consumer to do it on its own. We do this because by default it would take\n+                    // 5 minutes for kafka to do this which is too long. With defaults consumerReEnableWaitTime would be\n+                    // 500000 millis. We also can't simply retry indefinitely because once the consumer has been paused\n+                    // for consumerReEnableWaitTime kafka will force a re-balance once resumed.\n+                    // We are doing retries using the time intervals 2s, 4s, 8s, 10s, 10s, 10s, 10s...\n+                    // The following formula will give us a reasonable number for retry attempt that is just greater\n+                    // than consumerReEnableWaitTime\n+                    final long consumerReEnableRetryMaxAttempts = 1\n+                            + Math.max(0, 3 + (consumerReEnableWaitTime - 14_000) / 10_000);\n+\n+                    kafkaConsumer.partitionsAssignedHandler(set -> {\n+                        kafkaConsumer.pause();\n+                        log.executingConsumerAssignedRebalanceListener(group);\n+                        listener.onPartitionsAssigned(kafkaConsumer, set)\n+                                .onFailure().invoke(t -> log.unableToExecuteConsumerAssignedRebalanceListener(group, t))\n+                                .onFailure().retry().withBackOff(Duration.ofSeconds(1), Duration.ofSeconds(10)).withJitter(0.0)", "originalCommit": "c2d1571f5305c9de2095e4a6e6582e6be0645df2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDIxMzIzNw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r440213237", "bodyText": "I think so. I'm worried that it would cause the resume to start before the session times out. Unfortunately UniRetry doesn't have a untilTime method. That would've been super helpful. It has an until but that doesn't do an exponential backoff.", "author": "pcasaes", "createdAt": "2020-06-15T14:23:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0NjE5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0NjM1MA==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439946350", "bodyText": "I would recommend moving this to the subscribe.", "author": "cescoffier", "createdAt": "2020-06-15T06:03:20Z", "path": "smallrye-reactive-messaging-kafka/src/main/java/io/smallrye/reactive/messaging/kafka/impl/KafkaSource.java", "diffHunk": "@@ -59,7 +66,74 @@ public KafkaSource(Vertx vertx, KafkaConnectorIncomingConfiguration config) {\n         kafkaConfiguration.remove(\"broadcast\");\n         kafkaConfiguration.remove(\"partitions\");\n \n-        this.consumer = KafkaConsumer.create(vertx, kafkaConfiguration);\n+        final KafkaConsumer<K, V> kafkaConsumer = KafkaConsumer.create(vertx, kafkaConfiguration);\n+        config\n+                .getConsumerRebalanceListenerName()\n+                .map(name -> {\n+                    log.loadingConsumerRebalanceListenerFromConfiguredName(name);\n+                    return NamedLiteral.of(name);\n+                })\n+                .map(consumerRebalanceListeners::select)\n+                .map(Instance::get)\n+                .map(Optional::of)\n+                .orElseGet(() -> {\n+                    Instance<KafkaConsumerRebalanceListener> rebalanceFromGroupListeners = consumerRebalanceListeners\n+                            .select(NamedLiteral.of(group));\n+\n+                    if (!rebalanceFromGroupListeners.isUnsatisfied()) {\n+                        log.loadingConsumerRebalanceListenerFromGroupId(group);\n+                        return Optional.of(rebalanceFromGroupListeners.get());\n+                    }\n+                    return Optional.empty();\n+                })\n+                .ifPresent(listener -> {\n+                    // If the re-balance assign fails we must resume the consumer in order to force a consumer group\n+                    // re-balance. To do so we must wait until after the poll interval time or\n+                    // poll interval time + session timeout if group instance id is not null.\n+                    final long consumerReEnableWaitTime = Long.parseLong(\n+                            kafkaConfiguration.getOrDefault(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, \"300000\"))\n+                            + (kafkaConfiguration.get(ConsumerConfig.GROUP_INSTANCE_ID_CONFIG) == null ? 0L\n+                                    : Long.parseLong(\n+                                            kafkaConfiguration.getOrDefault(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG,\n+                                                    \"10000\")));\n+\n+                    // We will retry the re-balance consumer listener on failure using an exponential backoff until\n+                    // we can allow the kafka consumer to do it on its own. We do this because by default it would take\n+                    // 5 minutes for kafka to do this which is too long. With defaults consumerReEnableWaitTime would be\n+                    // 500000 millis. We also can't simply retry indefinitely because once the consumer has been paused\n+                    // for consumerReEnableWaitTime kafka will force a re-balance once resumed.\n+                    // We are doing retries using the time intervals 2s, 4s, 8s, 10s, 10s, 10s, 10s...\n+                    // The following formula will give us a reasonable number for retry attempt that is just greater\n+                    // than consumerReEnableWaitTime\n+                    final long consumerReEnableRetryMaxAttempts = 1\n+                            + Math.max(0, 3 + (consumerReEnableWaitTime - 14_000) / 10_000);\n+\n+                    kafkaConsumer.partitionsAssignedHandler(set -> {\n+                        kafkaConsumer.pause();\n+                        log.executingConsumerAssignedRebalanceListener(group);\n+                        listener.onPartitionsAssigned(kafkaConsumer, set)\n+                                .onFailure().invoke(t -> log.unableToExecuteConsumerAssignedRebalanceListener(group, t))\n+                                .onFailure().retry().withBackOff(Duration.ofSeconds(1), Duration.ofSeconds(10)).withJitter(0.0)\n+                                .atMost(consumerReEnableRetryMaxAttempts)\n+                                .onFailure().invoke(t -> {\n+                                    log.reEnablingConsumerforGroup(group);\n+                                    kafkaConsumer.resume();\n+                                })\n+                                .onItem().invoke(a -> kafkaConsumer.resume())\n+                                .subscribe()\n+                                .with(a -> log.executedConsumerAssignedRebalanceListener(group));\n+                    });\n+\n+                    kafkaConsumer.partitionsRevokedHandler(set -> {\n+                        log.executingConsumerRevokedRebalanceListener(group);\n+                        listener.onPartitionsRevoked(kafkaConsumer, set)\n+                                .onFailure().invoke(t -> log.unableToExecuteConsumerRevokedRebalanceListener(group, t))", "originalCommit": "c2d1571f5305c9de2095e4a6e6582e6be0645df2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI0NTU2Ng==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r440245566", "bodyText": "done", "author": "pcasaes", "createdAt": "2020-06-15T15:08:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0NjM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0NjczMw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r439946733", "bodyText": "A test checking that we fail if a listener is configured but cannot be found should be added.", "author": "cescoffier", "createdAt": "2020-06-15T06:04:30Z", "path": "smallrye-reactive-messaging-kafka/src/test/java/io/smallrye/reactive/messaging/kafka/KafkaSourceTest.java", "diffHunk": "@@ -388,15 +506,64 @@ public void testSourceWithEmptyOptionalConfiguration() {\n                 .collect(Collectors.toList())).containsExactly(0, 1, 2, 3, 4, 5, 6, 7, 8, 9);\n     }\n \n+    private BeanManager getBeanManager() {\n+        if (container == null) {\n+            Weld weld = baseWeld();\n+            addConfig(new MapBasedConfig(new HashMap<>()));\n+            weld.disableDiscovery();\n+            container = weld.initialize();\n+        }\n+        return container.getBeanManager();\n+    }\n+\n+    private Instance<KafkaConsumerRebalanceListener> getConsumerRebalanceListeners() {\n+        return getBeanManager()\n+                .createInstance()\n+                .select(KafkaConsumerRebalanceListener.class);\n+    }\n+\n+    private ConsumptionConsumerRebalanceListener getConsumptionConsumerRebalanceListener() {\n+        return getBeanManager()\n+                .createInstance()\n+                .select(ConsumptionConsumerRebalanceListener.class)\n+                .select(NamedLiteral.of(ConsumptionConsumerRebalanceListener.class.getSimpleName()))\n+                .get();\n+\n+    }\n+\n+    private StartFromFifthOffsetFromLatestConsumerRebalanceListener getStartFromFifthOffsetFromLatestConsumerRebalanceListener(\n+            String name) {\n+        return getBeanManager()\n+                .createInstance()\n+                .select(StartFromFifthOffsetFromLatestConsumerRebalanceListener.class)\n+                .select(NamedLiteral.of(name))\n+                .get();\n+\n+    }\n+\n     private ConsumptionBean deploy(MapBasedConfig config) {\n         Weld weld = baseWeld();\n         addConfig(config);\n         weld.addBeanClass(ConsumptionBean.class);\n+        weld.addBeanClass(ConsumptionConsumerRebalanceListener.class);\n         weld.disableDiscovery();\n         container = weld.initialize();\n         return container.getBeanManager().createInstance().select(ConsumptionBean.class).get();\n     }\n \n+    private ConsumptionBeanWithoutAck deployWithoutAck(MapBasedConfig config) {", "originalCommit": "c2d1571f5305c9de2095e4a6e6582e6be0645df2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI0Nzg5Mw==", "url": "https://github.com/smallrye/smallrye-reactive-messaging/pull/601#discussion_r440247893", "bodyText": "done", "author": "pcasaes", "createdAt": "2020-06-15T15:11:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0NjczMw=="}], "type": "inlineReview"}, {"oid": "817f131a1bfaf1ab3ad74ee2104fbdc47d557f99", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/817f131a1bfaf1ab3ad74ee2104fbdc47d557f99", "message": "Add support for Kafka's ConsumerRebalanceListener", "committedDate": "2020-06-15T15:00:42Z", "type": "commit"}, {"oid": "817f131a1bfaf1ab3ad74ee2104fbdc47d557f99", "url": "https://github.com/smallrye/smallrye-reactive-messaging/commit/817f131a1bfaf1ab3ad74ee2104fbdc47d557f99", "message": "Add support for Kafka's ConsumerRebalanceListener", "committedDate": "2020-06-15T15:00:42Z", "type": "forcePushed"}]}