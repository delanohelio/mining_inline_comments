{"pr_number": 2917, "pr_title": "[java] New Java XPath functions", "pr_createdAt": "2020-11-13T13:58:14Z", "pr_url": "https://github.com/pmd/pmd/pull/2917", "timeline": [{"oid": "150f8c746ecff98b1275a1ceb6a21d8e76f2cef0", "url": "https://github.com/pmd/pmd/commit/150f8c746ecff98b1275a1ceb6a21d8e76f2cef0", "message": "Extract changes to xpath functions", "committedDate": "2020-11-13T13:29:20Z", "type": "commit"}, {"oid": "c35b4e879ec1ac22b392e41c6e650da8fa46fbdf", "url": "https://github.com/pmd/pmd/commit/c35b4e879ec1ac22b392e41c6e650da8fa46fbdf", "message": "Extract changes to invocation matchers", "committedDate": "2020-11-13T13:32:32Z", "type": "commit"}, {"oid": "4b98c4012d1ba457c95cfdc3e203e46ba6851316", "url": "https://github.com/pmd/pmd/commit/4b98c4012d1ba457c95cfdc3e203e46ba6851316", "message": "Extract xpath fun doc", "committedDate": "2020-11-13T13:33:25Z", "type": "commit"}, {"oid": "fbc12562ba537b2c27edf50da18d525a07287b68", "url": "https://github.com/pmd/pmd/commit/fbc12562ba537b2c27edf50da18d525a07287b68", "message": "Extract changes to ast", "committedDate": "2020-11-13T13:35:18Z", "type": "commit"}, {"oid": "715c8facf133acf56c536882672026479ec9cc4d", "url": "https://github.com/pmd/pmd/commit/715c8facf133acf56c536882672026479ec9cc4d", "message": "Extract changes to core", "committedDate": "2020-11-13T13:37:38Z", "type": "commit"}, {"oid": "f287f56d62ce1f041748afa422b2afa443a95c49", "url": "https://github.com/pmd/pmd/commit/f287f56d62ce1f041748afa422b2afa443a95c49", "message": "Add location information", "committedDate": "2020-11-13T13:41:55Z", "type": "commit"}, {"oid": "67d3b8a4f4b1587326209721312379ab43ee10e1", "url": "https://github.com/pmd/pmd/commit/67d3b8a4f4b1587326209721312379ab43ee10e1", "message": "Extract changes to lang-test", "committedDate": "2020-11-13T13:43:02Z", "type": "commit"}, {"oid": "2b10c79caa19f3f7cfbb4bd3e64e1a5af4b9c68f", "url": "https://github.com/pmd/pmd/commit/2b10c79caa19f3f7cfbb4bd3e64e1a5af4b9c68f", "message": "Fix documentation", "committedDate": "2020-11-13T14:15:44Z", "type": "commit"}, {"oid": "7635a19ea4f53b99992a3851375eacf9def437f3", "url": "https://github.com/pmd/pmd/commit/7635a19ea4f53b99992a3851375eacf9def437f3", "message": "Fix exception not thrown", "committedDate": "2020-11-13T15:22:43Z", "type": "commit"}, {"oid": "bc15bb96c521b5d4efb273dd01c5f98e3fb58f95", "url": "https://github.com/pmd/pmd/commit/bc15bb96c521b5d4efb273dd01c5f98e3fb58f95", "message": "Merge branch '7.0.x' into java-new-xpath-functions", "committedDate": "2020-11-15T15:10:30Z", "type": "commit"}, {"oid": "3651e66c126c801283dbcb3722a11483fbc7ce5c", "url": "https://github.com/pmd/pmd/commit/3651e66c126c801283dbcb3722a11483fbc7ce5c", "message": "Merge branch 'pmd/7.0.x' into pr-2917", "committedDate": "2020-11-24T08:11:08Z", "type": "commit"}, {"oid": "f8ed1495c25535713529aa7e4b2c79fc465ae854", "url": "https://github.com/pmd/pmd/commit/f8ed1495c25535713529aa7e4b2c79fc465ae854", "message": "Merge branch '7.0.x' into java-new-xpath-functions", "committedDate": "2020-11-25T11:03:11Z", "type": "commit"}, {"oid": "9d518790881cfb376df778db9cbf948f4cf33e67", "url": "https://github.com/pmd/pmd/commit/9d518790881cfb376df778db9cbf948f4cf33e67", "message": "Small fixes (since=7.0.0, unused ExpectedExeption)", "committedDate": "2020-11-25T14:58:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI4OTU3OQ==", "url": "https://github.com/pmd/pmd/pull/2917#discussion_r529289579", "bodyText": "It might be better, to have the class InvocationMatcher in a separate file instead in TypeTestUtil.... something we can consider later, though. It's new API, so we can still move it around.", "author": "adangel", "createdAt": "2020-11-24T08:32:06Z", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeTestUtil.java", "diffHunk": "@@ -184,53 +218,309 @@ private static boolean isExactlyA(@NonNull Class<?> klass, @Nullable JTypeDeclSy\n         return symClass.getBinaryName().equals(klass.getName());\n     }\n \n+    /**\n+     * Returns true if the signature is that of a method declared in the\n+     * given class.\n+     *\n+     * @param klass Class\n+     * @param sig   Method signature to test\n+     *\n+     * @throws NullPointerException If any argument is null\n+     */\n+    public static boolean isDeclaredInClass(@NonNull Class<?> klass, @NonNull JMethodSig sig) {\n+        return isExactlyA(klass, sig.getDeclaringType().getSymbol());\n+    }\n+\n \n     /**\n      * Checks whether the static type of the node is exactly the type\n-     * given by the name. This ignores strict supertypes, and type arguments\n-     * if the type of the node is parameterized.\n-     *\n-     * <pre>{@code\n-     * isExactlyA(List.class, <new ArrayList<String>()>)      = false\n-     * isExactlyA(ArrayList.class, <new ArrayList<String>()>) = true\n-     * isExactlyA(int[].class, <new int[0]>)                  = true\n-     * isExactlyA(Object[].class, <new String[0]>)            = false\n-     * isExactlyA(_, null) = false\n-     * isExactlyA(null, _) = NullPointerException\n-     * }</pre>\n+     * given by the name. See {@link #isExactlyA(Class, TypeNode)} for\n+     * examples and more info.\n      *\n      * @param canonicalName a canonical name of a class or array type\n      * @param node          the type node to check\n      *\n      * @return true if the node is non-null and has the given type\n      *\n-     * @throws NullPointerException if the class name parameter is null\n+     * @throws NullPointerException     if the class name parameter is null\n+     * @throws IllegalArgumentException if the class name parameter is not a valid java binary name,\n+     *                                  eg it has type arguments\n+     * @see #isExactlyA(Class, TypeNode)\n      */\n     public static boolean isExactlyA(@NonNull String canonicalName, final @Nullable TypeNode node) {\n-        AssertionUtil.requireParamNotNull(\"canonicalName\", canonicalName);\n         if (node == null) {\n             return false;\n         }\n+        return isExactlyAOrAnon(canonicalName, node.getTypeMirror()) == OptionalBool.YES;\n+    }\n+\n+    private static OptionalBool isExactlyAOrAnon(@NonNull String canonicalName, final @NonNull JTypeMirror node) {\n+        AssertionUtil.requireParamNotNull(\"canonicalName\", canonicalName);\n \n-        JTypeDeclSymbol sym = node.getTypeMirror().getSymbol();\n+        JTypeDeclSymbol sym = node.getSymbol();\n         if (sym == null || sym instanceof JTypeParameterSymbol) {\n-            return false;\n+            return OptionalBool.NO;\n         }\n \n         canonicalName = StringUtils.deleteWhitespace(canonicalName);\n \n         JClassSymbol klass = (JClassSymbol) sym;\n         String canonical = klass.getCanonicalName();\n-        return canonical != null && canonical.equals(canonicalName);\n+        if (canonical == null) {\n+            return OptionalBool.UNKNOWN; // anonymous\n+        }\n+        return OptionalBool.definitely(canonical.equals(canonicalName));\n     }\n \n \n-\n     private static boolean hasNoSubtypes(Class<?> clazz) {\n         // Neither final nor an annotation. Enums & records have ACC_FINAL\n         // Note: arrays have ACC_FINAL, but have subtypes by covariance\n         // Note: annotations may be implemented by classes\n-        return Modifier.isFinal(clazz.getModifiers()) && !clazz.isArray();\n+        return Modifier.isFinal(clazz.getModifiers()) && !clazz.isArray() || clazz.isPrimitive();\n+    }\n+\n+\n+    /**\n+     * Matches a method or constructor call against a particular overload.\n+     * Use {@link #parse(String)} to create one. For example,\n+     *\n+     * <pre>\n+     *     java.lang.String#toString()   // match calls to toString on String instances\n+     *     _#toString()                  // match calls to toString on any receiver\n+     *     _#_()                         // match all calls to a method with no parameters\n+     *     _#toString(_*)                // match calls to a \"toString\" method with any number of parameters\n+     *     _#eq(_, _)                    // match calls to an \"eq\" method that has 2 parameters of unspecified type\n+     *     _#eq(java.lang.String, _)     // like the previous, but the first parameter must be String\n+     *     java.util.ArrayList#new(int)  // match constructor calls of this overload of the ArrayList constructor\n+     * </pre>\n+     *\n+     * <p>The receiver matcher (first half) is matched against the\n+     * static type of the <i>receiver</i> of the call, and not the\n+     * declaration site of the method, unless the called method is\n+     * static, or a constructor.\n+     *\n+     * <p>The parameters are matched against the declared parameters\n+     * types of the called overload, and not the actual argument types.\n+     * In particular, for vararg methods, the signature should mention\n+     * a single parameter, with an array type.\n+     *\n+     * <p>For example {@code Integer.valueOf('0')} will be matched by\n+     * {@code _#valueOf(int)} but not {@code _#valueOf(char)}, which is\n+     * an overload that does not exist (the char is widened to an int,\n+     * so the int overload is selected).\n+     *\n+     * <h5 id='ebnf'>Full EBNF grammar</h5>\n+     *\n+     * <p>(no whitespace is tolerated anywhere):\n+     * <pre>{@code\n+     * sig         ::= type '#' method_name param_list\n+     * type        ::= qname ( '[]' )* | '_'\n+     * method_name ::= '_' | ident | 'new'\n+     * param_list  ::= '(_*)' | '(' type (',' type )* ')'\n+     * qname       ::= java binary name\n+     * }</pre>\n+     */\n+    public static final class InvocationMatcher {", "originalCommit": "3651e66c126c801283dbcb3722a11483fbc7ce5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI5MjQxNQ==", "url": "https://github.com/pmd/pmd/pull/2917#discussion_r529292415", "bodyText": "This provides the \"nodeIs\" function for java. The issue #1787 describes this actually as a general, core function, available for all languages. I think, it would be not too hard to port this class + BaseRewrittenFunction to core. But IMHO we should wait with that for later.\nTherefore I'll keep #1787 open, as it is only fixed for java.", "author": "adangel", "createdAt": "2020-11-24T08:36:48Z", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/xpath/internal/NodeIsFunction.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.java.rule.xpath.internal;\n+\n+import net.sourceforge.pmd.lang.java.ast.JavaNode;\n+\n+import net.sf.saxon.trans.XPathException;\n+\n+public final class NodeIsFunction extends BaseRewrittenFunction<Class<?>, JavaNode> {\n+\n+    public static final NodeIsFunction INSTANCE = new NodeIsFunction();\n+\n+    private NodeIsFunction() {\n+        super(\"nodeIs\", JavaNode.class);\n+    }\n+\n+    @Override\n+    protected Class<?> parseArgument(String constantArg) throws XPathException {\n+        try {\n+            return Class.forName(\"net.sourceforge.pmd.lang.java.ast.AST\" + constantArg);", "originalCommit": "3651e66c126c801283dbcb3722a11483fbc7ce5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI5Njk5NQ==", "url": "https://github.com/pmd/pmd/pull/2917#discussion_r529296995", "bodyText": "7.0.0 \ud83d\ude04", "author": "adangel", "createdAt": "2020-11-24T08:43:56Z", "path": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/rule/xpath/internal/BaseXPathFunctionTest.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.java.rule.xpath.internal;\n+\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+import java.util.function.Consumer;\n+\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.junit.Assert;\n+\n+import net.sourceforge.pmd.Report;\n+import net.sourceforge.pmd.Rule;\n+import net.sourceforge.pmd.lang.LanguageRegistry;\n+import net.sourceforge.pmd.lang.ast.test.TestUtilsKt;\n+import net.sourceforge.pmd.lang.java.JavaLanguageModule;\n+import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;\n+import net.sourceforge.pmd.lang.rule.XPathRule;\n+import net.sourceforge.pmd.lang.rule.xpath.PmdXPathException;\n+import net.sourceforge.pmd.lang.rule.xpath.XPathVersion;\n+\n+/**\n+ * @author Cl\u00e9ment Fournier\n+ * @since 6.0.0", "originalCommit": "3651e66c126c801283dbcb3722a11483fbc7ce5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI5OTQwNA==", "url": "https://github.com/pmd/pmd/pull/2917#discussion_r529299404", "bodyText": "Is this still needed, since you use already assertThrows?", "author": "adangel", "createdAt": "2020-11-24T08:47:38Z", "path": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/types/InvocationMatcherTest.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.java.types;\n+\n+import static net.sourceforge.pmd.lang.java.types.TypeTestUtil.InvocationMatcher.parse;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;\n+import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;\n+import net.sourceforge.pmd.lang.java.ast.InvocationNode;\n+import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;\n+\n+public class InvocationMatcherTest extends BaseNonParserTest {\n+\n+    @Rule\n+    public final ExpectedException expect = ExpectedException.none();", "originalCommit": "3651e66c126c801283dbcb3722a11483fbc7ce5c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}