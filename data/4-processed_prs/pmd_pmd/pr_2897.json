{"pr_number": 2897, "pr_title": "[java] Update UnnecessaryFullyQualifiedName", "pr_createdAt": "2020-11-02T19:41:26Z", "pr_url": "https://github.com/pmd/pmd/pull/2897", "timeline": [{"oid": "f5c3c152eb66b34b62f7ed5f41ff7267ab25efcc", "url": "https://github.com/pmd/pmd/commit/f5c3c152eb66b34b62f7ed5f41ff7267ab25efcc", "message": "Reimplement UnnecessaryFullyQualifiedName\n\nFix tests\n\nDoesn't work yet for static method calls:\nresolution of methods needs type resolution.\nAlso fails with same package if classloader\nis not set", "committedDate": "2020-11-02T17:38:15Z", "type": "commit"}, {"oid": "e19dba1377266387909f8c0f960ca32052631048", "url": "https://github.com/pmd/pmd/commit/e19dba1377266387909f8c0f960ca32052631048", "message": "Simplify", "committedDate": "2020-11-02T18:01:54Z", "type": "commit"}, {"oid": "b6616795f5dc6ced1c8576e9507cebc84ea2171b", "url": "https://github.com/pmd/pmd/commit/b6616795f5dc6ced1c8576e9507cebc84ea2171b", "message": "Support methods", "committedDate": "2020-11-02T18:39:55Z", "type": "commit"}, {"oid": "6ae64dbb540e0a3400603deaf4467ae434c2192f", "url": "https://github.com/pmd/pmd/commit/6ae64dbb540e0a3400603deaf4467ae434c2192f", "message": "Add test", "committedDate": "2020-11-02T18:42:54Z", "type": "commit"}, {"oid": "c3d1ca4db0bff140a91c3493c8aab6b74ed77188", "url": "https://github.com/pmd/pmd/commit/c3d1ca4db0bff140a91c3493c8aab6b74ed77188", "message": "Fix PMD warning", "committedDate": "2020-11-02T19:52:14Z", "type": "commit"}, {"oid": "d3353191f0018fdc6d6124c29f014f04f7cc415b", "url": "https://github.com/pmd/pmd/commit/d3353191f0018fdc6d6124c29f014f04f7cc415b", "message": "Add test cases", "committedDate": "2020-11-02T21:07:40Z", "type": "commit"}, {"oid": "720678eac9ea1225f05de7a6097fca0b47659194", "url": "https://github.com/pmd/pmd/commit/720678eac9ea1225f05de7a6097fca0b47659194", "message": "Handle type obscuring\n\nFix #1790", "committedDate": "2020-11-02T21:11:11Z", "type": "commit"}, {"oid": "7acbcc869417439a879e2d2e0f4a980bfa14fde5", "url": "https://github.com/pmd/pmd/commit/7acbcc869417439a879e2d2e0f4a980bfa14fde5", "message": "Ensure #2299 is fixed\n\nfix #2299", "committedDate": "2020-11-02T21:12:58Z", "type": "commit"}, {"oid": "d66516b2d3a540bce0fce1530e8ae47bf08b5848", "url": "https://github.com/pmd/pmd/commit/d66516b2d3a540bce0fce1530e8ae47bf08b5848", "message": "Add more test cases", "committedDate": "2020-11-02T21:20:20Z", "type": "commit"}, {"oid": "9a2fe42af4f0677e79d2320d315f82219bd6e18c", "url": "https://github.com/pmd/pmd/commit/9a2fe42af4f0677e79d2320d315f82219bd6e18c", "message": "Fix fp with method type arguments", "committedDate": "2020-11-02T21:22:29Z", "type": "commit"}, {"oid": "33bc87f8310bb3797d12de3ad506de9b96b69f40", "url": "https://github.com/pmd/pmd/commit/33bc87f8310bb3797d12de3ad506de9b96b69f40", "message": "Add todo test case", "committedDate": "2020-11-02T22:01:50Z", "type": "commit"}, {"oid": "59881c9338721af99ae6b570030ceacf470a61fe", "url": "https://github.com/pmd/pmd/commit/59881c9338721af99ae6b570030ceacf470a61fe", "message": "Add properties to control behavior", "committedDate": "2020-11-03T06:06:06Z", "type": "commit"}, {"oid": "8fc9d3166bea57c8722c7fa686db12ab0c0d82b4", "url": "https://github.com/pmd/pmd/commit/8fc9d3166bea57c8722c7fa686db12ab0c0d82b4", "message": "Fix problem with method imported through subtype", "committedDate": "2020-11-03T06:28:36Z", "type": "commit"}, {"oid": "7d6e7b1522e39eb4daa5e35713664e81d65b2efc", "url": "https://github.com/pmd/pmd/commit/7d6e7b1522e39eb4daa5e35713664e81d65b2efc", "message": "Support field access", "committedDate": "2020-11-03T06:49:11Z", "type": "commit"}, {"oid": "3e089c0e9bf61483f701b1910575fb48226d844b", "url": "https://github.com/pmd/pmd/commit/3e089c0e9bf61483f701b1910575fb48226d844b", "message": "Update release notes", "committedDate": "2020-11-03T06:51:50Z", "type": "commit"}, {"oid": "afa5a168eb3f3d7c341aaa8b9135ebbeb1cd6af7", "url": "https://github.com/pmd/pmd/commit/afa5a168eb3f3d7c341aaa8b9135ebbeb1cd6af7", "message": "Checkstyle", "committedDate": "2020-11-03T06:55:44Z", "type": "commit"}, {"oid": "f8a3b2a1f60f1f8c876a0529b50e5f05b93d0a7f", "url": "https://github.com/pmd/pmd/commit/f8a3b2a1f60f1f8c876a0529b50e5f05b93d0a7f", "message": "Fix concurrent modification exception", "committedDate": "2020-11-03T13:07:25Z", "type": "commit"}, {"oid": "b661abe3bda85c75a2d8e5af60f3c15b1b629534", "url": "https://github.com/pmd/pmd/commit/b661abe3bda85c75a2d8e5af60f3c15b1b629534", "message": "Checkstyle", "committedDate": "2020-11-03T13:16:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc0MDUxNg==", "url": "https://github.com/pmd/pmd/pull/2897#discussion_r518740516", "bodyText": "\ud83d\ude04", "author": "adangel", "createdAt": "2020-11-06T13:09:49Z", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryFullyQualifiedNameRule.java", "diffHunk": "@@ -4,427 +4,252 @@\n \n package net.sourceforge.pmd.lang.java.rule.codestyle;\n \n-import java.lang.reflect.Method;\n-import java.util.ArrayList;\n+import static net.sourceforge.pmd.properties.PropertyFactory.booleanProperty;\n+\n import java.util.List;\n-import java.util.Map.Entry;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n \n-import org.apache.commons.lang3.StringUtils;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n \n-import net.sourceforge.pmd.RuleContext;\n+import net.sourceforge.pmd.internal.util.AssertionUtil;\n import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;\n-import net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;\n-import net.sourceforge.pmd.lang.java.ast.ASTName;\n-import net.sourceforge.pmd.lang.java.ast.ASTNameList;\n-import net.sourceforge.pmd.lang.java.ast.ASTPackageDeclaration;\n-import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\n-import net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\n-import net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\n+import net.sourceforge.pmd.lang.java.ast.ASTFieldAccess;\n+import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;\n+import net.sourceforge.pmd.lang.java.ast.ASTTypeExpression;\n import net.sourceforge.pmd.lang.java.ast.JavaNode;\n-import net.sourceforge.pmd.lang.java.ast.TypeNode;\n-import net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n-import net.sourceforge.pmd.lang.java.symboltable.SourceFileScope;\n-import net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration;\n-import net.sourceforge.pmd.lang.symboltable.NameOccurrence;\n-import net.sourceforge.pmd.lang.symboltable.Scope;\n-\n-public class UnnecessaryFullyQualifiedNameRule extends AbstractJavaRule {\n-    private static final Logger LOG = Logger.getLogger(UnnecessaryFullyQualifiedNameRule.class.getName());\n-\n-    private List<ASTImportDeclaration> imports = new ArrayList<>();\n-    private String currentPackage;\n+import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;\n+import net.sourceforge.pmd.lang.java.symbols.JAccessibleElementSymbol;\n+import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\n+import net.sourceforge.pmd.lang.java.symbols.JElementSymbol;\n+import net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;\n+import net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\n+import net.sourceforge.pmd.lang.java.symbols.table.JSymbolTable;\n+import net.sourceforge.pmd.lang.java.symbols.table.ScopeInfo;\n+import net.sourceforge.pmd.lang.java.symbols.table.coreimpl.ShadowChain;\n+import net.sourceforge.pmd.lang.java.symbols.table.coreimpl.ShadowChainIterator;\n+import net.sourceforge.pmd.lang.java.types.JMethodSig;\n+import net.sourceforge.pmd.properties.PropertyDescriptor;\n+\n+public class UnnecessaryFullyQualifiedNameRule extends AbstractJavaRulechainRule {\n+\n+    private static final PropertyDescriptor<Boolean> REPORT_METHODS =\n+        booleanProperty(\"reportStaticMethods\")\n+            .desc(\"Report unnecessary static method qualifiers like in `Collections.emptyList()`, if the method is imported or inherited.\")\n+            .defaultValue(true)\n+            .build();\n+\n+    private static final PropertyDescriptor<Boolean> REPORT_FIELDS =\n+        booleanProperty(\"reportStaticFields\")\n+            .desc(\"Report unnecessary static field qualifiers like in `Math.PI`, if the field is imported or inherited.\")\n+            .defaultValue(true)\n+            .build();\n \n     public UnnecessaryFullyQualifiedNameRule() {\n-        super.addRuleChainVisit(ASTPackageDeclaration.class);\n-        super.addRuleChainVisit(ASTImportDeclaration.class);\n-        super.addRuleChainVisit(ASTClassOrInterfaceType.class);\n-        super.addRuleChainVisit(ASTName.class);\n-    }\n-\n-    @Override\n-    public void start(final RuleContext ctx) {\n-        imports.clear();\n-        currentPackage = null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTPackageDeclaration node, Object data) {\n-        currentPackage = node.getPackageNameImage();\n-        return data;\n+        super(ASTClassOrInterfaceType.class);\n+        definePropertyDescriptor(REPORT_METHODS);\n+        definePropertyDescriptor(REPORT_FIELDS);\n     }\n \n     @Override\n-    public Object visit(ASTImportDeclaration node, Object data) {\n-        imports.add(node);\n-        return data;\n-    }\n-\n-    @Override\n-    public Object visit(ASTClassOrInterfaceType node, Object data) {\n-        // This name has no qualification, it can't be unnecessarily qualified\n-        if (node.getImage().indexOf('.') < 0) {\n+    public Object visit(final ASTClassOrInterfaceType deepest, Object data) {\n+        if (deepest.getQualifier() != null) {\n+            // the child will be visited instead\n             return data;\n         }\n-        checkImports(node, data);\n-        return data;\n-    }\n \n-    @Override\n-    public Object visit(ASTName node, Object data) {\n-        if (!(node.getParent() instanceof ASTImportDeclaration)\n-                && !(node.getParent() instanceof ASTPackageDeclaration)) {\n-            // This name has no qualification, it can't be unnecessarily qualified\n-            if (node.getImage().indexOf('.') < 0) {\n-                return data;\n-            }\n-            checkImports(node, data);\n+        ASTClassOrInterfaceType next = deepest;\n+        ScopeInfo bestReason = null;\n+        if (next.isFullyQualified()) {\n+            bestReason = typeMeansSame(next);\n         }\n-        return data;\n-    }\n \n-\n-    /**\n-     * Returns true if the name could be imported by this declaration.\n-     * The name must be fully qualified, the import is either on-demand\n-     * or static, that is its {@link ASTImportDeclaration#getImportedName()}\n-     * is the enclosing package or type name of the imported type or static member.\n-     */\n-    private boolean declarationMatches(ASTImportDeclaration decl, String name) {\n-        return name.startsWith(decl.getImportedName())\n-                && name.lastIndexOf('.') == decl.getImportedName().length();\n-    }\n-\n-    private boolean couldBeMethodCall(JavaNode node) {\n-        if (node.getNthParent(2) instanceof ASTPrimaryExpression && node.getNthParent(1) instanceof ASTPrimaryPrefix) {\n-            int nextSibling = node.getParent().getIndexInParent() + 1;\n-            if (node.getNthParent(2).getNumChildren() > nextSibling) {\n-                return node.getNthParent(2).getChild(nextSibling) instanceof ASTPrimarySuffix;\n+        // try to find the longest prefix that can be removed\n+        while (bestReason != null && segmentIsIrrelevant(next) && next.getParent() instanceof ASTClassOrInterfaceType) {\n+            ASTClassOrInterfaceType nextParent = (ASTClassOrInterfaceType) next.getParent();\n+            ScopeInfo newBestReason = typeMeansSame(nextParent);\n+            if (newBestReason == null) {\n+                break;\n+            } else {\n+                bestReason = newBestReason;\n+                next = nextParent;\n             }\n         }\n-        return false;\n-    }\n \n-    private void checkImports(TypeNode node, Object data) {\n-        final String name = node.getImage();\n+        // maybe a method call/field can still take precedence\n+        if (next.getParent() instanceof ASTTypeExpression) {\n \n-        // variable names shadow everything else\n-        // If the first segment is a variable, then all\n-        // the following are field accesses and it's not an FQCN\n-        if (isVariable(node.getScope(), name)) {\n-            return;\n-        }\n-\n-        List<ASTImportDeclaration> matches = new ArrayList<>();\n-\n-        // Find all \"matching\" import declarations\n-        for (ASTImportDeclaration importDeclaration : imports) {\n-            if (!importDeclaration.isImportOnDemand()) {\n-                // Exact match of imported class\n-                if (name.equals(importDeclaration.getImportedName())) {\n-                    matches.add(importDeclaration);\n-                    continue;\n+            JavaNode opa = next.getParent().getParent();", "originalCommit": "b661abe3bda85c75a2d8e5af60f3c15b1b629534", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}