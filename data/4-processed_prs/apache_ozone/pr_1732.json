{"pr_number": 1732, "pr_title": "HDDS.4387. Create a Trash File System that will be used by Trash Emptier", "pr_createdAt": "2020-12-24T04:38:43Z", "pr_url": "https://github.com/apache/ozone/pull/1732", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDczMTc4Mg==", "url": "https://github.com/apache/ozone/pull/1732#discussion_r550731782", "bodyText": "please remove wildcards", "author": "mukul1987", "createdAt": "2021-01-01T05:05:15Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/TrashOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership.  The ASF\n+ * licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.hadoop.ozone.om;\n+\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.ServiceException;\n+import org.apache.hadoop.fs.*;", "originalCommit": "8c1a9e9c040594222e4423d754ec5813559926ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5MTUyMQ==", "url": "https://github.com/apache/ozone/pull/1732#discussion_r552391521", "bodyText": "done", "author": "sadanand48", "createdAt": "2021-01-06T06:21:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDczMTc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDczMjE3Ng==", "url": "https://github.com/apache/ozone/pull/1732#discussion_r550732176", "bodyText": "In order to remove the null/empty functions, I feel we can stop import from Filesystem.java", "author": "mukul1987", "createdAt": "2021-01-01T05:10:20Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/TrashOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership.  The ASF\n+ * licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.hadoop.ozone.om;\n+\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.ServiceException;\n+import org.apache.hadoop.fs.*;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.TableIterator;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OFSPath;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyArgs;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.util.Progressable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.addTrailingSlashIfNeeded;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.pathToKey;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Type.DeleteKeys;\n+\n+/**\n+ * FileSystem to be used by the Trash Emptier.\n+ * Only the apis used by the trash emptier are implemented.\n+ */\n+public class TrashOzoneFileSystem extends FileSystem {\n+\n+  private static final RpcController NULL_RPC_CONTROLLER = null;\n+\n+  private static final int OZONE_FS_ITERATE_BATCH_SIZE = 100;\n+\n+  private OzoneManager ozoneManager;\n+\n+  private String userName;\n+\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(TrashOzoneFileSystem.class);\n+\n+  public TrashOzoneFileSystem(OzoneManager ozoneManager) throws IOException {\n+    this.ozoneManager = ozoneManager;\n+    this.userName =\n+          UserGroupInformation.getCurrentUser().getShortUserName();\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int i) throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path path,\n+      FsPermission fsPermission,\n+      boolean b, int i, short i1,\n+      long l, Progressable progressable) throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path path, int i, Progressable progressable)\n+      throws IOException {", "originalCommit": "8c1a9e9c040594222e4423d754ec5813559926ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDczMjkzMQ==", "url": "https://github.com/apache/ozone/pull/1732#discussion_r550732931", "bodyText": "Lets not use the rpc sever here and lets use the following call in\n`\n@OverRide\npublic OMResponse submitRequest(RpcController controller,\nOMRequest request) throws ServiceException {\nreturn dispatcher.processRequest(request, this::processRequest,\n    request.getCmdType(), request.getTraceID());\n\n}\n`", "author": "mukul1987", "createdAt": "2021-01-01T05:21:26Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/TrashOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership.  The ASF\n+ * licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.hadoop.ozone.om;\n+\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.ServiceException;\n+import org.apache.hadoop.fs.*;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.TableIterator;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OFSPath;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyArgs;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.util.Progressable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.addTrailingSlashIfNeeded;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.pathToKey;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Type.DeleteKeys;\n+\n+/**\n+ * FileSystem to be used by the Trash Emptier.\n+ * Only the apis used by the trash emptier are implemented.\n+ */\n+public class TrashOzoneFileSystem extends FileSystem {\n+\n+  private static final RpcController NULL_RPC_CONTROLLER = null;\n+\n+  private static final int OZONE_FS_ITERATE_BATCH_SIZE = 100;\n+\n+  private OzoneManager ozoneManager;\n+\n+  private String userName;\n+\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(TrashOzoneFileSystem.class);\n+\n+  public TrashOzoneFileSystem(OzoneManager ozoneManager) throws IOException {\n+    this.ozoneManager = ozoneManager;\n+    this.userName =\n+          UserGroupInformation.getCurrentUser().getShortUserName();\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int i) throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path path,\n+      FsPermission fsPermission,\n+      boolean b, int i, short i1,\n+      long l, Progressable progressable) throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path path, int i, Progressable progressable)\n+      throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    LOG.info(\"Src:\" + src + \"Dst:\" + dst);\n+    RenameIterator iterator = new RenameIterator(src, dst);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean delete(Path path, boolean b) throws IOException {\n+    DeleteIterator iterator = new DeleteIterator(path, true);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public FileStatus[] listStatus(Path path) throws  IOException {\n+    List<FileStatus> fileStatuses = new ArrayList<>();\n+    OFSPath ofsPath = new OFSPath(path);\n+    String volume = ofsPath.getVolumeName();\n+    String bucket = ofsPath.getBucketName();\n+    String key =  ofsPath.getKeyName();\n+    String ofsPathPrefix = \"/\" + volume + \"/\" + bucket;\n+    OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+        .setVolumeName(volume)\n+        .setBucketName(bucket)\n+        .setKeyName(key)\n+        .build();\n+    List<OzoneFileStatus> list = ozoneManager.\n+        listStatus(keyArgs, false, null, Integer.MAX_VALUE);\n+    for (OzoneFileStatus status : list) {\n+      Path temp = new Path(ofsPathPrefix +\n+          OZONE_URI_DELIMITER + status.getKeyInfo().getKeyName());\n+      FileStatus fileStatus = new FileStatus(\n+          status.getKeyInfo().getDataSize(),\n+          status.isDirectory(),\n+          status.getKeyInfo().getFactor().getNumber(),\n+          status.getBlockSize(),\n+          status.getKeyInfo().getModificationTime(),\n+          temp\n+      );\n+      fileStatuses.add(fileStatus);\n+\n+    }\n+    return fileStatuses.toArray(new FileStatus[0]);\n+  }\n+\n+  @Override\n+  public void setWorkingDirectory(Path path) {\n+\n+  }\n+\n+  @Override\n+  public Path getWorkingDirectory() {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean mkdirs(Path path,\n+      FsPermission fsPermission) throws IOException {\n+    return false;\n+  }\n+\n+\n+  @Override\n+  public FileStatus getFileStatus(Path path) throws IOException {\n+    OFSPath ofsPath = new OFSPath(path);\n+    String volume = ofsPath.getVolumeName();\n+    String bucket = ofsPath.getBucketName();\n+    String key =  ofsPath.getKeyName();\n+    OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+        .setVolumeName(volume)\n+        .setBucketName(bucket)\n+        .setKeyName(key)\n+        .build();\n+    String ofsPathPrefix = OZONE_URI_DELIMITER +\n+        volume + OZONE_URI_DELIMITER + bucket;\n+    OzoneFileStatus ofs = ozoneManager.getKeyManager().getFileStatus(keyArgs);\n+    Path temp = new Path(ofsPathPrefix +\n+        OZONE_URI_DELIMITER + ofs.getKeyInfo().getKeyName());\n+    FileStatus fileStatus = new FileStatus(ofs.getKeyInfo().getDataSize(),\n+        ofs.isDirectory(),\n+        ofs.getKeyInfo().getFactor().getNumber(),\n+        ofs.getBlockSize(),\n+        ofs.getKeyInfo().getModificationTime(),\n+        temp);\n+    return fileStatus;\n+  }\n+\n+  @Override\n+  public Collection<FileStatus> getTrashRoots(boolean allUsers) {\n+    Iterator<Map.Entry<CacheKey<String>,\n+        CacheValue<OmBucketInfo>>> bucketIterator =\n+        ozoneManager.getMetadataManager().getBucketIterator();\n+    List<FileStatus> ret = new ArrayList<>();\n+    while (bucketIterator.hasNext()){\n+      Map.Entry<CacheKey<String>, CacheValue<OmBucketInfo>> entry =\n+          bucketIterator.next();\n+      OmBucketInfo omBucketInfo = entry.getValue().getCacheValue();\n+      Path volumePath = new Path(OZONE_URI_DELIMITER,\n+          omBucketInfo.getVolumeName());\n+      Path bucketPath = new Path(volumePath, omBucketInfo.getBucketName());\n+      Path trashRoot = new Path(bucketPath, FileSystem.TRASH_PREFIX);\n+      LOG.info(trashRoot.toString());\n+      try {\n+        if (exists(trashRoot)) {\n+          FileStatus[] list = this.listStatus(trashRoot);\n+          for (FileStatus candidate : list) {\n+            if (exists(candidate.getPath()) && candidate.isDirectory()) {\n+              ret.add(candidate);\n+            }\n+          }\n+        }\n+      } catch (Exception e){\n+        LOG.error(\"Couldn't perform fs operation \" +\n+            \"fs.listStatus()/fs.exists()\" + e);\n+      }\n+    }\n+    return ret;\n+  }\n+\n+  @Override\n+  public boolean exists(Path f) throws IOException {\n+    try {\n+      this.getFileStatus(f);\n+      return true;\n+    } catch (FileNotFoundException var3) {\n+      LOG.info(\"Couldn't execute getFileStatus()\"  + var3);\n+      return false;\n+    }\n+  }\n+\n+  private abstract class OzoneListingIterator {\n+    private final Path path;\n+    private final FileStatus status;\n+    private String pathKey;\n+    private TableIterator<String, ? extends Table.KeyValue<String, OmKeyInfo>>\n+          keyIterator;\n+\n+    OzoneListingIterator(Path path)\n+          throws IOException {\n+      this.path = path;\n+      this.status = getFileStatus(path);\n+      this.pathKey = pathToKey(path);\n+      if (status.isDirectory()) {\n+        this.pathKey = addTrailingSlashIfNeeded(pathKey);\n+      }\n+      keyIterator = ozoneManager.getMetadataManager().getKeyIterator();\n+    }\n+\n+      /**\n+       * The output of processKey determines if further iteration through the\n+       * keys should be done or not.\n+       *\n+       * @return true if we should continue iteration of keys, false otherwise.\n+       * @throws IOException\n+       */\n+    abstract boolean processKeyPath(List<String> keyPathList)\n+          throws IOException;\n+\n+      /**\n+       * Iterates through all the keys prefixed with the input path's key and\n+       * processes the key though processKey().\n+       * If for any key, the processKey() returns false, then the iteration is\n+       * stopped and returned with false indicating that all the keys could not\n+       * be processed successfully.\n+       *\n+       * @return true if all keys are processed successfully, false otherwise.\n+       * @throws IOException\n+       */\n+    boolean iterate() throws IOException {\n+      LOG.trace(\"Iterating path: {}\", path);\n+      List<String> keyPathList = new ArrayList<>();\n+      //hardcoded make it read from conf\n+      if (status.isDirectory()) {\n+        LOG.trace(\"Iterating directory: {}\", pathKey);\n+        OFSPath ofsPath = new OFSPath(pathKey);\n+        String ofsPathPrefix =\n+            ofsPath.getNonKeyPathNoPrefixDelim() + OZONE_URI_DELIMITER;\n+        while (keyIterator.hasNext()) {\n+          Table.KeyValue< String, OmKeyInfo > kv = keyIterator.next();\n+          String keyPath = ofsPathPrefix + kv.getValue().getKeyName();\n+          LOG.trace(\"iterating key path: {}\", keyPath);\n+          String k = kv.getKey();\n+          if (!kv.getValue().getKeyName().equals(\"\")\n+              && kv.getKey().startsWith(\"/\" + pathKey)) {\n+            keyPathList.add(keyPath);\n+          }\n+          if (keyPathList.size() >= OZONE_FS_ITERATE_BATCH_SIZE) {\n+            if (!processKeyPath(keyPathList)) {\n+              return false;\n+            } else {\n+              keyPathList.clear();\n+            }\n+          }\n+        }\n+        if (keyPathList.size() > 0) {\n+          if (!processKeyPath(keyPathList)) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      } else {\n+        LOG.trace(\"iterating file: {}\", path);\n+        keyPathList.add(pathKey);\n+        return processKeyPath(keyPathList);\n+      }\n+    }\n+\n+    FileStatus getStatus() {\n+      return status;\n+    }\n+  }\n+\n+  private class RenameIterator extends OzoneListingIterator {\n+    private final String srcPath;\n+    private final String dstPath;\n+\n+    RenameIterator(Path srcPath, Path dstPath)\n+        throws IOException {\n+      super(srcPath);\n+      this.srcPath = pathToKey(srcPath);\n+      this.dstPath = pathToKey(dstPath);\n+      LOG.trace(\"rename from:{} to:{}\", this.srcPath, this.dstPath);\n+    }\n+\n+    @Override\n+    boolean processKeyPath(List<String> keyPathList) throws IOException {\n+      for (String keyPath : keyPathList) {\n+        String newPath = dstPath.concat(keyPath.substring(srcPath.length()));\n+        LOG.info(newPath);\n+        OFSPath src = new OFSPath(keyPath);\n+        OFSPath dst = new OFSPath(newPath);\n+\n+        String volumeName = src.getVolumeName();\n+        String bucketName = src.getBucketName();\n+        String keyName = src.getKeyName();\n+\n+        OzoneManagerProtocolProtos.KeyArgs keyArgs =\n+            OzoneManagerProtocolProtos.KeyArgs.newBuilder().setKeyName(keyName)\n+            .setVolumeName(volumeName).setBucketName(bucketName).build();\n+\n+        String toKeyName = dst.getKeyName();\n+\n+        OzoneManagerProtocolProtos.RenameKeyRequest renameKeyRequest =\n+            OzoneManagerProtocolProtos.RenameKeyRequest.newBuilder()\n+            .setKeyArgs(keyArgs).setToKeyName(toKeyName).build();\n+        OzoneManagerProtocolProtos.OMRequest omRequest =\n+            OzoneManagerProtocolProtos.OMRequest.newBuilder()\n+            .setClientId(UUID.randomUUID().toString())\n+            .setRenameKeyRequest(renameKeyRequest)\n+            .setCmdType(OzoneManagerProtocolProtos.Type.RenameKey).build();\n+        try {\n+          ozoneManager.getOmServerProtocol().", "originalCommit": "8c1a9e9c040594222e4423d754ec5813559926ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDczMjk0Ng==", "url": "https://github.com/apache/ozone/pull/1732#discussion_r550732946", "bodyText": "ozone/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/protocolPB/OzoneManagerProtocolServerSideTranslatorPB.java\n    \n    \n         Line 119\n      in\n      b0d54d4\n    \n    \n    \n    \n\n        \n          \n           public OMResponse submitRequest(RpcController controller,", "author": "mukul1987", "createdAt": "2021-01-01T05:21:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDczMjkzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDczNDk1NA==", "url": "https://github.com/apache/ozone/pull/1732#discussion_r550734954", "bodyText": "i am calling the same method here i.e\n public OMResponse submitRequest(RpcController controller, OMRequest request) throws ServiceException {. om.getOmServerProtocol() returns OzoneManagerProtocolServerSideTranslatorPB object.", "author": "sadanand48", "createdAt": "2021-01-01T05:52:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDczMjkzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDczMzIxNw==", "url": "https://github.com/apache/ozone/pull/1732#discussion_r550733217", "bodyText": "this code is similar between listStatus and getFileStatus, lets have a common function to avoid duplication of code", "author": "mukul1987", "createdAt": "2021-01-01T05:25:40Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/TrashOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership.  The ASF\n+ * licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.hadoop.ozone.om;\n+\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.ServiceException;\n+import org.apache.hadoop.fs.*;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.TableIterator;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OFSPath;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyArgs;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.util.Progressable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.addTrailingSlashIfNeeded;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.pathToKey;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Type.DeleteKeys;\n+\n+/**\n+ * FileSystem to be used by the Trash Emptier.\n+ * Only the apis used by the trash emptier are implemented.\n+ */\n+public class TrashOzoneFileSystem extends FileSystem {\n+\n+  private static final RpcController NULL_RPC_CONTROLLER = null;\n+\n+  private static final int OZONE_FS_ITERATE_BATCH_SIZE = 100;\n+\n+  private OzoneManager ozoneManager;\n+\n+  private String userName;\n+\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(TrashOzoneFileSystem.class);\n+\n+  public TrashOzoneFileSystem(OzoneManager ozoneManager) throws IOException {\n+    this.ozoneManager = ozoneManager;\n+    this.userName =\n+          UserGroupInformation.getCurrentUser().getShortUserName();\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int i) throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path path,\n+      FsPermission fsPermission,\n+      boolean b, int i, short i1,\n+      long l, Progressable progressable) throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path path, int i, Progressable progressable)\n+      throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    LOG.info(\"Src:\" + src + \"Dst:\" + dst);\n+    RenameIterator iterator = new RenameIterator(src, dst);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean delete(Path path, boolean b) throws IOException {\n+    DeleteIterator iterator = new DeleteIterator(path, true);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public FileStatus[] listStatus(Path path) throws  IOException {\n+    List<FileStatus> fileStatuses = new ArrayList<>();\n+    OFSPath ofsPath = new OFSPath(path);\n+    String volume = ofsPath.getVolumeName();\n+    String bucket = ofsPath.getBucketName();\n+    String key =  ofsPath.getKeyName();\n+    String ofsPathPrefix = \"/\" + volume + \"/\" + bucket;\n+    OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+        .setVolumeName(volume)\n+        .setBucketName(bucket)\n+        .setKeyName(key)\n+        .build();\n+    List<OzoneFileStatus> list = ozoneManager.\n+        listStatus(keyArgs, false, null, Integer.MAX_VALUE);\n+    for (OzoneFileStatus status : list) {\n+      Path temp = new Path(ofsPathPrefix +\n+          OZONE_URI_DELIMITER + status.getKeyInfo().getKeyName());\n+      FileStatus fileStatus = new FileStatus(\n+          status.getKeyInfo().getDataSize(),\n+          status.isDirectory(),\n+          status.getKeyInfo().getFactor().getNumber(),\n+          status.getBlockSize(),\n+          status.getKeyInfo().getModificationTime(),\n+          temp\n+      );\n+      fileStatuses.add(fileStatus);\n+\n+    }\n+    return fileStatuses.toArray(new FileStatus[0]);\n+  }\n+\n+  @Override\n+  public void setWorkingDirectory(Path path) {\n+\n+  }\n+\n+  @Override\n+  public Path getWorkingDirectory() {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean mkdirs(Path path,\n+      FsPermission fsPermission) throws IOException {\n+    return false;\n+  }\n+\n+\n+  @Override\n+  public FileStatus getFileStatus(Path path) throws IOException {\n+    OFSPath ofsPath = new OFSPath(path);\n+    String volume = ofsPath.getVolumeName();\n+    String bucket = ofsPath.getBucketName();\n+    String key =  ofsPath.getKeyName();\n+    OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+        .setVolumeName(volume)\n+        .setBucketName(bucket)\n+        .setKeyName(key)\n+        .build();\n+    String ofsPathPrefix = OZONE_URI_DELIMITER +\n+        volume + OZONE_URI_DELIMITER + bucket;\n+    OzoneFileStatus ofs = ozoneManager.getKeyManager().getFileStatus(keyArgs);\n+    Path temp = new Path(ofsPathPrefix +\n+        OZONE_URI_DELIMITER + ofs.getKeyInfo().getKeyName());", "originalCommit": "8c1a9e9c040594222e4423d754ec5813559926ff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDczMzI2Mw==", "url": "https://github.com/apache/ozone/pull/1732#discussion_r550733263", "bodyText": "debug logging, please convert to trace.", "author": "mukul1987", "createdAt": "2021-01-01T05:26:12Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/TrashOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,418 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership.  The ASF\n+ * licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.hadoop.ozone.om;\n+\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.ServiceException;\n+import org.apache.hadoop.fs.*;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.TableIterator;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OFSPath;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyArgs;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.util.Progressable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.*;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.addTrailingSlashIfNeeded;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.pathToKey;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Type.DeleteKeys;\n+\n+/**\n+ * FileSystem to be used by the Trash Emptier.\n+ * Only the apis used by the trash emptier are implemented.\n+ */\n+public class TrashOzoneFileSystem extends FileSystem {\n+\n+  private static final RpcController NULL_RPC_CONTROLLER = null;\n+\n+  private static final int OZONE_FS_ITERATE_BATCH_SIZE = 100;\n+\n+  private OzoneManager ozoneManager;\n+\n+  private String userName;\n+\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(TrashOzoneFileSystem.class);\n+\n+  public TrashOzoneFileSystem(OzoneManager ozoneManager) throws IOException {\n+    this.ozoneManager = ozoneManager;\n+    this.userName =\n+          UserGroupInformation.getCurrentUser().getShortUserName();\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int i) throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path path,\n+      FsPermission fsPermission,\n+      boolean b, int i, short i1,\n+      long l, Progressable progressable) throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path path, int i, Progressable progressable)\n+      throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    LOG.info(\"Src:\" + src + \"Dst:\" + dst);\n+    RenameIterator iterator = new RenameIterator(src, dst);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean delete(Path path, boolean b) throws IOException {\n+    DeleteIterator iterator = new DeleteIterator(path, true);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public FileStatus[] listStatus(Path path) throws  IOException {\n+    List<FileStatus> fileStatuses = new ArrayList<>();\n+    OFSPath ofsPath = new OFSPath(path);\n+    String volume = ofsPath.getVolumeName();\n+    String bucket = ofsPath.getBucketName();\n+    String key =  ofsPath.getKeyName();\n+    String ofsPathPrefix = \"/\" + volume + \"/\" + bucket;\n+    OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+        .setVolumeName(volume)\n+        .setBucketName(bucket)\n+        .setKeyName(key)\n+        .build();\n+    List<OzoneFileStatus> list = ozoneManager.\n+        listStatus(keyArgs, false, null, Integer.MAX_VALUE);\n+    for (OzoneFileStatus status : list) {\n+      Path temp = new Path(ofsPathPrefix +\n+          OZONE_URI_DELIMITER + status.getKeyInfo().getKeyName());\n+      FileStatus fileStatus = new FileStatus(\n+          status.getKeyInfo().getDataSize(),\n+          status.isDirectory(),\n+          status.getKeyInfo().getFactor().getNumber(),\n+          status.getBlockSize(),\n+          status.getKeyInfo().getModificationTime(),\n+          temp\n+      );\n+      fileStatuses.add(fileStatus);\n+\n+    }\n+    return fileStatuses.toArray(new FileStatus[0]);\n+  }\n+\n+  @Override\n+  public void setWorkingDirectory(Path path) {\n+\n+  }\n+\n+  @Override\n+  public Path getWorkingDirectory() {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean mkdirs(Path path,\n+      FsPermission fsPermission) throws IOException {\n+    return false;\n+  }\n+\n+\n+  @Override\n+  public FileStatus getFileStatus(Path path) throws IOException {\n+    OFSPath ofsPath = new OFSPath(path);\n+    String volume = ofsPath.getVolumeName();\n+    String bucket = ofsPath.getBucketName();\n+    String key =  ofsPath.getKeyName();\n+    OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+        .setVolumeName(volume)\n+        .setBucketName(bucket)\n+        .setKeyName(key)\n+        .build();\n+    String ofsPathPrefix = OZONE_URI_DELIMITER +\n+        volume + OZONE_URI_DELIMITER + bucket;\n+    OzoneFileStatus ofs = ozoneManager.getKeyManager().getFileStatus(keyArgs);\n+    Path temp = new Path(ofsPathPrefix +\n+        OZONE_URI_DELIMITER + ofs.getKeyInfo().getKeyName());\n+    FileStatus fileStatus = new FileStatus(ofs.getKeyInfo().getDataSize(),\n+        ofs.isDirectory(),\n+        ofs.getKeyInfo().getFactor().getNumber(),\n+        ofs.getBlockSize(),\n+        ofs.getKeyInfo().getModificationTime(),\n+        temp);\n+    return fileStatus;\n+  }\n+\n+  @Override\n+  public Collection<FileStatus> getTrashRoots(boolean allUsers) {\n+    Iterator<Map.Entry<CacheKey<String>,\n+        CacheValue<OmBucketInfo>>> bucketIterator =\n+        ozoneManager.getMetadataManager().getBucketIterator();\n+    List<FileStatus> ret = new ArrayList<>();\n+    while (bucketIterator.hasNext()){\n+      Map.Entry<CacheKey<String>, CacheValue<OmBucketInfo>> entry =\n+          bucketIterator.next();\n+      OmBucketInfo omBucketInfo = entry.getValue().getCacheValue();\n+      Path volumePath = new Path(OZONE_URI_DELIMITER,\n+          omBucketInfo.getVolumeName());\n+      Path bucketPath = new Path(volumePath, omBucketInfo.getBucketName());\n+      Path trashRoot = new Path(bucketPath, FileSystem.TRASH_PREFIX);\n+      LOG.info(trashRoot.toString());", "originalCommit": "8c1a9e9c040594222e4423d754ec5813559926ff", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5MTU3Mg==", "url": "https://github.com/apache/ozone/pull/1732#discussion_r552391572", "bodyText": "done", "author": "sadanand48", "createdAt": "2021-01-06T06:22:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDczMzI2Mw=="}], "type": "inlineReview"}, {"oid": "5f1b9fa05944f416bbf4d68fb2e9fbfa986a184e", "url": "https://github.com/apache/ozone/commit/5f1b9fa05944f416bbf4d68fb2e9fbfa986a184e", "message": "Create a Trash File System that will be used by Trash Emptier", "committedDate": "2021-01-05T08:40:31Z", "type": "commit"}, {"oid": "b1bb9fc4997a29fbc49c2cf24e5dcca2791ec8f3", "url": "https://github.com/apache/ozone/commit/b1bb9fc4997a29fbc49c2cf24e5dcca2791ec8f3", "message": "fix checks", "committedDate": "2021-01-05T08:40:31Z", "type": "commit"}, {"oid": "1a185bd6aa97591c439486cfe1a6c78984f067fc", "url": "https://github.com/apache/ozone/commit/1a185bd6aa97591c439486cfe1a6c78984f067fc", "message": "address comments", "committedDate": "2021-01-05T08:40:31Z", "type": "commit"}, {"oid": "c348d7c8c377fa3e0f6fe88cb5a42afac8d0071e", "url": "https://github.com/apache/ozone/commit/c348d7c8c377fa3e0f6fe88cb5a42afac8d0071e", "message": "trigger new CI check", "committedDate": "2021-01-05T08:41:15Z", "type": "commit"}, {"oid": "c348d7c8c377fa3e0f6fe88cb5a42afac8d0071e", "url": "https://github.com/apache/ozone/commit/c348d7c8c377fa3e0f6fe88cb5a42afac8d0071e", "message": "trigger new CI check", "committedDate": "2021-01-05T08:41:15Z", "type": "forcePushed"}, {"oid": "05593741a55cff6fd82f74fc0d8989b377070ed9", "url": "https://github.com/apache/ozone/commit/05593741a55cff6fd82f74fc0d8989b377070ed9", "message": "fix checkstyle", "committedDate": "2021-01-05T08:51:27Z", "type": "commit"}, {"oid": "8b62859ba191191fdd611a02c6a7d55c331c7582", "url": "https://github.com/apache/ozone/commit/8b62859ba191191fdd611a02c6a7d55c331c7582", "message": "add test", "committedDate": "2021-01-05T14:21:47Z", "type": "commit"}, {"oid": "b9e9d1b489953ef3a8a59b520e50fbcf40f5954f", "url": "https://github.com/apache/ozone/commit/b9e9d1b489953ef3a8a59b520e50fbcf40f5954f", "message": "trigger new CI check", "committedDate": "2021-01-05T17:02:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NzYwNg==", "url": "https://github.com/apache/ozone/pull/1732#discussion_r552047606", "bodyText": "Lets also add that ${result} also has Trash in the name ?", "author": "mukul1987", "createdAt": "2021-01-05T16:34:06Z", "path": "hadoop-ozone/dist/src/main/smoketest/ozonefs/ozonefs.robot", "diffHunk": "@@ -92,10 +92,16 @@ Touch file\n     ${result} =    Execute               ozone sh key list ${VOLUME}/${BUCKET} | jq -r '.name'\n                    Should contain        ${result}       TOUCHFILE-${SCHEME}.txt\n \n+Delete file with Trash\n+                   Execute               ozone fs -touch ${DEEP_URL}/testFile.txt\n+    ${result} =    Execute               ozone fs -rm ${DEEP_URL}/testFile.txt\n+                   Should contain        ${result}     testFile.txt", "originalCommit": "8b62859ba191191fdd611a02c6a7d55c331c7582", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NzgxMA==", "url": "https://github.com/apache/ozone/pull/1732#discussion_r552047810", "bodyText": "Also lets check if the file is actually present in the path", "author": "mukul1987", "createdAt": "2021-01-05T16:34:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NzYwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5MjIxOQ==", "url": "https://github.com/apache/ozone/pull/1732#discussion_r552392219", "bodyText": "done.", "author": "sadanand48", "createdAt": "2021-01-06T06:24:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0NzYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0ODg4MA==", "url": "https://github.com/apache/ozone/pull/1732#discussion_r552048880", "bodyText": "Lets also add a function to convert OzoneFileStatus to FileStatus ?", "author": "mukul1987", "createdAt": "2021-01-05T16:36:04Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/TrashOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership.  The ASF\n+ * licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.hadoop.ozone.om;\n+\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.ServiceException;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.TableIterator;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OFSPath;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyArgs;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.util.Progressable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Iterator;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.addTrailingSlashIfNeeded;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.pathToKey;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Type.DeleteKeys;\n+\n+/**\n+ * FileSystem to be used by the Trash Emptier.\n+ * Only the apis used by the trash emptier are implemented.\n+ */\n+public class TrashOzoneFileSystem extends FileSystem {\n+\n+  private static final RpcController NULL_RPC_CONTROLLER = null;\n+\n+  private static final int OZONE_FS_ITERATE_BATCH_SIZE = 100;\n+\n+  private OzoneManager ozoneManager;\n+\n+  private String userName;\n+\n+  private String ofsPathPrefix;\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(TrashOzoneFileSystem.class);\n+\n+  public TrashOzoneFileSystem(OzoneManager ozoneManager) throws IOException {\n+    this.ozoneManager = ozoneManager;\n+    this.userName =\n+          UserGroupInformation.getCurrentUser().getShortUserName();\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int i) {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path path,\n+      FsPermission fsPermission,\n+      boolean b, int i, short i1,\n+      long l, Progressable progressable){\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path path, int i,\n+      Progressable progressable) {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    LOG.trace(\"Src:\" + src + \"Dst:\" + dst);\n+    RenameIterator iterator = new RenameIterator(src, dst);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean delete(Path path, boolean b) throws IOException {\n+    DeleteIterator iterator = new DeleteIterator(path, true);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public FileStatus[] listStatus(Path path) throws  IOException {\n+    List<FileStatus> fileStatuses = new ArrayList<>();\n+    OmKeyArgs keyArgs = constructOmKeyArgs(path);\n+    List<OzoneFileStatus> list = ozoneManager.\n+        listStatus(keyArgs, false, null, Integer.MAX_VALUE);\n+    for (OzoneFileStatus status : list) {\n+      Path temp = new Path(ofsPathPrefix +\n+          OZONE_URI_DELIMITER + status.getKeyInfo().getKeyName());\n+      FileStatus fileStatus = new FileStatus(", "originalCommit": "8b62859ba191191fdd611a02c6a7d55c331c7582", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5MTYxNg==", "url": "https://github.com/apache/ozone/pull/1732#discussion_r552391616", "bodyText": "done", "author": "sadanand48", "createdAt": "2021-01-06T06:22:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA0ODg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2Nzk0Mg==", "url": "https://github.com/apache/ozone/pull/1732#discussion_r552067942", "bodyText": "why are we deleting only the first entry ? and ignoring the rest of the entries here ?", "author": "mukul1987", "createdAt": "2021-01-05T17:06:54Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/TrashOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership.  The ASF\n+ * licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.hadoop.ozone.om;\n+\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.ServiceException;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.TableIterator;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OFSPath;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyArgs;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.util.Progressable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Iterator;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.addTrailingSlashIfNeeded;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.pathToKey;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Type.DeleteKeys;\n+\n+/**\n+ * FileSystem to be used by the Trash Emptier.\n+ * Only the apis used by the trash emptier are implemented.\n+ */\n+public class TrashOzoneFileSystem extends FileSystem {\n+\n+  private static final RpcController NULL_RPC_CONTROLLER = null;\n+\n+  private static final int OZONE_FS_ITERATE_BATCH_SIZE = 100;\n+\n+  private OzoneManager ozoneManager;\n+\n+  private String userName;\n+\n+  private String ofsPathPrefix;\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(TrashOzoneFileSystem.class);\n+\n+  public TrashOzoneFileSystem(OzoneManager ozoneManager) throws IOException {\n+    this.ozoneManager = ozoneManager;\n+    this.userName =\n+          UserGroupInformation.getCurrentUser().getShortUserName();\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int i) {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path path,\n+      FsPermission fsPermission,\n+      boolean b, int i, short i1,\n+      long l, Progressable progressable){\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path path, int i,\n+      Progressable progressable) {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    LOG.trace(\"Src:\" + src + \"Dst:\" + dst);\n+    RenameIterator iterator = new RenameIterator(src, dst);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean delete(Path path, boolean b) throws IOException {\n+    DeleteIterator iterator = new DeleteIterator(path, true);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public FileStatus[] listStatus(Path path) throws  IOException {\n+    List<FileStatus> fileStatuses = new ArrayList<>();\n+    OmKeyArgs keyArgs = constructOmKeyArgs(path);\n+    List<OzoneFileStatus> list = ozoneManager.\n+        listStatus(keyArgs, false, null, Integer.MAX_VALUE);\n+    for (OzoneFileStatus status : list) {\n+      Path temp = new Path(ofsPathPrefix +\n+          OZONE_URI_DELIMITER + status.getKeyInfo().getKeyName());\n+      FileStatus fileStatus = new FileStatus(\n+          status.getKeyInfo().getDataSize(),\n+          status.isDirectory(),\n+          status.getKeyInfo().getFactor().getNumber(),\n+          status.getBlockSize(),\n+          status.getKeyInfo().getModificationTime(),\n+          temp\n+      );\n+      fileStatuses.add(fileStatus);\n+\n+    }\n+    return fileStatuses.toArray(new FileStatus[0]);\n+  }\n+\n+  @Override\n+  public void setWorkingDirectory(Path path) {\n+\n+  }\n+\n+  @Override\n+  public Path getWorkingDirectory() {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean mkdirs(Path path,\n+      FsPermission fsPermission) {\n+    return false;\n+  }\n+\n+\n+  @Override\n+  public FileStatus getFileStatus(Path path) throws IOException {\n+    OmKeyArgs keyArgs = constructOmKeyArgs(path);\n+    OzoneFileStatus ofs = ozoneManager.getKeyManager().getFileStatus(keyArgs);\n+    Path temp = new Path(ofsPathPrefix +\n+        OZONE_URI_DELIMITER + ofs.getKeyInfo().getKeyName());\n+    FileStatus fileStatus = new FileStatus(ofs.getKeyInfo().getDataSize(),\n+        ofs.isDirectory(),\n+        ofs.getKeyInfo().getFactor().getNumber(),\n+        ofs.getBlockSize(),\n+        ofs.getKeyInfo().getModificationTime(),\n+        temp);\n+    return fileStatus;\n+  }\n+\n+  private OmKeyArgs constructOmKeyArgs(Path path) {\n+    OFSPath ofsPath = new OFSPath(path);\n+    String volume = ofsPath.getVolumeName();\n+    String bucket = ofsPath.getBucketName();\n+    String key = ofsPath.getKeyName();\n+    OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+        .setVolumeName(volume)\n+        .setBucketName(bucket)\n+        .setKeyName(key)\n+        .build();\n+    this.ofsPathPrefix = OZONE_URI_DELIMITER +\n+        volume + OZONE_URI_DELIMITER + bucket;\n+    return keyArgs;\n+  }\n+\n+  @Override\n+  public Collection<FileStatus> getTrashRoots(boolean allUsers) {\n+    Iterator<Map.Entry<CacheKey<String>,\n+        CacheValue<OmBucketInfo>>> bucketIterator =\n+        ozoneManager.getMetadataManager().getBucketIterator();\n+    List<FileStatus> ret = new ArrayList<>();\n+    while (bucketIterator.hasNext()){\n+      Map.Entry<CacheKey<String>, CacheValue<OmBucketInfo>> entry =\n+          bucketIterator.next();\n+      OmBucketInfo omBucketInfo = entry.getValue().getCacheValue();\n+      Path volumePath = new Path(OZONE_URI_DELIMITER,\n+          omBucketInfo.getVolumeName());\n+      Path bucketPath = new Path(volumePath, omBucketInfo.getBucketName());\n+      Path trashRoot = new Path(bucketPath, FileSystem.TRASH_PREFIX);\n+      try {\n+        if (exists(trashRoot)) {\n+          FileStatus[] list = this.listStatus(trashRoot);\n+          for (FileStatus candidate : list) {\n+            if (exists(candidate.getPath()) && candidate.isDirectory()) {\n+              ret.add(candidate);\n+            }\n+          }\n+        }\n+      } catch (Exception e){\n+        LOG.error(\"Couldn't perform fs operation \" +\n+            \"fs.listStatus()/fs.exists()\" + e);\n+      }\n+    }\n+    return ret;\n+  }\n+\n+  @Override\n+  public boolean exists(Path f) throws IOException {\n+    try {\n+      this.getFileStatus(f);\n+      return true;\n+    } catch (FileNotFoundException var3) {\n+      LOG.info(\"Couldn't execute getFileStatus()\"  + var3);\n+      return false;\n+    }\n+  }\n+\n+  private abstract class OzoneListingIterator {\n+    private final Path path;\n+    private final FileStatus status;\n+    private String pathKey;\n+    private TableIterator<String, ? extends Table.KeyValue<String, OmKeyInfo>>\n+          keyIterator;\n+\n+    OzoneListingIterator(Path path)\n+          throws IOException {\n+      this.path = path;\n+      this.status = getFileStatus(path);\n+      this.pathKey = pathToKey(path);\n+      if (status.isDirectory()) {\n+        this.pathKey = addTrailingSlashIfNeeded(pathKey);\n+      }\n+      keyIterator = ozoneManager.getMetadataManager().getKeyIterator();\n+    }\n+\n+      /**\n+       * The output of processKey determines if further iteration through the\n+       * keys should be done or not.\n+       *\n+       * @return true if we should continue iteration of keys, false otherwise.\n+       * @throws IOException\n+       */\n+    abstract boolean processKeyPath(List<String> keyPathList)\n+          throws IOException;\n+\n+      /**\n+       * Iterates through all the keys prefixed with the input path's key and\n+       * processes the key though processKey().\n+       * If for any key, the processKey() returns false, then the iteration is\n+       * stopped and returned with false indicating that all the keys could not\n+       * be processed successfully.\n+       *\n+       * @return true if all keys are processed successfully, false otherwise.\n+       * @throws IOException\n+       */\n+    boolean iterate() throws IOException {\n+      LOG.trace(\"Iterating path: {}\", path);\n+      List<String> keyPathList = new ArrayList<>();\n+      //hardcoded make it read from conf\n+      if (status.isDirectory()) {\n+        LOG.trace(\"Iterating directory: {}\", pathKey);\n+        OFSPath ofsPath = new OFSPath(pathKey);\n+        String ofsPathprefix =\n+            ofsPath.getNonKeyPathNoPrefixDelim() + OZONE_URI_DELIMITER;\n+        while (keyIterator.hasNext()) {\n+          Table.KeyValue< String, OmKeyInfo > kv = keyIterator.next();\n+          String keyPath = ofsPathprefix + kv.getValue().getKeyName();\n+          LOG.trace(\"iterating key path: {}\", keyPath);\n+          if (!kv.getValue().getKeyName().equals(\"\")\n+              && kv.getKey().startsWith(\"/\" + pathKey)) {\n+            keyPathList.add(keyPath);\n+          }\n+          if (keyPathList.size() >= OZONE_FS_ITERATE_BATCH_SIZE) {\n+            if (!processKeyPath(keyPathList)) {\n+              return false;\n+            } else {\n+              keyPathList.clear();\n+            }\n+          }\n+        }\n+        if (keyPathList.size() > 0) {\n+          if (!processKeyPath(keyPathList)) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      } else {\n+        LOG.trace(\"iterating file: {}\", path);\n+        keyPathList.add(pathKey);\n+        return processKeyPath(keyPathList);\n+      }\n+    }\n+\n+    FileStatus getStatus() {\n+      return status;\n+    }\n+  }\n+\n+  private class RenameIterator extends OzoneListingIterator {\n+    private final String srcPath;\n+    private final String dstPath;\n+\n+    RenameIterator(Path srcPath, Path dstPath)\n+        throws IOException {\n+      super(srcPath);\n+      this.srcPath = pathToKey(srcPath);\n+      this.dstPath = pathToKey(dstPath);\n+      LOG.trace(\"rename from:{} to:{}\", this.srcPath, this.dstPath);\n+    }\n+\n+    @Override\n+    boolean processKeyPath(List<String> keyPathList) {\n+      for (String keyPath : keyPathList) {\n+        String newPath = dstPath.concat(keyPath.substring(srcPath.length()));\n+        OFSPath src = new OFSPath(keyPath);\n+        OFSPath dst = new OFSPath(newPath);\n+\n+        String volumeName = src.getVolumeName();\n+        String bucketName = src.getBucketName();\n+        String keyName = src.getKeyName();\n+\n+        OzoneManagerProtocolProtos.KeyArgs keyArgs =\n+            OzoneManagerProtocolProtos.KeyArgs.newBuilder().setKeyName(keyName)\n+            .setVolumeName(volumeName).setBucketName(bucketName).build();\n+\n+        String toKeyName = dst.getKeyName();\n+\n+        OzoneManagerProtocolProtos.RenameKeyRequest renameKeyRequest =\n+            OzoneManagerProtocolProtos.RenameKeyRequest.newBuilder()\n+            .setKeyArgs(keyArgs).setToKeyName(toKeyName).build();\n+        OzoneManagerProtocolProtos.OMRequest omRequest =\n+            OzoneManagerProtocolProtos.OMRequest.newBuilder()\n+            .setClientId(UUID.randomUUID().toString())\n+            .setRenameKeyRequest(renameKeyRequest)\n+            .setCmdType(OzoneManagerProtocolProtos.Type.RenameKey).build();\n+        try {\n+          ozoneManager.getOmServerProtocol().\n+              submitRequest(NULL_RPC_CONTROLLER, omRequest);\n+        } catch (ServiceException e) {\n+          LOG.error(\"Couldn't send rename request.\");\n+        }\n+\n+      }\n+      return true;\n+    }\n+  }\n+\n+  private class DeleteIterator extends OzoneListingIterator {\n+    final private boolean recursive;\n+\n+\n+    DeleteIterator(Path f, boolean recursive)\n+        throws IOException {\n+      super(f);\n+      this.recursive = recursive;\n+      if (getStatus().isDirectory()\n+          && !this.recursive\n+          && listStatus(f).length != 0) {\n+        throw new PathIsNotEmptyDirectoryException(f.toString());\n+      }\n+    }\n+\n+    @Override\n+    boolean processKeyPath(List<String> keyPathList) {\n+      LOG.trace(\"Deleting keys: {}\", keyPathList);\n+\n+      String volumeName;\n+      String bucketName;\n+      List<String> keyList = keyPathList.stream()\n+          .map(p -> new OFSPath(p).getKeyName())\n+          .collect(Collectors.toList());\n+\n+      if(!keyPathList.isEmpty()){\n+        OFSPath p = new OFSPath(keyPathList.get(0));", "originalCommit": "8b62859ba191191fdd611a02c6a7d55c331c7582", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5MjE3Mg==", "url": "https://github.com/apache/ozone/pull/1732#discussion_r552392172", "bodyText": "the keys in the keyset belong to the same volume and bucket.hence just reading the volume and bucket from the first entry. we are not ignoring other entries. all entries are deleted .", "author": "sadanand48", "createdAt": "2021-01-06T06:24:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2Nzk0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjc1NjcwMA==", "url": "https://github.com/apache/ozone/pull/1732#discussion_r552756700", "bodyText": "Sure. got it thanks.", "author": "mukul1987", "createdAt": "2021-01-06T16:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2Nzk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2ODYwMg==", "url": "https://github.com/apache/ozone/pull/1732#discussion_r552068602", "bodyText": "Lets have a helper function to convert src,dst to OzoneManagerProtocolProtos.RenameKeyRequest", "author": "mukul1987", "createdAt": "2021-01-05T17:08:03Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/TrashOzoneFileSystem.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership.  The ASF\n+ * licenses this file to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package org.apache.hadoop.ozone.om;\n+\n+import com.google.protobuf.RpcController;\n+import com.google.protobuf.ServiceException;\n+import org.apache.hadoop.fs.FSDataInputStream;\n+import org.apache.hadoop.fs.permission.FsPermission;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.FSDataOutputStream;\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.PathIsNotEmptyDirectoryException;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.TableIterator;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OFSPath;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyArgs;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFileStatus;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.security.UserGroupInformation;\n+import org.apache.hadoop.util.Progressable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Iterator;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.hadoop.ozone.OzoneConsts.OZONE_URI_DELIMITER;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.addTrailingSlashIfNeeded;\n+import static org.apache.hadoop.ozone.om.helpers.OzoneFSUtils.pathToKey;\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Type.DeleteKeys;\n+\n+/**\n+ * FileSystem to be used by the Trash Emptier.\n+ * Only the apis used by the trash emptier are implemented.\n+ */\n+public class TrashOzoneFileSystem extends FileSystem {\n+\n+  private static final RpcController NULL_RPC_CONTROLLER = null;\n+\n+  private static final int OZONE_FS_ITERATE_BATCH_SIZE = 100;\n+\n+  private OzoneManager ozoneManager;\n+\n+  private String userName;\n+\n+  private String ofsPathPrefix;\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(TrashOzoneFileSystem.class);\n+\n+  public TrashOzoneFileSystem(OzoneManager ozoneManager) throws IOException {\n+    this.ozoneManager = ozoneManager;\n+    this.userName =\n+          UserGroupInformation.getCurrentUser().getShortUserName();\n+  }\n+\n+  @Override\n+  public URI getUri() {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataInputStream open(Path path, int i) {\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream create(Path path,\n+      FsPermission fsPermission,\n+      boolean b, int i, short i1,\n+      long l, Progressable progressable){\n+    return null;\n+  }\n+\n+  @Override\n+  public FSDataOutputStream append(Path path, int i,\n+      Progressable progressable) {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean rename(Path src, Path dst) throws IOException {\n+    LOG.trace(\"Src:\" + src + \"Dst:\" + dst);\n+    RenameIterator iterator = new RenameIterator(src, dst);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public boolean delete(Path path, boolean b) throws IOException {\n+    DeleteIterator iterator = new DeleteIterator(path, true);\n+    iterator.iterate();\n+    return true;\n+  }\n+\n+  @Override\n+  public FileStatus[] listStatus(Path path) throws  IOException {\n+    List<FileStatus> fileStatuses = new ArrayList<>();\n+    OmKeyArgs keyArgs = constructOmKeyArgs(path);\n+    List<OzoneFileStatus> list = ozoneManager.\n+        listStatus(keyArgs, false, null, Integer.MAX_VALUE);\n+    for (OzoneFileStatus status : list) {\n+      Path temp = new Path(ofsPathPrefix +\n+          OZONE_URI_DELIMITER + status.getKeyInfo().getKeyName());\n+      FileStatus fileStatus = new FileStatus(\n+          status.getKeyInfo().getDataSize(),\n+          status.isDirectory(),\n+          status.getKeyInfo().getFactor().getNumber(),\n+          status.getBlockSize(),\n+          status.getKeyInfo().getModificationTime(),\n+          temp\n+      );\n+      fileStatuses.add(fileStatus);\n+\n+    }\n+    return fileStatuses.toArray(new FileStatus[0]);\n+  }\n+\n+  @Override\n+  public void setWorkingDirectory(Path path) {\n+\n+  }\n+\n+  @Override\n+  public Path getWorkingDirectory() {\n+    return null;\n+  }\n+\n+  @Override\n+  public boolean mkdirs(Path path,\n+      FsPermission fsPermission) {\n+    return false;\n+  }\n+\n+\n+  @Override\n+  public FileStatus getFileStatus(Path path) throws IOException {\n+    OmKeyArgs keyArgs = constructOmKeyArgs(path);\n+    OzoneFileStatus ofs = ozoneManager.getKeyManager().getFileStatus(keyArgs);\n+    Path temp = new Path(ofsPathPrefix +\n+        OZONE_URI_DELIMITER + ofs.getKeyInfo().getKeyName());\n+    FileStatus fileStatus = new FileStatus(ofs.getKeyInfo().getDataSize(),\n+        ofs.isDirectory(),\n+        ofs.getKeyInfo().getFactor().getNumber(),\n+        ofs.getBlockSize(),\n+        ofs.getKeyInfo().getModificationTime(),\n+        temp);\n+    return fileStatus;\n+  }\n+\n+  private OmKeyArgs constructOmKeyArgs(Path path) {\n+    OFSPath ofsPath = new OFSPath(path);\n+    String volume = ofsPath.getVolumeName();\n+    String bucket = ofsPath.getBucketName();\n+    String key = ofsPath.getKeyName();\n+    OmKeyArgs keyArgs = new OmKeyArgs.Builder()\n+        .setVolumeName(volume)\n+        .setBucketName(bucket)\n+        .setKeyName(key)\n+        .build();\n+    this.ofsPathPrefix = OZONE_URI_DELIMITER +\n+        volume + OZONE_URI_DELIMITER + bucket;\n+    return keyArgs;\n+  }\n+\n+  @Override\n+  public Collection<FileStatus> getTrashRoots(boolean allUsers) {\n+    Iterator<Map.Entry<CacheKey<String>,\n+        CacheValue<OmBucketInfo>>> bucketIterator =\n+        ozoneManager.getMetadataManager().getBucketIterator();\n+    List<FileStatus> ret = new ArrayList<>();\n+    while (bucketIterator.hasNext()){\n+      Map.Entry<CacheKey<String>, CacheValue<OmBucketInfo>> entry =\n+          bucketIterator.next();\n+      OmBucketInfo omBucketInfo = entry.getValue().getCacheValue();\n+      Path volumePath = new Path(OZONE_URI_DELIMITER,\n+          omBucketInfo.getVolumeName());\n+      Path bucketPath = new Path(volumePath, omBucketInfo.getBucketName());\n+      Path trashRoot = new Path(bucketPath, FileSystem.TRASH_PREFIX);\n+      try {\n+        if (exists(trashRoot)) {\n+          FileStatus[] list = this.listStatus(trashRoot);\n+          for (FileStatus candidate : list) {\n+            if (exists(candidate.getPath()) && candidate.isDirectory()) {\n+              ret.add(candidate);\n+            }\n+          }\n+        }\n+      } catch (Exception e){\n+        LOG.error(\"Couldn't perform fs operation \" +\n+            \"fs.listStatus()/fs.exists()\" + e);\n+      }\n+    }\n+    return ret;\n+  }\n+\n+  @Override\n+  public boolean exists(Path f) throws IOException {\n+    try {\n+      this.getFileStatus(f);\n+      return true;\n+    } catch (FileNotFoundException var3) {\n+      LOG.info(\"Couldn't execute getFileStatus()\"  + var3);\n+      return false;\n+    }\n+  }\n+\n+  private abstract class OzoneListingIterator {\n+    private final Path path;\n+    private final FileStatus status;\n+    private String pathKey;\n+    private TableIterator<String, ? extends Table.KeyValue<String, OmKeyInfo>>\n+          keyIterator;\n+\n+    OzoneListingIterator(Path path)\n+          throws IOException {\n+      this.path = path;\n+      this.status = getFileStatus(path);\n+      this.pathKey = pathToKey(path);\n+      if (status.isDirectory()) {\n+        this.pathKey = addTrailingSlashIfNeeded(pathKey);\n+      }\n+      keyIterator = ozoneManager.getMetadataManager().getKeyIterator();\n+    }\n+\n+      /**\n+       * The output of processKey determines if further iteration through the\n+       * keys should be done or not.\n+       *\n+       * @return true if we should continue iteration of keys, false otherwise.\n+       * @throws IOException\n+       */\n+    abstract boolean processKeyPath(List<String> keyPathList)\n+          throws IOException;\n+\n+      /**\n+       * Iterates through all the keys prefixed with the input path's key and\n+       * processes the key though processKey().\n+       * If for any key, the processKey() returns false, then the iteration is\n+       * stopped and returned with false indicating that all the keys could not\n+       * be processed successfully.\n+       *\n+       * @return true if all keys are processed successfully, false otherwise.\n+       * @throws IOException\n+       */\n+    boolean iterate() throws IOException {\n+      LOG.trace(\"Iterating path: {}\", path);\n+      List<String> keyPathList = new ArrayList<>();\n+      //hardcoded make it read from conf\n+      if (status.isDirectory()) {\n+        LOG.trace(\"Iterating directory: {}\", pathKey);\n+        OFSPath ofsPath = new OFSPath(pathKey);\n+        String ofsPathprefix =\n+            ofsPath.getNonKeyPathNoPrefixDelim() + OZONE_URI_DELIMITER;\n+        while (keyIterator.hasNext()) {\n+          Table.KeyValue< String, OmKeyInfo > kv = keyIterator.next();\n+          String keyPath = ofsPathprefix + kv.getValue().getKeyName();\n+          LOG.trace(\"iterating key path: {}\", keyPath);\n+          if (!kv.getValue().getKeyName().equals(\"\")\n+              && kv.getKey().startsWith(\"/\" + pathKey)) {\n+            keyPathList.add(keyPath);\n+          }\n+          if (keyPathList.size() >= OZONE_FS_ITERATE_BATCH_SIZE) {\n+            if (!processKeyPath(keyPathList)) {\n+              return false;\n+            } else {\n+              keyPathList.clear();\n+            }\n+          }\n+        }\n+        if (keyPathList.size() > 0) {\n+          if (!processKeyPath(keyPathList)) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      } else {\n+        LOG.trace(\"iterating file: {}\", path);\n+        keyPathList.add(pathKey);\n+        return processKeyPath(keyPathList);\n+      }\n+    }\n+\n+    FileStatus getStatus() {\n+      return status;\n+    }\n+  }\n+\n+  private class RenameIterator extends OzoneListingIterator {\n+    private final String srcPath;\n+    private final String dstPath;\n+\n+    RenameIterator(Path srcPath, Path dstPath)\n+        throws IOException {\n+      super(srcPath);\n+      this.srcPath = pathToKey(srcPath);\n+      this.dstPath = pathToKey(dstPath);\n+      LOG.trace(\"rename from:{} to:{}\", this.srcPath, this.dstPath);\n+    }\n+\n+    @Override\n+    boolean processKeyPath(List<String> keyPathList) {\n+      for (String keyPath : keyPathList) {\n+        String newPath = dstPath.concat(keyPath.substring(srcPath.length()));\n+        OFSPath src = new OFSPath(keyPath);\n+        OFSPath dst = new OFSPath(newPath);\n+\n+        String volumeName = src.getVolumeName();\n+        String bucketName = src.getBucketName();", "originalCommit": "8b62859ba191191fdd611a02c6a7d55c331c7582", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjM5MTY2MQ==", "url": "https://github.com/apache/ozone/pull/1732#discussion_r552391661", "bodyText": "done", "author": "sadanand48", "createdAt": "2021-01-06T06:22:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA2ODYwMg=="}], "type": "inlineReview"}, {"oid": "4ace5ae23dd5d26de58f72da4872153e72e09af6", "url": "https://github.com/apache/ozone/commit/4ace5ae23dd5d26de58f72da4872153e72e09af6", "message": "addressed comments", "committedDate": "2021-01-06T06:21:11Z", "type": "commit"}, {"oid": "114baba37894236ead568184f956839479d09be1", "url": "https://github.com/apache/ozone/commit/114baba37894236ead568184f956839479d09be1", "message": "added comments", "committedDate": "2021-01-06T06:33:06Z", "type": "commit"}, {"oid": "77471b696b6419453b0069d677bdfa4994252191", "url": "https://github.com/apache/ozone/commit/77471b696b6419453b0069d677bdfa4994252191", "message": "code cleanup", "committedDate": "2021-01-06T08:21:27Z", "type": "commit"}, {"oid": "3a5627100e939de7b02e2378078f5d0e85eae99a", "url": "https://github.com/apache/ozone/commit/3a5627100e939de7b02e2378078f5d0e85eae99a", "message": "resolve failing check", "committedDate": "2021-01-06T11:21:38Z", "type": "commit"}, {"oid": "279a4c9acfcec1261a89e4baa4c15ad702bf3194", "url": "https://github.com/apache/ozone/commit/279a4c9acfcec1261a89e4baa4c15ad702bf3194", "message": "trigger new CI check", "committedDate": "2021-01-06T12:29:21Z", "type": "commit"}, {"oid": "64e1761da9647352716e9dc8f1ef32b14303cc43", "url": "https://github.com/apache/ozone/commit/64e1761da9647352716e9dc8f1ef32b14303cc43", "message": "resolve check", "committedDate": "2021-01-06T17:08:40Z", "type": "commit"}, {"oid": "99deab7195c1647e62d1f24f1a9f31b394c1a2db", "url": "https://github.com/apache/ozone/commit/99deab7195c1647e62d1f24f1a9f31b394c1a2db", "message": "resolve check", "committedDate": "2021-01-06T17:29:12Z", "type": "commit"}, {"oid": "c9c022cc5883a9cc1f8f2a3873fa804391a3bd4b", "url": "https://github.com/apache/ozone/commit/c9c022cc5883a9cc1f8f2a3873fa804391a3bd4b", "message": "remove unused variable", "committedDate": "2021-01-06T17:31:22Z", "type": "commit"}, {"oid": "2904bfa18ead7c04924894c81c545ad76b46bd6a", "url": "https://github.com/apache/ozone/commit/2904bfa18ead7c04924894c81c545ad76b46bd6a", "message": "resolve failing check", "committedDate": "2021-01-06T19:11:52Z", "type": "commit"}]}