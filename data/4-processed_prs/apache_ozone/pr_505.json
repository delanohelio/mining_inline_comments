{"pr_number": 505, "pr_title": "HDDS-2956. Handle Replay of AllocateBlock request", "pr_createdAt": "2020-01-30T01:07:32Z", "pr_url": "https://github.com/apache/ozone/pull/505", "timeline": [{"oid": "2ddfa0317a9fc44e440b87c9172c14cb46317352", "url": "https://github.com/apache/ozone/commit/2ddfa0317a9fc44e440b87c9172c14cb46317352", "message": "HDDS-2956. Handle Replay of AllocateBlock request", "committedDate": "2020-01-30T01:06:46Z", "type": "commit"}, {"oid": "8ebe8b1127895feca1416a27f41795c068b8fdf3", "url": "https://github.com/apache/ozone/commit/8ebe8b1127895feca1416a27f41795c068b8fdf3", "message": "CI fixes", "committedDate": "2020-01-30T17:19:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5NDY0NA==", "url": "https://github.com/apache/ozone/pull/505#discussion_r373294644", "bodyText": "I think, this check will help only when Key is created and Committed. But it will not help in the scenario:\nT1 - Key Create\nT2 - allocate block\nT3 - Key Commit\nT4- Key Delete\nWhen replay, we will still throw an error, as it will not be in the openKeyTable. So, I think it is okay not to get from key table and do a check. As we cannot 100% find replay transactions.", "author": "bharatviswa504", "createdAt": "2020-01-31T02:46:14Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMAllocateBlockRequest.java", "diffHunk": "@@ -160,71 +160,98 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n     Map<String, String> auditMap = buildKeyArgsAuditMap(keyArgs);\n     auditMap.put(OzoneConsts.CLIENT_ID, String.valueOf(clientID));\n \n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    String openKeyName = omMetadataManager.getOpenKey(volumeName, bucketName,\n+        keyName, clientID);\n+\n     OMResponse.Builder omResponse = OMResponse.newBuilder().setCmdType(\n         OzoneManagerProtocolProtos.Type.AllocateBlock).setStatus(\n         OzoneManagerProtocolProtos.Status.OK).setSuccess(true);\n+    OMClientResponse omClientResponse = null;\n \n+    OmKeyInfo openKeyInfo = null;\n     IOException exception = null;\n-    OmKeyInfo omKeyInfo = null;\n+\n     try {\n       // check Acl\n       checkKeyAclsInOpenKeyTable(ozoneManager, volumeName, bucketName, keyName,\n           IAccessAuthorizer.ACLType.WRITE, allocateBlockRequest.getClientID());\n \n-      OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n       validateBucketAndVolume(omMetadataManager, volumeName,\n           bucketName);\n \n-      String openKey = omMetadataManager.getOpenKey(\n-          volumeName, bucketName, keyName, clientID);\n-\n       // Here we don't acquire bucket/volume lock because for a single client\n       // allocateBlock is called in serial fashion.\n \n-      omKeyInfo = omMetadataManager.getOpenKeyTable().get(openKey);\n-      if (omKeyInfo == null) {\n-        throw new OMException(\"Open Key not found \" + openKey, KEY_NOT_FOUND);\n+      openKeyInfo = omMetadataManager.getOpenKeyTable().get(openKeyName);\n+      if (openKeyInfo == null) {\n+        // Check if this transaction is a replay of ratis logs.\n+        // If the Key was already committed and this transaction is being\n+        // replayed, we should ignore this transaction.\n+        String ozoneKey = omMetadataManager.getOzoneKey(volumeName,", "originalCommit": "8ebe8b1127895feca1416a27f41795c068b8fdf3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYwNDE0MA==", "url": "https://github.com/apache/ozone/pull/505#discussion_r373604140", "bodyText": "My intention was to capture the maximum number of cases. If Key is deleted, we cannot help it. And this does not affect the regular case when the openKey exists. So it is not a performance concern.", "author": "hanishakoneru", "createdAt": "2020-01-31T17:49:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5NDY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5NDkzMA==", "url": "https://github.com/apache/ozone/pull/505#discussion_r373294930", "bodyText": "Just one minor comment, can we eliminate renaming variable changes, as this is increasing jira scope and code line changes. As with focussed change, it will be simple.", "author": "bharatviswa504", "createdAt": "2020-01-31T02:47:35Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMAllocateBlockRequest.java", "diffHunk": "@@ -134,8 +135,7 @@ public OMRequest preExecute(OzoneManager ozoneManager) throws IOException {\n \n   @Override\n   public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n-      long transactionLogIndex,\n-      OzoneManagerDoubleBufferHelper ozoneManagerDoubleBufferHelper) {\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {", "originalCommit": "8ebe8b1127895feca1416a27f41795c068b8fdf3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYwNTA1OA==", "url": "https://github.com/apache/ozone/pull/505#discussion_r373605058", "bodyText": "Sure. I will avoid it in future. The variable names were so big that it was causing unnecessary increase in the lines of code. I was trying to club code cleanup along with these changes. But I will reserve it for separate Jira in the future.", "author": "hanishakoneru", "createdAt": "2020-01-31T17:51:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5NDkzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5NTY5NA==", "url": "https://github.com/apache/ozone/pull/505#discussion_r373295694", "bodyText": "We want to do auditLog when it is not a replay(best try), like how we did in other key patches.", "author": "bharatviswa504", "createdAt": "2020-01-31T02:51:10Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMAllocateBlockRequest.java", "diffHunk": "@@ -160,71 +160,98 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n     Map<String, String> auditMap = buildKeyArgsAuditMap(keyArgs);\n     auditMap.put(OzoneConsts.CLIENT_ID, String.valueOf(clientID));\n \n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    String openKeyName = omMetadataManager.getOpenKey(volumeName, bucketName,\n+        keyName, clientID);\n+\n     OMResponse.Builder omResponse = OMResponse.newBuilder().setCmdType(\n         OzoneManagerProtocolProtos.Type.AllocateBlock).setStatus(\n         OzoneManagerProtocolProtos.Status.OK).setSuccess(true);\n+    OMClientResponse omClientResponse = null;\n \n+    OmKeyInfo openKeyInfo = null;\n     IOException exception = null;\n-    OmKeyInfo omKeyInfo = null;\n+\n     try {\n       // check Acl\n       checkKeyAclsInOpenKeyTable(ozoneManager, volumeName, bucketName, keyName,\n           IAccessAuthorizer.ACLType.WRITE, allocateBlockRequest.getClientID());\n \n-      OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n       validateBucketAndVolume(omMetadataManager, volumeName,\n           bucketName);\n \n-      String openKey = omMetadataManager.getOpenKey(\n-          volumeName, bucketName, keyName, clientID);\n-\n       // Here we don't acquire bucket/volume lock because for a single client\n       // allocateBlock is called in serial fashion.\n \n-      omKeyInfo = omMetadataManager.getOpenKeyTable().get(openKey);\n-      if (omKeyInfo == null) {\n-        throw new OMException(\"Open Key not found \" + openKey, KEY_NOT_FOUND);\n+      openKeyInfo = omMetadataManager.getOpenKeyTable().get(openKeyName);\n+      if (openKeyInfo == null) {\n+        // Check if this transaction is a replay of ratis logs.\n+        // If the Key was already committed and this transaction is being\n+        // replayed, we should ignore this transaction.\n+        String ozoneKey = omMetadataManager.getOzoneKey(volumeName,\n+            bucketName, keyName);\n+        OmKeyInfo dbKeyInfo = omMetadataManager.getKeyTable().get(ozoneKey);\n+        if (dbKeyInfo != null) {\n+          if (isReplay(ozoneManager, dbKeyInfo.getUpdateID(), trxnLogIndex)) {\n+            // This transaction is a replay. Send replay response.\n+            throw new OMReplayException();\n+          }\n+        }\n+        throw new OMException(\"Open Key not found \" + openKeyName,\n+            KEY_NOT_FOUND);\n+      }\n+\n+      // Check if this transaction is a replay of ratis logs.\n+      // Check the updateID of the openKey to verify that it is not greater\n+      // than the current transactionLogIndex\n+      if (isReplay(ozoneManager, openKeyInfo.getUpdateID(), trxnLogIndex)) {\n+        // This transaction is a replay. Send replay response.\n+        throw new OMReplayException();\n       }\n \n       // Append new block\n-      omKeyInfo.appendNewBlocks(Collections.singletonList(\n+      openKeyInfo.appendNewBlocks(Collections.singletonList(\n           OmKeyLocationInfo.getFromProtobuf(blockLocation)), false);\n \n       // Set modification time.\n-      omKeyInfo.setModificationTime(keyArgs.getModificationTime());\n+      openKeyInfo.setModificationTime(keyArgs.getModificationTime());\n \n       // Set the UpdateID to current transactionLogIndex\n-      omKeyInfo.setUpdateID(transactionLogIndex);\n+      openKeyInfo.setUpdateID(trxnLogIndex);\n \n       // Add to cache.\n       omMetadataManager.getOpenKeyTable().addCacheEntry(\n-          new CacheKey<>(openKey), new CacheValue<>(Optional.of(omKeyInfo),\n-              transactionLogIndex));\n+          new CacheKey<>(openKeyName),\n+          new CacheValue<>(Optional.of(openKeyInfo), trxnLogIndex));\n \n+      omResponse.setAllocateBlockResponse(AllocateBlockResponse.newBuilder()\n+          .setKeyLocation(blockLocation).build());\n+      omClientResponse = new OMAllocateBlockResponse(omResponse.build(),\n+          openKeyInfo, clientID);\n+      LOG.debug(\"Allocated block for Volume:{}, Bucket:{}, OpenKey:{}\",\n+          volumeName, bucketName, openKeyName);\n     } catch (IOException ex) {\n-      exception = ex;\n+      if (ex instanceof OMReplayException) {\n+        omClientResponse = new OMAllocateBlockResponse(createReplayOMResponse(\n+            omResponse));\n+        LOG.debug(\"Replayed Transaction {} ignored. Request: {}\", trxnLogIndex,\n+            allocateBlockRequest);\n+      } else {\n+        omMetrics.incNumBlockAllocateCallFails();\n+        exception = ex;\n+        omClientResponse = new OMAllocateBlockResponse(createErrorOMResponse(\n+            omResponse, exception));\n+        LOG.error(\"Allocate Block failed. Volume:{}, Bucket:{}, OpenKey:{}. \" +\n+            \"Exception:{}\", volumeName, bucketName, openKeyName, exception);\n+      }\n     }\n \n     auditLog(auditLogger, buildAuditMessage(OMAction.ALLOCATE_BLOCK, auditMap,", "originalCommit": "8ebe8b1127895feca1416a27f41795c068b8fdf3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYwNjY3Mg==", "url": "https://github.com/apache/ozone/pull/505#discussion_r373606672", "bodyText": "done.", "author": "hanishakoneru", "createdAt": "2020-01-31T17:55:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5NTY5NA=="}], "type": "inlineReview"}, {"oid": "c20546f8c2927e94921b4c132c9d7afc5e4b647f", "url": "https://github.com/apache/ozone/commit/c20546f8c2927e94921b4c132c9d7afc5e4b647f", "message": "review comment", "committedDate": "2020-01-31T17:54:59Z", "type": "commit"}]}