{"pr_number": 941, "pr_title": "HDDS-3574. Implement ofs://: Override getTrashRoot", "pr_createdAt": "2020-05-18T23:50:25Z", "pr_url": "https://github.com/apache/ozone/pull/941", "timeline": [{"oid": "ac3cc695ce1dd91c518e1423504a86d7b0419d60", "url": "https://github.com/apache/ozone/commit/ac3cc695ce1dd91c518e1423504a86d7b0419d60", "message": "Implement getTrashRoot for OFS.", "committedDate": "2020-05-18T23:48:37Z", "type": "commit"}, {"oid": "0747a141faff5cbf2964bb1b249d35c7098026db", "url": "https://github.com/apache/ozone/commit/0747a141faff5cbf2964bb1b249d35c7098026db", "message": "Add test.", "committedDate": "2020-05-18T23:48:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY2MzAzMw==", "url": "https://github.com/apache/ozone/pull/941#discussion_r427663033", "bodyText": "Minor NIT: Should we set authority in the initOFSPath??\nAs there we have checked for auth.", "author": "bharatviswa504", "createdAt": "2020-05-19T23:48:09Z", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -66,7 +70,13 @@\n   static final String OFS_MOUNT_TMP_VOLUMENAME = \"tmp\";\n \n   OFSPath(Path path) {\n-    String pathStr = path.toUri().getPath();\n+    URI uri = path.toUri();\n+    // scheme is case-insensitive\n+    if (!uri.getScheme().toLowerCase().equals(OZONE_OFS_URI_SCHEME)) {\n+      throw new ParseException(\"Can't parse schemes other than ofs://.\");\n+    }\n+    authority = uri.getAuthority();", "originalCommit": "0747a141faff5cbf2964bb1b249d35c7098026db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2NDA0OQ==", "url": "https://github.com/apache/ozone/pull/941#discussion_r428264049", "bodyText": "initOFSPath was designed to take a path without scheme or authority though. I didn't intend to change the parsing logic too much but I might do a refactoring to make it more consistent overall since you mentioned.", "author": "smengcl", "createdAt": "2020-05-20T19:41:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY2MzAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY2NTMyMA==", "url": "https://github.com/apache/ozone/pull/941#discussion_r427665320", "bodyText": "Thinking more, do we need this, from above uri, we can get authority and check if it is empty or nulll and then throw error. So, in this way, we don't need to convert path to URI again.", "author": "bharatviswa504", "createdAt": "2020-05-19T23:55:41Z", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -78,8 +88,8 @@ private void initOFSPath(String pathStr) {\n     // pathStr should not have authority\n     try {\n       URI uri = new URI(pathStr);\n-      String authority = uri.getAuthority();\n-      if (authority != null && !authority.isEmpty()) {\n+      String auth = uri.getAuthority();", "originalCommit": "0747a141faff5cbf2964bb1b249d35c7098026db", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MTc3Mg==", "url": "https://github.com/apache/ozone/pull/941#discussion_r428181772", "bodyText": "Should it be first username and then .Trash ? like ofs:///vol1/bucket1/username/.Trash  ?\nThis is default iml at FileSystem.java\n\n /**\n   * Get the root directory of Trash for current user when the path specified\n   * is deleted.\n   *\n   * @param path the trash root of the path to be determined.\n   * @return the default implementation returns {@code /user/$USER/.Trash}\n   */\n  public Path getTrashRoot(Path path) {\n    return this.makeQualified(new Path(getHomeDirectory().toUri().getPath(),\n        TRASH_PREFIX));\n  }\n\nCC: @mukul1987 @sadanand48 @arp7 : I think this should be checked with Sadanand implementation as well to be in sync?", "author": "umamaheswararao", "createdAt": "2020-05-20T17:22:30Z", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -238,4 +248,23 @@ static String getTempMountBucketNameOfCurrentUser() throws IOException {\n     String username = UserGroupInformation.getCurrentUser().getUserName();\n     return getTempMountBucketName(username);\n   }\n+\n+  /**\n+   * Return trash root for the given path.\n+   * @return trash root for the given path\n+   */\n+  public Path getTrashRoot() {\n+    try {\n+      String username = UserGroupInformation.getCurrentUser().getUserName();\n+      URI uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)", "originalCommit": "0747a141faff5cbf2964bb1b249d35c7098026db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwODk0Mg==", "url": "https://github.com/apache/ozone/pull/941#discussion_r428208942", "bodyText": "Given we don't have a home directory per bucket, I think this PR took an approach similar to encryption zone where the .Trash is created per bucket, i.e., ofs://vol1/bucket1/.Trash/username, which have a common trash root per bucket.\nIf we take ofs:///vol1/bucket1/username/.Trash, we won't have a common trash root. As a result, the trash clean up will be expensive as we don't have a common root per bucket to check the expired trash checkpoints.", "author": "xiaoyuyao", "createdAt": "2020-05-20T18:08:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MTc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI1MzU1Ng==", "url": "https://github.com/apache/ozone/pull/941#discussion_r428253556", "bodyText": "Thanks @xiaoyuyao for explanation. I agree on flipping folders here.\nMy point is: after looking at Trash impl demo today, in o3fs we seems to be getting /.Trash\nMy point is, this o3fs and ofs trash directories should be in sync. so that emptier will not omit the  trash dirs created by o3fs?\nAlso inside OM Server, we get trashRoots from the fs configured as OM. That should default fs. When we configure ofs, it should also consider trash dirs created by o3fs? I think yes, so that they both should be in sync.", "author": "umamaheswararao", "createdAt": "2020-05-20T19:21:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MTc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI2OTg0NQ==", "url": "https://github.com/apache/ozone/pull/941#discussion_r428269845", "bodyText": "I agree o3fs and ofs trash locations should be the same. We should refactor the common parts to some new shared classes later.\nI didn't get the \"OM Server\" part though. IMO getTrashRoot is purely a client-side method?", "author": "smengcl", "createdAt": "2020-05-20T19:52:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MTc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI4NjU1OQ==", "url": "https://github.com/apache/ozone/pull/941#discussion_r428286559", "bodyText": "Yes its client side logic. TrashEmptier uses fs to get the directories and this TrashEmptier runs inside NN, so here it will be in OM server.\nIf we wanted to reuse the logic, all dirs should be in sync and TrashEmptier will get the trashRoots and cleanup.\nFor your ref below is the TrashEmptier code:\ntry {\n         now = Time.now();\n         if (now >= end) {\n           Collection<FileStatus> trashRoots;\n           trashRoots = fs.getTrashRoots(true);      // list all trash dirs\n\n           for (FileStatus trashRoot : trashRoots) {   // dump each trash\n             if (!trashRoot.isDirectory())\n               continue;\n             try {\n               TrashPolicyDefault trash = new TrashPolicyDefault(fs, conf);\n               trash.deleteCheckpoint(trashRoot.getPath(), false);\n               trash.createCheckpoint(trashRoot.getPath(), new Date(now));\n             } catch (IOException e) {\n               LOG.warn(\"Trash caught: \"+e+\". Skipping \" +\n                   trashRoot.getPath() + \".\");\n             } \n           }\n         }\n       } catch (Exception e) {\n         LOG.warn(\"RuntimeException during Trash.Emptier.run(): \", e); \n       }", "author": "umamaheswararao", "createdAt": "2020-05-20T20:24:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MTc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5ODE2OQ==", "url": "https://github.com/apache/ozone/pull/941#discussion_r428298169", "bodyText": "I am in favor of maintaining trash roots for ofs and o3fs the same (We should override getTrashRoot for o3fs similar to this Jira), as @umamaheswararao said in the first phase, we can reuse the code of hdfs logic and run the same in OM with OFS filesystem object and also for this we need to implement fs.getTrashRoots return path for all buckets in the system(Which can be done in a separate Jira).", "author": "bharatviswa504", "createdAt": "2020-05-20T20:47:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MTc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3NzYyOA==", "url": "https://github.com/apache/ozone/pull/941#discussion_r428377628", "bodyText": "@umamaheswararao I think we are on the same page. Both o3fs and ofs have Trash per bucket. And code should be reused.", "author": "xiaoyuyao", "createdAt": "2020-05-21T00:14:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MTc3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczMTUyOA==", "url": "https://github.com/apache/ozone/pull/941#discussion_r432731528", "bodyText": "I agree we should reuse some code when we implement trash for o3fs.", "author": "smengcl", "createdAt": "2020-05-29T20:57:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE4MTc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwNDc1MA==", "url": "https://github.com/apache/ozone/pull/941#discussion_r428204750", "bodyText": "should we change initOFSPath to take URI as parameter so that all the URI check can be done inside initOFSPath?", "author": "xiaoyuyao", "createdAt": "2020-05-20T18:00:47Z", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -78,8 +88,8 @@ private void initOFSPath(String pathStr) {\n     // pathStr should not have authority", "originalCommit": "0747a141faff5cbf2964bb1b249d35c7098026db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3MDA5Nw==", "url": "https://github.com/apache/ozone/pull/941#discussion_r428270097", "bodyText": "@bharatviswa504  also mentioned this. Will do.", "author": "smengcl", "createdAt": "2020-05-20T19:53:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwNDc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwOTQ4Mg==", "url": "https://github.com/apache/ozone/pull/941#discussion_r428209482", "bodyText": "NIT: we can use Path API to create the path safely instead of string concat.", "author": "xiaoyuyao", "createdAt": "2020-05-20T18:09:12Z", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/OFSPath.java", "diffHunk": "@@ -238,4 +248,23 @@ static String getTempMountBucketNameOfCurrentUser() throws IOException {\n     String username = UserGroupInformation.getCurrentUser().getUserName();\n     return getTempMountBucketName(username);\n   }\n+\n+  /**\n+   * Return trash root for the given path.\n+   * @return trash root for the given path\n+   */\n+  public Path getTrashRoot() {\n+    try {\n+      String username = UserGroupInformation.getCurrentUser().getUserName();\n+      URI uri = new URIBuilder().setScheme(OZONE_OFS_URI_SCHEME)\n+          .setHost(authority).setPath(OZONE_URI_DELIMITER + volumeName +", "originalCommit": "0747a141faff5cbf2964bb1b249d35c7098026db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3MTIyNw==", "url": "https://github.com/apache/ozone/pull/941#discussion_r428271227", "bodyText": "Do you mean using constructor new Path(prevPath, \"child\") and building the path step by step?", "author": "smengcl", "createdAt": "2020-05-20T19:55:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwOTQ4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTQyMjYwMg==", "url": "https://github.com/apache/ozone/pull/941#discussion_r429422602", "bodyText": "Attempted in 53c19f1.\nI also explored Paths.get() but it returns java.nio.file.Paths.", "author": "smengcl", "createdAt": "2020-05-22T19:34:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIwOTQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIxMDMxNg==", "url": "https://github.com/apache/ozone/pull/941#discussion_r428210316", "bodyText": "Can you also verify the key1 is moved to the proper Trash location?", "author": "xiaoyuyao", "createdAt": "2020-05-20T18:10:24Z", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/ozone/shell/TestOzoneShellHA.java", "diffHunk": "@@ -442,6 +446,27 @@ public void testOzoneShCmdList() {\n     Assert.assertEquals(0, getNumOfBuckets(\"bucket\"));\n   }\n \n+  @Test\n+  public void testDeleteToTrash() throws Exception {\n+    OzoneConfiguration confcli = new OzoneConfiguration(conf);\n+    confcli.setInt(FS_TRASH_INTERVAL_KEY, 60);\n+    confcli.set(\"fs.ofs.impl\",\n+        \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    OzoneFsShell shell = new OzoneFsShell(confcli);\n+    final String hostPrefix = OZONE_OFS_URI_SCHEME + \"://\" + omServiceId;\n+    final String dirPrefix = hostPrefix + \"/volumed2t/bucket1/dir1\";\n+    int res;\n+    try {\n+      res = ToolRunner.run(shell, new String[]{\"-mkdir\", \"-p\", dirPrefix});\n+      Assert.assertEquals(0, res);\n+      res = ToolRunner.run(shell, new String[]{\"-touch\", dirPrefix + \"/key1\"});\n+      Assert.assertEquals(0, res);\n+      res = ToolRunner.run(shell, new String[]{\"-rm\", dirPrefix + \"/key1\"});\n+      Assert.assertEquals(0, res);", "originalCommit": "0747a141faff5cbf2964bb1b249d35c7098026db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjcwOTc0NA==", "url": "https://github.com/apache/ozone/pull/941#discussion_r432709744", "bodyText": "done in 31969f9", "author": "smengcl", "createdAt": "2020-05-29T20:05:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIxMDMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIxMDU1Ng==", "url": "https://github.com/apache/ozone/pull/941#discussion_r428210556", "bodyText": "Can you add a test with skipTrash and make sure it is not moved to the Trash location?", "author": "xiaoyuyao", "createdAt": "2020-05-20T18:10:51Z", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/ozone/shell/TestOzoneShellHA.java", "diffHunk": "@@ -442,6 +446,27 @@ public void testOzoneShCmdList() {\n     Assert.assertEquals(0, getNumOfBuckets(\"bucket\"));\n   }\n \n+  @Test\n+  public void testDeleteToTrash() throws Exception {\n+    OzoneConfiguration confcli = new OzoneConfiguration(conf);\n+    confcli.setInt(FS_TRASH_INTERVAL_KEY, 60);\n+    confcli.set(\"fs.ofs.impl\",\n+        \"org.apache.hadoop.fs.ozone.RootedOzoneFileSystem\");\n+    OzoneFsShell shell = new OzoneFsShell(confcli);\n+    final String hostPrefix = OZONE_OFS_URI_SCHEME + \"://\" + omServiceId;\n+    final String dirPrefix = hostPrefix + \"/volumed2t/bucket1/dir1\";\n+    int res;\n+    try {\n+      res = ToolRunner.run(shell, new String[]{\"-mkdir\", \"-p\", dirPrefix});\n+      Assert.assertEquals(0, res);\n+      res = ToolRunner.run(shell, new String[]{\"-touch\", dirPrefix + \"/key1\"});\n+      Assert.assertEquals(0, res);\n+      res = ToolRunner.run(shell, new String[]{\"-rm\", dirPrefix + \"/key1\"});", "originalCommit": "0747a141faff5cbf2964bb1b249d35c7098026db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjczMDk0Nw==", "url": "https://github.com/apache/ozone/pull/941#discussion_r432730947", "bodyText": "done in 241361e.", "author": "smengcl", "createdAt": "2020-05-29T20:56:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIxMDU1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIxMjc0MQ==", "url": "https://github.com/apache/ozone/pull/941#discussion_r428212741", "bodyText": "You also need to Override getTrashRoots() which returns all trash locations under the root across multiple buckets. This should be very similar to how Trash under encryption zone is handled in DistributedFileSystem#getTrashRoots().", "author": "xiaoyuyao", "createdAt": "2020-05-20T18:14:55Z", "path": "hadoop-ozone/ozonefs/src/main/java/org/apache/hadoop/fs/ozone/BasicRootedOzoneFileSystem.java", "diffHunk": "@@ -658,6 +658,19 @@ public String getUsername() {\n     return userName;\n   }\n \n+  /**\n+   * Get the root directory of Trash for a path in OFS.\n+   * Returns /<volumename>/<bucketname>/.Trash/<username>\n+   * Caller appends either Current or checkpoint timestamp for trash destination\n+   * @param path the trash root of the path to be determined.\n+   * @return trash root\n+   */\n+  @Override", "originalCommit": "0747a141faff5cbf2964bb1b249d35c7098026db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI5MjU0Nw==", "url": "https://github.com/apache/ozone/pull/941#discussion_r428292547", "bodyText": "Good catch. It also seems Emptier in TrashPolicyDefault utilizes getTrashRoots(), which @umamaheswararao believes might make trash clean up easier in Ozone.", "author": "smengcl", "createdAt": "2020-05-20T20:36:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIxMjc0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzk0MDM1NQ==", "url": "https://github.com/apache/ozone/pull/941#discussion_r433940355", "bodyText": "Created HDDS-3705 to track getTrashRoots impl.", "author": "smengcl", "createdAt": "2020-06-02T14:55:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODIxMjc0MQ=="}], "type": "inlineReview"}, {"oid": "53c19f1f1f543978f7e381d2160e35415756a859", "url": "https://github.com/apache/ozone/commit/53c19f1f1f543978f7e381d2160e35415756a859", "message": "Use only Hadoop common Path API to build the trash root path.", "committedDate": "2020-05-22T19:31:02Z", "type": "commit"}, {"oid": "a6dae41c800fb80b1b28054387c0418cecdc2f39", "url": "https://github.com/apache/ozone/commit/a6dae41c800fb80b1b28054387c0418cecdc2f39", "message": "Refactor OFSPath.", "committedDate": "2020-05-28T21:15:52Z", "type": "commit"}, {"oid": "06ad9d2a8285828b5506a891298df90f9d730b02", "url": "https://github.com/apache/ozone/commit/06ad9d2a8285828b5506a891298df90f9d730b02", "message": "Impl OFSPath#toString.", "committedDate": "2020-05-28T22:37:37Z", "type": "commit"}, {"oid": "31969f9066a3e81fdf44e40b04d676e341604648", "url": "https://github.com/apache/ozone/commit/31969f9066a3e81fdf44e40b04d676e341604648", "message": "testDeleteToTrash now checks if file is moved to the trash location.", "committedDate": "2020-05-29T20:04:42Z", "type": "commit"}, {"oid": "241361e378f7fc541229883137a93cbb2960869f", "url": "https://github.com/apache/ozone/commit/241361e378f7fc541229883137a93cbb2960869f", "message": "testDeleteToTrash -> testDeleteToTrashOrSkipTrash. Also checks skipTrash behavior now.", "committedDate": "2020-05-29T20:46:55Z", "type": "commit"}, {"oid": "c04e5594debcf459c3f2478b59e34904cc43b980", "url": "https://github.com/apache/ozone/commit/c04e5594debcf459c3f2478b59e34904cc43b980", "message": "Fix checkstyle.", "committedDate": "2020-05-29T20:48:04Z", "type": "commit"}, {"oid": "49125a00b193ccfa00f3e0913c01025a054948d0", "url": "https://github.com/apache/ozone/commit/49125a00b193ccfa00f3e0913c01025a054948d0", "message": "Remove suppress checkstyle in the new test. Committed erroneously.", "committedDate": "2020-05-29T20:49:12Z", "type": "commit"}, {"oid": "48108000f1f32013b18d5241e7a666932e487bb8", "url": "https://github.com/apache/ozone/commit/48108000f1f32013b18d5241e7a666932e487bb8", "message": "Fix checkstyle.", "committedDate": "2020-05-29T20:49:55Z", "type": "commit"}]}