{"pr_number": 1195, "pr_title": "HDDS-3930. Fix OMKeyDeletesRequest.", "pr_createdAt": "2020-07-10T22:46:30Z", "pr_url": "https://github.com/apache/ozone/pull/1195", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzI3MTEwNA==", "url": "https://github.com/apache/ozone/pull/1195#discussion_r453271104", "bodyText": "More arguments (not counting exception) than placeholders:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    LOG.error(\"Keys delete failed. Volume:{}, Bucket:{}, DeletedKey:{}, \" +\n          \n          \n            \n                            \"UnDeletedKeys:{}\", volumeName, bucketName, keyName,\n          \n          \n            \n                        auditMap.get(DELETED_KEYS_LIST), auditMap.get(UNDELETED_KEYS_LIST),\n          \n          \n            \n                    LOG.error(\"Keys delete failed. Volume:{}, Bucket:{}, DeletedKeys:{}, \" +\n          \n          \n            \n                            \"UnDeletedKeys:{}\", volumeName, bucketName,\n          \n          \n            \n                        auditMap.get(DELETED_KEYS_LIST), auditMap.get(UNDELETED_KEYS_LIST),", "author": "adoroszlai", "createdAt": "2020-07-12T05:45:59Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysDeleteRequest.java", "diffHunk": "@@ -116,99 +98,144 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n     OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n         getOmRequest());\n     OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n-    try {\n-      for (KeyArgs deleteKeyArgs : deleteKeyArgsList) {\n-        volumeName = deleteKeyArgs.getVolumeName();\n-        bucketName = deleteKeyArgs.getBucketName();\n-        keyName = deleteKeyArgs.getKeyName();\n-        String objectKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n-            keyName);\n-        OmKeyInfo omKeyInfo = omMetadataManager.getKeyTable().get(objectKey);\n-        omKeyInfoList.add(omKeyInfo);\n-        unDeletedKeys.add(omKeyInfo);\n-      }\n \n-      // Check if any of the key in the batch cannot be deleted. If exists the\n-      // batch will delete failed.\n-      for (KeyArgs deleteKeyArgs : deleteKeyArgsList) {\n-        volumeName = deleteKeyArgs.getVolumeName();\n-        bucketName = deleteKeyArgs.getBucketName();\n-        keyName = deleteKeyArgs.getKeyName();\n-        auditMap = buildKeyArgsAuditMap(deleteKeyArgs);\n-        // check Acl\n-        checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n-            IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n \n-        String objectKey = omMetadataManager.getOzoneKey(\n-            volumeName, bucketName, keyName);\n+    boolean acquiredLock =\n+        omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+\n+    int indexFailed = 0;\n+    int length = deleteKeys.size();\n+    OzoneManagerProtocolProtos.DeleteKeyArgs.Builder unDeletedKeys =\n+        OzoneManagerProtocolProtos.DeleteKeyArgs.newBuilder()\n+            .setVolumeName(volumeName).setBucketName(bucketName);\n+\n+    boolean deleteStatus = true;\n+    try {\n \n-        // Validate bucket and volume exists or not.\n-        validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+      // Validate bucket and volume exists or not.\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n \n+      for (indexFailed = 0; indexFailed < length; indexFailed++) {\n+        keyName = deleteKeyArgs.getKeys(indexFailed);\n+        String objectKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n+            keyName);\n         OmKeyInfo omKeyInfo = omMetadataManager.getKeyTable().get(objectKey);\n \n         if (omKeyInfo == null) {\n-          throw new OMException(\"Key not found: \" + keyName, KEY_NOT_FOUND);\n+          deleteStatus = false;\n+          LOG.error(\"Received a request to delete a Key does not exist {}\",\n+              objectKey);\n+          deleteKeys.remove(keyName);\n+          unDeletedKeys.addKeys(keyName);\n+          continue;\n         }\n \n-        // Check if this transaction is a replay of ratis logs.\n-        if (isReplay(ozoneManager, omKeyInfo, trxnLogIndex)) {\n-          // Replay implies the response has already been returned to\n-          // the client. So take no further action and return a dummy\n-          // OMClientResponse.\n-          throw new OMReplayException();\n+        try {\n+          // check Acl\n+          checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+              IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+          omKeyInfoList.add(omKeyInfo);\n+        } catch (Exception ex) {\n+          deleteStatus = false;\n+          LOG.error(\"Acl check failed for Key: {}\", objectKey, ex);\n+          deleteKeys.remove(keyName);\n+          unDeletedKeys.addKeys(keyName);\n         }\n       }\n \n+      // Mark all keys which can be deleted, in cache as deleted.\n+      for (OmKeyInfo omKeyInfo : omKeyInfoList) {\n+        omMetadataManager.getKeyTable().addCacheEntry(\n+            new CacheKey<>(omMetadataManager.getOzoneKey(volumeName, bucketName,\n+                omKeyInfo.getKeyName())),\n+            new CacheValue<>(Optional.absent(), trxnLogIndex));\n+      }\n+\n       omClientResponse = new OMKeysDeleteResponse(omResponse\n-          .setDeleteKeysResponse(DeleteKeysResponse.newBuilder()).build(),\n-          omKeyInfoList, trxnLogIndex, ozoneManager.isRatisEnabled());\n+          .setDeleteKeysResponse(DeleteKeysResponse.newBuilder()\n+              .setStatus(deleteStatus).setUnDeletedKeys(unDeletedKeys))\n+          .setStatus(deleteStatus ? OK : PARTIAL_DELETE)\n+          .setSuccess(deleteStatus).build(),\n+          omKeyInfoList, trxnLogIndex,\n+          ozoneManager.isRatisEnabled());\n+\n       result = Result.SUCCESS;\n+\n     } catch (IOException ex) {\n-      if (ex instanceof OMReplayException) {\n-        result = Result.REPLAY;\n-        omClientResponse = new OMKeyDeleteResponse(createReplayOMResponse(\n-            omResponse));\n-      } else {\n-        result = Result.FAILURE;\n-        exception = ex;\n-\n-        omClientResponse = new OMKeyDeleteResponse(\n-            createOperationKeysErrorOMResponse(omResponse, exception,\n-                unDeletedKeys));\n+      result = Result.FAILURE;\n+      exception = ex;\n+      createErrorOMResponse(omResponse, ex);\n+\n+      // reset deleteKeys as request failed.\n+      deleteKeys = new ArrayList<>();\n+      // Add all keys which are failed due to any other exception .\n+      for (int i = indexFailed; i < length; i++) {\n+        unDeletedKeys.addKeys(deleteKeyArgs.getKeys(i));\n       }\n \n+      omResponse.setDeleteKeysResponse(DeleteKeysResponse.newBuilder()\n+          .setStatus(false).setUnDeletedKeys(unDeletedKeys).build()).build();\n+      omClientResponse = new OMKeysDeleteResponse(omResponse.build());\n+\n     } finally {\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+      }\n       addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n           omDoubleBufferHelper);\n     }\n \n-    // Performing audit logging outside of the lock.\n-    if (result != Result.REPLAY) {\n-      auditLog(auditLogger, buildAuditMessage(\n-          OMAction.DELETE_KEY, auditMap, exception, userInfo));\n-    }\n+    auditMap = buildDeleteKeysAuditMap(volumeName, bucketName, deleteKeys,\n+        unDeletedKeys.getKeysList());\n+\n+    auditLog(auditLogger, buildAuditMessage(DELETE_KEYS, auditMap, exception,\n+        userInfo));\n+\n \n     switch (result) {\n     case SUCCESS:\n-      omMetrics.decNumKeys();\n-      LOG.debug(\"Key deleted. Volume:{}, Bucket:{}, Key:{}\", volumeName,\n-          bucketName, keyName);\n-      break;\n-    case REPLAY:\n-      LOG.debug(\"Replayed Transaction {} ignored. Request: {}\",\n-          trxnLogIndex, deleteKeyRequest);\n+      omMetrics.decNumKeys(deleteKeys.size());\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Keys delete success. Volume:{}, Bucket:{}, Keys:{}\",\n+            volumeName, bucketName, auditMap.get(DELETED_KEYS_LIST));\n+      }\n       break;\n     case FAILURE:\n+      omMetrics.decNumKeys(deleteKeys.size());\n       omMetrics.incNumKeyDeleteFails();\n-      LOG.error(\"Key delete failed. Volume:{}, Bucket:{}, Key{}.\" +\n-          \" Exception:{}\", volumeName, bucketName, keyName, exception);\n+      if (LOG.isDebugEnabled()) {\n+        LOG.error(\"Keys delete failed. Volume:{}, Bucket:{}, DeletedKey:{}, \" +\n+                \"UnDeletedKeys:{}\", volumeName, bucketName, keyName,\n+            auditMap.get(DELETED_KEYS_LIST), auditMap.get(UNDELETED_KEYS_LIST),", "originalCommit": "b46762e9cbf2a319ee95ac6d9f0fb50c9311ecff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzI3Mzc2MA==", "url": "https://github.com/apache/ozone/pull/1195#discussion_r453273760", "bodyText": "Nit: log level mismatch (isDebugEnabled vs. error).", "author": "adoroszlai", "createdAt": "2020-07-12T06:18:15Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeysDeleteRequest.java", "diffHunk": "@@ -116,99 +98,144 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n     OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n         getOmRequest());\n     OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n-    try {\n-      for (KeyArgs deleteKeyArgs : deleteKeyArgsList) {\n-        volumeName = deleteKeyArgs.getVolumeName();\n-        bucketName = deleteKeyArgs.getBucketName();\n-        keyName = deleteKeyArgs.getKeyName();\n-        String objectKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n-            keyName);\n-        OmKeyInfo omKeyInfo = omMetadataManager.getKeyTable().get(objectKey);\n-        omKeyInfoList.add(omKeyInfo);\n-        unDeletedKeys.add(omKeyInfo);\n-      }\n \n-      // Check if any of the key in the batch cannot be deleted. If exists the\n-      // batch will delete failed.\n-      for (KeyArgs deleteKeyArgs : deleteKeyArgsList) {\n-        volumeName = deleteKeyArgs.getVolumeName();\n-        bucketName = deleteKeyArgs.getBucketName();\n-        keyName = deleteKeyArgs.getKeyName();\n-        auditMap = buildKeyArgsAuditMap(deleteKeyArgs);\n-        // check Acl\n-        checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n-            IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n \n-        String objectKey = omMetadataManager.getOzoneKey(\n-            volumeName, bucketName, keyName);\n+    boolean acquiredLock =\n+        omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+\n+    int indexFailed = 0;\n+    int length = deleteKeys.size();\n+    OzoneManagerProtocolProtos.DeleteKeyArgs.Builder unDeletedKeys =\n+        OzoneManagerProtocolProtos.DeleteKeyArgs.newBuilder()\n+            .setVolumeName(volumeName).setBucketName(bucketName);\n+\n+    boolean deleteStatus = true;\n+    try {\n \n-        // Validate bucket and volume exists or not.\n-        validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+      // Validate bucket and volume exists or not.\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n \n+      for (indexFailed = 0; indexFailed < length; indexFailed++) {\n+        keyName = deleteKeyArgs.getKeys(indexFailed);\n+        String objectKey = omMetadataManager.getOzoneKey(volumeName, bucketName,\n+            keyName);\n         OmKeyInfo omKeyInfo = omMetadataManager.getKeyTable().get(objectKey);\n \n         if (omKeyInfo == null) {\n-          throw new OMException(\"Key not found: \" + keyName, KEY_NOT_FOUND);\n+          deleteStatus = false;\n+          LOG.error(\"Received a request to delete a Key does not exist {}\",\n+              objectKey);\n+          deleteKeys.remove(keyName);\n+          unDeletedKeys.addKeys(keyName);\n+          continue;\n         }\n \n-        // Check if this transaction is a replay of ratis logs.\n-        if (isReplay(ozoneManager, omKeyInfo, trxnLogIndex)) {\n-          // Replay implies the response has already been returned to\n-          // the client. So take no further action and return a dummy\n-          // OMClientResponse.\n-          throw new OMReplayException();\n+        try {\n+          // check Acl\n+          checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+              IAccessAuthorizer.ACLType.DELETE, OzoneObj.ResourceType.KEY);\n+          omKeyInfoList.add(omKeyInfo);\n+        } catch (Exception ex) {\n+          deleteStatus = false;\n+          LOG.error(\"Acl check failed for Key: {}\", objectKey, ex);\n+          deleteKeys.remove(keyName);\n+          unDeletedKeys.addKeys(keyName);\n         }\n       }\n \n+      // Mark all keys which can be deleted, in cache as deleted.\n+      for (OmKeyInfo omKeyInfo : omKeyInfoList) {\n+        omMetadataManager.getKeyTable().addCacheEntry(\n+            new CacheKey<>(omMetadataManager.getOzoneKey(volumeName, bucketName,\n+                omKeyInfo.getKeyName())),\n+            new CacheValue<>(Optional.absent(), trxnLogIndex));\n+      }\n+\n       omClientResponse = new OMKeysDeleteResponse(omResponse\n-          .setDeleteKeysResponse(DeleteKeysResponse.newBuilder()).build(),\n-          omKeyInfoList, trxnLogIndex, ozoneManager.isRatisEnabled());\n+          .setDeleteKeysResponse(DeleteKeysResponse.newBuilder()\n+              .setStatus(deleteStatus).setUnDeletedKeys(unDeletedKeys))\n+          .setStatus(deleteStatus ? OK : PARTIAL_DELETE)\n+          .setSuccess(deleteStatus).build(),\n+          omKeyInfoList, trxnLogIndex,\n+          ozoneManager.isRatisEnabled());\n+\n       result = Result.SUCCESS;\n+\n     } catch (IOException ex) {\n-      if (ex instanceof OMReplayException) {\n-        result = Result.REPLAY;\n-        omClientResponse = new OMKeyDeleteResponse(createReplayOMResponse(\n-            omResponse));\n-      } else {\n-        result = Result.FAILURE;\n-        exception = ex;\n-\n-        omClientResponse = new OMKeyDeleteResponse(\n-            createOperationKeysErrorOMResponse(omResponse, exception,\n-                unDeletedKeys));\n+      result = Result.FAILURE;\n+      exception = ex;\n+      createErrorOMResponse(omResponse, ex);\n+\n+      // reset deleteKeys as request failed.\n+      deleteKeys = new ArrayList<>();\n+      // Add all keys which are failed due to any other exception .\n+      for (int i = indexFailed; i < length; i++) {\n+        unDeletedKeys.addKeys(deleteKeyArgs.getKeys(i));\n       }\n \n+      omResponse.setDeleteKeysResponse(DeleteKeysResponse.newBuilder()\n+          .setStatus(false).setUnDeletedKeys(unDeletedKeys).build()).build();\n+      omClientResponse = new OMKeysDeleteResponse(omResponse.build());\n+\n     } finally {\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+      }\n       addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n           omDoubleBufferHelper);\n     }\n \n-    // Performing audit logging outside of the lock.\n-    if (result != Result.REPLAY) {\n-      auditLog(auditLogger, buildAuditMessage(\n-          OMAction.DELETE_KEY, auditMap, exception, userInfo));\n-    }\n+    auditMap = buildDeleteKeysAuditMap(volumeName, bucketName, deleteKeys,\n+        unDeletedKeys.getKeysList());\n+\n+    auditLog(auditLogger, buildAuditMessage(DELETE_KEYS, auditMap, exception,\n+        userInfo));\n+\n \n     switch (result) {\n     case SUCCESS:\n-      omMetrics.decNumKeys();\n-      LOG.debug(\"Key deleted. Volume:{}, Bucket:{}, Key:{}\", volumeName,\n-          bucketName, keyName);\n-      break;\n-    case REPLAY:\n-      LOG.debug(\"Replayed Transaction {} ignored. Request: {}\",\n-          trxnLogIndex, deleteKeyRequest);\n+      omMetrics.decNumKeys(deleteKeys.size());\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Keys delete success. Volume:{}, Bucket:{}, Keys:{}\",\n+            volumeName, bucketName, auditMap.get(DELETED_KEYS_LIST));\n+      }\n       break;\n     case FAILURE:\n+      omMetrics.decNumKeys(deleteKeys.size());\n       omMetrics.incNumKeyDeleteFails();\n-      LOG.error(\"Key delete failed. Volume:{}, Bucket:{}, Key{}.\" +\n-          \" Exception:{}\", volumeName, bucketName, keyName, exception);\n+      if (LOG.isDebugEnabled()) {\n+        LOG.error(\"Keys delete failed. Volume:{}, Bucket:{}, DeletedKey:{}, \" +", "originalCommit": "b46762e9cbf2a319ee95ac6d9f0fb50c9311ecff", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0cc9063e8f399b044e07d95b9b02d852921364a8", "url": "https://github.com/apache/ozone/commit/0cc9063e8f399b044e07d95b9b02d852921364a8", "message": "HDDS-3900. Fix OMKeyDeletesRequest.", "committedDate": "2020-07-14T04:50:13Z", "type": "commit"}, {"oid": "d7e052b1e34106d82bcbe91d5524756d0af81cb4", "url": "https://github.com/apache/ozone/commit/d7e052b1e34106d82bcbe91d5524756d0af81cb4", "message": "revert not required", "committedDate": "2020-07-14T04:50:14Z", "type": "commit"}, {"oid": "19f8971f39f8cf5d32ebc9d3c057b8f938b38e36", "url": "https://github.com/apache/ozone/commit/19f8971f39f8cf5d32ebc9d3c057b8f938b38e36", "message": "revert not needed", "committedDate": "2020-07-14T04:50:14Z", "type": "commit"}, {"oid": "48bf7d5533d079109cce4a7af9c73f396745b8d5", "url": "https://github.com/apache/ozone/commit/48bf7d5533d079109cce4a7af9c73f396745b8d5", "message": "use trxnLogIndex", "committedDate": "2020-07-14T04:50:14Z", "type": "commit"}, {"oid": "9b1a4c472c49a245506c422f3143773c67befe85", "url": "https://github.com/apache/ozone/commit/9b1a4c472c49a245506c422f3143773c67befe85", "message": "fix", "committedDate": "2020-07-14T04:50:14Z", "type": "commit"}, {"oid": "8311ea977e8faa011bd72e6a088998078eaa5a66", "url": "https://github.com/apache/ozone/commit/8311ea977e8faa011bd72e6a088998078eaa5a66", "message": "fix", "committedDate": "2020-07-14T04:50:14Z", "type": "commit"}, {"oid": "a0a8914178ce3d18350a11ffe7cab0214bce40ec", "url": "https://github.com/apache/ozone/commit/a0a8914178ce3d18350a11ffe7cab0214bce40ec", "message": "fix", "committedDate": "2020-07-14T04:50:15Z", "type": "commit"}, {"oid": "bbb59860d27c7baa8570995e83edc933aa9341c4", "url": "https://github.com/apache/ozone/commit/bbb59860d27c7baa8570995e83edc933aa9341c4", "message": "remove unneeded", "committedDate": "2020-07-14T04:50:15Z", "type": "commit"}, {"oid": "22e4b79e820d5c3bd5ce01302bce7f89c0156c1c", "url": "https://github.com/apache/ozone/commit/22e4b79e820d5c3bd5ce01302bce7f89c0156c1c", "message": "add back", "committedDate": "2020-07-14T04:50:15Z", "type": "commit"}, {"oid": "258dd0b46655a2c67e34b5e61400185f838f0770", "url": "https://github.com/apache/ozone/commit/258dd0b46655a2c67e34b5e61400185f838f0770", "message": "fix review bug", "committedDate": "2020-07-14T04:50:15Z", "type": "commit"}, {"oid": "400068d0adc928293aa740087f3811dbdb795924", "url": "https://github.com/apache/ozone/commit/400068d0adc928293aa740087f3811dbdb795924", "message": "Add tests", "committedDate": "2020-07-14T04:50:15Z", "type": "commit"}, {"oid": "f12d32b51f31ac957a2235bca7d5708ba062fa65", "url": "https://github.com/apache/ozone/commit/f12d32b51f31ac957a2235bca7d5708ba062fa65", "message": "fix sonar issue", "committedDate": "2020-07-14T04:50:15Z", "type": "commit"}, {"oid": "d1601b1bf7b19cc0fe77ec646f691e214f22c4b7", "url": "https://github.com/apache/ozone/commit/d1601b1bf7b19cc0fe77ec646f691e214f22c4b7", "message": "fix review comments", "committedDate": "2020-07-14T04:53:00Z", "type": "commit"}, {"oid": "d32f8580d41cbc3a4c61563b09b78c9e3ab0fc94", "url": "https://github.com/apache/ozone/commit/d32f8580d41cbc3a4c61563b09b78c9e3ab0fc94", "message": "rat check", "committedDate": "2020-07-14T04:53:00Z", "type": "commit"}, {"oid": "f883cd98fce50b46a4e975656e2dd835be8848df", "url": "https://github.com/apache/ozone/commit/f883cd98fce50b46a4e975656e2dd835be8848df", "message": "fix checkstyle", "committedDate": "2020-07-14T04:53:01Z", "type": "commit"}, {"oid": "769a4ef8b2a25862e3e2dcd03c91f2c34b7a8b96", "url": "https://github.com/apache/ozone/commit/769a4ef8b2a25862e3e2dcd03c91f2c34b7a8b96", "message": "fix issue in deletekey", "committedDate": "2020-07-14T04:53:01Z", "type": "commit"}, {"oid": "8ecb356269a7cf853c86e99bd65dedb453c8e97e", "url": "https://github.com/apache/ozone/commit/8ecb356269a7cf853c86e99bd65dedb453c8e97e", "message": "handle partial delete in response class\"", "committedDate": "2020-07-14T04:53:01Z", "type": "commit"}, {"oid": "ff294b6eee5db7794ffeb580569c846b096f475f", "url": "https://github.com/apache/ozone/commit/ff294b6eee5db7794ffeb580569c846b096f475f", "message": "fix TestResultCodes\"", "committedDate": "2020-07-14T04:53:27Z", "type": "commit"}, {"oid": "31917681dde181b3365cbc77c6f777f558275e7d", "url": "https://github.com/apache/ozone/commit/31917681dde181b3365cbc77c6f777f558275e7d", "message": "revert imports", "committedDate": "2020-07-14T04:53:28Z", "type": "commit"}, {"oid": "e2c2bcff4dbecd65b4b114e47d424746ec1da1f1", "url": "https://github.com/apache/ozone/commit/e2c2bcff4dbecd65b4b114e47d424746ec1da1f1", "message": "fix checkstyle", "committedDate": "2020-07-14T04:53:28Z", "type": "commit"}, {"oid": "b26df38ac077849825a91adeaf2d66e965171a80", "url": "https://github.com/apache/ozone/commit/b26df38ac077849825a91adeaf2d66e965171a80", "message": "remove intellij optimize import changes", "committedDate": "2020-07-14T04:53:28Z", "type": "commit"}, {"oid": "93841960201b518983d63cfedd4feef5dc61a9e3", "url": "https://github.com/apache/ozone/commit/93841960201b518983d63cfedd4feef5dc61a9e3", "message": "import change", "committedDate": "2020-07-14T04:53:28Z", "type": "commit"}, {"oid": "4eb9f74f8fedb9904a5d646a2c91f4bd3905ceb8", "url": "https://github.com/apache/ozone/commit/4eb9f74f8fedb9904a5d646a2c91f4bd3905ceb8", "message": "remove unchanged file", "committedDate": "2020-07-14T04:53:28Z", "type": "commit"}, {"oid": "5eac5832049d11c42e4acfdaa28a96aa490de915", "url": "https://github.com/apache/ozone/commit/5eac5832049d11c42e4acfdaa28a96aa490de915", "message": "cs", "committedDate": "2020-07-14T04:53:29Z", "type": "commit"}, {"oid": "3d65b7d4cbbde15d66ca1337bb1110cde8fdb4be", "url": "https://github.com/apache/ozone/commit/3d65b7d4cbbde15d66ca1337bb1110cde8fdb4be", "message": "fix tests", "committedDate": "2020-07-14T04:54:32Z", "type": "commit"}, {"oid": "077348e20b11959c5a104c700a7f8fa9bd6df27b", "url": "https://github.com/apache/ozone/commit/077348e20b11959c5a104c700a7f8fa9bd6df27b", "message": "fix cs", "committedDate": "2020-07-14T04:54:32Z", "type": "commit"}, {"oid": "3a342924747af8000eaf718d4059b6b62f0b3d47", "url": "https://github.com/apache/ozone/commit/3a342924747af8000eaf718d4059b6b62f0b3d47", "message": "address review comments", "committedDate": "2020-07-14T04:54:33Z", "type": "commit"}, {"oid": "006814ad6aa9de6714ea642d3887df339f859906", "url": "https://github.com/apache/ozone/commit/006814ad6aa9de6714ea642d3887df339f859906", "message": "fix metric mistake", "committedDate": "2020-07-14T04:54:33Z", "type": "commit"}, {"oid": "4c4ff0d2442bc9c054fa8aba8a6481828b60a6a3", "url": "https://github.com/apache/ozone/commit/4c4ff0d2442bc9c054fa8aba8a6481828b60a6a3", "message": "fix cs", "committedDate": "2020-07-14T04:54:33Z", "type": "commit"}, {"oid": "7ae63c6a2eaef7498a33715ff7b4c58669006bd0", "url": "https://github.com/apache/ozone/commit/7ae63c6a2eaef7498a33715ff7b4c58669006bd0", "message": "fix review comments", "committedDate": "2020-07-14T04:54:33Z", "type": "commit"}, {"oid": "7ae63c6a2eaef7498a33715ff7b4c58669006bd0", "url": "https://github.com/apache/ozone/commit/7ae63c6a2eaef7498a33715ff7b4c58669006bd0", "message": "fix review comments", "committedDate": "2020-07-14T04:54:33Z", "type": "forcePushed"}, {"oid": "41bce6f152ea20f6d295ddd3294fd115418deb27", "url": "https://github.com/apache/ozone/commit/41bce6f152ea20f6d295ddd3294fd115418deb27", "message": "trigger new CI check", "committedDate": "2020-07-14T07:35:09Z", "type": "commit"}, {"oid": "2b13bd231a746180c71777e510a26ee1c93f7fe9", "url": "https://github.com/apache/ozone/commit/2b13bd231a746180c71777e510a26ee1c93f7fe9", "message": "trigger new CI check", "committedDate": "2020-07-14T09:42:26Z", "type": "commit"}, {"oid": "2144af7364bce0ff1b51ff7bf2f436a4d19ea640", "url": "https://github.com/apache/ozone/commit/2144af7364bce0ff1b51ff7bf2f436a4d19ea640", "message": "trigger new CI check", "committedDate": "2020-07-14T13:23:51Z", "type": "commit"}, {"oid": "25a902e299107d642cfd944e408b3abb2289900a", "url": "https://github.com/apache/ozone/commit/25a902e299107d642cfd944e408b3abb2289900a", "message": "trigger new CI check", "committedDate": "2020-07-14T14:35:37Z", "type": "commit"}]}