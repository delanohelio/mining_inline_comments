{"pr_number": 438, "pr_title": "HDDS-2878. Refactor MiniOzoneLoadGenerator to add more load generators to chaos testing.", "pr_createdAt": "2020-01-12T13:32:50Z", "pr_url": "https://github.com/apache/ozone/pull/438", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA0MDExNQ==", "url": "https://github.com/apache/ozone/pull/438#discussion_r373040115", "bodyText": "Typo: defautl", "author": "nandakumar131", "createdAt": "2020-01-30T16:04:55Z", "path": "hadoop-ozone/fault-injection-test/mini-chaos-tests/src/test/java/org/apache/hadoop/ozone/loadgenerators/AgedLoadGenerator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.loadgenerators;\n+\n+import org.apache.commons.lang3.RandomUtils;\n+import org.apache.hadoop.ozone.MiniOzoneLoadGenerator;\n+import org.apache.hadoop.ozone.utils.LoadBucket;\n+import org.apache.hadoop.ozone.utils.TestProbability;\n+import org.apache.hadoop.util.ExitUtil;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Aged Load Generator for Ozone.\n+ *\n+ * This Load Generator reads and write key to an Ozone bucket.\n+ *\n+ * The defautl writes to read ratio is 10:90.", "originalCommit": "5b5f9acdd455b855639d2e071eac926543ac5fe4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA0MTI1OA==", "url": "https://github.com/apache/ozone/pull/438#discussion_r373041258", "bodyText": "Typo: Suffex", "author": "nandakumar131", "createdAt": "2020-01-30T16:06:52Z", "path": "hadoop-ozone/fault-injection-test/mini-chaos-tests/src/test/java/org/apache/hadoop/ozone/loadgenerators/AgedLoadGenerator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.loadgenerators;\n+\n+import org.apache.commons.lang3.RandomUtils;\n+import org.apache.hadoop.ozone.MiniOzoneLoadGenerator;\n+import org.apache.hadoop.ozone.utils.LoadBucket;\n+import org.apache.hadoop.ozone.utils.TestProbability;\n+import org.apache.hadoop.util.ExitUtil;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Aged Load Generator for Ozone.\n+ *\n+ * This Load Generator reads and write key to an Ozone bucket.\n+ *\n+ * The defautl writes to read ratio is 10:90.\n+ */\n+public class AgedLoadGenerator implements LoadGenerator {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(AgedLoadGenerator.class);\n+  private static String fileSuffex = \"aged\";", "originalCommit": "5b5f9acdd455b855639d2e071eac926543ac5fe4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA0NTk3Ng==", "url": "https://github.com/apache/ozone/pull/438#discussion_r373045976", "bodyText": "Typo: pluggable", "author": "nandakumar131", "createdAt": "2020-01-30T16:14:13Z", "path": "hadoop-ozone/fault-injection-test/mini-chaos-tests/src/test/java/org/apache/hadoop/ozone/loadgenerators/LoadExecutors.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.loadgenerators;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Load executors for Ozone, this class provides a pluggable", "originalCommit": "5b5f9acdd455b855639d2e071eac926543ac5fe4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA1NDc5MQ==", "url": "https://github.com/apache/ozone/pull/438#discussion_r373054791", "bodyText": "numClients actually mean the max number of buckets that will be used by RandomLoadGenerator ?\nCorrect me if I'm wrong, we got numThreads which actually means the number of client threads.", "author": "nandakumar131", "createdAt": "2020-01-30T16:28:42Z", "path": "hadoop-ozone/fault-injection-test/mini-chaos-tests/src/test/java/org/apache/hadoop/ozone/MiniOzoneLoadGenerator.java", "diffHunk": "@@ -47,212 +42,61 @@\n       LoggerFactory.getLogger(MiniOzoneLoadGenerator.class);\n \n   private static String keyNameDelimiter = \"_\";\n-\n-  private ThreadPoolExecutor writeExecutor;\n-  private int numThreads;\n-  // number of buffer to be allocated, each is allocated with length which\n-  // is multiple of 2, each buffer is populated with random data.\n-  private int numBuffers;\n-  private List<ByteBuffer> buffers;\n-\n-  private AtomicBoolean isIOThreadRunning;\n-\n-  private final List<LoadBucket> ozoneBuckets;\n-\n-  private final AtomicInteger agedFileWrittenIndex;\n-  private final ExecutorService agedFileExecutor;\n-  private final LoadBucket agedLoadBucket;\n-  private final TestProbability agedWriteProbability;\n-\n-  private final ThreadPoolExecutor fsExecutor;\n-  private final LoadBucket fsBucket;\n-\n-  MiniOzoneLoadGenerator(List<LoadBucket> bucket,\n-                         LoadBucket agedLoadBucket, LoadBucket fsBucket,\n-                         int numThreads, int numBuffers) {\n-    this.ozoneBuckets = bucket;\n-    this.numThreads = numThreads;\n-    this.numBuffers = numBuffers;\n-    this.writeExecutor = createExecutor();\n-\n-    this.agedFileWrittenIndex = new AtomicInteger(0);\n-    this.agedFileExecutor = Executors.newSingleThreadExecutor();\n-    this.agedLoadBucket = agedLoadBucket;\n-    this.agedWriteProbability = TestProbability.valueOf(10);\n-\n-    this.fsExecutor = createExecutor();\n-    this.fsBucket = fsBucket;\n-\n-    this.isIOThreadRunning = new AtomicBoolean(false);\n-\n-    // allocate buffers and populate random data.\n-    buffers = new ArrayList<>();\n-    for (int i = 0; i < numBuffers; i++) {\n-      int size = (int) StorageUnit.KB.toBytes(1 << i);\n-      ByteBuffer buffer = ByteBuffer.allocate(size);\n-      buffer.put(RandomUtils.nextBytes(size));\n-      buffers.add(buffer);\n-    }\n-  }\n-\n-  private ThreadPoolExecutor createExecutor() {\n-    ThreadPoolExecutor executor = new ThreadPoolExecutor(numThreads, numThreads,\n-        100, TimeUnit.SECONDS, new ArrayBlockingQueue<>(1024),\n-        new ThreadPoolExecutor.CallerRunsPolicy());\n-    executor.prestartAllCoreThreads();\n-    return executor;\n-\n-  }\n-\n-  // Start IO load on an Ozone bucket.\n-  private void load(long runTimeMillis) {\n-    long threadID = Thread.currentThread().getId();\n-    LOG.info(\"Started Mixed IO Thread:{}.\", threadID);\n-    String threadName = Thread.currentThread().getName();\n-    long startTime = Time.monotonicNow();\n-\n-    while (isIOThreadRunning.get() &&\n-        (Time.monotonicNow() < startTime + runTimeMillis)) {\n-      LoadBucket bucket =\n-          ozoneBuckets.get((int) (Math.random() * ozoneBuckets.size()));\n-      try {\n-        int index = RandomUtils.nextInt();\n-        ByteBuffer buffer = getBuffer(index);\n-        String keyName = getKeyName(index, threadName);\n-        bucket.writeKey(buffer, keyName);\n-\n-        bucket.readKey(buffer, keyName);\n-\n-        bucket.deleteKey(keyName);\n-      } catch (Exception e) {\n-        LOG.error(\"LOADGEN: Exiting due to exception\", e);\n-        break;\n-      }\n-    }\n-    // This will terminate other threads too.\n-    isIOThreadRunning.set(false);\n-    LOG.info(\"Terminating IO thread:{}.\", threadID);\n-  }\n-\n-  private Optional<Integer> randomKeyToRead() {\n-    int currentIndex = agedFileWrittenIndex.get();\n-    return currentIndex != 0\n-      ? Optional.of(RandomUtils.nextInt(0, currentIndex))\n-      : Optional.empty();\n-  }\n-\n-  private void startAgedLoad(long runTimeMillis) {\n-    long threadID = Thread.currentThread().getId();\n-    LOG.info(\"AGED LOADGEN: Started Aged IO Thread:{}.\", threadID);\n-    String threadName = Thread.currentThread().getName();\n-    long startTime = Time.monotonicNow();\n-\n-    while (isIOThreadRunning.get() &&\n-        (Time.monotonicNow() < startTime + runTimeMillis)) {\n-\n-      String keyName = null;\n-      try {\n-        if (agedWriteProbability.isTrue()) {\n-          int index = agedFileWrittenIndex.getAndIncrement();\n-          ByteBuffer buffer = getBuffer(index);\n-          keyName = getKeyName(index, threadName);\n-\n-          agedLoadBucket.writeKey(buffer, keyName);\n-        } else {\n-          Optional<Integer> index = randomKeyToRead();\n-          if (index.isPresent()) {\n-            ByteBuffer buffer = getBuffer(index.get());\n-            keyName = getKeyName(index.get(), threadName);\n-            agedLoadBucket.readKey(buffer, keyName);\n-          }\n-        }\n-      } catch (Throwable t) {\n-        LOG.error(\"AGED LOADGEN: {} Exiting due to exception\", keyName, t);\n-        break;\n-      }\n-    }\n-    // This will terminate other threads too.\n-    isIOThreadRunning.set(false);\n-    LOG.info(\"Terminating IO thread:{}.\", threadID);\n-  }\n-\n-  // Start IO load on an Ozone bucket.\n-  private void startFsLoad(long runTimeMillis) {\n-    long threadID = Thread.currentThread().getId();\n-    LOG.info(\"Started Filesystem IO Thread:{}.\", threadID);\n-    String threadName = Thread.currentThread().getName();\n-    long startTime = Time.monotonicNow();\n-\n-    while (isIOThreadRunning.get() &&\n-      (Time.monotonicNow() < startTime + runTimeMillis)) {\n-      try {\n-        int index = RandomUtils.nextInt();\n-        ByteBuffer buffer = getBuffer(index);\n-        String keyName = getKeyName(index, threadName);\n-        fsBucket.writeKey(true, buffer, keyName);\n-\n-        fsBucket.readKey(true, buffer, keyName);\n-\n-        fsBucket.deleteKey(true, keyName);\n-      } catch (Exception e) {\n-        LOG.error(\"LOADGEN: Exiting due to exception\", e);\n-        break;\n-      }\n+  private final List<LoadExecutors> loadExecutors;\n+\n+  MiniOzoneLoadGenerator(OzoneVolume volume, int numClients, int numThreads,", "originalCommit": "5b5f9acdd455b855639d2e071eac926543ac5fe4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY5NzE5Mw==", "url": "https://github.com/apache/ozone/pull/438#discussion_r392697193", "bodyText": "yes, thats write. numthreads is the number of threads used across all the buckets", "author": "mukul1987", "createdAt": "2020-03-15T17:59:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA1NDc5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA1NzkyMg==", "url": "https://github.com/apache/ozone/pull/438#discussion_r373057922", "bodyText": "The numThreads option given is used by all the generators separately. So if the numThreads value is 5, we will be ideally starting\n5 - RandomLoadGenerator Threads\n5 - AgedLoadGenerator Threads\n5 - FilesystemLoadGenerator Threads\nTotal of 15 threads, everything parallel?", "author": "nandakumar131", "createdAt": "2020-01-30T16:33:41Z", "path": "hadoop-ozone/fault-injection-test/mini-chaos-tests/src/test/java/org/apache/hadoop/ozone/MiniOzoneLoadGenerator.java", "diffHunk": "@@ -47,212 +42,61 @@\n       LoggerFactory.getLogger(MiniOzoneLoadGenerator.class);\n \n   private static String keyNameDelimiter = \"_\";\n-\n-  private ThreadPoolExecutor writeExecutor;\n-  private int numThreads;\n-  // number of buffer to be allocated, each is allocated with length which\n-  // is multiple of 2, each buffer is populated with random data.\n-  private int numBuffers;\n-  private List<ByteBuffer> buffers;\n-\n-  private AtomicBoolean isIOThreadRunning;\n-\n-  private final List<LoadBucket> ozoneBuckets;\n-\n-  private final AtomicInteger agedFileWrittenIndex;\n-  private final ExecutorService agedFileExecutor;\n-  private final LoadBucket agedLoadBucket;\n-  private final TestProbability agedWriteProbability;\n-\n-  private final ThreadPoolExecutor fsExecutor;\n-  private final LoadBucket fsBucket;\n-\n-  MiniOzoneLoadGenerator(List<LoadBucket> bucket,\n-                         LoadBucket agedLoadBucket, LoadBucket fsBucket,\n-                         int numThreads, int numBuffers) {\n-    this.ozoneBuckets = bucket;\n-    this.numThreads = numThreads;\n-    this.numBuffers = numBuffers;\n-    this.writeExecutor = createExecutor();\n-\n-    this.agedFileWrittenIndex = new AtomicInteger(0);\n-    this.agedFileExecutor = Executors.newSingleThreadExecutor();\n-    this.agedLoadBucket = agedLoadBucket;\n-    this.agedWriteProbability = TestProbability.valueOf(10);\n-\n-    this.fsExecutor = createExecutor();\n-    this.fsBucket = fsBucket;\n-\n-    this.isIOThreadRunning = new AtomicBoolean(false);\n-\n-    // allocate buffers and populate random data.\n-    buffers = new ArrayList<>();\n-    for (int i = 0; i < numBuffers; i++) {\n-      int size = (int) StorageUnit.KB.toBytes(1 << i);\n-      ByteBuffer buffer = ByteBuffer.allocate(size);\n-      buffer.put(RandomUtils.nextBytes(size));\n-      buffers.add(buffer);\n-    }\n-  }\n-\n-  private ThreadPoolExecutor createExecutor() {\n-    ThreadPoolExecutor executor = new ThreadPoolExecutor(numThreads, numThreads,\n-        100, TimeUnit.SECONDS, new ArrayBlockingQueue<>(1024),\n-        new ThreadPoolExecutor.CallerRunsPolicy());\n-    executor.prestartAllCoreThreads();\n-    return executor;\n-\n-  }\n-\n-  // Start IO load on an Ozone bucket.\n-  private void load(long runTimeMillis) {\n-    long threadID = Thread.currentThread().getId();\n-    LOG.info(\"Started Mixed IO Thread:{}.\", threadID);\n-    String threadName = Thread.currentThread().getName();\n-    long startTime = Time.monotonicNow();\n-\n-    while (isIOThreadRunning.get() &&\n-        (Time.monotonicNow() < startTime + runTimeMillis)) {\n-      LoadBucket bucket =\n-          ozoneBuckets.get((int) (Math.random() * ozoneBuckets.size()));\n-      try {\n-        int index = RandomUtils.nextInt();\n-        ByteBuffer buffer = getBuffer(index);\n-        String keyName = getKeyName(index, threadName);\n-        bucket.writeKey(buffer, keyName);\n-\n-        bucket.readKey(buffer, keyName);\n-\n-        bucket.deleteKey(keyName);\n-      } catch (Exception e) {\n-        LOG.error(\"LOADGEN: Exiting due to exception\", e);\n-        break;\n-      }\n-    }\n-    // This will terminate other threads too.\n-    isIOThreadRunning.set(false);\n-    LOG.info(\"Terminating IO thread:{}.\", threadID);\n-  }\n-\n-  private Optional<Integer> randomKeyToRead() {\n-    int currentIndex = agedFileWrittenIndex.get();\n-    return currentIndex != 0\n-      ? Optional.of(RandomUtils.nextInt(0, currentIndex))\n-      : Optional.empty();\n-  }\n-\n-  private void startAgedLoad(long runTimeMillis) {\n-    long threadID = Thread.currentThread().getId();\n-    LOG.info(\"AGED LOADGEN: Started Aged IO Thread:{}.\", threadID);\n-    String threadName = Thread.currentThread().getName();\n-    long startTime = Time.monotonicNow();\n-\n-    while (isIOThreadRunning.get() &&\n-        (Time.monotonicNow() < startTime + runTimeMillis)) {\n-\n-      String keyName = null;\n-      try {\n-        if (agedWriteProbability.isTrue()) {\n-          int index = agedFileWrittenIndex.getAndIncrement();\n-          ByteBuffer buffer = getBuffer(index);\n-          keyName = getKeyName(index, threadName);\n-\n-          agedLoadBucket.writeKey(buffer, keyName);\n-        } else {\n-          Optional<Integer> index = randomKeyToRead();\n-          if (index.isPresent()) {\n-            ByteBuffer buffer = getBuffer(index.get());\n-            keyName = getKeyName(index.get(), threadName);\n-            agedLoadBucket.readKey(buffer, keyName);\n-          }\n-        }\n-      } catch (Throwable t) {\n-        LOG.error(\"AGED LOADGEN: {} Exiting due to exception\", keyName, t);\n-        break;\n-      }\n-    }\n-    // This will terminate other threads too.\n-    isIOThreadRunning.set(false);\n-    LOG.info(\"Terminating IO thread:{}.\", threadID);\n-  }\n-\n-  // Start IO load on an Ozone bucket.\n-  private void startFsLoad(long runTimeMillis) {\n-    long threadID = Thread.currentThread().getId();\n-    LOG.info(\"Started Filesystem IO Thread:{}.\", threadID);\n-    String threadName = Thread.currentThread().getName();\n-    long startTime = Time.monotonicNow();\n-\n-    while (isIOThreadRunning.get() &&\n-      (Time.monotonicNow() < startTime + runTimeMillis)) {\n-      try {\n-        int index = RandomUtils.nextInt();\n-        ByteBuffer buffer = getBuffer(index);\n-        String keyName = getKeyName(index, threadName);\n-        fsBucket.writeKey(true, buffer, keyName);\n-\n-        fsBucket.readKey(true, buffer, keyName);\n-\n-        fsBucket.deleteKey(true, keyName);\n-      } catch (Exception e) {\n-        LOG.error(\"LOADGEN: Exiting due to exception\", e);\n-        break;\n-      }\n+  private final List<LoadExecutors> loadExecutors;\n+", "originalCommit": "5b5f9acdd455b855639d2e071eac926543ac5fe4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY5Njc2Ng==", "url": "https://github.com/apache/ozone/pull/438#discussion_r392696766", "bodyText": "yes", "author": "mukul1987", "createdAt": "2020-03-15T17:54:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA1NzkyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA1ODk5OA==", "url": "https://github.com/apache/ozone/pull/438#discussion_r373058998", "bodyText": "Why do we need to synchronize here?", "author": "nandakumar131", "createdAt": "2020-01-30T16:35:39Z", "path": "hadoop-ozone/fault-injection-test/mini-chaos-tests/src/test/java/org/apache/hadoop/ozone/loadgenerators/AgedLoadGenerator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.loadgenerators;\n+\n+import org.apache.commons.lang3.RandomUtils;\n+import org.apache.hadoop.ozone.MiniOzoneLoadGenerator;\n+import org.apache.hadoop.ozone.utils.LoadBucket;\n+import org.apache.hadoop.ozone.utils.TestProbability;\n+import org.apache.hadoop.util.ExitUtil;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Aged Load Generator for Ozone.\n+ *\n+ * This Load Generator reads and write key to an Ozone bucket.\n+ *\n+ * The defautl writes to read ratio is 10:90.\n+ */\n+public class AgedLoadGenerator implements LoadGenerator {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(AgedLoadGenerator.class);\n+  private static String fileSuffex = \"aged\";\n+\n+  private final AtomicInteger agedFileWrittenIndex;\n+  private final AtomicInteger agedFileAllocationIndex;\n+  private final LoadBucket agedLoadBucket;\n+  private final TestProbability agedWriteProbability;\n+  private final DataBuffer dataBuffer;\n+\n+  public AgedLoadGenerator(DataBuffer data, LoadBucket agedLoadBucket) {\n+    this.dataBuffer = data;\n+    this.agedFileWrittenIndex = new AtomicInteger(0);\n+    this.agedFileAllocationIndex = new AtomicInteger(0);\n+    this.agedLoadBucket = agedLoadBucket;\n+    this.agedWriteProbability = TestProbability.valueOf(10);\n+  }\n+\n+  public void startLoad(long runTimeMillis) {\n+    long threadID = Thread.currentThread().getId();\n+    LOG.info(\"AGED LOADGEN: Started Aged IO Thread:{}.\", threadID);\n+    long startTime = Time.monotonicNow();\n+\n+    while (Time.monotonicNow() < startTime + runTimeMillis) {\n+\n+      String keyName = null;\n+      try {\n+        if (agedWriteProbability.isTrue()) {\n+          synchronized (agedFileAllocationIndex) {", "originalCommit": "5b5f9acdd455b855639d2e071eac926543ac5fe4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjY5NzMyNw==", "url": "https://github.com/apache/ozone/pull/438#discussion_r392697327", "bodyText": "This agedFileWrittenIndex can increment for lets say file-4 before file-1 and that causes the read to fail as the file can not been written to already.", "author": "mukul1987", "createdAt": "2020-03-15T18:01:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA1ODk5OA=="}], "type": "inlineReview"}, {"oid": "51489c5aa4b6ed5113c8be708549a2aa78534316", "url": "https://github.com/apache/ozone/commit/51489c5aa4b6ed5113c8be708549a2aa78534316", "message": "fix review comments", "committedDate": "2020-03-15T18:05:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3MTM1OQ==", "url": "https://github.com/apache/ozone/pull/438#discussion_r394471359", "bodyText": "NIT: line 65-84 can be refactored to dedup the same create loadgenerator and added to load executors.", "author": "xiaoyuyao", "createdAt": "2020-03-18T16:16:26Z", "path": "hadoop-ozone/fault-injection-test/mini-chaos-tests/src/test/java/org/apache/hadoop/ozone/MiniOzoneLoadGenerator.java", "diffHunk": "@@ -47,212 +42,61 @@\n       LoggerFactory.getLogger(MiniOzoneLoadGenerator.class);\n \n   private static String keyNameDelimiter = \"_\";\n-\n-  private ThreadPoolExecutor writeExecutor;\n-  private int numThreads;\n-  // number of buffer to be allocated, each is allocated with length which\n-  // is multiple of 2, each buffer is populated with random data.\n-  private int numBuffers;\n-  private List<ByteBuffer> buffers;\n-\n-  private AtomicBoolean isIOThreadRunning;\n-\n-  private final List<LoadBucket> ozoneBuckets;\n-\n-  private final AtomicInteger agedFileWrittenIndex;\n-  private final ExecutorService agedFileExecutor;\n-  private final LoadBucket agedLoadBucket;\n-  private final TestProbability agedWriteProbability;\n-\n-  private final ThreadPoolExecutor fsExecutor;\n-  private final LoadBucket fsBucket;\n-\n-  MiniOzoneLoadGenerator(List<LoadBucket> bucket,\n-                         LoadBucket agedLoadBucket, LoadBucket fsBucket,\n-                         int numThreads, int numBuffers) {\n-    this.ozoneBuckets = bucket;\n-    this.numThreads = numThreads;\n-    this.numBuffers = numBuffers;\n-    this.writeExecutor = createExecutor();\n-\n-    this.agedFileWrittenIndex = new AtomicInteger(0);\n-    this.agedFileExecutor = Executors.newSingleThreadExecutor();\n-    this.agedLoadBucket = agedLoadBucket;\n-    this.agedWriteProbability = TestProbability.valueOf(10);\n-\n-    this.fsExecutor = createExecutor();\n-    this.fsBucket = fsBucket;\n-\n-    this.isIOThreadRunning = new AtomicBoolean(false);\n-\n-    // allocate buffers and populate random data.\n-    buffers = new ArrayList<>();\n-    for (int i = 0; i < numBuffers; i++) {\n-      int size = (int) StorageUnit.KB.toBytes(1 << i);\n-      ByteBuffer buffer = ByteBuffer.allocate(size);\n-      buffer.put(RandomUtils.nextBytes(size));\n-      buffers.add(buffer);\n-    }\n-  }\n-\n-  private ThreadPoolExecutor createExecutor() {\n-    ThreadPoolExecutor executor = new ThreadPoolExecutor(numThreads, numThreads,\n-        100, TimeUnit.SECONDS, new ArrayBlockingQueue<>(1024),\n-        new ThreadPoolExecutor.CallerRunsPolicy());\n-    executor.prestartAllCoreThreads();\n-    return executor;\n-\n-  }\n-\n-  // Start IO load on an Ozone bucket.\n-  private void load(long runTimeMillis) {\n-    long threadID = Thread.currentThread().getId();\n-    LOG.info(\"Started Mixed IO Thread:{}.\", threadID);\n-    String threadName = Thread.currentThread().getName();\n-    long startTime = Time.monotonicNow();\n-\n-    while (isIOThreadRunning.get() &&\n-        (Time.monotonicNow() < startTime + runTimeMillis)) {\n-      LoadBucket bucket =\n-          ozoneBuckets.get((int) (Math.random() * ozoneBuckets.size()));\n-      try {\n-        int index = RandomUtils.nextInt();\n-        ByteBuffer buffer = getBuffer(index);\n-        String keyName = getKeyName(index, threadName);\n-        bucket.writeKey(buffer, keyName);\n-\n-        bucket.readKey(buffer, keyName);\n-\n-        bucket.deleteKey(keyName);\n-      } catch (Exception e) {\n-        LOG.error(\"LOADGEN: Exiting due to exception\", e);\n-        break;\n-      }\n-    }\n-    // This will terminate other threads too.\n-    isIOThreadRunning.set(false);\n-    LOG.info(\"Terminating IO thread:{}.\", threadID);\n-  }\n-\n-  private Optional<Integer> randomKeyToRead() {\n-    int currentIndex = agedFileWrittenIndex.get();\n-    return currentIndex != 0\n-      ? Optional.of(RandomUtils.nextInt(0, currentIndex))\n-      : Optional.empty();\n-  }\n-\n-  private void startAgedLoad(long runTimeMillis) {\n-    long threadID = Thread.currentThread().getId();\n-    LOG.info(\"AGED LOADGEN: Started Aged IO Thread:{}.\", threadID);\n-    String threadName = Thread.currentThread().getName();\n-    long startTime = Time.monotonicNow();\n-\n-    while (isIOThreadRunning.get() &&\n-        (Time.monotonicNow() < startTime + runTimeMillis)) {\n-\n-      String keyName = null;\n-      try {\n-        if (agedWriteProbability.isTrue()) {\n-          int index = agedFileWrittenIndex.getAndIncrement();\n-          ByteBuffer buffer = getBuffer(index);\n-          keyName = getKeyName(index, threadName);\n-\n-          agedLoadBucket.writeKey(buffer, keyName);\n-        } else {\n-          Optional<Integer> index = randomKeyToRead();\n-          if (index.isPresent()) {\n-            ByteBuffer buffer = getBuffer(index.get());\n-            keyName = getKeyName(index.get(), threadName);\n-            agedLoadBucket.readKey(buffer, keyName);\n-          }\n-        }\n-      } catch (Throwable t) {\n-        LOG.error(\"AGED LOADGEN: {} Exiting due to exception\", keyName, t);\n-        break;\n-      }\n-    }\n-    // This will terminate other threads too.\n-    isIOThreadRunning.set(false);\n-    LOG.info(\"Terminating IO thread:{}.\", threadID);\n-  }\n-\n-  // Start IO load on an Ozone bucket.\n-  private void startFsLoad(long runTimeMillis) {\n-    long threadID = Thread.currentThread().getId();\n-    LOG.info(\"Started Filesystem IO Thread:{}.\", threadID);\n-    String threadName = Thread.currentThread().getName();\n-    long startTime = Time.monotonicNow();\n-\n-    while (isIOThreadRunning.get() &&\n-      (Time.monotonicNow() < startTime + runTimeMillis)) {\n-      try {\n-        int index = RandomUtils.nextInt();\n-        ByteBuffer buffer = getBuffer(index);\n-        String keyName = getKeyName(index, threadName);\n-        fsBucket.writeKey(true, buffer, keyName);\n-\n-        fsBucket.readKey(true, buffer, keyName);\n-\n-        fsBucket.deleteKey(true, keyName);\n-      } catch (Exception e) {\n-        LOG.error(\"LOADGEN: Exiting due to exception\", e);\n-        break;\n-      }\n+  private final List<LoadExecutors> loadExecutors;\n+\n+  MiniOzoneLoadGenerator(OzoneVolume volume, int numClients, int numThreads,\n+                         int numBuffers, OzoneConfiguration conf)\n+      throws Exception {\n+    DataBuffer buffer = new DataBuffer(numBuffers);\n+    loadExecutors = new ArrayList<>();\n+\n+    // Random Load\n+    String mixBucketName = RandomStringUtils.randomAlphabetic(10).toLowerCase();\n+    volume.createBucket(mixBucketName);\n+    List<LoadBucket> ozoneBuckets = new ArrayList<>(numClients);\n+    for (int i = 0; i < numClients; i++) {\n+      ozoneBuckets.add(new LoadBucket(volume.getBucket(mixBucketName),\n+          conf));\n     }\n-    // This will terminate other threads too.\n-    isIOThreadRunning.set(false);\n-    LOG.info(\"Terminating IO thread:{}.\", threadID);\n+    RandomLoadGenerator loadGenerator =\n+        new RandomLoadGenerator(buffer, ozoneBuckets);\n+    loadExecutors.add(new LoadExecutors(numThreads, loadGenerator));\n+\n+    // Aged Load", "originalCommit": "51489c5aa4b6ed5113c8be708549a2aa78534316", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTIxMzkzMg==", "url": "https://github.com/apache/ozone/pull/438#discussion_r395213932", "bodyText": "done", "author": "mukul1987", "createdAt": "2020-03-19T17:52:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ3MTM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4MzUxMQ==", "url": "https://github.com/apache/ozone/pull/438#discussion_r394483511", "bodyText": "Can we generate only 1 random byte array of size 1<<(numBuffers+10) and use List of ByteBuffer to wrap 0~1<<i part of the same array with wrap(byte[]\u00a0array, int\u00a0offset, int\u00a0length)?", "author": "xiaoyuyao", "createdAt": "2020-03-18T16:33:53Z", "path": "hadoop-ozone/fault-injection-test/mini-chaos-tests/src/test/java/org/apache/hadoop/ozone/loadgenerators/DataBuffer.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.loadgenerators;\n+\n+import org.apache.commons.lang3.RandomUtils;\n+import org.apache.hadoop.conf.StorageUnit;\n+\n+import java.nio.ByteBuffer;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * List of buffers used by the load generators.\n+ */\n+public class DataBuffer {\n+  private List<ByteBuffer> buffers;\n+  // number of buffer to be allocated, each is allocated with length which\n+  // is multiple of 2, each buffer is populated with random data.\n+  private int numBuffers;\n+\n+  public DataBuffer(int numBuffers) {\n+    // allocate buffers and populate random data.\n+    this.numBuffers = numBuffers;\n+    this.buffers = new ArrayList<>();\n+    for (int i = 0; i < numBuffers; i++) {", "originalCommit": "51489c5aa4b6ed5113c8be708549a2aa78534316", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ2Nzg4MA==", "url": "https://github.com/apache/ozone/pull/438#discussion_r396467880", "bodyText": "I am skipping his change for now as this will need a significant refactoring. Can I do this as a followup please.", "author": "mukul1987", "createdAt": "2020-03-23T13:55:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4MzUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxMTgzMg==", "url": "https://github.com/apache/ozone/pull/438#discussion_r394911832", "bodyText": "Would it make sense to use ThreadLocalRandom (also in other generators) to avoid contention among load generator threads?", "author": "adoroszlai", "createdAt": "2020-03-19T10:02:23Z", "path": "hadoop-ozone/fault-injection-test/mini-chaos-tests/src/test/java/org/apache/hadoop/ozone/loadgenerators/FilesystemLoadGenerator.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.loadgenerators;\n+\n+import org.apache.commons.lang3.RandomUtils;\n+import org.apache.hadoop.ozone.MiniOzoneLoadGenerator;\n+import org.apache.hadoop.ozone.utils.LoadBucket;\n+import org.apache.hadoop.util.ExitUtil;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Filesystem load generator for Ozone.\n+ *\n+ * This load generator read, writes and deletes data using the filesystem\n+ * apis.\n+ */\n+public class FilesystemLoadGenerator implements LoadGenerator {\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(FilesystemLoadGenerator.class);\n+\n+\n+  private final LoadBucket fsBucket;\n+  private final DataBuffer dataBuffer;\n+\n+  public FilesystemLoadGenerator(DataBuffer dataBuffer, LoadBucket fsBucket) {\n+    this.dataBuffer = dataBuffer;\n+    this.fsBucket = fsBucket;\n+  }\n+\n+  // Start IO load on an Ozone bucket.\n+  public void startLoad(long runTimeMillis) {\n+    long threadID = Thread.currentThread().getId();\n+    LOG.info(\"Started Filesystem IO Thread:{}.\", threadID);\n+    String threadName = Thread.currentThread().getName();\n+    long startTime = Time.monotonicNow();\n+\n+    while (Time.monotonicNow() < startTime + runTimeMillis) {\n+      try {\n+        int index = RandomUtils.nextInt();", "originalCommit": "51489c5aa4b6ed5113c8be708549a2aa78534316", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1ODc4MQ==", "url": "https://github.com/apache/ozone/pull/438#discussion_r396458781", "bodyText": "I haven't seen the contention anytime in any run. Also, Chaos cluster is a correctness check and not a performance run. so skipping this.", "author": "mukul1987", "createdAt": "2020-03-23T13:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkxMTgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkyOTkxMA==", "url": "https://github.com/apache/ozone/pull/438#discussion_r394929910", "bodyText": "Nit: can be moved to LoadGenerator.", "author": "adoroszlai", "createdAt": "2020-03-19T10:34:07Z", "path": "hadoop-ozone/fault-injection-test/mini-chaos-tests/src/test/java/org/apache/hadoop/ozone/MiniOzoneLoadGenerator.java", "diffHunk": "@@ -47,212 +42,61 @@\n       LoggerFactory.getLogger(MiniOzoneLoadGenerator.class);\n \n   private static String keyNameDelimiter = \"_\";\n-\n-  private ThreadPoolExecutor writeExecutor;\n-  private int numThreads;\n-  // number of buffer to be allocated, each is allocated with length which\n-  // is multiple of 2, each buffer is populated with random data.\n-  private int numBuffers;\n-  private List<ByteBuffer> buffers;\n-\n-  private AtomicBoolean isIOThreadRunning;\n-\n-  private final List<LoadBucket> ozoneBuckets;\n-\n-  private final AtomicInteger agedFileWrittenIndex;\n-  private final ExecutorService agedFileExecutor;\n-  private final LoadBucket agedLoadBucket;\n-  private final TestProbability agedWriteProbability;\n-\n-  private final ThreadPoolExecutor fsExecutor;\n-  private final LoadBucket fsBucket;\n-\n-  MiniOzoneLoadGenerator(List<LoadBucket> bucket,\n-                         LoadBucket agedLoadBucket, LoadBucket fsBucket,\n-                         int numThreads, int numBuffers) {\n-    this.ozoneBuckets = bucket;\n-    this.numThreads = numThreads;\n-    this.numBuffers = numBuffers;\n-    this.writeExecutor = createExecutor();\n-\n-    this.agedFileWrittenIndex = new AtomicInteger(0);\n-    this.agedFileExecutor = Executors.newSingleThreadExecutor();\n-    this.agedLoadBucket = agedLoadBucket;\n-    this.agedWriteProbability = TestProbability.valueOf(10);\n-\n-    this.fsExecutor = createExecutor();\n-    this.fsBucket = fsBucket;\n-\n-    this.isIOThreadRunning = new AtomicBoolean(false);\n-\n-    // allocate buffers and populate random data.\n-    buffers = new ArrayList<>();\n-    for (int i = 0; i < numBuffers; i++) {\n-      int size = (int) StorageUnit.KB.toBytes(1 << i);\n-      ByteBuffer buffer = ByteBuffer.allocate(size);\n-      buffer.put(RandomUtils.nextBytes(size));\n-      buffers.add(buffer);\n-    }\n-  }\n-\n-  private ThreadPoolExecutor createExecutor() {\n-    ThreadPoolExecutor executor = new ThreadPoolExecutor(numThreads, numThreads,\n-        100, TimeUnit.SECONDS, new ArrayBlockingQueue<>(1024),\n-        new ThreadPoolExecutor.CallerRunsPolicy());\n-    executor.prestartAllCoreThreads();\n-    return executor;\n-\n-  }\n-\n-  // Start IO load on an Ozone bucket.\n-  private void load(long runTimeMillis) {\n-    long threadID = Thread.currentThread().getId();\n-    LOG.info(\"Started Mixed IO Thread:{}.\", threadID);\n-    String threadName = Thread.currentThread().getName();\n-    long startTime = Time.monotonicNow();\n-\n-    while (isIOThreadRunning.get() &&\n-        (Time.monotonicNow() < startTime + runTimeMillis)) {\n-      LoadBucket bucket =\n-          ozoneBuckets.get((int) (Math.random() * ozoneBuckets.size()));\n-      try {\n-        int index = RandomUtils.nextInt();\n-        ByteBuffer buffer = getBuffer(index);\n-        String keyName = getKeyName(index, threadName);\n-        bucket.writeKey(buffer, keyName);\n-\n-        bucket.readKey(buffer, keyName);\n-\n-        bucket.deleteKey(keyName);\n-      } catch (Exception e) {\n-        LOG.error(\"LOADGEN: Exiting due to exception\", e);\n-        break;\n-      }\n-    }\n-    // This will terminate other threads too.\n-    isIOThreadRunning.set(false);\n-    LOG.info(\"Terminating IO thread:{}.\", threadID);\n-  }\n-\n-  private Optional<Integer> randomKeyToRead() {\n-    int currentIndex = agedFileWrittenIndex.get();\n-    return currentIndex != 0\n-      ? Optional.of(RandomUtils.nextInt(0, currentIndex))\n-      : Optional.empty();\n-  }\n-\n-  private void startAgedLoad(long runTimeMillis) {\n-    long threadID = Thread.currentThread().getId();\n-    LOG.info(\"AGED LOADGEN: Started Aged IO Thread:{}.\", threadID);\n-    String threadName = Thread.currentThread().getName();\n-    long startTime = Time.monotonicNow();\n-\n-    while (isIOThreadRunning.get() &&\n-        (Time.monotonicNow() < startTime + runTimeMillis)) {\n-\n-      String keyName = null;\n-      try {\n-        if (agedWriteProbability.isTrue()) {\n-          int index = agedFileWrittenIndex.getAndIncrement();\n-          ByteBuffer buffer = getBuffer(index);\n-          keyName = getKeyName(index, threadName);\n-\n-          agedLoadBucket.writeKey(buffer, keyName);\n-        } else {\n-          Optional<Integer> index = randomKeyToRead();\n-          if (index.isPresent()) {\n-            ByteBuffer buffer = getBuffer(index.get());\n-            keyName = getKeyName(index.get(), threadName);\n-            agedLoadBucket.readKey(buffer, keyName);\n-          }\n-        }\n-      } catch (Throwable t) {\n-        LOG.error(\"AGED LOADGEN: {} Exiting due to exception\", keyName, t);\n-        break;\n-      }\n-    }\n-    // This will terminate other threads too.\n-    isIOThreadRunning.set(false);\n-    LOG.info(\"Terminating IO thread:{}.\", threadID);\n-  }\n-\n-  // Start IO load on an Ozone bucket.\n-  private void startFsLoad(long runTimeMillis) {\n-    long threadID = Thread.currentThread().getId();\n-    LOG.info(\"Started Filesystem IO Thread:{}.\", threadID);\n-    String threadName = Thread.currentThread().getName();\n-    long startTime = Time.monotonicNow();\n-\n-    while (isIOThreadRunning.get() &&\n-      (Time.monotonicNow() < startTime + runTimeMillis)) {\n-      try {\n-        int index = RandomUtils.nextInt();\n-        ByteBuffer buffer = getBuffer(index);\n-        String keyName = getKeyName(index, threadName);\n-        fsBucket.writeKey(true, buffer, keyName);\n-\n-        fsBucket.readKey(true, buffer, keyName);\n-\n-        fsBucket.deleteKey(true, keyName);\n-      } catch (Exception e) {\n-        LOG.error(\"LOADGEN: Exiting due to exception\", e);\n-        break;\n-      }\n+  private final List<LoadExecutors> loadExecutors;\n+\n+  MiniOzoneLoadGenerator(OzoneVolume volume, int numClients, int numThreads,\n+                         int numBuffers, OzoneConfiguration conf)\n+      throws Exception {\n+    DataBuffer buffer = new DataBuffer(numBuffers);\n+    loadExecutors = new ArrayList<>();\n+\n+    // Random Load\n+    String mixBucketName = RandomStringUtils.randomAlphabetic(10).toLowerCase();\n+    volume.createBucket(mixBucketName);\n+    List<LoadBucket> ozoneBuckets = new ArrayList<>(numClients);\n+    for (int i = 0; i < numClients; i++) {\n+      ozoneBuckets.add(new LoadBucket(volume.getBucket(mixBucketName),\n+          conf));\n     }\n-    // This will terminate other threads too.\n-    isIOThreadRunning.set(false);\n-    LOG.info(\"Terminating IO thread:{}.\", threadID);\n+    RandomLoadGenerator loadGenerator =\n+        new RandomLoadGenerator(buffer, ozoneBuckets);\n+    loadExecutors.add(new LoadExecutors(numThreads, loadGenerator));\n+\n+    // Aged Load\n+    String agedBucketName =\n+        RandomStringUtils.randomAlphabetic(10).toLowerCase();\n+    volume.createBucket(agedBucketName);\n+    LoadBucket agedLoadBucket =\n+        new LoadBucket(volume.getBucket(agedBucketName), conf);\n+    AgedLoadGenerator agedLoadGenerator =\n+        new AgedLoadGenerator(buffer, agedLoadBucket);\n+    loadExecutors.add(new LoadExecutors(numThreads, agedLoadGenerator));\n+\n+    //Filesystem Load\n+    String fsBucketName =\n+        RandomStringUtils.randomAlphabetic(10).toLowerCase();\n+\n+    volume.createBucket(fsBucketName);\n+    LoadBucket fsBucket =\n+        new LoadBucket(volume.getBucket(fsBucketName), conf);\n+    FilesystemLoadGenerator filesystemLoadGenerator =\n+        new FilesystemLoadGenerator(buffer, fsBucket);\n+    loadExecutors.add(new LoadExecutors(numThreads, filesystemLoadGenerator));\n   }\n \n   void startIO(long time, TimeUnit timeUnit) {\n-    List<CompletableFuture<Void>> writeFutures = new ArrayList<>();\n-    LOG.info(\"Starting MiniOzoneLoadGenerator for time {}:{} with {} buffers \" +\n-            \"and {} threads\", time, timeUnit, numBuffers, numThreads);\n-    if (isIOThreadRunning.compareAndSet(false, true)) {\n-      // Start the IO thread\n-      for (int i = 0; i < numThreads; i++) {\n-        writeFutures.add(\n-            CompletableFuture.runAsync(() -> load(timeUnit.toMillis(time)),\n-                writeExecutor));\n-      }\n-\n-      for (int i = 0; i < numThreads; i++) {\n-        writeFutures.add(\n-            CompletableFuture.runAsync(() -> startAgedLoad(\n-                timeUnit.toMillis(time)), agedFileExecutor));\n-      }\n-\n-      for (int i = 0; i < numThreads; i++) {\n-        writeFutures.add(\n-            CompletableFuture.runAsync(() -> startFsLoad(\n-              timeUnit.toMillis(time)), fsExecutor));\n-      }\n-\n-      // Wait for IO to complete\n-      for (CompletableFuture<Void> f : writeFutures) {\n-        try {\n-          f.get();\n-        } catch (Throwable t) {\n-          LOG.error(\"startIO failed with exception\", t);\n-        }\n-      }\n-    }\n-  }\n-\n-  public void shutdownLoadGenerator() {\n-    try {\n-      writeExecutor.shutdown();\n-      writeExecutor.awaitTermination(1, TimeUnit.DAYS);\n-    } catch (Exception e) {\n-      LOG.error(\"error while closing \", e);\n-    }\n+    LOG.info(\"Starting MiniOzoneLoadGenerator for time {}:{}\", time, timeUnit);\n+    long runTime = timeUnit.toMillis(time);\n+    // start and wait for executors to finish\n+    loadExecutors.forEach(le -> le.startLoad(runTime));\n+    loadExecutors.forEach(LoadExecutors::waitForCompletion);\n   }\n \n-  private ByteBuffer getBuffer(int keyIndex) {\n-    return buffers.get(keyIndex % numBuffers);\n+  void shutdownLoadGenerator() {\n+    loadExecutors.forEach(LoadExecutors::shutdown);\n   }\n \n-  private String getKeyName(int keyIndex, String threadName) {\n-    return threadName + keyNameDelimiter + keyIndex;\n+  public static String getKeyName(int keyIndex, String prefix) {\n+    return prefix + keyNameDelimiter + keyIndex;\n   }", "originalCommit": "51489c5aa4b6ed5113c8be708549a2aa78534316", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjQ1NDc3OQ==", "url": "https://github.com/apache/ozone/pull/438#discussion_r396454779", "bodyText": "done", "author": "mukul1987", "createdAt": "2020-03-23T13:36:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkyOTkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkzMzc0Mw==", "url": "https://github.com/apache/ozone/pull/438#discussion_r394933743", "bodyText": "System#nanoTime says timestamps should be compared in the form: t1 - t0 < ..., so I think this should be:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                while (Time.monotonicNow() < startTime + runTimeMillis) {\n          \n          \n            \n                while (Time.monotonicNow() - startTime < runTimeMillis) {", "author": "adoroszlai", "createdAt": "2020-03-19T10:41:20Z", "path": "hadoop-ozone/fault-injection-test/mini-chaos-tests/src/test/java/org/apache/hadoop/ozone/loadgenerators/AgedLoadGenerator.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.loadgenerators;\n+\n+import org.apache.commons.lang3.RandomUtils;\n+import org.apache.hadoop.ozone.MiniOzoneLoadGenerator;\n+import org.apache.hadoop.ozone.utils.LoadBucket;\n+import org.apache.hadoop.ozone.utils.TestProbability;\n+import org.apache.hadoop.util.ExitUtil;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.nio.ByteBuffer;\n+import java.util.Optional;\n+import java.util.concurrent.atomic.AtomicInteger;\n+\n+/**\n+ * Aged Load Generator for Ozone.\n+ *\n+ * This Load Generator reads and write key to an Ozone bucket.\n+ *\n+ * The default writes to read ratio is 10:90.\n+ */\n+public class AgedLoadGenerator implements LoadGenerator {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(AgedLoadGenerator.class);\n+  private static String agedSuffix = \"aged\";\n+\n+  private final AtomicInteger agedFileWrittenIndex;\n+  private final AtomicInteger agedFileAllocationIndex;\n+  private final LoadBucket agedLoadBucket;\n+  private final TestProbability agedWriteProbability;\n+  private final DataBuffer dataBuffer;\n+\n+  public AgedLoadGenerator(DataBuffer data, LoadBucket agedLoadBucket) {\n+    this.dataBuffer = data;\n+    this.agedFileWrittenIndex = new AtomicInteger(0);\n+    this.agedFileAllocationIndex = new AtomicInteger(0);\n+    this.agedLoadBucket = agedLoadBucket;\n+    this.agedWriteProbability = TestProbability.valueOf(10);\n+  }\n+\n+  public void startLoad(long runTimeMillis) {\n+    long threadID = Thread.currentThread().getId();\n+    LOG.info(\"AGED LOADGEN: Started Aged IO Thread:{}.\", threadID);\n+    long startTime = Time.monotonicNow();\n+\n+    while (Time.monotonicNow() < startTime + runTimeMillis) {", "originalCommit": "51489c5aa4b6ed5113c8be708549a2aa78534316", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI5OTg2Nw==", "url": "https://github.com/apache/ozone/pull/438#discussion_r396299867", "bodyText": "done", "author": "mukul1987", "createdAt": "2020-03-23T09:06:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkzMzc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDkzNzYyMg==", "url": "https://github.com/apache/ozone/pull/438#discussion_r394937622", "bodyText": "Can you please extract common structure from all 3 generators?  Only <perform operation> is changing.\npublic void startLoad(long runTimeMillis) {\n  ...\n  while (...) {\n    try {\n      <perform operation>\n    } catch (...) {\n      ..\n    }\n  }\n}", "author": "adoroszlai", "createdAt": "2020-03-19T10:48:19Z", "path": "hadoop-ozone/fault-injection-test/mini-chaos-tests/src/test/java/org/apache/hadoop/ozone/loadgenerators/RandomLoadGenerator.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.loadgenerators;\n+\n+import org.apache.commons.lang3.RandomUtils;\n+import org.apache.hadoop.ozone.MiniOzoneLoadGenerator;\n+import org.apache.hadoop.ozone.utils.LoadBucket;\n+import org.apache.hadoop.util.ExitUtil;\n+import org.apache.hadoop.util.Time;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.nio.ByteBuffer;\n+import java.util.List;\n+\n+/**\n+ * Random load generator which writes, read and deletes keys from\n+ * the bucket.\n+ */\n+public class RandomLoadGenerator implements LoadGenerator {\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(RandomLoadGenerator.class);\n+\n+  private final List<LoadBucket> ozoneBuckets;\n+  private final DataBuffer dataBuffer;\n+\n+  public RandomLoadGenerator(DataBuffer dataBuffer, List<LoadBucket> buckets) {\n+    this.ozoneBuckets = buckets;\n+    this.dataBuffer = dataBuffer;\n+  }\n+\n+  // Start IO load on an Ozone bucket.\n+  public void startLoad(long runTimeMillis) {\n+    long threadID = Thread.currentThread().getId();\n+    LOG.info(\"Started Mixed IO Thread:{}.\", threadID);\n+    String threadName = Thread.currentThread().getName();\n+    long startTime = Time.monotonicNow();\n+\n+    while (Time.monotonicNow() < startTime + runTimeMillis) {\n+      LoadBucket bucket =\n+          ozoneBuckets.get((int) (Math.random() * ozoneBuckets.size()));\n+      try {\n+        int index = RandomUtils.nextInt();\n+        ByteBuffer buffer = dataBuffer.getBuffer(index);\n+        String keyName = MiniOzoneLoadGenerator.getKeyName(index, threadName);\n+        bucket.writeKey(buffer, keyName);\n+\n+        bucket.readKey(buffer, keyName);\n+\n+        bucket.deleteKey(keyName);\n+      } catch (Throwable t) {\n+        LOG.error(\"LOADGEN: Exiting due to exception\", t);\n+        ExitUtil.terminate(new ExitUtil.ExitException(3, t));\n+      }\n+    }\n+  }", "originalCommit": "51489c5aa4b6ed5113c8be708549a2aa78534316", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk0Mjg5Mg==", "url": "https://github.com/apache/ozone/pull/438#discussion_r394942892", "bodyText": "Since the number of threads (both core and max) and number of tasks is the same, do we need to specify keepAliveTime, queue limit and policy?  I don't think these parameters will be applied in any case.  I think using Executors.newFixedThreadPool(numThreads) would be simpler.  Sure, ExecutorService provides no way to prestart threads, but this is not a short-running performance test, so the overhead of starting threads as tasks are added does not seem to matter.", "author": "adoroszlai", "createdAt": "2020-03-19T10:57:59Z", "path": "hadoop-ozone/fault-injection-test/mini-chaos-tests/src/test/java/org/apache/hadoop/ozone/loadgenerators/LoadExecutors.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.loadgenerators;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+/**\n+ * Load executors for Ozone, this class provides a plugable\n+ * executor for different load generators.\n+ */\n+public class LoadExecutors {\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(LoadExecutors.class);\n+\n+  private final LoadGenerator generator;\n+  private final int numThreads;\n+  private final ThreadPoolExecutor executor;\n+  private final List<CompletableFuture<Void>> futures = new ArrayList<>();\n+\n+  public LoadExecutors(int numThreads, LoadGenerator generator) {\n+    this.numThreads = numThreads;\n+    this.generator = generator;\n+    this.executor = new ThreadPoolExecutor(numThreads, numThreads,\n+        100, TimeUnit.SECONDS, new ArrayBlockingQueue<>(1024),\n+        new ThreadPoolExecutor.CallerRunsPolicy());", "originalCommit": "51489c5aa4b6ed5113c8be708549a2aa78534316", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjI5Nzc2NQ==", "url": "https://github.com/apache/ozone/pull/438#discussion_r396297765", "bodyText": "done", "author": "mukul1987", "createdAt": "2020-03-23T09:02:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDk0Mjg5Mg=="}], "type": "inlineReview"}, {"oid": "235ff220c6738a8f46ee109cc296dd02b507b1d7", "url": "https://github.com/apache/ozone/commit/235ff220c6738a8f46ee109cc296dd02b507b1d7", "message": "address review comments", "committedDate": "2020-03-19T17:55:50Z", "type": "forcePushed"}, {"oid": "03206f91753b633a77f8c4b35091881fb4dc50c4", "url": "https://github.com/apache/ozone/commit/03206f91753b633a77f8c4b35091881fb4dc50c4", "message": "fix checkstyle", "committedDate": "2020-03-23T14:16:00Z", "type": "forcePushed"}, {"oid": "bdb4a32e8a584f74b82792df3bc3cabdcd589c07", "url": "https://github.com/apache/ozone/commit/bdb4a32e8a584f74b82792df3bc3cabdcd589c07", "message": "HDDS-2878. Refactor MiniOzoneLoadGenerator to add more load generators to chaos testing.", "committedDate": "2020-03-23T14:30:27Z", "type": "commit"}, {"oid": "17b6494999ee5e76a5e3eb36a373a28be935176f", "url": "https://github.com/apache/ozone/commit/17b6494999ee5e76a5e3eb36a373a28be935176f", "message": "fix checkstyle issues", "committedDate": "2020-03-23T14:30:27Z", "type": "commit"}, {"oid": "a1426459ce45a4c3c0189f2cc6b6f44a184260b8", "url": "https://github.com/apache/ozone/commit/a1426459ce45a4c3c0189f2cc6b6f44a184260b8", "message": "fix review comments", "committedDate": "2020-03-23T14:30:28Z", "type": "commit"}, {"oid": "fa0535afef472017d9940a71cc98724b18c6bf0f", "url": "https://github.com/apache/ozone/commit/fa0535afef472017d9940a71cc98724b18c6bf0f", "message": "address review comments", "committedDate": "2020-03-23T14:30:28Z", "type": "commit"}, {"oid": "3ac706adb358fc4b415e6d195dfe60f15952f87e", "url": "https://github.com/apache/ozone/commit/3ac706adb358fc4b415e6d195dfe60f15952f87e", "message": "address review comments", "committedDate": "2020-03-23T14:30:28Z", "type": "commit"}, {"oid": "8c9a42de0a1698a5e9ecf257ab13636bce164d77", "url": "https://github.com/apache/ozone/commit/8c9a42de0a1698a5e9ecf257ab13636bce164d77", "message": "fix checkstyle", "committedDate": "2020-03-23T14:30:28Z", "type": "commit"}, {"oid": "8c9a42de0a1698a5e9ecf257ab13636bce164d77", "url": "https://github.com/apache/ozone/commit/8c9a42de0a1698a5e9ecf257ab13636bce164d77", "message": "fix checkstyle", "committedDate": "2020-03-23T14:30:28Z", "type": "forcePushed"}]}