{"pr_number": 450, "pr_title": "HDDS-2893. Handle replay of KeyPurge Request.", "pr_createdAt": "2020-01-16T15:16:05Z", "pr_url": "https://github.com/apache/ozone/pull/450", "timeline": [{"oid": "f0a9ba7849112d8e497e47e0d8c51841e9da41c5", "url": "https://github.com/apache/ozone/commit/f0a9ba7849112d8e497e47e0d8c51841e9da41c5", "message": "Unit test for KeyPurgeRequest replay", "committedDate": "2020-01-28T21:49:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEyODEzMQ==", "url": "https://github.com/apache/ozone/pull/450#discussion_r372128131", "bodyText": "objectID  -> updatedID", "author": "bharatviswa504", "createdAt": "2020-01-29T00:07:48Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyPurgeRequest.java", "diffHunk": "@@ -49,25 +57,76 @@ public OMKeyPurgeRequest(OMRequest omRequest) {\n   public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n       long transactionLogIndex,\n       OzoneManagerDoubleBufferHelper ozoneManagerDoubleBufferHelper) {\n-    PurgeKeysRequest purgeKeysRequest = getOmRequest().getPurgeKeysRequest();\n-    List<String> purgeKeysList = purgeKeysRequest.getKeysList();\n \n-    LOG.debug(\"Processing Purge Keys for {} number of keys.\",\n-        purgeKeysList.size());\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+\n+    PurgeKeysRequest purgeKeysRequest = getOmRequest().getPurgeKeysRequest();\n+    List<DeletedKeys> bucketDeletedKeysList = purgeKeysRequest\n+        .getDeletedKeysList();\n+    List<String> keysToBePurgedList = new ArrayList<>();\n \n-    OMResponse omResponse = OMResponse.newBuilder()\n+    OMResponse.Builder omResponse = OMResponse.newBuilder()\n         .setCmdType(Type.PurgeKeys)\n-        .setPurgeKeysResponse(\n-            OzoneManagerProtocolProtos.PurgeKeysResponse.newBuilder().build())\n+        .setPurgeKeysResponse(PurgeKeysResponse.newBuilder().build())\n         .setStatus(Status.OK)\n-        .setSuccess(true)\n-        .build();\n+        .setSuccess(true);\n+    OMClientResponse omClientResponse = null;\n+    boolean success = true;\n+    IOException exception = null;\n+\n+    // Filter the keys that objectID > transactionLogIndex. This is done so", "originalCommit": "f0a9ba7849112d8e497e47e0d8c51841e9da41c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjEzOTE4Nw==", "url": "https://github.com/apache/ozone/pull/450#discussion_r372139187", "bodyText": "As discussed offline.\nHere there is a chance of not deleting the old keyInfo from RepeatedKeyInfo when a new Key with transaction ID greater than the transactionLogIndex of purgeKeyRequest.", "author": "bharatviswa504", "createdAt": "2020-01-29T00:51:38Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyPurgeRequest.java", "diffHunk": "@@ -49,25 +57,76 @@ public OMKeyPurgeRequest(OMRequest omRequest) {\n   public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n       long transactionLogIndex,\n       OzoneManagerDoubleBufferHelper ozoneManagerDoubleBufferHelper) {\n-    PurgeKeysRequest purgeKeysRequest = getOmRequest().getPurgeKeysRequest();\n-    List<String> purgeKeysList = purgeKeysRequest.getKeysList();\n \n-    LOG.debug(\"Processing Purge Keys for {} number of keys.\",\n-        purgeKeysList.size());\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+\n+    PurgeKeysRequest purgeKeysRequest = getOmRequest().getPurgeKeysRequest();\n+    List<DeletedKeys> bucketDeletedKeysList = purgeKeysRequest\n+        .getDeletedKeysList();\n+    List<String> keysToBePurgedList = new ArrayList<>();\n \n-    OMResponse omResponse = OMResponse.newBuilder()\n+    OMResponse.Builder omResponse = OMResponse.newBuilder()\n         .setCmdType(Type.PurgeKeys)\n-        .setPurgeKeysResponse(\n-            OzoneManagerProtocolProtos.PurgeKeysResponse.newBuilder().build())\n+        .setPurgeKeysResponse(PurgeKeysResponse.newBuilder().build())\n         .setStatus(Status.OK)\n-        .setSuccess(true)\n-        .build();\n+        .setSuccess(true);\n+    OMClientResponse omClientResponse = null;\n+    boolean success = true;\n+    IOException exception = null;\n+\n+    // Filter the keys that objectID > transactionLogIndex. This is done so\n+    // that in case this transaction is a replay, we do not purge keys\n+    // created after the original purge request.\n+    // PurgeKeys request has keys belonging to same bucket grouped together.\n+    // We get each bucket lock and check the above condition.\n+    for (DeletedKeys bucketWithDeleteKeys : bucketDeletedKeysList) {\n+      boolean acquiredLock = false;\n+      String volumeName = bucketWithDeleteKeys.getVolumeName();\n+      String bucketName = bucketWithDeleteKeys.getBucketName();\n+      try {\n+        acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+            volumeName, bucketName);\n+        for (String deletedKey : bucketWithDeleteKeys.getKeysList()) {\n+          RepeatedOmKeyInfo repeatedOmKeyInfo =\n+              omMetadataManager.getDeletedTable().get(deletedKey);\n+          boolean purgeKey = true;\n+          if (repeatedOmKeyInfo != null) {\n+            for (OmKeyInfo omKeyInfo : repeatedOmKeyInfo.getOmKeyInfoList()) {\n+              // Discard those keys whose updateID is > transactionLogIndex.\n+              // This could happen when the PurgeRequest is replayed.\n+              if (isReplay(ozoneManager, omKeyInfo.getUpdateID(),\n+                  transactionLogIndex)) {\n+                purgeKey = false;\n+                break;\n+              }\n+            }\n+            if (purgeKey) {", "originalCommit": "f0a9ba7849112d8e497e47e0d8c51841e9da41c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjE0MTQzNQ==", "url": "https://github.com/apache/ozone/pull/450#discussion_r372141435", "bodyText": "Can we add some logging for replay case and normal logging also which will help in debugging", "author": "bharatviswa504", "createdAt": "2020-01-29T01:00:15Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyPurgeRequest.java", "diffHunk": "@@ -49,25 +57,76 @@ public OMKeyPurgeRequest(OMRequest omRequest) {\n   public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n       long transactionLogIndex,\n       OzoneManagerDoubleBufferHelper ozoneManagerDoubleBufferHelper) {\n-    PurgeKeysRequest purgeKeysRequest = getOmRequest().getPurgeKeysRequest();\n-    List<String> purgeKeysList = purgeKeysRequest.getKeysList();\n \n-    LOG.debug(\"Processing Purge Keys for {} number of keys.\",\n-        purgeKeysList.size());\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+\n+    PurgeKeysRequest purgeKeysRequest = getOmRequest().getPurgeKeysRequest();\n+    List<DeletedKeys> bucketDeletedKeysList = purgeKeysRequest\n+        .getDeletedKeysList();\n+    List<String> keysToBePurgedList = new ArrayList<>();\n \n-    OMResponse omResponse = OMResponse.newBuilder()\n+    OMResponse.Builder omResponse = OMResponse.newBuilder()\n         .setCmdType(Type.PurgeKeys)\n-        .setPurgeKeysResponse(\n-            OzoneManagerProtocolProtos.PurgeKeysResponse.newBuilder().build())\n+        .setPurgeKeysResponse(PurgeKeysResponse.newBuilder().build())\n         .setStatus(Status.OK)\n-        .setSuccess(true)\n-        .build();\n+        .setSuccess(true);\n+    OMClientResponse omClientResponse = null;\n+    boolean success = true;\n+    IOException exception = null;\n+\n+    // Filter the keys that objectID > transactionLogIndex. This is done so\n+    // that in case this transaction is a replay, we do not purge keys\n+    // created after the original purge request.\n+    // PurgeKeys request has keys belonging to same bucket grouped together.\n+    // We get each bucket lock and check the above condition.\n+    for (DeletedKeys bucketWithDeleteKeys : bucketDeletedKeysList) {\n+      boolean acquiredLock = false;\n+      String volumeName = bucketWithDeleteKeys.getVolumeName();\n+      String bucketName = bucketWithDeleteKeys.getBucketName();\n+      try {\n+        acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+            volumeName, bucketName);\n+        for (String deletedKey : bucketWithDeleteKeys.getKeysList()) {\n+          RepeatedOmKeyInfo repeatedOmKeyInfo =\n+              omMetadataManager.getDeletedTable().get(deletedKey);\n+          boolean purgeKey = true;\n+          if (repeatedOmKeyInfo != null) {\n+            for (OmKeyInfo omKeyInfo : repeatedOmKeyInfo.getOmKeyInfoList()) {\n+              // Discard those keys whose updateID is > transactionLogIndex.\n+              // This could happen when the PurgeRequest is replayed.\n+              if (isReplay(ozoneManager, omKeyInfo.getUpdateID(),\n+                  transactionLogIndex)) {\n+                purgeKey = false;\n+                break;\n+              }\n+            }\n+            if (purgeKey) {\n+              keysToBePurgedList.add(deletedKey);\n+            }\n+          }\n+        }\n+      } catch (IOException ex) {\n+        success = false;\n+        exception = ex;\n+        break;\n+      } finally {\n+        if (acquiredLock) {\n+          omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+              bucketName);", "originalCommit": "f0a9ba7849112d8e497e47e0d8c51841e9da41c5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7612b4f4c9facea6b413f7d113286ea1eff3b054", "url": "https://github.com/apache/ozone/commit/7612b4f4c9facea6b413f7d113286ea1eff3b054", "message": "HDDS-2893. Handle replay of KeyPurge Request.", "committedDate": "2020-01-30T17:31:31Z", "type": "commit"}, {"oid": "174ee6947784a5ccca9d7912a346850d847acdd7", "url": "https://github.com/apache/ozone/commit/174ee6947784a5ccca9d7912a346850d847acdd7", "message": "Unit test for KeyPurgeRequest replay", "committedDate": "2020-01-30T17:31:31Z", "type": "commit"}, {"oid": "4d39192f9be7c0cd64e8fa2021e46c81a850de31", "url": "https://github.com/apache/ozone/commit/4d39192f9be7c0cd64e8fa2021e46c81a850de31", "message": "review comments", "committedDate": "2020-01-30T17:31:31Z", "type": "commit"}, {"oid": "52c33306d3425b4818e119ab141f40f1f880ffd7", "url": "https://github.com/apache/ozone/commit/52c33306d3425b4818e119ab141f40f1f880ffd7", "message": "compile fix", "committedDate": "2020-01-30T17:31:31Z", "type": "commit"}, {"oid": "7340374159ba98035c9d78942ab094741d4ceb92", "url": "https://github.com/apache/ozone/commit/7340374159ba98035c9d78942ab094741d4ceb92", "message": "checkstyle fix", "committedDate": "2020-01-30T17:31:31Z", "type": "commit"}, {"oid": "03dc581617ca3cf26473a936f26a23f5e9cf2d79", "url": "https://github.com/apache/ozone/commit/03dc581617ca3cf26473a936f26a23f5e9cf2d79", "message": "rebase fixes", "committedDate": "2020-01-30T18:02:44Z", "type": "commit"}, {"oid": "03dc581617ca3cf26473a936f26a23f5e9cf2d79", "url": "https://github.com/apache/ozone/commit/03dc581617ca3cf26473a936f26a23f5e9cf2d79", "message": "rebase fixes", "committedDate": "2020-01-30T18:02:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5MzYwMQ==", "url": "https://github.com/apache/ozone/pull/450#discussion_r373293601", "bodyText": "Minor: We can use the Java8 String method String.join(\", list)", "author": "bharatviswa504", "createdAt": "2020-01-31T02:40:50Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/key/OMKeyPurgeRequest.java", "diffHunk": "@@ -115,18 +126,42 @@ public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n               bucketName);\n         }\n       }\n+\n+      if (result == Result.REPLAY) {\n+        LOG.debug(\"Replayed Transaction {}. Request: {}\", trxnLogIndex,\n+            purgeKeysRequest);\n+        if (!keysNotPurged.isEmpty()) {", "originalCommit": "4d39192f9be7c0cd64e8fa2021e46c81a850de31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5MzgwMw==", "url": "https://github.com/apache/ozone/pull/450#discussion_r373293803", "bodyText": "And also as discussed offline for debug statements we can use isDebugEnabled, so that parameter conversion will not happen. If you want, we can open a new Jira to address this and above.", "author": "bharatviswa504", "createdAt": "2020-01-31T02:41:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI5MzYwMQ=="}], "type": "inlineReview"}, {"oid": "0a82c9f51076baa23393e46cf5bd83076dc5d882", "url": "https://github.com/apache/ozone/commit/0a82c9f51076baa23393e46cf5bd83076dc5d882", "message": "Check Debug Log enabled", "committedDate": "2020-01-31T23:44:01Z", "type": "commit"}]}