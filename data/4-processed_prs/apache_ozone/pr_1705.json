{"pr_number": 1705, "pr_title": "HDDS-4569. Add pre append gate and marker file to OM prepare state.", "pr_createdAt": "2020-12-15T23:53:52Z", "pr_url": "https://github.com/apache/ozone/pull/1705", "timeline": [{"oid": "2f6978117c702f0be27e192a18e0e826176d2db8", "url": "https://github.com/apache/ozone/commit/2f6978117c702f0be27e192a18e0e826176d2db8", "message": "Add first draft of blocking write transactions in OM prepare mode", "committedDate": "2020-12-09T22:26:47Z", "type": "commit"}, {"oid": "ddb8ccd82bb1152e70b63e7c4d976ed2834c7861", "url": "https://github.com/apache/ozone/commit/ddb8ccd82bb1152e70b63e7c4d976ed2834c7861", "message": "Move prepare state to external class", "committedDate": "2020-12-09T22:26:47Z", "type": "commit"}, {"oid": "28db622cba916f41b331304a6262aa76e53fcf4a", "url": "https://github.com/apache/ozone/commit/28db622cba916f41b331304a6262aa76e53fcf4a", "message": "Create prepare marker file in prepare request", "committedDate": "2020-12-09T22:26:47Z", "type": "commit"}, {"oid": "38190e08faf906b74cfbb49e6dad8318bf7f2ad9", "url": "https://github.com/apache/ozone/commit/38190e08faf906b74cfbb49e6dad8318bf7f2ad9", "message": "Move prepare marker file operations to the OzoneManagerPrepareState class", "committedDate": "2020-12-09T22:26:47Z", "type": "commit"}, {"oid": "e280b81807a1545716b0d12d115f00919fcc15de", "url": "https://github.com/apache/ozone/commit/e280b81807a1545716b0d12d115f00919fcc15de", "message": "Add exception handling to turn off leader step down on prepare reject\n\nRequires RATIS-1216", "committedDate": "2020-12-10T20:31:43Z", "type": "commit"}, {"oid": "b9723427d65241bc6f0623b7c651f3090f590bcd", "url": "https://github.com/apache/ozone/commit/b9723427d65241bc6f0623b7c651f3090f590bcd", "message": "Turn off failover for write failure while in prepare and add simple test", "committedDate": "2020-12-10T20:32:38Z", "type": "commit"}, {"oid": "348302683a1dcd5ca3e272d477680290a4af20b3", "url": "https://github.com/apache/ozone/commit/348302683a1dcd5ca3e272d477680290a4af20b3", "message": "Update ratis to use tip of ratis master + RATIS-1216", "committedDate": "2020-12-10T21:57:18Z", "type": "commit"}, {"oid": "4f4156a27db09e08d72f0d0adbdb89ec69301e7c", "url": "https://github.com/apache/ozone/commit/4f4156a27db09e08d72f0d0adbdb89ec69301e7c", "message": "Updates for initial integration tests", "committedDate": "2020-12-11T23:02:28Z", "type": "commit"}, {"oid": "69df22c169d08bd4bab53e82ea8a84c9d2b50320", "url": "https://github.com/apache/ozone/commit/69df22c169d08bd4bab53e82ea8a84c9d2b50320", "message": "More refactoring of integration tests\n\nThe tests still do not pass consistently. Doing the test with transactions\nsometimes times out, and the test with restarts sometimes segfaults RocksDB.", "committedDate": "2020-12-14T20:51:54Z", "type": "commit"}, {"oid": "558632706afd277106666303241792d68dadb804", "url": "https://github.com/apache/ozone/commit/558632706afd277106666303241792d68dadb804", "message": "Create marker file in 'current' subdirectory of om metadata dir", "committedDate": "2020-12-14T21:26:18Z", "type": "commit"}, {"oid": "6592dde817da8af59ef10edaa1186b5f13956217", "url": "https://github.com/apache/ozone/commit/6592dde817da8af59ef10edaa1186b5f13956217", "message": "Clean up error responses", "committedDate": "2020-12-14T21:54:41Z", "type": "commit"}, {"oid": "387f7b6eb5222345c9ce04eef4b8536eb52abe27", "url": "https://github.com/apache/ozone/commit/387f7b6eb5222345c9ce04eef4b8536eb52abe27", "message": "Remoce forUpgrade flag in ozone manager ctor", "committedDate": "2020-12-14T21:56:33Z", "type": "commit"}, {"oid": "65cb97b867bfa417b39a480eff9eadd0fd8aed77", "url": "https://github.com/apache/ozone/commit/65cb97b867bfa417b39a480eff9eadd0fd8aed77", "message": "Fix errors in error status code and marker file creation", "committedDate": "2020-12-14T22:57:43Z", "type": "commit"}, {"oid": "cebbb36a0d6f2e073f8e54eedea123d3f26b0f2b", "url": "https://github.com/apache/ozone/commit/cebbb36a0d6f2e073f8e54eedea123d3f26b0f2b", "message": "Remove incorrect raft log index check\n\nThis check is also removed by HDDS-4564, which will probably be merged first.", "committedDate": "2020-12-15T15:50:20Z", "type": "commit"}, {"oid": "658b27a5cf80d44e541b150013bc3d59c82067bb", "url": "https://github.com/apache/ozone/commit/658b27a5cf80d44e541b150013bc3d59c82067bb", "message": "Add concurrent request test for prepare\n\nSeems to pass consistently.", "committedDate": "2020-12-15T15:51:08Z", "type": "commit"}, {"oid": "34c19c60eb01e0d86d0d141b1b094b95af29b1e2", "url": "https://github.com/apache/ozone/commit/34c19c60eb01e0d86d0d141b1b094b95af29b1e2", "message": "Add unit tests for prepare state", "committedDate": "2020-12-15T17:07:05Z", "type": "commit"}, {"oid": "85cace143377284d203b8462ac4e4d54a68ad015", "url": "https://github.com/apache/ozone/commit/85cace143377284d203b8462ac4e4d54a68ad015", "message": "Rename methods and add docs for prepare state", "committedDate": "2020-12-15T17:32:05Z", "type": "commit"}, {"oid": "827168ecdcff7a1f23c39acc734906e5a0ecb209", "url": "https://github.com/apache/ozone/commit/827168ecdcff7a1f23c39acc734906e5a0ecb209", "message": "Fix rat and checkstyle failures", "committedDate": "2020-12-15T18:11:28Z", "type": "commit"}, {"oid": "c3e674232a2158629de477dc6a3f7ea9a52d2db9", "url": "https://github.com/apache/ozone/commit/c3e674232a2158629de477dc6a3f7ea9a52d2db9", "message": "Update waiting conditions in tests", "committedDate": "2020-12-15T23:28:57Z", "type": "commit"}, {"oid": "e8950fa2137dc57bac8e1d91067642595308d9d2", "url": "https://github.com/apache/ozone/commit/e8950fa2137dc57bac8e1d91067642595308d9d2", "message": "Update Ratis to latest snapshot", "committedDate": "2020-12-15T23:48:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzMzMxMw==", "url": "https://github.com/apache/ozone/pull/1705#discussion_r544333313", "bodyText": "Can you closed executorService after the test.", "author": "linyiqun", "createdAt": "2020-12-16T14:17:50Z", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/ozone/om/TestOzoneManagerPrepare.java", "diffHunk": "@@ -138,75 +112,111 @@ public void testPrepareWithTransactions() throws Exception {\n    */\n //  @Test\n   public void testPrepareDownedOM() throws Exception {\n+    setup();\n     // Index of the OM that will be shut down during this test.\n     final int shutdownOMIndex = 2;\n-\n-    MiniOzoneHAClusterImpl cluster = getCluster();\n-    OzoneClient ozClient = OzoneClientFactory.getRpcClient(getConf());\n-\n-    String volumeName = UUID.randomUUID().toString();\n-    String bucketName = UUID.randomUUID().toString();\n-    ObjectStore store = ozClient.getObjectStore();\n+    List<OzoneManager> runningOms = cluster.getOzoneManagersList();\n \n     // Create keys with all 3 OMs up.\n-    store.createVolume(volumeName);\n-    OzoneVolume volume = store.getVolume(volumeName);\n-    volume.createBucket(bucketName);\n-\n-    Set<String> writtenKeys = new HashSet<>();\n-    for (int i = 1; i <= 50; i++) {\n-      String keyName = keyPrefix + i;\n-      writeTestData(store, volumeName, bucketName, keyName);\n-      writtenKeys.add(keyName);\n-    }\n-\n-    // Make sure all OMs have logs from writing data, so we can check that\n-    // they are purged after prepare.\n-    for (OzoneManager om: cluster.getOzoneManagersList()) {\n-      LambdaTestUtils.await(timeoutMillis, 1000,\n-          () -> logFilesPresentInRatisPeer(om));\n-    }\n+    Set<String> writtenKeys = writeKeysAndWaitForLogs(10, runningOms);\n \n     // Shut down one OM.\n     cluster.stopOzoneManager(shutdownOMIndex);\n     OzoneManager downedOM = cluster.getOzoneManager(shutdownOMIndex);\n     Assert.assertFalse(downedOM.isRunning());\n+    Assert.assertEquals(runningOms.remove(shutdownOMIndex), downedOM);\n \n     // Write keys with the remaining OMs up.\n-    for (int i = 51; i <= 100; i++) {\n-      String keyName = keyPrefix + i;\n-      writeTestData(store, volumeName, bucketName, keyName);\n-      writtenKeys.add(keyName);\n-    }\n+    writtenKeys.addAll(\n+        writeKeysAndWaitForLogs(10, runningOms));\n \n-    OzoneManagerProtocol ozoneManagerClient =\n-        ozClient.getObjectStore().getClientProxy().getOzoneManagerClient();\n-    long prepareIndex = ozoneManagerClient.prepareOzoneManager(\n-        PREPARE_FLUSH_WAIT_TIMEOUT_SECONDS, PREPARE_FLUSH_INTERVAL_SECONDS);\n+    long prepareIndex = submitPrepareRequest();\n \n     // Check that the two live OMs are prepared.\n-    for (OzoneManager om: cluster.getOzoneManagersList()) {\n-      if (om != downedOM) {\n-        // Follower may still be applying transactions.\n-        waitAndCheckPrepared(om, prepareIndex);\n-      }\n-    }\n+    assertClusterPrepared(prepareIndex, runningOms);\n \n     // Restart the downed OM and wait for it to catch up.\n     // Since prepare was the last Ratis transaction, it should have all data\n     // it missed once it receives the prepare transaction.\n     cluster.restartOzoneManager(downedOM, true);\n-    LambdaTestUtils.await(timeoutMillis, 2000,\n-        () -> checkPrepared(downedOM, prepareIndex));\n+    runningOms.add(shutdownOMIndex, downedOM);\n \n     // Make sure all OMs are prepared and still have data.\n-    for (OzoneManager om: cluster.getOzoneManagersList()) {\n-      List<OmKeyInfo> readKeys = om.getMetadataManager().listKeys(volumeName,\n-          bucketName, null, keyPrefix, 100);\n+    assertClusterPrepared(prepareIndex, runningOms);\n+    assertKeysWritten(writtenKeys, runningOms);\n+  }\n+\n+  @Test\n+  public void testPrepareWithRestart() throws Exception {\n+    setup();\n+    writeKeysAndWaitForLogs(10);\n+    long prepareIndex = submitPrepareRequest();\n+    assertClusterPrepared(prepareIndex);\n+\n+    // Restart all ozone managers.\n+    cluster.restartOzoneManager();\n+\n+    // No check for cleared logs, since Ratis meta transactions may slip in\n+    // on restart.\n+    assertClusterPrepared(prepareIndex);\n+  }\n \n-      Assert.assertEquals(writtenKeys.size(), readKeys.size());\n-      for (OmKeyInfo keyInfo: readKeys) {\n-        Assert.assertTrue(writtenKeys.contains(keyInfo.getKeyName()));\n+  /**\n+   * Issues requests on ten different threads, for which one is a prepare and\n+   * the rest are create volume. We cannot be sure of the exact order that\n+   * the requests will execute, so this test checks that the cluster ends in\n+   * a prepared state, and that create volume requests either succeed, or fail\n+   * indicating the cluster was prepared before they were encountered.\n+   * @throws Exception\n+   */\n+  @Test\n+  public void testPrepareWithMultipleThreads() throws Exception {\n+    setup();\n+    final int numThreads = 10;\n+    final int prepareTaskIndex = 5;\n+\n+    ExecutorService executorService = Executors.newFixedThreadPool(numThreads);\n+    // For the prepare task, the future will return a log index.\n+    // For the create volume tasks, 0 (dummy value) will be returned.\n+    List<Future<Long>> tasks = new ArrayList<>();\n+\n+    for (int i = 0; i < numThreads; i++) {\n+      Callable<Long> task;\n+      if (i == prepareTaskIndex) {\n+        task = this::submitPrepareRequest;\n+      } else {\n+        String volumeName = VOLUME + i;\n+        task = () -> {\n+          clientProtocol.createVolume(volumeName);\n+          return 0L;\n+        };\n+      }\n+      tasks.add(executorService.submit(task));\n+    }\n+\n+    // For each task, wait for it to complete and check its result.\n+    for (int i = 0; i < numThreads; i++) {\n+      Future<Long> future = tasks.get(i);\n+\n+      if (i == prepareTaskIndex) {\n+        assertClusterPrepared(future.get());\n+        assertRatisLogsCleared();\n+      } else {\n+        try {\n+          // If this throws an exception, it should be an OMException\n+          // indicating failure because the cluster was already prepared.\n+          // If no exception is thrown, the volume should be created.\n+          future.get();\n+          String volumeName = VOLUME + i;\n+          Assert.assertTrue(clientProtocol.listVolumes(volumeName, \"\", 1)\n+              .stream()\n+              .anyMatch((vol) -> vol.getName().equals(volumeName)));\n+        } catch (ExecutionException ex) {\n+          Throwable cause = ex.getCause();\n+          Assert.assertTrue(cause instanceof OMException);\n+          Assert.assertEquals(OMException.ResultCodes.NOT_SUPPORTED_OPERATION,\n+              ((OMException) cause).getResult());\n+        }\n       }\n     }", "originalCommit": "e8950fa2137dc57bac8e1d91067642595308d9d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUyNzE4NA==", "url": "https://github.com/apache/ozone/pull/1705#discussion_r547527184", "bodyText": "Yes, just fixed in latest revision.", "author": "errose28", "createdAt": "2020-12-22T21:59:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzMzMxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzNjM1OQ==", "url": "https://github.com/apache/ozone/pull/1705#discussion_r544336359", "bodyText": "Can we use a better status name for this, like OM_IN_PREPARE_MODE?", "author": "linyiqun", "createdAt": "2020-12-16T14:21:45Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/ratis/OzoneManagerRatisServer.java", "diffHunk": "@@ -128,10 +129,25 @@ private static long nextCallId() {\n    * @throws ServiceException\n    */\n   public OMResponse submitRequest(OMRequest omRequest) throws ServiceException {\n-    RaftClientRequest raftClientRequest =\n-        createWriteRaftClientRequest(omRequest);\n-    RaftClientReply raftClientReply = submitRequestToRatis(raftClientRequest);\n-    return processReply(omRequest, raftClientReply);\n+    // In prepare mode, only prepare and cancel requests are allowed to go\n+    // through.\n+    if (OzoneManagerPrepareState.requestAllowed(omRequest.getCmdType())) {\n+      RaftClientRequest raftClientRequest =\n+          createWriteRaftClientRequest(omRequest);\n+      RaftClientReply raftClientReply = submitRequestToRatis(raftClientRequest);\n+\n+      return processReply(omRequest, raftClientReply);\n+    } else {\n+      String message = \"Cannot apply write request \" +\n+          omRequest.getCmdType().name() + \" when OM is in prepare mode.\";\n+      OMResponse.Builder omResponse = OMResponse.newBuilder()\n+          .setMessage(message)\n+          .setStatus(OzoneManagerProtocolProtos.Status.NOT_SUPPORTED_OPERATION)", "originalCommit": "e8950fa2137dc57bac8e1d91067642595308d9d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUyNzQ2Mw==", "url": "https://github.com/apache/ozone/pull/1705#discussion_r547527463", "bodyText": "Yes, I have created a new dedicated status for rejecting requests because the om is in prepare mode. Thanks for the suggestion!", "author": "errose28", "createdAt": "2020-12-22T22:00:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzNjM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzODk0Nw==", "url": "https://github.com/apache/ozone/pull/1705#discussion_r544338947", "bodyText": "Can you add @OverRide here, so we could directly know this is an override method.", "author": "linyiqun", "createdAt": "2020-12-16T14:25:04Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/ratis/OzoneManagerStateMachine.java", "diffHunk": "@@ -193,6 +196,32 @@ public TransactionContext startTransaction(\n     return handleStartTransactionRequests(raftClientRequest, omRequest);\n   }\n \n+  public TransactionContext preAppendTransaction(TransactionContext trx)", "originalCommit": "e8950fa2137dc57bac8e1d91067642595308d9d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUyNzY2OA==", "url": "https://github.com/apache/ozone/pull/1705#discussion_r547527668", "bodyText": "Done", "author": "errose28", "createdAt": "2020-12-22T22:00:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDMzODk0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0MDI1Nw==", "url": "https://github.com/apache/ozone/pull/1705#discussion_r544340257", "bodyText": "Not fully get this, why we remove this safe check?", "author": "linyiqun", "createdAt": "2020-12-16T14:26:44Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/upgrade/OMPrepareRequest.java", "diffHunk": "@@ -184,26 +188,18 @@ private static void waitForLogIndex(long indexToWaitFor,\n \n   /**\n    * Take a snapshot of the state machine at the last index, and purge ALL logs.\n-   * @param impl RaftServerImpl instance\n+   * @param division Raft server division.\n    * @throws IOException on Error.\n    */\n-  public static long takeSnapshotAndPurgeLogs(RaftServerImpl impl)\n+  public static long takeSnapshotAndPurgeLogs(RaftServer.Division division)\n       throws IOException {\n \n-    StateMachine stateMachine = impl.getStateMachine();\n+    StateMachine stateMachine = division.getStateMachine();\n     long snapshotIndex = stateMachine.takeSnapshot();\n-    RaftLog raftLog = impl.getState().getLog();\n-    long raftLogIndex = raftLog.getLastEntryTermIndex().getIndex();\n-\n-    // Ensure that Ratis's in memory snapshot index is the same as the index\n-    // of its last log entry.\n-    if (snapshotIndex != raftLogIndex) {\n-      throw new IOException(\"Snapshot index \" + snapshotIndex + \" does not \" +\n-          \"match last log index \" + raftLogIndex);\n-    }", "originalCommit": "e8950fa2137dc57bac8e1d91067642595308d9d2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzUzODA2OA==", "url": "https://github.com/apache/ozone/pull/1705#discussion_r547538068", "bodyText": "It is possible that an extra Ratis transaction to commit the prepare request happens after we take the snapshot. This entry is internal to Ratis so it is not sent to the state machine. This is normal, but with this check in place, it would cause the prepare to fail. HDDS-4610 will wait on this extra transaction and update the DB with its index when the snapshot is taken, which will provide consistent behavior here, instead of the transaction getting included only sometimes.", "author": "errose28", "createdAt": "2020-12-22T22:29:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0MDI1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk5NzkyOQ==", "url": "https://github.com/apache/ozone/pull/1705#discussion_r547997929", "bodyText": "Okay, get it.", "author": "linyiqun", "createdAt": "2020-12-23T14:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0MDI1Nw=="}], "type": "inlineReview"}, {"oid": "8938f11299ca66bd2800aa83f373225aa559de54", "url": "https://github.com/apache/ozone/commit/8938f11299ca66bd2800aa83f373225aa559de54", "message": "Merge branch 'HDDS-3698-upgrade' into HDDS-4569\n\n* HDDS-3698-upgrade:\n  HDDS-4564. Prepare client should check every OM individually for the prepared check based on Txn ID. (#1692)\n  HDDS-4178. SCM Finalize client command implementation (#1651)", "committedDate": "2020-12-21T15:56:24Z", "type": "commit"}, {"oid": "1623db1559ff6dada1a6ffdb724d194be7a74376", "url": "https://github.com/apache/ozone/commit/1623db1559ff6dada1a6ffdb724d194be7a74376", "message": "Refactor prepare state to use the not started -> in progress -> completed states", "committedDate": "2020-12-21T23:35:32Z", "type": "commit"}, {"oid": "65e3ba50282d0f817e1092fcfcfca7fa23d123ae", "url": "https://github.com/apache/ozone/commit/65e3ba50282d0f817e1092fcfcfca7fa23d123ae", "message": "Make prepare state a member of OzoneManager\n\nChanging the prepare state now requires retrieving it from the ozone manager.", "committedDate": "2020-12-22T17:17:31Z", "type": "commit"}, {"oid": "86bf7a564dc39ff82a3f179f677c0f37a3016f33", "url": "https://github.com/apache/ozone/commit/86bf7a564dc39ff82a3f179f677c0f37a3016f33", "message": "Fix checkstyle violations", "committedDate": "2020-12-22T17:19:42Z", "type": "commit"}, {"oid": "871fd52a7e87c12fd686d08605eedfbaa05c125c", "url": "https://github.com/apache/ozone/commit/871fd52a7e87c12fd686d08605eedfbaa05c125c", "message": "Fixes based on review comments", "committedDate": "2020-12-22T17:55:31Z", "type": "commit"}, {"oid": "f046aad1f22c4afb484f9bd552975fdc44d547f6", "url": "https://github.com/apache/ozone/commit/f046aad1f22c4afb484f9bd552975fdc44d547f6", "message": "Add specific result code for failing a request because OM is prepared", "committedDate": "2020-12-22T18:40:14Z", "type": "commit"}, {"oid": "5b3f1f5490b37c1802ed5c6dcc4f0a502ebc0170", "url": "https://github.com/apache/ozone/commit/5b3f1f5490b37c1802ed5c6dcc4f0a502ebc0170", "message": "Connect prepare status request from HDDS-4564 to this feature\n\nAllow retrieving prepare state as one object for a consistent view.\nFix old test that incorrectly checked for OMException on finish prepare.", "committedDate": "2020-12-22T19:27:59Z", "type": "commit"}, {"oid": "5b995e38eaac982f47ba6d8e094cbb7e011c5a56", "url": "https://github.com/apache/ozone/commit/5b995e38eaac982f47ba6d8e094cbb7e011c5a56", "message": "Minor tweaks to ratis fixes to more closely follow HDDS-4617\n\nWill remove merge conflicts where the code was functionally identical.\nHDDS-4617 updates to a newer ratis snapshot, so it contains more changes than\nare present here.", "committedDate": "2020-12-22T20:46:03Z", "type": "commit"}, {"oid": "5c622b0f9758ddefb0c168bff83671dfd9f03427", "url": "https://github.com/apache/ozone/commit/5c622b0f9758ddefb0c168bff83671dfd9f03427", "message": "Fix checkstyle", "committedDate": "2020-12-22T20:59:43Z", "type": "commit"}, {"oid": "ebdb679c7d2b4b186901b4ba1901fc9aebd1422d", "url": "https://github.com/apache/ozone/commit/ebdb679c7d2b4b186901b4ba1901fc9aebd1422d", "message": "Fix spotbugs violations", "committedDate": "2020-12-22T21:56:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzczMjE2MQ==", "url": "https://github.com/apache/ozone/pull/1705#discussion_r547732161", "bodyText": "There is an 'enablePrepareGate()' in finishPrepare. Do we need the one in Line # 180?", "author": "avijayanhwx", "createdAt": "2020-12-23T07:02:40Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/OzoneManagerPrepareState.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.server.ServerUtils;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.om.ratis.OzoneManagerStateMachine;\n+import org.apache.hadoop.ozone.om.ratis.OzoneManagerRatisServer;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Type;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.PrepareStatusResponse.PrepareStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+\n+/**\n+ * Controls the prepare state of the {@link OzoneManager} containing the\n+ * instance. When prepared, an ozone manager should have no Ratis logs\n+ * remaining, disallow all write requests except prepare and cancel prepare,\n+ * and have a marker file present on disk that will cause it to remain prepared\n+ * on restart.\n+ */\n+public final class OzoneManagerPrepareState {\n+  public static final long NO_PREPARE_INDEX = -1;\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OzoneManagerPrepareState.class);\n+\n+  private boolean prepareGateEnabled;\n+  private long prepareIndex;\n+  private PrepareStatus status;\n+  private final ConfigurationSource conf;\n+\n+  public OzoneManagerPrepareState(ConfigurationSource conf) {\n+    prepareGateEnabled = false;\n+    prepareIndex = NO_PREPARE_INDEX;\n+    status = PrepareStatus.PREPARE_NOT_STARTED;\n+    this.conf = conf;\n+  }\n+\n+  /**\n+   * Turns on the prepare gate flag, clears the prepare index, and moves the\n+   * prepare status to {@link PrepareStatus#PREPARE_IN_PROGRESS}.\n+   *\n+   * Turning on the prepare gate flag will enable a gate in the\n+   * {@link OzoneManagerStateMachine#preAppendTransaction} (called on leader\n+   * OM only) and {@link OzoneManagerRatisServer#submitRequest}\n+   * (called on all OMs) that block write requests from reaching the OM and\n+   * fail them with error responses to the client.\n+   */\n+  public synchronized void enablePrepareGate() {\n+    prepareGateEnabled = true;\n+    prepareIndex = NO_PREPARE_INDEX;\n+    status = PrepareStatus.PREPARE_IN_PROGRESS;\n+  }\n+\n+  /**\n+   * Removes the prepare marker file, clears the prepare index, turns off\n+   * the prepare gate, and moves the prepare status to\n+   * {@link PrepareStatus#PREPARE_NOT_STARTED}.\n+   * This can be called from any state to clear the current prepare state.\n+   *\n+   * @throws IOException If the prepare marker file exists but cannot be\n+   * deleted.\n+   */\n+  public synchronized void cancelPrepare()\n+      throws IOException {\n+    deletePrepareMarkerFile();\n+    prepareIndex = NO_PREPARE_INDEX;\n+    prepareGateEnabled = false;\n+    status = PrepareStatus.PREPARE_NOT_STARTED;\n+  }\n+\n+  /**\n+   * Enables the prepare gate, writes the prepare marker file, sets the in\n+   * memory prepare index, and\n+   * moves the prepare status to {@link PrepareStatus#PREPARE_COMPLETED}.\n+   * This can be called from any state to move the OM into prepare mode.\n+   *\n+   * @param index The log index to prepare the OM on.\n+   * @throws IOException If the marker file cannot be written.\n+   */\n+  public synchronized void finishPrepare(long index) throws IOException {\n+    finishPrepare(index, true);\n+  }\n+\n+  private void finishPrepare(long index, boolean writeFile) throws IOException {\n+    // Enabling the prepare gate is idempotent, and may have already been\n+    // performed if we are the leader.If we are a follower, we must ensure this\n+    // is run now case we become the leader.\n+    enablePrepareGate();\n+\n+    if (writeFile) {\n+      writePrepareMarkerFile(index);\n+    }\n+    prepareIndex = index;\n+    status = PrepareStatus.PREPARE_COMPLETED;\n+  }\n+\n+  /**\n+   * Uses the on disk marker file to determine the OM's prepare state.\n+   * If the marker file exists and contains an index matching {@code\n+   * expectedPrepareIndex}, the necessary steps will be taken to finish\n+   * preparation and the state will be moved to\n+   * {@link PrepareStatus#PREPARE_COMPLETED}.\n+   * Else, the status will be moved to\n+   * {@link PrepareStatus#PREPARE_NOT_STARTED} and any preparation steps will\n+   * be cancelled.\n+   *\n+   * @return The status the OM is in after this method call.\n+   * @throws IOException If the marker file cannot be read, and it cannot be\n+   * deleted as part of moving to the\n+   * {@link PrepareStatus#PREPARE_NOT_STARTED} state.\n+   */\n+  public synchronized PrepareStatus restorePrepare(long expectedPrepareIndex)\n+      throws IOException {\n+    boolean prepareIndexRead = true;\n+    long prepareMarkerIndex = NO_PREPARE_INDEX;\n+\n+    File prepareMarkerFile = getPrepareMarkerFile();\n+    if (prepareMarkerFile.exists()) {\n+      byte[] data = new byte[(int) prepareMarkerFile.length()];\n+      try(FileInputStream stream = new FileInputStream(prepareMarkerFile)) {\n+        stream.read(data);\n+      } catch (IOException e) {\n+        LOG.error(\"Failed to read prepare marker file {} while restoring OM.\",\n+            prepareMarkerFile.getAbsolutePath());\n+        prepareIndexRead = false;\n+      }\n+\n+      try {\n+        prepareMarkerIndex = Long.parseLong(\n+            new String(data, StandardCharsets.UTF_8));\n+      } catch (NumberFormatException e) {\n+        LOG.error(\"Failed to parse log index from prepare marker file {} \" +\n+            \"while restoring OM.\", prepareMarkerFile.getAbsolutePath());\n+        prepareIndexRead = false;\n+      }\n+    } else {\n+      // No marker file found.\n+      prepareIndexRead = false;\n+    }\n+\n+    boolean prepareRestored = false;\n+    if (prepareIndexRead) {\n+      if (prepareMarkerIndex != expectedPrepareIndex) {\n+        LOG.error(\"Failed to restore OM prepare state, because the expected \" +\n+            \"prepare index {} does not match the index {} written to the \" +\n+            \"marker file.\", expectedPrepareIndex, prepareMarkerIndex);\n+      } else {\n+        // Prepare state can only be restored if we read the expected index\n+        // from the marker file.\n+        prepareRestored = true;\n+      }\n+    }\n+\n+    if (prepareRestored) {\n+      enablePrepareGate();", "originalCommit": "ebdb679c7d2b4b186901b4ba1901fc9aebd1422d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAyMzc2Mg==", "url": "https://github.com/apache/ozone/pull/1705#discussion_r548023762", "bodyText": "No, looks like this was left over from an old version, I'll remove it.", "author": "errose28", "createdAt": "2020-12-23T15:51:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzczMjE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzczNTM4Mw==", "url": "https://github.com/apache/ozone/pull/1705#discussion_r547735383", "bodyText": "Can we add a unit test for this method since it has a few different execution flows?", "author": "avijayanhwx", "createdAt": "2020-12-23T07:06:39Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/ratis/OzoneManagerStateMachine.java", "diffHunk": "@@ -193,6 +196,32 @@ public TransactionContext startTransaction(\n     return handleStartTransactionRequests(raftClientRequest, omRequest);\n   }\n \n+  @Override\n+  public TransactionContext preAppendTransaction(TransactionContext trx)", "originalCommit": "ebdb679c7d2b4b186901b4ba1901fc9aebd1422d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA4OTc0Mg==", "url": "https://github.com/apache/ozone/pull/1705#discussion_r548089742", "bodyText": "Yes, done.", "author": "errose28", "createdAt": "2020-12-23T17:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzczNTM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzczNjk5OQ==", "url": "https://github.com/apache/ozone/pull/1705#discussion_r547736999", "bodyText": "Can we add a log line when we create & delete the marker file? It will help us with troubleshooting issues with preparation.", "author": "avijayanhwx", "createdAt": "2020-12-23T07:08:48Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/OzoneManagerPrepareState.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import org.apache.hadoop.hdds.conf.ConfigurationSource;\n+import org.apache.hadoop.hdds.server.ServerUtils;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.om.ratis.OzoneManagerStateMachine;\n+import org.apache.hadoop.ozone.om.ratis.OzoneManagerRatisServer;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Type;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.PrepareStatusResponse.PrepareStatus;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+\n+/**\n+ * Controls the prepare state of the {@link OzoneManager} containing the\n+ * instance. When prepared, an ozone manager should have no Ratis logs\n+ * remaining, disallow all write requests except prepare and cancel prepare,\n+ * and have a marker file present on disk that will cause it to remain prepared\n+ * on restart.\n+ */\n+public final class OzoneManagerPrepareState {\n+  public static final long NO_PREPARE_INDEX = -1;\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OzoneManagerPrepareState.class);\n+\n+  private boolean prepareGateEnabled;\n+  private long prepareIndex;\n+  private PrepareStatus status;\n+  private final ConfigurationSource conf;\n+\n+  public OzoneManagerPrepareState(ConfigurationSource conf) {\n+    prepareGateEnabled = false;\n+    prepareIndex = NO_PREPARE_INDEX;\n+    status = PrepareStatus.PREPARE_NOT_STARTED;\n+    this.conf = conf;\n+  }\n+\n+  /**\n+   * Turns on the prepare gate flag, clears the prepare index, and moves the\n+   * prepare status to {@link PrepareStatus#PREPARE_IN_PROGRESS}.\n+   *\n+   * Turning on the prepare gate flag will enable a gate in the\n+   * {@link OzoneManagerStateMachine#preAppendTransaction} (called on leader\n+   * OM only) and {@link OzoneManagerRatisServer#submitRequest}\n+   * (called on all OMs) that block write requests from reaching the OM and\n+   * fail them with error responses to the client.\n+   */\n+  public synchronized void enablePrepareGate() {\n+    prepareGateEnabled = true;\n+    prepareIndex = NO_PREPARE_INDEX;\n+    status = PrepareStatus.PREPARE_IN_PROGRESS;\n+  }\n+\n+  /**\n+   * Removes the prepare marker file, clears the prepare index, turns off\n+   * the prepare gate, and moves the prepare status to\n+   * {@link PrepareStatus#PREPARE_NOT_STARTED}.\n+   * This can be called from any state to clear the current prepare state.\n+   *\n+   * @throws IOException If the prepare marker file exists but cannot be\n+   * deleted.\n+   */\n+  public synchronized void cancelPrepare()\n+      throws IOException {\n+    deletePrepareMarkerFile();\n+    prepareIndex = NO_PREPARE_INDEX;\n+    prepareGateEnabled = false;\n+    status = PrepareStatus.PREPARE_NOT_STARTED;\n+  }\n+\n+  /**\n+   * Enables the prepare gate, writes the prepare marker file, sets the in\n+   * memory prepare index, and\n+   * moves the prepare status to {@link PrepareStatus#PREPARE_COMPLETED}.\n+   * This can be called from any state to move the OM into prepare mode.\n+   *\n+   * @param index The log index to prepare the OM on.\n+   * @throws IOException If the marker file cannot be written.\n+   */\n+  public synchronized void finishPrepare(long index) throws IOException {\n+    finishPrepare(index, true);\n+  }\n+\n+  private void finishPrepare(long index, boolean writeFile) throws IOException {\n+    // Enabling the prepare gate is idempotent, and may have already been\n+    // performed if we are the leader.If we are a follower, we must ensure this\n+    // is run now case we become the leader.\n+    enablePrepareGate();\n+\n+    if (writeFile) {\n+      writePrepareMarkerFile(index);\n+    }\n+    prepareIndex = index;\n+    status = PrepareStatus.PREPARE_COMPLETED;\n+  }\n+\n+  /**\n+   * Uses the on disk marker file to determine the OM's prepare state.\n+   * If the marker file exists and contains an index matching {@code\n+   * expectedPrepareIndex}, the necessary steps will be taken to finish\n+   * preparation and the state will be moved to\n+   * {@link PrepareStatus#PREPARE_COMPLETED}.\n+   * Else, the status will be moved to\n+   * {@link PrepareStatus#PREPARE_NOT_STARTED} and any preparation steps will\n+   * be cancelled.\n+   *\n+   * @return The status the OM is in after this method call.\n+   * @throws IOException If the marker file cannot be read, and it cannot be\n+   * deleted as part of moving to the\n+   * {@link PrepareStatus#PREPARE_NOT_STARTED} state.\n+   */\n+  public synchronized PrepareStatus restorePrepare(long expectedPrepareIndex)\n+      throws IOException {\n+    boolean prepareIndexRead = true;\n+    long prepareMarkerIndex = NO_PREPARE_INDEX;\n+\n+    File prepareMarkerFile = getPrepareMarkerFile();\n+    if (prepareMarkerFile.exists()) {\n+      byte[] data = new byte[(int) prepareMarkerFile.length()];\n+      try(FileInputStream stream = new FileInputStream(prepareMarkerFile)) {\n+        stream.read(data);\n+      } catch (IOException e) {\n+        LOG.error(\"Failed to read prepare marker file {} while restoring OM.\",\n+            prepareMarkerFile.getAbsolutePath());\n+        prepareIndexRead = false;\n+      }\n+\n+      try {\n+        prepareMarkerIndex = Long.parseLong(\n+            new String(data, StandardCharsets.UTF_8));\n+      } catch (NumberFormatException e) {\n+        LOG.error(\"Failed to parse log index from prepare marker file {} \" +\n+            \"while restoring OM.\", prepareMarkerFile.getAbsolutePath());\n+        prepareIndexRead = false;\n+      }\n+    } else {\n+      // No marker file found.\n+      prepareIndexRead = false;\n+    }\n+\n+    boolean prepareRestored = false;\n+    if (prepareIndexRead) {\n+      if (prepareMarkerIndex != expectedPrepareIndex) {\n+        LOG.error(\"Failed to restore OM prepare state, because the expected \" +\n+            \"prepare index {} does not match the index {} written to the \" +\n+            \"marker file.\", expectedPrepareIndex, prepareMarkerIndex);\n+      } else {\n+        // Prepare state can only be restored if we read the expected index\n+        // from the marker file.\n+        prepareRestored = true;\n+      }\n+    }\n+\n+    if (prepareRestored) {\n+      enablePrepareGate();\n+      // Do not rewrite the marker file, since we verified it already exists.\n+      finishPrepare(prepareMarkerIndex, false);\n+    } else {\n+      // If the potentially faulty marker file cannot be deleted,\n+      // propagate the IOException.\n+      // If there is no marker file, this call sets the in memory state only.\n+      cancelPrepare();\n+    }\n+\n+    return status;\n+  }\n+\n+  /**\n+   * If the prepare gate is enabled, always returns true.\n+   * If the prepare gate is disabled, returns true only if {@code\n+   * requestType} is {@code Prepare} or {@code CancelPrepare}. Returns false\n+   * otherwise.\n+   */\n+  public synchronized boolean requestAllowed(Type requestType) {\n+    boolean requestAllowed = true;\n+\n+    if (prepareGateEnabled) {\n+      // TODO: Also return true for cancel prepare when it is implemented.\n+      requestAllowed = (requestType == Type.Prepare);\n+    }\n+\n+    return requestAllowed;\n+  }\n+\n+  /**\n+   * @return the current log index and status of preparation.\n+   * Both fields are returned together to provide a consistent view of the\n+   * state, which would not be guaranteed if they had to be retrieved through\n+   * separate getters.\n+   */\n+  public synchronized State getState() {\n+    return new State(prepareIndex, status);\n+  }\n+\n+  /**\n+   * Creates a prepare marker file inside {@code metadataDir} which contains\n+   * the log index {@code index}. If a marker file already exists, it will be\n+   * overwritten.\n+   */\n+  private void writePrepareMarkerFile(long index) throws IOException {\n+    File markerFile = getPrepareMarkerFile();\n+    File parentDir = markerFile.getParentFile();\n+    if (!parentDir.mkdirs()) {\n+      throw new IOException(\"Failed to create necessary directories in \" +\n+          \"marker file path: \" + parentDir);\n+    }\n+\n+    try(FileOutputStream stream = new FileOutputStream(markerFile)) {\n+      stream.write(Long.toString(index).getBytes(StandardCharsets.UTF_8));\n+    }\n+  }\n+\n+  private void deletePrepareMarkerFile()", "originalCommit": "ebdb679c7d2b4b186901b4ba1901fc9aebd1422d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAyOTQ4Mg==", "url": "https://github.com/apache/ozone/pull/1705#discussion_r548029482", "bodyText": "Done", "author": "errose28", "createdAt": "2020-12-23T16:04:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzczNjk5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzc0OTY2NQ==", "url": "https://github.com/apache/ozone/pull/1705#discussion_r547749665", "bodyText": "I believe this should be NOT_SUPPORTED_OPERATION_WHEN_PREPARED.", "author": "avijayanhwx", "createdAt": "2020-12-23T07:25:41Z", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/ozone/om/TestOzoneManagerPrepare.java", "diffHunk": "@@ -138,77 +112,116 @@ public void testPrepareWithTransactions() throws Exception {\n    */\n //  @Test\n   public void testPrepareDownedOM() throws Exception {\n+    setup();\n     // Index of the OM that will be shut down during this test.\n     final int shutdownOMIndex = 2;\n-\n-    MiniOzoneHAClusterImpl cluster = getCluster();\n-    OzoneClient ozClient = OzoneClientFactory.getRpcClient(getConf());\n-\n-    String volumeName = UUID.randomUUID().toString();\n-    String bucketName = UUID.randomUUID().toString();\n-    ObjectStore store = ozClient.getObjectStore();\n+    List<OzoneManager> runningOms = cluster.getOzoneManagersList();\n \n     // Create keys with all 3 OMs up.\n-    store.createVolume(volumeName);\n-    OzoneVolume volume = store.getVolume(volumeName);\n-    volume.createBucket(bucketName);\n-\n-    Set<String> writtenKeys = new HashSet<>();\n-    for (int i = 1; i <= 50; i++) {\n-      String keyName = keyPrefix + i;\n-      writeTestData(store, volumeName, bucketName, keyName);\n-      writtenKeys.add(keyName);\n-    }\n-\n-    // Make sure all OMs have logs from writing data, so we can check that\n-    // they are purged after prepare.\n-    for (OzoneManager om: cluster.getOzoneManagersList()) {\n-      LambdaTestUtils.await(timeoutMillis, 1000,\n-          () -> logFilesPresentInRatisPeer(om));\n-    }\n+    Set<String> writtenKeys = writeKeysAndWaitForLogs(10, runningOms);\n \n     // Shut down one OM.\n     cluster.stopOzoneManager(shutdownOMIndex);\n     OzoneManager downedOM = cluster.getOzoneManager(shutdownOMIndex);\n     Assert.assertFalse(downedOM.isRunning());\n+    Assert.assertEquals(runningOms.remove(shutdownOMIndex), downedOM);\n \n     // Write keys with the remaining OMs up.\n-    for (int i = 51; i <= 100; i++) {\n-      String keyName = keyPrefix + i;\n-      writeTestData(store, volumeName, bucketName, keyName);\n-      writtenKeys.add(keyName);\n-    }\n+    writtenKeys.addAll(\n+        writeKeysAndWaitForLogs(10, runningOms));\n \n-    OzoneManagerProtocol ozoneManagerClient =\n-        ozClient.getObjectStore().getClientProxy().getOzoneManagerClient();\n-    long prepareIndex = ozoneManagerClient.prepareOzoneManager(\n-        PREPARE_FLUSH_WAIT_TIMEOUT_SECONDS, PREPARE_FLUSH_INTERVAL_SECONDS);\n+    long prepareIndex = submitPrepareRequest();\n \n     // Check that the two live OMs are prepared.\n-    for (OzoneManager om: cluster.getOzoneManagersList()) {\n-      if (om != downedOM) {\n-        // Follower may still be applying transactions.\n-        waitAndCheckPrepared(om, prepareIndex);\n-      }\n-    }\n+    assertClusterPrepared(prepareIndex, runningOms);\n \n     // Restart the downed OM and wait for it to catch up.\n     // Since prepare was the last Ratis transaction, it should have all data\n     // it missed once it receives the prepare transaction.\n     cluster.restartOzoneManager(downedOM, true);\n-    LambdaTestUtils.await(timeoutMillis, 2000,\n-        () -> checkPrepared(downedOM, prepareIndex));\n+    runningOms.add(shutdownOMIndex, downedOM);\n \n     // Make sure all OMs are prepared and still have data.\n-    for (OzoneManager om: cluster.getOzoneManagersList()) {\n-      List<OmKeyInfo> readKeys = om.getMetadataManager().listKeys(volumeName,\n-          bucketName, null, keyPrefix, 100);\n+    assertClusterPrepared(prepareIndex, runningOms);\n+    assertKeysWritten(writtenKeys, runningOms);\n+  }\n+\n+  @Test\n+  public void testPrepareWithRestart() throws Exception {\n+    setup();\n+    writeKeysAndWaitForLogs(10);\n+    long prepareIndex = submitPrepareRequest();\n+    assertClusterPrepared(prepareIndex);\n+\n+    // Restart all ozone managers.\n+    cluster.restartOzoneManager();\n+\n+    // No check for cleared logs, since Ratis meta transactions may slip in\n+    // on restart.\n+    assertClusterPrepared(prepareIndex);\n+  }\n \n-      Assert.assertEquals(writtenKeys.size(), readKeys.size());\n-      for (OmKeyInfo keyInfo: readKeys) {\n-        Assert.assertTrue(writtenKeys.contains(keyInfo.getKeyName()));\n+  /**\n+   * Issues requests on ten different threads, for which one is a prepare and\n+   * the rest are create volume. We cannot be sure of the exact order that\n+   * the requests will execute, so this test checks that the cluster ends in\n+   * a prepared state, and that create volume requests either succeed, or fail\n+   * indicating the cluster was prepared before they were encountered.\n+   * @throws Exception\n+   */\n+  @Test\n+  public void testPrepareWithMultipleThreads() throws Exception {\n+    setup();\n+    final int numThreads = 10;\n+    final int prepareTaskIndex = 5;\n+\n+    ExecutorService executorService = Executors.newFixedThreadPool(numThreads);\n+    // For the prepare task, the future will return a log index.\n+    // For the create volume tasks, 0 (dummy value) will be returned.\n+    List<Future<Long>> tasks = new ArrayList<>();\n+\n+    for (int i = 0; i < numThreads; i++) {\n+      Callable<Long> task;\n+      if (i == prepareTaskIndex) {\n+        task = this::submitPrepareRequest;\n+      } else {\n+        String volumeName = VOLUME + i;\n+        task = () -> {\n+          clientProtocol.createVolume(volumeName);\n+          return 0L;\n+        };\n       }\n+      tasks.add(executorService.submit(task));\n     }\n+\n+    // For each task, wait for it to complete and check its result.\n+    for (int i = 0; i < numThreads; i++) {\n+      Future<Long> future = tasks.get(i);\n+\n+      if (i == prepareTaskIndex) {\n+        assertClusterPrepared(future.get());\n+        assertRatisLogsCleared();\n+      } else {\n+        try {\n+          // If this throws an exception, it should be an OMException\n+          // indicating failure because the cluster was already prepared.\n+          // If no exception is thrown, the volume should be created.\n+          future.get();\n+          String volumeName = VOLUME + i;\n+          Assert.assertTrue(clientProtocol.listVolumes(volumeName, \"\", 1)\n+              .stream()\n+              .anyMatch((vol) -> vol.getName().equals(volumeName)));\n+        } catch (ExecutionException ex) {\n+          Throwable cause = ex.getCause();\n+          Assert.assertTrue(cause instanceof OMException);\n+          Assert.assertEquals(OMException.ResultCodes.NOT_SUPPORTED_OPERATION,", "originalCommit": "ebdb679c7d2b4b186901b4ba1901fc9aebd1422d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAyMzkyNA==", "url": "https://github.com/apache/ozone/pull/1705#discussion_r548023924", "bodyText": "Right, fixed.", "author": "errose28", "createdAt": "2020-12-23T15:51:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzc0OTY2NQ=="}], "type": "inlineReview"}, {"oid": "bd45733ce74faadf7a38c0829e3193f8f4250522", "url": "https://github.com/apache/ozone/commit/bd45733ce74faadf7a38c0829e3193f8f4250522", "message": "Do not raise error if directories for marker file already exist", "committedDate": "2020-12-23T15:29:29Z", "type": "commit"}, {"oid": "db07867ac8e0501000ab475b2d8e797c81642480", "url": "https://github.com/apache/ozone/commit/db07867ac8e0501000ab475b2d8e797c81642480", "message": "Fix typos and add/improve log lines", "committedDate": "2020-12-23T16:06:55Z", "type": "commit"}, {"oid": "ddb9d7e098d5d1695ba52cd66c0567f427eceff3", "url": "https://github.com/apache/ozone/commit/ddb9d7e098d5d1695ba52cd66c0567f427eceff3", "message": "Add unit test for pre append", "committedDate": "2020-12-23T17:52:24Z", "type": "commit"}, {"oid": "f6cf4ca6fc06c9557a60529238dab6a310f30087", "url": "https://github.com/apache/ozone/commit/f6cf4ca6fc06c9557a60529238dab6a310f30087", "message": "Fix missed omexception result change", "committedDate": "2020-12-23T18:21:52Z", "type": "commit"}, {"oid": "0eb4fb23e7e51f635958dbb639401dc20fde9779", "url": "https://github.com/apache/ozone/commit/0eb4fb23e7e51f635958dbb639401dc20fde9779", "message": "Comment out test failing due to missing features and add waits for remaining tests\n\nTest involving OM restart should pass after HDDS-4610 and RATIS-1241.", "committedDate": "2020-12-23T20:21:24Z", "type": "commit"}]}