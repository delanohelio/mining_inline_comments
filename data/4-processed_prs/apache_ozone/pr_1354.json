{"pr_number": 1354, "pr_title": "HDDS-4151. Skip the inputstream while offset larger than zero in s3g", "pr_createdAt": "2020-08-26T12:18:10Z", "pr_url": "https://github.com/apache/ozone/pull/1354", "timeline": [{"oid": "d1a729785afef127a605e67195fc09e622b3b8e5", "url": "https://github.com/apache/ozone/commit/d1a729785afef127a605e67195fc09e622b3b8e5", "message": "HDDS-4151. Skip the inputstream while offset larger than zero in s3g", "committedDate": "2020-08-26T13:42:35Z", "type": "commit"}, {"oid": "d1a729785afef127a605e67195fc09e622b3b8e5", "url": "https://github.com/apache/ozone/commit/d1a729785afef127a605e67195fc09e622b3b8e5", "message": "HDDS-4151. Skip the inputstream while offset larger than zero in s3g", "committedDate": "2020-08-26T13:42:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY5ODYwNg==", "url": "https://github.com/apache/ozone/pull/1354#discussion_r477698606", "bodyText": "I understand that we do seek, because we don't do actual read just change the position at client. but using IOUtils.copyLarge we read and skip.\nNot sure if my understanding is right? If not, can you explain if I am missing anything here?", "author": "bharatviswa504", "createdAt": "2020-08-26T23:46:26Z", "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/endpoint/ObjectEndpoint.java", "diffHunk": "@@ -277,7 +278,8 @@ public Response get(\n           try (S3WrapperInputStream s3WrapperInputStream =\n               new S3WrapperInputStream(\n                   key.getInputStream())) {\n-            IOUtils.copyLarge(s3WrapperInputStream, dest, startOffset,\n+            s3WrapperInputStream.seek(startOffset);\n+            IOUtils.copyLarge(s3WrapperInputStream, dest, 0,", "originalCommit": "d1a729785afef127a605e67195fc09e622b3b8e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzg4NDk0Mw==", "url": "https://github.com/apache/ozone/pull/1354#discussion_r477884943", "bodyText": "The copyLarge related code is here\n    public static long copyLarge(final InputStream input, final OutputStream output,\n                                 final long inputOffset, final long length, final byte[] buffer) throws IOException {\n        if (inputOffset > 0) {\n            skipFully(input, inputOffset);\n        }\n        if (length == 0) {\n            return 0;\n        }\n        final int bufferLength = buffer.length;\n        int bytesToRead = bufferLength;\n        if (length > 0 && length < bufferLength) {\n            bytesToRead = (int) length;\n        }\n        int read;\n        long totalRead = 0;\n        while (bytesToRead > 0 && EOF != (read = input.read(buffer, 0, bytesToRead))) {\n            output.write(buffer, 0, read);\n            totalRead += read;\n            if (length > 0) { // only adjust length if not reading to the end\n                // Note the cast must work because buffer.length is an integer\n                bytesToRead = (int) Math.min(length - totalRead, bufferLength);\n            }\n        }\n        return totalRead;\n    }\n\n    public static void skipFully(final InputStream input, final long toSkip) throws IOException {\n        if (toSkip < 0) {\n            throw new IllegalArgumentException(\"Bytes to skip must not be negative: \" + toSkip);\n        }\n        final long skipped = skip(input, toSkip);\n        if (skipped != toSkip) {\n            throw new EOFException(\"Bytes to skip: \" + toSkip + \" actual: \" + skipped);\n        }\n    }\n\npublic static long skip(final InputStream input, final long toSkip) throws IOException {\n        if (toSkip < 0) {\n            throw new IllegalArgumentException(\"Skip count must be non-negative, actual: \" + toSkip);\n        }\n        /*\n         * N.B. no need to synchronize this because: - we don't care if the buffer is created multiple times (the data\n         * is ignored) - we always use the same size buffer, so if it it is recreated it will still be OK (if the buffer\n         * size were variable, we would need to synch. to ensure some other thread did not create a smaller one)\n         */\n        if (SKIP_BYTE_BUFFER == null) {\n            SKIP_BYTE_BUFFER = new byte[SKIP_BUFFER_SIZE];\n        }\n        long remain = toSkip;\n        while (remain > 0) {\n            // See https://issues.apache.org/jira/browse/IO-203 for why we use read() rather than delegating to skip()\n            final long n = input.read(SKIP_BYTE_BUFFER, 0, (int) Math.min(remain, SKIP_BUFFER_SIZE));\n            if (n < 0) { // EOF\n                break;\n            }\n            remain -= n;\n        }\n        return toSkip - remain;\n    }\nFrom the above code of IOUtils.java, we can know that the static method skip really read the inputstream, it is unnecessary and impact the performance, instead, using seek can set the position to the right point, Let's imaging that there are a 10GB file, when we want to read the if for offset 1GB and length 1GB, it have to read the first 1GB contents from datanode and drop it, now, we can seek to the position 1GB, and read the inputstream directly.", "author": "maobaolong", "createdAt": "2020-08-27T01:39:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY5ODYwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0NDg0Ng==", "url": "https://github.com/apache/ozone/pull/1354#discussion_r478744846", "bodyText": "Got it.", "author": "bharatviswa504", "createdAt": "2020-08-27T23:11:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY5ODYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY5OTY2Mw==", "url": "https://github.com/apache/ozone/pull/1354#discussion_r477699663", "bodyText": "skip again uses read and moves the position, why not use like above seek and call copylarge?", "author": "bharatviswa504", "createdAt": "2020-08-26T23:47:07Z", "path": "hadoop-ozone/s3gateway/src/main/java/org/apache/hadoop/ozone/s3/endpoint/ObjectEndpoint.java", "diffHunk": "@@ -557,8 +559,14 @@ private Response createMultipartKey(String bucket, String key, long length,\n             if (range != null) {\n               RangeHeader rangeHeader =\n                   RangeHeaderParserUtil.parseRangeHeader(range, 0);\n-              IOUtils.copyLarge(sourceObject, ozoneOutputStream,\n-                  rangeHeader.getStartOffset(),\n+              final long skipped =\n+                  sourceObject.skip(rangeHeader.getStartOffset());", "originalCommit": "d1a729785afef127a605e67195fc09e622b3b8e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Nzg5MTMwMQ==", "url": "https://github.com/apache/ozone/pull/1354#discussion_r477891301", "bodyText": "@bharatviswa504 use skip here due to we are not sure the sourceObject is a seekable inputstream, so I have to use skip method, but luckily, I have override the skip method in KeyInputStream.java, it look like\n  public long skip(long n) throws IOException {\n    if (n <= 0) {\n      return 0;\n    }\n\n    long toSkip = Math.min(n, length - getPos());\n    seek(getPos() + toSkip);\n    return toSkip;\n  }\nSo, for KeyInputStream which is an implementation of InputStream, which implements the skip method to a seek mode, it can bring the better performance.", "author": "maobaolong", "createdAt": "2020-08-27T01:44:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY5OTY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0NDM2MA==", "url": "https://github.com/apache/ozone/pull/1354#discussion_r478744360", "bodyText": "But we use OzoneInputStream here, which has not implemented the skip(). So we use from BaseClass InputStream, which does not take advantage of KeyInputStream seek implementation.\npublic long skip(long n) throws IOException {\n\n    long remaining = n;\n    int nr;\n\n    if (n <= 0) {\n        return 0;\n    }\n\n    int size = (int)Math.min(MAX_SKIP_BUFFER_SIZE, remaining);\n    byte[] skipBuffer = new byte[size];\n    while (remaining > 0) {\n        nr = read(skipBuffer, 0, (int)Math.min(size, remaining));\n        if (nr < 0) {\n            break;\n        }\n        remaining -= nr;\n    }\n\n    return n - remaining;\n}", "author": "bharatviswa504", "createdAt": "2020-08-27T23:10:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY5OTY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc0NDc2OA==", "url": "https://github.com/apache/ozone/pull/1354#discussion_r478744768", "bodyText": "Why can't we add seek to OzoneInputStream like how we have done for S3WrapperInputStream.\nAs anyway underlying inputStream used in OzoneInputStream is KeyInputStream which has implemented seek.", "author": "bharatviswa504", "createdAt": "2020-08-27T23:11:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY5OTY2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc3ODAxMw==", "url": "https://github.com/apache/ozone/pull/1354#discussion_r478778013", "bodyText": "@bharatviswa504 Thanks for your suggestion, indeed, it is necessary to override the skip method of OzoneInputStream, I've done it by the last commit.", "author": "maobaolong", "createdAt": "2020-08-28T01:15:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzY5OTY2Mw=="}], "type": "inlineReview"}, {"oid": "7d62336fc1ceea80061a1f4b36ad516d3d589d32", "url": "https://github.com/apache/ozone/commit/7d62336fc1ceea80061a1f4b36ad516d3d589d32", "message": "Override the skip method, using underlying skip inputstream.", "committedDate": "2020-08-28T01:13:55Z", "type": "commit"}]}