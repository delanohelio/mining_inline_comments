{"pr_number": 1009, "pr_title": "HDDS-3612. Document details of bucket mount design", "pr_createdAt": "2020-06-02T12:42:08Z", "pr_url": "https://github.com/apache/ozone/pull/1009", "timeline": [{"oid": "8c8dd0218bb9d1b04e166ccdcbef50b300307182", "url": "https://github.com/apache/ozone/commit/8c8dd0218bb9d1b04e166ccdcbef50b300307182", "message": "HDDS-3612. Document details of bucket mount design", "committedDate": "2020-06-02T11:35:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAxMTI1NA==", "url": "https://github.com/apache/ozone/pull/1009#discussion_r434011254", "bodyText": "You can remove my name, I really cannot claim any authorship credit for this idea. \ud83d\ude42", "author": "arp7", "createdAt": "2020-06-02T16:26:22Z", "path": "hadoop-hdds/docs/content/design/ozone-volume-management.md", "diffHunk": "@@ -4,7 +4,7 @@ summary: A simplified version of mapping between S3 buckets and Ozone volume/buc\n date: 2020-04-02\n jira: HDDS-3331\n status: accepted\n-author: Marton Elek, Arpit Agarwall, Sunjay Radia\n+author: Marton Elek, Arpit Agarwal, Sanjay Radia", "originalCommit": "8c8dd0218bb9d1b04e166ccdcbef50b300307182", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjY0NDY1OQ==", "url": "https://github.com/apache/ozone/pull/1009#discussion_r436644659", "bodyText": "@arp7 You wrote additional section to this document about the volume ownership problems.", "author": "elek", "createdAt": "2020-06-08T12:06:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAxMTI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAxMjI4Ng==", "url": "https://github.com/apache/ozone/pull/1009#discussion_r434012286", "bodyText": "Yeah this should work a lot like symlinks, so we shouldn't perform reverse checks on changes to the target bucket.", "author": "arp7", "createdAt": "2020-06-02T16:28:06Z", "path": "hadoop-hdds/docs/content/design/ozone-volume-management.md", "diffHunk": "@@ -106,19 +106,27 @@ This is an easy an fast method, but with this approach not all the volumes are a\n \n The first approach required a secondary cache table and it violates the naming hierarchy. The s3 bucket name is a global unique name, therefore it's more than just a single attribute on a specific object. It's more like an element in the hierachy. For this reason the second option is proposed:\n \n-For example if the default s3 volume is `s3`\n+For example if the default s3 volume is `s3v`\n \n- 1. Every new buckets created via s3 interface will be placed under the `/s3` volume\n- 2. Any existing **Ozone** buckets can be exposed with mounting it to s3: `ozone sh mount /vol1/bucket1 /s3/s3bucketname`\n+ 1. Every new buckets created via s3 interface will be placed under the `/s3v` volume\n+ 2. Any existing **Ozone** buckets can be exposed with mounting it to s3: `ozone sh mount /vol1/bucket1 /s3v/s3bucketname`\n \n **Lock contention problem**\n \n-One possible problem with using just one volume is using the locks of the same volume for all the D3 buckets (thanks Xiaoyu). But this shouldn't be a big problem.\n+One possible problem with using just one volume is using the locks of the same volume for all the S3 buckets (thanks Xiaoyu). But this shouldn't be a big problem.\n \n  1. We hold only a READ lock. Most of the time it can acquired without any contention (writing lock is required only to change owner / set quota)\n  2. For symbolic link / bind mounts the read lock is only required for the first read. After that the lock of the referenced volume will be used. In case of any performance problem multiple volumes + bind mounts can be used.\n \n-Note: Sunjay is added to the authors as the original proposal of this approach.\n+Note: Sanjay is added to the authors as the original proposal of this approach.\n+\n+#### Implementation details\n+\n+ * Let bucket mount operation create a link bucket.  Links are like regular buckets, stored in DB the same way, but with two new, optional pieces of information: source volume and bucket.\n+ * Existing bucket operations (info, delete, ACL) work on the link object in the same way as they do on regular buckets.  No new link-specific RPC is required.\n+ * Links are followed for key operations (list, get, put, etc.).  Checks for existence of the source bucket, as well as ACL, are performed at this time (similar to symlinks).  This avoids the need for reverse checks for each bucket delete or ACL change.", "originalCommit": "8c8dd0218bb9d1b04e166ccdcbef50b300307182", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAxMjcxNg==", "url": "https://github.com/apache/ozone/pull/1009#discussion_r434012716", "bodyText": "We should probably try to match the behavior of Unix symlinks wrt permissions.", "author": "arp7", "createdAt": "2020-06-02T16:28:47Z", "path": "hadoop-hdds/docs/content/design/ozone-volume-management.md", "diffHunk": "@@ -106,19 +106,27 @@ This is an easy an fast method, but with this approach not all the volumes are a\n \n The first approach required a secondary cache table and it violates the naming hierarchy. The s3 bucket name is a global unique name, therefore it's more than just a single attribute on a specific object. It's more like an element in the hierachy. For this reason the second option is proposed:\n \n-For example if the default s3 volume is `s3`\n+For example if the default s3 volume is `s3v`\n \n- 1. Every new buckets created via s3 interface will be placed under the `/s3` volume\n- 2. Any existing **Ozone** buckets can be exposed with mounting it to s3: `ozone sh mount /vol1/bucket1 /s3/s3bucketname`\n+ 1. Every new buckets created via s3 interface will be placed under the `/s3v` volume\n+ 2. Any existing **Ozone** buckets can be exposed with mounting it to s3: `ozone sh mount /vol1/bucket1 /s3v/s3bucketname`\n \n **Lock contention problem**\n \n-One possible problem with using just one volume is using the locks of the same volume for all the D3 buckets (thanks Xiaoyu). But this shouldn't be a big problem.\n+One possible problem with using just one volume is using the locks of the same volume for all the S3 buckets (thanks Xiaoyu). But this shouldn't be a big problem.\n \n  1. We hold only a READ lock. Most of the time it can acquired without any contention (writing lock is required only to change owner / set quota)\n  2. For symbolic link / bind mounts the read lock is only required for the first read. After that the lock of the referenced volume will be used. In case of any performance problem multiple volumes + bind mounts can be used.\n \n-Note: Sunjay is added to the authors as the original proposal of this approach.\n+Note: Sanjay is added to the authors as the original proposal of this approach.\n+\n+#### Implementation details\n+\n+ * Let bucket mount operation create a link bucket.  Links are like regular buckets, stored in DB the same way, but with two new, optional pieces of information: source volume and bucket.\n+ * Existing bucket operations (info, delete, ACL) work on the link object in the same way as they do on regular buckets.  No new link-specific RPC is required.\n+ * Links are followed for key operations (list, get, put, etc.).  Checks for existence of the source bucket, as well as ACL, are performed at this time (similar to symlinks).  This avoids the need for reverse checks for each bucket delete or ACL change.\n+ * The same permission is required on both the link and the source bucket to be able to perform the operation via the link.  This allows finer-grained access control.", "originalCommit": "8c8dd0218bb9d1b04e166ccdcbef50b300307182", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAxMzY4NA==", "url": "https://github.com/apache/ozone/pull/1009#discussion_r434013684", "bodyText": "Let bucket mount operation create a link bucket\n\nDidn't understand this sentence. Does it mean that when you try to mount a bucket in a new volume it silently creates a link under the covers? Is the link reused next time we try to mount again?\nAlso how do we handle name collisions? Can the user choose any name for the link/mount point?", "author": "arp7", "createdAt": "2020-06-02T16:30:14Z", "path": "hadoop-hdds/docs/content/design/ozone-volume-management.md", "diffHunk": "@@ -106,19 +106,27 @@ This is an easy an fast method, but with this approach not all the volumes are a\n \n The first approach required a secondary cache table and it violates the naming hierarchy. The s3 bucket name is a global unique name, therefore it's more than just a single attribute on a specific object. It's more like an element in the hierachy. For this reason the second option is proposed:\n \n-For example if the default s3 volume is `s3`\n+For example if the default s3 volume is `s3v`\n \n- 1. Every new buckets created via s3 interface will be placed under the `/s3` volume\n- 2. Any existing **Ozone** buckets can be exposed with mounting it to s3: `ozone sh mount /vol1/bucket1 /s3/s3bucketname`\n+ 1. Every new buckets created via s3 interface will be placed under the `/s3v` volume\n+ 2. Any existing **Ozone** buckets can be exposed with mounting it to s3: `ozone sh mount /vol1/bucket1 /s3v/s3bucketname`\n \n **Lock contention problem**\n \n-One possible problem with using just one volume is using the locks of the same volume for all the D3 buckets (thanks Xiaoyu). But this shouldn't be a big problem.\n+One possible problem with using just one volume is using the locks of the same volume for all the S3 buckets (thanks Xiaoyu). But this shouldn't be a big problem.\n \n  1. We hold only a READ lock. Most of the time it can acquired without any contention (writing lock is required only to change owner / set quota)\n  2. For symbolic link / bind mounts the read lock is only required for the first read. After that the lock of the referenced volume will be used. In case of any performance problem multiple volumes + bind mounts can be used.\n \n-Note: Sunjay is added to the authors as the original proposal of this approach.\n+Note: Sanjay is added to the authors as the original proposal of this approach.\n+\n+#### Implementation details\n+\n+ * Let bucket mount operation create a link bucket.  Links are like regular buckets, stored in DB the same way, but with two new, optional pieces of information: source volume and bucket.", "originalCommit": "8c8dd0218bb9d1b04e166ccdcbef50b300307182", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAzMDI0Mg==", "url": "https://github.com/apache/ozone/pull/1009#discussion_r434030242", "bodyText": "Let bucket mount operation create a link bucket\n\nDidn't understand this sentence. Does it mean that when you try to mount a bucket in a new volume it silently creates a link under the covers?\n\nMount and link are the same.  (Even the high-level parts of the doc refer to it as \"link\" in some places and \"mount\" in others.  Maybe we should not mix terminology.  Since proposed behavior is closer to symlinks, I suggest using \"link\" instead of \"mount\".)\n\nIs the link reused next time we try to mount again?\n\nThe mount is \"active\" until the link is deleted via regular DeleteBucket request.  Until then, another attempt to mount (or create a bucket with same name) will result in a \"bucket already exists\" error.\n\nAlso how do we handle name collisions? Can the user choose any name for the link/mount point?\n\nName collision is handled the same as if trying to create a regular bucket.\nBasically, the extra link info does not change behavior until client starts working with keys in the \"bucket\".  Then it is redirected.", "author": "adoroszlai", "createdAt": "2020-06-02T16:56:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAxMzY4NA=="}], "type": "inlineReview"}, {"oid": "be5f111ea0ecf553b9203dded2e25f9842e693a8", "url": "https://github.com/apache/ozone/commit/be5f111ea0ecf553b9203dded2e25f9842e693a8", "message": "HDDS-3612. Only require read permission for following links", "committedDate": "2020-06-05T07:03:31Z", "type": "commit"}, {"oid": "ed6f7a628c3a93e9b112882b038cd0b383775966", "url": "https://github.com/apache/ozone/commit/ed6f7a628c3a93e9b112882b038cd0b383775966", "message": "HDDS-3612. Clarify link behavior, drop \"mount\" terminology", "committedDate": "2020-06-05T07:19:25Z", "type": "commit"}, {"oid": "4337bed7ab57d87452e053d0adf9e2a60c8bfe89", "url": "https://github.com/apache/ozone/commit/4337bed7ab57d87452e053d0adf9e2a60c8bfe89", "message": "trigger new CI check", "committedDate": "2020-06-05T08:20:11Z", "type": "commit"}, {"oid": "04a42c14fd2e8dc106efe91ee44f239f05b43311", "url": "https://github.com/apache/ozone/commit/04a42c14fd2e8dc106efe91ee44f239f05b43311", "message": "trigger new CI check", "committedDate": "2020-06-05T11:36:10Z", "type": "commit"}]}