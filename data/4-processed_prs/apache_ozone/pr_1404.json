{"pr_number": 1404, "pr_title": "HDDS-2949: mkdir : store directory entries in a separate table", "pr_createdAt": "2020-09-07T17:15:29Z", "pr_url": "https://github.com/apache/ozone/pull/1404", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzNTIyOA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r485035228", "bodyText": "Wrong log instance name, TestOzoneFileSystem -> TestOzoneDirectory", "author": "linyiqun", "createdAt": "2020-09-08T16:05:48Z", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneDirectory.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.\u2002\u2002See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.\u2002\u2002The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.\u2002\u2002You may obtain a copy of the License at\n+ *\n+ * \u2002\u2002\u2002\u2002 http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.hadoop.fs.*;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.TableIterator;\n+import org.apache.hadoop.ozone.MiniOzoneCluster;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.TestDataUtil;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.om.OMConfigKeys;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.util.StringUtils;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.apache.hadoop.fs.CommonConfigurationKeysPublic.FS_TRASH_INTERVAL_KEY;\n+import static org.apache.hadoop.ozone.OzoneConfigKeys.OZONE_FS_ITERATE_BATCH_SIZE;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Test verifies the entries and operations in directory table.\n+ */\n+public class TestOzoneDirectory {\n+\n+  @Rule\n+  public Timeout timeout = new Timeout(300000);\n+\n+  private static final Logger LOG =\n+          LoggerFactory.getLogger(TestOzoneFileSystem.class);", "originalCommit": "af21eda4b80d02c0643bafc84ab84bc0a63aa04e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUyNzUwNA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r485527504", "bodyText": "Will do it. Thanks!", "author": "rakeshadr", "createdAt": "2020-09-09T11:07:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzNTIyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzNzUyOA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r485037528", "bodyText": "Just a comment: will we introduced DIR_LOCK for dir table update in the future?", "author": "linyiqun", "createdAt": "2020-09-08T16:09:33Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMDirectoryCreateRequestV1.java", "diffHunk": "@@ -0,0 +1,313 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.file;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.*;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.file.OMDirectoryCreateResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .Status;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.FILE_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.INVALID_KEY_NAME;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+import static org.apache.hadoop.ozone.om.request.file.OMFileRequest.OMDirectoryResult.*;\n+\n+/**\n+ * Handle create directory request. It will add path components to the directory\n+ * table and maintains file system semantics.\n+ */\n+public class OMDirectoryCreateRequestV1 extends OMDirectoryCreateRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMDirectoryCreateRequestV1.class);\n+\n+  public OMDirectoryCreateRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    CreateDirectoryRequest createDirectoryRequest = getOmRequest()\n+        .getCreateDirectoryRequest();\n+    KeyArgs keyArgs = createDirectoryRequest.getKeyArgs();\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+    omResponse.setCreateDirectoryResponse(CreateDirectoryResponse.newBuilder());\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumCreateDirectory();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+    OzoneManagerProtocolProtos.UserInfo userInfo = getOmRequest().getUserInfo();\n+\n+    Map<String, String> auditMap = buildKeyArgsAuditMap(keyArgs);\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = Result.FAILURE;\n+    List<OmDirectoryInfo> missingParentInfos;\n+\n+    try {\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acl\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+          IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      // Check if this is the root of the filesystem.\n+      if (keyName.length() == 0) {\n+        throw new OMException(\"Directory create failed. Cannot create \" +\n+            \"directory at root of the filesystem\",\n+            OMException.ResultCodes.CANNOT_CREATE_DIRECTORY_AT_ROOT);\n+      }\n+      // acquire lock\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,", "originalCommit": "af21eda4b80d02c0643bafc84ab84bc0a63aa04e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUyNzM3NQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r485527375", "bodyText": "Yes, exactly. This is long term goal and will kick start once the primary changes are IN.", "author": "rakeshadr", "createdAt": "2020-09-09T11:07:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTAzNzUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5NDkxMg==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488394912", "bodyText": "Minor:\nHere this should be like this.ozoneAcls.add(ozoneacls)", "author": "bharatviswa504", "createdAt": "2020-09-15T05:30:30Z", "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmDirectoryInfo.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.helpers;\n+\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+\n+import java.util.*;\n+\n+/**\n+ * This class represents the directory information by keeping each component\n+ * in the user given path and a pointer to its parent directory element in the\n+ * path. Also, it stores directory node related metdata details.\n+ */\n+public class OmDirectoryInfo extends WithObjectID {\n+  private long parentObjectID; // pointer to parent directory\n+\n+  private String name; // directory name\n+\n+  private long creationTime;\n+  private long modificationTime;\n+\n+  private List<OzoneAcl> acls;\n+\n+  public OmDirectoryInfo(Builder builder) {\n+    this.name = builder.name;\n+    this.acls = builder.acls;\n+    this.metadata = builder.metadata;\n+    this.objectID = builder.objectID;\n+    this.updateID = builder.updateID;\n+    this.parentObjectID = builder.parentObjectID;\n+    this.creationTime = builder.creationTime;\n+    this.modificationTime = builder.modificationTime;\n+  }\n+\n+  /**\n+   * Returns new builder class that builds a OmPrefixInfo.\n+   *\n+   * @return Builder\n+   */\n+  public static OmDirectoryInfo.Builder newBuilder() {\n+    return new OmDirectoryInfo.Builder();\n+  }\n+\n+  /**\n+   * Builder for Directory Info.\n+   */\n+  public static class Builder {\n+    private long parentObjectID; // pointer to parent directory\n+\n+    private long objectID;\n+    private long updateID;\n+\n+    private String name;\n+\n+    private long creationTime;\n+    private long modificationTime;\n+\n+    private List<OzoneAcl> acls;\n+    private Map<String, String> metadata;\n+\n+    public Builder() {\n+      //Default values\n+      this.acls = new LinkedList<>();\n+      this.metadata = new HashMap<>();\n+    }\n+\n+    public Builder setParentObjectID(long parentObjectId) {\n+      this.parentObjectID = parentObjectId;\n+      return this;\n+    }\n+\n+    public Builder setObjectID(long objectId) {\n+      this.objectID = objectId;\n+      return this;\n+    }\n+\n+    public Builder setUpdateID(long updateId) {\n+      this.updateID = updateId;\n+      return this;\n+    }\n+\n+    public Builder setName(String dirName) {\n+      this.name = dirName;\n+      return this;\n+    }\n+\n+    public Builder setCreationTime(long newCreationTime) {\n+      this.creationTime = newCreationTime;\n+      return this;\n+    }\n+\n+    public Builder setModificationTime(long newModificationTime) {\n+      this.modificationTime = newModificationTime;\n+      return this;\n+    }\n+\n+    public Builder setAcls(List<OzoneAcl> newAcls) {\n+      this.acls = newAcls;", "originalCommit": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDc2OA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r491970768", "bodyText": "Sure, will take care", "author": "rakeshadr", "createdAt": "2020-09-21T11:32:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5NDkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5NTEzOA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488395138", "bodyText": "Minor:\nHere this should be like this.metadata.putAll(newMetadata)", "author": "bharatviswa504", "createdAt": "2020-09-15T05:31:15Z", "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmDirectoryInfo.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.helpers;\n+\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+\n+import java.util.*;\n+\n+/**\n+ * This class represents the directory information by keeping each component\n+ * in the user given path and a pointer to its parent directory element in the\n+ * path. Also, it stores directory node related metdata details.\n+ */\n+public class OmDirectoryInfo extends WithObjectID {\n+  private long parentObjectID; // pointer to parent directory\n+\n+  private String name; // directory name\n+\n+  private long creationTime;\n+  private long modificationTime;\n+\n+  private List<OzoneAcl> acls;\n+\n+  public OmDirectoryInfo(Builder builder) {\n+    this.name = builder.name;\n+    this.acls = builder.acls;\n+    this.metadata = builder.metadata;\n+    this.objectID = builder.objectID;\n+    this.updateID = builder.updateID;\n+    this.parentObjectID = builder.parentObjectID;\n+    this.creationTime = builder.creationTime;\n+    this.modificationTime = builder.modificationTime;\n+  }\n+\n+  /**\n+   * Returns new builder class that builds a OmPrefixInfo.\n+   *\n+   * @return Builder\n+   */\n+  public static OmDirectoryInfo.Builder newBuilder() {\n+    return new OmDirectoryInfo.Builder();\n+  }\n+\n+  /**\n+   * Builder for Directory Info.\n+   */\n+  public static class Builder {\n+    private long parentObjectID; // pointer to parent directory\n+\n+    private long objectID;\n+    private long updateID;\n+\n+    private String name;\n+\n+    private long creationTime;\n+    private long modificationTime;\n+\n+    private List<OzoneAcl> acls;\n+    private Map<String, String> metadata;\n+\n+    public Builder() {\n+      //Default values\n+      this.acls = new LinkedList<>();\n+      this.metadata = new HashMap<>();\n+    }\n+\n+    public Builder setParentObjectID(long parentObjectId) {\n+      this.parentObjectID = parentObjectId;\n+      return this;\n+    }\n+\n+    public Builder setObjectID(long objectId) {\n+      this.objectID = objectId;\n+      return this;\n+    }\n+\n+    public Builder setUpdateID(long updateId) {\n+      this.updateID = updateId;\n+      return this;\n+    }\n+\n+    public Builder setName(String dirName) {\n+      this.name = dirName;\n+      return this;\n+    }\n+\n+    public Builder setCreationTime(long newCreationTime) {\n+      this.creationTime = newCreationTime;\n+      return this;\n+    }\n+\n+    public Builder setModificationTime(long newModificationTime) {\n+      this.modificationTime = newModificationTime;\n+      return this;\n+    }\n+\n+    public Builder setAcls(List<OzoneAcl> newAcls) {\n+      this.acls = newAcls;\n+      return this;\n+    }\n+\n+    public Builder addAcl(OzoneAcl ozoneAcl) {\n+      if (ozoneAcl != null) {\n+        this.acls.add(ozoneAcl);\n+      }\n+      return this;\n+    }\n+\n+    public Builder setMetadata(Map<String, String> newMetadata) {\n+      this.metadata = newMetadata;", "originalCommit": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDc0NQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r491970745", "bodyText": "Sure, will take care", "author": "rakeshadr", "createdAt": "2020-09-21T11:32:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5NTEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5NTczNg==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488395736", "bodyText": "Do we need to atleast print getObjectID() + name here?", "author": "bharatviswa504", "createdAt": "2020-09-15T05:33:10Z", "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmDirectoryInfo.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.helpers;\n+\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+\n+import java.util.*;\n+\n+/**\n+ * This class represents the directory information by keeping each component\n+ * in the user given path and a pointer to its parent directory element in the\n+ * path. Also, it stores directory node related metdata details.\n+ */\n+public class OmDirectoryInfo extends WithObjectID {\n+  private long parentObjectID; // pointer to parent directory\n+\n+  private String name; // directory name\n+\n+  private long creationTime;\n+  private long modificationTime;\n+\n+  private List<OzoneAcl> acls;\n+\n+  public OmDirectoryInfo(Builder builder) {\n+    this.name = builder.name;\n+    this.acls = builder.acls;\n+    this.metadata = builder.metadata;\n+    this.objectID = builder.objectID;\n+    this.updateID = builder.updateID;\n+    this.parentObjectID = builder.parentObjectID;\n+    this.creationTime = builder.creationTime;\n+    this.modificationTime = builder.modificationTime;\n+  }\n+\n+  /**\n+   * Returns new builder class that builds a OmPrefixInfo.\n+   *\n+   * @return Builder\n+   */\n+  public static OmDirectoryInfo.Builder newBuilder() {\n+    return new OmDirectoryInfo.Builder();\n+  }\n+\n+  /**\n+   * Builder for Directory Info.\n+   */\n+  public static class Builder {\n+    private long parentObjectID; // pointer to parent directory\n+\n+    private long objectID;\n+    private long updateID;\n+\n+    private String name;\n+\n+    private long creationTime;\n+    private long modificationTime;\n+\n+    private List<OzoneAcl> acls;\n+    private Map<String, String> metadata;\n+\n+    public Builder() {\n+      //Default values\n+      this.acls = new LinkedList<>();\n+      this.metadata = new HashMap<>();\n+    }\n+\n+    public Builder setParentObjectID(long parentObjectId) {\n+      this.parentObjectID = parentObjectId;\n+      return this;\n+    }\n+\n+    public Builder setObjectID(long objectId) {\n+      this.objectID = objectId;\n+      return this;\n+    }\n+\n+    public Builder setUpdateID(long updateId) {\n+      this.updateID = updateId;\n+      return this;\n+    }\n+\n+    public Builder setName(String dirName) {\n+      this.name = dirName;\n+      return this;\n+    }\n+\n+    public Builder setCreationTime(long newCreationTime) {\n+      this.creationTime = newCreationTime;\n+      return this;\n+    }\n+\n+    public Builder setModificationTime(long newModificationTime) {\n+      this.modificationTime = newModificationTime;\n+      return this;\n+    }\n+\n+    public Builder setAcls(List<OzoneAcl> newAcls) {\n+      this.acls = newAcls;\n+      return this;\n+    }\n+\n+    public Builder addAcl(OzoneAcl ozoneAcl) {\n+      if (ozoneAcl != null) {\n+        this.acls.add(ozoneAcl);\n+      }\n+      return this;\n+    }\n+\n+    public Builder setMetadata(Map<String, String> newMetadata) {\n+      this.metadata = newMetadata;\n+      return this;\n+    }\n+\n+    public Builder addMetadata(String key, String value) {\n+      metadata.put(key, value);\n+      return this;\n+    }\n+\n+    public Builder addAllMetadata(Map<String, String> additionalMetadata) {\n+      if (additionalMetadata != null) {\n+        metadata.putAll(additionalMetadata);\n+      }\n+      return this;\n+    }\n+\n+    public OmDirectoryInfo build() {\n+      return new OmDirectoryInfo(this);\n+    }\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return getObjectID() + \"\";", "originalCommit": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDY5Mw==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r491970693", "bodyText": "Sure, will take care", "author": "rakeshadr", "createdAt": "2020-09-21T11:32:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5NTczNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5NjgxMw==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488396813", "bodyText": "Minor: New line missing at end of file.", "author": "bharatviswa504", "createdAt": "2020-09-15T05:36:21Z", "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmDirectoryInfo.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.helpers;\n+\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+\n+import java.util.*;\n+\n+/**\n+ * This class represents the directory information by keeping each component\n+ * in the user given path and a pointer to its parent directory element in the\n+ * path. Also, it stores directory node related metdata details.\n+ */\n+public class OmDirectoryInfo extends WithObjectID {\n+  private long parentObjectID; // pointer to parent directory\n+\n+  private String name; // directory name\n+\n+  private long creationTime;\n+  private long modificationTime;\n+\n+  private List<OzoneAcl> acls;\n+\n+  public OmDirectoryInfo(Builder builder) {\n+    this.name = builder.name;\n+    this.acls = builder.acls;\n+    this.metadata = builder.metadata;\n+    this.objectID = builder.objectID;\n+    this.updateID = builder.updateID;\n+    this.parentObjectID = builder.parentObjectID;\n+    this.creationTime = builder.creationTime;\n+    this.modificationTime = builder.modificationTime;\n+  }\n+\n+  /**\n+   * Returns new builder class that builds a OmPrefixInfo.\n+   *\n+   * @return Builder\n+   */\n+  public static OmDirectoryInfo.Builder newBuilder() {\n+    return new OmDirectoryInfo.Builder();\n+  }\n+\n+  /**\n+   * Builder for Directory Info.\n+   */\n+  public static class Builder {\n+    private long parentObjectID; // pointer to parent directory\n+\n+    private long objectID;\n+    private long updateID;\n+\n+    private String name;\n+\n+    private long creationTime;\n+    private long modificationTime;\n+\n+    private List<OzoneAcl> acls;\n+    private Map<String, String> metadata;\n+\n+    public Builder() {\n+      //Default values\n+      this.acls = new LinkedList<>();\n+      this.metadata = new HashMap<>();\n+    }\n+\n+    public Builder setParentObjectID(long parentObjectId) {\n+      this.parentObjectID = parentObjectId;\n+      return this;\n+    }\n+\n+    public Builder setObjectID(long objectId) {\n+      this.objectID = objectId;\n+      return this;\n+    }\n+\n+    public Builder setUpdateID(long updateId) {\n+      this.updateID = updateId;\n+      return this;\n+    }\n+\n+    public Builder setName(String dirName) {\n+      this.name = dirName;\n+      return this;\n+    }\n+\n+    public Builder setCreationTime(long newCreationTime) {\n+      this.creationTime = newCreationTime;\n+      return this;\n+    }\n+\n+    public Builder setModificationTime(long newModificationTime) {\n+      this.modificationTime = newModificationTime;\n+      return this;\n+    }\n+\n+    public Builder setAcls(List<OzoneAcl> newAcls) {\n+      this.acls = newAcls;\n+      return this;\n+    }\n+\n+    public Builder addAcl(OzoneAcl ozoneAcl) {\n+      if (ozoneAcl != null) {\n+        this.acls.add(ozoneAcl);\n+      }\n+      return this;\n+    }\n+\n+    public Builder setMetadata(Map<String, String> newMetadata) {\n+      this.metadata = newMetadata;\n+      return this;\n+    }\n+\n+    public Builder addMetadata(String key, String value) {\n+      metadata.put(key, value);\n+      return this;\n+    }\n+\n+    public Builder addAllMetadata(Map<String, String> additionalMetadata) {\n+      if (additionalMetadata != null) {\n+        metadata.putAll(additionalMetadata);\n+      }\n+      return this;\n+    }\n+\n+    public OmDirectoryInfo build() {\n+      return new OmDirectoryInfo(this);\n+    }\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return getObjectID() + \"\";\n+  }\n+\n+  public long getParentObjectID() {\n+    return parentObjectID;\n+  }\n+\n+  public String getPath() {\n+    return getParentObjectID() + OzoneConsts.OM_KEY_PREFIX + getName();\n+  }\n+\n+  public String getName() {\n+    return name;\n+  }\n+\n+  public long getCreationTime() {\n+    return creationTime;\n+  }\n+\n+  public long getModificationTime() {\n+    return modificationTime;\n+  }\n+\n+  public List<OzoneAcl> getAcls() {\n+    return acls;\n+  }\n+\n+  /**\n+   * Creates DirectoryInfo protobuf from OmDirectoryInfo.\n+   */\n+  public OzoneManagerProtocolProtos.DirectoryInfo getProtobuf() {\n+    OzoneManagerProtocolProtos.DirectoryInfo.Builder pib =\n+            OzoneManagerProtocolProtos.DirectoryInfo.newBuilder().setName(name)\n+                    .setCreationTime(creationTime)\n+                    .setModificationTime(modificationTime)\n+                    .addAllMetadata(KeyValueUtil.toProtobuf(metadata))\n+                    .setObjectID(objectID)\n+                    .setUpdateID(updateID)\n+                    .setParentID(parentObjectID);\n+    if (acls != null) {\n+      pib.addAllAcls(OzoneAclUtil.toProtobuf(acls));\n+    }\n+    return pib.build();\n+  }\n+\n+  /**\n+   * Parses DirectoryInfo protobuf and creates OmPrefixInfo.\n+   * @param dirInfo\n+   * @return instance of OmDirectoryInfo\n+   */\n+  public static OmDirectoryInfo getFromProtobuf(\n+          OzoneManagerProtocolProtos.DirectoryInfo dirInfo) {\n+    OmDirectoryInfo.Builder opib = OmDirectoryInfo.newBuilder()\n+            .setName(dirInfo.getName())\n+            .setCreationTime(dirInfo.getCreationTime())\n+            .setModificationTime(dirInfo.getModificationTime())\n+            .setAcls(OzoneAclUtil.fromProtobuf(dirInfo.getAclsList()));\n+    if (dirInfo.getMetadataList() != null) {\n+      opib.addAllMetadata(KeyValueUtil\n+              .getFromProtobuf(dirInfo.getMetadataList()));\n+    }\n+    if (dirInfo.hasObjectID()) {\n+      opib.setObjectID(dirInfo.getObjectID());\n+    }\n+    if (dirInfo.hasParentID()) {\n+      opib.setParentObjectID(dirInfo.getParentID());\n+    }\n+    if (dirInfo.hasUpdateID()) {\n+      opib.setUpdateID(dirInfo.getUpdateID());\n+    }\n+    return opib.build();\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (this == o) {\n+      return true;\n+    }\n+    if (o == null || getClass() != o.getClass()) {\n+      return false;\n+    }\n+    OmDirectoryInfo omDirInfo = (OmDirectoryInfo) o;\n+    return creationTime == omDirInfo.creationTime &&\n+            modificationTime == omDirInfo.modificationTime &&\n+            name.equals(omDirInfo.name) &&\n+            Objects.equals(metadata, omDirInfo.metadata) &&\n+            Objects.equals(acls, omDirInfo.acls) &&\n+            objectID == omDirInfo.objectID &&\n+            updateID == omDirInfo.updateID &&\n+            parentObjectID == omDirInfo.parentObjectID;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return Objects.hash(objectID, parentObjectID, name);\n+  }\n+\n+  /**\n+   * Return a new copy of the object.\n+   */\n+  public OmDirectoryInfo copyObject() {\n+    OmDirectoryInfo.Builder builder = new Builder()\n+            .setName(name)\n+            .setCreationTime(creationTime)\n+            .setModificationTime(modificationTime)\n+            .setParentObjectID(parentObjectID)\n+            .setObjectID(objectID)\n+            .setUpdateID(updateID);\n+\n+    acls.forEach(acl -> builder.addAcl(new OzoneAcl(acl.getType(),\n+            acl.getName(), (BitSet) acl.getAclBitSet().clone(),\n+            acl.getAclScope())));\n+\n+    if (metadata != null) {\n+      metadata.forEach((k, v) -> builder.addMetadata(k, v));\n+    }\n+\n+    return builder.build();\n+  }\n+}", "originalCommit": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDYyNQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r491970625", "bodyText": "Sure, will take care. One doubt, can't checkstyle detect this?", "author": "rakeshadr", "createdAt": "2020-09-21T11:31:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5NjgxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5Nzc0Ng==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488397746", "bodyText": "Minor: Newline missing at end of the file.", "author": "bharatviswa504", "createdAt": "2020-09-15T05:39:21Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/codec/OmDirectoryInfoCodec.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.codec;\n+\n+import com.google.common.base.Preconditions;\n+import com.google.protobuf.InvalidProtocolBufferException;\n+import org.apache.hadoop.hdds.utils.db.Codec;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.DirectoryInfo;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Codec to encode OmDirectoryInfo as byte array.\n+ */\n+public class OmDirectoryInfoCodec implements Codec<OmDirectoryInfo> {\n+\n+  @Override\n+  public byte[] toPersistedFormat(OmDirectoryInfo object) throws IOException {\n+    Preconditions\n+            .checkNotNull(object, \"Null object can't be converted \" +\n+                    \"to byte array.\");\n+    return object.getProtobuf().toByteArray();\n+  }\n+\n+  @Override\n+  public OmDirectoryInfo fromPersistedFormat(byte[] rawData)\n+          throws IOException {\n+    Preconditions\n+            .checkNotNull(rawData,\n+                    \"Null byte array can't converted to real object.\");\n+    try {\n+      return OmDirectoryInfo.getFromProtobuf(DirectoryInfo.parseFrom(rawData));\n+    } catch (InvalidProtocolBufferException e) {\n+      throw new IllegalArgumentException(\n+              \"Can't encode the the raw data from the byte array\", e);\n+    }\n+  }\n+\n+  @Override\n+  public OmDirectoryInfo copyObject(OmDirectoryInfo object) {\n+    return object.copyObject();\n+  }\n+}", "originalCommit": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDQxMQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r491970411", "bodyText": "Sure, will take care", "author": "rakeshadr", "createdAt": "2020-09-21T11:31:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5Nzc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5OTQ3OA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488399478", "bodyText": "once we change setMetadata with the same code, we can remove this API.", "author": "bharatviswa504", "createdAt": "2020-09-15T05:44:31Z", "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmDirectoryInfo.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.helpers;\n+\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+\n+import java.util.*;\n+\n+/**\n+ * This class represents the directory information by keeping each component\n+ * in the user given path and a pointer to its parent directory element in the\n+ * path. Also, it stores directory node related metdata details.\n+ */\n+public class OmDirectoryInfo extends WithObjectID {\n+  private long parentObjectID; // pointer to parent directory\n+\n+  private String name; // directory name\n+\n+  private long creationTime;\n+  private long modificationTime;\n+\n+  private List<OzoneAcl> acls;\n+\n+  public OmDirectoryInfo(Builder builder) {\n+    this.name = builder.name;\n+    this.acls = builder.acls;\n+    this.metadata = builder.metadata;\n+    this.objectID = builder.objectID;\n+    this.updateID = builder.updateID;\n+    this.parentObjectID = builder.parentObjectID;\n+    this.creationTime = builder.creationTime;\n+    this.modificationTime = builder.modificationTime;\n+  }\n+\n+  /**\n+   * Returns new builder class that builds a OmPrefixInfo.\n+   *\n+   * @return Builder\n+   */\n+  public static OmDirectoryInfo.Builder newBuilder() {\n+    return new OmDirectoryInfo.Builder();\n+  }\n+\n+  /**\n+   * Builder for Directory Info.\n+   */\n+  public static class Builder {\n+    private long parentObjectID; // pointer to parent directory\n+\n+    private long objectID;\n+    private long updateID;\n+\n+    private String name;\n+\n+    private long creationTime;\n+    private long modificationTime;\n+\n+    private List<OzoneAcl> acls;\n+    private Map<String, String> metadata;\n+\n+    public Builder() {\n+      //Default values\n+      this.acls = new LinkedList<>();\n+      this.metadata = new HashMap<>();\n+    }\n+\n+    public Builder setParentObjectID(long parentObjectId) {\n+      this.parentObjectID = parentObjectId;\n+      return this;\n+    }\n+\n+    public Builder setObjectID(long objectId) {\n+      this.objectID = objectId;\n+      return this;\n+    }\n+\n+    public Builder setUpdateID(long updateId) {\n+      this.updateID = updateId;\n+      return this;\n+    }\n+\n+    public Builder setName(String dirName) {\n+      this.name = dirName;\n+      return this;\n+    }\n+\n+    public Builder setCreationTime(long newCreationTime) {\n+      this.creationTime = newCreationTime;\n+      return this;\n+    }\n+\n+    public Builder setModificationTime(long newModificationTime) {\n+      this.modificationTime = newModificationTime;\n+      return this;\n+    }\n+\n+    public Builder setAcls(List<OzoneAcl> newAcls) {\n+      this.acls = newAcls;\n+      return this;\n+    }\n+\n+    public Builder addAcl(OzoneAcl ozoneAcl) {\n+      if (ozoneAcl != null) {\n+        this.acls.add(ozoneAcl);\n+      }\n+      return this;\n+    }\n+\n+    public Builder setMetadata(Map<String, String> newMetadata) {\n+      this.metadata = newMetadata;\n+      return this;\n+    }\n+\n+    public Builder addMetadata(String key, String value) {\n+      metadata.put(key, value);\n+      return this;\n+    }\n+\n+    public Builder addAllMetadata(Map<String, String> additionalMetadata) {", "originalCommit": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDM4Mg==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r491970382", "bodyText": "Sure, will take care", "author": "rakeshadr", "createdAt": "2020-09-21T11:31:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5OTQ3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NjgxMA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496146810", "bodyText": "Here still addallMetadata is there and setMetadata is removed.\nI think that should be fine, but if we can name it as setMetadata it will be uniform with setAcls", "author": "bharatviswa504", "createdAt": "2020-09-28T18:21:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5OTQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxNTIxOQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488915219", "bodyText": "Can we add a unit test similar to TestOMDirectoryCreateRequest.java", "author": "bharatviswa504", "createdAt": "2020-09-15T19:26:58Z", "path": "hadoop-ozone/integration-test/src/test/java/org/apache/hadoop/fs/ozone/TestOzoneDirectory.java", "diffHunk": "@@ -0,0 +1,200 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.\u2002\u2002See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.\u2002\u2002The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ *  with the License.\u2002\u2002You may obtain a copy of the License at\n+ *\n+ * \u2002\u2002\u2002\u2002 http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.fs.ozone;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.fs.CommonConfigurationKeysPublic;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.utils.db.Table;\n+import org.apache.hadoop.hdds.utils.db.TableIterator;\n+import org.apache.hadoop.ozone.MiniOzoneCluster;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.TestDataUtil;\n+import org.apache.hadoop.ozone.client.OzoneBucket;\n+import org.apache.hadoop.ozone.om.OMConfigKeys;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.util.StringUtils;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.Timeout;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.concurrent.TimeoutException;\n+\n+import static org.apache.hadoop.fs.CommonConfigurationKeysPublic.FS_TRASH_INTERVAL_KEY;\n+import static org.apache.hadoop.ozone.OzoneConfigKeys.OZONE_FS_ITERATE_BATCH_SIZE;\n+import static org.junit.Assert.fail;\n+\n+/**\n+ * Test verifies the entries and operations in directory table.\n+ */\n+public class TestOzoneDirectory {\n+\n+  @Rule\n+  public Timeout timeout = new Timeout(300000);\n+", "originalCommit": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk4MzU3MQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488983571", "bodyText": "And also cover tests like FILE_EXISTS_IN_GIVEN_PATH, DIRECTORY_EXISTS, FILE_EXISTS and DIRECTORY_EXISTS_IN_GIVEN_PATH.", "author": "bharatviswa504", "createdAt": "2020-09-15T21:28:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxNTIxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDkzOA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r491970938", "bodyText": "Good point, will add more UTs.", "author": "rakeshadr", "createdAt": "2020-09-21T11:32:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxNTIxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxNzc5OQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488917799", "bodyText": "Minor: omPrefixInfo -> omDirectoryInfo", "author": "bharatviswa504", "createdAt": "2020-09-15T19:29:54Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -129,6 +133,123 @@ public static OMPathInfo verifyFilesInPath(\n     return new OMPathInfo(missing, OMDirectoryResult.NONE, inheritAcls);\n   }\n \n+  /**\n+   * Verify any dir/key exist in the given path in the specified\n+   * volume/bucket by iterating through directory table.\n+   *\n+   * @param omMetadataManager OM Metadata manager\n+   * @param volumeName        volume name\n+   * @param bucketName        bucket name\n+   * @param keyName           key name\n+   * @param keyPath           path\n+   * @return OMPathInfoV1 path info object\n+   * @throws IOException on DB failure\n+   */\n+  public static OMPathInfoV1 verifyDirectoryKeysInPath(\n+          @Nonnull OMMetadataManager omMetadataManager,\n+          @Nonnull String volumeName,\n+          @Nonnull String bucketName, @Nonnull String keyName,\n+          @Nonnull Path keyPath) throws IOException {\n+\n+    String leafNodeName = OzoneFSUtils.getFileName(keyName);\n+    List<String> missing = new ArrayList<>();\n+    List<OzoneAcl> inheritAcls = new ArrayList<>();\n+    OMDirectoryResult result = OMDirectoryResult.NONE;\n+\n+    Iterator<Path> elements = keyPath.iterator();\n+    // TODO: volume id and bucket id generation logic.\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    long bucketId =\n+            omMetadataManager.getBucketTable().get(bucketKey).getObjectID();\n+    long lastKnownParentId = bucketId;\n+    OmDirectoryInfo parentPrefixInfo = null;\n+    String dbDirName = \"\"; // absolute path for trace logs\n+    while (elements.hasNext()) {\n+      String fileName = elements.next().toString();\n+      if (missing.size() > 0) {\n+        // Add all the sub-dirs to the missing list except the leaf element.\n+        // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt.\n+        // Assume /vol1/buck1/a/b/c exists, then add d, e, f into missing list.\n+        if(elements.hasNext()){\n+          // skips leaf node.\n+          missing.add(fileName);\n+        }\n+        continue;\n+      }\n+\n+      // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt\n+      // 1. Do lookup on directoryTable. If not exists goto next step.\n+      // 2. Do look on keyTable. If not exists goto next step.\n+      // 3. Add 'sub-dir' to missing parents list\n+      String dbNodeName = omMetadataManager.getOzoneLeafNodeKey(\n+              lastKnownParentId, fileName);\n+      OmDirectoryInfo omPrefixInfo = omMetadataManager.getDirectoryTable().", "originalCommit": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDMxNA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r491970314", "bodyText": "Sure, will take care", "author": "rakeshadr", "createdAt": "2020-09-21T11:31:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkxNzc5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyMzMzNw==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488923337", "bodyText": "Minor: parentPrefixInfo -> parentDirectoryInfo", "author": "bharatviswa504", "createdAt": "2020-09-15T19:36:13Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -129,6 +133,123 @@ public static OMPathInfo verifyFilesInPath(\n     return new OMPathInfo(missing, OMDirectoryResult.NONE, inheritAcls);\n   }\n \n+  /**\n+   * Verify any dir/key exist in the given path in the specified\n+   * volume/bucket by iterating through directory table.\n+   *\n+   * @param omMetadataManager OM Metadata manager\n+   * @param volumeName        volume name\n+   * @param bucketName        bucket name\n+   * @param keyName           key name\n+   * @param keyPath           path\n+   * @return OMPathInfoV1 path info object\n+   * @throws IOException on DB failure\n+   */\n+  public static OMPathInfoV1 verifyDirectoryKeysInPath(\n+          @Nonnull OMMetadataManager omMetadataManager,\n+          @Nonnull String volumeName,\n+          @Nonnull String bucketName, @Nonnull String keyName,\n+          @Nonnull Path keyPath) throws IOException {\n+\n+    String leafNodeName = OzoneFSUtils.getFileName(keyName);\n+    List<String> missing = new ArrayList<>();\n+    List<OzoneAcl> inheritAcls = new ArrayList<>();\n+    OMDirectoryResult result = OMDirectoryResult.NONE;\n+\n+    Iterator<Path> elements = keyPath.iterator();\n+    // TODO: volume id and bucket id generation logic.\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    long bucketId =\n+            omMetadataManager.getBucketTable().get(bucketKey).getObjectID();\n+    long lastKnownParentId = bucketId;\n+    OmDirectoryInfo parentPrefixInfo = null;", "originalCommit": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDI1NA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r491970254", "bodyText": "Sure, will take care", "author": "rakeshadr", "createdAt": "2020-09-21T11:31:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyMzMzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk0MDE3NQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488940175", "bodyText": "With current logic Key and directory in bucket root will pass, as we have not checked bucket/key in keyTable in first iteration.\nExample scenario:\nFSDataOutputStream ozoneOutputStream = fs.create(new Path(\"/a1\"));\n    ozoneOutputStream.close();\n\n    fs.mkdirs(new Path(\"/a1\"));", "author": "bharatviswa504", "createdAt": "2020-09-15T20:02:40Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -129,6 +133,123 @@ public static OMPathInfo verifyFilesInPath(\n     return new OMPathInfo(missing, OMDirectoryResult.NONE, inheritAcls);\n   }\n \n+  /**\n+   * Verify any dir/key exist in the given path in the specified\n+   * volume/bucket by iterating through directory table.\n+   *\n+   * @param omMetadataManager OM Metadata manager\n+   * @param volumeName        volume name\n+   * @param bucketName        bucket name\n+   * @param keyName           key name\n+   * @param keyPath           path\n+   * @return OMPathInfoV1 path info object\n+   * @throws IOException on DB failure\n+   */\n+  public static OMPathInfoV1 verifyDirectoryKeysInPath(\n+          @Nonnull OMMetadataManager omMetadataManager,\n+          @Nonnull String volumeName,\n+          @Nonnull String bucketName, @Nonnull String keyName,\n+          @Nonnull Path keyPath) throws IOException {\n+\n+    String leafNodeName = OzoneFSUtils.getFileName(keyName);\n+    List<String> missing = new ArrayList<>();\n+    List<OzoneAcl> inheritAcls = new ArrayList<>();\n+    OMDirectoryResult result = OMDirectoryResult.NONE;\n+\n+    Iterator<Path> elements = keyPath.iterator();\n+    // TODO: volume id and bucket id generation logic.\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    long bucketId =\n+            omMetadataManager.getBucketTable().get(bucketKey).getObjectID();\n+    long lastKnownParentId = bucketId;\n+    OmDirectoryInfo parentPrefixInfo = null;\n+    String dbDirName = \"\"; // absolute path for trace logs\n+    while (elements.hasNext()) {\n+      String fileName = elements.next().toString();\n+      if (missing.size() > 0) {\n+        // Add all the sub-dirs to the missing list except the leaf element.\n+        // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt.\n+        // Assume /vol1/buck1/a/b/c exists, then add d, e, f into missing list.\n+        if(elements.hasNext()){\n+          // skips leaf node.\n+          missing.add(fileName);\n+        }\n+        continue;\n+      }\n+\n+      // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt\n+      // 1. Do lookup on directoryTable. If not exists goto next step.\n+      // 2. Do look on keyTable. If not exists goto next step.\n+      // 3. Add 'sub-dir' to missing parents list\n+      String dbNodeName = omMetadataManager.getOzoneLeafNodeKey(\n+              lastKnownParentId, fileName);\n+      OmDirectoryInfo omPrefixInfo = omMetadataManager.getDirectoryTable().\n+              get(dbNodeName);\n+      if (omPrefixInfo != null) {\n+        dbDirName += omPrefixInfo.getName() + OzoneConsts.OZONE_URI_DELIMITER;\n+        if (elements.hasNext()) {\n+          lastKnownParentId = omPrefixInfo.getObjectID();\n+          parentPrefixInfo = omPrefixInfo;\n+          continue;\n+        } else {\n+          // Checked all the sub-dirs till the leaf node.\n+          // Found a directory in the given path.\n+          result = OMDirectoryResult.DIRECTORY_EXISTS;\n+        }\n+      } else {\n+        if (parentPrefixInfo != null) {", "originalCommit": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3MDA5Nw==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r491970097", "bodyText": "Good point, I will add logic to handle it.", "author": "rakeshadr", "createdAt": "2020-09-21T11:30:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk0MDE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk0OTM2Mg==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488949362", "bodyText": "result = OMDirectoryResult.DIRECTORY_EXISTS_IN_GIVENPATH;\n\nShould this line of code be here, as here we found a directory exists in given path? But with this approach, I see there is no real use of it.", "author": "bharatviswa504", "createdAt": "2020-09-15T20:20:36Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -129,6 +133,123 @@ public static OMPathInfo verifyFilesInPath(\n     return new OMPathInfo(missing, OMDirectoryResult.NONE, inheritAcls);\n   }\n \n+  /**\n+   * Verify any dir/key exist in the given path in the specified\n+   * volume/bucket by iterating through directory table.\n+   *\n+   * @param omMetadataManager OM Metadata manager\n+   * @param volumeName        volume name\n+   * @param bucketName        bucket name\n+   * @param keyName           key name\n+   * @param keyPath           path\n+   * @return OMPathInfoV1 path info object\n+   * @throws IOException on DB failure\n+   */\n+  public static OMPathInfoV1 verifyDirectoryKeysInPath(\n+          @Nonnull OMMetadataManager omMetadataManager,\n+          @Nonnull String volumeName,\n+          @Nonnull String bucketName, @Nonnull String keyName,\n+          @Nonnull Path keyPath) throws IOException {\n+\n+    String leafNodeName = OzoneFSUtils.getFileName(keyName);\n+    List<String> missing = new ArrayList<>();\n+    List<OzoneAcl> inheritAcls = new ArrayList<>();\n+    OMDirectoryResult result = OMDirectoryResult.NONE;\n+\n+    Iterator<Path> elements = keyPath.iterator();\n+    // TODO: volume id and bucket id generation logic.\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    long bucketId =\n+            omMetadataManager.getBucketTable().get(bucketKey).getObjectID();\n+    long lastKnownParentId = bucketId;\n+    OmDirectoryInfo parentPrefixInfo = null;\n+    String dbDirName = \"\"; // absolute path for trace logs\n+    while (elements.hasNext()) {\n+      String fileName = elements.next().toString();\n+      if (missing.size() > 0) {\n+        // Add all the sub-dirs to the missing list except the leaf element.\n+        // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt.\n+        // Assume /vol1/buck1/a/b/c exists, then add d, e, f into missing list.\n+        if(elements.hasNext()){\n+          // skips leaf node.\n+          missing.add(fileName);\n+        }\n+        continue;\n+      }\n+\n+      // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt\n+      // 1. Do lookup on directoryTable. If not exists goto next step.\n+      // 2. Do look on keyTable. If not exists goto next step.\n+      // 3. Add 'sub-dir' to missing parents list\n+      String dbNodeName = omMetadataManager.getOzoneLeafNodeKey(\n+              lastKnownParentId, fileName);\n+      OmDirectoryInfo omPrefixInfo = omMetadataManager.getDirectoryTable().\n+              get(dbNodeName);\n+      if (omPrefixInfo != null) {\n+        dbDirName += omPrefixInfo.getName() + OzoneConsts.OZONE_URI_DELIMITER;\n+        if (elements.hasNext()) {", "originalCommit": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk2OTc2Mg==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r491969762", "bodyText": "As 'OMDirectoryResult.DIRECTORY_EXISTS_IN_GIVENPATH' comment says, there are some part of the parent component exists.\nAssume user given path is \"vol1/buck1/a/b/c\" in volume volume\nIf there is a directory with name \"a/b\" it returns this enum value.\nPls refer: https://github.com/apache/hadoop-ozone/blob/master/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java#L202", "author": "rakeshadr", "createdAt": "2020-09-21T11:30:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk0OTM2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI0MzkxMw==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496243913", "bodyText": "DIRECTORY_EXISTS_IN_GIVENPATH is used when we check from leaf to parent, but now this logic is opposite.\nI am fine with leaving, but not really required in this case.", "author": "bharatviswa504", "createdAt": "2020-09-28T21:30:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk0OTM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3Mjg1Mw==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488972853", "bodyText": "Modified logic below, looks like few cases are missed.\nHave a look into it, and reuse it as needed.\n  public static OMPathInfoV1 verifyDirectoryKeysInPath(\n          @Nonnull OMMetadataManager omMetadataManager,\n          @Nonnull String volumeName,\n          @Nonnull String bucketName, @Nonnull String keyName,\n          @Nonnull Path keyPath) throws IOException {\n\n    String leafNodeName = OzoneFSUtils.getFileName(keyName);\n    List<String> missing = new ArrayList<>();\n    List<OzoneAcl> inheritAcls = new ArrayList<>();\n    OMDirectoryResult result = OMDirectoryResult.NONE;\n\n    Iterator<Path> elements = keyPath.iterator();\n    // TODO: volume id and bucket id generation logic.\n    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n    long lastKnownParentId = omMetadataManager.getBucketTable().get(bucketKey)\n        .getObjectID();\n    String dbDirName = \"\"; // absolute path for trace logs\n    while (elements.hasNext()) {\n      String fileName = elements.next().toString();\n      if (missing.size() > 0) {\n        // Add all the sub-dirs to the missing list except the leaf element.\n        // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt.\n        // Assume /vol1/buck1/a/b/c exists, then add d, e, f into missing list.\n        if(elements.hasNext()){\n          // skips leaf node.\n          missing.add(fileName);\n        }\n        continue;\n      }\n\n      // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt\n      // 1. Do lookup on directoryTable. If not exists goto next step.\n      // 2. Do look on keyTable. If not exists goto next step.\n      // 3. Add 'sub-dir' to missing parents list\n      String dbNodeName = omMetadataManager.getOzoneLeafNodeKey(\n              lastKnownParentId, fileName);\n      OmDirectoryInfo omPrefixInfo = omMetadataManager.getDirectoryTable().\n              get(dbNodeName);\n      if (omPrefixInfo != null) {\n        dbDirName += omPrefixInfo.getName() + OzoneConsts.OZONE_URI_DELIMITER;\n        if (elements.hasNext()) {\n          result = OMDirectoryResult.DIRECTORY_EXISTS_IN_GIVENPATH;\n          lastKnownParentId = omPrefixInfo.getObjectID();\n          inheritAcls = omPrefixInfo.getAcls();\n          continue;\n        } else {\n          // Checked all the sub-dirs till the leaf node.\n          // Found a directory in the given path.\n          result = OMDirectoryResult.DIRECTORY_EXISTS;\n          break;\n        }\n      } else {\n        if (omMetadataManager.getKeyTable().isExist(dbNodeName)) {\n          if (elements.hasNext()) {\n            // Found a file in the given key name.\n            result = OMDirectoryResult.FILE_EXISTS_IN_GIVENPATH;\n          } else {\n            // Checked all the sub-dirs till the leaf file.\n            // Found a file with the given key name.\n            result = OMDirectoryResult.FILE_EXISTS;\n          }\n          break; // Skip directory traversal as it hits key.\n        }\n      }\n\n      // Add to missing list, there is no such key/directory with given name\n      if (elements.hasNext()) {\n        missing.add(fileName);\n      }\n    }\n\n    if (result == OMDirectoryResult.DIRECTORY_EXISTS_IN_GIVENPATH) {\n      String dbDirKeyName = omMetadataManager.getOzoneDirKey(volumeName,\n          bucketName, dbDirName);\n      LOG.trace(\"Acls inherited from parent \" + dbDirKeyName + \" are : \"\n          + inheritAcls);\n    }\n\n    if (result != OMDirectoryResult.NONE) {\n      LOG.trace(\"verifyFiles in Path : \" + \"/\" + volumeName\n              + \"/\" + bucketName + \"/\" + keyName + \":\" + result);\n      return new OMPathInfoV1(leafNodeName, lastKnownParentId, missing, result,\n              inheritAcls, dbDirName);\n    }\n\n    if (inheritAcls.isEmpty()) {\n      inheritAcls = omMetadataManager.getBucketTable().get(bucketKey)\n              .getAcls();\n      LOG.trace(\"Acls inherited from bucket \" + bucketName + \" are : \"\n              + inheritAcls);\n    }\n\n    LOG.trace(\"verifyFiles in Path : \" + volumeName + \"/\" + bucketName + \"/\"\n            + keyName + \":\" + result);\n\n    // Found no files/ directories in the given path.\n    return new OMPathInfoV1(leafNodeName, lastKnownParentId, missing,\n            OMDirectoryResult.NONE, inheritAcls, null);\n  }", "author": "bharatviswa504", "createdAt": "2020-09-15T21:05:49Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -129,6 +133,123 @@ public static OMPathInfo verifyFilesInPath(\n     return new OMPathInfo(missing, OMDirectoryResult.NONE, inheritAcls);\n   }\n \n+  /**\n+   * Verify any dir/key exist in the given path in the specified\n+   * volume/bucket by iterating through directory table.\n+   *\n+   * @param omMetadataManager OM Metadata manager\n+   * @param volumeName        volume name\n+   * @param bucketName        bucket name\n+   * @param keyName           key name\n+   * @param keyPath           path\n+   * @return OMPathInfoV1 path info object\n+   * @throws IOException on DB failure\n+   */\n+  public static OMPathInfoV1 verifyDirectoryKeysInPath(", "originalCommit": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIwNTU4MQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r492205581", "bodyText": "Thanks for the help. Will incorporate it.", "author": "rakeshadr", "createdAt": "2020-09-21T16:49:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3Mjg1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3NDY3NQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488974675", "bodyText": "Here this should be in new format right?\nlike parentObjectID/name, as we use the format of parentObjectID/name when writing to DB in Response class.", "author": "bharatviswa504", "createdAt": "2020-09-15T21:09:34Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -254,4 +440,34 @@ public static void addKeyTableCacheEntries(\n           new CacheValue<>(keyInfo, index));\n     }\n   }\n+\n+  /**\n+   * Adding directory info to the Table cache.\n+   *\n+   * @param omMetadataManager  OM Metdata Manager\n+   * @param dirInfo            directory info\n+   * @param missingParentInfos list of the parents to be added to DB\n+   * @param trxnLogIndex       transaction log index\n+   */\n+  public static void addDirectoryTableCacheEntries(\n+          OMMetadataManager omMetadataManager,\n+          Optional<OmDirectoryInfo> dirInfo,\n+          Optional<List<OmDirectoryInfo>> missingParentInfos,\n+          long trxnLogIndex) {\n+    for (OmDirectoryInfo parentInfo : missingParentInfos.get()) {\n+      omMetadataManager.getDirectoryTable().addCacheEntry(\n+              new CacheKey<>(omMetadataManager.getOzoneLeafNodeKey(", "originalCommit": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE4NTM5OA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r492185398", "bodyText": "Yes, it is in the new format:   \"parentInfo.getParentObjectID(), parentInfo.getName()\".\nI hope the variable name is confusing.\nI think, rename variable 'parentInfo' to 'subDirInfo' , will make it more clear \"subDirInfo.getParentObjectID(), subDirInfo.getName()\".\nDoes it make sense to you?", "author": "rakeshadr", "createdAt": "2020-09-21T16:17:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3NDY3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3NTQ1Mw==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488975453", "bodyText": "Not understand what this TODO means here.\nCan you explain what is missing here?", "author": "bharatviswa504", "createdAt": "2020-09-15T21:11:11Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMDirectoryCreateRequestV1.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.file;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.*;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.file.OMDirectoryCreateResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .Status;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.FILE_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.INVALID_KEY_NAME;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+import static org.apache.hadoop.ozone.om.request.file.OMFileRequest.OMDirectoryResult.*;\n+\n+/**\n+ * Handle create directory request. It will add path components to the directory\n+ * table and maintains file system semantics.\n+ */\n+public class OMDirectoryCreateRequestV1 extends OMDirectoryCreateRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMDirectoryCreateRequestV1.class);\n+\n+  public OMDirectoryCreateRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    CreateDirectoryRequest createDirectoryRequest = getOmRequest()\n+        .getCreateDirectoryRequest();\n+    KeyArgs keyArgs = createDirectoryRequest.getKeyArgs();\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+    omResponse.setCreateDirectoryResponse(CreateDirectoryResponse.newBuilder());\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumCreateDirectory();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+    OzoneManagerProtocolProtos.UserInfo userInfo = getOmRequest().getUserInfo();\n+\n+    Map<String, String> auditMap = buildKeyArgsAuditMap(keyArgs);\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = Result.FAILURE;\n+    List<OmDirectoryInfo> missingParentInfos;\n+\n+    try {\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acl\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+          IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      // Check if this is the root of the filesystem.\n+      if (keyName.length() == 0) {\n+        throw new OMException(\"Directory create failed. Cannot create \" +\n+            \"directory at root of the filesystem\",\n+            OMException.ResultCodes.CANNOT_CREATE_DIRECTORY_AT_ROOT);\n+      }\n+      // acquire lock\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+          volumeName, bucketName);\n+\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      Path keyPath = Paths.get(keyName);\n+\n+      // Need to check if any files exist in the given path, if they exist we\n+      // cannot create a directory with the given key.\n+      // Verify the path against directory table\n+      OMFileRequest.OMPathInfoV1 omPathInfo =\n+          OMFileRequest.verifyDirectoryKeysInPath(omMetadataManager, volumeName,\n+              bucketName, keyName, keyPath);\n+      OMFileRequest.OMDirectoryResult omDirectoryResult =\n+          omPathInfo.getDirectoryResult();\n+\n+      if (omDirectoryResult == FILE_EXISTS ||\n+          omDirectoryResult == FILE_EXISTS_IN_GIVENPATH) {\n+        throw new OMException(\"Unable to create directory: \" +keyName\n+            + \" in volume/bucket: \" + volumeName + \"/\" + bucketName,\n+            FILE_ALREADY_EXISTS);\n+      } else if (omDirectoryResult == DIRECTORY_EXISTS_IN_GIVENPATH ||\n+          omDirectoryResult == NONE) {\n+\n+        // prepare all missing parents\n+        missingParentInfos = OMDirectoryCreateRequestV1.getAllParentDirInfo(\n+                ozoneManager, keyArgs, omPathInfo, trxnLogIndex);\n+        // prepare leafNode dir\n+        OmDirectoryInfo dirInfo = createDirectoryInfoWithACL(\n+                omPathInfo.getLeafNodeName(),\n+                keyArgs, omPathInfo.getLeafNodeObjectId(),\n+                omPathInfo.getLastKnownParentId(), trxnLogIndex,\n+                OzoneAclUtil.fromProtobuf(keyArgs.getAclsList()));\n+        OMFileRequest.addDirectoryTableCacheEntries(omMetadataManager,\n+                Optional.of(dirInfo), Optional.of(missingParentInfos),\n+                trxnLogIndex);\n+        result = OMDirectoryCreateRequest.Result.SUCCESS;\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+                dirInfo, missingParentInfos, result);\n+      } else {\n+        result = Result.DIRECTORY_ALREADY_EXISTS;\n+        omResponse.setStatus(Status.DIRECTORY_ALREADY_EXISTS);\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+            result);\n+      }\n+    } catch (IOException ex) {\n+      exception = ex;\n+      omClientResponse = new OMDirectoryCreateResponseV1(\n+          createErrorOMResponse(omResponse, exception), result);\n+    } finally {\n+      addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n+          omDoubleBufferHelper);\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+      }\n+    }\n+\n+    auditLog(auditLogger, buildAuditMessage(OMAction.CREATE_DIRECTORY,\n+        auditMap, exception, userInfo));\n+\n+    logResult(createDirectoryRequest, keyArgs, omMetrics, result, exception);\n+\n+    return omClientResponse;\n+  }\n+\n+  private void logResult(CreateDirectoryRequest createDirectoryRequest,\n+                         KeyArgs keyArgs, OMMetrics omMetrics, Result result,\n+                         IOException exception) {\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    switch (result) {\n+    case SUCCESS:\n+      omMetrics.incNumKeys();\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Directory created. Volume:{}, Bucket:{}, Key:{}\",\n+            volumeName, bucketName, keyName);\n+      }\n+      break;\n+    case DIRECTORY_ALREADY_EXISTS:\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Directory already exists. Volume:{}, Bucket:{}, Key{}\",\n+            volumeName, bucketName, keyName, exception);\n+      }\n+      break;\n+    case FAILURE:\n+      omMetrics.incNumCreateDirectoryFails();\n+      LOG.error(\"Directory creation failed. Volume:{}, Bucket:{}, Key{}. \" +\n+          \"Exception:{}\", volumeName, bucketName, keyName, exception);\n+      break;\n+    default:\n+      LOG.error(\"Unrecognized Result for OMDirectoryCreateRequest: {}\",\n+          createDirectoryRequest);\n+    }\n+  }\n+\n+  /**\n+   * Construct OmDirectoryInfo for every parent directory in missing list.\n+   * @param ozoneManager\n+   * @param keyArgs\n+   * @param pathInfo list of parent directories to be created and its ACLs\n+   * @param trxnLogIndex\n+   * @return\n+   * @throws IOException\n+   */\n+  public static List<OmDirectoryInfo> getAllParentDirInfo(\n+          OzoneManager ozoneManager, KeyArgs keyArgs,\n+          OMFileRequest.OMPathInfoV1 pathInfo, long trxnLogIndex)\n+          throws IOException {\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    List<OmDirectoryInfo> missingParentInfos = new ArrayList<>();\n+\n+    ImmutablePair<Long, Long> objIdRange = OMFileRequest\n+            .getObjIdRangeFromTxId(trxnLogIndex);\n+    long baseObjId = objIdRange.getLeft();\n+    long maxObjId = objIdRange.getRight();\n+    long maxLevels = maxObjId - baseObjId;\n+    long objectCount = 1; // baseObjID is used by the leaf directory\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    long lastKnownParentId = pathInfo.getLastKnownParentId();\n+    List<String> missingParents = pathInfo.getMissingParents();\n+    List<OzoneAcl> inheritAcls = pathInfo.getAcls();\n+    for (String missingKey : missingParents) {\n+      long nextObjId = baseObjId + objectCount;\n+      if (nextObjId > maxObjId) {\n+        throw new OMException(\"Too many directories in path. Exceeds limit of \"\n+                + maxLevels + \". Unable to create directory: \" + keyName\n+                + \" in volume/bucket: \" + volumeName + \"/\" + bucketName,\n+                INVALID_KEY_NAME);\n+      }\n+\n+      LOG.debug(\"missing parent {} getting added to KeyTable\", missingKey);\n+      // what about keyArgs for parent directories? TODO", "originalCommit": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3NTI2MA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r491975260", "bodyText": "I just copy pasted from original file OMDirectoryCreateRequestV.java. I don't know more about this.\nPlease refer: https://github.com/apache/hadoop-ozone/blob/master/hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMDirectoryCreateRequest.java#L270", "author": "rakeshadr", "createdAt": "2020-09-21T11:41:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3NTQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI0NjQwMA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496246400", "bodyText": "We are creating entries for missing parent directories. I think we can remove this TODO.  But if you think there is something still missing, we can leave it.", "author": "bharatviswa504", "createdAt": "2020-09-28T21:36:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3NTQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgyMDUyNA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496820524", "bodyText": "Nothing specific. Will remove this comment.", "author": "rakeshadr", "createdAt": "2020-09-29T15:34:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3NTQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3NTk1Nw==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488975957", "bodyText": "Here should we increment Keys based on the number of directories being created?", "author": "bharatviswa504", "createdAt": "2020-09-15T21:12:12Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMDirectoryCreateRequestV1.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.file;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.*;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.file.OMDirectoryCreateResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .Status;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.FILE_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.INVALID_KEY_NAME;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+import static org.apache.hadoop.ozone.om.request.file.OMFileRequest.OMDirectoryResult.*;\n+\n+/**\n+ * Handle create directory request. It will add path components to the directory\n+ * table and maintains file system semantics.\n+ */\n+public class OMDirectoryCreateRequestV1 extends OMDirectoryCreateRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMDirectoryCreateRequestV1.class);\n+\n+  public OMDirectoryCreateRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    CreateDirectoryRequest createDirectoryRequest = getOmRequest()\n+        .getCreateDirectoryRequest();\n+    KeyArgs keyArgs = createDirectoryRequest.getKeyArgs();\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+    omResponse.setCreateDirectoryResponse(CreateDirectoryResponse.newBuilder());\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumCreateDirectory();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+    OzoneManagerProtocolProtos.UserInfo userInfo = getOmRequest().getUserInfo();\n+\n+    Map<String, String> auditMap = buildKeyArgsAuditMap(keyArgs);\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = Result.FAILURE;\n+    List<OmDirectoryInfo> missingParentInfos;\n+\n+    try {\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acl\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+          IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      // Check if this is the root of the filesystem.\n+      if (keyName.length() == 0) {\n+        throw new OMException(\"Directory create failed. Cannot create \" +\n+            \"directory at root of the filesystem\",\n+            OMException.ResultCodes.CANNOT_CREATE_DIRECTORY_AT_ROOT);\n+      }\n+      // acquire lock\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+          volumeName, bucketName);\n+\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      Path keyPath = Paths.get(keyName);\n+\n+      // Need to check if any files exist in the given path, if they exist we\n+      // cannot create a directory with the given key.\n+      // Verify the path against directory table\n+      OMFileRequest.OMPathInfoV1 omPathInfo =\n+          OMFileRequest.verifyDirectoryKeysInPath(omMetadataManager, volumeName,\n+              bucketName, keyName, keyPath);\n+      OMFileRequest.OMDirectoryResult omDirectoryResult =\n+          omPathInfo.getDirectoryResult();\n+\n+      if (omDirectoryResult == FILE_EXISTS ||\n+          omDirectoryResult == FILE_EXISTS_IN_GIVENPATH) {\n+        throw new OMException(\"Unable to create directory: \" +keyName\n+            + \" in volume/bucket: \" + volumeName + \"/\" + bucketName,\n+            FILE_ALREADY_EXISTS);\n+      } else if (omDirectoryResult == DIRECTORY_EXISTS_IN_GIVENPATH ||\n+          omDirectoryResult == NONE) {\n+\n+        // prepare all missing parents\n+        missingParentInfos = OMDirectoryCreateRequestV1.getAllParentDirInfo(\n+                ozoneManager, keyArgs, omPathInfo, trxnLogIndex);\n+        // prepare leafNode dir\n+        OmDirectoryInfo dirInfo = createDirectoryInfoWithACL(\n+                omPathInfo.getLeafNodeName(),\n+                keyArgs, omPathInfo.getLeafNodeObjectId(),\n+                omPathInfo.getLastKnownParentId(), trxnLogIndex,\n+                OzoneAclUtil.fromProtobuf(keyArgs.getAclsList()));\n+        OMFileRequest.addDirectoryTableCacheEntries(omMetadataManager,\n+                Optional.of(dirInfo), Optional.of(missingParentInfos),\n+                trxnLogIndex);\n+        result = OMDirectoryCreateRequest.Result.SUCCESS;\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+                dirInfo, missingParentInfos, result);\n+      } else {\n+        result = Result.DIRECTORY_ALREADY_EXISTS;\n+        omResponse.setStatus(Status.DIRECTORY_ALREADY_EXISTS);\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+            result);\n+      }\n+    } catch (IOException ex) {\n+      exception = ex;\n+      omClientResponse = new OMDirectoryCreateResponseV1(\n+          createErrorOMResponse(omResponse, exception), result);\n+    } finally {\n+      addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n+          omDoubleBufferHelper);\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+      }\n+    }\n+\n+    auditLog(auditLogger, buildAuditMessage(OMAction.CREATE_DIRECTORY,\n+        auditMap, exception, userInfo));\n+\n+    logResult(createDirectoryRequest, keyArgs, omMetrics, result, exception);\n+\n+    return omClientResponse;\n+  }\n+\n+  private void logResult(CreateDirectoryRequest createDirectoryRequest,\n+                         KeyArgs keyArgs, OMMetrics omMetrics, Result result,\n+                         IOException exception) {\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    switch (result) {\n+    case SUCCESS:\n+      omMetrics.incNumKeys();", "originalCommit": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk3NjgzOQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r491976839", "bodyText": "Good catch. Yes, will incr it", "author": "rakeshadr", "createdAt": "2020-09-21T11:45:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk3NTk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk4NDc1OQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r488984759", "bodyText": "Here we can add exisitingKeyPath also it will help in debugging failure scenario for like mkdir fails with FILE_EXISTS or FILE_EXISTS_IN_GIVEN_PATH or other error", "author": "bharatviswa504", "createdAt": "2020-09-15T21:31:20Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -156,6 +277,71 @@ public static long getObjIDFromTxId(long id) {\n     return new ImmutablePair<>(baseId, maxAvailableId);\n   }\n \n+\n+  /**\n+   * Class to return the results from verifyDirectoryKeysInPath.\n+   * Includes the list of missing intermediate directories and\n+   * the directory search result code.\n+   */\n+  public static class OMPathInfoV1 {\n+    private OMDirectoryResult directoryResult;\n+    private String leafNodeName;\n+    private long lastKnownParentId;\n+    private long leafNodeObjectId;\n+    private List<String> missingParents;\n+    private List<OzoneAcl> acls;\n+\n+    public OMPathInfoV1(String leafNodeName, long lastKnownParentId,\n+                        List missingParents, OMDirectoryResult result,\n+                        List<OzoneAcl> aclList) {\n+      this.leafNodeName = leafNodeName;\n+      this.lastKnownParentId = lastKnownParentId;\n+      this.missingParents = missingParents;\n+      this.directoryResult = result;\n+      this.acls = aclList;", "originalCommit": "2150aa042038c7aaa0dd78e50ffe6fb822b177ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIxMzgxMQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r492213811", "bodyText": "'keyName' is already available as local variable and am making use of that. How about add it to 'OMPathInfoV1' later based on requirement ?", "author": "rakeshadr", "createdAt": "2020-09-21T17:03:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk4NDc1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjIxNTgzNA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r492215834", "bodyText": "No my point here is lets say when user tries to create file '/a/b/c/file1\" it failed with NOT_A_FILE, but I don't know from log error due to which part of the file exist. (As during some S3 debug, I thought this will be useful)\nlet me know your thoughts.", "author": "bharatviswa504", "createdAt": "2020-09-21T17:07:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk4NDc1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjI0MjI5NA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r492242294", "bodyText": "Thanks for the explanation. Yes, will add it.", "author": "rakeshadr", "createdAt": "2020-09-21T17:51:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODk4NDc1OQ=="}], "type": "inlineReview"}, {"oid": "1fd60f6688f3f9df14749fb6ea4af4332c00d907", "url": "https://github.com/apache/ozone/commit/1fd60f6688f3f9df14749fb6ea4af4332c00d907", "message": "HDDS-2949: mkdir : store directory entries in a separate table", "committedDate": "2020-09-25T19:43:56Z", "type": "commit"}, {"oid": "0f2560eeb2c26aaef2e9c619ba2f93b08177a754", "url": "https://github.com/apache/ozone/commit/0f2560eeb2c26aaef2e9c619ba2f93b08177a754", "message": "Fixed checkstyle warnings and changed layout version defaulting to V0 to run existing UTs happily", "committedDate": "2020-09-25T19:43:56Z", "type": "commit"}, {"oid": "6023e771bdb88af811c907509e558dbcfcbb602a", "url": "https://github.com/apache/ozone/commit/6023e771bdb88af811c907509e558dbcfcbb602a", "message": "Fixed checkstyle, findbug warnings, review comments", "committedDate": "2020-09-25T19:43:56Z", "type": "commit"}, {"oid": "e8dc0607f00efa9c1fd53c26f117ef2c4d558202", "url": "https://github.com/apache/ozone/commit/e8dc0607f00efa9c1fd53c26f117ef2c4d558202", "message": "Fixed review comments", "committedDate": "2020-09-25T19:43:56Z", "type": "commit"}, {"oid": "786b2972981a2ff624136a0a2cc75f21d431951f", "url": "https://github.com/apache/ozone/commit/786b2972981a2ff624136a0a2cc75f21d431951f", "message": "Fixed checkstyle warnings", "committedDate": "2020-09-25T19:43:56Z", "type": "commit"}, {"oid": "892214ba54ff5de62355470818ab47de8b94d2ec", "url": "https://github.com/apache/ozone/commit/892214ba54ff5de62355470818ab47de8b94d2ec", "message": "Fixed typos and renamed method name", "committedDate": "2020-09-25T19:43:56Z", "type": "commit"}, {"oid": "892214ba54ff5de62355470818ab47de8b94d2ec", "url": "https://github.com/apache/ozone/commit/892214ba54ff5de62355470818ab47de8b94d2ec", "message": "Fixed typos and renamed method name", "committedDate": "2020-09-25T19:43:56Z", "type": "forcePushed"}, {"oid": "c94d909974f2df086bbceb0e5b6b0f87dc977c53", "url": "https://github.com/apache/ozone/commit/c94d909974f2df086bbceb0e5b6b0f87dc977c53", "message": "Fixed rebase compilation failures and renamed variable name", "committedDate": "2020-09-25T19:55:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0MzQwMA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496143400", "bodyText": "We dont need this check.\nAs default inheritAcls is bucketAcls only.\nLet's say, we create /a/b/c, now for all of them we have acls with bucketAcls.\nSo, next time when we create /a/b/c/d, then it will have Acls.", "author": "bharatviswa504", "createdAt": "2020-09-28T18:15:01Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -129,6 +134,131 @@ public static OMPathInfo verifyFilesInPath(\n     return new OMPathInfo(missing, OMDirectoryResult.NONE, inheritAcls);\n   }\n \n+  /**\n+   * Verify any dir/key exist in the given path in the specified\n+   * volume/bucket by iterating through directory table.\n+   *\n+   * @param omMetadataManager OM Metadata manager\n+   * @param volumeName        volume name\n+   * @param bucketName        bucket name\n+   * @param keyName           key name\n+   * @param keyPath           path\n+   * @return OMPathInfoV1 path info object\n+   * @throws IOException on DB failure\n+   */\n+  public static OMPathInfoV1 verifyDirectoryKeysInPath(\n+          @Nonnull OMMetadataManager omMetadataManager,\n+          @Nonnull String volumeName,\n+          @Nonnull String bucketName, @Nonnull String keyName,\n+          @Nonnull Path keyPath) throws IOException {\n+\n+    String leafNodeName = OzoneFSUtils.getFileName(keyName);\n+    List<String> missing = new ArrayList<>();\n+    List<OzoneAcl> inheritAcls = new ArrayList<>();\n+    OMDirectoryResult result = OMDirectoryResult.NONE;\n+\n+    Iterator<Path> elements = keyPath.iterator();\n+    // TODO: volume id and bucket id generation logic.\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    inheritAcls = omBucketInfo.getAcls();\n+    long lastKnownParentId = omBucketInfo.getObjectID();\n+    OmDirectoryInfo parentDirInfo = null;\n+    String dbDirName = \"\"; // absolute path for trace logs\n+    // for better logging\n+    StringBuilder fullKeyPath = new StringBuilder(bucketKey);\n+    while (elements.hasNext()) {\n+      String fileName = elements.next().toString();\n+      fullKeyPath.append(OzoneConsts.OM_KEY_PREFIX);\n+      fullKeyPath.append(fileName);\n+      if (missing.size() > 0) {\n+        // Add all the sub-dirs to the missing list except the leaf element.\n+        // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt.\n+        // Assume /vol1/buck1/a/b/c exists, then add d, e, f into missing list.\n+        if(elements.hasNext()){\n+          // skips leaf node.\n+          missing.add(fileName);\n+        }\n+        continue;\n+      }\n+\n+      // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt\n+      // 1. Do lookup on directoryTable. If not exists goto next step.\n+      // 2. Do look on keyTable. If not exists goto next step.\n+      // 3. Add 'sub-dir' to missing parents list\n+      String dbNodeName = omMetadataManager.getOzonePathKey(\n+              lastKnownParentId, fileName);\n+      OmDirectoryInfo omDirInfo = omMetadataManager.getDirectoryTable().\n+              get(dbNodeName);\n+      if (omDirInfo != null) {\n+        dbDirName += omDirInfo.getName() + OzoneConsts.OZONE_URI_DELIMITER;\n+        if (elements.hasNext()) {\n+          result = OMDirectoryResult.DIRECTORY_EXISTS_IN_GIVENPATH;\n+          lastKnownParentId = omDirInfo.getObjectID();\n+          inheritAcls = omDirInfo.getAcls();\n+          continue;\n+        } else {\n+          // Checked all the sub-dirs till the leaf node.\n+          // Found a directory in the given path.\n+          result = OMDirectoryResult.DIRECTORY_EXISTS;\n+        }\n+      } else {\n+        // Get parentID from the lastKnownParent. For any files, directly under\n+        // the bucket, the parent is the bucketID. Say, \"/vol1/buck1/file1\"\n+        // TODO: Need to add UT for this case along with OMFileCreateRequest.\n+        if (omMetadataManager.getKeyTable().isExist(dbNodeName)) {\n+          if (elements.hasNext()) {\n+            // Found a file in the given key name.\n+            result = OMDirectoryResult.FILE_EXISTS_IN_GIVENPATH;\n+          } else {\n+            // Checked all the sub-dirs till the leaf file.\n+            // Found a file with the given key name.\n+            result = OMDirectoryResult.FILE_EXISTS;\n+          }\n+          break; // Skip directory traversal as it hits key.\n+        }\n+\n+        // Add to missing list, there is no such file/directory with given name.\n+        if (elements.hasNext()) {\n+          missing.add(fileName);\n+        }\n+\n+        String dbDirKeyName = omMetadataManager.getOzoneDirKey(volumeName,\n+                bucketName, dbDirName);\n+        LOG.trace(\"Acls inherited from parent \" + dbDirKeyName + \" are : \"\n+                + inheritAcls);\n+      }\n+    }\n+\n+    if (result == OMDirectoryResult.DIRECTORY_EXISTS_IN_GIVENPATH) {\n+      String dbDirKeyName = omMetadataManager.getOzoneDirKey(volumeName,\n+              bucketName, dbDirName);\n+      LOG.trace(\"Acls inherited from parent \" + dbDirKeyName + \" are : \"\n+              + inheritAcls);\n+    }\n+\n+    if (result != OMDirectoryResult.NONE) {\n+      LOG.trace(\"verifyFiles in Path : \" + \"/\" + volumeName\n+              + \"/\" + bucketName + \"/\" + keyName + \":\" + result);\n+      return new OMPathInfoV1(leafNodeName, lastKnownParentId, missing, result,\n+              inheritAcls, fullKeyPath.toString());\n+    }\n+\n+    if (inheritAcls.isEmpty()) {", "originalCommit": "c94d909974f2df086bbceb0e5b6b0f87dc977c53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxOTU2Ng==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496819566", "bodyText": "Sure, will remove it.", "author": "rakeshadr", "createdAt": "2020-09-29T15:33:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0MzQwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NTczMA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496145730", "bodyText": "Now we don't really need this, as now logic checks from parent to leaf, as previous logic checks from leaf to parent DIRECTORY_EXISTS_IN_GIVENPATH makes sense, so we don't really need this special handling.", "author": "bharatviswa504", "createdAt": "2020-09-28T18:19:33Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -129,6 +134,131 @@ public static OMPathInfo verifyFilesInPath(\n     return new OMPathInfo(missing, OMDirectoryResult.NONE, inheritAcls);\n   }\n \n+  /**\n+   * Verify any dir/key exist in the given path in the specified\n+   * volume/bucket by iterating through directory table.\n+   *\n+   * @param omMetadataManager OM Metadata manager\n+   * @param volumeName        volume name\n+   * @param bucketName        bucket name\n+   * @param keyName           key name\n+   * @param keyPath           path\n+   * @return OMPathInfoV1 path info object\n+   * @throws IOException on DB failure\n+   */\n+  public static OMPathInfoV1 verifyDirectoryKeysInPath(\n+          @Nonnull OMMetadataManager omMetadataManager,\n+          @Nonnull String volumeName,\n+          @Nonnull String bucketName, @Nonnull String keyName,\n+          @Nonnull Path keyPath) throws IOException {\n+\n+    String leafNodeName = OzoneFSUtils.getFileName(keyName);\n+    List<String> missing = new ArrayList<>();\n+    List<OzoneAcl> inheritAcls = new ArrayList<>();\n+    OMDirectoryResult result = OMDirectoryResult.NONE;\n+\n+    Iterator<Path> elements = keyPath.iterator();\n+    // TODO: volume id and bucket id generation logic.\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    inheritAcls = omBucketInfo.getAcls();\n+    long lastKnownParentId = omBucketInfo.getObjectID();\n+    OmDirectoryInfo parentDirInfo = null;\n+    String dbDirName = \"\"; // absolute path for trace logs\n+    // for better logging\n+    StringBuilder fullKeyPath = new StringBuilder(bucketKey);\n+    while (elements.hasNext()) {\n+      String fileName = elements.next().toString();\n+      fullKeyPath.append(OzoneConsts.OM_KEY_PREFIX);\n+      fullKeyPath.append(fileName);\n+      if (missing.size() > 0) {\n+        // Add all the sub-dirs to the missing list except the leaf element.\n+        // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt.\n+        // Assume /vol1/buck1/a/b/c exists, then add d, e, f into missing list.\n+        if(elements.hasNext()){\n+          // skips leaf node.\n+          missing.add(fileName);\n+        }\n+        continue;\n+      }\n+\n+      // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt\n+      // 1. Do lookup on directoryTable. If not exists goto next step.\n+      // 2. Do look on keyTable. If not exists goto next step.\n+      // 3. Add 'sub-dir' to missing parents list\n+      String dbNodeName = omMetadataManager.getOzonePathKey(\n+              lastKnownParentId, fileName);\n+      OmDirectoryInfo omDirInfo = omMetadataManager.getDirectoryTable().\n+              get(dbNodeName);\n+      if (omDirInfo != null) {\n+        dbDirName += omDirInfo.getName() + OzoneConsts.OZONE_URI_DELIMITER;\n+        if (elements.hasNext()) {\n+          result = OMDirectoryResult.DIRECTORY_EXISTS_IN_GIVENPATH;\n+          lastKnownParentId = omDirInfo.getObjectID();\n+          inheritAcls = omDirInfo.getAcls();\n+          continue;\n+        } else {\n+          // Checked all the sub-dirs till the leaf node.\n+          // Found a directory in the given path.\n+          result = OMDirectoryResult.DIRECTORY_EXISTS;\n+        }\n+      } else {\n+        // Get parentID from the lastKnownParent. For any files, directly under\n+        // the bucket, the parent is the bucketID. Say, \"/vol1/buck1/file1\"\n+        // TODO: Need to add UT for this case along with OMFileCreateRequest.\n+        if (omMetadataManager.getKeyTable().isExist(dbNodeName)) {\n+          if (elements.hasNext()) {\n+            // Found a file in the given key name.\n+            result = OMDirectoryResult.FILE_EXISTS_IN_GIVENPATH;\n+          } else {\n+            // Checked all the sub-dirs till the leaf file.\n+            // Found a file with the given key name.\n+            result = OMDirectoryResult.FILE_EXISTS;\n+          }\n+          break; // Skip directory traversal as it hits key.\n+        }\n+\n+        // Add to missing list, there is no such file/directory with given name.\n+        if (elements.hasNext()) {\n+          missing.add(fileName);\n+        }\n+\n+        String dbDirKeyName = omMetadataManager.getOzoneDirKey(volumeName,\n+                bucketName, dbDirName);\n+        LOG.trace(\"Acls inherited from parent \" + dbDirKeyName + \" are : \"\n+                + inheritAcls);\n+      }\n+    }\n+\n+    if (result == OMDirectoryResult.DIRECTORY_EXISTS_IN_GIVENPATH) {", "originalCommit": "c94d909974f2df086bbceb0e5b6b0f87dc977c53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NjMzMw==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496146333", "bodyText": "We need only full path in case of errors where we can return fullKeyPath.", "author": "bharatviswa504", "createdAt": "2020-09-28T18:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NTczMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxODY3OQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496818679", "bodyText": "As this is a utility function, I would like to return fullKeyPath this as well. Caller can take a decision to use it or not.\nI will remove DIRECTORY_EXISTS_IN_GIVENPATH check here. But I would like to return result with DIRECTORY_EXISTS_IN_GIVENPATH just to make it readable. Hope thats fine!", "author": "rakeshadr", "createdAt": "2020-09-29T15:32:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NTczMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgyMzYxNw==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496823617", "bodyText": "Ya special handling if removed that is fine.", "author": "bharatviswa504", "createdAt": "2020-09-29T15:36:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE0NTczMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE1MjcyNw==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496152727", "bodyText": "Cache KeyName also should be same as parentObjectID/dirname\nAs this is what we used to search for the entry in the directory table.", "author": "bharatviswa504", "createdAt": "2020-09-28T18:32:12Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMDirectoryCreateRequestV1.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.file;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.*;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.file.OMDirectoryCreateResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .Status;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.FILE_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.INVALID_KEY_NAME;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+import static org.apache.hadoop.ozone.om.request.file.OMFileRequest.OMDirectoryResult.*;\n+\n+/**\n+ * Handle create directory request. It will add path components to the directory\n+ * table and maintains file system semantics.\n+ */\n+public class OMDirectoryCreateRequestV1 extends OMDirectoryCreateRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMDirectoryCreateRequestV1.class);\n+\n+  public OMDirectoryCreateRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    CreateDirectoryRequest createDirectoryRequest = getOmRequest()\n+        .getCreateDirectoryRequest();\n+    KeyArgs keyArgs = createDirectoryRequest.getKeyArgs();\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+    int numKeysCreated = 0;\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+    omResponse.setCreateDirectoryResponse(CreateDirectoryResponse.newBuilder());\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumCreateDirectory();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+    OzoneManagerProtocolProtos.UserInfo userInfo = getOmRequest().getUserInfo();\n+\n+    Map<String, String> auditMap = buildKeyArgsAuditMap(keyArgs);\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = Result.FAILURE;\n+    List<OmDirectoryInfo> missingParentInfos;\n+\n+    try {\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acl\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+          IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      // Check if this is the root of the filesystem.\n+      if (keyName.length() == 0) {\n+        throw new OMException(\"Directory create failed. Cannot create \" +\n+            \"directory at root of the filesystem\",\n+            OMException.ResultCodes.CANNOT_CREATE_DIRECTORY_AT_ROOT);\n+      }\n+      // acquire lock\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+          volumeName, bucketName);\n+\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      Path keyPath = Paths.get(keyName);\n+\n+      // Need to check if any files exist in the given path, if they exist we\n+      // cannot create a directory with the given key.\n+      // Verify the path against directory table\n+      OMFileRequest.OMPathInfoV1 omPathInfo =\n+          OMFileRequest.verifyDirectoryKeysInPath(omMetadataManager, volumeName,\n+              bucketName, keyName, keyPath);\n+      OMFileRequest.OMDirectoryResult omDirectoryResult =\n+          omPathInfo.getDirectoryResult();\n+\n+      if (omDirectoryResult == FILE_EXISTS ||\n+          omDirectoryResult == FILE_EXISTS_IN_GIVENPATH) {\n+        throw new OMException(\"Unable to create directory: \" + keyName\n+            + \" in volume/bucket: \" + volumeName + \"/\" + bucketName + \" as \" +\n+                \"file:\" + omPathInfo.getFullKeyPathName() + \" already exists\",\n+            FILE_ALREADY_EXISTS);\n+      } else if (omDirectoryResult == DIRECTORY_EXISTS_IN_GIVENPATH ||\n+          omDirectoryResult == NONE) {\n+\n+        // prepare all missing parents\n+        missingParentInfos = OMDirectoryCreateRequestV1.getAllParentDirInfo(\n+                ozoneManager, keyArgs, omPathInfo, trxnLogIndex);\n+        // prepare leafNode dir\n+        OmDirectoryInfo dirInfo = createDirectoryInfoWithACL(\n+                omPathInfo.getLeafNodeName(),\n+                keyArgs, omPathInfo.getLeafNodeObjectId(),\n+                omPathInfo.getLastKnownParentId(), trxnLogIndex,\n+                OzoneAclUtil.fromProtobuf(keyArgs.getAclsList()));\n+        OMFileRequest.addDirectoryTableCacheEntries(omMetadataManager,\n+                Optional.of(dirInfo), Optional.of(missingParentInfos),\n+                trxnLogIndex);\n+\n+        // total number of keys created.\n+        numKeysCreated = missingParentInfos.size() + 1;\n+\n+        result = OMDirectoryCreateRequest.Result.SUCCESS;\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+                dirInfo, missingParentInfos, result);\n+      } else {\n+        result = Result.DIRECTORY_ALREADY_EXISTS;\n+        omResponse.setStatus(Status.DIRECTORY_ALREADY_EXISTS);\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+            result);\n+      }\n+    } catch (IOException ex) {\n+      exception = ex;\n+      omClientResponse = new OMDirectoryCreateResponseV1(\n+          createErrorOMResponse(omResponse, exception), result);\n+    } finally {\n+      addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n+          omDoubleBufferHelper);\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+      }\n+    }\n+\n+    auditLog(auditLogger, buildAuditMessage(OMAction.CREATE_DIRECTORY,\n+        auditMap, exception, userInfo));\n+\n+    logResult(createDirectoryRequest, keyArgs, omMetrics, numKeysCreated,\n+            result, exception);\n+\n+    return omClientResponse;\n+  }\n+\n+  private void logResult(CreateDirectoryRequest createDirectoryRequest,\n+                         KeyArgs keyArgs, OMMetrics omMetrics, int numKeys,\n+                         Result result,\n+                         IOException exception) {\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    switch (result) {\n+    case SUCCESS:\n+      for (int indx = 0; indx < numKeys; indx++) {\n+        omMetrics.incNumKeys();\n+      }\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Directory created. Volume:{}, Bucket:{}, Key:{}\",\n+            volumeName, bucketName, keyName);\n+      }\n+      break;\n+    case DIRECTORY_ALREADY_EXISTS:\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Directory already exists. Volume:{}, Bucket:{}, Key{}\",\n+            volumeName, bucketName, keyName, exception);\n+      }\n+      break;\n+    case FAILURE:\n+      omMetrics.incNumCreateDirectoryFails();\n+      LOG.error(\"Directory creation failed. Volume:{}, Bucket:{}, Key{}. \" +\n+          \"Exception:{}\", volumeName, bucketName, keyName, exception);\n+      break;\n+    default:\n+      LOG.error(\"Unrecognized Result for OMDirectoryCreateRequest: {}\",\n+          createDirectoryRequest);\n+    }\n+  }\n+\n+  /**\n+   * Construct OmDirectoryInfo for every parent directory in missing list.\n+   * @param ozoneManager\n+   * @param keyArgs\n+   * @param pathInfo list of parent directories to be created and its ACLs\n+   * @param trxnLogIndex\n+   * @return\n+   * @throws IOException\n+   */\n+  public static List<OmDirectoryInfo> getAllParentDirInfo(\n+          OzoneManager ozoneManager, KeyArgs keyArgs,\n+          OMFileRequest.OMPathInfoV1 pathInfo, long trxnLogIndex)\n+          throws IOException {\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    List<OmDirectoryInfo> missingParentInfos = new ArrayList<>();\n+\n+    ImmutablePair<Long, Long> objIdRange = OMFileRequest\n+            .getObjIdRangeFromTxId(trxnLogIndex);\n+    long baseObjId = objIdRange.getLeft();\n+    long maxObjId = objIdRange.getRight();\n+    long maxLevels = maxObjId - baseObjId;\n+    long objectCount = 1; // baseObjID is used by the leaf directory\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    long lastKnownParentId = pathInfo.getLastKnownParentId();\n+    List<String> missingParents = pathInfo.getMissingParents();\n+    List<OzoneAcl> inheritAcls = pathInfo.getAcls();\n+    for (String missingKey : missingParents) {\n+      long nextObjId = baseObjId + objectCount;\n+      if (nextObjId > maxObjId) {\n+        throw new OMException(\"Too many directories in path. Exceeds limit of \"\n+                + maxLevels + \". Unable to create directory: \" + keyName\n+                + \" in volume/bucket: \" + volumeName + \"/\" + bucketName,\n+                INVALID_KEY_NAME);\n+      }\n+\n+      LOG.debug(\"missing parent {} getting added to DirectoryTable\",\n+              missingKey);\n+      // what about keyArgs for parent directories? TODO\n+      OmDirectoryInfo dirInfo = createDirectoryInfoWithACL(missingKey,\n+              keyArgs, nextObjId, lastKnownParentId, trxnLogIndex, inheritAcls);\n+      objectCount++;\n+\n+      missingParentInfos.add(dirInfo);\n+\n+      // add entry to directory table\n+      omMetadataManager.getDirectoryTable().addCacheEntry(\n+              new CacheKey<>(omMetadataManager.getOzoneKey(volumeName,", "originalCommit": "c94d909974f2df086bbceb0e5b6b0f87dc977c53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE4MzE5NA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496183194", "bodyText": "And also here entries are set with only leaf name, it should be full path.\nExample:\n/v/b/a/b1/c\nRight now with this logic, missing directory Info's created in cache are which is wrong\n/v/b/a\n/v/b/b1 --> /v/b/a/b1\n/v/b/c --> /v/b/a/b1/c\nI see that we do in OMDirectoryCreateRequestV1.java, So we can remove adding to the cache here, which will solve this issue.\nRight now because of the above logic we have both.", "author": "bharatviswa504", "createdAt": "2020-09-28T19:29:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE1MjcyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxNTU2OA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496815568", "bodyText": "Good catch!", "author": "rakeshadr", "createdAt": "2020-09-29T15:29:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE1MjcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE1NjA4NQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496156085", "bodyText": "Can we have a new API in Metrics class to take a value for increment, instead of calling in for loop?", "author": "bharatviswa504", "createdAt": "2020-09-28T18:38:34Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMDirectoryCreateRequestV1.java", "diffHunk": "@@ -0,0 +1,323 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.file;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.*;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.file.OMDirectoryCreateResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .Status;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.FILE_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.INVALID_KEY_NAME;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+import static org.apache.hadoop.ozone.om.request.file.OMFileRequest.OMDirectoryResult.*;\n+\n+/**\n+ * Handle create directory request. It will add path components to the directory\n+ * table and maintains file system semantics.\n+ */\n+public class OMDirectoryCreateRequestV1 extends OMDirectoryCreateRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMDirectoryCreateRequestV1.class);\n+\n+  public OMDirectoryCreateRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    CreateDirectoryRequest createDirectoryRequest = getOmRequest()\n+        .getCreateDirectoryRequest();\n+    KeyArgs keyArgs = createDirectoryRequest.getKeyArgs();\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+    int numKeysCreated = 0;\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+    omResponse.setCreateDirectoryResponse(CreateDirectoryResponse.newBuilder());\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumCreateDirectory();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+    OzoneManagerProtocolProtos.UserInfo userInfo = getOmRequest().getUserInfo();\n+\n+    Map<String, String> auditMap = buildKeyArgsAuditMap(keyArgs);\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = Result.FAILURE;\n+    List<OmDirectoryInfo> missingParentInfos;\n+\n+    try {\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acl\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+          IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      // Check if this is the root of the filesystem.\n+      if (keyName.length() == 0) {\n+        throw new OMException(\"Directory create failed. Cannot create \" +\n+            \"directory at root of the filesystem\",\n+            OMException.ResultCodes.CANNOT_CREATE_DIRECTORY_AT_ROOT);\n+      }\n+      // acquire lock\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+          volumeName, bucketName);\n+\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      Path keyPath = Paths.get(keyName);\n+\n+      // Need to check if any files exist in the given path, if they exist we\n+      // cannot create a directory with the given key.\n+      // Verify the path against directory table\n+      OMFileRequest.OMPathInfoV1 omPathInfo =\n+          OMFileRequest.verifyDirectoryKeysInPath(omMetadataManager, volumeName,\n+              bucketName, keyName, keyPath);\n+      OMFileRequest.OMDirectoryResult omDirectoryResult =\n+          omPathInfo.getDirectoryResult();\n+\n+      if (omDirectoryResult == FILE_EXISTS ||\n+          omDirectoryResult == FILE_EXISTS_IN_GIVENPATH) {\n+        throw new OMException(\"Unable to create directory: \" + keyName\n+            + \" in volume/bucket: \" + volumeName + \"/\" + bucketName + \" as \" +\n+                \"file:\" + omPathInfo.getFullKeyPathName() + \" already exists\",\n+            FILE_ALREADY_EXISTS);\n+      } else if (omDirectoryResult == DIRECTORY_EXISTS_IN_GIVENPATH ||\n+          omDirectoryResult == NONE) {\n+\n+        // prepare all missing parents\n+        missingParentInfos = OMDirectoryCreateRequestV1.getAllParentDirInfo(\n+                ozoneManager, keyArgs, omPathInfo, trxnLogIndex);\n+        // prepare leafNode dir\n+        OmDirectoryInfo dirInfo = createDirectoryInfoWithACL(\n+                omPathInfo.getLeafNodeName(),\n+                keyArgs, omPathInfo.getLeafNodeObjectId(),\n+                omPathInfo.getLastKnownParentId(), trxnLogIndex,\n+                OzoneAclUtil.fromProtobuf(keyArgs.getAclsList()));\n+        OMFileRequest.addDirectoryTableCacheEntries(omMetadataManager,\n+                Optional.of(dirInfo), Optional.of(missingParentInfos),\n+                trxnLogIndex);\n+\n+        // total number of keys created.\n+        numKeysCreated = missingParentInfos.size() + 1;\n+\n+        result = OMDirectoryCreateRequest.Result.SUCCESS;\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+                dirInfo, missingParentInfos, result);\n+      } else {\n+        result = Result.DIRECTORY_ALREADY_EXISTS;\n+        omResponse.setStatus(Status.DIRECTORY_ALREADY_EXISTS);\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+            result);\n+      }\n+    } catch (IOException ex) {\n+      exception = ex;\n+      omClientResponse = new OMDirectoryCreateResponseV1(\n+          createErrorOMResponse(omResponse, exception), result);\n+    } finally {\n+      addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n+          omDoubleBufferHelper);\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+      }\n+    }\n+\n+    auditLog(auditLogger, buildAuditMessage(OMAction.CREATE_DIRECTORY,\n+        auditMap, exception, userInfo));\n+\n+    logResult(createDirectoryRequest, keyArgs, omMetrics, numKeysCreated,\n+            result, exception);\n+\n+    return omClientResponse;\n+  }\n+\n+  private void logResult(CreateDirectoryRequest createDirectoryRequest,\n+                         KeyArgs keyArgs, OMMetrics omMetrics, int numKeys,\n+                         Result result,\n+                         IOException exception) {\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    switch (result) {\n+    case SUCCESS:\n+      for (int indx = 0; indx < numKeys; indx++) {\n+        omMetrics.incNumKeys();", "originalCommit": "c94d909974f2df086bbceb0e5b6b0f87dc977c53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgyMTI5NQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496821295", "bodyText": "Sure, thats nice addition. Will do it", "author": "rakeshadr", "createdAt": "2020-09-29T15:34:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE1NjA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE5MDk5MQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496190991", "bodyText": "We can remove trace here in loop, we can log outside the for loop.", "author": "bharatviswa504", "createdAt": "2020-09-28T19:44:58Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -129,6 +134,131 @@ public static OMPathInfo verifyFilesInPath(\n     return new OMPathInfo(missing, OMDirectoryResult.NONE, inheritAcls);\n   }\n \n+  /**\n+   * Verify any dir/key exist in the given path in the specified\n+   * volume/bucket by iterating through directory table.\n+   *\n+   * @param omMetadataManager OM Metadata manager\n+   * @param volumeName        volume name\n+   * @param bucketName        bucket name\n+   * @param keyName           key name\n+   * @param keyPath           path\n+   * @return OMPathInfoV1 path info object\n+   * @throws IOException on DB failure\n+   */\n+  public static OMPathInfoV1 verifyDirectoryKeysInPath(\n+          @Nonnull OMMetadataManager omMetadataManager,\n+          @Nonnull String volumeName,\n+          @Nonnull String bucketName, @Nonnull String keyName,\n+          @Nonnull Path keyPath) throws IOException {\n+\n+    String leafNodeName = OzoneFSUtils.getFileName(keyName);\n+    List<String> missing = new ArrayList<>();\n+    List<OzoneAcl> inheritAcls = new ArrayList<>();\n+    OMDirectoryResult result = OMDirectoryResult.NONE;\n+\n+    Iterator<Path> elements = keyPath.iterator();\n+    // TODO: volume id and bucket id generation logic.\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    inheritAcls = omBucketInfo.getAcls();\n+    long lastKnownParentId = omBucketInfo.getObjectID();\n+    OmDirectoryInfo parentDirInfo = null;\n+    String dbDirName = \"\"; // absolute path for trace logs\n+    // for better logging\n+    StringBuilder fullKeyPath = new StringBuilder(bucketKey);\n+    while (elements.hasNext()) {\n+      String fileName = elements.next().toString();\n+      fullKeyPath.append(OzoneConsts.OM_KEY_PREFIX);\n+      fullKeyPath.append(fileName);\n+      if (missing.size() > 0) {\n+        // Add all the sub-dirs to the missing list except the leaf element.\n+        // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt.\n+        // Assume /vol1/buck1/a/b/c exists, then add d, e, f into missing list.\n+        if(elements.hasNext()){\n+          // skips leaf node.\n+          missing.add(fileName);\n+        }\n+        continue;\n+      }\n+\n+      // For example, /vol1/buck1/a/b/c/d/e/f/file1.txt\n+      // 1. Do lookup on directoryTable. If not exists goto next step.\n+      // 2. Do look on keyTable. If not exists goto next step.\n+      // 3. Add 'sub-dir' to missing parents list\n+      String dbNodeName = omMetadataManager.getOzonePathKey(\n+              lastKnownParentId, fileName);\n+      OmDirectoryInfo omDirInfo = omMetadataManager.getDirectoryTable().\n+              get(dbNodeName);\n+      if (omDirInfo != null) {\n+        dbDirName += omDirInfo.getName() + OzoneConsts.OZONE_URI_DELIMITER;\n+        if (elements.hasNext()) {\n+          result = OMDirectoryResult.DIRECTORY_EXISTS_IN_GIVENPATH;\n+          lastKnownParentId = omDirInfo.getObjectID();\n+          inheritAcls = omDirInfo.getAcls();\n+          continue;\n+        } else {\n+          // Checked all the sub-dirs till the leaf node.\n+          // Found a directory in the given path.\n+          result = OMDirectoryResult.DIRECTORY_EXISTS;\n+        }\n+      } else {\n+        // Get parentID from the lastKnownParent. For any files, directly under\n+        // the bucket, the parent is the bucketID. Say, \"/vol1/buck1/file1\"\n+        // TODO: Need to add UT for this case along with OMFileCreateRequest.\n+        if (omMetadataManager.getKeyTable().isExist(dbNodeName)) {\n+          if (elements.hasNext()) {\n+            // Found a file in the given key name.\n+            result = OMDirectoryResult.FILE_EXISTS_IN_GIVENPATH;\n+          } else {\n+            // Checked all the sub-dirs till the leaf file.\n+            // Found a file with the given key name.\n+            result = OMDirectoryResult.FILE_EXISTS;\n+          }\n+          break; // Skip directory traversal as it hits key.\n+        }\n+\n+        // Add to missing list, there is no such file/directory with given name.\n+        if (elements.hasNext()) {\n+          missing.add(fileName);\n+        }\n+\n+        String dbDirKeyName = omMetadataManager.getOzoneDirKey(volumeName,\n+                bucketName, dbDirName);\n+        LOG.trace(\"Acls inherited from parent \" + dbDirKeyName + \" are : \"", "originalCommit": "c94d909974f2df086bbceb0e5b6b0f87dc977c53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE5NDAxMQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496194011", "bodyText": "Here only validateAndUpdateCache is done, so it will only be in cache.\nAs Table get checks both in cache and DB first check should be enough here.", "author": "bharatviswa504", "createdAt": "2020-09-28T19:50:51Z", "path": "hadoop-ozone/ozone-manager/src/test/java/org/apache/hadoop/ozone/om/request/file/TestOMDirectoryCreateRequestV1.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.file;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.proto.HddsProtos;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.AuditMessage;\n+import org.apache.hadoop.ozone.om.*;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFSUtils;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.OMClientRequest;\n+import org.apache.hadoop.ozone.om.request.TestOMRequestUtils;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.CreateDirectoryRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.*;\n+import org.junit.rules.TemporaryFolder;\n+import org.mockito.Mockito;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.VOLUME_NOT_FOUND;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Test OM directory create request V1 layout version.\n+ */\n+public class TestOMDirectoryCreateRequestV1 {\n+\n+  @Rule\n+  public TemporaryFolder folder = new TemporaryFolder();\n+\n+  private OzoneManager ozoneManager;\n+  private OMMetrics omMetrics;\n+  private OMMetadataManager omMetadataManager;\n+  private AuditLogger auditLogger;\n+  // Just setting ozoneManagerDoubleBuffer which does nothing.\n+  private OzoneManagerDoubleBufferHelper ozoneManagerDoubleBufferHelper =\n+          ((response, transactionIndex) -> {\n+            return null;\n+          });\n+\n+  @Before\n+  public void setup() throws Exception {\n+    ozoneManager = Mockito.mock(OzoneManager.class);\n+    omMetrics = OMMetrics.create();\n+    OzoneConfiguration ozoneConfiguration = new OzoneConfiguration();\n+    ozoneConfiguration.set(OMConfigKeys.OZONE_OM_DB_DIRS,\n+            folder.newFolder().getAbsolutePath());\n+    omMetadataManager = new OmMetadataManagerImpl(ozoneConfiguration);\n+    when(ozoneManager.getMetrics()).thenReturn(omMetrics);\n+    when(ozoneManager.getMetadataManager()).thenReturn(omMetadataManager);\n+    auditLogger = Mockito.mock(AuditLogger.class);\n+    when(ozoneManager.getAuditLogger()).thenReturn(auditLogger);\n+    Mockito.doNothing().when(auditLogger).logWrite(any(AuditMessage.class));\n+    when(ozoneManager.resolveBucketLink(any(KeyArgs.class),\n+            any(OMClientRequest.class)))\n+            .thenReturn(new ResolvedBucket(Pair.of(\"\", \"\"), Pair.of(\"\", \"\")));\n+  }\n+\n+  @After\n+  public void stop() {\n+    omMetrics.unRegister();\n+    Mockito.framework().clearInlineMocks();\n+  }\n+\n+  @Test\n+  public void testPreExecute() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    String keyName = \"a/b/c\";\n+\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirectoryCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest =\n+            omDirectoryCreateRequestV1.preExecute(ozoneManager);\n+\n+    // As in preExecute, we modify original request.\n+    Assert.assertNotEquals(omRequest, modifiedOmRequest);\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCache() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long bucketID = omBucketInfo.getObjectID();\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.OK);\n+    verifyDirectoriesInDB(dirs, bucketID);\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithVolumeNotFound() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertEquals(VOLUME_NOT_FOUND,\n+            omClientResponse.getOMResponse().getStatus());\n+\n+    // Key should not exist in DB\n+    Assert.assertTrue(\"Unexpected directory entries!\",\n+            omMetadataManager.getDirectoryTable().isEmpty());\n+\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithBucketNotFound() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+    TestOMRequestUtils.addVolumeToDB(volumeName, omMetadataManager);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.BUCKET_NOT_FOUND);\n+\n+    // Key should not exist in DB\n+    Assert.assertTrue(\"Unexpected directory entries!\",\n+            omMetadataManager.getDirectoryTable().isEmpty());\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithSubDirectoryInPath()\n+          throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long bucketID = omBucketInfo.getObjectID();\n+    int objID = 100;\n+\n+    //1. Create root\n+    OmDirectoryInfo omDirInfo =\n+            TestOMRequestUtils.createOmDirectoryInfo(dirs.get(0), objID++,\n+                    bucketID);\n+    TestOMRequestUtils.addDirKeyToDirTable(true, omDirInfo, 5000,\n+            omMetadataManager);\n+    //2. Create sub-directory under root\n+    omDirInfo = TestOMRequestUtils.createOmDirectoryInfo(dirs.get(1), objID++,\n+            omDirInfo.getObjectID());\n+    TestOMRequestUtils.addDirKeyToDirTable(true, omDirInfo, 5000,\n+            omMetadataManager);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.OK);\n+\n+    // Key should exist in DB and cache.\n+    verifyDirectoriesInDB(dirs, bucketID);\n+    verifyDirectoriesInCache(dirs, bucketID);\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithDirectoryAlreadyExists()\n+          throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long bucketID = omBucketInfo.getObjectID();\n+\n+    // bucketID is the parent\n+    long parentID = bucketID;\n+\n+    // add all the directories into DirectoryTable\n+    for (int indx = 0; indx < dirs.size(); indx++) {\n+      long objID = 100 + indx;\n+      long txnID = 5000 + indx;\n+      // for index=0, parentID is bucketID\n+      OmDirectoryInfo omDirInfo = TestOMRequestUtils.createOmDirectoryInfo(\n+              dirs.get(indx), objID, parentID);\n+      TestOMRequestUtils.addDirKeyToDirTable(true, omDirInfo,\n+              txnID, omMetadataManager);\n+\n+      parentID = omDirInfo.getObjectID();\n+    }\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.DIRECTORY_ALREADY_EXISTS);\n+\n+    // Key should exist in DB and cache.\n+    verifyDirectoriesInDB(dirs, bucketID);", "originalCommit": "c94d909974f2df086bbceb0e5b6b0f87dc977c53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxMzkzNA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496813934", "bodyText": "Sure, I will do dirNotExists check in testValidateAndUpdateCacheWithDirectoryAlreadyExists", "author": "rakeshadr", "createdAt": "2020-09-29T15:27:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE5NDAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzNTU0MQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496235541", "bodyText": "Can we use Key separator(/) here?", "author": "bharatviswa504", "createdAt": "2020-09-28T21:12:32Z", "path": "hadoop-ozone/common/src/main/java/org/apache/hadoop/ozone/om/helpers/OmDirectoryInfo.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.om.helpers;\n+\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.OzoneConsts;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+\n+import java.util.*;\n+\n+/**\n+ * This class represents the directory information by keeping each component\n+ * in the user given path and a pointer to its parent directory element in the\n+ * path. Also, it stores directory node related metdata details.\n+ */\n+public class OmDirectoryInfo extends WithObjectID {\n+  private long parentObjectID; // pointer to parent directory\n+\n+  private String name; // directory name\n+\n+  private long creationTime;\n+  private long modificationTime;\n+\n+  private List<OzoneAcl> acls;\n+\n+  public OmDirectoryInfo(Builder builder) {\n+    this.name = builder.name;\n+    this.acls = builder.acls;\n+    this.metadata = builder.metadata;\n+    this.objectID = builder.objectID;\n+    this.updateID = builder.updateID;\n+    this.parentObjectID = builder.parentObjectID;\n+    this.creationTime = builder.creationTime;\n+    this.modificationTime = builder.modificationTime;\n+  }\n+\n+  /**\n+   * Returns new builder class that builds a OmPrefixInfo.\n+   *\n+   * @return Builder\n+   */\n+  public static OmDirectoryInfo.Builder newBuilder() {\n+    return new OmDirectoryInfo.Builder();\n+  }\n+\n+  /**\n+   * Builder for Directory Info.\n+   */\n+  public static class Builder {\n+    private long parentObjectID; // pointer to parent directory\n+\n+    private long objectID;\n+    private long updateID;\n+\n+    private String name;\n+\n+    private long creationTime;\n+    private long modificationTime;\n+\n+    private List<OzoneAcl> acls;\n+    private Map<String, String> metadata;\n+\n+    public Builder() {\n+      //Default values\n+      this.acls = new LinkedList<>();\n+      this.metadata = new HashMap<>();\n+    }\n+\n+    public Builder setParentObjectID(long parentObjectId) {\n+      this.parentObjectID = parentObjectId;\n+      return this;\n+    }\n+\n+    public Builder setObjectID(long objectId) {\n+      this.objectID = objectId;\n+      return this;\n+    }\n+\n+    public Builder setUpdateID(long updateId) {\n+      this.updateID = updateId;\n+      return this;\n+    }\n+\n+    public Builder setName(String dirName) {\n+      this.name = dirName;\n+      return this;\n+    }\n+\n+    public Builder setCreationTime(long newCreationTime) {\n+      this.creationTime = newCreationTime;\n+      return this;\n+    }\n+\n+    public Builder setModificationTime(long newModificationTime) {\n+      this.modificationTime = newModificationTime;\n+      return this;\n+    }\n+\n+    public Builder setAcls(List<OzoneAcl> listOfAcls) {\n+      if (listOfAcls != null) {\n+        this.acls.addAll(listOfAcls);\n+      }\n+      return this;\n+    }\n+\n+    public Builder addAcl(OzoneAcl ozoneAcl) {\n+      if (ozoneAcl != null) {\n+        this.acls.add(ozoneAcl);\n+      }\n+      return this;\n+    }\n+\n+    public Builder addMetadata(String key, String value) {\n+      metadata.put(key, value);\n+      return this;\n+    }\n+\n+    public Builder addAllMetadata(Map<String, String> additionalMetadata) {\n+      if (additionalMetadata != null) {\n+        metadata.putAll(additionalMetadata);\n+      }\n+      return this;\n+    }\n+\n+    public OmDirectoryInfo build() {\n+      return new OmDirectoryInfo(this);\n+    }\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return getObjectID() + \":\" + getName();", "originalCommit": "c94d909974f2df086bbceb0e5b6b0f87dc977c53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgxMjk4Nw==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496812987", "bodyText": "Will this get confused with the value by getPath(). This will return \"getParentObjectID() + OzoneConsts.OM_KEY_PREFIX + getName()\"\nI don't have strong opinion. If you feel then I can make toString() also like getObjectID() + OzoneConsts.OM_KEY_PREFIX + getName()", "author": "rakeshadr", "createdAt": "2020-09-29T15:27:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzNTU0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgzMTQ2OQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496831469", "bodyText": "As discussed offline, we will print here  parentID/name:objectID", "author": "bharatviswa504", "createdAt": "2020-09-29T15:44:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzNTU0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzODU4Mg==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496238582", "bodyText": "One more test can be added here file exists in a given path.", "author": "bharatviswa504", "createdAt": "2020-09-28T21:18:53Z", "path": "hadoop-ozone/ozone-manager/src/test/java/org/apache/hadoop/ozone/om/request/file/TestOMDirectoryCreateRequestV1.java", "diffHunk": "@@ -0,0 +1,484 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.file;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.proto.HddsProtos;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.AuditMessage;\n+import org.apache.hadoop.ozone.om.*;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFSUtils;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.OMClientRequest;\n+import org.apache.hadoop.ozone.om.request.TestOMRequestUtils;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.CreateDirectoryRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.*;\n+import org.junit.rules.TemporaryFolder;\n+import org.mockito.Mockito;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.VOLUME_NOT_FOUND;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Test OM directory create request V1 layout version.\n+ */\n+public class TestOMDirectoryCreateRequestV1 {\n+\n+  @Rule\n+  public TemporaryFolder folder = new TemporaryFolder();\n+\n+  private OzoneManager ozoneManager;\n+  private OMMetrics omMetrics;\n+  private OMMetadataManager omMetadataManager;\n+  private AuditLogger auditLogger;\n+  // Just setting ozoneManagerDoubleBuffer which does nothing.\n+  private OzoneManagerDoubleBufferHelper ozoneManagerDoubleBufferHelper =\n+          ((response, transactionIndex) -> {\n+            return null;\n+          });\n+\n+  @Before\n+  public void setup() throws Exception {\n+    ozoneManager = Mockito.mock(OzoneManager.class);\n+    omMetrics = OMMetrics.create();\n+    OzoneConfiguration ozoneConfiguration = new OzoneConfiguration();\n+    ozoneConfiguration.set(OMConfigKeys.OZONE_OM_DB_DIRS,\n+            folder.newFolder().getAbsolutePath());\n+    omMetadataManager = new OmMetadataManagerImpl(ozoneConfiguration);\n+    when(ozoneManager.getMetrics()).thenReturn(omMetrics);\n+    when(ozoneManager.getMetadataManager()).thenReturn(omMetadataManager);\n+    auditLogger = Mockito.mock(AuditLogger.class);\n+    when(ozoneManager.getAuditLogger()).thenReturn(auditLogger);\n+    Mockito.doNothing().when(auditLogger).logWrite(any(AuditMessage.class));\n+    when(ozoneManager.resolveBucketLink(any(KeyArgs.class),\n+            any(OMClientRequest.class)))\n+            .thenReturn(new ResolvedBucket(Pair.of(\"\", \"\"), Pair.of(\"\", \"\")));\n+  }\n+\n+  @After\n+  public void stop() {\n+    omMetrics.unRegister();\n+    Mockito.framework().clearInlineMocks();\n+  }\n+\n+  @Test\n+  public void testPreExecute() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    String keyName = \"a/b/c\";\n+\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirectoryCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest =\n+            omDirectoryCreateRequestV1.preExecute(ozoneManager);\n+\n+    // As in preExecute, we modify original request.\n+    Assert.assertNotEquals(omRequest, modifiedOmRequest);\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCache() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long bucketID = omBucketInfo.getObjectID();\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.OK);\n+    verifyDirectoriesInDB(dirs, bucketID);\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithVolumeNotFound() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertEquals(VOLUME_NOT_FOUND,\n+            omClientResponse.getOMResponse().getStatus());\n+\n+    // Key should not exist in DB\n+    Assert.assertTrue(\"Unexpected directory entries!\",\n+            omMetadataManager.getDirectoryTable().isEmpty());\n+\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithBucketNotFound() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+    TestOMRequestUtils.addVolumeToDB(volumeName, omMetadataManager);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.BUCKET_NOT_FOUND);\n+\n+    // Key should not exist in DB\n+    Assert.assertTrue(\"Unexpected directory entries!\",\n+            omMetadataManager.getDirectoryTable().isEmpty());\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithSubDirectoryInPath()\n+          throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long bucketID = omBucketInfo.getObjectID();\n+    int objID = 100;\n+\n+    //1. Create root\n+    OmDirectoryInfo omDirInfo =\n+            TestOMRequestUtils.createOmDirectoryInfo(dirs.get(0), objID++,\n+                    bucketID);\n+    TestOMRequestUtils.addDirKeyToDirTable(true, omDirInfo, 5000,\n+            omMetadataManager);\n+    //2. Create sub-directory under root\n+    omDirInfo = TestOMRequestUtils.createOmDirectoryInfo(dirs.get(1), objID++,\n+            omDirInfo.getObjectID());\n+    TestOMRequestUtils.addDirKeyToDirTable(true, omDirInfo, 5000,\n+            omMetadataManager);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.OK);\n+\n+    // Key should exist in DB and cache.\n+    verifyDirectoriesInDB(dirs, bucketID);\n+    verifyDirectoriesInCache(dirs, bucketID);\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithDirectoryAlreadyExists()\n+          throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long bucketID = omBucketInfo.getObjectID();\n+\n+    // bucketID is the parent\n+    long parentID = bucketID;\n+\n+    // add all the directories into DirectoryTable\n+    for (int indx = 0; indx < dirs.size(); indx++) {\n+      long objID = 100 + indx;\n+      long txnID = 5000 + indx;\n+      // for index=0, parentID is bucketID\n+      OmDirectoryInfo omDirInfo = TestOMRequestUtils.createOmDirectoryInfo(\n+              dirs.get(indx), objID, parentID);\n+      TestOMRequestUtils.addDirKeyToDirTable(true, omDirInfo,\n+              txnID, omMetadataManager);\n+\n+      parentID = omDirInfo.getObjectID();\n+    }\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.DIRECTORY_ALREADY_EXISTS);\n+\n+    // Key should exist in DB and cache.\n+    verifyDirectoriesInDB(dirs, bucketID);\n+    verifyDirectoriesInCache(dirs, bucketID);\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithFilesInPath() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long parentID = omBucketInfo.getObjectID();\n+\n+    long objID = 100;\n+    long txnID = 5000;\n+    // for index=0, parentID is bucketID\n+    OmDirectoryInfo omDirInfo = TestOMRequestUtils.createOmDirectoryInfo(\n+            dirs.get(0), objID++, parentID);\n+    TestOMRequestUtils.addDirKeyToDirTable(true, omDirInfo,\n+            txnID, omMetadataManager);\n+    parentID = omDirInfo.getObjectID();\n+\n+    // Add a key in second level.\n+    OmKeyInfo omKeyInfo = TestOMRequestUtils.createOmKeyInfo(volumeName,\n+            bucketName, keyName, HddsProtos.ReplicationType.RATIS,\n+            HddsProtos.ReplicationFactor.THREE, objID++);\n+    String ozoneKey = parentID + \"/\" + dirs.get(1);\n+    omMetadataManager.getKeyTable().addCacheEntry(new CacheKey<>(ozoneKey),\n+            new CacheValue<>(Optional.of(omKeyInfo), ++txnID));\n+    omMetadataManager.getKeyTable().put(ozoneKey, omKeyInfo);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest =\n+            omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.FILE_ALREADY_EXISTS);", "originalCommit": "c94d909974f2df086bbceb0e5b6b0f87dc977c53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgyNDE4MQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496824181", "bodyText": "Sure, will add.", "author": "rakeshadr", "createdAt": "2020-09-29T15:37:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjIzODU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI0MzQwOA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496243408", "bodyText": "This can be removed, already volume/buckets use new id generation logic.", "author": "bharatviswa504", "createdAt": "2020-09-28T21:29:23Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMFileRequest.java", "diffHunk": "@@ -129,6 +134,131 @@ public static OMPathInfo verifyFilesInPath(\n     return new OMPathInfo(missing, OMDirectoryResult.NONE, inheritAcls);\n   }\n \n+  /**\n+   * Verify any dir/key exist in the given path in the specified\n+   * volume/bucket by iterating through directory table.\n+   *\n+   * @param omMetadataManager OM Metadata manager\n+   * @param volumeName        volume name\n+   * @param bucketName        bucket name\n+   * @param keyName           key name\n+   * @param keyPath           path\n+   * @return OMPathInfoV1 path info object\n+   * @throws IOException on DB failure\n+   */\n+  public static OMPathInfoV1 verifyDirectoryKeysInPath(\n+          @Nonnull OMMetadataManager omMetadataManager,\n+          @Nonnull String volumeName,\n+          @Nonnull String bucketName, @Nonnull String keyName,\n+          @Nonnull Path keyPath) throws IOException {\n+\n+    String leafNodeName = OzoneFSUtils.getFileName(keyName);\n+    List<String> missing = new ArrayList<>();\n+    List<OzoneAcl> inheritAcls = new ArrayList<>();\n+    OMDirectoryResult result = OMDirectoryResult.NONE;\n+\n+    Iterator<Path> elements = keyPath.iterator();\n+    // TODO: volume id and bucket id generation logic.", "originalCommit": "c94d909974f2df086bbceb0e5b6b0f87dc977c53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjgyNDQyMQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r496824421", "bodyText": "Sure", "author": "rakeshadr", "createdAt": "2020-09-29T15:37:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI0MzQwOA=="}], "type": "inlineReview"}, {"oid": "4347ff0ccf452a92b5e62ba332a0400140f177ff", "url": "https://github.com/apache/ozone/commit/4347ff0ccf452a92b5e62ba332a0400140f177ff", "message": "Fixed review comments", "committedDate": "2020-09-29T17:19:36Z", "type": "commit"}, {"oid": "72172429fb9580ac63f35427ca91d34d5fe4eaca", "url": "https://github.com/apache/ozone/commit/72172429fb9580ac63f35427ca91d34d5fe4eaca", "message": "Fixed cheeckstyle warnings", "committedDate": "2020-09-29T18:33:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg0MDI5OQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r497840299", "bodyText": "We are adding them 2 times once here, and next immediately in addDirectoryTableCacheEntries.\nNo correctness issue, but can be removed from one place.", "author": "bharatviswa504", "createdAt": "2020-09-30T22:39:49Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMDirectoryCreateRequestV1.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.file;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.*;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.file.OMDirectoryCreateResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .Status;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.FILE_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.INVALID_KEY_NAME;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+import static org.apache.hadoop.ozone.om.request.file.OMFileRequest.OMDirectoryResult.*;\n+\n+/**\n+ * Handle create directory request. It will add path components to the directory\n+ * table and maintains file system semantics.\n+ */\n+public class OMDirectoryCreateRequestV1 extends OMDirectoryCreateRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMDirectoryCreateRequestV1.class);\n+\n+  public OMDirectoryCreateRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    CreateDirectoryRequest createDirectoryRequest = getOmRequest()\n+        .getCreateDirectoryRequest();\n+    KeyArgs keyArgs = createDirectoryRequest.getKeyArgs();\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+    int numKeysCreated = 0;\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+    omResponse.setCreateDirectoryResponse(CreateDirectoryResponse.newBuilder());\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumCreateDirectory();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+    OzoneManagerProtocolProtos.UserInfo userInfo = getOmRequest().getUserInfo();\n+\n+    Map<String, String> auditMap = buildKeyArgsAuditMap(keyArgs);\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = Result.FAILURE;\n+    List<OmDirectoryInfo> missingParentInfos;\n+\n+    try {\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acl\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+          IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      // Check if this is the root of the filesystem.\n+      if (keyName.length() == 0) {\n+        throw new OMException(\"Directory create failed. Cannot create \" +\n+            \"directory at root of the filesystem\",\n+            OMException.ResultCodes.CANNOT_CREATE_DIRECTORY_AT_ROOT);\n+      }\n+      // acquire lock\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+          volumeName, bucketName);\n+\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      Path keyPath = Paths.get(keyName);\n+\n+      // Need to check if any files exist in the given path, if they exist we\n+      // cannot create a directory with the given key.\n+      // Verify the path against directory table\n+      OMFileRequest.OMPathInfoV1 omPathInfo =\n+          OMFileRequest.verifyDirectoryKeysInPath(omMetadataManager, volumeName,\n+              bucketName, keyName, keyPath);\n+      OMFileRequest.OMDirectoryResult omDirectoryResult =\n+          omPathInfo.getDirectoryResult();\n+\n+      if (omDirectoryResult == FILE_EXISTS ||\n+          omDirectoryResult == FILE_EXISTS_IN_GIVENPATH) {\n+        throw new OMException(\"Unable to create directory: \" + keyName\n+            + \" in volume/bucket: \" + volumeName + \"/\" + bucketName + \" as \" +\n+                \"file:\" + omPathInfo.getFileExistsInPath() + \" already exists\",\n+            FILE_ALREADY_EXISTS);\n+      } else if (omDirectoryResult == DIRECTORY_EXISTS_IN_GIVENPATH ||\n+          omDirectoryResult == NONE) {\n+\n+        // prepare all missing parents\n+        missingParentInfos = OMDirectoryCreateRequestV1.getAllParentDirInfo(\n+                ozoneManager, keyArgs, omPathInfo, trxnLogIndex);\n+        // prepare leafNode dir\n+        OmDirectoryInfo dirInfo = createDirectoryInfoWithACL(\n+                omPathInfo.getLeafNodeName(),\n+                keyArgs, omPathInfo.getLeafNodeObjectId(),\n+                omPathInfo.getLastKnownParentId(), trxnLogIndex,\n+                OzoneAclUtil.fromProtobuf(keyArgs.getAclsList()));\n+        OMFileRequest.addDirectoryTableCacheEntries(omMetadataManager,\n+                Optional.of(dirInfo), Optional.of(missingParentInfos),\n+                trxnLogIndex);\n+\n+        // total number of keys created.\n+        numKeysCreated = missingParentInfos.size() + 1;\n+\n+        result = OMDirectoryCreateRequest.Result.SUCCESS;\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+                dirInfo, missingParentInfos, result);\n+      } else {\n+        result = Result.DIRECTORY_ALREADY_EXISTS;\n+        omResponse.setStatus(Status.DIRECTORY_ALREADY_EXISTS);\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+            result);\n+      }\n+    } catch (IOException ex) {\n+      exception = ex;\n+      omClientResponse = new OMDirectoryCreateResponseV1(\n+          createErrorOMResponse(omResponse, exception), result);\n+    } finally {\n+      addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n+          omDoubleBufferHelper);\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+      }\n+    }\n+\n+    auditLog(auditLogger, buildAuditMessage(OMAction.CREATE_DIRECTORY,\n+        auditMap, exception, userInfo));\n+\n+    logResult(createDirectoryRequest, keyArgs, omMetrics, numKeysCreated,\n+            result, exception);\n+\n+    return omClientResponse;\n+  }\n+\n+  private void logResult(CreateDirectoryRequest createDirectoryRequest,\n+                         KeyArgs keyArgs, OMMetrics omMetrics, int numKeys,\n+                         Result result,\n+                         IOException exception) {\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    switch (result) {\n+    case SUCCESS:\n+      omMetrics.incNumKeys(numKeys);\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Directory created. Volume:{}, Bucket:{}, Key:{}\",\n+            volumeName, bucketName, keyName);\n+      }\n+      break;\n+    case DIRECTORY_ALREADY_EXISTS:\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Directory already exists. Volume:{}, Bucket:{}, Key{}\",\n+            volumeName, bucketName, keyName, exception);\n+      }\n+      break;\n+    case FAILURE:\n+      omMetrics.incNumCreateDirectoryFails();\n+      LOG.error(\"Directory creation failed. Volume:{}, Bucket:{}, Key{}. \" +\n+          \"Exception:{}\", volumeName, bucketName, keyName, exception);\n+      break;\n+    default:\n+      LOG.error(\"Unrecognized Result for OMDirectoryCreateRequest: {}\",\n+          createDirectoryRequest);\n+    }\n+  }\n+\n+  /**\n+   * Construct OmDirectoryInfo for every parent directory in missing list.\n+   * @param ozoneManager\n+   * @param keyArgs\n+   * @param pathInfo list of parent directories to be created and its ACLs\n+   * @param trxnLogIndex\n+   * @return\n+   * @throws IOException\n+   */\n+  public static List<OmDirectoryInfo> getAllParentDirInfo(\n+          OzoneManager ozoneManager, KeyArgs keyArgs,\n+          OMFileRequest.OMPathInfoV1 pathInfo, long trxnLogIndex)\n+          throws IOException {\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    List<OmDirectoryInfo> missingParentInfos = new ArrayList<>();\n+\n+    ImmutablePair<Long, Long> objIdRange = OMFileRequest\n+            .getObjIdRangeFromTxId(trxnLogIndex);\n+    long baseObjId = objIdRange.getLeft();\n+    long maxObjId = objIdRange.getRight();\n+    long maxLevels = maxObjId - baseObjId;\n+    long objectCount = 1; // baseObjID is used by the leaf directory\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    long lastKnownParentId = pathInfo.getLastKnownParentId();\n+    List<String> missingParents = pathInfo.getMissingParents();\n+    List<OzoneAcl> inheritAcls = pathInfo.getAcls();\n+    for (String missingKey : missingParents) {\n+      long nextObjId = baseObjId + objectCount;\n+      if (nextObjId > maxObjId) {\n+        throw new OMException(\"Too many directories in path. Exceeds limit of \"\n+                + maxLevels + \". Unable to create directory: \" + keyName\n+                + \" in volume/bucket: \" + volumeName + \"/\" + bucketName,\n+                INVALID_KEY_NAME);\n+      }\n+\n+      LOG.debug(\"missing parent {} getting added to DirectoryTable\",\n+              missingKey);\n+      OmDirectoryInfo dirInfo = createDirectoryInfoWithACL(missingKey,\n+              keyArgs, nextObjId, lastKnownParentId, trxnLogIndex, inheritAcls);\n+      objectCount++;\n+\n+      missingParentInfos.add(dirInfo);\n+\n+      // add entry to directory table\n+      String dirKey = omMetadataManager.getOzonePathKey(", "originalCommit": "72172429fb9580ac63f35427ca91d34d5fe4eaca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk2MjU2Ng==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r497962566", "bodyText": "Sure, I will remove it in my new class.\nFYI, looks like existing code OMDirectoryCreateRequest.java#L276 has this issue. Like you said, there is no harm anyway and am not touching the current code.", "author": "rakeshadr", "createdAt": "2020-10-01T03:22:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg0MDI5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ2MjA1MA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r498462050", "bodyText": "Yes, looks like we can remove from existing code.\nLet's open a new jira to fix this.", "author": "bharatviswa504", "createdAt": "2020-10-01T19:16:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg0MDI5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg0Mjg2OQ==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r497842869", "bodyText": "Minor:\nkeyName should be bucketKey+\"/\"+dirs.get(0)+\"/\"+dirs.get(1), as this is the key put in to keyTable.\nNo correctness issue BTW.", "author": "bharatviswa504", "createdAt": "2020-09-30T22:47:25Z", "path": "hadoop-ozone/ozone-manager/src/test/java/org/apache/hadoop/ozone/om/request/file/TestOMDirectoryCreateRequestV1.java", "diffHunk": "@@ -0,0 +1,576 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.file;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.RandomStringUtils;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.apache.hadoop.hdds.conf.OzoneConfiguration;\n+import org.apache.hadoop.hdds.protocol.proto.HddsProtos;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.AuditMessage;\n+import org.apache.hadoop.ozone.om.OMConfigKeys;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OmMetadataManagerImpl;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.ResolvedBucket;\n+import org.apache.hadoop.ozone.om.helpers.OmBucketInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmDirectoryInfo;\n+import org.apache.hadoop.ozone.om.helpers.OmKeyInfo;\n+import org.apache.hadoop.ozone.om.helpers.OzoneFSUtils;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.OMClientRequest;\n+import org.apache.hadoop.ozone.om.request.TestOMRequestUtils;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.CreateDirectoryRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.OMRequest;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+import org.mockito.Mockito;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.UUID;\n+\n+import static org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos.Status.VOLUME_NOT_FOUND;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Test OM directory create request V1 layout version.\n+ */\n+public class TestOMDirectoryCreateRequestV1 {\n+\n+  @Rule\n+  public TemporaryFolder folder = new TemporaryFolder();\n+\n+  private OzoneManager ozoneManager;\n+  private OMMetrics omMetrics;\n+  private OMMetadataManager omMetadataManager;\n+  private AuditLogger auditLogger;\n+  // Just setting ozoneManagerDoubleBuffer which does nothing.\n+  private OzoneManagerDoubleBufferHelper ozoneManagerDoubleBufferHelper =\n+          ((response, transactionIndex) -> {\n+            return null;\n+          });\n+\n+  @Before\n+  public void setup() throws Exception {\n+    ozoneManager = Mockito.mock(OzoneManager.class);\n+    omMetrics = OMMetrics.create();\n+    OzoneConfiguration ozoneConfiguration = new OzoneConfiguration();\n+    ozoneConfiguration.set(OMConfigKeys.OZONE_OM_DB_DIRS,\n+            folder.newFolder().getAbsolutePath());\n+    omMetadataManager = new OmMetadataManagerImpl(ozoneConfiguration);\n+    when(ozoneManager.getMetrics()).thenReturn(omMetrics);\n+    when(ozoneManager.getMetadataManager()).thenReturn(omMetadataManager);\n+    auditLogger = Mockito.mock(AuditLogger.class);\n+    when(ozoneManager.getAuditLogger()).thenReturn(auditLogger);\n+    Mockito.doNothing().when(auditLogger).logWrite(any(AuditMessage.class));\n+    when(ozoneManager.resolveBucketLink(any(KeyArgs.class),\n+            any(OMClientRequest.class)))\n+            .thenReturn(new ResolvedBucket(Pair.of(\"\", \"\"), Pair.of(\"\", \"\")));\n+  }\n+\n+  @After\n+  public void stop() {\n+    omMetrics.unRegister();\n+    Mockito.framework().clearInlineMocks();\n+  }\n+\n+  @Test\n+  public void testPreExecute() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    String keyName = \"a/b/c\";\n+\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirectoryCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest =\n+            omDirectoryCreateRequestV1.preExecute(ozoneManager);\n+\n+    // As in preExecute, we modify original request.\n+    Assert.assertNotEquals(omRequest, modifiedOmRequest);\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCache() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long bucketID = omBucketInfo.getObjectID();\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.OK);\n+    verifyDirectoriesInDB(dirs, bucketID);\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithVolumeNotFound() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertEquals(VOLUME_NOT_FOUND,\n+            omClientResponse.getOMResponse().getStatus());\n+\n+    // Key should not exist in DB\n+    Assert.assertTrue(\"Unexpected directory entries!\",\n+            omMetadataManager.getDirectoryTable().isEmpty());\n+\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithBucketNotFound() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+    TestOMRequestUtils.addVolumeToDB(volumeName, omMetadataManager);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.BUCKET_NOT_FOUND);\n+\n+    // Key should not exist in DB\n+    Assert.assertTrue(\"Unexpected directory entries!\",\n+            omMetadataManager.getDirectoryTable().isEmpty());\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithSubDirectoryInPath()\n+          throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long bucketID = omBucketInfo.getObjectID();\n+    int objID = 100;\n+\n+    //1. Create root\n+    OmDirectoryInfo omDirInfo =\n+            TestOMRequestUtils.createOmDirectoryInfo(dirs.get(0), objID++,\n+                    bucketID);\n+    TestOMRequestUtils.addDirKeyToDirTable(true, omDirInfo, 5000,\n+            omMetadataManager);\n+    //2. Create sub-directory under root\n+    omDirInfo = TestOMRequestUtils.createOmDirectoryInfo(dirs.get(1), objID++,\n+            omDirInfo.getObjectID());\n+    TestOMRequestUtils.addDirKeyToDirTable(true, omDirInfo, 5000,\n+            omMetadataManager);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.OK);\n+\n+    // Key should exist in DB and cache.\n+    verifyDirectoriesInDB(dirs, bucketID);\n+  }\n+\n+  @Test\n+  public void testValidateAndUpdateCacheWithDirectoryAlreadyExists()\n+          throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long bucketID = omBucketInfo.getObjectID();\n+\n+    // bucketID is the parent\n+    long parentID = bucketID;\n+\n+    // add all the directories into DirectoryTable\n+    for (int indx = 0; indx < dirs.size(); indx++) {\n+      long objID = 100 + indx;\n+      long txnID = 5000 + indx;\n+      // for index=0, parentID is bucketID\n+      OmDirectoryInfo omDirInfo = TestOMRequestUtils.createOmDirectoryInfo(\n+              dirs.get(indx), objID, parentID);\n+      TestOMRequestUtils.addDirKeyToDirTable(false, omDirInfo,\n+              txnID, omMetadataManager);\n+\n+      parentID = omDirInfo.getObjectID();\n+    }\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest = omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.DIRECTORY_ALREADY_EXISTS);\n+\n+    Assert.assertEquals(\"Wrong OM numKeys metrics\",\n+            0, ozoneManager.getMetrics().getNumKeys());\n+\n+    // Key should exist in DB and doesn't added to cache.\n+    verifyDirectoriesInDB(dirs, bucketID);\n+    verifyDirectoriesNotInCache(dirs, bucketID);\n+  }\n+\n+  /**\n+   * Case: File exists with the same name as the requested directory.\n+   * Say, requested to createDir '/a/b/c' and there is a file exists with\n+   * same name.\n+   */\n+  @Test\n+  public void testValidateAndUpdateCacheWithFilesInPath() throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long parentID = omBucketInfo.getObjectID();\n+\n+    // add all the parent directories into DirectoryTable. This won't create\n+    // the leaf node and this will be used in CreateDirectoryReq.\n+    for (int indx = 0; indx < dirs.size() - 1; indx++) {\n+      long objID = 100 + indx;\n+      long txnID = 5000 + indx;\n+      // for index=0, parentID is bucketID\n+      OmDirectoryInfo omDirInfo = TestOMRequestUtils.createOmDirectoryInfo(\n+              dirs.get(indx), objID, parentID);\n+      TestOMRequestUtils.addDirKeyToDirTable(false, omDirInfo,\n+              txnID, omMetadataManager);\n+\n+      parentID = omDirInfo.getObjectID();\n+    }\n+\n+    long objID = parentID + 100;\n+    long txnID = 50000;\n+\n+    // Add a file into the FileTable, this is to simulate \"file exists\" check.\n+    OmKeyInfo omKeyInfo = TestOMRequestUtils.createOmKeyInfo(volumeName,\n+            bucketName, keyName, HddsProtos.ReplicationType.RATIS,\n+            HddsProtos.ReplicationFactor.THREE, objID++);\n+    String ozoneFileName = parentID + \"/\" + dirs.get(dirs.size() - 1);\n+    omMetadataManager.getKeyTable().addCacheEntry(new CacheKey<>(ozoneFileName),\n+            new CacheValue<>(Optional.of(omKeyInfo), ++txnID));\n+    omMetadataManager.getKeyTable().put(ozoneFileName, omKeyInfo);\n+\n+    OMRequest omRequest = createDirectoryRequest(volumeName, bucketName,\n+            keyName);\n+    OMDirectoryCreateRequestV1 omDirCreateRequestV1 =\n+            new OMDirectoryCreateRequestV1(omRequest);\n+\n+    OMRequest modifiedOmRequest =\n+            omDirCreateRequestV1.preExecute(ozoneManager);\n+\n+    omDirCreateRequestV1 = new OMDirectoryCreateRequestV1(modifiedOmRequest);\n+\n+    OMClientResponse omClientResponse =\n+            omDirCreateRequestV1.validateAndUpdateCache(ozoneManager, 100L,\n+                    ozoneManagerDoubleBufferHelper);\n+\n+    Assert.assertTrue(omClientResponse.getOMResponse().getStatus()\n+            == OzoneManagerProtocolProtos.Status.FILE_ALREADY_EXISTS);\n+\n+    Assert.assertEquals(\"Wrong OM numKeys metrics\",\n+            0, ozoneManager.getMetrics().getNumKeys());\n+\n+    // Key should not exist in DB\n+    Assert.assertNotNull(omMetadataManager.getKeyTable().get(ozoneFileName));\n+    // Key should not exist in DB\n+    Assert.assertEquals(\"Wrong directories count!\", 3,\n+            omMetadataManager.getDirectoryTable().getEstimatedKeyCount());\n+  }\n+\n+\n+  /**\n+   * Case: File exists in the given path.\n+   * Say, requested to createDir '/a/b/c/d' and there is a file '/a/b' exists\n+   * in the given path.\n+   */\n+  @Test\n+  public void testValidateAndUpdateCacheWithFileExistsInGivenPath()\n+          throws Exception {\n+    String volumeName = \"vol1\";\n+    String bucketName = \"bucket1\";\n+    List<String> dirs = new ArrayList<String>();\n+    String keyName = createDirKey(dirs);\n+\n+    // Add volume and bucket entries to DB.\n+    TestOMRequestUtils.addVolumeAndBucketToDB(volumeName, bucketName,\n+            omMetadataManager);\n+    String bucketKey = omMetadataManager.getBucketKey(volumeName, bucketName);\n+    OmBucketInfo omBucketInfo =\n+            omMetadataManager.getBucketTable().get(bucketKey);\n+    long parentID = omBucketInfo.getObjectID();\n+\n+    long objID = parentID + 100;\n+    long txnID = 5000;\n+\n+    // for index=0, parentID is bucketID\n+    OmDirectoryInfo omDirInfo = TestOMRequestUtils.createOmDirectoryInfo(\n+            dirs.get(0), objID++, parentID);\n+    TestOMRequestUtils.addDirKeyToDirTable(true, omDirInfo,\n+            txnID, omMetadataManager);\n+    parentID = omDirInfo.getObjectID();\n+\n+    // Add a key in second level.\n+    OmKeyInfo omKeyInfo = TestOMRequestUtils.createOmKeyInfo(volumeName,\n+            bucketName, keyName, HddsProtos.ReplicationType.RATIS,", "originalCommit": "72172429fb9580ac63f35427ca91d34d5fe4eaca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk1ODQwNA==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r497958404", "bodyText": "Thanks a lot for the detailed reviews.\nWith the new proposal, the key put into KeyTable will be in the new format 'parentID/fileName'. Secondly, the keyName attribute in OmKeyInfo object stores the name without vol/buck prefix part. It is like dirs.get(0)+\"/\"+dirs.get(1)+\"/\"+fileName.\nOnce HDDS-4266 changes are in, then it will be readable. Hope this is fine for you?", "author": "rakeshadr", "createdAt": "2020-10-01T03:03:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg0Mjg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk3MDM2Ng==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r497970366", "bodyText": "Yes. thanks for explanation.", "author": "bharatviswa504", "createdAt": "2020-10-01T03:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg0Mjg2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg0NzU4Mg==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r497847582", "bodyText": "For leaf, we have used baseObjID + objCount. But here it is mentioned we use baseObjID is used for leaf, assuming that it has started for missing directories from baseObjID +1.\n pathInfo.setLeafNodeObjectId(baseObjId + objectCount);\nIf we want to keep them sorted, we can start with ObjCount as 0. (Not sure, in future if this will help in the listing)\nWith this, there is a chance to exceed maxObjectID", "author": "bharatviswa504", "createdAt": "2020-09-30T23:01:53Z", "path": "hadoop-ozone/ozone-manager/src/main/java/org/apache/hadoop/ozone/om/request/file/OMDirectoryCreateRequestV1.java", "diffHunk": "@@ -0,0 +1,321 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.om.request.file;\n+\n+import com.google.common.base.Optional;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheKey;\n+import org.apache.hadoop.hdds.utils.db.cache.CacheValue;\n+import org.apache.hadoop.ozone.OzoneAcl;\n+import org.apache.hadoop.ozone.audit.AuditLogger;\n+import org.apache.hadoop.ozone.audit.OMAction;\n+import org.apache.hadoop.ozone.om.OMMetadataManager;\n+import org.apache.hadoop.ozone.om.OMMetrics;\n+import org.apache.hadoop.ozone.om.OzoneManager;\n+import org.apache.hadoop.ozone.om.exceptions.OMException;\n+import org.apache.hadoop.ozone.om.helpers.*;\n+import org.apache.hadoop.ozone.om.ratis.utils.OzoneManagerDoubleBufferHelper;\n+import org.apache.hadoop.ozone.om.request.util.OmResponseUtil;\n+import org.apache.hadoop.ozone.om.response.OMClientResponse;\n+import org.apache.hadoop.ozone.om.response.file.OMDirectoryCreateResponseV1;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .CreateDirectoryResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .KeyArgs;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMRequest;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .OMResponse;\n+import org.apache.hadoop.ozone.protocol.proto.OzoneManagerProtocolProtos\n+        .Status;\n+import org.apache.hadoop.ozone.security.acl.IAccessAuthorizer;\n+import org.apache.hadoop.ozone.security.acl.OzoneObj;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.FILE_ALREADY_EXISTS;\n+import static org.apache.hadoop.ozone.om.exceptions.OMException.ResultCodes.INVALID_KEY_NAME;\n+import static org.apache.hadoop.ozone.om.lock.OzoneManagerLock.Resource.BUCKET_LOCK;\n+import static org.apache.hadoop.ozone.om.request.file.OMFileRequest.OMDirectoryResult.*;\n+\n+/**\n+ * Handle create directory request. It will add path components to the directory\n+ * table and maintains file system semantics.\n+ */\n+public class OMDirectoryCreateRequestV1 extends OMDirectoryCreateRequest {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(OMDirectoryCreateRequestV1.class);\n+\n+  public OMDirectoryCreateRequestV1(OMRequest omRequest) {\n+    super(omRequest);\n+  }\n+\n+  @Override\n+  public OMClientResponse validateAndUpdateCache(OzoneManager ozoneManager,\n+      long trxnLogIndex, OzoneManagerDoubleBufferHelper omDoubleBufferHelper) {\n+\n+    CreateDirectoryRequest createDirectoryRequest = getOmRequest()\n+        .getCreateDirectoryRequest();\n+    KeyArgs keyArgs = createDirectoryRequest.getKeyArgs();\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+    int numKeysCreated = 0;\n+\n+    OMResponse.Builder omResponse = OmResponseUtil.getOMResponseBuilder(\n+        getOmRequest());\n+    omResponse.setCreateDirectoryResponse(CreateDirectoryResponse.newBuilder());\n+    OMMetrics omMetrics = ozoneManager.getMetrics();\n+    omMetrics.incNumCreateDirectory();\n+\n+    AuditLogger auditLogger = ozoneManager.getAuditLogger();\n+    OzoneManagerProtocolProtos.UserInfo userInfo = getOmRequest().getUserInfo();\n+\n+    Map<String, String> auditMap = buildKeyArgsAuditMap(keyArgs);\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    boolean acquiredLock = false;\n+    IOException exception = null;\n+    OMClientResponse omClientResponse = null;\n+    Result result = Result.FAILURE;\n+    List<OmDirectoryInfo> missingParentInfos;\n+\n+    try {\n+      keyArgs = resolveBucketLink(ozoneManager, keyArgs, auditMap);\n+      volumeName = keyArgs.getVolumeName();\n+      bucketName = keyArgs.getBucketName();\n+\n+      // check Acl\n+      checkKeyAcls(ozoneManager, volumeName, bucketName, keyName,\n+          IAccessAuthorizer.ACLType.CREATE, OzoneObj.ResourceType.KEY);\n+\n+      // Check if this is the root of the filesystem.\n+      if (keyName.length() == 0) {\n+        throw new OMException(\"Directory create failed. Cannot create \" +\n+            \"directory at root of the filesystem\",\n+            OMException.ResultCodes.CANNOT_CREATE_DIRECTORY_AT_ROOT);\n+      }\n+      // acquire lock\n+      acquiredLock = omMetadataManager.getLock().acquireWriteLock(BUCKET_LOCK,\n+          volumeName, bucketName);\n+\n+      validateBucketAndVolume(omMetadataManager, volumeName, bucketName);\n+\n+      Path keyPath = Paths.get(keyName);\n+\n+      // Need to check if any files exist in the given path, if they exist we\n+      // cannot create a directory with the given key.\n+      // Verify the path against directory table\n+      OMFileRequest.OMPathInfoV1 omPathInfo =\n+          OMFileRequest.verifyDirectoryKeysInPath(omMetadataManager, volumeName,\n+              bucketName, keyName, keyPath);\n+      OMFileRequest.OMDirectoryResult omDirectoryResult =\n+          omPathInfo.getDirectoryResult();\n+\n+      if (omDirectoryResult == FILE_EXISTS ||\n+          omDirectoryResult == FILE_EXISTS_IN_GIVENPATH) {\n+        throw new OMException(\"Unable to create directory: \" + keyName\n+            + \" in volume/bucket: \" + volumeName + \"/\" + bucketName + \" as \" +\n+                \"file:\" + omPathInfo.getFileExistsInPath() + \" already exists\",\n+            FILE_ALREADY_EXISTS);\n+      } else if (omDirectoryResult == DIRECTORY_EXISTS_IN_GIVENPATH ||\n+          omDirectoryResult == NONE) {\n+\n+        // prepare all missing parents\n+        missingParentInfos = OMDirectoryCreateRequestV1.getAllParentDirInfo(\n+                ozoneManager, keyArgs, omPathInfo, trxnLogIndex);\n+        // prepare leafNode dir\n+        OmDirectoryInfo dirInfo = createDirectoryInfoWithACL(\n+                omPathInfo.getLeafNodeName(),\n+                keyArgs, omPathInfo.getLeafNodeObjectId(),\n+                omPathInfo.getLastKnownParentId(), trxnLogIndex,\n+                OzoneAclUtil.fromProtobuf(keyArgs.getAclsList()));\n+        OMFileRequest.addDirectoryTableCacheEntries(omMetadataManager,\n+                Optional.of(dirInfo), Optional.of(missingParentInfos),\n+                trxnLogIndex);\n+\n+        // total number of keys created.\n+        numKeysCreated = missingParentInfos.size() + 1;\n+\n+        result = OMDirectoryCreateRequest.Result.SUCCESS;\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+                dirInfo, missingParentInfos, result);\n+      } else {\n+        result = Result.DIRECTORY_ALREADY_EXISTS;\n+        omResponse.setStatus(Status.DIRECTORY_ALREADY_EXISTS);\n+        omClientResponse = new OMDirectoryCreateResponseV1(omResponse.build(),\n+            result);\n+      }\n+    } catch (IOException ex) {\n+      exception = ex;\n+      omClientResponse = new OMDirectoryCreateResponseV1(\n+          createErrorOMResponse(omResponse, exception), result);\n+    } finally {\n+      addResponseToDoubleBuffer(trxnLogIndex, omClientResponse,\n+          omDoubleBufferHelper);\n+      if (acquiredLock) {\n+        omMetadataManager.getLock().releaseWriteLock(BUCKET_LOCK, volumeName,\n+            bucketName);\n+      }\n+    }\n+\n+    auditLog(auditLogger, buildAuditMessage(OMAction.CREATE_DIRECTORY,\n+        auditMap, exception, userInfo));\n+\n+    logResult(createDirectoryRequest, keyArgs, omMetrics, numKeysCreated,\n+            result, exception);\n+\n+    return omClientResponse;\n+  }\n+\n+  private void logResult(CreateDirectoryRequest createDirectoryRequest,\n+                         KeyArgs keyArgs, OMMetrics omMetrics, int numKeys,\n+                         Result result,\n+                         IOException exception) {\n+\n+    String volumeName = keyArgs.getVolumeName();\n+    String bucketName = keyArgs.getBucketName();\n+    String keyName = keyArgs.getKeyName();\n+\n+    switch (result) {\n+    case SUCCESS:\n+      omMetrics.incNumKeys(numKeys);\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Directory created. Volume:{}, Bucket:{}, Key:{}\",\n+            volumeName, bucketName, keyName);\n+      }\n+      break;\n+    case DIRECTORY_ALREADY_EXISTS:\n+      if (LOG.isDebugEnabled()) {\n+        LOG.debug(\"Directory already exists. Volume:{}, Bucket:{}, Key{}\",\n+            volumeName, bucketName, keyName, exception);\n+      }\n+      break;\n+    case FAILURE:\n+      omMetrics.incNumCreateDirectoryFails();\n+      LOG.error(\"Directory creation failed. Volume:{}, Bucket:{}, Key{}. \" +\n+          \"Exception:{}\", volumeName, bucketName, keyName, exception);\n+      break;\n+    default:\n+      LOG.error(\"Unrecognized Result for OMDirectoryCreateRequest: {}\",\n+          createDirectoryRequest);\n+    }\n+  }\n+\n+  /**\n+   * Construct OmDirectoryInfo for every parent directory in missing list.\n+   * @param ozoneManager\n+   * @param keyArgs\n+   * @param pathInfo list of parent directories to be created and its ACLs\n+   * @param trxnLogIndex\n+   * @return\n+   * @throws IOException\n+   */\n+  public static List<OmDirectoryInfo> getAllParentDirInfo(\n+          OzoneManager ozoneManager, KeyArgs keyArgs,\n+          OMFileRequest.OMPathInfoV1 pathInfo, long trxnLogIndex)\n+          throws IOException {\n+    OMMetadataManager omMetadataManager = ozoneManager.getMetadataManager();\n+    List<OmDirectoryInfo> missingParentInfos = new ArrayList<>();\n+\n+    ImmutablePair<Long, Long> objIdRange = OMFileRequest\n+            .getObjIdRangeFromTxId(trxnLogIndex);\n+    long baseObjId = objIdRange.getLeft();\n+    long maxObjId = objIdRange.getRight();\n+    long maxLevels = maxObjId - baseObjId;\n+    long objectCount = 1; // baseObjID is used by the leaf directory", "originalCommit": "72172429fb9580ac63f35427ca91d34d5fe4eaca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk2MTk1Ng==", "url": "https://github.com/apache/ozone/pull/1404#discussion_r497961956", "bodyText": "Good point. I've used existing logic from code OMDirectoryCreateRequest#254.\nI will add two more UTs to verify it. Also, I will remove the wrong comment. Hope this is fine?\n\ntestCreateDirectoryExceedLimitOfMaxLevels255\ntestCreateDirectoryUptoLimitOfMaxLevels255\n\nSay,    baseObjId = 25600\n        maxObjId  = 25855\n        maxLevels = 25855 - 25600 = 255\nSince the exit condition is \"if (nextObjId > maxObjId)\", it will exit and throw exception once\nthe value of nextObjId becomes 25856, which will be used for the leaf node.", "author": "rakeshadr", "createdAt": "2020-10-01T03:20:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg0NzU4Mg=="}], "type": "inlineReview"}, {"oid": "96a750b7ba25c980416654f8e0ca226c8f2a1bb3", "url": "https://github.com/apache/ozone/commit/96a750b7ba25c980416654f8e0ca226c8f2a1bb3", "message": "Fixed review comments - added UTs and removed duplicated calls", "committedDate": "2020-10-01T03:26:25Z", "type": "commit"}, {"oid": "9c6e3f9cae97050939e8165bb85509af4d401d9a", "url": "https://github.com/apache/ozone/commit/9c6e3f9cae97050939e8165bb85509af4d401d9a", "message": "Fixed checkstyle warning - unused imports", "committedDate": "2020-10-01T04:11:46Z", "type": "commit"}]}