{"pr_number": 994, "pr_title": "HDDS-3082. Refactor recon missing containers task to detect under, over and mis-replicated containers.", "pr_createdAt": "2020-05-29T16:24:15Z", "pr_url": "https://github.com/apache/ozone/pull/994", "timeline": [{"oid": "a4a2668975a63f0e8a71dbf7d257ef52274f73e8", "url": "https://github.com/apache/ozone/commit/a4a2668975a63f0e8a71dbf7d257ef52274f73e8", "message": "Implement new ContainerHealthTask", "committedDate": "2020-05-29T16:14:00Z", "type": "commit"}, {"oid": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482", "url": "https://github.com/apache/ozone/commit/6765db0f7a345ecc0a6cf7645ff0199c0cd95482", "message": "Fix style issue", "committedDate": "2020-05-29T16:32:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4NjUzNw==", "url": "https://github.com/apache/ozone/pull/994#discussion_r432686537", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n          \n          \n            \n                    LOG.info(\"Container Health task thread took {} milliseconds to\" +", "author": "vivekratnavel", "createdAt": "2020-05-29T19:19:12Z", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +", "originalCommit": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2MDgxMw==", "url": "https://github.com/apache/ozone/pull/994#discussion_r433160813", "bodyText": "Well spotted. I have fixed this.", "author": "sodonnel", "createdAt": "2020-06-01T10:36:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4NjUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4NjczOA==", "url": "https://github.com/apache/ozone/pull/994#discussion_r432686738", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n          \n          \n            \n                    LOG.info(\"Container Health task thread took {} milliseconds for\" +", "author": "vivekratnavel", "createdAt": "2020-05-29T19:19:43Z", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +", "originalCommit": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2MDg3MQ==", "url": "https://github.com/apache/ozone/pull/994#discussion_r433160871", "bodyText": "Well spotted. I have fixed this.", "author": "sodonnel", "createdAt": "2020-06-01T10:36:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4NjczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4OTgxNA==", "url": "https://github.com/apache/ozone/pull/994#discussion_r432689814", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  LOG.error(\"Container not found while finding missing containers\", e);\n          \n          \n            \n                  LOG.error(\"Container not found while processing container in Container Health task\", e);", "author": "vivekratnavel", "createdAt": "2020-05-29T19:26:57Z", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {\n+    long recordCount = 0;\n+    try (Cursor<UnhealthyContainersRecord> cursor =\n+             containerSchemaManager.getAllUnhealthyRecordsCursor()) {\n+      ContainerHealthStatus currentContainer = null;\n+      Set<String> existingRecords = new HashSet<>();\n+      while(cursor.hasNext()) {\n+        recordCount++;\n+        UnhealthyContainersRecord rec = cursor.fetchNext();\n+        try {\n+          if (currentContainer == null\n+              || currentContainer.getContainerID() != rec.getContainerId()) {\n+            completeProcessingContainer(\n+                currentContainer, existingRecords, currentTime);\n+            existingRecords.clear();\n+            currentContainer = setCurrentContainer(rec.getContainerId());\n+          }\n+          if (ContainerHealthRecords\n+              .retainOrUpdateRecord(currentContainer, rec)) {\n+            existingRecords.add(rec.getContainerState());\n+            if (rec.changed()) {\n+              rec.update();\n+            }\n+          } else {\n+            rec.delete();\n+          }\n+        } catch (ContainerNotFoundException cnf) {\n+          rec.delete();\n+          currentContainer = null;\n+        }\n+      }\n+      // Remember to finish processing the last container\n+      completeProcessingContainer(\n+          currentContainer, existingRecords, currentTime);\n+    }\n+    return recordCount;\n+  }\n+\n+  private void processContainer(ContainerInfo container, long currentTime) {\n+    try {\n+      if (processedContainers.contains(container)) {\n+        // Was already handled when processing the existing DB records, so skip\n+        return;\n+      }\n+      Set<ContainerReplica> containerReplicas =\n+          containerManager.getContainerReplicas(container.containerID());\n+      ContainerHealthStatus h = new ContainerHealthStatus(\n+          container, containerReplicas, placementPolicy);\n+      if (h.isHealthy()) {\n+        return;\n+      }\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(h, currentTime));\n+    } catch (ContainerNotFoundException e) {\n+      LOG.error(\"Container not found while finding missing containers\", e);", "originalCommit": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2MTMyMg==", "url": "https://github.com/apache/ozone/pull/994#discussion_r433161322", "bodyText": "Fixed.", "author": "sodonnel", "createdAt": "2020-06-01T10:37:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY4OTgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5MjM0Nw==", "url": "https://github.com/apache/ozone/pull/994#discussion_r432692347", "bodyText": "Can you please add JavaDoc for this method?", "author": "vivekratnavel", "createdAt": "2020-05-29T19:32:48Z", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {\n+    long recordCount = 0;\n+    try (Cursor<UnhealthyContainersRecord> cursor =\n+             containerSchemaManager.getAllUnhealthyRecordsCursor()) {\n+      ContainerHealthStatus currentContainer = null;\n+      Set<String> existingRecords = new HashSet<>();\n+      while(cursor.hasNext()) {\n+        recordCount++;\n+        UnhealthyContainersRecord rec = cursor.fetchNext();\n+        try {\n+          if (currentContainer == null\n+              || currentContainer.getContainerID() != rec.getContainerId()) {\n+            completeProcessingContainer(\n+                currentContainer, existingRecords, currentTime);\n+            existingRecords.clear();\n+            currentContainer = setCurrentContainer(rec.getContainerId());\n+          }\n+          if (ContainerHealthRecords\n+              .retainOrUpdateRecord(currentContainer, rec)) {\n+            existingRecords.add(rec.getContainerState());\n+            if (rec.changed()) {\n+              rec.update();\n+            }\n+          } else {\n+            rec.delete();\n+          }\n+        } catch (ContainerNotFoundException cnf) {\n+          rec.delete();\n+          currentContainer = null;\n+        }\n+      }\n+      // Remember to finish processing the last container\n+      completeProcessingContainer(\n+          currentContainer, existingRecords, currentTime);\n+    }\n+    return recordCount;\n+  }\n+\n+  private void processContainer(ContainerInfo container, long currentTime) {\n+    try {\n+      if (processedContainers.contains(container)) {\n+        // Was already handled when processing the existing DB records, so skip\n+        return;\n+      }\n+      Set<ContainerReplica> containerReplicas =\n+          containerManager.getContainerReplicas(container.containerID());\n+      ContainerHealthStatus h = new ContainerHealthStatus(\n+          container, containerReplicas, placementPolicy);\n+      if (h.isHealthy()) {\n+        return;\n+      }\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(h, currentTime));\n+    } catch (ContainerNotFoundException e) {\n+      LOG.error(\"Container not found while finding missing containers\", e);\n+    }\n+  }\n+\n+  /**\n+   * Helper methods to generate and update the required database records for\n+   * unhealthy containers.\n+   */\n+  static public class ContainerHealthRecords {\n+\n+    static public boolean retainOrUpdateRecord(", "originalCommit": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2NDIzMg==", "url": "https://github.com/apache/ozone/pull/994#discussion_r433164232", "bodyText": "Done.", "author": "sodonnel", "createdAt": "2020-06-01T10:45:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5MjM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5MzQwMQ==", "url": "https://github.com/apache/ozone/pull/994#discussion_r432693401", "bodyText": "Please fix the dangling statement", "author": "vivekratnavel", "createdAt": "2020-05-29T19:35:19Z", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {\n+    long recordCount = 0;\n+    try (Cursor<UnhealthyContainersRecord> cursor =\n+             containerSchemaManager.getAllUnhealthyRecordsCursor()) {\n+      ContainerHealthStatus currentContainer = null;\n+      Set<String> existingRecords = new HashSet<>();\n+      while(cursor.hasNext()) {\n+        recordCount++;\n+        UnhealthyContainersRecord rec = cursor.fetchNext();\n+        try {\n+          if (currentContainer == null\n+              || currentContainer.getContainerID() != rec.getContainerId()) {\n+            completeProcessingContainer(\n+                currentContainer, existingRecords, currentTime);\n+            existingRecords.clear();\n+            currentContainer = setCurrentContainer(rec.getContainerId());\n+          }\n+          if (ContainerHealthRecords\n+              .retainOrUpdateRecord(currentContainer, rec)) {\n+            existingRecords.add(rec.getContainerState());\n+            if (rec.changed()) {\n+              rec.update();\n+            }\n+          } else {\n+            rec.delete();\n+          }\n+        } catch (ContainerNotFoundException cnf) {\n+          rec.delete();\n+          currentContainer = null;\n+        }\n+      }\n+      // Remember to finish processing the last container\n+      completeProcessingContainer(\n+          currentContainer, existingRecords, currentTime);\n+    }\n+    return recordCount;\n+  }\n+\n+  private void processContainer(ContainerInfo container, long currentTime) {\n+    try {\n+      if (processedContainers.contains(container)) {\n+        // Was already handled when processing the existing DB records, so skip\n+        return;\n+      }\n+      Set<ContainerReplica> containerReplicas =\n+          containerManager.getContainerReplicas(container.containerID());\n+      ContainerHealthStatus h = new ContainerHealthStatus(\n+          container, containerReplicas, placementPolicy);\n+      if (h.isHealthy()) {\n+        return;\n+      }\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(h, currentTime));\n+    } catch (ContainerNotFoundException e) {\n+      LOG.error(\"Container not found while finding missing containers\", e);\n+    }\n+  }\n+\n+  /**\n+   * Helper methods to generate and update the required database records for\n+   * unhealthy containers.\n+   */\n+  static public class ContainerHealthRecords {\n+\n+    static public boolean retainOrUpdateRecord(\n+        ContainerHealthStatus container, UnhealthyContainersRecord rec) {\n+      boolean returnValue = false;\n+      switch(UnHealthyContainerStates.valueOf(rec.getContainerState())) {\n+      case MISSING:\n+        returnValue = container.isMissing();\n+        break;\n+      case MIS_REPLICATED:\n+        returnValue = keepMisReplicatedRecord(container, rec);\n+        break;\n+      case UNDER_REPLICATED:\n+        returnValue = keepUnderReplicatedRecord(container, rec);\n+        break;\n+      case OVER_REPLICATED:\n+        returnValue = keepOverReplicatedRecord(container, rec);\n+        break;\n+      default:\n+        returnValue = false;\n+      }\n+      return returnValue;\n+    }\n+\n+    static public List<UnhealthyContainers> generateUnhealthyRecords(\n+        ContainerHealthStatus container, long time) {\n+      return generateUnhealthyRecords(container, new HashSet<>(), time);\n+    }\n+\n+    /**\n+     * Check the status of the container and generate any database records that\n+     * need to be recorded. This method also considers the records seen by the\n+     * method retainOrUpdateRecord. If a record has been seen by that method\n+     * then it will not be emitted here. Therefore this method returns only the\n+     * missing records which have not been seen already.\n+     * @return List of UnhealthyContainer records to be stored in the DB\n+     */\n+    static public List<UnhealthyContainers> generateUnhealthyRecords(\n+        ContainerHealthStatus container, Set<String> recordForStateExists,\n+        long time) {\n+      List<UnhealthyContainers> records = new ArrayList<>();\n+      if (container.isHealthy()) {\n+        return records;\n+      }\n+\n+      if (container.isMissing()\n+          && !recordForStateExists.contains(\n+              UnHealthyContainerStates.MISSING.toString())) {\n+        records.add(\n+            recordForState(container, UnHealthyContainerStates.MISSING, time));\n+      }\n+\n+      if (container.isUnderReplicated()\n+          && !recordForStateExists.contains(\n+              UnHealthyContainerStates.UNDER_REPLICATED.toString())) {\n+        records.add(recordForState(\n+            container, UnHealthyContainerStates.UNDER_REPLICATED, time));\n+      }\n+\n+      if (container.isOverReplicated()\n+          && !recordForStateExists.contains(\n+              UnHealthyContainerStates.OVER_REPLICATED.toString())) {\n+        records.add(recordForState(\n+            container, UnHealthyContainerStates.OVER_REPLICATED, time));\n+      }\n+\n+      if (container.isMisReplicated()\n+          && !recordForStateExists.contains(\n+              UnHealthyContainerStates.MIS_REPLICATED.toString())) {\n+        records.add(recordForState(\n+            container, UnHealthyContainerStates.MIS_REPLICATED, time));\n+      }\n+      return records;\n+    }\n+\n+    static private UnhealthyContainers recordForState(\n+        ContainerHealthStatus container, UnHealthyContainerStates state,\n+        long time) {\n+      UnhealthyContainers rec = new UnhealthyContainers();\n+      rec.setContainerId(container.getContainerID());\n+      if (state == UnHealthyContainerStates.MIS_REPLICATED) {\n+        rec.setExpectedReplicaCount(container.expectedPlacementCount());\n+        rec.setActualReplicaCount(container.actualPlacementCount());\n+        rec.setReplicaDelta(container.misReplicatedDelta());\n+        rec.setReason(container.misReplicatedReason());\n+      } else {\n+        rec.setExpectedReplicaCount(container.getReplicationFactor());\n+        rec.setActualReplicaCount(container.getReplicaCount());\n+        rec.setReplicaDelta(container.replicaDelta());\n+      }\n+      rec.setContainerState(state.toString());\n+      rec.setInStateSince(time);\n+      return rec;\n+    }\n+\n+    static private boolean keepOverReplicatedRecord(\n+        ContainerHealthStatus container, UnhealthyContainersRecord rec) {\n+      if (container.isOverReplicated()) {\n+        updateExpectedReplicaCount(rec, container.getReplicationFactor());\n+        updateActualReplicaCount(rec, container.getReplicaCount());\n+        updateReplicaDelta(rec, container.replicaDelta());\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    static private boolean keepUnderReplicatedRecord(\n+        ContainerHealthStatus container, UnhealthyContainersRecord rec) {\n+      if (container.isUnderReplicated()) {\n+        updateExpectedReplicaCount(rec, container.getReplicationFactor());\n+        updateActualReplicaCount(rec, container.getReplicaCount());\n+        updateReplicaDelta(rec, container.replicaDelta());\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    static private boolean keepMisReplicatedRecord(\n+        ContainerHealthStatus container, UnhealthyContainersRecord rec) {\n+      if (container.isMisReplicated()) {\n+        updateExpectedReplicaCount(rec, container.expectedPlacementCount());\n+        updateActualReplicaCount(rec, container.actualPlacementCount());\n+        updateReplicaDelta(rec, container.misReplicatedDelta());\n+        updateReason(rec, container.misReplicatedReason());\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    /**\n+     * With a Jooq record, if you update any field in the record, the record\n+     * is marked as changed, even if you updated it to the same value as it is\n+     * already set to. We only need to run a DB update statement if the record\n+     * has really changed. The methods below ensure we do not update the Jooq\n+     * record unless the values have changed and hence save a DB execution\n+     * when", "originalCommit": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2NDM3NA==", "url": "https://github.com/apache/ozone/pull/994#discussion_r433164374", "bodyText": "Fixed.", "author": "sodonnel", "createdAt": "2020-06-01T10:45:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5MzQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5NTExNQ==", "url": "https://github.com/apache/ozone/pull/994#discussion_r432695115", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Test to ensure the correct container state is return by a\n          \n          \n            \n             * ContainerHealthyStatus instance.\n          \n          \n            \n             * Test to ensure the correct container state is returned by a\n          \n          \n            \n             * ContainerHealthStatus instance.", "author": "vivekratnavel", "createdAt": "2020-05-29T19:38:22Z", "path": "hadoop-ozone/recon/src/test/java/org/apache/hadoop/ozone/recon/fsck/TestContainerHealthStatus.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import org.apache.hadoop.hdds.protocol.MockDatanodeDetails;\n+import org.apache.hadoop.hdds.protocol.proto.HddsProtos;\n+import org.apache.hadoop.hdds.protocol.proto.StorageContainerDatanodeProtocolProtos.ContainerReplicaProto;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.hdds.scm.container.placement.algorithms.ContainerPlacementStatusDefault;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import static junit.framework.TestCase.assertEquals;\n+import static junit.framework.TestCase.assertTrue;\n+import static org.junit.Assert.assertFalse;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Test to ensure the correct container state is return by a\n+ * ContainerHealthyStatus instance.", "originalCommit": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2NDcyMg==", "url": "https://github.com/apache/ozone/pull/994#discussion_r433164722", "bodyText": "Fixed.", "author": "sodonnel", "createdAt": "2020-06-01T10:46:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5NTExNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5NjA5MA==", "url": "https://github.com/apache/ozone/pull/994#discussion_r432696090", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * Class to test single run of Missing Container Task.\n          \n          \n            \n             * Class to test single run of Container Health Task.", "author": "vivekratnavel", "createdAt": "2020-05-29T19:39:43Z", "path": "hadoop-ozone/recon/src/test/java/org/apache/hadoop/ozone/recon/fsck/TestContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,280 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import static junit.framework.TestCase.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.UUID;\n+\n+import org.apache.hadoop.hdds.protocol.DatanodeDetails;\n+import org.apache.hadoop.hdds.protocol.MockDatanodeDetails;\n+import org.apache.hadoop.hdds.protocol.proto.HddsProtos;\n+import org.apache.hadoop.hdds.protocol.proto.StorageContainerDatanodeProtocolProtos.ContainerReplicaProto.State;\n+import org.apache.hadoop.hdds.scm.ContainerPlacementStatus;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.hdds.scm.container.placement.algorithms.ContainerPlacementStatusDefault;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconStorageContainerManagerFacade;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.test.LambdaTestUtils;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition;\n+import org.hadoop.ozone.recon.schema.tables.daos.ContainerHistoryDao;\n+import org.apache.hadoop.ozone.recon.persistence.AbstractReconSqlDBTest;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.daos.UnhealthyContainersDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.ReconTaskStatus;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Class to test single run of Missing Container Task.", "originalCommit": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2NDk5OA==", "url": "https://github.com/apache/ozone/pull/994#discussion_r433164998", "bodyText": "Fixed.", "author": "sodonnel", "createdAt": "2020-06-01T10:46:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjY5NjA5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4MzM2NQ==", "url": "https://github.com/apache/ozone/pull/994#discussion_r432783365", "bodyText": "Nit. It would be good to add Javadoc for this method since it is doing some complex operations.", "author": "avijayanhwx", "createdAt": "2020-05-29T23:39:56Z", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {", "originalCommit": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE2ODMwMg==", "url": "https://github.com/apache/ozone/pull/994#discussion_r433168302", "bodyText": "Done.", "author": "sodonnel", "createdAt": "2020-06-01T10:55:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4MzM2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4NTE3Mw==", "url": "https://github.com/apache/ozone/pull/994#discussion_r432785173", "bodyText": "Can add .filter(c -> !processedContainers.contains(c)) here instead of adding a check inside the processContainer method.", "author": "avijayanhwx", "createdAt": "2020-05-29T23:49:40Z", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->", "originalCommit": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3MDY4NQ==", "url": "https://github.com/apache/ozone/pull/994#discussion_r433170685", "bodyText": "Good idea. I have changed this.", "author": "sodonnel", "createdAt": "2020-06-01T11:01:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4NTE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4NTk5OA==", "url": "https://github.com/apache/ozone/pull/994#discussion_r432785998", "bodyText": "I am wondering why this check is not written like\nif (currentContainer != null && currentContainer.getContainerID() != rec.getContainerId()) {\nIn Line #145, we can remove the 'currentContainer = null'.", "author": "avijayanhwx", "createdAt": "2020-05-29T23:53:51Z", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {\n+    long recordCount = 0;\n+    try (Cursor<UnhealthyContainersRecord> cursor =\n+             containerSchemaManager.getAllUnhealthyRecordsCursor()) {\n+      ContainerHealthStatus currentContainer = null;\n+      Set<String> existingRecords = new HashSet<>();\n+      while(cursor.hasNext()) {\n+        recordCount++;\n+        UnhealthyContainersRecord rec = cursor.fetchNext();\n+        try {\n+          if (currentContainer == null", "originalCommit": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3Nzk0Mw==", "url": "https://github.com/apache/ozone/pull/994#discussion_r433177943", "bodyText": "On the first pass through, currentContainer will be null, so we cannot called currentContainer.getContainerID() on it, so I think we need the null check.\nIf could be changed to something like:\nif (container == null) {\n  currentContainer = setCurrentContainer(rec.getContainerId());\n} else if (currentContainer.getContainerID() != rec.getContainerId()) {\n  completeProcessingContainer(currentContainer, existingRecords, currentTime);\n  existingRecords.clear(); \n  currentContainer = setCurrentContainer(rec.getContainerId());\n}\n\nI am not sure that is much better though.\nWe will also still need a null check in completeProcessingContainer or around the call to it, to handle the case where there are no containers processed in the cursor.", "author": "sodonnel", "createdAt": "2020-06-01T11:19:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4NTk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5MzYwOQ==", "url": "https://github.com/apache/ozone/pull/994#discussion_r432793609", "bodyText": "Can we add an 'else' after the isMissing() check? A missing container cannot be in any other state right?", "author": "avijayanhwx", "createdAt": "2020-05-30T00:48:24Z", "path": "hadoop-ozone/recon/src/main/java/org/apache/hadoop/ozone/recon/fsck/ContainerHealthTask.java", "diffHunk": "@@ -0,0 +1,345 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ * <p>\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * <p>\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hadoop.ozone.recon.fsck;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.hadoop.hdds.scm.PlacementPolicy;\n+import org.apache.hadoop.hdds.scm.container.ContainerID;\n+import org.apache.hadoop.hdds.scm.container.ContainerInfo;\n+import org.apache.hadoop.hdds.scm.container.ContainerManager;\n+import org.apache.hadoop.hdds.scm.container.ContainerNotFoundException;\n+import org.apache.hadoop.hdds.scm.container.ContainerReplica;\n+import org.apache.hadoop.ozone.recon.persistence.ContainerSchemaManager;\n+import org.apache.hadoop.ozone.recon.scm.ReconScmTask;\n+import org.apache.hadoop.ozone.recon.tasks.ReconTaskConfig;\n+import org.apache.hadoop.util.Time;\n+import org.hadoop.ozone.recon.schema.ContainerSchemaDefinition.UnHealthyContainerStates;\n+import org.hadoop.ozone.recon.schema.tables.daos.ReconTaskStatusDao;\n+import org.hadoop.ozone.recon.schema.tables.pojos.UnhealthyContainers;\n+import org.hadoop.ozone.recon.schema.tables.records.UnhealthyContainersRecord;\n+import org.jooq.Cursor;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Class that scans the list of containers and keeps track of containers with\n+ * no replicas in a SQL table.\n+ */\n+public class ContainerHealthTask extends ReconScmTask {\n+\n+  private static final Logger LOG =\n+      LoggerFactory.getLogger(ContainerHealthTask.class);\n+\n+  private ContainerManager containerManager;\n+  private ContainerSchemaManager containerSchemaManager;\n+  private PlacementPolicy placementPolicy;\n+  private final long interval;\n+  private Set<ContainerInfo> processedContainers = new HashSet<>();\n+\n+  public ContainerHealthTask(\n+      ContainerManager containerManager,\n+      ReconTaskStatusDao reconTaskStatusDao,\n+      ContainerSchemaManager containerSchemaManager,\n+      PlacementPolicy placementPolicy,\n+      ReconTaskConfig reconTaskConfig) {\n+    super(reconTaskStatusDao);\n+    this.containerSchemaManager = containerSchemaManager;\n+    this.placementPolicy = placementPolicy;\n+    this.containerManager = containerManager;\n+    this.interval = TimeUnit.SECONDS.toMillis(\n+        reconTaskConfig.getMissingContainerTaskInterval());\n+  }\n+\n+  public synchronized void run() {\n+    try {\n+      while (canRun()) {\n+        long start = Time.monotonicNow();\n+        long currentTime = System.currentTimeMillis();\n+        long existingCount = processExistingDBRecords(currentTime);\n+        LOG.info(\"Missing Container task thread took {} milliseconds to\" +\n+                \" process {} existing database records.\",\n+            Time.monotonicNow() - start, existingCount);\n+        start = Time.monotonicNow();\n+        final List<ContainerInfo> containers = containerManager.getContainers();\n+        containers.forEach(container ->\n+            processContainer(container, currentTime));\n+        recordSingleRunCompletion();\n+        LOG.info(\"Missing Container task Thread took {} milliseconds for\" +\n+                \" processing {} containers.\", Time.monotonicNow() - start,\n+            containers.size());\n+        processedContainers.clear();\n+        wait(interval);\n+      }\n+    } catch (Throwable t) {\n+      LOG.error(\"Exception in Missing Container task Thread.\", t);\n+    }\n+  }\n+\n+  private ContainerHealthStatus setCurrentContainer(long recordId)\n+      throws ContainerNotFoundException {\n+    ContainerInfo container =\n+        containerManager.getContainer(new ContainerID(recordId));\n+    Set<ContainerReplica> replicas =\n+        containerManager.getContainerReplicas(container.containerID());\n+    return new ContainerHealthStatus(container, replicas, placementPolicy);\n+  }\n+\n+  private void completeProcessingContainer(ContainerHealthStatus container,\n+      Set<String> existingRecords, long currentTime) {\n+    if (container != null) {\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(\n+              container, existingRecords, currentTime));\n+      processedContainers.add(container.getContainer());\n+    }\n+  }\n+\n+  private long processExistingDBRecords(long currentTime) {\n+    long recordCount = 0;\n+    try (Cursor<UnhealthyContainersRecord> cursor =\n+             containerSchemaManager.getAllUnhealthyRecordsCursor()) {\n+      ContainerHealthStatus currentContainer = null;\n+      Set<String> existingRecords = new HashSet<>();\n+      while(cursor.hasNext()) {\n+        recordCount++;\n+        UnhealthyContainersRecord rec = cursor.fetchNext();\n+        try {\n+          if (currentContainer == null\n+              || currentContainer.getContainerID() != rec.getContainerId()) {\n+            completeProcessingContainer(\n+                currentContainer, existingRecords, currentTime);\n+            existingRecords.clear();\n+            currentContainer = setCurrentContainer(rec.getContainerId());\n+          }\n+          if (ContainerHealthRecords\n+              .retainOrUpdateRecord(currentContainer, rec)) {\n+            existingRecords.add(rec.getContainerState());\n+            if (rec.changed()) {\n+              rec.update();\n+            }\n+          } else {\n+            rec.delete();\n+          }\n+        } catch (ContainerNotFoundException cnf) {\n+          rec.delete();\n+          currentContainer = null;\n+        }\n+      }\n+      // Remember to finish processing the last container\n+      completeProcessingContainer(\n+          currentContainer, existingRecords, currentTime);\n+    }\n+    return recordCount;\n+  }\n+\n+  private void processContainer(ContainerInfo container, long currentTime) {\n+    try {\n+      if (processedContainers.contains(container)) {\n+        // Was already handled when processing the existing DB records, so skip\n+        return;\n+      }\n+      Set<ContainerReplica> containerReplicas =\n+          containerManager.getContainerReplicas(container.containerID());\n+      ContainerHealthStatus h = new ContainerHealthStatus(\n+          container, containerReplicas, placementPolicy);\n+      if (h.isHealthy()) {\n+        return;\n+      }\n+      containerSchemaManager.insertUnhealthyContainerRecords(\n+          ContainerHealthRecords.generateUnhealthyRecords(h, currentTime));\n+    } catch (ContainerNotFoundException e) {\n+      LOG.error(\"Container not found while finding missing containers\", e);\n+    }\n+  }\n+\n+  /**\n+   * Helper methods to generate and update the required database records for\n+   * unhealthy containers.\n+   */\n+  static public class ContainerHealthRecords {\n+\n+    static public boolean retainOrUpdateRecord(\n+        ContainerHealthStatus container, UnhealthyContainersRecord rec) {\n+      boolean returnValue = false;\n+      switch(UnHealthyContainerStates.valueOf(rec.getContainerState())) {\n+      case MISSING:\n+        returnValue = container.isMissing();\n+        break;\n+      case MIS_REPLICATED:\n+        returnValue = keepMisReplicatedRecord(container, rec);\n+        break;\n+      case UNDER_REPLICATED:\n+        returnValue = keepUnderReplicatedRecord(container, rec);\n+        break;\n+      case OVER_REPLICATED:\n+        returnValue = keepOverReplicatedRecord(container, rec);\n+        break;\n+      default:\n+        returnValue = false;\n+      }\n+      return returnValue;\n+    }\n+\n+    static public List<UnhealthyContainers> generateUnhealthyRecords(\n+        ContainerHealthStatus container, long time) {\n+      return generateUnhealthyRecords(container, new HashSet<>(), time);\n+    }\n+\n+    /**\n+     * Check the status of the container and generate any database records that\n+     * need to be recorded. This method also considers the records seen by the\n+     * method retainOrUpdateRecord. If a record has been seen by that method\n+     * then it will not be emitted here. Therefore this method returns only the\n+     * missing records which have not been seen already.\n+     * @return List of UnhealthyContainer records to be stored in the DB\n+     */\n+    static public List<UnhealthyContainers> generateUnhealthyRecords(\n+        ContainerHealthStatus container, Set<String> recordForStateExists,\n+        long time) {\n+      List<UnhealthyContainers> records = new ArrayList<>();\n+      if (container.isHealthy()) {\n+        return records;\n+      }\n+\n+      if (container.isMissing()\n+          && !recordForStateExists.contains(\n+              UnHealthyContainerStates.MISSING.toString())) {\n+        records.add(\n+            recordForState(container, UnHealthyContainerStates.MISSING, time));\n+      }\n+\n+      if (container.isUnderReplicated()", "originalCommit": "6765db0f7a345ecc0a6cf7645ff0199c0cd95482", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzE3NDE1Mg==", "url": "https://github.com/apache/ozone/pull/994#discussion_r433174152", "bodyText": "You are correct. Rather than next the rest of the method in the else block, I added a return statement in the missing branch. Does that look ok?", "author": "sodonnel", "createdAt": "2020-06-01T11:09:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5MzYwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzQ4MTM5Mg==", "url": "https://github.com/apache/ozone/pull/994#discussion_r433481392", "bodyText": "+1", "author": "avijayanhwx", "createdAt": "2020-06-01T20:48:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5MzYwOQ=="}], "type": "inlineReview"}, {"oid": "1473d03d7d47e40a6189e980cbdc937bc1a08d90", "url": "https://github.com/apache/ozone/commit/1473d03d7d47e40a6189e980cbdc937bc1a08d90", "message": "Address review comments", "committedDate": "2020-06-01T12:06:47Z", "type": "commit"}, {"oid": "20bffd9330dadc8824c6402ea08ab7d712c2e4f0", "url": "https://github.com/apache/ozone/commit/20bffd9330dadc8824c6402ea08ab7d712c2e4f0", "message": "Trigger CI checks", "committedDate": "2020-06-01T13:26:01Z", "type": "commit"}, {"oid": "1c52fd149762852aa54513330c3c9742e6658c4f", "url": "https://github.com/apache/ozone/commit/1c52fd149762852aa54513330c3c9742e6658c4f", "message": "Trigger CI checks", "committedDate": "2020-06-01T15:11:41Z", "type": "commit"}, {"oid": "d9d7e9e6208bc5c5c84075f9e6bd3c27cbaab10a", "url": "https://github.com/apache/ozone/commit/d9d7e9e6208bc5c5c84075f9e6bd3c27cbaab10a", "message": "Refactor code to avoid passing null containers", "committedDate": "2020-06-02T18:32:39Z", "type": "commit"}]}