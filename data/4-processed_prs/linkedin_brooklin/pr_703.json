{"pr_number": 703, "pr_title": "Fix Connector task cleanup, when leader coordinator thread gets interrupted.", "pr_createdAt": "2020-04-16T07:06:20Z", "pr_url": "https://github.com/linkedin/brooklin/pull/703", "timeline": [{"oid": "c31cd4a15cc8dd69b0a653dbe4201de934ea6d65", "url": "https://github.com/linkedin/brooklin/commit/c31cd4a15cc8dd69b0a653dbe4201de934ea6d65", "message": "Merge pull request #1 from linkedin/master\n\nPull latest", "committedDate": "2019-11-18T20:06:44Z", "type": "commit"}, {"oid": "6a4c33f184c68f793fbfdbde825a0868e79277cb", "url": "https://github.com/linkedin/brooklin/commit/6a4c33f184c68f793fbfdbde825a0868e79277cb", "message": "Merge branch 'master' of github.com:linkedin/brooklin into HEAD", "committedDate": "2020-04-16T03:27:48Z", "type": "commit"}, {"oid": "f3aa084698c8c83239079da26f1c52da67b134b2", "url": "https://github.com/linkedin/brooklin/commit/f3aa084698c8c83239079da26f1c52da67b134b2", "message": "Fix Connector task cleanup, when leader coordinator thread gets interrupted", "committedDate": "2020-04-16T06:47:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5ODcwNQ==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r409698705", "bodyText": "I see here that this walks the remaining unusedTasks and deletes them from under the /connectorconnector name/ path. The previous step also removes tasks from the same /connector/connector name/ path. Can you add a comment explaining why we need this second step so that the problem this solves is clear to someone reading this code?", "author": "somandal", "createdAt": "2020-04-16T16:41:49Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/Coordinator.java", "diffHunk": "@@ -998,8 +998,10 @@ private void handleLeaderDoAssignment(boolean cleanUpOrphanConnectorTasks) {\n     if (succeeded) {\n       List<String> instances = new ArrayList<>(liveInstances);\n       instances.add(PAUSED_INSTANCE);\n-      _adapter.cleanupDeadInstanceAssignments(instances);\n-      _adapter.cleanupOldUnusedTasks(previousAssignmentByInstance, newAssignmentsByInstance);\n+      Set<DatastreamTask> unusedTasks = _adapter.findOldUnusedTasks(previousAssignmentByInstance,\n+          newAssignmentsByInstance);\n+      _adapter.cleanupDeadInstanceAssignments(instances, unusedTasks);\n+      _adapter.cleanupOldUnusedTasks(unusedTasks);", "originalCommit": "f3aa084698c8c83239079da26f1c52da67b134b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwMjQzNQ==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r409702435", "bodyText": "Can you update the java docs to explain that it removes both the task under the instance and the connector. Explain why it needs to do this.\nAlso, do we want to rename this function to indicate it cleans up under /instances and /connector/connectorName?", "author": "somandal", "createdAt": "2020-04-16T16:47:31Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -850,13 +846,36 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n+  public void cleanupDeadInstanceAssignments(List<String> instances, Set<DatastreamTask> unusedTasks) {", "originalCommit": "f3aa084698c8c83239079da26f1c52da67b134b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwMjYzNA==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r409702634", "bodyText": "Add the second @param unusedTasks", "author": "somandal", "createdAt": "2020-04-16T16:47:52Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -850,13 +846,36 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up", "originalCommit": "f3aa084698c8c83239079da26f1c52da67b134b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwMzkwNQ==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r409703905", "bodyText": "Not part of your change, but I noticed this removeTaskNodes() method has a comment saying it deletes both from /instance and from /connector, but it doesn't do that. Can you fix that comment? May even want to rename it to indicate it only removes task nodes under /instance, e.g. removeTaskNodeFromInstance", "author": "somandal", "createdAt": "2020-04-16T16:49:41Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -850,13 +846,36 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n+  public void cleanupDeadInstanceAssignments(List<String> instances, Set<DatastreamTask> unusedTasks) {\n     List<String> deadInstances = getAllInstances();\n+    Map<String, DatastreamTask> unusedTasksByName = new HashMap<>();\n+    unusedTasks.forEach(unusedTask -> unusedTasksByName.put(unusedTask.getDatastreamTaskName(), unusedTask));\n     deadInstances.removeAll(instances);\n+\n+    LOG.debug(\"unusedTasks before cleanup: {}\", unusedTasksByName);\n     if (deadInstances.size() > 0) {\n       LOG.info(\"Cleaning up assignments for dead instances: \" + deadInstances);\n \n       for (String instance : deadInstances) {\n+        // get the old assignment from ZooKeeper\n+        Set<String> oldAssignments = new HashSet<>(getInstanceAssignment(instance));\n+\n+        oldAssignments.forEach(oldAssignment -> {\n+          DatastreamTask unusedTask = unusedTasksByName.remove(oldAssignment);\n+          removeTaskNodes(instance, oldAssignment);", "originalCommit": "f3aa084698c8c83239079da26f1c52da67b134b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwNDUyMQ==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r409704521", "bodyText": "update this to be /connector/<connectorName>/", "author": "somandal", "createdAt": "2020-04-16T16:50:41Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -850,13 +846,36 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n+  public void cleanupDeadInstanceAssignments(List<String> instances, Set<DatastreamTask> unusedTasks) {\n     List<String> deadInstances = getAllInstances();\n+    Map<String, DatastreamTask> unusedTasksByName = new HashMap<>();\n+    unusedTasks.forEach(unusedTask -> unusedTasksByName.put(unusedTask.getDatastreamTaskName(), unusedTask));\n     deadInstances.removeAll(instances);\n+\n+    LOG.debug(\"unusedTasks before cleanup: {}\", unusedTasksByName);\n     if (deadInstances.size() > 0) {\n       LOG.info(\"Cleaning up assignments for dead instances: \" + deadInstances);\n \n       for (String instance : deadInstances) {\n+        // get the old assignment from ZooKeeper\n+        Set<String> oldAssignments = new HashSet<>(getInstanceAssignment(instance));\n+\n+        oldAssignments.forEach(oldAssignment -> {\n+          DatastreamTask unusedTask = unusedTasksByName.remove(oldAssignment);\n+          removeTaskNodes(instance, oldAssignment);\n+          // /connector/<Task> node should always be deleted after /instance/<Task>/.", "originalCommit": "f3aa084698c8c83239079da26f1c52da67b134b2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwMzE0Mw==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r413403143", "bodyText": "Can you please clarify this again?", "author": "vmaheshw", "createdAt": "2020-04-22T23:34:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwNDUyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzQwNDgxNw==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r413404817", "bodyText": "updated the comment", "author": "somandal", "createdAt": "2020-04-22T23:38:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwNDUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwNTI2Mg==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r409705262", "bodyText": "Update the java docs to say this finds unused tasks.\nUpdate the java doc to add an @returns as well, indicating that it returns a list of unused DatastreamTasks", "author": "somandal", "createdAt": "2020-04-16T16:51:58Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -875,21 +895,39 @@ public void cleanupDeadInstanceAssignments(List<String> instances) {\n    * @param previousAssignmentByInstance Previous task assignment\n    * @param newAssignmentsByInstance New task assignment.\n    */\n-  public void cleanupOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n+  public Set<DatastreamTask> findOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,", "originalCommit": "f3aa084698c8c83239079da26f1c52da67b134b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwNTY2Mg==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r409705662", "bodyText": "nit: don't need the space after {}", "author": "somandal", "createdAt": "2020-04-16T16:52:38Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -875,21 +895,39 @@ public void cleanupDeadInstanceAssignments(List<String> instances) {\n    * @param previousAssignmentByInstance Previous task assignment\n    * @param newAssignmentsByInstance New task assignment.\n    */\n-  public void cleanupOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n+  public Set<DatastreamTask> findOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n       Map<String, List<DatastreamTask>> newAssignmentsByInstance) {\n \n     Set<DatastreamTask> newTasks =\n         newAssignmentsByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n     Set<DatastreamTask> oldTasks =\n         previousAssignmentByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n-    List<DatastreamTask> unusedTasks =\n-        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toList());\n-    LOG.info(\"Deleting the unused tasks {} \", unusedTasks);\n+    Set<DatastreamTask> unusedTasks =\n+        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toSet());\n+    LOG.info(\"Unused tasks to be deleted: {} \", unusedTasks);", "originalCommit": "f3aa084698c8c83239079da26f1c52da67b134b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwNTk0Ng==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r409705946", "bodyText": "Can you rename this to be findAndCleanupOldUnusedTasks()?\nAnd if you decide to rename the previous function to indicate that the tasks are getting cleaned up under /connector, please do the same here as well.", "author": "somandal", "createdAt": "2020-04-16T16:53:06Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -875,21 +895,39 @@ public void cleanupDeadInstanceAssignments(List<String> instances) {\n    * @param previousAssignmentByInstance Previous task assignment\n    * @param newAssignmentsByInstance New task assignment.\n    */\n-  public void cleanupOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n+  public Set<DatastreamTask> findOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n       Map<String, List<DatastreamTask>> newAssignmentsByInstance) {\n \n     Set<DatastreamTask> newTasks =\n         newAssignmentsByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n     Set<DatastreamTask> oldTasks =\n         previousAssignmentByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n-    List<DatastreamTask> unusedTasks =\n-        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toList());\n-    LOG.info(\"Deleting the unused tasks {} \", unusedTasks);\n+    Set<DatastreamTask> unusedTasks =\n+        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toSet());\n+    LOG.info(\"Unused tasks to be deleted: {} \", unusedTasks);\n+    return unusedTasks;\n+  }\n \n+  /**\n+   * Delete the unused connector tasks from zookeeper.\n+   * @param unusedTasks Unused tasks.\n+   */\n+  public void cleanupOldUnusedTasks(Set<DatastreamTask> unusedTasks) {\n     // Delete the connector tasks.\n     unusedTasks.forEach(t -> deleteConnectorTask(t.getConnectorType(), t.getDatastreamTaskName()));\n   }\n \n+  /**\n+   * Find the ununsed tasks and delete the unused connector tasks from zookeeper.\n+   * @param previousAssignmentByInstance Previous task assignment\n+   * @param newAssignmentsByInstance New task assignment.\n+   */\n+  public void cleanupOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,", "originalCommit": "f3aa084698c8c83239079da26f1c52da67b134b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwNjIxMQ==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r409706211", "bodyText": "nit: ununsed -> unused", "author": "somandal", "createdAt": "2020-04-16T16:53:34Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -875,21 +895,39 @@ public void cleanupDeadInstanceAssignments(List<String> instances) {\n    * @param previousAssignmentByInstance Previous task assignment\n    * @param newAssignmentsByInstance New task assignment.\n    */\n-  public void cleanupOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n+  public Set<DatastreamTask> findOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n       Map<String, List<DatastreamTask>> newAssignmentsByInstance) {\n \n     Set<DatastreamTask> newTasks =\n         newAssignmentsByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n     Set<DatastreamTask> oldTasks =\n         previousAssignmentByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n-    List<DatastreamTask> unusedTasks =\n-        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toList());\n-    LOG.info(\"Deleting the unused tasks {} \", unusedTasks);\n+    Set<DatastreamTask> unusedTasks =\n+        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toSet());\n+    LOG.info(\"Unused tasks to be deleted: {} \", unusedTasks);\n+    return unusedTasks;\n+  }\n \n+  /**\n+   * Delete the unused connector tasks from zookeeper.\n+   * @param unusedTasks Unused tasks.\n+   */\n+  public void cleanupOldUnusedTasks(Set<DatastreamTask> unusedTasks) {\n     // Delete the connector tasks.\n     unusedTasks.forEach(t -> deleteConnectorTask(t.getConnectorType(), t.getDatastreamTaskName()));\n   }\n \n+  /**\n+   * Find the ununsed tasks and delete the unused connector tasks from zookeeper.", "originalCommit": "f3aa084698c8c83239079da26f1c52da67b134b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTcwNjk3OQ==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r409706979", "bodyText": "I'm wondering if we should rename this to indicate that it clears unused tasks from /connector, e.g. cleanupOldUnusedTasksFromConnector() or something like that? Same for the next function named this way.", "author": "somandal", "createdAt": "2020-04-16T16:54:47Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -875,21 +895,39 @@ public void cleanupDeadInstanceAssignments(List<String> instances) {\n    * @param previousAssignmentByInstance Previous task assignment\n    * @param newAssignmentsByInstance New task assignment.\n    */\n-  public void cleanupOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n+  public Set<DatastreamTask> findOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n       Map<String, List<DatastreamTask>> newAssignmentsByInstance) {\n \n     Set<DatastreamTask> newTasks =\n         newAssignmentsByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n     Set<DatastreamTask> oldTasks =\n         previousAssignmentByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n-    List<DatastreamTask> unusedTasks =\n-        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toList());\n-    LOG.info(\"Deleting the unused tasks {} \", unusedTasks);\n+    Set<DatastreamTask> unusedTasks =\n+        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toSet());\n+    LOG.info(\"Unused tasks to be deleted: {} \", unusedTasks);\n+    return unusedTasks;\n+  }\n \n+  /**\n+   * Delete the unused connector tasks from zookeeper.\n+   * @param unusedTasks Unused tasks.\n+   */\n+  public void cleanupOldUnusedTasks(Set<DatastreamTask> unusedTasks) {", "originalCommit": "f3aa084698c8c83239079da26f1c52da67b134b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3687be18d3187eb733ba0312b8f178875ad6e15f", "url": "https://github.com/linkedin/brooklin/commit/3687be18d3187eb733ba0312b8f178875ad6e15f", "message": "Address PR comments", "committedDate": "2020-04-23T01:16:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA2Mjc4NQ==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414062785", "bodyText": "findOldUnusedTasks() looks like an implementation detail of cleanupDeadInstanceAssignmentsAndUnusedTasks(); it's not useful on its own as an independent public API of _adapter.\nI suggest we invoke findOldUnusedTasks() from within cleanupDeadInstanceAssignmentsAndUnusedTasks(). In this case, we should be able to mark the former private.", "author": "ahmedahamid", "createdAt": "2020-04-23T19:24:23Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/Coordinator.java", "diffHunk": "@@ -998,8 +998,9 @@ private void handleLeaderDoAssignment(boolean cleanUpOrphanConnectorTasks) {\n     if (succeeded) {\n       List<String> instances = new ArrayList<>(liveInstances);\n       instances.add(PAUSED_INSTANCE);\n-      _adapter.cleanupDeadInstanceAssignments(instances);\n-      _adapter.cleanupOldUnusedTasks(previousAssignmentByInstance, newAssignmentsByInstance);\n+      Set<DatastreamTask> unusedTasks = _adapter.findOldUnusedTasks(previousAssignmentByInstance,\n+          newAssignmentsByInstance);", "originalCommit": "3687be18d3187eb733ba0312b8f178875ad6e15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA2ODk3NQ==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414068975", "bodyText": "cleanUp (capital U)\nNot all your fault nit: please make sure all other cleanup methods on this class use a capital U\nnit: please free to ignore this one but let me know what you think \u2014 Is this name a little too verbose? Should it be something like cleanUpDeadInstanceData? Rationale is: the javadoc can capture the details; we know cleaning up dead instances involves deleting a number of different things but should they all be reflected in the name?\nSince this is the main cleanup function called from the Coordinator, I suggest we add informational log statements on entry and exit. This can be very useful during debugging, let alone it helps us observe how long cleanup takes.", "author": "ahmedahamid", "createdAt": "2020-04-23T19:34:30Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -841,22 +838,50 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n   }\n \n   /**\n-   * Remove instance assignment nodes whose instances are dead\n+   * Remove instance assignment nodes whose instances are dead. This also\n+   * removes the node from under /connector if present in unusedTasks.\n    *\n    * NOTE: this should only be called after the valid tasks have been\n    * reassigned or become safe to discard per strategy requirement.\n    * Coordinator is expected to cache the \"current\" assignment before\n    * invoking the assignment strategy and pass the saved assignment\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up\n+   * @param unusedTasks Unused tasks that can be cleaned up once they\n+   *                    are removed from dead instances.\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n+  public void cleanupDeadInstanceAssignmentsAndUnusedTasks(List<String> instances,", "originalCommit": "3687be18d3187eb733ba0312b8f178875ad6e15f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMwODgwNw==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414308807", "bodyText": "Along with cleaning up dead instance data this function is also cleaning up remaining unused tasks which are not present in new assignment. so this name may be insufficient.\nHow about cleanUpDeadInstanceDataAndOtherUnusedTasks ?", "author": "vmaheshw", "createdAt": "2020-04-24T05:43:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA2ODk3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg0NzAyNA==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414847024", "bodyText": "Both names are equally descriptive. Thank you.", "author": "ahmedahamid", "createdAt": "2020-04-24T20:34:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA2ODk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA3MDIyOA==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414070228", "bodyText": "nit: findAnd; finding is implied", "author": "ahmedahamid", "createdAt": "2020-04-23T19:36:36Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -867,29 +892,53 @@ public void cleanupDeadInstanceAssignments(List<String> instances) {\n         _liveTaskMap.remove(instance);\n       }\n     }\n+    LOG.debug(\"unusedTasks remaining after dead instances cleanup: {}\", unusedTasksByName.keySet());\n+    // Clean the remaining unusedTasks.\n+    findAndCleanupOldUnusedTasksFromConnector(unusedTasks);\n   }\n \n   /**\n+   * It finds old unused tasks.\n+   *\n    * New assignment may not contain all the tasks from the previous assignment. This means that the diff of the\n    * tasks between the new and old assignment are not used any more which can be deleted.\n    * @param previousAssignmentByInstance Previous task assignment\n    * @param newAssignmentsByInstance New task assignment.\n+   * @return Tasks absent in newAssignment but present in oldAssignment.\n    */\n-  public void cleanupOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n+  public Set<DatastreamTask> findOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n       Map<String, List<DatastreamTask>> newAssignmentsByInstance) {\n \n     Set<DatastreamTask> newTasks =\n         newAssignmentsByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n     Set<DatastreamTask> oldTasks =\n         previousAssignmentByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n-    List<DatastreamTask> unusedTasks =\n-        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toList());\n-    LOG.info(\"Deleting the unused tasks {} \", unusedTasks);\n+    Set<DatastreamTask> unusedTasks =\n+        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toSet());\n+    LOG.info(\"Unused tasks to be deleted: {}\", unusedTasks);\n+    return unusedTasks;\n+  }\n \n+  /**\n+   * Delete the unused connector tasks from zookeeper.\n+   * @param unusedTasks Unused tasks.\n+   */\n+  private void findAndCleanupOldUnusedTasksFromConnector(Set<DatastreamTask> unusedTasks) {\n     // Delete the connector tasks.\n     unusedTasks.forEach(t -> deleteConnectorTask(t.getConnectorType(), t.getDatastreamTaskName()));\n   }\n \n+  /**\n+   * Find the unused tasks and delete the unused connector tasks from zookeeper.\n+   * @param previousAssignmentByInstance Previous task assignment\n+   * @param newAssignmentsByInstance New task assignment.\n+   */\n+  public void findAndCleanupOldUnusedTasksFromConnector(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,", "originalCommit": "3687be18d3187eb733ba0312b8f178875ad6e15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA3MzA4Ng==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414073086", "bodyText": "This sentence doesn't read well now. I find the original version okay/useful though; the clarification you're adding below is sufficient.", "author": "ahmedahamid", "createdAt": "2020-04-23T19:41:12Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -613,19 +613,20 @@ private void addTaskNodes(String instance, DatastreamTaskImpl task) {\n   }\n \n   /**\n-   * Two nodes need to be removed for a removed task:\n+   * Nodes need to be removed for a removed task:", "originalCommit": "3687be18d3187eb733ba0312b8f178875ad6e15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA3MzI2Mg==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414073262", "bodyText": "add {@link}s for both functions", "author": "ahmedahamid", "createdAt": "2020-04-23T19:41:28Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -613,19 +613,20 @@ private void addTaskNodes(String instance, DatastreamTaskImpl task) {\n   }\n \n   /**\n-   * Two nodes need to be removed for a removed task:\n+   * Nodes need to be removed for a removed task:\n    * <ol>\n    *  <li>{@code /<cluster>/instances/<instance>/<task>[JSON]}</li>\n-   *  <li>{@code /<cluster>/connectors/<connectorType>/<task>}</li>\n    * </ol>\n-   *  If either failed, a RuntimeException will be thrown.\n+   *\n+   * {@code /<cluster>/connectors/<connectorType>/<task>} gets cleaned up\n+   * in cleanupDeadInstanceAssignmentsAndUnusedTasks() after updateAssignments is successful.", "originalCommit": "3687be18d3187eb733ba0312b8f178875ad6e15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA3NjAxOA==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414076018", "bodyText": "new HashSet<> is not needed; oldAssignmentNames is only used for exclusion from a set, let alone the returned assignments are always unique anyways (read straight from ZooKeeper). oldAssignmentNames  can be a List<String or even Collection<String>.", "author": "ahmedahamid", "createdAt": "2020-04-23T19:45:55Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -703,11 +704,7 @@ private void diffAssignmentNodes(Map<String, List<DatastreamTask>> assignmentsBy\n           .collect(Collectors.toSet());\n \n       // get the old assignment from ZooKeeper\n-      Set<String> oldAssignmentNames = new HashSet<>();\n-      String instancePath = KeyBuilder.instanceAssignments(_cluster, instance);\n-      if (_zkclient.exists(instancePath)) {\n-        oldAssignmentNames.addAll(_zkclient.getChildren(instancePath));\n-      }\n+      Set<String> oldAssignmentNames = new HashSet<>(getInstanceAssignment(instance));", "originalCommit": "3687be18d3187eb733ba0312b8f178875ad6e15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDA5NTI5MQ==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414095291", "bodyText": "Move to line 856 since it's closely related to 855.\nNot your fault: since we're doing removeAll(), let's turn deadInstances into a Set<String> so the complexity of that operation becomes linear.", "author": "ahmedahamid", "createdAt": "2020-04-23T20:17:48Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -841,22 +838,50 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n   }\n \n   /**\n-   * Remove instance assignment nodes whose instances are dead\n+   * Remove instance assignment nodes whose instances are dead. This also\n+   * removes the node from under /connector if present in unusedTasks.\n    *\n    * NOTE: this should only be called after the valid tasks have been\n    * reassigned or become safe to discard per strategy requirement.\n    * Coordinator is expected to cache the \"current\" assignment before\n    * invoking the assignment strategy and pass the saved assignment\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up\n+   * @param unusedTasks Unused tasks that can be cleaned up once they\n+   *                    are removed from dead instances.\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n+  public void cleanupDeadInstanceAssignmentsAndUnusedTasks(List<String> instances,\n+      Set<DatastreamTask> unusedTasks) {\n     List<String> deadInstances = getAllInstances();\n+    Map<String, DatastreamTask> unusedTasksByName = new HashMap<>();\n+    unusedTasks.forEach(unusedTask -> unusedTasksByName.put(unusedTask.getDatastreamTaskName(), unusedTask));\n     deadInstances.removeAll(instances);", "originalCommit": "3687be18d3187eb733ba0312b8f178875ad6e15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDE3NjcwNw==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414176707", "bodyText": "Please feel free to ignore this comment if you prefer it the way it is \u2014 this can be written as:\nMap<String, DatastreamTask> unusedTasksByName = unusedTasks.stream()\n       .collect(Collectors.toMap(DatastreamTask::getDatastreamTaskName, Function.identity()));", "author": "ahmedahamid", "createdAt": "2020-04-23T22:53:50Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -841,22 +838,50 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n   }\n \n   /**\n-   * Remove instance assignment nodes whose instances are dead\n+   * Remove instance assignment nodes whose instances are dead. This also\n+   * removes the node from under /connector if present in unusedTasks.\n    *\n    * NOTE: this should only be called after the valid tasks have been\n    * reassigned or become safe to discard per strategy requirement.\n    * Coordinator is expected to cache the \"current\" assignment before\n    * invoking the assignment strategy and pass the saved assignment\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up\n+   * @param unusedTasks Unused tasks that can be cleaned up once they\n+   *                    are removed from dead instances.\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n+  public void cleanupDeadInstanceAssignmentsAndUnusedTasks(List<String> instances,\n+      Set<DatastreamTask> unusedTasks) {\n     List<String> deadInstances = getAllInstances();\n+    Map<String, DatastreamTask> unusedTasksByName = new HashMap<>();\n+    unusedTasks.forEach(unusedTask -> unusedTasksByName.put(unusedTask.getDatastreamTaskName(), unusedTask));", "originalCommit": "3687be18d3187eb733ba0312b8f178875ad6e15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI0MjUwOQ==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414242509", "bodyText": "Do we need to update unusedTasks? Can't we pass unusedTasksByName.values() to findAndCleanupOldUnusedTasksFromConnector() after changing the latter to expect a Collection?", "author": "ahmedahamid", "createdAt": "2020-04-24T02:14:50Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -841,22 +838,50 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n   }\n \n   /**\n-   * Remove instance assignment nodes whose instances are dead\n+   * Remove instance assignment nodes whose instances are dead. This also\n+   * removes the node from under /connector if present in unusedTasks.\n    *\n    * NOTE: this should only be called after the valid tasks have been\n    * reassigned or become safe to discard per strategy requirement.\n    * Coordinator is expected to cache the \"current\" assignment before\n    * invoking the assignment strategy and pass the saved assignment\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up\n+   * @param unusedTasks Unused tasks that can be cleaned up once they\n+   *                    are removed from dead instances.\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n+  public void cleanupDeadInstanceAssignmentsAndUnusedTasks(List<String> instances,\n+      Set<DatastreamTask> unusedTasks) {\n     List<String> deadInstances = getAllInstances();\n+    Map<String, DatastreamTask> unusedTasksByName = new HashMap<>();\n+    unusedTasks.forEach(unusedTask -> unusedTasksByName.put(unusedTask.getDatastreamTaskName(), unusedTask));\n     deadInstances.removeAll(instances);\n+\n+    LOG.debug(\"unusedTasks before cleanup: {}\", unusedTasksByName.keySet());\n     if (deadInstances.size() > 0) {\n       LOG.info(\"Cleaning up assignments for dead instances: \" + deadInstances);\n \n       for (String instance : deadInstances) {\n+        // get the old assignment from ZooKeeper\n+        Set<String> oldAssignments = new HashSet<>(getInstanceAssignment(instance));\n+\n+        oldAssignments.forEach(oldAssignment -> {\n+          removeTaskNodes(instance, oldAssignment);\n+          // /<cluster>/connectors/<connectorType>/<task> node should always be deleted after\n+          // /<cluster>/instances/<task>/.\n+          // If a node is present under /instance, the code assumes that the node will be present under\n+          // /<cluster>/connectors/<connectorType>/ as well. So, the cleanup order is very important.\n+\n+          // If the thread gets interrupted after removing node under /instance, but before deleting node\n+          // under /<cluster>/connectors/<connectorType>/, next leader will take care of cleaning this orphan node in\n+          // cleanUpOrphanConnectorTask call.\n+          DatastreamTask unusedTask = unusedTasksByName.remove(oldAssignment);\n+          if (unusedTask != null) {\n+            deleteConnectorTask(unusedTask.getConnectorType(), unusedTask.getDatastreamTaskName());\n+            unusedTasks.remove(unusedTask);", "originalCommit": "3687be18d3187eb733ba0312b8f178875ad6e15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI0NTM4Nw==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414245387", "bodyText": "This is a purely stylistic comment that is heavily subjective: I personally find it slightly better to have this be an ordinary for loop because that makes it easier to grasp the logic with a quick glance at the two nested loops:\nfor (String instance: deadInstances) {\n    ...\n    for (String assignment : oldAssignments) {\n        ...   \n    }\n}", "author": "ahmedahamid", "createdAt": "2020-04-24T02:25:06Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -841,22 +838,50 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n   }\n \n   /**\n-   * Remove instance assignment nodes whose instances are dead\n+   * Remove instance assignment nodes whose instances are dead. This also\n+   * removes the node from under /connector if present in unusedTasks.\n    *\n    * NOTE: this should only be called after the valid tasks have been\n    * reassigned or become safe to discard per strategy requirement.\n    * Coordinator is expected to cache the \"current\" assignment before\n    * invoking the assignment strategy and pass the saved assignment\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up\n+   * @param unusedTasks Unused tasks that can be cleaned up once they\n+   *                    are removed from dead instances.\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n+  public void cleanupDeadInstanceAssignmentsAndUnusedTasks(List<String> instances,\n+      Set<DatastreamTask> unusedTasks) {\n     List<String> deadInstances = getAllInstances();\n+    Map<String, DatastreamTask> unusedTasksByName = new HashMap<>();\n+    unusedTasks.forEach(unusedTask -> unusedTasksByName.put(unusedTask.getDatastreamTaskName(), unusedTask));\n     deadInstances.removeAll(instances);\n+\n+    LOG.debug(\"unusedTasks before cleanup: {}\", unusedTasksByName.keySet());\n     if (deadInstances.size() > 0) {\n       LOG.info(\"Cleaning up assignments for dead instances: \" + deadInstances);\n \n       for (String instance : deadInstances) {\n+        // get the old assignment from ZooKeeper\n+        Set<String> oldAssignments = new HashSet<>(getInstanceAssignment(instance));\n+\n+        oldAssignments.forEach(oldAssignment -> {", "originalCommit": "3687be18d3187eb733ba0312b8f178875ad6e15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI2NDM4OQ==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414264389", "bodyText": "new HashSet<> is extraneous; we just need iteration + the elements are unique since they're read from ZooKeeper\nThe name oldAssignments doesn't convey that these are actually datastream task names. I suggest renaming it to oldDatastreamTaskNames.\nI have a suggestion in handleLeaderDoAssignment() to inline the computation of unusedTasks in this method (cleanupDeadInstanceAssignmentsAndUnusedTasks()). If we do so, we'll have access to previousAssignmentByInstance and newAssignmentsByInstance over here. In this case, wouldn't it be better to compute oldAssignments from the in-memory previousAssignmentByInstance instead of a round trip to ZooKeeper using getInstanceAssignment()?", "author": "ahmedahamid", "createdAt": "2020-04-24T03:25:58Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -841,22 +838,50 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n   }\n \n   /**\n-   * Remove instance assignment nodes whose instances are dead\n+   * Remove instance assignment nodes whose instances are dead. This also\n+   * removes the node from under /connector if present in unusedTasks.\n    *\n    * NOTE: this should only be called after the valid tasks have been\n    * reassigned or become safe to discard per strategy requirement.\n    * Coordinator is expected to cache the \"current\" assignment before\n    * invoking the assignment strategy and pass the saved assignment\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up\n+   * @param unusedTasks Unused tasks that can be cleaned up once they\n+   *                    are removed from dead instances.\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n+  public void cleanupDeadInstanceAssignmentsAndUnusedTasks(List<String> instances,\n+      Set<DatastreamTask> unusedTasks) {\n     List<String> deadInstances = getAllInstances();\n+    Map<String, DatastreamTask> unusedTasksByName = new HashMap<>();\n+    unusedTasks.forEach(unusedTask -> unusedTasksByName.put(unusedTask.getDatastreamTaskName(), unusedTask));\n     deadInstances.removeAll(instances);\n+\n+    LOG.debug(\"unusedTasks before cleanup: {}\", unusedTasksByName.keySet());\n     if (deadInstances.size() > 0) {\n       LOG.info(\"Cleaning up assignments for dead instances: \" + deadInstances);\n \n       for (String instance : deadInstances) {\n+        // get the old assignment from ZooKeeper\n+        Set<String> oldAssignments = new HashSet<>(getInstanceAssignment(instance));", "originalCommit": "3687be18d3187eb733ba0312b8f178875ad6e15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3MzI0OQ==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414273249", "bodyText": "findAnd", "author": "ahmedahamid", "createdAt": "2020-04-24T03:55:00Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -867,29 +892,53 @@ public void cleanupDeadInstanceAssignments(List<String> instances) {\n         _liveTaskMap.remove(instance);\n       }\n     }\n+    LOG.debug(\"unusedTasks remaining after dead instances cleanup: {}\", unusedTasksByName.keySet());\n+    // Clean the remaining unusedTasks.\n+    findAndCleanupOldUnusedTasksFromConnector(unusedTasks);\n   }\n \n   /**\n+   * It finds old unused tasks.\n+   *\n    * New assignment may not contain all the tasks from the previous assignment. This means that the diff of the\n    * tasks between the new and old assignment are not used any more which can be deleted.\n    * @param previousAssignmentByInstance Previous task assignment\n    * @param newAssignmentsByInstance New task assignment.\n+   * @return Tasks absent in newAssignment but present in oldAssignment.\n    */\n-  public void cleanupOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n+  public Set<DatastreamTask> findOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n       Map<String, List<DatastreamTask>> newAssignmentsByInstance) {\n \n     Set<DatastreamTask> newTasks =\n         newAssignmentsByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n     Set<DatastreamTask> oldTasks =\n         previousAssignmentByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n-    List<DatastreamTask> unusedTasks =\n-        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toList());\n-    LOG.info(\"Deleting the unused tasks {} \", unusedTasks);\n+    Set<DatastreamTask> unusedTasks =\n+        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toSet());\n+    LOG.info(\"Unused tasks to be deleted: {}\", unusedTasks);\n+    return unusedTasks;\n+  }\n \n+  /**\n+   * Delete the unused connector tasks from zookeeper.\n+   * @param unusedTasks Unused tasks.\n+   */\n+  private void findAndCleanupOldUnusedTasksFromConnector(Set<DatastreamTask> unusedTasks) {", "originalCommit": "3687be18d3187eb733ba0312b8f178875ad6e15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3NjI4MQ==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414276281", "bodyText": "I like this comment a lot but:\n\nIt doesn't say that removeTaskNodes() removes /<cluster>/instances/<task>/\nThe path isn't exactly /<cluster>/instances/<task>/\nIt assumes a bit of background\n\nHow about we write this as:\n        oldAssignments.forEach(oldAssignment -> {\n          // We have two znodes to clean up for every datastream task\n          //  1. /<cluster>/instances/{instanceId}/assignments/<task>\n          //  2. /<cluster>/connectors/<connectorType>/<task>\n          // \n          // (1) should always be deleted first. If we were to delete (2) first,\n          // and the code got interrupted (e.g. due to shutdown), we would run\n          // the risk of having the next leader assign a task with no presence\n          // in (2) to a live host, which may cause errors in other pieces of\n          // code because datastream task entries in (2) are needed for host-\n          // independent operations like locking tasks and check-pointing progress.\n          //\n          // On the other hand, when we delete (1) before (2), if the code is \n          // interrupted in between the two operations, the next leader will not\n          // assign that task to any host; only (2) will become an orphan node \n          // and the next leader will take care of deleting it in cleanUpOrphanConnectorTask().\n          \n          // Delete (1)\n          removeTaskNodes(instance, oldAssignment);\n          \n          DatastreamTask unusedTask = unusedTasksByName.remove(oldAssignment);\n          if (unusedTask != null) {\n            // Delete (2)\n            deleteConnectorTask(unusedTask.getConnectorType(), unusedTask.getDatastreamTaskName());\n            unusedTasks.remove(unusedTask);\n          }\n        });", "author": "ahmedahamid", "createdAt": "2020-04-24T04:04:59Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -841,22 +838,50 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n   }\n \n   /**\n-   * Remove instance assignment nodes whose instances are dead\n+   * Remove instance assignment nodes whose instances are dead. This also\n+   * removes the node from under /connector if present in unusedTasks.\n    *\n    * NOTE: this should only be called after the valid tasks have been\n    * reassigned or become safe to discard per strategy requirement.\n    * Coordinator is expected to cache the \"current\" assignment before\n    * invoking the assignment strategy and pass the saved assignment\n    * to us to figure out the obsolete tasks.\n    * @param instances Instances for which nodes are to be cleaned up\n+   * @param unusedTasks Unused tasks that can be cleaned up once they\n+   *                    are removed from dead instances.\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n+  public void cleanupDeadInstanceAssignmentsAndUnusedTasks(List<String> instances,\n+      Set<DatastreamTask> unusedTasks) {\n     List<String> deadInstances = getAllInstances();\n+    Map<String, DatastreamTask> unusedTasksByName = new HashMap<>();\n+    unusedTasks.forEach(unusedTask -> unusedTasksByName.put(unusedTask.getDatastreamTaskName(), unusedTask));\n     deadInstances.removeAll(instances);\n+\n+    LOG.debug(\"unusedTasks before cleanup: {}\", unusedTasksByName.keySet());\n     if (deadInstances.size() > 0) {\n       LOG.info(\"Cleaning up assignments for dead instances: \" + deadInstances);\n \n       for (String instance : deadInstances) {\n+        // get the old assignment from ZooKeeper\n+        Set<String> oldAssignments = new HashSet<>(getInstanceAssignment(instance));\n+\n+        oldAssignments.forEach(oldAssignment -> {\n+          removeTaskNodes(instance, oldAssignment);\n+          // /<cluster>/connectors/<connectorType>/<task> node should always be deleted after\n+          // /<cluster>/instances/<task>/.\n+          // If a node is present under /instance, the code assumes that the node will be present under\n+          // /<cluster>/connectors/<connectorType>/ as well. So, the cleanup order is very important.\n+\n+          // If the thread gets interrupted after removing node under /instance, but before deleting node\n+          // under /<cluster>/connectors/<connectorType>/, next leader will take care of cleaning this orphan node in\n+          // cleanUpOrphanConnectorTask call.", "originalCommit": "3687be18d3187eb733ba0312b8f178875ad6e15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3ODc3NQ==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414278775", "bodyText": "Collections.emptyList()", "author": "ahmedahamid", "createdAt": "2020-04-24T04:12:28Z", "path": "datastream-server/src/test/java/com/linkedin/datastream/server/zk/TestZkAdapter.java", "diffHunk": "@@ -787,6 +788,49 @@ public void testDeleteTasksWithPrefix() {\n     adapter.disconnect();\n   }\n \n+  @Test\n+  public void testUpdateAssignmentDeleteUnusedTasks() {\n+    String testCluster = \"testUpdateAssignmentDeleteUnusedTasks\";\n+    String connectorType = \"connectorType\";\n+    int totalTasks = 10;\n+\n+    ZkClientInterceptingAdapter adapter = createInterceptingZkAdapter(testCluster);\n+    adapter.connect();\n+\n+    List<DatastreamTask> tasks1 = new ArrayList<>();\n+    Set<DatastreamTask> unusedTaskSet = new HashSet<>();\n+\n+    // Create some nodes\n+    for (int i = 0; i < totalTasks; i++) {\n+      DatastreamTaskImpl dsTask = new DatastreamTaskImpl();\n+      dsTask.setId(\"task1\" + i);\n+      String taskPrefix = \"taskPrefix1\" + i;\n+      dsTask.setTaskPrefix(taskPrefix);\n+      dsTask.setConnectorType(connectorType);\n+      dsTask.setZkAdapter(adapter);\n+      tasks1.add(dsTask);\n+      if (i % 2 == 0) {\n+        unusedTaskSet.add(dsTask);\n+      }\n+    }\n+    updateInstanceAssignment(adapter, adapter.getInstanceName(), tasks1);\n+\n+    // Send some of the connector tasks as unused tasks to check there are still left over tasks under /connector,\n+    // but everything cleaned up under /instance.\n+    Assert.assertEquals(unusedTaskSet.size(), totalTasks / 2);\n+    adapter.cleanupDeadInstanceAssignmentsAndUnusedTasks(new ArrayList<>(), unusedTaskSet);", "originalCommit": "3687be18d3187eb733ba0312b8f178875ad6e15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI3OTM1NQ==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414279355", "bodyText": "Collections.emptyList()", "author": "ahmedahamid", "createdAt": "2020-04-24T04:14:19Z", "path": "datastream-server/src/test/java/com/linkedin/datastream/server/zk/TestZkAdapter.java", "diffHunk": "@@ -769,7 +770,7 @@ public void testDeleteTasksWithPrefix() {\n     leftOverTasks = zkClient.getChildren(KeyBuilder.connector(testCluster, connectorType));\n     Assert.assertEquals(leftOverTasks.size(), 2);\n \n-    updateInstanceAssignment(adapter, adapter.getInstanceName(), new ArrayList<DatastreamTask>());\n+    updateInstanceAssignment(adapter, adapter.getInstanceName(), new ArrayList<>());", "originalCommit": "3687be18d3187eb733ba0312b8f178875ad6e15f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "acb48aadbaaece1c721a875b4a7504081138b311", "url": "https://github.com/linkedin/brooklin/commit/acb48aadbaaece1c721a875b4a7504081138b311", "message": "Address PR comments", "committedDate": "2020-04-24T19:07:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgyNDE3OQ==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414824179", "bodyText": "nit: it should be Cleanup (lowercase u) in this context. Rationale is: cleanup (noun) is one word, clean up (verb) is two words. We capitalize word boundaries.", "author": "ahmedahamid", "createdAt": "2020-04-24T19:51:22Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/Coordinator.java", "diffHunk": "@@ -998,10 +998,10 @@ private void handleLeaderDoAssignment(boolean cleanUpOrphanConnectorTasks) {\n     if (succeeded) {\n       List<String> instances = new ArrayList<>(liveInstances);\n       instances.add(PAUSED_INSTANCE);\n-      _adapter.cleanupDeadInstanceAssignments(instances);\n-      _adapter.cleanupOldUnusedTasks(previousAssignmentByInstance, newAssignmentsByInstance);\n+      _adapter.cleanUpDeadInstanceDataAndOtherUnusedTasks(previousAssignmentByInstance,\n+          newAssignmentsByInstance, instances);\n       if (cleanUpOrphanConnectorTasks) {\n-        performCleanupOrphanConnectorTasks();\n+        performCleanUpOrphanConnectorTasks();", "originalCommit": "acb48aadbaaece1c721a875b4a7504081138b311", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzMTk2MQ==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414831961", "bodyText": "If you're only interested in keySet() then maybe we don't need a map. A list will do.\n    LOG.debug(\"unusedTasks before cleanUp: {}\", unusedTasks.stream()\n        .map(DatastreamTask::getDatastreamTaskName).collect(Collectors.toList()));\nThe same applies to lines 910-911.", "author": "ahmedahamid", "createdAt": "2020-04-24T20:05:51Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -841,22 +838,65 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n   }\n \n   /**\n-   * Remove instance assignment nodes whose instances are dead\n+   * Remove instance assignment nodes whose instances are dead. This also\n+   * removes the node from under /connector if present in unusedTasks.\n    *\n    * NOTE: this should only be called after the valid tasks have been\n    * reassigned or become safe to discard per strategy requirement.\n    * Coordinator is expected to cache the \"current\" assignment before\n    * invoking the assignment strategy and pass the saved assignment\n    * to us to figure out the obsolete tasks.\n+   * @param previousAssignmentByInstance Previous task assignment\n+   * @param newAssignmentsByInstance New task assignment.\n    * @param instances Instances for which nodes are to be cleaned up\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n-    List<String> deadInstances = getAllInstances();\n+  public void cleanUpDeadInstanceDataAndOtherUnusedTasks(\n+      Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n+      Map<String, List<DatastreamTask>> newAssignmentsByInstance,\n+      List<String> instances) {\n+\n+    LOG.info(\"cleanUpDeadInstanceData is called\");\n+    Set<DatastreamTask> unusedTasks = findOldUnusedTasks(previousAssignmentByInstance, newAssignmentsByInstance);\n+\n+    Set<String> deadInstances = previousAssignmentByInstance.keySet();\n     deadInstances.removeAll(instances);\n+\n+    LOG.debug(\"unusedTasks before cleanUp: {}\", unusedTasks.stream()\n+        .collect(Collectors.toMap(DatastreamTask::getDatastreamTaskName, Function.identity())).keySet());", "originalCommit": "acb48aadbaaece1c721a875b4a7504081138b311", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgzMzE4Ng==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414833186", "bodyText": "Stale function name. The same applies to line 914.", "author": "ahmedahamid", "createdAt": "2020-04-24T20:08:05Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -841,22 +838,65 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n   }\n \n   /**\n-   * Remove instance assignment nodes whose instances are dead\n+   * Remove instance assignment nodes whose instances are dead. This also\n+   * removes the node from under /connector if present in unusedTasks.\n    *\n    * NOTE: this should only be called after the valid tasks have been\n    * reassigned or become safe to discard per strategy requirement.\n    * Coordinator is expected to cache the \"current\" assignment before\n    * invoking the assignment strategy and pass the saved assignment\n    * to us to figure out the obsolete tasks.\n+   * @param previousAssignmentByInstance Previous task assignment\n+   * @param newAssignmentsByInstance New task assignment.\n    * @param instances Instances for which nodes are to be cleaned up\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n-    List<String> deadInstances = getAllInstances();\n+  public void cleanUpDeadInstanceDataAndOtherUnusedTasks(\n+      Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n+      Map<String, List<DatastreamTask>> newAssignmentsByInstance,\n+      List<String> instances) {\n+\n+    LOG.info(\"cleanUpDeadInstanceData is called\");", "originalCommit": "acb48aadbaaece1c721a875b4a7504081138b311", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDg1MDIwMw==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r414850203", "bodyText": "Rename to liveInstances", "author": "ahmedahamid", "createdAt": "2020-04-24T20:40:58Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -841,22 +838,65 @@ public void setDatastreamTaskStateForKey(DatastreamTask datastreamTask, String k\n   }\n \n   /**\n-   * Remove instance assignment nodes whose instances are dead\n+   * Remove instance assignment nodes whose instances are dead. This also\n+   * removes the node from under /connector if present in unusedTasks.\n    *\n    * NOTE: this should only be called after the valid tasks have been\n    * reassigned or become safe to discard per strategy requirement.\n    * Coordinator is expected to cache the \"current\" assignment before\n    * invoking the assignment strategy and pass the saved assignment\n    * to us to figure out the obsolete tasks.\n+   * @param previousAssignmentByInstance Previous task assignment\n+   * @param newAssignmentsByInstance New task assignment.\n    * @param instances Instances for which nodes are to be cleaned up\n    */\n-  public void cleanupDeadInstanceAssignments(List<String> instances) {\n-    List<String> deadInstances = getAllInstances();\n+  public void cleanUpDeadInstanceDataAndOtherUnusedTasks(\n+      Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n+      Map<String, List<DatastreamTask>> newAssignmentsByInstance,\n+      List<String> instances) {", "originalCommit": "acb48aadbaaece1c721a875b4a7504081138b311", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b1defe95d43235e133117095e644770a193a311b", "url": "https://github.com/linkedin/brooklin/commit/b1defe95d43235e133117095e644770a193a311b", "message": "Address PR Comments", "committedDate": "2020-04-24T22:29:24Z", "type": "commit"}, {"oid": "e9989fd1f007427d4bf2253343e33e5d883aa13a", "url": "https://github.com/linkedin/brooklin/commit/e9989fd1f007427d4bf2253343e33e5d883aa13a", "message": "Address PR Comments", "committedDate": "2020-04-24T22:54:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyOTU2MQ==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r416929561", "bodyText": "Can you add logs for when this starts and when this completes? Want to be able to figure out how long this process takes", "author": "somandal", "createdAt": "2020-04-28T21:19:26Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -867,29 +908,56 @@ public void cleanupDeadInstanceAssignments(List<String> instances) {\n         _liveTaskMap.remove(instance);\n       }\n     }\n+    LOG.debug(\"unusedTasks remaining after dead instances cleanup: {}\", unusedTasks.stream()\n+        .map(DatastreamTask::getDatastreamTaskName)\n+        .collect(Collectors.toList()));\n+    // Clean the remaining unusedTasks.\n+    cleanUpOldUnusedTasksFromConnector(unusedTasks);\n+    LOG.info(\"cleanUpDeadInstanceDataAndOtherUnusedTasks completed successfully.\");\n   }\n \n   /**\n+   * It finds old unused tasks.\n+   *\n    * New assignment may not contain all the tasks from the previous assignment. This means that the diff of the\n    * tasks between the new and old assignment are not used any more which can be deleted.\n    * @param previousAssignmentByInstance Previous task assignment\n    * @param newAssignmentsByInstance New task assignment.\n+   * @return Tasks absent in newAssignment but present in oldAssignment.\n    */\n-  public void cleanupOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n+  private Set<DatastreamTask> findOldUnusedTasks(Map<String, Set<DatastreamTask>> previousAssignmentByInstance,\n       Map<String, List<DatastreamTask>> newAssignmentsByInstance) {\n \n     Set<DatastreamTask> newTasks =\n         newAssignmentsByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n     Set<DatastreamTask> oldTasks =\n         previousAssignmentByInstance.values().stream().flatMap(Collection::stream).collect(Collectors.toSet());\n-    List<DatastreamTask> unusedTasks =\n-        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toList());\n-    LOG.info(\"Deleting the unused tasks {} \", unusedTasks);\n+    Set<DatastreamTask> unusedTasks =\n+        oldTasks.stream().filter(x -> !newTasks.contains(x)).collect(Collectors.toSet());\n+    LOG.info(\"Unused tasks to be deleted: {}\", unusedTasks);\n+    return unusedTasks;\n+  }\n \n+  /**\n+   * Delete the unused connector tasks from zookeeper.\n+   * @param unusedTasks Unused tasks.\n+   */\n+  private void cleanUpOldUnusedTasksFromConnector(Collection<DatastreamTask> unusedTasks) {", "originalCommit": "e9989fd1f007427d4bf2253343e33e5d883aa13a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzNTM0MA==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r416935340", "bodyText": "There are start and end logs in the api calling this api which will take care of it. Also, the api inside this has api for each task.", "author": "vmaheshw", "createdAt": "2020-04-28T21:30:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyOTU2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzNzI4Nw==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r416937287", "bodyText": "Adding logs here may be useful for other callers of this function that aren't going through cleanUpDeadInstanceDataAndOtherUnusedTasks()", "author": "somandal", "createdAt": "2020-04-28T21:33:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyOTU2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MDQyMQ==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r416940421", "bodyText": "\"LOG.info(\"Unused tasks to be deleted: {}\", unusedTasks);\" This is the log present in the other path as well to detect.", "author": "vmaheshw", "createdAt": "2020-04-28T21:39:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyOTU2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MjIwNg==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r416942206", "bodyText": "And is end time also logged for other code paths?", "author": "somandal", "createdAt": "2020-04-28T21:43:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyOTU2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0MzI0MA==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r416943240", "bodyText": "Adding the log, but can't that be interpreted from interrupt exception time?", "author": "vmaheshw", "createdAt": "2020-04-28T21:45:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyOTU2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NDk0OQ==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r416944949", "bodyText": "What if I want to find out how long these take to complete without it getting interrupted? I'm just trying to get data on how long these cleanup phases take on average. Today we only know when each event in the coordinator starts and ends. There is no way to track how long cleanup itself takes. Knowing this may be important to make a call on whether we should minimize interruptions during cleanup or not in the future.", "author": "somandal", "createdAt": "2020-04-28T21:49:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyOTU2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk0NzkxNg==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r416947916", "bodyText": "Added the log that will cover both the conversations.", "author": "vmaheshw", "createdAt": "2020-04-28T21:56:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyOTU2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyOTc4OQ==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r416929789", "bodyText": "Can you add a log before this so that we can find out how long the previous phase of cleanup took? I am concerned that we are increasing the time it will take to cleanup the dead instances, which can lead to handleDoLeaderAssignmentChange failures that can wedge the cluster into a bad state requiring a cluster restart. We should have sufficient logging to understand how long each phase takes in case we need to make a call later on about preventing such stages from getting interrupted in the first place.", "author": "somandal", "createdAt": "2020-04-28T21:19:56Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/zk/ZkAdapter.java", "diffHunk": "@@ -867,29 +908,56 @@ public void cleanupDeadInstanceAssignments(List<String> instances) {\n         _liveTaskMap.remove(instance);\n       }\n     }\n+    LOG.debug(\"unusedTasks remaining after dead instances cleanup: {}\", unusedTasks.stream()\n+        .map(DatastreamTask::getDatastreamTaskName)\n+        .collect(Collectors.toList()));\n+    // Clean the remaining unusedTasks.", "originalCommit": "e9989fd1f007427d4bf2253343e33e5d883aa13a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzNzQ0MA==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r416937440", "bodyText": "We are not really increasing the dead instance cleanup time. Just doing the two cleaning process interleaved. I don't really see a value of another debug line in the middle. If we come across a condition when we need it, we can always enable debug logs.", "author": "vmaheshw", "createdAt": "2020-04-28T21:34:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyOTc4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkzODE0MQ==", "url": "https://github.com/linkedin/brooklin/pull/703#discussion_r416938141", "bodyText": "I know we have run into issues when cleaning up dead instances gets interrupted and I would prefer having a log to know how long that takes. Cleaning up two nodes instead of one can essentially double the time this process takes since you need to make two calls to ZK to delete.", "author": "somandal", "createdAt": "2020-04-28T21:35:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjkyOTc4OQ=="}], "type": "inlineReview"}, {"oid": "0054b5dc29f90efa06a4e5350a85dcf0c73b5989", "url": "https://github.com/linkedin/brooklin/commit/0054b5dc29f90efa06a4e5350a85dcf0c73b5989", "message": "Address PR Comments", "committedDate": "2020-04-28T21:47:53Z", "type": "commit"}]}