{"pr_number": 737, "pr_title": "Added kafka headers in BrooklinEnvelope", "pr_createdAt": "2020-08-06T19:19:08Z", "pr_url": "https://github.com/linkedin/brooklin/pull/737", "timeline": [{"oid": "e920e7db391e6a1628924fcde9926c3a9140353d", "url": "https://github.com/linkedin/brooklin/commit/e920e7db391e6a1628924fcde9926c3a9140353d", "message": "Added kafka headers in Brooklin Envelope in order to avoid dropping them in transit", "committedDate": "2020-08-06T19:11:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY1Njg3Ng==", "url": "https://github.com/linkedin/brooklin/pull/737#discussion_r466656876", "bodyText": "can we instead use Headers which is an Iterable of Header? This is what the ConsumerRecord's getHeaders() returns:\n    /** * The headers */ public Headers headers() { return headers; }\nAnd headers looks like this:\npublic interface Headers extends Iterable<Header>", "author": "somandal", "createdAt": "2020-08-06T20:06:28Z", "path": "datastream-common/src/main/java/com/linkedin/datastream/common/BrooklinEnvelope.java", "diffHunk": "@@ -29,14 +30,16 @@\n \n   private Map<String, String> _metadata;\n \n+  private Iterable<Header> _headers;", "originalCommit": "e920e7db391e6a1628924fcde9926c3a9140353d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY1NzI4NA==", "url": "https://github.com/linkedin/brooklin/pull/737#discussion_r466657284", "bodyText": "nit: can we keep order of function parameters the same as order of setting them? so here move this before setMetadata(metadata)?", "author": "somandal", "createdAt": "2020-08-06T20:07:20Z", "path": "datastream-common/src/main/java/com/linkedin/datastream/common/BrooklinEnvelope.java", "diffHunk": "@@ -48,11 +51,25 @@ public BrooklinEnvelope(Object key, Object value, Map<String, String> metadata)\n    */\n   public BrooklinEnvelope(@Nullable Object key, @Nullable Object value, @Nullable Object previousValue,\n       Map<String, String> metadata) {\n+    this(key, value, previousValue, null, metadata);\n+  }\n+\n+  /**\n+   * Construct a {@link BrooklinEnvelope} using record key, value, headers and metadata\n+   * @param key The record key (e.g. primary key)\n+   * @param value The new record value\n+   * @param previousValue The old record value\n+   * @param headers Kafka headers to associate with the change event\n+   * @param metadata Additional metadata to associate with the change event\n+   */\n+  public BrooklinEnvelope(@Nullable Object key, @Nullable Object value, @Nullable Object previousValue,\n+      @Nullable Iterable<Header> headers, Map<String, String> metadata) {\n     Validate.notNull(metadata, \"metadata cannot be null\");\n     setKey(key);\n     setValue(value);\n     setPreviousValue(previousValue);\n     setMetadata(metadata);\n+    setHeaders(headers);", "originalCommit": "e920e7db391e6a1628924fcde9926c3a9140353d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY1NzQ4MQ==", "url": "https://github.com/linkedin/brooklin/pull/737#discussion_r466657481", "bodyText": "if we do change this to store Headers directly, we can return Headers here too.", "author": "somandal", "createdAt": "2020-08-06T20:07:48Z", "path": "datastream-common/src/main/java/com/linkedin/datastream/common/BrooklinEnvelope.java", "diffHunk": "@@ -75,6 +92,20 @@ public void setPreviousValue(Object previousValue) {\n     _previousValue = previousValue instanceof Optional ? ((Optional<?>) previousValue).orElse(null) : previousValue;\n   }\n \n+  /**\n+   * Get the Kafka headers\n+   */\n+  public Iterable<Header> getHeaders() {", "originalCommit": "e920e7db391e6a1628924fcde9926c3a9140353d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY1Nzc1Ng==", "url": "https://github.com/linkedin/brooklin/pull/737#discussion_r466657756", "bodyText": "if we do change this to store Headers directly, we can pass Headers here as the argument.", "author": "somandal", "createdAt": "2020-08-06T20:08:22Z", "path": "datastream-common/src/main/java/com/linkedin/datastream/common/BrooklinEnvelope.java", "diffHunk": "@@ -75,6 +92,20 @@ public void setPreviousValue(Object previousValue) {\n     _previousValue = previousValue instanceof Optional ? ((Optional<?>) previousValue).orElse(null) : previousValue;\n   }\n \n+  /**\n+   * Get the Kafka headers\n+   */\n+  public Iterable<Header> getHeaders() {\n+    return _headers;\n+  }\n+\n+  /**\n+   * Set the Kafka headers\n+   */\n+  public void setHeaders(Iterable<Header> headers) {", "originalCommit": "e920e7db391e6a1628924fcde9926c3a9140353d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY0OTk4NQ==", "url": "https://github.com/linkedin/brooklin/pull/737#discussion_r466649985", "bodyText": "I admire the generality Iterable<T> allows us but I think it may be a little inconvenient for headers, especially for a type as general as BrooklinEnvelope. For instance, to find out the header count, we'd have to enumerate the iterable. For this reason, I'd prefer Collection<T>; it would allow us to find the count and enumerate, while giving callers the freedom to pass in any collection they'd like.", "author": "ahmedahamid", "createdAt": "2020-08-06T19:52:12Z", "path": "datastream-common/src/main/java/com/linkedin/datastream/common/BrooklinEnvelope.java", "diffHunk": "@@ -29,14 +30,16 @@\n \n   private Map<String, String> _metadata;\n \n+  private Iterable<Header> _headers;", "originalCommit": "e920e7db391e6a1628924fcde9926c3a9140353d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY3MDM4OQ==", "url": "https://github.com/linkedin/brooklin/pull/737#discussion_r466670389", "bodyText": "Just saw Sonam's comment, I like her suggestion more actually.", "author": "ahmedahamid", "createdAt": "2020-08-06T20:33:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY0OTk4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY2OTQzMA==", "url": "https://github.com/linkedin/brooklin/pull/737#discussion_r466669430", "bodyText": "Just out of curiosity, how are we planning to fit headers within DatastreamEvent and LiDatastreamEvent?", "author": "ahmedahamid", "createdAt": "2020-08-06T20:31:58Z", "path": "datastream-common/src/main/java/com/linkedin/datastream/common/BrooklinEnvelope.java", "diffHunk": "@@ -48,11 +51,25 @@ public BrooklinEnvelope(Object key, Object value, Map<String, String> metadata)\n    */\n   public BrooklinEnvelope(@Nullable Object key, @Nullable Object value, @Nullable Object previousValue,\n       Map<String, String> metadata) {\n+    this(key, value, previousValue, null, metadata);\n+  }\n+\n+  /**\n+   * Construct a {@link BrooklinEnvelope} using record key, value, headers and metadata\n+   * @param key The record key (e.g. primary key)\n+   * @param value The new record value\n+   * @param previousValue The old record value\n+   * @param headers Kafka headers to associate with the change event\n+   * @param metadata Additional metadata to associate with the change event\n+   */\n+  public BrooklinEnvelope(@Nullable Object key, @Nullable Object value, @Nullable Object previousValue,", "originalCommit": "e920e7db391e6a1628924fcde9926c3a9140353d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY3MDU4OA==", "url": "https://github.com/linkedin/brooklin/pull/737#discussion_r466670588", "bodyText": "@ahmedahamid we don't need to actually. The ProducerRecord<> takes headers as an argument, so we don't need to modify our own LiDatastreamEvent or DatastreamEvent AFAIK", "author": "somandal", "createdAt": "2020-08-06T20:34:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY2OTQzMA=="}], "type": "inlineReview"}, {"oid": "5e13a95d79d478103b7abe7125d703634af557e7", "url": "https://github.com/linkedin/brooklin/commit/5e13a95d79d478103b7abe7125d703634af557e7", "message": "Minor improvements", "committedDate": "2020-08-06T21:33:28Z", "type": "commit"}]}