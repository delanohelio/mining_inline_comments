{"pr_number": 774, "pr_title": "Add preAssignmentCleanup in Coordinator and extend assignment strategy", "pr_createdAt": "2020-11-03T19:20:47Z", "pr_url": "https://github.com/linkedin/brooklin/pull/774", "timeline": [{"oid": "c31cd4a15cc8dd69b0a653dbe4201de934ea6d65", "url": "https://github.com/linkedin/brooklin/commit/c31cd4a15cc8dd69b0a653dbe4201de934ea6d65", "message": "Merge pull request #1 from linkedin/master\n\nPull latest", "committedDate": "2019-11-18T20:06:44Z", "type": "commit"}, {"oid": "79ffa91188aa16ebcb2e9c1e55d4b9a8911b9c36", "url": "https://github.com/linkedin/brooklin/commit/79ffa91188aa16ebcb2e9c1e55d4b9a8911b9c36", "message": "Merge branch 'master' of github.com:linkedin/brooklin", "committedDate": "2020-11-02T20:44:50Z", "type": "commit"}, {"oid": "0f33e4e600ce5ef837f603269fba4118e581b6b7", "url": "https://github.com/linkedin/brooklin/commit/0f33e4e600ce5ef837f603269fba4118e581b6b7", "message": "Add pre assignment cleanup to let the new leader perform cleanup before assignment if required", "committedDate": "2020-11-03T19:05:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMDMzNw==", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r516910337", "bodyText": "Maybe \"need to be validated\"?", "author": "jzakaryan", "createdAt": "2020-11-03T19:37:19Z", "path": "datastream-server-api/src/main/java/com/linkedin/datastream/server/api/strategy/AssignmentStrategy.java", "diffHunk": "@@ -89,4 +90,16 @@\n       Map<String, Set<String>> targetAssignment, DatastreamGroupPartitionsMetadata partitionsMetadata) {\n     throw new NotImplementedException(\"movePartitions are not implemented\");\n   }\n+\n+  /**\n+   * Validate the current assignment and return the list of DatastreamTask per instance to be cleaned up.\n+   *\n+   * @param datastreams all the datastreams for which the associated tasks to be validated", "originalCommit": "0f33e4e600ce5ef837f603269fba4118e581b6b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMzg3OA==", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r516913878", "bodyText": "Do you think we should turn on this feature by default without testing it in production?", "author": "jzakaryan", "createdAt": "2020-11-03T19:43:52Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/CoordinatorConfig.java", "diffHunk": "@@ -59,6 +61,7 @@ public CoordinatorConfig(Properties config) {\n     _defaultTransportProviderName = _properties.getString(CONFIG_DEFAULT_TRANSPORT_PROVIDER, \"\");\n     _zkCleanUpOrphanConnectorTask = _properties.getBoolean(CONFIG_ZK_CLEANUP_ORPHAN_CONNECTOR_TASK, false);\n     _zkCleanUpOrphanConnectorTaskLock = _properties.getBoolean(CONFIG_ZK_CLEANUP_ORPHAN_CONNECTOR_TASK_LOCK, false);\n+    _performPreAssignmentCleanup = _properties.getBoolean(CONFIG_PERFORM_PRE_ASSIGNMENT_CLEANUP, true);", "originalCommit": "0f33e4e600ce5ef837f603269fba4118e581b6b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxNDM1MQ==", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r517714351", "bodyText": "+1 we should definitely test this first", "author": "somandal", "createdAt": "2020-11-05T00:40:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMzg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzMDg3NA==", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r518430874", "bodyText": "From testing, you mean we should just identify and print them?", "author": "vmaheshw", "createdAt": "2020-11-05T23:23:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMzg3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODQzNzAwMg==", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r518437002", "bodyText": "No, at least I meant, let's disable this by default, enable it through config when testing in cert, and once it looks good, add the config to enable it everywhere.", "author": "somandal", "createdAt": "2020-11-05T23:41:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxMzg3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjkxNTYwNg==", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r516915606", "bodyText": "Nit: list of tasks\nAlso could be reworded to:\nIf a task is both in the dependency list as well as the current assignment list, it's possible that the previous leader went down before getting a chance to clean it up and update the zookeeper. This method identifies such tasks.", "author": "jzakaryan", "createdAt": "2020-11-03T19:47:09Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -268,6 +271,46 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n     return newAssignment;\n   }\n \n+  /**\n+   * This method checks the current assignment and returns the list of the task which are in the", "originalCommit": "0f33e4e600ce5ef837f603269fba4118e581b6b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxNjE4MA==", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r517716180", "bodyText": "nit: Reword: list of datastream tasks mapped by instance that need to be cleaned up.", "author": "somandal", "createdAt": "2020-11-05T00:46:52Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -268,6 +271,46 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n     return newAssignment;\n   }\n \n+  /**\n+   * This method checks the current assignment and returns the list of the task which are in the\n+   * dependency list as well as in current assignment. The logic is the task in the dependency list\n+   * cannot be present in the current assignment list. It is possible if the previous leader was\n+   * not able to complete the update on the zookeeper and the new leader gets the intermediate state\n+   * from the zookeeper.\n+   *\n+   * @param datastreamGroups datastream groups to associate the tasks with\n+   * @param currentAssignment existing assignment\n+   * @return List of datastreamTask per instance that needs to be cleaned up.", "originalCommit": "0f33e4e600ce5ef837f603269fba4118e581b6b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxNzcyMA==", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r517717720", "bodyText": "nit: rename tasksPerInstance to dependencyTasksPerInstance (since this is doing the actual filtering logic, and the final list consists of dependency tasks left behind in the assignment)", "author": "somandal", "createdAt": "2020-11-05T00:51:56Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -268,6 +271,46 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n     return newAssignment;\n   }\n \n+  /**\n+   * This method checks the current assignment and returns the list of the task which are in the\n+   * dependency list as well as in current assignment. The logic is the task in the dependency list\n+   * cannot be present in the current assignment list. It is possible if the previous leader was\n+   * not able to complete the update on the zookeeper and the new leader gets the intermediate state\n+   * from the zookeeper.\n+   *\n+   * @param datastreamGroups datastream groups to associate the tasks with\n+   * @param currentAssignment existing assignment\n+   * @return List of datastreamTask per instance that needs to be cleaned up.\n+   */\n+  public Map<String, List<DatastreamTask>> getTasksToCleanUp(List<DatastreamGroup> datastreamGroups,\n+      Map<String, Set<DatastreamTask>> currentAssignment) {\n+\n+    Set<String> datastreamGroupsSet = datastreamGroups.stream().map(DatastreamGroup::getTaskPrefix).collect(Collectors.toSet());\n+    Map<String, List<DatastreamTask>> tasksToCleanUp = new HashMap<>();\n+    // map of task name to DatastreamTask for future reference\n+    Map<String, DatastreamTask> assignmentsMap = currentAssignment.values()\n+        .stream()\n+        .flatMap(Collection::stream)\n+        .collect(Collectors.toMap(DatastreamTask::getDatastreamTaskName, Function.identity()));\n+\n+    for (String instance : currentAssignment.keySet()) {\n+      // find the dependency task which exists in the assignmentsMap as well.\n+      List<DatastreamTask> tasksPerInstance = currentAssignment.get(instance)", "originalCommit": "0f33e4e600ce5ef837f603269fba4118e581b6b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxNzkzNw==", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r517717937", "bodyText": "nit: Reword: find the dependency tasks which also exist in the current assignment list.", "author": "somandal", "createdAt": "2020-11-05T00:52:42Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -268,6 +271,46 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n     return newAssignment;\n   }\n \n+  /**\n+   * This method checks the current assignment and returns the list of the task which are in the\n+   * dependency list as well as in current assignment. The logic is the task in the dependency list\n+   * cannot be present in the current assignment list. It is possible if the previous leader was\n+   * not able to complete the update on the zookeeper and the new leader gets the intermediate state\n+   * from the zookeeper.\n+   *\n+   * @param datastreamGroups datastream groups to associate the tasks with\n+   * @param currentAssignment existing assignment\n+   * @return List of datastreamTask per instance that needs to be cleaned up.\n+   */\n+  public Map<String, List<DatastreamTask>> getTasksToCleanUp(List<DatastreamGroup> datastreamGroups,\n+      Map<String, Set<DatastreamTask>> currentAssignment) {\n+\n+    Set<String> datastreamGroupsSet = datastreamGroups.stream().map(DatastreamGroup::getTaskPrefix).collect(Collectors.toSet());\n+    Map<String, List<DatastreamTask>> tasksToCleanUp = new HashMap<>();\n+    // map of task name to DatastreamTask for future reference\n+    Map<String, DatastreamTask> assignmentsMap = currentAssignment.values()\n+        .stream()\n+        .flatMap(Collection::stream)\n+        .collect(Collectors.toMap(DatastreamTask::getDatastreamTaskName, Function.identity()));\n+\n+    for (String instance : currentAssignment.keySet()) {\n+      // find the dependency task which exists in the assignmentsMap as well.", "originalCommit": "0f33e4e600ce5ef837f603269fba4118e581b6b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcxOTc2Nw==", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r517719767", "bodyText": "Can we add a log to print the tasksToCleanUp and also the count? To keep the log readable, let's print only task names?\nFor debugging purposes it may be helpful to print the task names on which these tasks exist as dependencies. I'll leave it to you to assess if this can be useful though.", "author": "somandal", "createdAt": "2020-11-05T00:58:33Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/assignment/StickyPartitionAssignmentStrategy.java", "diffHunk": "@@ -268,6 +271,46 @@ public StickyPartitionAssignmentStrategy(Optional<Integer> maxTasks, Optional<In\n     return newAssignment;\n   }\n \n+  /**\n+   * This method checks the current assignment and returns the list of the task which are in the\n+   * dependency list as well as in current assignment. The logic is the task in the dependency list\n+   * cannot be present in the current assignment list. It is possible if the previous leader was\n+   * not able to complete the update on the zookeeper and the new leader gets the intermediate state\n+   * from the zookeeper.\n+   *\n+   * @param datastreamGroups datastream groups to associate the tasks with\n+   * @param currentAssignment existing assignment\n+   * @return List of datastreamTask per instance that needs to be cleaned up.\n+   */\n+  public Map<String, List<DatastreamTask>> getTasksToCleanUp(List<DatastreamGroup> datastreamGroups,\n+      Map<String, Set<DatastreamTask>> currentAssignment) {\n+\n+    Set<String> datastreamGroupsSet = datastreamGroups.stream().map(DatastreamGroup::getTaskPrefix).collect(Collectors.toSet());\n+    Map<String, List<DatastreamTask>> tasksToCleanUp = new HashMap<>();\n+    // map of task name to DatastreamTask for future reference\n+    Map<String, DatastreamTask> assignmentsMap = currentAssignment.values()\n+        .stream()\n+        .flatMap(Collection::stream)\n+        .collect(Collectors.toMap(DatastreamTask::getDatastreamTaskName, Function.identity()));\n+\n+    for (String instance : currentAssignment.keySet()) {\n+      // find the dependency task which exists in the assignmentsMap as well.\n+      List<DatastreamTask> tasksPerInstance = currentAssignment.get(instance)\n+          .stream()\n+          .filter(t -> datastreamGroupsSet.contains(t.getTaskPrefix()))\n+          .map(task -> ((DatastreamTaskImpl) task).getDependencies())\n+          .flatMap(Collection::stream)\n+          .map(assignmentsMap::get)\n+          .filter(Objects::nonNull)\n+          .collect(Collectors.toList());\n+\n+      if (!tasksPerInstance.isEmpty()) {\n+        tasksToCleanUp.put(instance, tasksPerInstance);\n+      }\n+    }\n+    return tasksToCleanUp;", "originalCommit": "0f33e4e600ce5ef837f603269fba4118e581b6b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzcyMDcwOA==", "url": "https://github.com/linkedin/brooklin/pull/774#discussion_r517720708", "bodyText": "Should we also validate that the tasksToCleanup only contains the tasks we expect it to by matching task names?", "author": "somandal", "createdAt": "2020-11-05T01:01:42Z", "path": "datastream-server/src/test/java/com/linkedin/datastream/server/assignment/TestStickyPartitionAssignment.java", "diffHunk": "@@ -87,11 +86,24 @@ public void testAddPartitions() {\n     DatastreamGroupPartitionsMetadata newPartitionsMetadata =\n         new DatastreamGroupPartitionsMetadata(datastreams.get(0), newPartitions);\n \n-    assignment = strategy.assignPartitions(assignment, newPartitionsMetadata);\n+    Map<String, Set<DatastreamTask>> newAssignment = strategy.assignPartitions(assignment, newPartitionsMetadata);\n \n-    for (DatastreamTask task : assignment.get(\"instance1\")) {\n+    for (DatastreamTask task : newAssignment.get(\"instance0\")) {\n       Assert.assertEquals(task.getPartitionsV2().size(), 2);\n     }\n+\n+    Map<String, List<DatastreamTask>> taskToCleanup = strategy.getTasksToCleanUp(datastreams, newAssignment);\n+    Assert.assertEquals(taskToCleanup.size(), 0);\n+\n+    // Adding the dependency task as well in the assignment list to simulate the scenario where\n+    // the dependency task nodes are not deleted and the leader gets interrupted, OOM or hit session expiry.\n+    // The next leader should be able to identify and cleanup.\n+    Map<String, Set<DatastreamTask>> finalAssignment = assignment;\n+    newAssignment.forEach((instance, taskSet1) -> taskSet1.addAll(finalAssignment.get(instance)));\n+\n+    taskToCleanup = strategy.getTasksToCleanUp(datastreams, newAssignment);\n+    Assert.assertEquals(taskToCleanup.size(), 1);\n+    taskToCleanup.forEach((instance, taskList1) -> Assert.assertEquals(taskList1.size(), 3));", "originalCommit": "0f33e4e600ce5ef837f603269fba4118e581b6b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2e308d8f5556cb4e8deae13a18d79ac6932a2187", "url": "https://github.com/linkedin/brooklin/commit/2e308d8f5556cb4e8deae13a18d79ac6932a2187", "message": "Address comments", "committedDate": "2020-11-06T05:33:17Z", "type": "commit"}, {"oid": "4bd8c4f213fee2a4da1857f2d3fdd6a29d37af1e", "url": "https://github.com/linkedin/brooklin/commit/4bd8c4f213fee2a4da1857f2d3fdd6a29d37af1e", "message": "Merge branch 'master' into fixStickPartitionAssignment", "committedDate": "2020-11-06T23:39:55Z", "type": "commit"}]}