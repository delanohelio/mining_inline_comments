{"pr_number": 701, "pr_title": "Fix broken Coordinator metrics", "pr_createdAt": "2020-04-14T09:28:51Z", "pr_url": "https://github.com/linkedin/brooklin/pull/701", "timeline": [{"oid": "5759512403b8791ae6ccd6d73502af73344ad3b0", "url": "https://github.com/linkedin/brooklin/commit/5759512403b8791ae6ccd6d73502af73344ad3b0", "message": "Fix broken Coordinator metrics\n\nThis change fixes a number of broken connector metrics that were\nnot being emitted to ingraphs because they were not included among\nthe metrics the Coordinator returned in Coordinator.getMetricInfos().\nThe fix changes the way metrics are registered and updated in the\nCoordinator to reduce the chances of developer oversight.", "committedDate": "2020-04-14T10:36:38Z", "type": "commit"}, {"oid": "5759512403b8791ae6ccd6d73502af73344ad3b0", "url": "https://github.com/linkedin/brooklin/commit/5759512403b8791ae6ccd6d73502af73344ad3b0", "message": "Fix broken Coordinator metrics\n\nThis change fixes a number of broken connector metrics that were\nnot being emitted to ingraphs because they were not included among\nthe metrics the Coordinator returned in Coordinator.getMetricInfos().\nThe fix changes the way metrics are registered and updated in the\nCoordinator to reduce the chances of developer oversight.", "committedDate": "2020-04-14T10:36:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2Mzk5Mg==", "url": "https://github.com/linkedin/brooklin/pull/701#discussion_r416963992", "bodyText": "typo: NUM_REBLANCES to NUM_REBALANCES", "author": "vmaheshw", "createdAt": "2020-04-28T22:33:40Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/Coordinator.java", "diffHunk": "@@ -1685,4 +1632,234 @@ ZkAdapter getZkAdapter() {\n   CoordinatorConfig getConfig() {\n     return _config;\n   }\n+\n+  /**\n+   * Encapsulates metric registration and update for the {@link Coordinator}\n+   */\n+  private static class CoordinatorMetrics {\n+    private static final String MODULE = Coordinator.class.getSimpleName();\n+\n+    private static final String NUM_RETRIES = \"numRetries\";\n+    private static final String NUM_ERRORS = \"numErrors\";\n+    private static final String HANDLE_EVENT_PREFIX = \"handleEvent\";\n+\n+    // Gauge metrics\n+    private static final String MAX_PARTITION_COUNT_IN_TASK = \"maxPartitionCountInTask\";\n+    private static final String NUM_PAUSED_DATASTREAMS_GROUPS = \"numPausedDatastreamsGroups\";\n+    private static final String IS_LEADER = \"isLeader\";\n+\n+    // Connector common metrics\n+    private static final String NUM_DATASTREAMS = \"numDatastreams\";\n+    private static final String NUM_DATASTREAM_TASKS = \"numDatastreamTasks\";\n+\n+    private final Coordinator _coordinator;\n+    private final List<BrooklinMetricInfo> _metricInfos;\n+    private final DynamicMetricsManager _dynamicMetricsManager;\n+\n+    public CoordinatorMetrics(Coordinator coordinator) {\n+      _coordinator = coordinator;\n+      _metricInfos = new ArrayList<>();\n+      _dynamicMetricsManager = DynamicMetricsManager.getInstance();\n+\n+      addComponentMetricInfos();\n+\n+      registerMeterMetrics();\n+      registerKeyedMeterMetrics();\n+      registerGaugeMetrics();\n+      registerCounterMetrics();\n+    }\n+\n+    public void addMetricInfos(MetricsAware metricsAware) {\n+      Optional.ofNullable(metricsAware.getMetricInfos()).ifPresent(_metricInfos::addAll);\n+    }\n+\n+    public void addConnectorMetrics(ConnectorInfo connectorInfo) {\n+      addMetricInfos(connectorInfo.getConnector().getConnectorInstance());\n+\n+      // Register common connector metrics\n+      // Use connector name for the metrics, as there can be multiple connectors specified in the config that use\n+      // same connector class.\n+      String connectorName = connectorInfo.getConnectorType();\n+\n+      _dynamicMetricsManager.registerGauge(connectorName, NUM_DATASTREAMS,\n+          () -> connectorInfo.getConnector().getNumDatastreams());\n+      _metricInfos.add(new BrooklinGaugeInfo(MetricRegistry.name(connectorName, NUM_DATASTREAMS)));\n+\n+      _dynamicMetricsManager.registerGauge(connectorName, NUM_DATASTREAM_TASKS,\n+          () -> connectorInfo.getConnector().getNumDatastreamTasks());\n+      _metricInfos.add(new BrooklinGaugeInfo(MetricRegistry.name(connectorName, NUM_DATASTREAM_TASKS)));\n+    }\n+\n+    public List<BrooklinMetricInfo> getMetricInfos() {\n+      return Collections.unmodifiableList(_metricInfos);\n+    }\n+\n+    public void updateMeter(Meter metric, int value) {\n+      _dynamicMetricsManager.createOrUpdateMeter(MODULE, metric.getName(), value);\n+    }\n+\n+    public void updateKeyedMeter(KeyedMeter metric, int value) {\n+      _dynamicMetricsManager.createOrUpdateMeter(MODULE, metric.getKey(), metric.getName(), value);\n+    }\n+\n+    public void updateCounter(Counter metric, int value) {\n+      _dynamicMetricsManager.createOrUpdateCounter(MODULE, metric.getName(), value);\n+    }\n+\n+    public static KeyedMeter getKeyedMeter(EventType eventType) {\n+      switch (eventType) {\n+        case LEADER_DO_ASSIGNMENT:\n+          return KeyedMeter.LEADER_DO_ASSIGNMENT_NUM_ERRORS;\n+        case LEADER_PARTITION_ASSIGNMENT:\n+          return KeyedMeter.LEADER_PARTITION_ASSIGNMENT_NUM_ERRORS;\n+        case LEADER_PARTITION_MOVEMENT:\n+          return KeyedMeter.LEADER_PARTITION_MOVEMENT_NUM_ERRORS;\n+        case HANDLE_ASSIGNMENT_CHANGE:\n+          return KeyedMeter.HANDLE_ASSIGNMENT_CHANGE_NUM_ERRORS;\n+        case HANDLE_DATASTREAM_CHANGE_WITH_UPDATE:\n+          return KeyedMeter.HANDLE_DATASTREAM_CHANGE_WITH_UPDATE_NUM_ERRORS;\n+        case HANDLE_ADD_OR_DELETE_DATASTREAM:\n+          return KeyedMeter.HANDLE_ADD_OR_DELETE_DATASTREAM_NUM_ERRORS;\n+        case HANDLE_INSTANCE_ERROR:\n+          return KeyedMeter.HANDLE_INSTANCE_ERROR_NUM_ERRORS;\n+        case HEARTBEAT:\n+          return KeyedMeter.HEARTBEAT_NUM_ERRORS;\n+        case NO_OP:\n+          return KeyedMeter.NO_OP_NUM_ERRORS;\n+        default:\n+          throw new IllegalArgumentException(\"Unexpected Coordinator event type: \" + eventType);\n+      }\n+    }\n+\n+    private void addComponentMetricInfos() {\n+      // CheckpointProvider metrics\n+      addMetricInfos(_coordinator._cpProvider);\n+\n+      // EventProducer metrics\n+      _metricInfos.addAll(EventProducer.getMetricInfos());\n+    }\n+\n+    private void registerMeterMetrics() {\n+      Arrays.stream(Meter.values()).forEach(this::registerMeter);\n+    }\n+\n+    private void registerKeyedMeterMetrics() {\n+      Arrays.stream(KeyedMeter.values()).forEach(this::registerKeyedMeter);\n+    }\n+\n+    private void registerGaugeMetrics() {\n+      ImmutableMap<String, Supplier<?>> gaugeMetrics = ImmutableMap.<String, Supplier<?>>builder()\n+          .put(MAX_PARTITION_COUNT_IN_TASK, MAX_PARTITION_COUNT::get)\n+          .put(NUM_PAUSED_DATASTREAMS_GROUPS, PAUSED_DATASTREAMS_GROUPS::get)\n+          .put(IS_LEADER, () -> _coordinator.getIsLeader().getAsBoolean() ? 1 : 0)\n+          .build();\n+      gaugeMetrics.forEach(this::registerGauge);\n+    }\n+\n+    private void registerCounterMetrics() {\n+      Arrays.stream(Counter.values()).forEach(this::registerCounter);\n+    }\n+\n+    private void registerMeter(Meter metric) {\n+      String metricName = metric.getName();\n+      _dynamicMetricsManager.registerMetric(MODULE, metricName, com.codahale.metrics.Meter.class);\n+      _metricInfos.add(new BrooklinMeterInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    private void registerKeyedMeter(KeyedMeter metric) {\n+      String metricName = metric.getName();\n+      _dynamicMetricsManager.registerMetric(MODULE, metric.getKey(), metricName, com.codahale.metrics.Meter.class);\n+      _metricInfos.add(new BrooklinMeterInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    private void registerGauge(String metricName, Supplier<?> valueSupplier) {\n+      _dynamicMetricsManager.registerGauge(MODULE, metricName, valueSupplier);\n+      _metricInfos.add(new BrooklinGaugeInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    private void registerCounter(Counter metric) {\n+      String metricName = metric.getName();\n+      _dynamicMetricsManager.registerMetric(MODULE, metricName, com.codahale.metrics.Counter.class);\n+      _metricInfos.add(new BrooklinCounterInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    /**\n+     * Coordinator metrics of type {@link com.codahale.metrics.Meter}\n+     */\n+    public enum Meter {\n+      NUM_REBLANCES(\"numRebalances\"),", "originalCommit": "5759512403b8791ae6ccd6d73502af73344ad3b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI1MDMzNA==", "url": "https://github.com/linkedin/brooklin/pull/701#discussion_r418250334", "bodyText": "Done. Thanks for the catch.", "author": "ahmedahamid", "createdAt": "2020-04-30T19:50:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2Mzk5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2NjIxOA==", "url": "https://github.com/linkedin/brooklin/pull/701#discussion_r416966218", "bodyText": "this should be \"handleEvent-\" to avoid regression. If this metrics is present in any dashboard, it will fail.", "author": "vmaheshw", "createdAt": "2020-04-28T22:39:31Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/Coordinator.java", "diffHunk": "@@ -1685,4 +1632,234 @@ ZkAdapter getZkAdapter() {\n   CoordinatorConfig getConfig() {\n     return _config;\n   }\n+\n+  /**\n+   * Encapsulates metric registration and update for the {@link Coordinator}\n+   */\n+  private static class CoordinatorMetrics {\n+    private static final String MODULE = Coordinator.class.getSimpleName();\n+\n+    private static final String NUM_RETRIES = \"numRetries\";\n+    private static final String NUM_ERRORS = \"numErrors\";\n+    private static final String HANDLE_EVENT_PREFIX = \"handleEvent\";", "originalCommit": "5759512403b8791ae6ccd6d73502af73344ad3b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI1MDg4OQ==", "url": "https://github.com/linkedin/brooklin/pull/701#discussion_r418250889", "bodyText": "I did that on purpose; this metric was broken anyways (not being emitted since it wasn't returned from getMetricInfos()) and a dash isn't common in metric names. Please, let me know if you still think I should fix it. cc: @somandal", "author": "ahmedahamid", "createdAt": "2020-04-30T19:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2NjIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTIxNDMxOQ==", "url": "https://github.com/linkedin/brooklin/pull/701#discussion_r419214319", "bodyText": "You can ignore it if it is not emitted. My only concern was regression, which is not the case.", "author": "vmaheshw", "createdAt": "2020-05-04T05:00:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk2NjIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MTE2Ng==", "url": "https://github.com/linkedin/brooklin/pull/701#discussion_r416971166", "bodyText": "do you need it to be public or can you change to package-private?", "author": "vmaheshw", "createdAt": "2020-04-28T22:52:11Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/Coordinator.java", "diffHunk": "@@ -1685,4 +1632,234 @@ ZkAdapter getZkAdapter() {\n   CoordinatorConfig getConfig() {\n     return _config;\n   }\n+\n+  /**\n+   * Encapsulates metric registration and update for the {@link Coordinator}\n+   */\n+  private static class CoordinatorMetrics {\n+    private static final String MODULE = Coordinator.class.getSimpleName();\n+\n+    private static final String NUM_RETRIES = \"numRetries\";\n+    private static final String NUM_ERRORS = \"numErrors\";\n+    private static final String HANDLE_EVENT_PREFIX = \"handleEvent\";\n+\n+    // Gauge metrics\n+    private static final String MAX_PARTITION_COUNT_IN_TASK = \"maxPartitionCountInTask\";\n+    private static final String NUM_PAUSED_DATASTREAMS_GROUPS = \"numPausedDatastreamsGroups\";\n+    private static final String IS_LEADER = \"isLeader\";\n+\n+    // Connector common metrics\n+    private static final String NUM_DATASTREAMS = \"numDatastreams\";\n+    private static final String NUM_DATASTREAM_TASKS = \"numDatastreamTasks\";\n+\n+    private final Coordinator _coordinator;\n+    private final List<BrooklinMetricInfo> _metricInfos;\n+    private final DynamicMetricsManager _dynamicMetricsManager;\n+\n+    public CoordinatorMetrics(Coordinator coordinator) {\n+      _coordinator = coordinator;\n+      _metricInfos = new ArrayList<>();\n+      _dynamicMetricsManager = DynamicMetricsManager.getInstance();\n+\n+      addComponentMetricInfos();\n+\n+      registerMeterMetrics();\n+      registerKeyedMeterMetrics();\n+      registerGaugeMetrics();\n+      registerCounterMetrics();\n+    }\n+\n+    public void addMetricInfos(MetricsAware metricsAware) {\n+      Optional.ofNullable(metricsAware.getMetricInfos()).ifPresent(_metricInfos::addAll);\n+    }\n+\n+    public void addConnectorMetrics(ConnectorInfo connectorInfo) {\n+      addMetricInfos(connectorInfo.getConnector().getConnectorInstance());\n+\n+      // Register common connector metrics\n+      // Use connector name for the metrics, as there can be multiple connectors specified in the config that use\n+      // same connector class.\n+      String connectorName = connectorInfo.getConnectorType();\n+\n+      _dynamicMetricsManager.registerGauge(connectorName, NUM_DATASTREAMS,\n+          () -> connectorInfo.getConnector().getNumDatastreams());\n+      _metricInfos.add(new BrooklinGaugeInfo(MetricRegistry.name(connectorName, NUM_DATASTREAMS)));\n+\n+      _dynamicMetricsManager.registerGauge(connectorName, NUM_DATASTREAM_TASKS,\n+          () -> connectorInfo.getConnector().getNumDatastreamTasks());\n+      _metricInfos.add(new BrooklinGaugeInfo(MetricRegistry.name(connectorName, NUM_DATASTREAM_TASKS)));\n+    }\n+\n+    public List<BrooklinMetricInfo> getMetricInfos() {\n+      return Collections.unmodifiableList(_metricInfos);\n+    }\n+\n+    public void updateMeter(Meter metric, int value) {\n+      _dynamicMetricsManager.createOrUpdateMeter(MODULE, metric.getName(), value);\n+    }\n+\n+    public void updateKeyedMeter(KeyedMeter metric, int value) {\n+      _dynamicMetricsManager.createOrUpdateMeter(MODULE, metric.getKey(), metric.getName(), value);\n+    }\n+\n+    public void updateCounter(Counter metric, int value) {\n+      _dynamicMetricsManager.createOrUpdateCounter(MODULE, metric.getName(), value);\n+    }\n+\n+    public static KeyedMeter getKeyedMeter(EventType eventType) {\n+      switch (eventType) {\n+        case LEADER_DO_ASSIGNMENT:\n+          return KeyedMeter.LEADER_DO_ASSIGNMENT_NUM_ERRORS;\n+        case LEADER_PARTITION_ASSIGNMENT:\n+          return KeyedMeter.LEADER_PARTITION_ASSIGNMENT_NUM_ERRORS;\n+        case LEADER_PARTITION_MOVEMENT:\n+          return KeyedMeter.LEADER_PARTITION_MOVEMENT_NUM_ERRORS;\n+        case HANDLE_ASSIGNMENT_CHANGE:\n+          return KeyedMeter.HANDLE_ASSIGNMENT_CHANGE_NUM_ERRORS;\n+        case HANDLE_DATASTREAM_CHANGE_WITH_UPDATE:\n+          return KeyedMeter.HANDLE_DATASTREAM_CHANGE_WITH_UPDATE_NUM_ERRORS;\n+        case HANDLE_ADD_OR_DELETE_DATASTREAM:\n+          return KeyedMeter.HANDLE_ADD_OR_DELETE_DATASTREAM_NUM_ERRORS;\n+        case HANDLE_INSTANCE_ERROR:\n+          return KeyedMeter.HANDLE_INSTANCE_ERROR_NUM_ERRORS;\n+        case HEARTBEAT:\n+          return KeyedMeter.HEARTBEAT_NUM_ERRORS;\n+        case NO_OP:\n+          return KeyedMeter.NO_OP_NUM_ERRORS;\n+        default:\n+          throw new IllegalArgumentException(\"Unexpected Coordinator event type: \" + eventType);\n+      }\n+    }\n+\n+    private void addComponentMetricInfos() {\n+      // CheckpointProvider metrics\n+      addMetricInfos(_coordinator._cpProvider);\n+\n+      // EventProducer metrics\n+      _metricInfos.addAll(EventProducer.getMetricInfos());\n+    }\n+\n+    private void registerMeterMetrics() {\n+      Arrays.stream(Meter.values()).forEach(this::registerMeter);\n+    }\n+\n+    private void registerKeyedMeterMetrics() {\n+      Arrays.stream(KeyedMeter.values()).forEach(this::registerKeyedMeter);\n+    }\n+\n+    private void registerGaugeMetrics() {\n+      ImmutableMap<String, Supplier<?>> gaugeMetrics = ImmutableMap.<String, Supplier<?>>builder()\n+          .put(MAX_PARTITION_COUNT_IN_TASK, MAX_PARTITION_COUNT::get)\n+          .put(NUM_PAUSED_DATASTREAMS_GROUPS, PAUSED_DATASTREAMS_GROUPS::get)\n+          .put(IS_LEADER, () -> _coordinator.getIsLeader().getAsBoolean() ? 1 : 0)\n+          .build();\n+      gaugeMetrics.forEach(this::registerGauge);\n+    }\n+\n+    private void registerCounterMetrics() {\n+      Arrays.stream(Counter.values()).forEach(this::registerCounter);\n+    }\n+\n+    private void registerMeter(Meter metric) {\n+      String metricName = metric.getName();\n+      _dynamicMetricsManager.registerMetric(MODULE, metricName, com.codahale.metrics.Meter.class);\n+      _metricInfos.add(new BrooklinMeterInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    private void registerKeyedMeter(KeyedMeter metric) {\n+      String metricName = metric.getName();\n+      _dynamicMetricsManager.registerMetric(MODULE, metric.getKey(), metricName, com.codahale.metrics.Meter.class);\n+      _metricInfos.add(new BrooklinMeterInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    private void registerGauge(String metricName, Supplier<?> valueSupplier) {\n+      _dynamicMetricsManager.registerGauge(MODULE, metricName, valueSupplier);\n+      _metricInfos.add(new BrooklinGaugeInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    private void registerCounter(Counter metric) {\n+      String metricName = metric.getName();\n+      _dynamicMetricsManager.registerMetric(MODULE, metricName, com.codahale.metrics.Counter.class);\n+      _metricInfos.add(new BrooklinCounterInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    /**\n+     * Coordinator metrics of type {@link com.codahale.metrics.Meter}\n+     */\n+    public enum Meter {\n+      NUM_REBLANCES(\"numRebalances\"),\n+      NUM_ASSIGNMENT_CHANGES(\"numAssignmentChanges\"),\n+      NUM_PARTITION_ASSIGNMENTS(\"numPartitionAssignments\"),\n+      NUM_PARTITION_MOVEMENTS(\"numPartitionMovements\");\n+\n+      private final String _name;\n+\n+      Meter(String name) {\n+        _name = name;\n+      }\n+\n+      public String getName() {", "originalCommit": "5759512403b8791ae6ccd6d73502af73344ad3b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI1NDU5Nw==", "url": "https://github.com/linkedin/brooklin/pull/701#discussion_r418254597", "bodyText": "I can actually change it to private if I want to; Java would still allow Coordinator to access private members of its inner classes. The reason I mark fields/methods/types public in inner types is declaration of intent; I'm communicating to the reader that this method is intended to be accessed outside this (inner) class. Additionally, that entire inner class, CoordinatorMetrics, that encapsulates these enums is marked private, so all the access modifiers on the fields/methods/types within it are practically only meant for documentation.\nThe same rationale applies to the next comment. I can still change it to package private though. Please, let me know what you think. cc: @somandal", "author": "ahmedahamid", "createdAt": "2020-04-30T19:58:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MTE2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODI2NzUwOQ==", "url": "https://github.com/linkedin/brooklin/pull/701#discussion_r418267509", "bodyText": "Relevant: I remember looking at this SO question a long while ago, and liking this answer:\n\nThis method can be made public in order to indicate that it's semantically public, despite the fact that compiler doesn't enforce visibility rules in this particular case.\nImagine that during some refactoring you need to make this inner class top-level. If this method is private, how would you decide whether it should be made public, or some more restrictive modifier should be used? Declaring method as public tells reader the intentions of original author - this method shouldn't be considered an implementation detail.\n\nIt's worth noting the top-voted answer said using public was \"nonsense\" (i.e. ineffective/inconsequential) nonetheless.", "author": "ahmedahamid", "createdAt": "2020-04-30T20:24:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3MTE2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjk3NDIxNQ==", "url": "https://github.com/linkedin/brooklin/pull/701#discussion_r416974215", "bodyText": "Do you need these enums to be public or can you change it to private?", "author": "vmaheshw", "createdAt": "2020-04-28T23:00:46Z", "path": "datastream-server/src/main/java/com/linkedin/datastream/server/Coordinator.java", "diffHunk": "@@ -1685,4 +1632,234 @@ ZkAdapter getZkAdapter() {\n   CoordinatorConfig getConfig() {\n     return _config;\n   }\n+\n+  /**\n+   * Encapsulates metric registration and update for the {@link Coordinator}\n+   */\n+  private static class CoordinatorMetrics {\n+    private static final String MODULE = Coordinator.class.getSimpleName();\n+\n+    private static final String NUM_RETRIES = \"numRetries\";\n+    private static final String NUM_ERRORS = \"numErrors\";\n+    private static final String HANDLE_EVENT_PREFIX = \"handleEvent\";\n+\n+    // Gauge metrics\n+    private static final String MAX_PARTITION_COUNT_IN_TASK = \"maxPartitionCountInTask\";\n+    private static final String NUM_PAUSED_DATASTREAMS_GROUPS = \"numPausedDatastreamsGroups\";\n+    private static final String IS_LEADER = \"isLeader\";\n+\n+    // Connector common metrics\n+    private static final String NUM_DATASTREAMS = \"numDatastreams\";\n+    private static final String NUM_DATASTREAM_TASKS = \"numDatastreamTasks\";\n+\n+    private final Coordinator _coordinator;\n+    private final List<BrooklinMetricInfo> _metricInfos;\n+    private final DynamicMetricsManager _dynamicMetricsManager;\n+\n+    public CoordinatorMetrics(Coordinator coordinator) {\n+      _coordinator = coordinator;\n+      _metricInfos = new ArrayList<>();\n+      _dynamicMetricsManager = DynamicMetricsManager.getInstance();\n+\n+      addComponentMetricInfos();\n+\n+      registerMeterMetrics();\n+      registerKeyedMeterMetrics();\n+      registerGaugeMetrics();\n+      registerCounterMetrics();\n+    }\n+\n+    public void addMetricInfos(MetricsAware metricsAware) {\n+      Optional.ofNullable(metricsAware.getMetricInfos()).ifPresent(_metricInfos::addAll);\n+    }\n+\n+    public void addConnectorMetrics(ConnectorInfo connectorInfo) {\n+      addMetricInfos(connectorInfo.getConnector().getConnectorInstance());\n+\n+      // Register common connector metrics\n+      // Use connector name for the metrics, as there can be multiple connectors specified in the config that use\n+      // same connector class.\n+      String connectorName = connectorInfo.getConnectorType();\n+\n+      _dynamicMetricsManager.registerGauge(connectorName, NUM_DATASTREAMS,\n+          () -> connectorInfo.getConnector().getNumDatastreams());\n+      _metricInfos.add(new BrooklinGaugeInfo(MetricRegistry.name(connectorName, NUM_DATASTREAMS)));\n+\n+      _dynamicMetricsManager.registerGauge(connectorName, NUM_DATASTREAM_TASKS,\n+          () -> connectorInfo.getConnector().getNumDatastreamTasks());\n+      _metricInfos.add(new BrooklinGaugeInfo(MetricRegistry.name(connectorName, NUM_DATASTREAM_TASKS)));\n+    }\n+\n+    public List<BrooklinMetricInfo> getMetricInfos() {\n+      return Collections.unmodifiableList(_metricInfos);\n+    }\n+\n+    public void updateMeter(Meter metric, int value) {\n+      _dynamicMetricsManager.createOrUpdateMeter(MODULE, metric.getName(), value);\n+    }\n+\n+    public void updateKeyedMeter(KeyedMeter metric, int value) {\n+      _dynamicMetricsManager.createOrUpdateMeter(MODULE, metric.getKey(), metric.getName(), value);\n+    }\n+\n+    public void updateCounter(Counter metric, int value) {\n+      _dynamicMetricsManager.createOrUpdateCounter(MODULE, metric.getName(), value);\n+    }\n+\n+    public static KeyedMeter getKeyedMeter(EventType eventType) {\n+      switch (eventType) {\n+        case LEADER_DO_ASSIGNMENT:\n+          return KeyedMeter.LEADER_DO_ASSIGNMENT_NUM_ERRORS;\n+        case LEADER_PARTITION_ASSIGNMENT:\n+          return KeyedMeter.LEADER_PARTITION_ASSIGNMENT_NUM_ERRORS;\n+        case LEADER_PARTITION_MOVEMENT:\n+          return KeyedMeter.LEADER_PARTITION_MOVEMENT_NUM_ERRORS;\n+        case HANDLE_ASSIGNMENT_CHANGE:\n+          return KeyedMeter.HANDLE_ASSIGNMENT_CHANGE_NUM_ERRORS;\n+        case HANDLE_DATASTREAM_CHANGE_WITH_UPDATE:\n+          return KeyedMeter.HANDLE_DATASTREAM_CHANGE_WITH_UPDATE_NUM_ERRORS;\n+        case HANDLE_ADD_OR_DELETE_DATASTREAM:\n+          return KeyedMeter.HANDLE_ADD_OR_DELETE_DATASTREAM_NUM_ERRORS;\n+        case HANDLE_INSTANCE_ERROR:\n+          return KeyedMeter.HANDLE_INSTANCE_ERROR_NUM_ERRORS;\n+        case HEARTBEAT:\n+          return KeyedMeter.HEARTBEAT_NUM_ERRORS;\n+        case NO_OP:\n+          return KeyedMeter.NO_OP_NUM_ERRORS;\n+        default:\n+          throw new IllegalArgumentException(\"Unexpected Coordinator event type: \" + eventType);\n+      }\n+    }\n+\n+    private void addComponentMetricInfos() {\n+      // CheckpointProvider metrics\n+      addMetricInfos(_coordinator._cpProvider);\n+\n+      // EventProducer metrics\n+      _metricInfos.addAll(EventProducer.getMetricInfos());\n+    }\n+\n+    private void registerMeterMetrics() {\n+      Arrays.stream(Meter.values()).forEach(this::registerMeter);\n+    }\n+\n+    private void registerKeyedMeterMetrics() {\n+      Arrays.stream(KeyedMeter.values()).forEach(this::registerKeyedMeter);\n+    }\n+\n+    private void registerGaugeMetrics() {\n+      ImmutableMap<String, Supplier<?>> gaugeMetrics = ImmutableMap.<String, Supplier<?>>builder()\n+          .put(MAX_PARTITION_COUNT_IN_TASK, MAX_PARTITION_COUNT::get)\n+          .put(NUM_PAUSED_DATASTREAMS_GROUPS, PAUSED_DATASTREAMS_GROUPS::get)\n+          .put(IS_LEADER, () -> _coordinator.getIsLeader().getAsBoolean() ? 1 : 0)\n+          .build();\n+      gaugeMetrics.forEach(this::registerGauge);\n+    }\n+\n+    private void registerCounterMetrics() {\n+      Arrays.stream(Counter.values()).forEach(this::registerCounter);\n+    }\n+\n+    private void registerMeter(Meter metric) {\n+      String metricName = metric.getName();\n+      _dynamicMetricsManager.registerMetric(MODULE, metricName, com.codahale.metrics.Meter.class);\n+      _metricInfos.add(new BrooklinMeterInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    private void registerKeyedMeter(KeyedMeter metric) {\n+      String metricName = metric.getName();\n+      _dynamicMetricsManager.registerMetric(MODULE, metric.getKey(), metricName, com.codahale.metrics.Meter.class);\n+      _metricInfos.add(new BrooklinMeterInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    private void registerGauge(String metricName, Supplier<?> valueSupplier) {\n+      _dynamicMetricsManager.registerGauge(MODULE, metricName, valueSupplier);\n+      _metricInfos.add(new BrooklinGaugeInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    private void registerCounter(Counter metric) {\n+      String metricName = metric.getName();\n+      _dynamicMetricsManager.registerMetric(MODULE, metricName, com.codahale.metrics.Counter.class);\n+      _metricInfos.add(new BrooklinCounterInfo(_coordinator.buildMetricName(MODULE, metricName)));\n+    }\n+\n+    /**\n+     * Coordinator metrics of type {@link com.codahale.metrics.Meter}\n+     */\n+    public enum Meter {", "originalCommit": "5759512403b8791ae6ccd6d73502af73344ad3b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "675891c12fec3aa50aa21d082c29584e2fbfe17c", "url": "https://github.com/linkedin/brooklin/commit/675891c12fec3aa50aa21d082c29584e2fbfe17c", "message": "Address PR review comments", "committedDate": "2020-04-30T19:49:07Z", "type": "commit"}]}