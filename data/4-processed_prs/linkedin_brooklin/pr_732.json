{"pr_number": 732, "pr_title": "Support for Kafka broker message format bump for passthrough BMM", "pr_createdAt": "2020-07-20T22:14:06Z", "pr_url": "https://github.com/linkedin/brooklin/pull/732", "timeline": [{"oid": "68a5a89651ae20d646a01ccc3443c39e903bd843", "url": "https://github.com/linkedin/brooklin/commit/68a5a89651ae20d646a01ccc3443c39e903bd843", "message": "Add support to extract magic byte from PassthroughConsumerRecord and store it in the BrooklinEnvelope metadata", "committedDate": "2020-07-20T21:14:44Z", "type": "commit"}, {"oid": "a08e43369d894ac0b2fc1414761e464a5c286c72", "url": "https://github.com/linkedin/brooklin/commit/a08e43369d894ac0b2fc1414761e464a5c286c72", "message": "Add producer side integration and add javadocs", "committedDate": "2020-07-20T22:11:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNzk0OA==", "url": "https://github.com/linkedin/brooklin/pull/732#discussion_r459137948", "bodyText": "This patch LGTM. Any reason, you want to convert this to a String and not use it as it is?", "author": "MayureshGharat", "createdAt": "2020-07-22T23:22:36Z", "path": "datastream-kafka-connector/src/main/java/com/linkedin/datastream/connectors/kafka/mirrormaker/KafkaMirrorMakerConnectorTask.java", "diffHunk": "@@ -241,6 +244,16 @@ protected DatastreamProducerRecord translate(ConsumerRecord<?, ?> fromKafka, Ins\n     String offsetStr = String.valueOf(offset);\n     metadata.put(KAFKA_ORIGIN_OFFSET, offsetStr);\n     metadata.put(BrooklinEnvelopeMetadataConstants.EVENT_TIMESTAMP, String.valueOf(eventsSourceTimestamp));\n+    if (Boolean.TRUE.toString()\n+        .equals(_datastream.getMetadata().get(KafkaDatastreamMetadataConstants.USE_PASSTHROUGH_COMPRESSION))) {\n+      // If passthrough mode is enabled, we need to create a Kafka header on the transport side for supporting\n+      // Kafka broker message format bump. The magic byte contains details about the message format for the passthrough\n+      // record and it needs to be preserved and set via the Kafka headers to ensure that the correct message format\n+      // can be negotiated.\n+      PassThroughConsumerRecord<?, ?> passThroughConsumerRecord = (PassThroughConsumerRecord<?, ?>) fromKafka;\n+      metadata.put(KafkaPassthroughRecordMagicConverter.PASS_THROUGH_MAGIC_VALUE,", "originalCommit": "a08e43369d894ac0b2fc1414761e464a5c286c72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzOTYwOA==", "url": "https://github.com/linkedin/brooklin/pull/732#discussion_r459139608", "bodyText": "@MayureshGharat we convert the ConsumerRecord to a DatastreamProducerRecord, and DatastreamProdcuerRecord has a list  of BrooklinEnvelope. BrooklinEnvelope has a generic field which stores all \"metadata\" and is a Map<String, String> . If I didn't convert the magic to String to store in this generic \"metadata\", I'd have to introduce a new field to store the magic as a byte. Which isn't a bad option, but this will only be used by BMM passthrough.\n@DEEPTHIKORAT and @jzakaryan can you folks also comment on whether using \"metadata\" and doing string conversion makes more sense, or it's okay to introduce this byte field to store the magic? The only use case would be BMM passthrough.", "author": "somandal", "createdAt": "2020-07-22T23:27:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNzk0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTYyMDU0MQ==", "url": "https://github.com/linkedin/brooklin/pull/732#discussion_r459620541", "bodyText": "Here's my two cents. @somandal I wouldn't introduce a \"magic\" byte as a separate field, because it only makes sense in the scope of BMM passthrough, and it would be useless and confusing out of that limited scope.\nThe only precaution with the current approach would be the conversion overhead, but since it's just being done once for a batch, it should be fine.", "author": "jzakaryan", "createdAt": "2020-07-23T17:43:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNzk0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY0OTM4OA==", "url": "https://github.com/linkedin/brooklin/pull/732#discussion_r459649388", "bodyText": "@jzakaryan thank you!", "author": "somandal", "createdAt": "2020-07-23T18:34:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTEzNzk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkxMjE3MA==", "url": "https://github.com/linkedin/brooklin/pull/732#discussion_r459912170", "bodyText": "nit: would it make sense to have a member field for isPassThrough to avoid checking this for each translate?", "author": "DEEPTHIKORAT", "createdAt": "2020-07-24T08:13:37Z", "path": "datastream-kafka-connector/src/main/java/com/linkedin/datastream/connectors/kafka/mirrormaker/KafkaMirrorMakerConnectorTask.java", "diffHunk": "@@ -241,6 +244,16 @@ protected DatastreamProducerRecord translate(ConsumerRecord<?, ?> fromKafka, Ins\n     String offsetStr = String.valueOf(offset);\n     metadata.put(KAFKA_ORIGIN_OFFSET, offsetStr);\n     metadata.put(BrooklinEnvelopeMetadataConstants.EVENT_TIMESTAMP, String.valueOf(eventsSourceTimestamp));\n+    if (Boolean.TRUE.toString()", "originalCommit": "a08e43369d894ac0b2fc1414761e464a5c286c72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2MzI0NA==", "url": "https://github.com/linkedin/brooklin/pull/732#discussion_r460163244", "bodyText": "done", "author": "somandal", "createdAt": "2020-07-24T16:35:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTkxMjE3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEyODY4Mg==", "url": "https://github.com/linkedin/brooklin/pull/732#discussion_r460128682", "bodyText": "Can it return a single byte instead? since we are using ISO-8 we can be sure not to get multiple bytes. Makes the APIs look consistent in the encode and decode with taking 1 byte and returning 1 byte.", "author": "DEEPTHIKORAT", "createdAt": "2020-07-24T15:33:41Z", "path": "datastream-kafka/src/main/java/com/linkedin/datastream/kafka/KafkaPassthroughRecordMagicConverter.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ *  Copyright 2020 LinkedIn Corporation. All rights reserved.\n+ *  Licensed under the BSD 2-Clause License. See the LICENSE file in the project root for license information.\n+ *  See the NOTICE file in the project root for additional information regarding copyright ownership.\n+ */\n+package com.linkedin.datastream.kafka;\n+\n+import java.io.UnsupportedEncodingException;\n+\n+import org.apache.kafka.common.header.internals.RecordHeader;\n+import org.apache.kafka.common.header.internals.RecordHeaders;\n+\n+import com.linkedin.datastream.common.DatastreamRuntimeException;\n+\n+\n+/**\n+ * This class is a utility class to convert the PassthroughConsumerRecord's magic() to a String, and back into byte.\n+ * It also adds a utility to create the RecordHeaders which can be used to pass headers with the magic set to the\n+ * ProducerRecord for passthrough message format bump support.\n+ */\n+public class KafkaPassthroughRecordMagicConverter {\n+  private static final String CHARSET = \"ISO-8859-1\";\n+\n+  public static final String PASS_THROUGH_MAGIC_VALUE = \"__passThroughMagicValue\";\n+\n+  /**\n+   * Convert the magic byte of the PassthroughConsumerRecord to a String\n+   */\n+  public static String convertMagicToString(byte magic) {\n+    try {\n+      return new String(new byte[] { magic }, CHARSET);\n+    } catch (UnsupportedEncodingException e) {\n+      throw new DatastreamRuntimeException(String.format(\"Cannot convert magic byte %02X to String\", magic), e);\n+    }\n+  }\n+\n+  /**\n+   * Convert the converted magic String back into a byte array\n+   */\n+  public static byte[] convertMagicStringToByteArray(String magic) {\n+    try {\n+      return magic.getBytes(CHARSET);", "originalCommit": "a08e43369d894ac0b2fc1414761e464a5c286c72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEzMzcwMw==", "url": "https://github.com/linkedin/brooklin/pull/732#discussion_r460133703", "bodyText": "oh nvm, looks like RecordHeader does require a byte array.", "author": "DEEPTHIKORAT", "createdAt": "2020-07-24T15:42:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEyODY4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2MzQ2Mg==", "url": "https://github.com/linkedin/brooklin/pull/732#discussion_r460163462", "bodyText": "yeah, that's why I decided to return a byte[] instead of byte.", "author": "somandal", "createdAt": "2020-07-24T16:35:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDEyODY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NzkxNw==", "url": "https://github.com/linkedin/brooklin/pull/732#discussion_r460147917", "bodyText": "nit and feel free to ignore, but the test might read better as a for loop iterating over all possibly magic byte values.", "author": "DEEPTHIKORAT", "createdAt": "2020-07-24T16:06:25Z", "path": "datastream-kafka/src/test/java/com/linkedin/datastream/kafka/TestKafkaPassthroughRecordMagicConverter.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/**\n+ *  Copyright 2020 LinkedIn Corporation. All rights reserved.\n+ *  Licensed under the BSD 2-Clause License. See the LICENSE file in the project root for license information.\n+ *  See the NOTICE file in the project root for additional information regarding copyright ownership.\n+ */\n+package com.linkedin.datastream.kafka;\n+\n+import org.apache.kafka.common.record.RecordBatch;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+\n+/**\n+ * Tests for {@link KafkaPassthroughRecordMagicConverter}.\n+ */\n+@Test\n+public class TestKafkaPassthroughRecordMagicConverter {\n+\n+  @Test\n+  public void testMagicConversion() {\n+    String magicValue0 = KafkaPassthroughRecordMagicConverter.convertMagicToString(RecordBatch.MAGIC_VALUE_V0);", "originalCommit": "a08e43369d894ac0b2fc1414761e464a5c286c72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE2MzUwNw==", "url": "https://github.com/linkedin/brooklin/pull/732#discussion_r460163507", "bodyText": "done", "author": "somandal", "createdAt": "2020-07-24T16:35:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NzkxNw=="}], "type": "inlineReview"}, {"oid": "31c73759c5efac3ecb65a6983a2246637ab5e6e5", "url": "https://github.com/linkedin/brooklin/commit/31c73759c5efac3ecb65a6983a2246637ab5e6e5", "message": "Address review comments", "committedDate": "2020-07-24T16:39:20Z", "type": "commit"}]}