{"pr_number": 2586, "pr_title": "(Closes #2510) Fix the true.type() == \"boolean\"", "pr_createdAt": "2020-04-24T07:42:44Z", "pr_url": "https://github.com/OpenRefine/OpenRefine/pull/2586", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc4NjQ4MA==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2586#discussion_r420786480", "bodyText": "I would remove this commented out line.", "author": "wetneb", "createdAt": "2020-05-06T13:24:11Z", "path": "main/tests/server/src/com/google/refine/expr/functions/TypeTests.java", "diffHunk": "@@ -26,15 +26,84 @@\n  ******************************************************************************/\n package com.google.refine.expr.functions;\n \n+import java.time.OffsetDateTime;\n+import java.time.format.DateTimeFormatter;\n+\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.BeforeTest;\n import org.testng.annotations.Test;\n \n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import com.google.refine.RefineTest;\n+import com.google.refine.expr.EvalError;\n import com.google.refine.expr.functions.Type;\n+import com.google.refine.grel.ControlFunctionRegistry;\n+import com.google.refine.grel.Function;\n import com.google.refine.util.TestUtils;\n \n-public class TypeTests {\n+\n+public class TypeTests extends RefineTest {\n+    private static Properties bindings;\n+    static final List<String> listArray = Arrays.asList(\"v1\", \"v2\", \"v3\");\n+    private static OffsetDateTime dateTimeValue = OffsetDateTime.parse(\"2017-05-12T05:45:00+00:00\", DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n+\n+    @Override\n+    @BeforeTest\n+    public void init() {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+    }\n+    \n+    @BeforeMethod\n+    public void setUp() {\n+        bindings = new Properties();\n+    }\n+\n+    @AfterMethod\n+    public void tearDown() {\n+        bindings = null;\n+    }\n+    \n+    /**\n+     * Lookup a control function by name and invoke it with a variable number of args\n+     */\n+    private static Object invoke(String name,Object... args) {\n+        // registry uses static initializer, so no need to set it up\n+        Function function = ControlFunctionRegistry.getFunction(name);\n+        if (function == null) {\n+            throw new IllegalArgumentException(\"Unknown function \"+name);\n+        }\n+        if (args == null) {\n+            return function.call(bindings,new Object[0]);\n+        } else {\n+            return function.call(bindings,args);\n+        }\n+    }\n+    \n+    @Test\n+    public void testTypeInvalidParams() {\n+        Assert.assertTrue(invoke(\"type\") instanceof EvalError);\n+    }\n+    \n+    @Test\n+    public void testType() {\n+        Assert.assertEquals(invoke(\"type\", (Object) null),\"undefined\");\n+        Assert.assertEquals(invoke(\"type\", 1),\"number\");\n+        Assert.assertEquals(invoke(\"type\", true),\"boolean\");\n+        Assert.assertEquals(invoke(\"type\", \"a string\"),\"string\");\n+        Assert.assertEquals(invoke(\"type\", dateTimeValue), \"date\");\n+        Assert.assertEquals(invoke(\"type\", listArray), \"array\");\n+//        Assert.assertEquals(invoke(\"type\", error), \"error\");", "originalCommit": "ed61882959974466e83fefb71b41380a56c436dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM2MTAwOQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2586#discussion_r426361009", "bodyText": "Done.", "author": "antoine2711", "createdAt": "2020-05-18T04:14:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc4NjQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI1NjAzMQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2586#discussion_r422256031", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                }    \n          \n          \n            \n                }", "author": "tfmorris", "createdAt": "2020-05-08T16:58:37Z", "path": "main/tests/server/src/com/google/refine/expr/functions/TypeTests.java", "diffHunk": "@@ -26,16 +26,82 @@\n  ******************************************************************************/\n package com.google.refine.expr.functions;\n \n+import java.time.OffsetDateTime;\n+import java.time.format.DateTimeFormatter;\n+\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.BeforeTest;\n import org.testng.annotations.Test;\n \n+import java.util.Properties;\n+\n+import com.google.refine.RefineTest;\n+import com.google.refine.expr.EvalError;\n import com.google.refine.expr.functions.Type;\n+import com.google.refine.grel.ControlFunctionRegistry;\n+import com.google.refine.grel.Function;\n import com.google.refine.util.TestUtils;\n \n-public class TypeTests {\n+\n+public class TypeTests extends RefineTest {\n+    private static Properties bindings;\n+    private static final Integer[] ZERO_TO_TWO = new Integer[] {0, 1, 2};\n+    private static OffsetDateTime dateTimeValue = OffsetDateTime.parse(\"2017-05-12T05:45:00+00:00\", DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n+\n+    @Override\n+    @BeforeTest\n+    public void init() {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+    }\n+    \n+    @BeforeMethod\n+    public void setUp() {\n+        bindings = new Properties();\n+    }\n+\n+    @AfterMethod\n+    public void tearDown() {\n+        bindings = null;\n+    }\n+    \n+    /**\n+     * Lookup a control function by name and invoke it with a variable number of args\n+     */\n+    private static Object invoke(String name,Object... args) {\n+        // registry uses static initializer, so no need to set it up\n+        Function function = ControlFunctionRegistry.getFunction(name);\n+        if (function == null) {\n+            throw new IllegalArgumentException(\"Unknown function \"+name);\n+        }\n+        if (args == null) {\n+            return function.call(bindings,new Object[0]);\n+        } else {\n+            return function.call(bindings,args);\n+        }\n+    }\n+    \n+    @Test\n+    public void testTypeInvalidParams() {\n+        Assert.assertTrue(invoke(\"type\") instanceof EvalError);\n+    }\n+    \n+    @Test\n+    public void testType() {\n+        Assert.assertEquals(invoke(\"type\", (Object) null),\"undefined\");\n+        Assert.assertEquals(invoke(\"type\", 1),\"number\");\n+        Assert.assertEquals(invoke(\"type\", true),\"boolean\");\n+        Assert.assertEquals(invoke(\"type\", \"a string\"),\"string\");\n+        Assert.assertEquals(invoke(\"type\", dateTimeValue), \"date\");\n+//        Assert.assertEquals(invoke(\"type\", error), \"error\");\n+    }\n+    \n     @Test\n     public void serializeType() {\n         String json = \"{\\\"description\\\":\\\"Returns the type of o as a string ('string', 'date', 'number', 'array', 'boolean', 'error' or a class name)\\\",\\\"params\\\":\\\"object o\\\",\\\"returns\\\":\\\"string\\\"}\";\n         TestUtils.isSerializedTo(new Type(), json);\n-    }\n+    }    ", "originalCommit": "d12326094ba25f57d027b2b40cd83e0dd3bd1566", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI1OTMxMg==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2586#discussion_r422259312", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return \"Returns the type of o as a string ('string', 'date', 'number', 'array', 'boolean', 'error' or a class name)\";\n          \n          \n            \n                    return \"Returns the type of o as a string ('string', 'date', 'number', 'array', or 'boolean'). The string 'error' is returned if the value can't be evaluated\";\n          \n      \n    \n    \n  \n\nNow that the bug is fixed, can it ever return a Java class name? I'd be tempted to just pare this down to simply \"Returns the type of o as a string.\"", "author": "tfmorris", "createdAt": "2020-05-08T17:05:06Z", "path": "main/src/com/google/refine/expr/functions/Type.java", "diffHunk": "@@ -70,7 +72,7 @@ public Object call(Properties bindings, Object[] args) {\n \n     @Override\n     public String getDescription() {\n-        return \"Returns the type of o\";\n+        return \"Returns the type of o as a string ('string', 'date', 'number', 'array', 'boolean', 'error' or a class name)\";", "originalCommit": "ed61882959974466e83fefb71b41380a56c436dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDcwNzI0Ng==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2586#discussion_r424707246", "bodyText": "Now that the bug is fixed, can it ever return a Java class name? I'd be tempted to just pare this down to simply \"Returns the type of o as a string.\"\n\n@tfmorris: the question you raise is far more complex, from what I see. In Issue \u00ab\ntrue.type() return \u00ab java.lang.Boolean \u00bb and not \u00ab boolean \u00bb\n#2510 \u00bb, you will find some discussion on that, but here's a table I did:\n\n\n\nExpression\nResult\nExpected result\n\n\n\n\nrow.type()\ncom.google.refine.expr.WrappedRow\n\"object: row\"\n\n\nrow.record.type()\ncom.google.refine.expr.WrappedRow$WrappedRecord\n\"object: record\"\n\n\ncell.type()\ncom.google.refine.expr.WrappedCell\n\"object: cell\"\n\n\ncells.type()\ncom.google.refine.expr.CellTuple\n\"object: cells\"\n\n\ncell.recon.features.type()\ncom.google.refine.model.Recon$Features\n\"object: features\"\n\n\nrow.record.cells.type()\ncom.google.refine.expr.WrappedRow$RecordCells\n\"object: cells\"\n\n\n\nBecause in the code, we have this: return v.getClass().getName(), we can never be sure of all the value that can be returned. I guess the only thing we can be sure it's that it's going to be a string\u2026\n                } else if (v instanceof EvalError) {\n                    return \"error\";\n                } else {\n                    return v.getClass().getName();\n                }\n\nI think we should close this issue, and maybe open another one on how to return a type from an object. By closing this issue, we finalize the type() function with basic datatypes.\nFor this particular change you suggest: \u00ab\u00a0The string 'error' is returned if the value can't be evaluated\"; \u00bb, I wouldn't write that because I don't believe it's accurate. Imagine the case of use type(value), where value contains a previous stored error. But this discussion should be in issue \u00ab type(an error) should return the string \"error\" like the code was designed to do but is buggy #2562 \u00bb. Do you share this opinion?\nRegards, Antoine", "author": "antoine2711", "createdAt": "2020-05-13T20:19:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI1OTMxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg5MzI4Nw==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2586#discussion_r426893287", "bodyText": "Marking this as resolved. As discussed elsewhere, evaluation errors happen before ever reaching this function.", "author": "tfmorris", "createdAt": "2020-05-18T21:06:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI1OTMxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI1OTYyMQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2586#discussion_r422259621", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            //        Assert.assertEquals(invoke(\"type\", error), \"error\");", "author": "tfmorris", "createdAt": "2020-05-08T17:05:45Z", "path": "main/tests/server/src/com/google/refine/expr/functions/TypeTests.java", "diffHunk": "@@ -26,15 +26,84 @@\n  ******************************************************************************/\n package com.google.refine.expr.functions;\n \n+import java.time.OffsetDateTime;\n+import java.time.format.DateTimeFormatter;\n+\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.BeforeTest;\n import org.testng.annotations.Test;\n \n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import com.google.refine.RefineTest;\n+import com.google.refine.expr.EvalError;\n import com.google.refine.expr.functions.Type;\n+import com.google.refine.grel.ControlFunctionRegistry;\n+import com.google.refine.grel.Function;\n import com.google.refine.util.TestUtils;\n \n-public class TypeTests {\n+\n+public class TypeTests extends RefineTest {\n+    private static Properties bindings;\n+    static final List<String> listArray = Arrays.asList(\"v1\", \"v2\", \"v3\");\n+    private static OffsetDateTime dateTimeValue = OffsetDateTime.parse(\"2017-05-12T05:45:00+00:00\", DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n+\n+    @Override\n+    @BeforeTest\n+    public void init() {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+    }\n+    \n+    @BeforeMethod\n+    public void setUp() {\n+        bindings = new Properties();\n+    }\n+\n+    @AfterMethod\n+    public void tearDown() {\n+        bindings = null;\n+    }\n+    \n+    /**\n+     * Lookup a control function by name and invoke it with a variable number of args\n+     */\n+    private static Object invoke(String name,Object... args) {\n+        // registry uses static initializer, so no need to set it up\n+        Function function = ControlFunctionRegistry.getFunction(name);\n+        if (function == null) {\n+            throw new IllegalArgumentException(\"Unknown function \"+name);\n+        }\n+        if (args == null) {\n+            return function.call(bindings,new Object[0]);\n+        } else {\n+            return function.call(bindings,args);\n+        }\n+    }\n+    \n+    @Test\n+    public void testTypeInvalidParams() {\n+        Assert.assertTrue(invoke(\"type\") instanceof EvalError);\n+    }\n+    \n+    @Test\n+    public void testType() {\n+        Assert.assertEquals(invoke(\"type\", (Object) null),\"undefined\");\n+        Assert.assertEquals(invoke(\"type\", 1),\"number\");\n+        Assert.assertEquals(invoke(\"type\", true),\"boolean\");\n+        Assert.assertEquals(invoke(\"type\", \"a string\"),\"string\");\n+        Assert.assertEquals(invoke(\"type\", dateTimeValue), \"date\");\n+        Assert.assertEquals(invoke(\"type\", listArray), \"array\");\n+//        Assert.assertEquals(invoke(\"type\", error), \"error\");", "originalCommit": "ed61882959974466e83fefb71b41380a56c436dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM2MTIwMA==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2586#discussion_r426361200", "bodyText": "Done.", "author": "antoine2711", "createdAt": "2020-05-18T04:15:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI1OTYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI1OTg0Ng==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2586#discussion_r422259846", "bodyText": "Fix test to match above.", "author": "tfmorris", "createdAt": "2020-05-08T17:06:16Z", "path": "main/tests/server/src/com/google/refine/expr/functions/TypeTests.java", "diffHunk": "@@ -26,15 +26,84 @@\n  ******************************************************************************/\n package com.google.refine.expr.functions;\n \n+import java.time.OffsetDateTime;\n+import java.time.format.DateTimeFormatter;\n+\n+import org.slf4j.LoggerFactory;\n+import org.testng.Assert;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.BeforeTest;\n import org.testng.annotations.Test;\n \n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Properties;\n+\n+import com.google.refine.RefineTest;\n+import com.google.refine.expr.EvalError;\n import com.google.refine.expr.functions.Type;\n+import com.google.refine.grel.ControlFunctionRegistry;\n+import com.google.refine.grel.Function;\n import com.google.refine.util.TestUtils;\n \n-public class TypeTests {\n+\n+public class TypeTests extends RefineTest {\n+    private static Properties bindings;\n+    static final List<String> listArray = Arrays.asList(\"v1\", \"v2\", \"v3\");\n+    private static OffsetDateTime dateTimeValue = OffsetDateTime.parse(\"2017-05-12T05:45:00+00:00\", DateTimeFormatter.ISO_OFFSET_DATE_TIME);\n+\n+    @Override\n+    @BeforeTest\n+    public void init() {\n+        logger = LoggerFactory.getLogger(this.getClass());\n+    }\n+    \n+    @BeforeMethod\n+    public void setUp() {\n+        bindings = new Properties();\n+    }\n+\n+    @AfterMethod\n+    public void tearDown() {\n+        bindings = null;\n+    }\n+    \n+    /**\n+     * Lookup a control function by name and invoke it with a variable number of args\n+     */\n+    private static Object invoke(String name,Object... args) {\n+        // registry uses static initializer, so no need to set it up\n+        Function function = ControlFunctionRegistry.getFunction(name);\n+        if (function == null) {\n+            throw new IllegalArgumentException(\"Unknown function \"+name);\n+        }\n+        if (args == null) {\n+            return function.call(bindings,new Object[0]);\n+        } else {\n+            return function.call(bindings,args);\n+        }\n+    }\n+    \n+    @Test\n+    public void testTypeInvalidParams() {\n+        Assert.assertTrue(invoke(\"type\") instanceof EvalError);\n+    }\n+    \n+    @Test\n+    public void testType() {\n+        Assert.assertEquals(invoke(\"type\", (Object) null),\"undefined\");\n+        Assert.assertEquals(invoke(\"type\", 1),\"number\");\n+        Assert.assertEquals(invoke(\"type\", true),\"boolean\");\n+        Assert.assertEquals(invoke(\"type\", \"a string\"),\"string\");\n+        Assert.assertEquals(invoke(\"type\", dateTimeValue), \"date\");\n+        Assert.assertEquals(invoke(\"type\", listArray), \"array\");\n+//        Assert.assertEquals(invoke(\"type\", error), \"error\");\n+    }\n+    \n     @Test\n     public void serializeType() {\n-        String json = \"{\\\"description\\\":\\\"Returns the type of o\\\",\\\"params\\\":\\\"object o\\\",\\\"returns\\\":\\\"string\\\"}\";\n+        String json = \"{\\\"description\\\":\\\"Returns the type of o as a string ('string', 'date', 'number', 'array', 'boolean', 'error' or a class name)\\\",\\\"params\\\":\\\"object o\\\",\\\"returns\\\":\\\"string\\\"}\";", "originalCommit": "ed61882959974466e83fefb71b41380a56c436dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0OTU0OQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2586#discussion_r422349549", "bodyText": "@tfmorris: Is what to be understood here is that type(an error) will only return \"error\" for certains types of errors? And if so, shouldn't it be documented which error are trap and which one are \u00ab\u00a0reraised\u00a0\u00bb?\nRegards, Antoine", "author": "antoine2711", "createdAt": "2020-05-08T20:10:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI1OTg0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjU5ODM1OQ==", "url": "https://github.com/OpenRefine/OpenRefine/pull/2586#discussion_r422598359", "bodyText": "@tfmorris: I also think this should be taken in consideration with PR #2562.\nIn particular, if isError(aParticularValue) == true, then type(aParticularValue) == \"error\" should be true.\nRegards, A.", "author": "antoine2711", "createdAt": "2020-05-10T06:57:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjI1OTg0Ng=="}], "type": "inlineReview"}, {"oid": "0e86619d86ffc98f9482f822cc4fa255091c44ef", "url": "https://github.com/OpenRefine/OpenRefine/commit/0e86619d86ffc98f9482f822cc4fa255091c44ef", "message": "Fix the true.type() == \"boolean\"\n\nFix the true.type() == \"boolean\" instead of java.lang.Boolean.\n\nRemove all the references to \"error\" result  in Type(). This will be addressed in:\n@ToDo fix this with issue #2562", "committedDate": "2020-05-18T21:23:43Z", "type": "commit"}, {"oid": "0e86619d86ffc98f9482f822cc4fa255091c44ef", "url": "https://github.com/OpenRefine/OpenRefine/commit/0e86619d86ffc98f9482f822cc4fa255091c44ef", "message": "Fix the true.type() == \"boolean\"\n\nFix the true.type() == \"boolean\" instead of java.lang.Boolean.\n\nRemove all the references to \"error\" result  in Type(). This will be addressed in:\n@ToDo fix this with issue #2562", "committedDate": "2020-05-18T21:23:43Z", "type": "forcePushed"}]}