{"pr_number": 1804, "pr_title": "[SCB-1971] Introduce SPI mechanism to enable/disable zero-config and \u2026", "pr_createdAt": "2020-06-01T01:30:53Z", "pr_url": "https://github.com/apache/servicecomb-java-chassis/pull/1804", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAxNzQwNQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1804#discussion_r433017405", "bodyText": "For zero config, Discovery and Registration must be enabled/disable togather. So it's better to use servicecomb.zeroconfig.registry.enabled. I'll modify other modules later.", "author": "liubao68", "createdAt": "2020-06-01T02:26:19Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/ZeroConfigDiscovery.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.zeroconfig;\n+\n+import com.netflix.config.DynamicPropertyFactory;\n+import java.util.Collection;\n+import java.util.List;\n+import org.apache.servicecomb.registry.api.Discovery;\n+import org.apache.servicecomb.registry.api.registry.Microservice;\n+import org.apache.servicecomb.registry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.registry.api.registry.MicroserviceInstances;\n+import org.apache.servicecomb.zeroconfig.client.ZeroConfigClient;\n+\n+public class ZeroConfigDiscovery implements Discovery {\n+\n+  private static final String NAME = \"zero-config discovery\";\n+  private static final String ENABLED = \"servicecomb.zeroconfig.registry.discovery.enabled\";", "originalCommit": "66b0708881ca3991c71d30ccac9398560e33890c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAyNDI2Mg==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1804#discussion_r433024262", "bodyText": "will just define this variable once in the Constant class/interface", "author": "jungan21", "createdAt": "2020-06-01T03:09:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAxNzQwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAxNzc3MA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1804#discussion_r433017770", "bodyText": "This can return null in future. Loading schema from instance will the core process, and this change is in progress, so can keep this code here for temporary usage. Maybe add a TODO is better.", "author": "liubao68", "createdAt": "2020-06-01T02:28:47Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/ZeroConfigDiscovery.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.zeroconfig;\n+\n+import com.netflix.config.DynamicPropertyFactory;\n+import java.util.Collection;\n+import java.util.List;\n+import org.apache.servicecomb.registry.api.Discovery;\n+import org.apache.servicecomb.registry.api.registry.Microservice;\n+import org.apache.servicecomb.registry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.registry.api.registry.MicroserviceInstances;\n+import org.apache.servicecomb.zeroconfig.client.ZeroConfigClient;\n+\n+public class ZeroConfigDiscovery implements Discovery {\n+\n+  private static final String NAME = \"zero-config discovery\";\n+  private static final String ENABLED = \"servicecomb.zeroconfig.registry.discovery.enabled\";\n+\n+  private ZeroConfigClient zeroConfigClient = ZeroConfigClient.INSTANCE;\n+  private String revision;\n+\n+  @Override\n+  public boolean enabled() {\n+    return DynamicPropertyFactory.getInstance().getBooleanProperty(ENABLED, true).get();\n+  }\n+\n+  @Override\n+  public void init() {\n+    // done in registration\n+  }\n+\n+  @Override\n+  public void run() {\n+    // done in registration\n+  }\n+\n+  @Override\n+  public void destroy() {\n+    // done in registration\n+  }\n+\n+  @Override\n+  public int getOrder() {\n+    return 101;\n+  }\n+\n+  @Override\n+  public Microservice getMicroservice(String microserviceId) {\n+    return zeroConfigClient.getMicroservice(microserviceId);\n+  }\n+\n+  @Override\n+  public List<Microservice> getAllMicroservices() {\n+    return zeroConfigClient.getAllMicroservices();\n+  }\n+\n+  @Override\n+  public String getSchema(String microserviceId, Collection<MicroserviceInstance> instances,\n+      String schemaId) {\n+    return zeroConfigClient.getSchema(microserviceId, schemaId);", "originalCommit": "66b0708881ca3991c71d30ccac9398560e33890c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAyNDIyNQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1804#discussion_r433024225", "bodyText": "wil add // TODO comment", "author": "jungan21", "createdAt": "2020-06-01T03:08:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAxNzc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAxODQ1MA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1804#discussion_r433018450", "bodyText": "Constructor is better to be private for singletan. And add a method with @VisibleForTesting to create new ZeroConfigClient instance.", "author": "liubao68", "createdAt": "2020-06-01T02:33:16Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/client/ZeroConfigClient.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.zeroconfig.client;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.servicecomb.registry.api.registry.FindInstancesResponse;\n+import org.apache.servicecomb.registry.api.registry.Microservice;\n+import org.apache.servicecomb.registry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.registry.api.registry.MicroserviceInstances;\n+import org.apache.servicecomb.registry.version.Version;\n+import org.apache.servicecomb.registry.version.VersionRule;\n+import org.apache.servicecomb.registry.version.VersionRuleUtils;\n+import org.apache.servicecomb.registry.version.VersionUtils;\n+import org.apache.servicecomb.zeroconfig.ZeroConfigRegistration;\n+import org.apache.servicecomb.zeroconfig.server.ServerMicroserviceInstance;\n+import org.apache.servicecomb.zeroconfig.server.ServerUtil;\n+import org.apache.servicecomb.zeroconfig.server.ZeroConfigRegistryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.web.client.RestTemplate;\n+\n+import static org.apache.servicecomb.zeroconfig.ZeroConfigRegistryConstants.*;\n+\n+public class ZeroConfigClient {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ZeroConfigClient.class);\n+\n+  public static ZeroConfigClient INSTANCE = buildZeroConfigClient();\n+\n+  // Constructor Parameters\n+  private ZeroConfigRegistryService zeroConfigRegistryService;\n+  private RestTemplate restTemplate;\n+  private MulticastSocket multicastSocket;\n+\n+  // Constructor\n+  public ZeroConfigClient(ZeroConfigRegistryService zeroConfigRegistryService,", "originalCommit": "66b0708881ca3991c71d30ccac9398560e33890c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAyNDE4Nw==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1804#discussion_r433024187", "bodyText": "ok", "author": "jungan21", "createdAt": "2020-06-01T03:08:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAxODQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAyMDU2Nw==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1804#discussion_r433020567", "bodyText": "Maybe @VisibleForTesting?", "author": "liubao68", "createdAt": "2020-06-01T02:46:40Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/ZeroConfigRegistration.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.zeroconfig;\n+\n+import com.netflix.config.DynamicPropertyFactory;\n+import java.util.Collection;\n+import org.apache.servicecomb.config.ConfigUtil;\n+import org.apache.servicecomb.config.archaius.sources.MicroserviceConfigLoader;\n+import org.apache.servicecomb.registry.api.Registration;\n+import org.apache.servicecomb.registry.api.registry.BasePath;\n+import org.apache.servicecomb.registry.api.registry.Microservice;\n+import org.apache.servicecomb.registry.api.registry.MicroserviceFactory;\n+import org.apache.servicecomb.registry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.registry.api.registry.MicroserviceInstanceStatus;\n+import org.apache.servicecomb.registry.definition.MicroserviceDefinition;\n+import org.apache.servicecomb.zeroconfig.client.ClientUtil;\n+import org.apache.servicecomb.zeroconfig.client.ZeroConfigClient;\n+import org.apache.servicecomb.zeroconfig.server.ServerUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ZeroConfigRegistration implements Registration {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ZeroConfigRegistration.class);\n+\n+  public static ZeroConfigRegistration INSTANCE = new ZeroConfigRegistration();\n+\n+  private static final String NAME = \"zero-config registration\";\n+  private static final String ENABLED = \"servicecomb.zeroconfig.registry.registration.enabled\";\n+\n+  private ZeroConfigClient zeroConfigClient = ZeroConfigClient.INSTANCE;\n+\n+  // registration objects\n+  private Microservice selfMicroservice;\n+  private MicroserviceInstance selfMicroserviceInstance;\n+\n+  @Override\n+  public boolean enabled() {\n+    return DynamicPropertyFactory.getInstance().getBooleanProperty(ENABLED, true).get();\n+  }\n+\n+  @Override\n+  public void init() {\n+    // init self Microservice & MicroserviceInstance objects\n+    MicroserviceConfigLoader loader = ConfigUtil.getMicroserviceConfigLoader();\n+    MicroserviceDefinition microserviceDefinition = new MicroserviceDefinition(\n+        loader.getConfigModels());\n+    MicroserviceFactory microserviceFactory = new MicroserviceFactory();\n+    this.selfMicroservice = microserviceFactory.create(microserviceDefinition);\n+    this.selfMicroserviceInstance = selfMicroservice.getInstance();\n+\n+    ServerUtil.init();\n+    ClientUtil.init();\n+  }\n+\n+  @Override\n+  public void run() {\n+    // register service instance\n+    boolean registerResult = zeroConfigClient.register();\n+\n+    if (!registerResult) {\n+      LOGGER.error(\"Failed to Register Service Instance in Zero-Config mode\");\n+    }\n+  }\n+\n+  @Override\n+  public void destroy() {\n+    // unregister service instance\n+    boolean unregisterResult = zeroConfigClient.unregister();\n+\n+    if (!unregisterResult) {\n+      LOGGER.error(\"Failed to Unregister Service Instance in Zero-Config mode\");\n+    }\n+  }\n+\n+  @Override\n+  public int getOrder() {\n+    return 101;\n+  }\n+\n+  @Override\n+  public String name() {\n+    return NAME;\n+  }\n+\n+  @Override\n+  public MicroserviceInstance getMicroserviceInstance() {\n+    return this.selfMicroserviceInstance;\n+  }\n+\n+  @Override\n+  public Microservice getMicroservice() {\n+    return this.selfMicroservice;\n+  }\n+\n+  @Override\n+  public String getAppId() {\n+    return this.selfMicroservice.getAppId();\n+  }\n+\n+  @Override\n+  public boolean updateMicroserviceInstanceStatus(MicroserviceInstanceStatus status) {\n+    this.selfMicroserviceInstance.setStatus(status);\n+    return true;\n+  }\n+\n+  @Override\n+  public void addSchema(String schemaId, String content) {\n+    this.selfMicroservice.addSchema(schemaId, content);\n+  }\n+\n+  @Override\n+  public void addEndpoint(String endpoint) {\n+    this.selfMicroserviceInstance.getEndpoints().add(endpoint);\n+  }\n+\n+  @Override\n+  public void addBasePath(Collection<BasePath> basePaths) {\n+    this.selfMicroservice.getPaths().addAll(basePaths);\n+  }\n+\n+  // setter/getter\n+\n+  public void setSelfMicroservice(", "originalCommit": "66b0708881ca3991c71d30ccac9398560e33890c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAyNDE3NQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1804#discussion_r433024175", "bodyText": "agree", "author": "jungan21", "createdAt": "2020-06-01T03:08:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAyMDU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAyMDg2NA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1804#discussion_r433020864", "bodyText": "I think it is better to initalize instance id and service id in init.   And can avoid many null and empty checks here.", "author": "liubao68", "createdAt": "2020-06-01T02:48:26Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/client/ZeroConfigClient.java", "diffHunk": "@@ -0,0 +1,309 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.zeroconfig.client;\n+\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.servicecomb.registry.api.registry.FindInstancesResponse;\n+import org.apache.servicecomb.registry.api.registry.Microservice;\n+import org.apache.servicecomb.registry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.registry.api.registry.MicroserviceInstances;\n+import org.apache.servicecomb.registry.version.Version;\n+import org.apache.servicecomb.registry.version.VersionRule;\n+import org.apache.servicecomb.registry.version.VersionRuleUtils;\n+import org.apache.servicecomb.registry.version.VersionUtils;\n+import org.apache.servicecomb.zeroconfig.ZeroConfigRegistration;\n+import org.apache.servicecomb.zeroconfig.server.ServerMicroserviceInstance;\n+import org.apache.servicecomb.zeroconfig.server.ServerUtil;\n+import org.apache.servicecomb.zeroconfig.server.ZeroConfigRegistryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.web.client.RestTemplate;\n+\n+import static org.apache.servicecomb.zeroconfig.ZeroConfigRegistryConstants.*;\n+\n+public class ZeroConfigClient {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ZeroConfigClient.class);\n+\n+  public static ZeroConfigClient INSTANCE = buildZeroConfigClient();\n+\n+  // Constructor Parameters\n+  private ZeroConfigRegistryService zeroConfigRegistryService;\n+  private RestTemplate restTemplate;\n+  private MulticastSocket multicastSocket;\n+\n+  // Constructor\n+  public ZeroConfigClient(ZeroConfigRegistryService zeroConfigRegistryService,\n+      MulticastSocket multicastSocket, RestTemplate restTemplate) {\n+    this.zeroConfigRegistryService = zeroConfigRegistryService;\n+    this.restTemplate = restTemplate;\n+    this.multicastSocket = multicastSocket;\n+  }\n+\n+  // builder method\n+  private static ZeroConfigClient buildZeroConfigClient() {\n+    MulticastSocket multicastSocket = null;\n+    try {\n+      multicastSocket = new MulticastSocket();\n+      multicastSocket.setLoopbackMode(false);\n+    } catch (IOException e) {\n+      // since we support multiple registries, not blocking other type of registries\n+      LOGGER.error(\"Failed to create MulticastSocket object in Zero-Config mode\", e);\n+      //throw new ServiceCombException(\"Failed to create MulticastSocket object\", e);\n+    }\n+    return new ZeroConfigClient(new ZeroConfigRegistryService(), multicastSocket,\n+        new RestTemplate());\n+  }\n+\n+  public boolean register() {\n+    Map<String, String> data = prepareRegisterData();\n+    if (data == null || data.isEmpty()) {\n+      return false;\n+    }\n+    String serviceInstanceId = doRegister(data);\n+    return StringUtils.isNotEmpty(serviceInstanceId);\n+  }\n+\n+  private String doRegister(Map<String, String> serviceInstanceDataMap) {\n+    try {\n+      byte[] instanceData = serviceInstanceDataMap.toString().getBytes();\n+      DatagramPacket instanceDataPacket = new DatagramPacket(instanceData, instanceData.length,\n+          InetAddress.getByName(GROUP), PORT);\n+      this.multicastSocket.send(instanceDataPacket);\n+\n+      // set this variable for heartbeat itself status\n+      serviceInstanceDataMap.put(EVENT, HEARTBEAT_EVENT);\n+      ClientUtil.setServiceInstanceMapForHeartbeat(serviceInstanceDataMap);\n+    } catch (IOException e) {\n+      LOGGER.error(\n+          \"Failed to Multicast Microservice Instance Registration Event in Zero-Config mode. servcieId: {} instanceId:{}\",\n+          serviceInstanceDataMap.get(SERVICE_ID), serviceInstanceDataMap.get(INSTANCE_ID), e);\n+      return null;\n+    }\n+    return serviceInstanceDataMap.get(INSTANCE_ID);\n+  }\n+\n+  public boolean unregister() {\n+    ServerMicroserviceInstance foundInstance = preUnregisterCheck();\n+    if (foundInstance == null) {\n+      LOGGER.warn(\n+          \"Failed to unregister as Microservice Instance doesn't exist in server side in Zero-Config mode\");\n+      return false;\n+    }\n+\n+    try {\n+      LOGGER.info(\n+          \"Start Multicast Microservice Instance Unregister Event in Zero-Config mode. Service ID: {}, Instance ID:{}\",\n+          foundInstance.getServiceId(), foundInstance.getInstanceId());\n+      Map<String, String> unregisterEventMap = new HashMap<>();\n+      unregisterEventMap.put(EVENT, UNREGISTER_EVENT);\n+      unregisterEventMap.put(SERVICE_ID, foundInstance.getServiceId());\n+      unregisterEventMap.put(INSTANCE_ID, foundInstance.getInstanceId());\n+      byte[] unregisterEventBytes = unregisterEventMap.toString().getBytes();\n+      DatagramPacket unregisterEventDataPacket = new DatagramPacket(unregisterEventBytes,\n+          unregisterEventBytes.length, InetAddress.getByName(GROUP), PORT);\n+      this.multicastSocket.send(unregisterEventDataPacket);\n+      return true;\n+    } catch (IOException e) {\n+      LOGGER.error(\n+          \"Failed to Multicast Microservice Instance Unregister Event in Zero-Config mode. Service ID: {}, Instance ID:{}\",\n+          foundInstance.getServiceId(), foundInstance.getInstanceId(), e);\n+      return false;\n+    }\n+\n+  }\n+\n+  public List<Microservice> getAllMicroservices() {\n+    List<Microservice> resultAllServices = new ArrayList<>();\n+    Map<String, Map<String, ServerMicroserviceInstance>> allServicesMap = ServerUtil.microserviceInstanceMap;\n+    allServicesMap.forEach((serviceId, instanceIdMap) -> {\n+      instanceIdMap.forEach((instanceId, instance) -> {\n+        resultAllServices.add(ClientUtil.convertToClientMicroservice(instance));\n+      });\n+    });\n+    return resultAllServices;\n+  }\n+\n+  public Microservice getMicroservice(String microserviceId) {\n+    Microservice selfMicroservice = ZeroConfigRegistration.INSTANCE.getSelfMicroservice();\n+    // for registration\n+    if (selfMicroservice.getServiceId().equals(microserviceId)) {\n+      return selfMicroservice;\n+    } else {\n+      // called when consumer discover provider for the very first time\n+      return ClientUtil\n+          .convertToClientMicroservice(zeroConfigRegistryService.getMicroservice(microserviceId));\n+    }\n+  }\n+\n+  public String getSchema(String microserviceId, String schemaId) {\n+    Microservice selfMicroservice = ZeroConfigRegistration.INSTANCE.getSelfMicroservice();\n+    LOGGER.info(\"Retrieve schema content for Microservice ID: {}, Schema ID: {}\",\n+        microserviceId, schemaId);\n+    // called by service registration task when registering itself\n+    if (selfMicroservice.getServiceId().equals(microserviceId)) {\n+      return selfMicroservice.getSchemaMap().computeIfPresent(schemaId, (k, v) -> v);\n+    } else {\n+      // called by consumer to load provider's schema content for the very first time\n+      String providerEndpoint = this.getEndpointForMicroservice(microserviceId);\n+      if (providerEndpoint == null) {\n+        throw new IllegalArgumentException(\"Provider's endpoint can NOT be Null\");\n+      }\n+      String providerSchemaContentEndpoint =\n+          providerEndpoint + \"/schemaEndpoint/schemas?schemaId=\" + schemaId;\n+\n+      LOGGER.info(\"Retrieve schema content from endpoint:{}\", providerSchemaContentEndpoint);\n+      // Make a rest call to provider's endpoint directly to retrieve the schema content\n+      return restTemplate.getForObject(providerSchemaContentEndpoint, String.class);\n+    }\n+  }\n+\n+  private String getEndpointForMicroservice(String microserviceId) {\n+    ServerMicroserviceInstance serverMicroserviceInstance = zeroConfigRegistryService\n+        .getMicroservice(microserviceId);\n+    LOGGER.info(\"Retrieve endpoint for serve rMicroservice Instance: {}\",\n+        serverMicroserviceInstance);\n+    if (serverMicroserviceInstance != null && !serverMicroserviceInstance.getEndpoints()\n+        .isEmpty()) {\n+      return serverMicroserviceInstance.getEndpoints().get(0)\n+          .replace(ENDPOINT_PREFIX_REST, ENDPOINT_PREFIX_HTTP);\n+    }\n+    return null;\n+  }\n+\n+  public MicroserviceInstance findMicroserviceInstance(String serviceId, String instanceId) {\n+    Optional<ServerMicroserviceInstance> optionalInstance = this.zeroConfigRegistryService.\n+        findServiceInstance(serviceId, instanceId);\n+\n+    if (optionalInstance.isPresent()) {\n+      return ClientUtil\n+          .convertToClientMicroserviceInstance(optionalInstance.get());\n+    } else {\n+      LOGGER.error(\n+          \"Invalid serviceId OR instanceId! Failed to retrieve Microservice Instance for serviceId {} and instanceId {}\",\n+          serviceId, instanceId);\n+      return null;\n+    }\n+  }\n+\n+  public MicroserviceInstances findServiceInstances(String appId, String providerServiceName,\n+      String strVersionRule) {\n+    LOGGER.info(\n+        \"Find service instance for App ID: {}, Provider ServiceName: {}, versionRule: {} in Zero-Config mode\",\n+        appId, providerServiceName, strVersionRule);\n+\n+    MicroserviceInstances resultMicroserviceInstances = new MicroserviceInstances();\n+    FindInstancesResponse response = new FindInstancesResponse();\n+    List<MicroserviceInstance> resultInstanceList = new ArrayList<>();\n+\n+    // 1.  find matched appId and serviceName from \"Server\"\n+    List<ServerMicroserviceInstance> tempServerInstanceList = this.zeroConfigRegistryService.\n+        findServiceInstances(appId, providerServiceName);\n+\n+    // 2.  find matched instance based on the strVersionRule\n+    VersionRule versionRule = VersionRuleUtils.getOrCreate(strVersionRule);\n+\n+    ServerMicroserviceInstance latestVersionInstance = findLatestVersionInstance(\n+        tempServerInstanceList, versionRule);\n+    if (latestVersionInstance != null) {\n+      Version latestVersion = VersionUtils.getOrCreate(latestVersionInstance.getVersion());\n+      for (ServerMicroserviceInstance serverInstance : tempServerInstanceList) {\n+        Version version = VersionUtils.getOrCreate(serverInstance.getVersion());\n+        if (!versionRule.isMatch(version, latestVersion)) {\n+          continue;\n+        }\n+        resultInstanceList.add(ClientUtil.convertToClientMicroserviceInstance(serverInstance));\n+      }\n+    }\n+\n+    response.setInstances(resultInstanceList);\n+    resultMicroserviceInstances.setInstancesResponse(response);\n+    return resultMicroserviceInstances;\n+  }\n+\n+  private ServerMicroserviceInstance findLatestVersionInstance(\n+      List<ServerMicroserviceInstance> instanceList, VersionRule versionRule) {\n+    Version latestVersion = null;\n+    ServerMicroserviceInstance latestVersionInstance = null;\n+    for (ServerMicroserviceInstance serverInstance : instanceList) {\n+      Version version = VersionUtils.getOrCreate(serverInstance.getVersion());\n+      if (!versionRule.isAccept(version)) {\n+        continue;\n+      }\n+\n+      if (latestVersion == null || version.compareTo(latestVersion) > 0) {\n+        latestVersion = version;\n+        latestVersionInstance = serverInstance;\n+      }\n+    }\n+    return latestVersionInstance;\n+  }\n+\n+  private Map<String, String> prepareRegisterData() {\n+    // set serviceId\n+    Microservice selfMicroservice = ZeroConfigRegistration.INSTANCE.getSelfMicroservice();\n+    MicroserviceInstance selfMicroserviceInstance = ZeroConfigRegistration.INSTANCE\n+        .getSelfMicroserviceInstance();\n+\n+    if (selfMicroservice == null || selfMicroserviceInstance == null) {\n+      return null;\n+    }\n+\n+    String serviceId = selfMicroservice.getServiceId();\n+    if (StringUtils.isEmpty(serviceId)) {\n+      serviceId = ClientUtil.generateServiceId(selfMicroservice);\n+      selfMicroservice.setServiceId(serviceId);\n+      selfMicroserviceInstance.setServiceId(serviceId);\n+    }\n+\n+    // set instanceId\n+    String instanceId = selfMicroserviceInstance\n+        .getInstanceId(); // allow client to set the instanceId\n+    if (StringUtils.isEmpty(instanceId)) {\n+      instanceId = ClientUtil.generateServiceInstanceId();\n+      selfMicroserviceInstance.setInstanceId(instanceId);\n+    }", "originalCommit": "66b0708881ca3991c71d30ccac9398560e33890c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAyNDA5Ng==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1804#discussion_r433024096", "bodyText": "ok", "author": "jungan21", "createdAt": "2020-06-01T03:08:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzAyMDg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA2MjYyMQ==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1804#discussion_r433062621", "bodyText": "specify locale to avoid problems.", "author": "liubao68", "createdAt": "2020-06-01T06:27:28Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/client/ZeroConfigClient.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.zeroconfig.client;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.servicecomb.registry.api.registry.FindInstancesResponse;\n+import org.apache.servicecomb.registry.api.registry.Microservice;\n+import org.apache.servicecomb.registry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.registry.api.registry.MicroserviceInstances;\n+import org.apache.servicecomb.registry.version.Version;\n+import org.apache.servicecomb.registry.version.VersionRule;\n+import org.apache.servicecomb.registry.version.VersionRuleUtils;\n+import org.apache.servicecomb.registry.version.VersionUtils;\n+import org.apache.servicecomb.zeroconfig.ZeroConfigRegistration;\n+import org.apache.servicecomb.zeroconfig.server.ServerMicroserviceInstance;\n+import org.apache.servicecomb.zeroconfig.server.ServerUtil;\n+import org.apache.servicecomb.zeroconfig.server.ZeroConfigRegistryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.web.client.RestTemplate;\n+\n+import static org.apache.servicecomb.zeroconfig.ZeroConfigRegistryConstants.*;\n+\n+public class ZeroConfigClient {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ZeroConfigClient.class);\n+\n+  public static ZeroConfigClient INSTANCE = buildZeroConfigClient();\n+\n+  // Constructor Parameters\n+  private ZeroConfigRegistryService zeroConfigRegistryService;\n+  private RestTemplate restTemplate;\n+  private MulticastSocket multicastSocket;\n+\n+  // Constructor\n+\n+  private ZeroConfigClient(ZeroConfigRegistryService zeroConfigRegistryService,\n+      MulticastSocket multicastSocket, RestTemplate restTemplate) {\n+    this.zeroConfigRegistryService = zeroConfigRegistryService;\n+    this.restTemplate = restTemplate;\n+    this.multicastSocket = multicastSocket;\n+  }\n+\n+  @VisibleForTesting\n+  public ZeroConfigClient initZeroConfigClientWithMocked(\n+      ZeroConfigRegistryService zeroConfigRegistryService,\n+      MulticastSocket multicastSocket, RestTemplate restTemplate) {\n+    this.zeroConfigRegistryService = zeroConfigRegistryService;\n+    this.multicastSocket = multicastSocket;\n+    this.restTemplate = restTemplate;\n+    return this;\n+  }\n+\n+  // builder method\n+  private static ZeroConfigClient buildZeroConfigClient() {\n+    MulticastSocket multicastSocket = null;\n+    try {\n+      multicastSocket = new MulticastSocket();\n+      multicastSocket.setLoopbackMode(false);\n+    } catch (IOException e) {\n+      // since we support multiple registries, not blocking other type of registries\n+      LOGGER.error(\"Failed to create MulticastSocket object in Zero-Config mode\", e);\n+      //throw new ServiceCombException(\"Failed to create MulticastSocket object\", e);\n+    }\n+    return new ZeroConfigClient(new ZeroConfigRegistryService(), multicastSocket,\n+        new RestTemplate());\n+  }\n+\n+  public boolean register() {\n+    Map<String, String> data = prepareRegisterData();\n+    if (data == null || data.isEmpty()) {\n+      return false;\n+    }\n+    String serviceInstanceId = doRegister(data);\n+    return StringUtils.isNotEmpty(serviceInstanceId);\n+  }\n+\n+  private String doRegister(Map<String, String> serviceInstanceDataMap) {\n+    try {\n+      byte[] instanceData = serviceInstanceDataMap.toString().getBytes();", "originalCommit": "c2eb13cf21cb6fae0372e8c0ec01c11f24eab4aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI0NDI3Nw==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1804#discussion_r433244277", "bodyText": "specify locale to avoid problems.\n\n? please explain more", "author": "jungan21", "createdAt": "2020-06-01T13:48:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA2MjYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIzODk4Mg==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1804#discussion_r433238982", "bodyText": "Can not use RestTemlate here bacause it is can only invoke simple services that do not deploy any security features, e.g. when TLS is eanbled.", "author": "liubao68", "createdAt": "2020-06-01T13:39:00Z", "path": "service-registry/registry-zero-config/src/main/java/org/apache/servicecomb/zeroconfig/client/ZeroConfigClient.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.servicecomb.zeroconfig.client;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import java.io.IOException;\n+import java.net.DatagramPacket;\n+import java.net.InetAddress;\n+import java.net.MulticastSocket;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import org.apache.commons.lang.StringUtils;\n+import org.apache.servicecomb.registry.api.registry.FindInstancesResponse;\n+import org.apache.servicecomb.registry.api.registry.Microservice;\n+import org.apache.servicecomb.registry.api.registry.MicroserviceInstance;\n+import org.apache.servicecomb.registry.api.registry.MicroserviceInstances;\n+import org.apache.servicecomb.registry.version.Version;\n+import org.apache.servicecomb.registry.version.VersionRule;\n+import org.apache.servicecomb.registry.version.VersionRuleUtils;\n+import org.apache.servicecomb.registry.version.VersionUtils;\n+import org.apache.servicecomb.zeroconfig.ZeroConfigRegistration;\n+import org.apache.servicecomb.zeroconfig.server.ServerMicroserviceInstance;\n+import org.apache.servicecomb.zeroconfig.server.ServerUtil;\n+import org.apache.servicecomb.zeroconfig.server.ZeroConfigRegistryService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.web.client.RestTemplate;\n+\n+import static org.apache.servicecomb.zeroconfig.ZeroConfigRegistryConstants.*;\n+\n+public class ZeroConfigClient {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ZeroConfigClient.class);\n+\n+  public static ZeroConfigClient INSTANCE = buildZeroConfigClient();\n+\n+  // Constructor Parameters\n+  private ZeroConfigRegistryService zeroConfigRegistryService;\n+  private RestTemplate restTemplate;\n+  private MulticastSocket multicastSocket;\n+\n+  // Constructor\n+\n+  private ZeroConfigClient(ZeroConfigRegistryService zeroConfigRegistryService,\n+      MulticastSocket multicastSocket, RestTemplate restTemplate) {\n+    this.zeroConfigRegistryService = zeroConfigRegistryService;\n+    this.restTemplate = restTemplate;\n+    this.multicastSocket = multicastSocket;\n+  }\n+\n+  @VisibleForTesting\n+  public ZeroConfigClient initZeroConfigClientWithMocked(\n+      ZeroConfigRegistryService zeroConfigRegistryService,\n+      MulticastSocket multicastSocket, RestTemplate restTemplate) {\n+    this.zeroConfigRegistryService = zeroConfigRegistryService;\n+    this.multicastSocket = multicastSocket;\n+    this.restTemplate = restTemplate;\n+    return this;\n+  }\n+\n+  // builder method\n+  private static ZeroConfigClient buildZeroConfigClient() {\n+    MulticastSocket multicastSocket = null;\n+    try {\n+      multicastSocket = new MulticastSocket();\n+      multicastSocket.setLoopbackMode(false);\n+    } catch (IOException e) {\n+      // since we support multiple registries, not blocking other type of registries\n+      LOGGER.error(\"Failed to create MulticastSocket object in Zero-Config mode\", e);\n+      //throw new ServiceCombException(\"Failed to create MulticastSocket object\", e);\n+    }\n+    return new ZeroConfigClient(new ZeroConfigRegistryService(), multicastSocket,\n+        new RestTemplate());", "originalCommit": "c2eb13cf21cb6fae0372e8c0ec01c11f24eab4aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzI0Mjk0OA==", "url": "https://github.com/apache/servicecomb-java-chassis/pull/1804#discussion_r433242948", "bodyText": "will think about perfect soution in next PR", "author": "jungan21", "createdAt": "2020-06-01T13:46:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzIzODk4Mg=="}], "type": "inlineReview"}, {"oid": "c2859ddb28b5d3dd73aa9e833dbea6bc63feb603", "url": "https://github.com/apache/servicecomb-java-chassis/commit/c2859ddb28b5d3dd73aa9e833dbea6bc63feb603", "message": "[SCB-1971] Introduce SPI mechanism to enable/disable zero-config and changes to adapt to new interfaces", "committedDate": "2020-06-01T19:04:36Z", "type": "commit"}, {"oid": "b3f894246e04708157903d3f34e94a9bbbe6c3be", "url": "https://github.com/apache/servicecomb-java-chassis/commit/b3f894246e04708157903d3f34e94a9bbbe6c3be", "message": "[SCB-1971] Address PR comments", "committedDate": "2020-06-01T19:04:36Z", "type": "commit"}, {"oid": "54a89ba2b8443ffc9fb8b623e47c38e1bffef987", "url": "https://github.com/apache/servicecomb-java-chassis/commit/54a89ba2b8443ffc9fb8b623e47c38e1bffef987", "message": "[SCB-1971] fix an issue", "committedDate": "2020-06-01T19:04:36Z", "type": "commit"}, {"oid": "76cda0c0a3bb99da8ac7368ec4a1ca50f5832f75", "url": "https://github.com/apache/servicecomb-java-chassis/commit/76cda0c0a3bb99da8ac7368ec4a1ca50f5832f75", "message": "[SCB-1971] Address comments", "committedDate": "2020-06-01T19:04:36Z", "type": "commit"}, {"oid": "3c8088a47509166774c1ac67fed4d6a563e3e1c2", "url": "https://github.com/apache/servicecomb-java-chassis/commit/3c8088a47509166774c1ac67fed4d6a563e3e1c2", "message": "[SCB-1971] Clean up", "committedDate": "2020-06-01T20:24:39Z", "type": "commit"}]}