{"pr_number": 528, "pr_title": "v4 fluent flatten mutiple inheritance", "pr_createdAt": "2020-03-06T10:32:03Z", "pr_url": "https://github.com/Azure/autorest.java/pull/528", "timeline": [{"oid": "4180b976b08e5b7b9ad12a033c281103a6e610d2", "url": "https://github.com/Azure/autorest.java/commit/4180b976b08e5b7b9ad12a033c281103a6e610d2", "message": "flatten multiple inheritance", "committedDate": "2020-03-06T08:02:54Z", "type": "commit"}, {"oid": "22cb409242f006bcfcde1a9846d58c3fcaa9a0c8", "url": "https://github.com/Azure/autorest.java/commit/22cb409242f006bcfcde1a9846d58c3fcaa9a0c8", "message": "flatten multiple inheritance", "committedDate": "2020-03-06T10:26:35Z", "type": "commit"}, {"oid": "3dde8d631b0506a7905d70dc9177cb23808a5a17", "url": "https://github.com/Azure/autorest.java/commit/3dde8d631b0506a7905d70dc9177cb23808a5a17", "message": "remove tranformer", "committedDate": "2020-03-06T10:27:12Z", "type": "commit"}, {"oid": "1426f10cb8774cd3182769668b6e5e32a808f0c8", "url": "https://github.com/Azure/autorest.java/commit/1426f10cb8774cd3182769668b6e5e32a808f0c8", "message": "comments", "committedDate": "2020-03-06T10:31:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMjQ1NA==", "url": "https://github.com/Azure/autorest.java/pull/528#discussion_r388932454", "bodyText": "Some mgmt-plane swagger has type with multiple base type. Currently I only take the first one as base, and flatten the rest. Could there be a better heuristic, like take the one that itself inherits a base class or got a discriminator?\nv1 flatten it as well. But not sure how it pick the base class.", "author": "weidongxu-microsoft", "createdAt": "2020-03-06T14:27:45Z", "path": "javagen/src/main/java/com/azure/autorest/mapper/ModelMapper.java", "diffHunk": "@@ -46,31 +47,46 @@ public ClientModel map(ObjectSchema compositeType) {\n \n             String parentModel = null;\n             boolean hasAdditionalProperties = false;\n+            List<ObjectSchema> parentsNeedFlatten = new ArrayList<>();\n             if (compositeType.getParents() != null && compositeType.getParents().getImmediate() != null) {\n-                if (!(compositeType.getParents().getImmediate().get(0) instanceof DictionarySchema)) {\n-//                ComplexSchema baseSchema = compositeType.getParents().getImmediate().get(0);\n-//                if (baseSchema instanceof ObjectSchema) {\n-//                    parentModel = map((ObjectSchema) baseSchema);\n-//                    serviceModels.addModel(parentModel);\n-//                } else {\n-//                    throw new RuntimeException(\"Wait what? How? Parent is not an object but a \" + baseSchema.getClass() + \"?\");\n-//                }\n-                    ComplexSchema parentComplexSchema = compositeType.getParents().getImmediate().get(0);\n-                    if (parentComplexSchema instanceof ObjectSchema) {\n-                        ClassType parentType = objectMapper.map((ObjectSchema) parentComplexSchema);\n-                        parentModel = parentType.getName();\n-                        modelImports.add(parentType.getPackage() + \".\" + parentModel);\n-                    } else {\n-                        parentModel = compositeType.getParents().getImmediate().get(0).getLanguage().getJava().getName();\n+                hasAdditionalProperties = compositeType.getParents().getImmediate().stream()\n+                        .anyMatch(s -> s instanceof DictionarySchema);\n+\n+                ObjectSchema firstParentComplexSchema = null;\n+                for (Schema parent : compositeType.getParents().getImmediate()) {\n+                    if (parent instanceof ObjectSchema) {\n+                        if (firstParentComplexSchema == null) {\n+                            firstParentComplexSchema = (ObjectSchema) parent;\n+                        } else {\n+                            parentsNeedFlatten.add((ObjectSchema) parent);\n+                        }\n                     }", "originalCommit": "1426f10cb8774cd3182769668b6e5e32a808f0c8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTExMDI1Mg==", "url": "https://github.com/Azure/autorest.java/pull/528#discussion_r389110252", "bodyText": "I agree the right way to handle multiple inheritance in Java is through composition. In v1 flattening was done by modeler so we didn't have to implement that.\nWhile we can reach out to Garrett for advice, I think keeping the same behavior as v1 should be okay.", "author": "jianghaolu", "createdAt": "2020-03-06T19:47:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMjQ1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTIxOTI1MA==", "url": "https://github.com/Azure/autorest.java/pull/528#discussion_r389219250", "bodyText": "Yes, agree. I will try composition, see if I can pull off the serialization/de-serialization correctly.", "author": "weidongxu-microsoft", "createdAt": "2020-03-07T02:25:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMjQ1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQ0MTQzNA==", "url": "https://github.com/Azure/autorest.java/pull/528#discussion_r389441434", "bodyText": "JsonUnwrapper should do (however even when I do not add this, the serialization/de-serialization of the properties under composition still works...).\nHowever the complete task would affect quite much to ClientModel and ModelTemplate, since the currently ModelTemplate and ClientModelProperty appears not able to handle the properties from composition.\nI will delay the implementation of composition to a future task.", "author": "weidongxu-microsoft", "createdAt": "2020-03-09T02:42:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMjQ1NA=="}], "type": "inlineReview"}, {"oid": "60762a463839e0e93568078b70d6ee60a51c3a1d", "url": "https://github.com/Azure/autorest.java/commit/60762a463839e0e93568078b70d6ee60a51c3a1d", "message": "rename", "committedDate": "2020-03-09T02:40:22Z", "type": "commit"}]}