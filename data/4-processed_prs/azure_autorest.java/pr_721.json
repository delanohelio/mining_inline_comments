{"pr_number": 721, "pr_title": "Implement paging code generation in service impl", "pr_createdAt": "2020-09-23T17:31:45Z", "pr_url": "https://github.com/Azure/autorest.java/pull/721", "timeline": [{"oid": "3ad827fb41d8c2ce0ab36e87e46934e8b9fa8a95", "url": "https://github.com/Azure/autorest.java/commit/3ad827fb41d8c2ce0ab36e87e46934e8b9fa8a95", "message": "Generate paging code in service client impl", "committedDate": "2020-09-23T00:58:24Z", "type": "commit"}, {"oid": "0bbc0eaf5cc70bb5c3d778a9c605a9c25c771ee1", "url": "https://github.com/Azure/autorest.java/commit/0bbc0eaf5cc70bb5c3d778a9c605a9c25c771ee1", "message": "Fix page construction", "committedDate": "2020-09-23T17:07:05Z", "type": "commit"}, {"oid": "b17298ad2df751c837afbdc00e5eb779266dc8aa", "url": "https://github.com/Azure/autorest.java/commit/b17298ad2df751c837afbdc00e5eb779266dc8aa", "message": "Use nextLink as Id for getting next page", "committedDate": "2020-09-23T21:25:17Z", "type": "commit"}, {"oid": "1d90ebf7ff15e4b7d1e1bbc255197e6dffe96b06", "url": "https://github.com/Azure/autorest.java/commit/1d90ebf7ff15e4b7d1e1bbc255197e6dffe96b06", "message": "Replace SimpleCallback with Callback", "committedDate": "2020-09-24T16:28:28Z", "type": "commit"}, {"oid": "ee0be773016d74c7d997f8d5030ff19264ec3d27", "url": "https://github.com/Azure/autorest.java/commit/ee0be773016d74c7d997f8d5030ff19264ec3d27", "message": "Embed async page retriever class into service client; Generate method to return async page collection", "committedDate": "2020-09-29T01:24:29Z", "type": "commit"}, {"oid": "c88239e08bbed81bcbb1dc6f291291e82579725c", "url": "https://github.com/Azure/autorest.java/commit/c88239e08bbed81bcbb1dc6f291291e82579725c", "message": "Fix async page retriver construction; Fix collection callback function", "committedDate": "2020-09-29T17:10:15Z", "type": "commit"}, {"oid": "03bfcffe0cab244f648022b8f3c74c17de473f78", "url": "https://github.com/Azure/autorest.java/commit/03bfcffe0cab244f648022b8f3c74c17de473f78", "message": "Generate sync paging method that returns page with response", "committedDate": "2020-09-29T19:09:21Z", "type": "commit"}, {"oid": "6c49ec14162a8c5de14ed97783170e958208b1b1", "url": "https://github.com/Azure/autorest.java/commit/6c49ec14162a8c5de14ed97783170e958208b1b1", "message": "Generate embedded retrievers for sync paging; Generate method to return page collection with and without response", "committedDate": "2020-09-29T20:55:04Z", "type": "commit"}, {"oid": "3e9cc3545d462bb9f385e83fb7db6126af982b96", "url": "https://github.com/Azure/autorest.java/commit/3e9cc3545d462bb9f385e83fb7db6126af982b96", "message": "Fix some syntax errors in generated code", "committedDate": "2020-09-29T23:51:05Z", "type": "commit"}, {"oid": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "url": "https://github.com/Azure/autorest.java/commit/b96e404d81dc82a9c8950c5aa30ffae384b49830", "message": "Move paging code to the right function", "committedDate": "2020-09-30T16:31:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcwNTg3OA==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497705878", "bodyText": "Try to avoid using name for logic", "author": "JianpingChen", "createdAt": "2020-09-30T18:09:48Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/AndroidClientMethodTemplate.java", "diffHunk": "@@ -406,198 +393,353 @@ public void write(ClientMethod clientMethod, JavaType typeBlock) {\n         ProxyMethod restAPIMethod = clientMethod.getProxyMethod();\n         generateJavadoc(clientMethod, typeBlock, restAPIMethod);\n \n-\n         clientMethod.getProxyMethod().getRequestContentType();\n-        List<ClientMethodParameter> parameters = clientMethod.getMethodParameters();\n-\n-\n-\n         switch (clientMethod.getType()) {\n             case SimpleAsyncRestResponse:\n                 // async method\n-                boolean generateAsyncMethodWithOnlyRequiredParams = clientMethod.getOnlyRequiredParameters();\n-                if (generateAsyncMethodWithOnlyRequiredParams) {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-                                // async-method-with-only-required-params delegate call to\n-                                // async-method-with-required-and-optional-param.\n-                                //\n-                                addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n-                                function.line(\"%s(%s);\",\n-                                        clientMethod.getName(), clientMethod.getArgumentList());\n-                            });\n-                } else {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-\n-                                final Optional<ClientMethodParameter> lastParamOpt = clientMethod.getMethodRequiredParameters()\n-                                        .stream()\n-                                        .reduce((current, next) -> next);\n-                                final ClientMethodParameter lastParam = lastParamOpt.get();\n-                                final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n-                                final String callbackParameterName = lastParam.getName();\n-\n-                                final String clientReferenceDot;\n-                                if (clientMethod.getClientReference().equals(\"this\")) {\n-                                    // 'this' is not resolvable from callback remove it.\n-                                    clientReferenceDot = \"\";\n-                                } else {\n-                                    clientReferenceDot = clientMethod.getClientReference().replace(\"this.\", \"\") + \".\";\n-                                }\n-\n-                                addValidations(function,\n-                                        clientMethod.getRequiredNullableParameterExpressions(),\n-                                        clientMethod.getValidateExpressions(),\n-                                        true,\n-                                        (exception, onError) -> {\n-                                            onError.line(\"%s.onFailure(%s, null);\", callbackParameterName, exception);\n-                                            onError.line(\"return;\");\n-                                            return null;\n-                                        },\n-                                        settings);\n-                                addOptionalAndConstantVariables(function,\n-                                        clientMethod,\n-                                        restAPIMethod.getParameters(),\n-                                        settings);\n-                                applyParameterTransformations(function,\n-                                        clientMethod,\n-                                        settings);\n-                                convertClientTypesToWireTypes(function,\n-                                        clientMethod,\n-                                        restAPIMethod.getParameters(),\n-                                        clientReferenceDot,\n-                                        (exception, onError) -> {\n-                                            onError.line(String.format(\"%s.onFailure(%s, null);\", callbackParameterName, exception));\n-                                            onError.line(\"return;\");\n-                                            return null;\n-                                        },\n-                                        settings);\n-                                String retrofitAPIArgsList = String.join(\", \",\n-                                        clientMethod.getProxyMethodArguments(settings));\n-                                String retrofitAPICall = String.format(\"service.%s(%s)\",\n-                                        restAPIMethod.getName(),\n-                                        retrofitAPIArgsList);\n-\n-                                function.line(\"Call<ResponseBody> call = %s;\", retrofitAPICall);\n-                                function.anonymousClass(\"retrofit2.Callback<ResponseBody>\",\n-                                        \"retrofitCallback\",\n-                                        anonymousCls -> {\n-                                    anonymousCls.annotation(\"Override\");\n-                                    anonymousCls.publicMethod(\"void onResponse(Call<okhttp3.ResponseBody> call, retrofit2.Response<ResponseBody> response)\",\n-                                            onResponseBlock -> onResponseBlock.ifBlock(\"response.isSuccessful()\", responseSuccessBlock -> {\n-                                                List<HttpResponseStatus> successStatusCodes = clientMethod.getProxyMethod().getResponseExpectedStatusCodes();\n-                                                String successCodeExpression = successStatusCodes\n-                                                        .stream()\n-                                                        .map(statusCode -> String.format(\"response.code() == %d\", statusCode.code()))\n-                                                        .collect(Collectors.joining(\" || \"));\n-\n-\n-                                                responseSuccessBlock.ifBlock(successCodeExpression, succeededCodeBlock -> {\n-                                                    IType bodyType = callbackParameter.getTypeArguments()[0];\n-                                                    if (bodyType == PrimitiveType.Void) {\n-                                                        succeededCodeBlock.line(\"response.body().close();\");\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(null, response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    } else if (bodyType == ClassType.OkHttp3ResponseBody) {\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(response.body(), response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    } else {\n-                                                        final String bodyJvaType;\n-                                                        if (bodyType instanceof ListType || bodyType instanceof MapType) {\n-                                                            StringBuilder builder = new StringBuilder();\n-                                                            builder.append(clientReferenceDot);\n-                                                            parameterizedTypeExpression(bodyType, builder);\n-                                                            bodyJvaType = builder.toString();\n-                                                        } else {\n-                                                            bodyJvaType = String.format(\"%s.class\", bodyType);\n-                                                        }\n-\n-                                                        List<String> exceptions = new ArrayList<>();\n-                                                        exceptions.add(\"Exception\");\n-                                                        succeededCodeBlock.line(\"final %s decodedResult;\", bodyType);\n-                                                        succeededCodeBlock.tryCatch(tryBlock -> {\n-                                                                    succeededCodeBlock.line(\"decodedResult = %sdeserializeContent(response.headers(), response.body(), %s);\",\n-                                                                            clientReferenceDot,\n-                                                                            bodyJvaType);\n-                                                                },\n-                                                                exceptions,\n-                                                                \"ex\",\n-                                                                catchBlock -> {\n-                                                                    catchBlock\n-                                                                            .line(String.format(\"%s.onFailure(ex, response.raw());\",\n-                                                                                    callbackParameterName));\n-                                                                    catchBlock.line(\"return;\");\n-                                                                },\n-                                                                null);\n-\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(decodedResult, response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    }\n-                                                }).elseBlock(errorCodeBlock -> {\n-                                                    errorCodeBlock.line(\"final String strContent = %sreadAsString(response.body());\", clientReferenceDot);\n-                                                    ClassType exceptionType = clientMethod.getProxyMethod().getUnexpectedResponseExceptionType();\n-                                                    String exceptionCreateExpression = String.format(\"new %s(strContent, response.raw())\", exceptionType.getName());\n-                                                    errorCodeBlock\n-                                                            .line(String.format(\"%s.onFailure(%s, response.raw());\",\n-                                                                    callbackParameterName,\n-                                                                    exceptionCreateExpression));\n-                                                });\n-                                            }).elseBlock(responseFailureBlock -> {\n-                                                responseFailureBlock.line(\"final String strContent = %sreadAsString(response.errorBody());\", clientReferenceDot);\n-                                                responseFailureBlock.line(String.format(\"%s.onFailure(new HttpResponseException(strContent, response.raw()), response.raw());\",\n-                                                        callbackParameterName));\n-                                            }));\n-\n-                                    anonymousCls.annotation(\"Override\");\n-                                    anonymousCls.publicMethod(\"void onFailure(Call<ResponseBody> call, Throwable t)\",\n-                                            onFailureBlock -> {\n-                                                onFailureBlock.line(String.format(\"%s.onFailure(t, null);\", callbackParameterName));\n-                                            });\n-                                });\n-                                function.line(\"call.enqueue(retrofitCallback);\");\n-                            });\n-                }\n+                writeAsyncWithRestResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, false);\n                 break;\n \n             case SimpleSync:\n                 // sync method\n-                boolean generateSyncMethodWithOnlyRequiredParams = clientMethod.getOnlyRequiredParameters();\n-                if (generateSyncMethodWithOnlyRequiredParams) {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-                                // sync-method-with-only-required-params delegate call to\n-                                // sync-method-with-required-and-optional-param.\n-                                //\n-                                addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n-                                IType returnType = clientMethod.getReturnValue().getType();\n-                                if (returnType == PrimitiveType.Void) {\n-                                    function.line(\"%sWithRestResponse(%s);\",\n-                                            clientMethod.getName(), clientMethod.getArgumentList());\n-                                } else {\n-                                    function.line(\"return %sWithRestResponse(%s).getValue();\",\n-                                            clientMethod.getName(), clientMethod.getArgumentList());\n-                                }\n-                            });\n+                writeSyncWithResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, false);\n+                break;\n+\n+            case PagingSync:\n+                writePagingSyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+\n+            case PagingAsync:\n+                writePagingAsyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+            case PagingAsyncSinglePage:\n+                generatePagedAsyncSinglePage(clientMethod, typeBlock, restAPIMethod, settings);\n+                break;\n+\n+            case LongRunningSync:\n+                // LongRunningAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningAsync:\n+                // LongRunningAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningBeginAsync:\n+                // LongRunningBeginAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningBeginSync:\n+                // LongRunningBeginSync not applicable to data-plane android\n+                break;\n+\n+            case Resumable:\n+                // Resumable not applicable to data-plane android\n+                break;\n+\n+            case SimpleAsync:\n+                writeSimpleAsyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+        }\n+    }\n+\n+    private void writeSimpleAsyncMethod(ClientMethod clientMethod, JavaType typeBlock, JavaSettings settings, ProxyMethod restAPIMethod) {\n+        typeBlock.publicMethod(clientMethod.getDeclaration(), (function -> {\n+            addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n+            function.line(\"return %s(%s)\", clientMethod.getProxyMethod().getSimpleAsyncRestResponseMethodName(), clientMethod.getArgumentList());\n+            function.indent((() -> {\n+                GenericType restAPIMethodClientReturnType = (GenericType) restAPIMethod.getReturnType().getClientType();\n+                IType returnValueTypeArgumentClientType = restAPIMethodClientReturnType.getTypeArguments()[0];\n+                if (GenericType.Flux(ClassType.ByteBuffer).equals(clientMethod.getReturnValue().getType())) {\n+                    function.text(\".flatMapMany(StreamResponse::getValue);\");\n+                } else if (!GenericType.Mono(ClassType.Void).equals(clientMethod.getReturnValue().getType()) &&\n+                        !GenericType.Flux(ClassType.Void).equals(clientMethod.getReturnValue().getType())) {\n+                    function.text(\".flatMap(\");\n+                    function.lambda(returnValueTypeArgumentClientType.toString(), \"res\", lambda -> {\n+                        lambda.ifBlock(\"res.getValue() != null\", ifAction -> {\n+                            ifAction.methodReturn(\"Mono.just(res.getValue())\");\n+                        }).elseBlock(elseAction -> {\n+                            elseAction.methodReturn(\"Mono.empty()\");\n+                        });\n+                    });\n+                    function.line(\");\");\n                 } else {\n-                    // ***WithRestResponse method.\n-                    //\n+                    function.text(\".flatMap(\");\n+                    function.lambda(returnValueTypeArgumentClientType.toString(), \"res\", \"Mono.empty()\");\n+                    function.line(\");\");\n+                }\n+            }));\n+        }));\n+    }\n+\n+    private void writePagingAsyncMethod(ClientMethod clientMethod, JavaType typeBlock, JavaSettings settings, ProxyMethod restAPIMethod) {\n+        if (clientMethod.getName().contains(\"Async\")) {", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcwNjYwMA==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497706600", "bodyText": "Use a static method in retriever template", "author": "JianpingChen", "createdAt": "2020-09-30T18:10:59Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/AndroidClientMethodTemplate.java", "diffHunk": "@@ -406,198 +393,353 @@ public void write(ClientMethod clientMethod, JavaType typeBlock) {\n         ProxyMethod restAPIMethod = clientMethod.getProxyMethod();\n         generateJavadoc(clientMethod, typeBlock, restAPIMethod);\n \n-\n         clientMethod.getProxyMethod().getRequestContentType();\n-        List<ClientMethodParameter> parameters = clientMethod.getMethodParameters();\n-\n-\n-\n         switch (clientMethod.getType()) {\n             case SimpleAsyncRestResponse:\n                 // async method\n-                boolean generateAsyncMethodWithOnlyRequiredParams = clientMethod.getOnlyRequiredParameters();\n-                if (generateAsyncMethodWithOnlyRequiredParams) {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-                                // async-method-with-only-required-params delegate call to\n-                                // async-method-with-required-and-optional-param.\n-                                //\n-                                addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n-                                function.line(\"%s(%s);\",\n-                                        clientMethod.getName(), clientMethod.getArgumentList());\n-                            });\n-                } else {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-\n-                                final Optional<ClientMethodParameter> lastParamOpt = clientMethod.getMethodRequiredParameters()\n-                                        .stream()\n-                                        .reduce((current, next) -> next);\n-                                final ClientMethodParameter lastParam = lastParamOpt.get();\n-                                final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n-                                final String callbackParameterName = lastParam.getName();\n-\n-                                final String clientReferenceDot;\n-                                if (clientMethod.getClientReference().equals(\"this\")) {\n-                                    // 'this' is not resolvable from callback remove it.\n-                                    clientReferenceDot = \"\";\n-                                } else {\n-                                    clientReferenceDot = clientMethod.getClientReference().replace(\"this.\", \"\") + \".\";\n-                                }\n-\n-                                addValidations(function,\n-                                        clientMethod.getRequiredNullableParameterExpressions(),\n-                                        clientMethod.getValidateExpressions(),\n-                                        true,\n-                                        (exception, onError) -> {\n-                                            onError.line(\"%s.onFailure(%s, null);\", callbackParameterName, exception);\n-                                            onError.line(\"return;\");\n-                                            return null;\n-                                        },\n-                                        settings);\n-                                addOptionalAndConstantVariables(function,\n-                                        clientMethod,\n-                                        restAPIMethod.getParameters(),\n-                                        settings);\n-                                applyParameterTransformations(function,\n-                                        clientMethod,\n-                                        settings);\n-                                convertClientTypesToWireTypes(function,\n-                                        clientMethod,\n-                                        restAPIMethod.getParameters(),\n-                                        clientReferenceDot,\n-                                        (exception, onError) -> {\n-                                            onError.line(String.format(\"%s.onFailure(%s, null);\", callbackParameterName, exception));\n-                                            onError.line(\"return;\");\n-                                            return null;\n-                                        },\n-                                        settings);\n-                                String retrofitAPIArgsList = String.join(\", \",\n-                                        clientMethod.getProxyMethodArguments(settings));\n-                                String retrofitAPICall = String.format(\"service.%s(%s)\",\n-                                        restAPIMethod.getName(),\n-                                        retrofitAPIArgsList);\n-\n-                                function.line(\"Call<ResponseBody> call = %s;\", retrofitAPICall);\n-                                function.anonymousClass(\"retrofit2.Callback<ResponseBody>\",\n-                                        \"retrofitCallback\",\n-                                        anonymousCls -> {\n-                                    anonymousCls.annotation(\"Override\");\n-                                    anonymousCls.publicMethod(\"void onResponse(Call<okhttp3.ResponseBody> call, retrofit2.Response<ResponseBody> response)\",\n-                                            onResponseBlock -> onResponseBlock.ifBlock(\"response.isSuccessful()\", responseSuccessBlock -> {\n-                                                List<HttpResponseStatus> successStatusCodes = clientMethod.getProxyMethod().getResponseExpectedStatusCodes();\n-                                                String successCodeExpression = successStatusCodes\n-                                                        .stream()\n-                                                        .map(statusCode -> String.format(\"response.code() == %d\", statusCode.code()))\n-                                                        .collect(Collectors.joining(\" || \"));\n-\n-\n-                                                responseSuccessBlock.ifBlock(successCodeExpression, succeededCodeBlock -> {\n-                                                    IType bodyType = callbackParameter.getTypeArguments()[0];\n-                                                    if (bodyType == PrimitiveType.Void) {\n-                                                        succeededCodeBlock.line(\"response.body().close();\");\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(null, response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    } else if (bodyType == ClassType.OkHttp3ResponseBody) {\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(response.body(), response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    } else {\n-                                                        final String bodyJvaType;\n-                                                        if (bodyType instanceof ListType || bodyType instanceof MapType) {\n-                                                            StringBuilder builder = new StringBuilder();\n-                                                            builder.append(clientReferenceDot);\n-                                                            parameterizedTypeExpression(bodyType, builder);\n-                                                            bodyJvaType = builder.toString();\n-                                                        } else {\n-                                                            bodyJvaType = String.format(\"%s.class\", bodyType);\n-                                                        }\n-\n-                                                        List<String> exceptions = new ArrayList<>();\n-                                                        exceptions.add(\"Exception\");\n-                                                        succeededCodeBlock.line(\"final %s decodedResult;\", bodyType);\n-                                                        succeededCodeBlock.tryCatch(tryBlock -> {\n-                                                                    succeededCodeBlock.line(\"decodedResult = %sdeserializeContent(response.headers(), response.body(), %s);\",\n-                                                                            clientReferenceDot,\n-                                                                            bodyJvaType);\n-                                                                },\n-                                                                exceptions,\n-                                                                \"ex\",\n-                                                                catchBlock -> {\n-                                                                    catchBlock\n-                                                                            .line(String.format(\"%s.onFailure(ex, response.raw());\",\n-                                                                                    callbackParameterName));\n-                                                                    catchBlock.line(\"return;\");\n-                                                                },\n-                                                                null);\n-\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(decodedResult, response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    }\n-                                                }).elseBlock(errorCodeBlock -> {\n-                                                    errorCodeBlock.line(\"final String strContent = %sreadAsString(response.body());\", clientReferenceDot);\n-                                                    ClassType exceptionType = clientMethod.getProxyMethod().getUnexpectedResponseExceptionType();\n-                                                    String exceptionCreateExpression = String.format(\"new %s(strContent, response.raw())\", exceptionType.getName());\n-                                                    errorCodeBlock\n-                                                            .line(String.format(\"%s.onFailure(%s, response.raw());\",\n-                                                                    callbackParameterName,\n-                                                                    exceptionCreateExpression));\n-                                                });\n-                                            }).elseBlock(responseFailureBlock -> {\n-                                                responseFailureBlock.line(\"final String strContent = %sreadAsString(response.errorBody());\", clientReferenceDot);\n-                                                responseFailureBlock.line(String.format(\"%s.onFailure(new HttpResponseException(strContent, response.raw()), response.raw());\",\n-                                                        callbackParameterName));\n-                                            }));\n-\n-                                    anonymousCls.annotation(\"Override\");\n-                                    anonymousCls.publicMethod(\"void onFailure(Call<ResponseBody> call, Throwable t)\",\n-                                            onFailureBlock -> {\n-                                                onFailureBlock.line(String.format(\"%s.onFailure(t, null);\", callbackParameterName));\n-                                            });\n-                                });\n-                                function.line(\"call.enqueue(retrofitCallback);\");\n-                            });\n-                }\n+                writeAsyncWithRestResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, false);\n                 break;\n \n             case SimpleSync:\n                 // sync method\n-                boolean generateSyncMethodWithOnlyRequiredParams = clientMethod.getOnlyRequiredParameters();\n-                if (generateSyncMethodWithOnlyRequiredParams) {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-                                // sync-method-with-only-required-params delegate call to\n-                                // sync-method-with-required-and-optional-param.\n-                                //\n-                                addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n-                                IType returnType = clientMethod.getReturnValue().getType();\n-                                if (returnType == PrimitiveType.Void) {\n-                                    function.line(\"%sWithRestResponse(%s);\",\n-                                            clientMethod.getName(), clientMethod.getArgumentList());\n-                                } else {\n-                                    function.line(\"return %sWithRestResponse(%s).getValue();\",\n-                                            clientMethod.getName(), clientMethod.getArgumentList());\n-                                }\n-                            });\n+                writeSyncWithResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, false);\n+                break;\n+\n+            case PagingSync:\n+                writePagingSyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+\n+            case PagingAsync:\n+                writePagingAsyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+            case PagingAsyncSinglePage:\n+                generatePagedAsyncSinglePage(clientMethod, typeBlock, restAPIMethod, settings);\n+                break;\n+\n+            case LongRunningSync:\n+                // LongRunningAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningAsync:\n+                // LongRunningAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningBeginAsync:\n+                // LongRunningBeginAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningBeginSync:\n+                // LongRunningBeginSync not applicable to data-plane android\n+                break;\n+\n+            case Resumable:\n+                // Resumable not applicable to data-plane android\n+                break;\n+\n+            case SimpleAsync:\n+                writeSimpleAsyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+        }\n+    }\n+\n+    private void writeSimpleAsyncMethod(ClientMethod clientMethod, JavaType typeBlock, JavaSettings settings, ProxyMethod restAPIMethod) {\n+        typeBlock.publicMethod(clientMethod.getDeclaration(), (function -> {\n+            addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n+            function.line(\"return %s(%s)\", clientMethod.getProxyMethod().getSimpleAsyncRestResponseMethodName(), clientMethod.getArgumentList());\n+            function.indent((() -> {\n+                GenericType restAPIMethodClientReturnType = (GenericType) restAPIMethod.getReturnType().getClientType();\n+                IType returnValueTypeArgumentClientType = restAPIMethodClientReturnType.getTypeArguments()[0];\n+                if (GenericType.Flux(ClassType.ByteBuffer).equals(clientMethod.getReturnValue().getType())) {\n+                    function.text(\".flatMapMany(StreamResponse::getValue);\");\n+                } else if (!GenericType.Mono(ClassType.Void).equals(clientMethod.getReturnValue().getType()) &&\n+                        !GenericType.Flux(ClassType.Void).equals(clientMethod.getReturnValue().getType())) {\n+                    function.text(\".flatMap(\");\n+                    function.lambda(returnValueTypeArgumentClientType.toString(), \"res\", lambda -> {\n+                        lambda.ifBlock(\"res.getValue() != null\", ifAction -> {\n+                            ifAction.methodReturn(\"Mono.just(res.getValue())\");\n+                        }).elseBlock(elseAction -> {\n+                            elseAction.methodReturn(\"Mono.empty()\");\n+                        });\n+                    });\n+                    function.line(\");\");\n                 } else {\n-                    // ***WithRestResponse method.\n-                    //\n+                    function.text(\".flatMap(\");\n+                    function.lambda(returnValueTypeArgumentClientType.toString(), \"res\", \"Mono.empty()\");\n+                    function.line(\");\");\n+                }\n+            }));\n+        }));\n+    }\n+\n+    private void writePagingAsyncMethod(ClientMethod clientMethod, JavaType typeBlock, JavaSettings settings, ProxyMethod restAPIMethod) {\n+        if (clientMethod.getName().contains(\"Async\")) {\n+            final Optional<ClientMethodParameter> lastParamOpt = clientMethod.getMethodRequiredParameters()\n+                    .stream()\n+                    .reduce((current, next) -> next);\n+            final ClientMethodParameter lastParam = lastParamOpt.get();\n+            final GenericType callbackParameterType = (GenericType) lastParam.getWireType();\n+\n+            typeBlock.publicMethod(clientMethod.getDeclaration(),\n+                function -> {\n+                    final IType collectionType = callbackParameterType.getTypeArguments()[0];\n+                    final IType elementType = ((GenericType) collectionType).getTypeArguments()[0];\n+\n+                    String retrieverClassName = elementType.toString() + \"PageAsyncRetriever\";", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcwNjg5MQ==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497706891", "bodyText": "Try to avoid using name for logic", "author": "JianpingChen", "createdAt": "2020-09-30T18:11:31Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/AndroidClientMethodTemplate.java", "diffHunk": "@@ -406,198 +393,353 @@ public void write(ClientMethod clientMethod, JavaType typeBlock) {\n         ProxyMethod restAPIMethod = clientMethod.getProxyMethod();\n         generateJavadoc(clientMethod, typeBlock, restAPIMethod);\n \n-\n         clientMethod.getProxyMethod().getRequestContentType();\n-        List<ClientMethodParameter> parameters = clientMethod.getMethodParameters();\n-\n-\n-\n         switch (clientMethod.getType()) {\n             case SimpleAsyncRestResponse:\n                 // async method\n-                boolean generateAsyncMethodWithOnlyRequiredParams = clientMethod.getOnlyRequiredParameters();\n-                if (generateAsyncMethodWithOnlyRequiredParams) {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-                                // async-method-with-only-required-params delegate call to\n-                                // async-method-with-required-and-optional-param.\n-                                //\n-                                addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n-                                function.line(\"%s(%s);\",\n-                                        clientMethod.getName(), clientMethod.getArgumentList());\n-                            });\n-                } else {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-\n-                                final Optional<ClientMethodParameter> lastParamOpt = clientMethod.getMethodRequiredParameters()\n-                                        .stream()\n-                                        .reduce((current, next) -> next);\n-                                final ClientMethodParameter lastParam = lastParamOpt.get();\n-                                final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n-                                final String callbackParameterName = lastParam.getName();\n-\n-                                final String clientReferenceDot;\n-                                if (clientMethod.getClientReference().equals(\"this\")) {\n-                                    // 'this' is not resolvable from callback remove it.\n-                                    clientReferenceDot = \"\";\n-                                } else {\n-                                    clientReferenceDot = clientMethod.getClientReference().replace(\"this.\", \"\") + \".\";\n-                                }\n-\n-                                addValidations(function,\n-                                        clientMethod.getRequiredNullableParameterExpressions(),\n-                                        clientMethod.getValidateExpressions(),\n-                                        true,\n-                                        (exception, onError) -> {\n-                                            onError.line(\"%s.onFailure(%s, null);\", callbackParameterName, exception);\n-                                            onError.line(\"return;\");\n-                                            return null;\n-                                        },\n-                                        settings);\n-                                addOptionalAndConstantVariables(function,\n-                                        clientMethod,\n-                                        restAPIMethod.getParameters(),\n-                                        settings);\n-                                applyParameterTransformations(function,\n-                                        clientMethod,\n-                                        settings);\n-                                convertClientTypesToWireTypes(function,\n-                                        clientMethod,\n-                                        restAPIMethod.getParameters(),\n-                                        clientReferenceDot,\n-                                        (exception, onError) -> {\n-                                            onError.line(String.format(\"%s.onFailure(%s, null);\", callbackParameterName, exception));\n-                                            onError.line(\"return;\");\n-                                            return null;\n-                                        },\n-                                        settings);\n-                                String retrofitAPIArgsList = String.join(\", \",\n-                                        clientMethod.getProxyMethodArguments(settings));\n-                                String retrofitAPICall = String.format(\"service.%s(%s)\",\n-                                        restAPIMethod.getName(),\n-                                        retrofitAPIArgsList);\n-\n-                                function.line(\"Call<ResponseBody> call = %s;\", retrofitAPICall);\n-                                function.anonymousClass(\"retrofit2.Callback<ResponseBody>\",\n-                                        \"retrofitCallback\",\n-                                        anonymousCls -> {\n-                                    anonymousCls.annotation(\"Override\");\n-                                    anonymousCls.publicMethod(\"void onResponse(Call<okhttp3.ResponseBody> call, retrofit2.Response<ResponseBody> response)\",\n-                                            onResponseBlock -> onResponseBlock.ifBlock(\"response.isSuccessful()\", responseSuccessBlock -> {\n-                                                List<HttpResponseStatus> successStatusCodes = clientMethod.getProxyMethod().getResponseExpectedStatusCodes();\n-                                                String successCodeExpression = successStatusCodes\n-                                                        .stream()\n-                                                        .map(statusCode -> String.format(\"response.code() == %d\", statusCode.code()))\n-                                                        .collect(Collectors.joining(\" || \"));\n-\n-\n-                                                responseSuccessBlock.ifBlock(successCodeExpression, succeededCodeBlock -> {\n-                                                    IType bodyType = callbackParameter.getTypeArguments()[0];\n-                                                    if (bodyType == PrimitiveType.Void) {\n-                                                        succeededCodeBlock.line(\"response.body().close();\");\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(null, response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    } else if (bodyType == ClassType.OkHttp3ResponseBody) {\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(response.body(), response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    } else {\n-                                                        final String bodyJvaType;\n-                                                        if (bodyType instanceof ListType || bodyType instanceof MapType) {\n-                                                            StringBuilder builder = new StringBuilder();\n-                                                            builder.append(clientReferenceDot);\n-                                                            parameterizedTypeExpression(bodyType, builder);\n-                                                            bodyJvaType = builder.toString();\n-                                                        } else {\n-                                                            bodyJvaType = String.format(\"%s.class\", bodyType);\n-                                                        }\n-\n-                                                        List<String> exceptions = new ArrayList<>();\n-                                                        exceptions.add(\"Exception\");\n-                                                        succeededCodeBlock.line(\"final %s decodedResult;\", bodyType);\n-                                                        succeededCodeBlock.tryCatch(tryBlock -> {\n-                                                                    succeededCodeBlock.line(\"decodedResult = %sdeserializeContent(response.headers(), response.body(), %s);\",\n-                                                                            clientReferenceDot,\n-                                                                            bodyJvaType);\n-                                                                },\n-                                                                exceptions,\n-                                                                \"ex\",\n-                                                                catchBlock -> {\n-                                                                    catchBlock\n-                                                                            .line(String.format(\"%s.onFailure(ex, response.raw());\",\n-                                                                                    callbackParameterName));\n-                                                                    catchBlock.line(\"return;\");\n-                                                                },\n-                                                                null);\n-\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(decodedResult, response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    }\n-                                                }).elseBlock(errorCodeBlock -> {\n-                                                    errorCodeBlock.line(\"final String strContent = %sreadAsString(response.body());\", clientReferenceDot);\n-                                                    ClassType exceptionType = clientMethod.getProxyMethod().getUnexpectedResponseExceptionType();\n-                                                    String exceptionCreateExpression = String.format(\"new %s(strContent, response.raw())\", exceptionType.getName());\n-                                                    errorCodeBlock\n-                                                            .line(String.format(\"%s.onFailure(%s, response.raw());\",\n-                                                                    callbackParameterName,\n-                                                                    exceptionCreateExpression));\n-                                                });\n-                                            }).elseBlock(responseFailureBlock -> {\n-                                                responseFailureBlock.line(\"final String strContent = %sreadAsString(response.errorBody());\", clientReferenceDot);\n-                                                responseFailureBlock.line(String.format(\"%s.onFailure(new HttpResponseException(strContent, response.raw()), response.raw());\",\n-                                                        callbackParameterName));\n-                                            }));\n-\n-                                    anonymousCls.annotation(\"Override\");\n-                                    anonymousCls.publicMethod(\"void onFailure(Call<ResponseBody> call, Throwable t)\",\n-                                            onFailureBlock -> {\n-                                                onFailureBlock.line(String.format(\"%s.onFailure(t, null);\", callbackParameterName));\n-                                            });\n-                                });\n-                                function.line(\"call.enqueue(retrofitCallback);\");\n-                            });\n-                }\n+                writeAsyncWithRestResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, false);\n                 break;\n \n             case SimpleSync:\n                 // sync method\n-                boolean generateSyncMethodWithOnlyRequiredParams = clientMethod.getOnlyRequiredParameters();\n-                if (generateSyncMethodWithOnlyRequiredParams) {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-                                // sync-method-with-only-required-params delegate call to\n-                                // sync-method-with-required-and-optional-param.\n-                                //\n-                                addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n-                                IType returnType = clientMethod.getReturnValue().getType();\n-                                if (returnType == PrimitiveType.Void) {\n-                                    function.line(\"%sWithRestResponse(%s);\",\n-                                            clientMethod.getName(), clientMethod.getArgumentList());\n-                                } else {\n-                                    function.line(\"return %sWithRestResponse(%s).getValue();\",\n-                                            clientMethod.getName(), clientMethod.getArgumentList());\n-                                }\n-                            });\n+                writeSyncWithResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, false);\n+                break;\n+\n+            case PagingSync:\n+                writePagingSyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+\n+            case PagingAsync:\n+                writePagingAsyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+            case PagingAsyncSinglePage:\n+                generatePagedAsyncSinglePage(clientMethod, typeBlock, restAPIMethod, settings);\n+                break;\n+\n+            case LongRunningSync:\n+                // LongRunningAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningAsync:\n+                // LongRunningAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningBeginAsync:\n+                // LongRunningBeginAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningBeginSync:\n+                // LongRunningBeginSync not applicable to data-plane android\n+                break;\n+\n+            case Resumable:\n+                // Resumable not applicable to data-plane android\n+                break;\n+\n+            case SimpleAsync:\n+                writeSimpleAsyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+        }\n+    }\n+\n+    private void writeSimpleAsyncMethod(ClientMethod clientMethod, JavaType typeBlock, JavaSettings settings, ProxyMethod restAPIMethod) {\n+        typeBlock.publicMethod(clientMethod.getDeclaration(), (function -> {\n+            addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n+            function.line(\"return %s(%s)\", clientMethod.getProxyMethod().getSimpleAsyncRestResponseMethodName(), clientMethod.getArgumentList());\n+            function.indent((() -> {\n+                GenericType restAPIMethodClientReturnType = (GenericType) restAPIMethod.getReturnType().getClientType();\n+                IType returnValueTypeArgumentClientType = restAPIMethodClientReturnType.getTypeArguments()[0];\n+                if (GenericType.Flux(ClassType.ByteBuffer).equals(clientMethod.getReturnValue().getType())) {\n+                    function.text(\".flatMapMany(StreamResponse::getValue);\");\n+                } else if (!GenericType.Mono(ClassType.Void).equals(clientMethod.getReturnValue().getType()) &&\n+                        !GenericType.Flux(ClassType.Void).equals(clientMethod.getReturnValue().getType())) {\n+                    function.text(\".flatMap(\");\n+                    function.lambda(returnValueTypeArgumentClientType.toString(), \"res\", lambda -> {\n+                        lambda.ifBlock(\"res.getValue() != null\", ifAction -> {\n+                            ifAction.methodReturn(\"Mono.just(res.getValue())\");\n+                        }).elseBlock(elseAction -> {\n+                            elseAction.methodReturn(\"Mono.empty()\");\n+                        });\n+                    });\n+                    function.line(\");\");\n                 } else {\n-                    // ***WithRestResponse method.\n-                    //\n+                    function.text(\".flatMap(\");\n+                    function.lambda(returnValueTypeArgumentClientType.toString(), \"res\", \"Mono.empty()\");\n+                    function.line(\");\");\n+                }\n+            }));\n+        }));\n+    }\n+\n+    private void writePagingAsyncMethod(ClientMethod clientMethod, JavaType typeBlock, JavaSettings settings, ProxyMethod restAPIMethod) {\n+        if (clientMethod.getName().contains(\"Async\")) {\n+            final Optional<ClientMethodParameter> lastParamOpt = clientMethod.getMethodRequiredParameters()\n+                    .stream()\n+                    .reduce((current, next) -> next);\n+            final ClientMethodParameter lastParam = lastParamOpt.get();\n+            final GenericType callbackParameterType = (GenericType) lastParam.getWireType();\n+\n+            typeBlock.publicMethod(clientMethod.getDeclaration(),\n+                function -> {\n+                    final IType collectionType = callbackParameterType.getTypeArguments()[0];\n+                    final IType elementType = ((GenericType) collectionType).getTypeArguments()[0];\n+\n+                    String retrieverClassName = elementType.toString() + \"PageAsyncRetriever\";\n+                    StringBuilder retrieverConstructionBuilder = new StringBuilder();\n+                    retrieverConstructionBuilder.append(String.format(\"%1$s retriever = new %1$s(\", retrieverClassName));\n+                    boolean hasPreviousParam = false;\n+                    for (ClientMethodParameter clientMethodParameter : clientMethod.getMethodParameters()) {\n+                        if (clientMethodParameter.getName().contains(\"collectionCallback\")) {", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcwNzc1OQ==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497707759", "bodyText": "Try to avoid using name for logic", "author": "JianpingChen", "createdAt": "2020-09-30T18:13:13Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/AndroidClientMethodTemplate.java", "diffHunk": "@@ -406,198 +393,353 @@ public void write(ClientMethod clientMethod, JavaType typeBlock) {\n         ProxyMethod restAPIMethod = clientMethod.getProxyMethod();\n         generateJavadoc(clientMethod, typeBlock, restAPIMethod);\n \n-\n         clientMethod.getProxyMethod().getRequestContentType();\n-        List<ClientMethodParameter> parameters = clientMethod.getMethodParameters();\n-\n-\n-\n         switch (clientMethod.getType()) {\n             case SimpleAsyncRestResponse:\n                 // async method\n-                boolean generateAsyncMethodWithOnlyRequiredParams = clientMethod.getOnlyRequiredParameters();\n-                if (generateAsyncMethodWithOnlyRequiredParams) {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-                                // async-method-with-only-required-params delegate call to\n-                                // async-method-with-required-and-optional-param.\n-                                //\n-                                addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n-                                function.line(\"%s(%s);\",\n-                                        clientMethod.getName(), clientMethod.getArgumentList());\n-                            });\n-                } else {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-\n-                                final Optional<ClientMethodParameter> lastParamOpt = clientMethod.getMethodRequiredParameters()\n-                                        .stream()\n-                                        .reduce((current, next) -> next);\n-                                final ClientMethodParameter lastParam = lastParamOpt.get();\n-                                final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n-                                final String callbackParameterName = lastParam.getName();\n-\n-                                final String clientReferenceDot;\n-                                if (clientMethod.getClientReference().equals(\"this\")) {\n-                                    // 'this' is not resolvable from callback remove it.\n-                                    clientReferenceDot = \"\";\n-                                } else {\n-                                    clientReferenceDot = clientMethod.getClientReference().replace(\"this.\", \"\") + \".\";\n-                                }\n-\n-                                addValidations(function,\n-                                        clientMethod.getRequiredNullableParameterExpressions(),\n-                                        clientMethod.getValidateExpressions(),\n-                                        true,\n-                                        (exception, onError) -> {\n-                                            onError.line(\"%s.onFailure(%s, null);\", callbackParameterName, exception);\n-                                            onError.line(\"return;\");\n-                                            return null;\n-                                        },\n-                                        settings);\n-                                addOptionalAndConstantVariables(function,\n-                                        clientMethod,\n-                                        restAPIMethod.getParameters(),\n-                                        settings);\n-                                applyParameterTransformations(function,\n-                                        clientMethod,\n-                                        settings);\n-                                convertClientTypesToWireTypes(function,\n-                                        clientMethod,\n-                                        restAPIMethod.getParameters(),\n-                                        clientReferenceDot,\n-                                        (exception, onError) -> {\n-                                            onError.line(String.format(\"%s.onFailure(%s, null);\", callbackParameterName, exception));\n-                                            onError.line(\"return;\");\n-                                            return null;\n-                                        },\n-                                        settings);\n-                                String retrofitAPIArgsList = String.join(\", \",\n-                                        clientMethod.getProxyMethodArguments(settings));\n-                                String retrofitAPICall = String.format(\"service.%s(%s)\",\n-                                        restAPIMethod.getName(),\n-                                        retrofitAPIArgsList);\n-\n-                                function.line(\"Call<ResponseBody> call = %s;\", retrofitAPICall);\n-                                function.anonymousClass(\"retrofit2.Callback<ResponseBody>\",\n-                                        \"retrofitCallback\",\n-                                        anonymousCls -> {\n-                                    anonymousCls.annotation(\"Override\");\n-                                    anonymousCls.publicMethod(\"void onResponse(Call<okhttp3.ResponseBody> call, retrofit2.Response<ResponseBody> response)\",\n-                                            onResponseBlock -> onResponseBlock.ifBlock(\"response.isSuccessful()\", responseSuccessBlock -> {\n-                                                List<HttpResponseStatus> successStatusCodes = clientMethod.getProxyMethod().getResponseExpectedStatusCodes();\n-                                                String successCodeExpression = successStatusCodes\n-                                                        .stream()\n-                                                        .map(statusCode -> String.format(\"response.code() == %d\", statusCode.code()))\n-                                                        .collect(Collectors.joining(\" || \"));\n-\n-\n-                                                responseSuccessBlock.ifBlock(successCodeExpression, succeededCodeBlock -> {\n-                                                    IType bodyType = callbackParameter.getTypeArguments()[0];\n-                                                    if (bodyType == PrimitiveType.Void) {\n-                                                        succeededCodeBlock.line(\"response.body().close();\");\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(null, response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    } else if (bodyType == ClassType.OkHttp3ResponseBody) {\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(response.body(), response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    } else {\n-                                                        final String bodyJvaType;\n-                                                        if (bodyType instanceof ListType || bodyType instanceof MapType) {\n-                                                            StringBuilder builder = new StringBuilder();\n-                                                            builder.append(clientReferenceDot);\n-                                                            parameterizedTypeExpression(bodyType, builder);\n-                                                            bodyJvaType = builder.toString();\n-                                                        } else {\n-                                                            bodyJvaType = String.format(\"%s.class\", bodyType);\n-                                                        }\n-\n-                                                        List<String> exceptions = new ArrayList<>();\n-                                                        exceptions.add(\"Exception\");\n-                                                        succeededCodeBlock.line(\"final %s decodedResult;\", bodyType);\n-                                                        succeededCodeBlock.tryCatch(tryBlock -> {\n-                                                                    succeededCodeBlock.line(\"decodedResult = %sdeserializeContent(response.headers(), response.body(), %s);\",\n-                                                                            clientReferenceDot,\n-                                                                            bodyJvaType);\n-                                                                },\n-                                                                exceptions,\n-                                                                \"ex\",\n-                                                                catchBlock -> {\n-                                                                    catchBlock\n-                                                                            .line(String.format(\"%s.onFailure(ex, response.raw());\",\n-                                                                                    callbackParameterName));\n-                                                                    catchBlock.line(\"return;\");\n-                                                                },\n-                                                                null);\n-\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(decodedResult, response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    }\n-                                                }).elseBlock(errorCodeBlock -> {\n-                                                    errorCodeBlock.line(\"final String strContent = %sreadAsString(response.body());\", clientReferenceDot);\n-                                                    ClassType exceptionType = clientMethod.getProxyMethod().getUnexpectedResponseExceptionType();\n-                                                    String exceptionCreateExpression = String.format(\"new %s(strContent, response.raw())\", exceptionType.getName());\n-                                                    errorCodeBlock\n-                                                            .line(String.format(\"%s.onFailure(%s, response.raw());\",\n-                                                                    callbackParameterName,\n-                                                                    exceptionCreateExpression));\n-                                                });\n-                                            }).elseBlock(responseFailureBlock -> {\n-                                                responseFailureBlock.line(\"final String strContent = %sreadAsString(response.errorBody());\", clientReferenceDot);\n-                                                responseFailureBlock.line(String.format(\"%s.onFailure(new HttpResponseException(strContent, response.raw()), response.raw());\",\n-                                                        callbackParameterName));\n-                                            }));\n-\n-                                    anonymousCls.annotation(\"Override\");\n-                                    anonymousCls.publicMethod(\"void onFailure(Call<ResponseBody> call, Throwable t)\",\n-                                            onFailureBlock -> {\n-                                                onFailureBlock.line(String.format(\"%s.onFailure(t, null);\", callbackParameterName));\n-                                            });\n-                                });\n-                                function.line(\"call.enqueue(retrofitCallback);\");\n-                            });\n-                }\n+                writeAsyncWithRestResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, false);\n                 break;\n \n             case SimpleSync:\n                 // sync method\n-                boolean generateSyncMethodWithOnlyRequiredParams = clientMethod.getOnlyRequiredParameters();\n-                if (generateSyncMethodWithOnlyRequiredParams) {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-                                // sync-method-with-only-required-params delegate call to\n-                                // sync-method-with-required-and-optional-param.\n-                                //\n-                                addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n-                                IType returnType = clientMethod.getReturnValue().getType();\n-                                if (returnType == PrimitiveType.Void) {\n-                                    function.line(\"%sWithRestResponse(%s);\",\n-                                            clientMethod.getName(), clientMethod.getArgumentList());\n-                                } else {\n-                                    function.line(\"return %sWithRestResponse(%s).getValue();\",\n-                                            clientMethod.getName(), clientMethod.getArgumentList());\n-                                }\n-                            });\n+                writeSyncWithResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, false);\n+                break;\n+\n+            case PagingSync:\n+                writePagingSyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+\n+            case PagingAsync:\n+                writePagingAsyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+            case PagingAsyncSinglePage:\n+                generatePagedAsyncSinglePage(clientMethod, typeBlock, restAPIMethod, settings);\n+                break;\n+\n+            case LongRunningSync:\n+                // LongRunningAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningAsync:\n+                // LongRunningAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningBeginAsync:\n+                // LongRunningBeginAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningBeginSync:\n+                // LongRunningBeginSync not applicable to data-plane android\n+                break;\n+\n+            case Resumable:\n+                // Resumable not applicable to data-plane android\n+                break;\n+\n+            case SimpleAsync:\n+                writeSimpleAsyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+        }\n+    }\n+\n+    private void writeSimpleAsyncMethod(ClientMethod clientMethod, JavaType typeBlock, JavaSettings settings, ProxyMethod restAPIMethod) {\n+        typeBlock.publicMethod(clientMethod.getDeclaration(), (function -> {\n+            addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n+            function.line(\"return %s(%s)\", clientMethod.getProxyMethod().getSimpleAsyncRestResponseMethodName(), clientMethod.getArgumentList());\n+            function.indent((() -> {\n+                GenericType restAPIMethodClientReturnType = (GenericType) restAPIMethod.getReturnType().getClientType();\n+                IType returnValueTypeArgumentClientType = restAPIMethodClientReturnType.getTypeArguments()[0];\n+                if (GenericType.Flux(ClassType.ByteBuffer).equals(clientMethod.getReturnValue().getType())) {\n+                    function.text(\".flatMapMany(StreamResponse::getValue);\");\n+                } else if (!GenericType.Mono(ClassType.Void).equals(clientMethod.getReturnValue().getType()) &&\n+                        !GenericType.Flux(ClassType.Void).equals(clientMethod.getReturnValue().getType())) {\n+                    function.text(\".flatMap(\");\n+                    function.lambda(returnValueTypeArgumentClientType.toString(), \"res\", lambda -> {\n+                        lambda.ifBlock(\"res.getValue() != null\", ifAction -> {\n+                            ifAction.methodReturn(\"Mono.just(res.getValue())\");\n+                        }).elseBlock(elseAction -> {\n+                            elseAction.methodReturn(\"Mono.empty()\");\n+                        });\n+                    });\n+                    function.line(\");\");\n                 } else {\n-                    // ***WithRestResponse method.\n-                    //\n+                    function.text(\".flatMap(\");\n+                    function.lambda(returnValueTypeArgumentClientType.toString(), \"res\", \"Mono.empty()\");\n+                    function.line(\");\");\n+                }\n+            }));\n+        }));\n+    }\n+\n+    private void writePagingAsyncMethod(ClientMethod clientMethod, JavaType typeBlock, JavaSettings settings, ProxyMethod restAPIMethod) {\n+        if (clientMethod.getName().contains(\"Async\")) {\n+            final Optional<ClientMethodParameter> lastParamOpt = clientMethod.getMethodRequiredParameters()\n+                    .stream()\n+                    .reduce((current, next) -> next);\n+            final ClientMethodParameter lastParam = lastParamOpt.get();\n+            final GenericType callbackParameterType = (GenericType) lastParam.getWireType();\n+\n+            typeBlock.publicMethod(clientMethod.getDeclaration(),\n+                function -> {\n+                    final IType collectionType = callbackParameterType.getTypeArguments()[0];\n+                    final IType elementType = ((GenericType) collectionType).getTypeArguments()[0];\n+\n+                    String retrieverClassName = elementType.toString() + \"PageAsyncRetriever\";\n+                    StringBuilder retrieverConstructionBuilder = new StringBuilder();\n+                    retrieverConstructionBuilder.append(String.format(\"%1$s retriever = new %1$s(\", retrieverClassName));\n+                    boolean hasPreviousParam = false;\n+                    for (ClientMethodParameter clientMethodParameter : clientMethod.getMethodParameters()) {\n+                        if (clientMethodParameter.getName().contains(\"collectionCallback\")) {\n+                            continue;\n+                        }\n+                        if (hasPreviousParam) {\n+                            retrieverConstructionBuilder.append(\", \");\n+                        }\n+                        retrieverConstructionBuilder.append(clientMethodParameter.getName());\n+                        hasPreviousParam = true;\n+                    }\n+                    if (hasPreviousParam) {\n+                        retrieverConstructionBuilder.append(\", \");\n+                    }\n+                    retrieverConstructionBuilder.append(\"this);\");\n+                    function.line(retrieverConstructionBuilder.toString());\n+                    function.line(String.format(\"%1$s.onSuccess(new AsyncPagedDataCollection<%2$s, Page<%2$s>>(retriever), null);\", lastParam.getName(), elementType));\n+                });\n+            return;\n+        }\n+        writeAsyncWithRestResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, true);\n+    }\n+\n+    private void writePagingSyncMethod(ClientMethod clientMethod, JavaType typeBlock, JavaSettings settings, ProxyMethod restAPIMethod) {\n+        if (clientMethod.getName().contains(\"WithPageResponse\")\n+                        ||  clientMethod.getName().contains(\"WithPage\")) {", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcwODQ3NQ==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497708475", "bodyText": "Use a static method in retriever template", "author": "JianpingChen", "createdAt": "2020-09-30T18:14:34Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/AndroidClientMethodTemplate.java", "diffHunk": "@@ -406,198 +393,353 @@ public void write(ClientMethod clientMethod, JavaType typeBlock) {\n         ProxyMethod restAPIMethod = clientMethod.getProxyMethod();\n         generateJavadoc(clientMethod, typeBlock, restAPIMethod);\n \n-\n         clientMethod.getProxyMethod().getRequestContentType();\n-        List<ClientMethodParameter> parameters = clientMethod.getMethodParameters();\n-\n-\n-\n         switch (clientMethod.getType()) {\n             case SimpleAsyncRestResponse:\n                 // async method\n-                boolean generateAsyncMethodWithOnlyRequiredParams = clientMethod.getOnlyRequiredParameters();\n-                if (generateAsyncMethodWithOnlyRequiredParams) {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-                                // async-method-with-only-required-params delegate call to\n-                                // async-method-with-required-and-optional-param.\n-                                //\n-                                addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n-                                function.line(\"%s(%s);\",\n-                                        clientMethod.getName(), clientMethod.getArgumentList());\n-                            });\n-                } else {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-\n-                                final Optional<ClientMethodParameter> lastParamOpt = clientMethod.getMethodRequiredParameters()\n-                                        .stream()\n-                                        .reduce((current, next) -> next);\n-                                final ClientMethodParameter lastParam = lastParamOpt.get();\n-                                final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n-                                final String callbackParameterName = lastParam.getName();\n-\n-                                final String clientReferenceDot;\n-                                if (clientMethod.getClientReference().equals(\"this\")) {\n-                                    // 'this' is not resolvable from callback remove it.\n-                                    clientReferenceDot = \"\";\n-                                } else {\n-                                    clientReferenceDot = clientMethod.getClientReference().replace(\"this.\", \"\") + \".\";\n-                                }\n-\n-                                addValidations(function,\n-                                        clientMethod.getRequiredNullableParameterExpressions(),\n-                                        clientMethod.getValidateExpressions(),\n-                                        true,\n-                                        (exception, onError) -> {\n-                                            onError.line(\"%s.onFailure(%s, null);\", callbackParameterName, exception);\n-                                            onError.line(\"return;\");\n-                                            return null;\n-                                        },\n-                                        settings);\n-                                addOptionalAndConstantVariables(function,\n-                                        clientMethod,\n-                                        restAPIMethod.getParameters(),\n-                                        settings);\n-                                applyParameterTransformations(function,\n-                                        clientMethod,\n-                                        settings);\n-                                convertClientTypesToWireTypes(function,\n-                                        clientMethod,\n-                                        restAPIMethod.getParameters(),\n-                                        clientReferenceDot,\n-                                        (exception, onError) -> {\n-                                            onError.line(String.format(\"%s.onFailure(%s, null);\", callbackParameterName, exception));\n-                                            onError.line(\"return;\");\n-                                            return null;\n-                                        },\n-                                        settings);\n-                                String retrofitAPIArgsList = String.join(\", \",\n-                                        clientMethod.getProxyMethodArguments(settings));\n-                                String retrofitAPICall = String.format(\"service.%s(%s)\",\n-                                        restAPIMethod.getName(),\n-                                        retrofitAPIArgsList);\n-\n-                                function.line(\"Call<ResponseBody> call = %s;\", retrofitAPICall);\n-                                function.anonymousClass(\"retrofit2.Callback<ResponseBody>\",\n-                                        \"retrofitCallback\",\n-                                        anonymousCls -> {\n-                                    anonymousCls.annotation(\"Override\");\n-                                    anonymousCls.publicMethod(\"void onResponse(Call<okhttp3.ResponseBody> call, retrofit2.Response<ResponseBody> response)\",\n-                                            onResponseBlock -> onResponseBlock.ifBlock(\"response.isSuccessful()\", responseSuccessBlock -> {\n-                                                List<HttpResponseStatus> successStatusCodes = clientMethod.getProxyMethod().getResponseExpectedStatusCodes();\n-                                                String successCodeExpression = successStatusCodes\n-                                                        .stream()\n-                                                        .map(statusCode -> String.format(\"response.code() == %d\", statusCode.code()))\n-                                                        .collect(Collectors.joining(\" || \"));\n-\n-\n-                                                responseSuccessBlock.ifBlock(successCodeExpression, succeededCodeBlock -> {\n-                                                    IType bodyType = callbackParameter.getTypeArguments()[0];\n-                                                    if (bodyType == PrimitiveType.Void) {\n-                                                        succeededCodeBlock.line(\"response.body().close();\");\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(null, response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    } else if (bodyType == ClassType.OkHttp3ResponseBody) {\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(response.body(), response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    } else {\n-                                                        final String bodyJvaType;\n-                                                        if (bodyType instanceof ListType || bodyType instanceof MapType) {\n-                                                            StringBuilder builder = new StringBuilder();\n-                                                            builder.append(clientReferenceDot);\n-                                                            parameterizedTypeExpression(bodyType, builder);\n-                                                            bodyJvaType = builder.toString();\n-                                                        } else {\n-                                                            bodyJvaType = String.format(\"%s.class\", bodyType);\n-                                                        }\n-\n-                                                        List<String> exceptions = new ArrayList<>();\n-                                                        exceptions.add(\"Exception\");\n-                                                        succeededCodeBlock.line(\"final %s decodedResult;\", bodyType);\n-                                                        succeededCodeBlock.tryCatch(tryBlock -> {\n-                                                                    succeededCodeBlock.line(\"decodedResult = %sdeserializeContent(response.headers(), response.body(), %s);\",\n-                                                                            clientReferenceDot,\n-                                                                            bodyJvaType);\n-                                                                },\n-                                                                exceptions,\n-                                                                \"ex\",\n-                                                                catchBlock -> {\n-                                                                    catchBlock\n-                                                                            .line(String.format(\"%s.onFailure(ex, response.raw());\",\n-                                                                                    callbackParameterName));\n-                                                                    catchBlock.line(\"return;\");\n-                                                                },\n-                                                                null);\n-\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(decodedResult, response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    }\n-                                                }).elseBlock(errorCodeBlock -> {\n-                                                    errorCodeBlock.line(\"final String strContent = %sreadAsString(response.body());\", clientReferenceDot);\n-                                                    ClassType exceptionType = clientMethod.getProxyMethod().getUnexpectedResponseExceptionType();\n-                                                    String exceptionCreateExpression = String.format(\"new %s(strContent, response.raw())\", exceptionType.getName());\n-                                                    errorCodeBlock\n-                                                            .line(String.format(\"%s.onFailure(%s, response.raw());\",\n-                                                                    callbackParameterName,\n-                                                                    exceptionCreateExpression));\n-                                                });\n-                                            }).elseBlock(responseFailureBlock -> {\n-                                                responseFailureBlock.line(\"final String strContent = %sreadAsString(response.errorBody());\", clientReferenceDot);\n-                                                responseFailureBlock.line(String.format(\"%s.onFailure(new HttpResponseException(strContent, response.raw()), response.raw());\",\n-                                                        callbackParameterName));\n-                                            }));\n-\n-                                    anonymousCls.annotation(\"Override\");\n-                                    anonymousCls.publicMethod(\"void onFailure(Call<ResponseBody> call, Throwable t)\",\n-                                            onFailureBlock -> {\n-                                                onFailureBlock.line(String.format(\"%s.onFailure(t, null);\", callbackParameterName));\n-                                            });\n-                                });\n-                                function.line(\"call.enqueue(retrofitCallback);\");\n-                            });\n-                }\n+                writeAsyncWithRestResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, false);\n                 break;\n \n             case SimpleSync:\n                 // sync method\n-                boolean generateSyncMethodWithOnlyRequiredParams = clientMethod.getOnlyRequiredParameters();\n-                if (generateSyncMethodWithOnlyRequiredParams) {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-                                // sync-method-with-only-required-params delegate call to\n-                                // sync-method-with-required-and-optional-param.\n-                                //\n-                                addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n-                                IType returnType = clientMethod.getReturnValue().getType();\n-                                if (returnType == PrimitiveType.Void) {\n-                                    function.line(\"%sWithRestResponse(%s);\",\n-                                            clientMethod.getName(), clientMethod.getArgumentList());\n-                                } else {\n-                                    function.line(\"return %sWithRestResponse(%s).getValue();\",\n-                                            clientMethod.getName(), clientMethod.getArgumentList());\n-                                }\n-                            });\n+                writeSyncWithResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, false);\n+                break;\n+\n+            case PagingSync:\n+                writePagingSyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+\n+            case PagingAsync:\n+                writePagingAsyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+            case PagingAsyncSinglePage:\n+                generatePagedAsyncSinglePage(clientMethod, typeBlock, restAPIMethod, settings);\n+                break;\n+\n+            case LongRunningSync:\n+                // LongRunningAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningAsync:\n+                // LongRunningAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningBeginAsync:\n+                // LongRunningBeginAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningBeginSync:\n+                // LongRunningBeginSync not applicable to data-plane android\n+                break;\n+\n+            case Resumable:\n+                // Resumable not applicable to data-plane android\n+                break;\n+\n+            case SimpleAsync:\n+                writeSimpleAsyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+        }\n+    }\n+\n+    private void writeSimpleAsyncMethod(ClientMethod clientMethod, JavaType typeBlock, JavaSettings settings, ProxyMethod restAPIMethod) {\n+        typeBlock.publicMethod(clientMethod.getDeclaration(), (function -> {\n+            addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n+            function.line(\"return %s(%s)\", clientMethod.getProxyMethod().getSimpleAsyncRestResponseMethodName(), clientMethod.getArgumentList());\n+            function.indent((() -> {\n+                GenericType restAPIMethodClientReturnType = (GenericType) restAPIMethod.getReturnType().getClientType();\n+                IType returnValueTypeArgumentClientType = restAPIMethodClientReturnType.getTypeArguments()[0];\n+                if (GenericType.Flux(ClassType.ByteBuffer).equals(clientMethod.getReturnValue().getType())) {\n+                    function.text(\".flatMapMany(StreamResponse::getValue);\");\n+                } else if (!GenericType.Mono(ClassType.Void).equals(clientMethod.getReturnValue().getType()) &&\n+                        !GenericType.Flux(ClassType.Void).equals(clientMethod.getReturnValue().getType())) {\n+                    function.text(\".flatMap(\");\n+                    function.lambda(returnValueTypeArgumentClientType.toString(), \"res\", lambda -> {\n+                        lambda.ifBlock(\"res.getValue() != null\", ifAction -> {\n+                            ifAction.methodReturn(\"Mono.just(res.getValue())\");\n+                        }).elseBlock(elseAction -> {\n+                            elseAction.methodReturn(\"Mono.empty()\");\n+                        });\n+                    });\n+                    function.line(\");\");\n                 } else {\n-                    // ***WithRestResponse method.\n-                    //\n+                    function.text(\".flatMap(\");\n+                    function.lambda(returnValueTypeArgumentClientType.toString(), \"res\", \"Mono.empty()\");\n+                    function.line(\");\");\n+                }\n+            }));\n+        }));\n+    }\n+\n+    private void writePagingAsyncMethod(ClientMethod clientMethod, JavaType typeBlock, JavaSettings settings, ProxyMethod restAPIMethod) {\n+        if (clientMethod.getName().contains(\"Async\")) {\n+            final Optional<ClientMethodParameter> lastParamOpt = clientMethod.getMethodRequiredParameters()\n+                    .stream()\n+                    .reduce((current, next) -> next);\n+            final ClientMethodParameter lastParam = lastParamOpt.get();\n+            final GenericType callbackParameterType = (GenericType) lastParam.getWireType();\n+\n+            typeBlock.publicMethod(clientMethod.getDeclaration(),\n+                function -> {\n+                    final IType collectionType = callbackParameterType.getTypeArguments()[0];\n+                    final IType elementType = ((GenericType) collectionType).getTypeArguments()[0];\n+\n+                    String retrieverClassName = elementType.toString() + \"PageAsyncRetriever\";\n+                    StringBuilder retrieverConstructionBuilder = new StringBuilder();\n+                    retrieverConstructionBuilder.append(String.format(\"%1$s retriever = new %1$s(\", retrieverClassName));\n+                    boolean hasPreviousParam = false;\n+                    for (ClientMethodParameter clientMethodParameter : clientMethod.getMethodParameters()) {\n+                        if (clientMethodParameter.getName().contains(\"collectionCallback\")) {\n+                            continue;\n+                        }\n+                        if (hasPreviousParam) {\n+                            retrieverConstructionBuilder.append(\", \");\n+                        }\n+                        retrieverConstructionBuilder.append(clientMethodParameter.getName());\n+                        hasPreviousParam = true;\n+                    }\n+                    if (hasPreviousParam) {\n+                        retrieverConstructionBuilder.append(\", \");\n+                    }\n+                    retrieverConstructionBuilder.append(\"this);\");\n+                    function.line(retrieverConstructionBuilder.toString());\n+                    function.line(String.format(\"%1$s.onSuccess(new AsyncPagedDataCollection<%2$s, Page<%2$s>>(retriever), null);\", lastParam.getName(), elementType));\n+                });\n+            return;\n+        }\n+        writeAsyncWithRestResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, true);\n+    }\n+\n+    private void writePagingSyncMethod(ClientMethod clientMethod, JavaType typeBlock, JavaSettings settings, ProxyMethod restAPIMethod) {\n+        if (clientMethod.getName().contains(\"WithPageResponse\")\n+                        ||  clientMethod.getName().contains(\"WithPage\")) {\n+            typeBlock.publicMethod(clientMethod.getDeclaration(), function -> {\n+                IType elementType = ((GenericType) clientMethod.getReturnValue().getType()).getTypeArguments()[0];\n+\n+                String retrieverClassName = elementType.toString() +\n+                        (clientMethod.getName().contains(\"WithPageResponse\") ? \"PageResponseRetriever\" : \"PageRetriever\");", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcwOTExOQ==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497709119", "bodyText": "Try to use names defined in GenericType", "author": "JianpingChen", "createdAt": "2020-09-30T18:15:43Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/AndroidClientMethodTemplate.java", "diffHunk": "@@ -406,198 +393,353 @@ public void write(ClientMethod clientMethod, JavaType typeBlock) {\n         ProxyMethod restAPIMethod = clientMethod.getProxyMethod();\n         generateJavadoc(clientMethod, typeBlock, restAPIMethod);\n \n-\n         clientMethod.getProxyMethod().getRequestContentType();\n-        List<ClientMethodParameter> parameters = clientMethod.getMethodParameters();\n-\n-\n-\n         switch (clientMethod.getType()) {\n             case SimpleAsyncRestResponse:\n                 // async method\n-                boolean generateAsyncMethodWithOnlyRequiredParams = clientMethod.getOnlyRequiredParameters();\n-                if (generateAsyncMethodWithOnlyRequiredParams) {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-                                // async-method-with-only-required-params delegate call to\n-                                // async-method-with-required-and-optional-param.\n-                                //\n-                                addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n-                                function.line(\"%s(%s);\",\n-                                        clientMethod.getName(), clientMethod.getArgumentList());\n-                            });\n-                } else {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-\n-                                final Optional<ClientMethodParameter> lastParamOpt = clientMethod.getMethodRequiredParameters()\n-                                        .stream()\n-                                        .reduce((current, next) -> next);\n-                                final ClientMethodParameter lastParam = lastParamOpt.get();\n-                                final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n-                                final String callbackParameterName = lastParam.getName();\n-\n-                                final String clientReferenceDot;\n-                                if (clientMethod.getClientReference().equals(\"this\")) {\n-                                    // 'this' is not resolvable from callback remove it.\n-                                    clientReferenceDot = \"\";\n-                                } else {\n-                                    clientReferenceDot = clientMethod.getClientReference().replace(\"this.\", \"\") + \".\";\n-                                }\n-\n-                                addValidations(function,\n-                                        clientMethod.getRequiredNullableParameterExpressions(),\n-                                        clientMethod.getValidateExpressions(),\n-                                        true,\n-                                        (exception, onError) -> {\n-                                            onError.line(\"%s.onFailure(%s, null);\", callbackParameterName, exception);\n-                                            onError.line(\"return;\");\n-                                            return null;\n-                                        },\n-                                        settings);\n-                                addOptionalAndConstantVariables(function,\n-                                        clientMethod,\n-                                        restAPIMethod.getParameters(),\n-                                        settings);\n-                                applyParameterTransformations(function,\n-                                        clientMethod,\n-                                        settings);\n-                                convertClientTypesToWireTypes(function,\n-                                        clientMethod,\n-                                        restAPIMethod.getParameters(),\n-                                        clientReferenceDot,\n-                                        (exception, onError) -> {\n-                                            onError.line(String.format(\"%s.onFailure(%s, null);\", callbackParameterName, exception));\n-                                            onError.line(\"return;\");\n-                                            return null;\n-                                        },\n-                                        settings);\n-                                String retrofitAPIArgsList = String.join(\", \",\n-                                        clientMethod.getProxyMethodArguments(settings));\n-                                String retrofitAPICall = String.format(\"service.%s(%s)\",\n-                                        restAPIMethod.getName(),\n-                                        retrofitAPIArgsList);\n-\n-                                function.line(\"Call<ResponseBody> call = %s;\", retrofitAPICall);\n-                                function.anonymousClass(\"retrofit2.Callback<ResponseBody>\",\n-                                        \"retrofitCallback\",\n-                                        anonymousCls -> {\n-                                    anonymousCls.annotation(\"Override\");\n-                                    anonymousCls.publicMethod(\"void onResponse(Call<okhttp3.ResponseBody> call, retrofit2.Response<ResponseBody> response)\",\n-                                            onResponseBlock -> onResponseBlock.ifBlock(\"response.isSuccessful()\", responseSuccessBlock -> {\n-                                                List<HttpResponseStatus> successStatusCodes = clientMethod.getProxyMethod().getResponseExpectedStatusCodes();\n-                                                String successCodeExpression = successStatusCodes\n-                                                        .stream()\n-                                                        .map(statusCode -> String.format(\"response.code() == %d\", statusCode.code()))\n-                                                        .collect(Collectors.joining(\" || \"));\n-\n-\n-                                                responseSuccessBlock.ifBlock(successCodeExpression, succeededCodeBlock -> {\n-                                                    IType bodyType = callbackParameter.getTypeArguments()[0];\n-                                                    if (bodyType == PrimitiveType.Void) {\n-                                                        succeededCodeBlock.line(\"response.body().close();\");\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(null, response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    } else if (bodyType == ClassType.OkHttp3ResponseBody) {\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(response.body(), response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    } else {\n-                                                        final String bodyJvaType;\n-                                                        if (bodyType instanceof ListType || bodyType instanceof MapType) {\n-                                                            StringBuilder builder = new StringBuilder();\n-                                                            builder.append(clientReferenceDot);\n-                                                            parameterizedTypeExpression(bodyType, builder);\n-                                                            bodyJvaType = builder.toString();\n-                                                        } else {\n-                                                            bodyJvaType = String.format(\"%s.class\", bodyType);\n-                                                        }\n-\n-                                                        List<String> exceptions = new ArrayList<>();\n-                                                        exceptions.add(\"Exception\");\n-                                                        succeededCodeBlock.line(\"final %s decodedResult;\", bodyType);\n-                                                        succeededCodeBlock.tryCatch(tryBlock -> {\n-                                                                    succeededCodeBlock.line(\"decodedResult = %sdeserializeContent(response.headers(), response.body(), %s);\",\n-                                                                            clientReferenceDot,\n-                                                                            bodyJvaType);\n-                                                                },\n-                                                                exceptions,\n-                                                                \"ex\",\n-                                                                catchBlock -> {\n-                                                                    catchBlock\n-                                                                            .line(String.format(\"%s.onFailure(ex, response.raw());\",\n-                                                                                    callbackParameterName));\n-                                                                    catchBlock.line(\"return;\");\n-                                                                },\n-                                                                null);\n-\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(decodedResult, response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    }\n-                                                }).elseBlock(errorCodeBlock -> {\n-                                                    errorCodeBlock.line(\"final String strContent = %sreadAsString(response.body());\", clientReferenceDot);\n-                                                    ClassType exceptionType = clientMethod.getProxyMethod().getUnexpectedResponseExceptionType();\n-                                                    String exceptionCreateExpression = String.format(\"new %s(strContent, response.raw())\", exceptionType.getName());\n-                                                    errorCodeBlock\n-                                                            .line(String.format(\"%s.onFailure(%s, response.raw());\",\n-                                                                    callbackParameterName,\n-                                                                    exceptionCreateExpression));\n-                                                });\n-                                            }).elseBlock(responseFailureBlock -> {\n-                                                responseFailureBlock.line(\"final String strContent = %sreadAsString(response.errorBody());\", clientReferenceDot);\n-                                                responseFailureBlock.line(String.format(\"%s.onFailure(new HttpResponseException(strContent, response.raw()), response.raw());\",\n-                                                        callbackParameterName));\n-                                            }));\n-\n-                                    anonymousCls.annotation(\"Override\");\n-                                    anonymousCls.publicMethod(\"void onFailure(Call<ResponseBody> call, Throwable t)\",\n-                                            onFailureBlock -> {\n-                                                onFailureBlock.line(String.format(\"%s.onFailure(t, null);\", callbackParameterName));\n-                                            });\n-                                });\n-                                function.line(\"call.enqueue(retrofitCallback);\");\n-                            });\n-                }\n+                writeAsyncWithRestResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, false);\n                 break;\n \n             case SimpleSync:\n                 // sync method\n-                boolean generateSyncMethodWithOnlyRequiredParams = clientMethod.getOnlyRequiredParameters();\n-                if (generateSyncMethodWithOnlyRequiredParams) {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-                                // sync-method-with-only-required-params delegate call to\n-                                // sync-method-with-required-and-optional-param.\n-                                //\n-                                addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n-                                IType returnType = clientMethod.getReturnValue().getType();\n-                                if (returnType == PrimitiveType.Void) {\n-                                    function.line(\"%sWithRestResponse(%s);\",\n-                                            clientMethod.getName(), clientMethod.getArgumentList());\n-                                } else {\n-                                    function.line(\"return %sWithRestResponse(%s).getValue();\",\n-                                            clientMethod.getName(), clientMethod.getArgumentList());\n-                                }\n-                            });\n+                writeSyncWithResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, false);\n+                break;\n+\n+            case PagingSync:\n+                writePagingSyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+\n+            case PagingAsync:\n+                writePagingAsyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+            case PagingAsyncSinglePage:\n+                generatePagedAsyncSinglePage(clientMethod, typeBlock, restAPIMethod, settings);\n+                break;\n+\n+            case LongRunningSync:\n+                // LongRunningAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningAsync:\n+                // LongRunningAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningBeginAsync:\n+                // LongRunningBeginAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningBeginSync:\n+                // LongRunningBeginSync not applicable to data-plane android\n+                break;\n+\n+            case Resumable:\n+                // Resumable not applicable to data-plane android\n+                break;\n+\n+            case SimpleAsync:\n+                writeSimpleAsyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+        }\n+    }\n+\n+    private void writeSimpleAsyncMethod(ClientMethod clientMethod, JavaType typeBlock, JavaSettings settings, ProxyMethod restAPIMethod) {\n+        typeBlock.publicMethod(clientMethod.getDeclaration(), (function -> {\n+            addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n+            function.line(\"return %s(%s)\", clientMethod.getProxyMethod().getSimpleAsyncRestResponseMethodName(), clientMethod.getArgumentList());\n+            function.indent((() -> {\n+                GenericType restAPIMethodClientReturnType = (GenericType) restAPIMethod.getReturnType().getClientType();\n+                IType returnValueTypeArgumentClientType = restAPIMethodClientReturnType.getTypeArguments()[0];\n+                if (GenericType.Flux(ClassType.ByteBuffer).equals(clientMethod.getReturnValue().getType())) {\n+                    function.text(\".flatMapMany(StreamResponse::getValue);\");\n+                } else if (!GenericType.Mono(ClassType.Void).equals(clientMethod.getReturnValue().getType()) &&\n+                        !GenericType.Flux(ClassType.Void).equals(clientMethod.getReturnValue().getType())) {\n+                    function.text(\".flatMap(\");\n+                    function.lambda(returnValueTypeArgumentClientType.toString(), \"res\", lambda -> {\n+                        lambda.ifBlock(\"res.getValue() != null\", ifAction -> {\n+                            ifAction.methodReturn(\"Mono.just(res.getValue())\");\n+                        }).elseBlock(elseAction -> {\n+                            elseAction.methodReturn(\"Mono.empty()\");\n+                        });\n+                    });\n+                    function.line(\");\");\n                 } else {\n-                    // ***WithRestResponse method.\n-                    //\n+                    function.text(\".flatMap(\");\n+                    function.lambda(returnValueTypeArgumentClientType.toString(), \"res\", \"Mono.empty()\");\n+                    function.line(\");\");\n+                }\n+            }));\n+        }));\n+    }\n+\n+    private void writePagingAsyncMethod(ClientMethod clientMethod, JavaType typeBlock, JavaSettings settings, ProxyMethod restAPIMethod) {\n+        if (clientMethod.getName().contains(\"Async\")) {\n+            final Optional<ClientMethodParameter> lastParamOpt = clientMethod.getMethodRequiredParameters()\n+                    .stream()\n+                    .reduce((current, next) -> next);\n+            final ClientMethodParameter lastParam = lastParamOpt.get();\n+            final GenericType callbackParameterType = (GenericType) lastParam.getWireType();\n+\n+            typeBlock.publicMethod(clientMethod.getDeclaration(),\n+                function -> {\n+                    final IType collectionType = callbackParameterType.getTypeArguments()[0];\n+                    final IType elementType = ((GenericType) collectionType).getTypeArguments()[0];\n+\n+                    String retrieverClassName = elementType.toString() + \"PageAsyncRetriever\";\n+                    StringBuilder retrieverConstructionBuilder = new StringBuilder();\n+                    retrieverConstructionBuilder.append(String.format(\"%1$s retriever = new %1$s(\", retrieverClassName));\n+                    boolean hasPreviousParam = false;\n+                    for (ClientMethodParameter clientMethodParameter : clientMethod.getMethodParameters()) {\n+                        if (clientMethodParameter.getName().contains(\"collectionCallback\")) {\n+                            continue;\n+                        }\n+                        if (hasPreviousParam) {\n+                            retrieverConstructionBuilder.append(\", \");\n+                        }\n+                        retrieverConstructionBuilder.append(clientMethodParameter.getName());\n+                        hasPreviousParam = true;\n+                    }\n+                    if (hasPreviousParam) {\n+                        retrieverConstructionBuilder.append(\", \");\n+                    }\n+                    retrieverConstructionBuilder.append(\"this);\");\n+                    function.line(retrieverConstructionBuilder.toString());\n+                    function.line(String.format(\"%1$s.onSuccess(new AsyncPagedDataCollection<%2$s, Page<%2$s>>(retriever), null);\", lastParam.getName(), elementType));\n+                });\n+            return;\n+        }\n+        writeAsyncWithRestResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, true);\n+    }\n+\n+    private void writePagingSyncMethod(ClientMethod clientMethod, JavaType typeBlock, JavaSettings settings, ProxyMethod restAPIMethod) {\n+        if (clientMethod.getName().contains(\"WithPageResponse\")\n+                        ||  clientMethod.getName().contains(\"WithPage\")) {\n+            typeBlock.publicMethod(clientMethod.getDeclaration(), function -> {\n+                IType elementType = ((GenericType) clientMethod.getReturnValue().getType()).getTypeArguments()[0];\n+\n+                String retrieverClassName = elementType.toString() +\n+                        (clientMethod.getName().contains(\"WithPageResponse\") ? \"PageResponseRetriever\" : \"PageRetriever\");\n+                StringBuilder retrieverConstructionBuilder = new StringBuilder();\n+                retrieverConstructionBuilder.append(String.format(\"%1$s retriever = new %1$s(\", retrieverClassName));\n+                boolean hasPreviousParam = false;\n+                for (ClientMethodParameter clientMethodParameter : clientMethod.getMethodParameters()) {\n+                    if (hasPreviousParam) {\n+                        retrieverConstructionBuilder.append(\", \");\n+                    }\n+                    retrieverConstructionBuilder.append(clientMethodParameter.getName());\n+                    hasPreviousParam = true;\n+                }\n+                if (hasPreviousParam) {\n+                    retrieverConstructionBuilder.append(\", \");\n+                }\n+                retrieverConstructionBuilder.append(\"this);\");\n+                function.line(retrieverConstructionBuilder.toString());\n+                String collectionName = clientMethod.getName().contains(\"WithPageResponse\")\n+                        ? \"PagedDataResponseCollection\"", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcxMTMwNA==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497711304", "bodyText": "Avoid hard code \"nextLink\" here.", "author": "JianpingChen", "createdAt": "2020-09-30T18:19:52Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/AndroidClientMethodTemplate.java", "diffHunk": "@@ -406,198 +393,353 @@ public void write(ClientMethod clientMethod, JavaType typeBlock) {\n         ProxyMethod restAPIMethod = clientMethod.getProxyMethod();\n         generateJavadoc(clientMethod, typeBlock, restAPIMethod);\n \n-\n         clientMethod.getProxyMethod().getRequestContentType();\n-        List<ClientMethodParameter> parameters = clientMethod.getMethodParameters();\n-\n-\n-\n         switch (clientMethod.getType()) {\n             case SimpleAsyncRestResponse:\n                 // async method\n-                boolean generateAsyncMethodWithOnlyRequiredParams = clientMethod.getOnlyRequiredParameters();\n-                if (generateAsyncMethodWithOnlyRequiredParams) {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-                                // async-method-with-only-required-params delegate call to\n-                                // async-method-with-required-and-optional-param.\n-                                //\n-                                addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n-                                function.line(\"%s(%s);\",\n-                                        clientMethod.getName(), clientMethod.getArgumentList());\n-                            });\n-                } else {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-\n-                                final Optional<ClientMethodParameter> lastParamOpt = clientMethod.getMethodRequiredParameters()\n-                                        .stream()\n-                                        .reduce((current, next) -> next);\n-                                final ClientMethodParameter lastParam = lastParamOpt.get();\n-                                final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n-                                final String callbackParameterName = lastParam.getName();\n-\n-                                final String clientReferenceDot;\n-                                if (clientMethod.getClientReference().equals(\"this\")) {\n-                                    // 'this' is not resolvable from callback remove it.\n-                                    clientReferenceDot = \"\";\n-                                } else {\n-                                    clientReferenceDot = clientMethod.getClientReference().replace(\"this.\", \"\") + \".\";\n-                                }\n-\n-                                addValidations(function,\n-                                        clientMethod.getRequiredNullableParameterExpressions(),\n-                                        clientMethod.getValidateExpressions(),\n-                                        true,\n-                                        (exception, onError) -> {\n-                                            onError.line(\"%s.onFailure(%s, null);\", callbackParameterName, exception);\n-                                            onError.line(\"return;\");\n-                                            return null;\n-                                        },\n-                                        settings);\n-                                addOptionalAndConstantVariables(function,\n-                                        clientMethod,\n-                                        restAPIMethod.getParameters(),\n-                                        settings);\n-                                applyParameterTransformations(function,\n-                                        clientMethod,\n-                                        settings);\n-                                convertClientTypesToWireTypes(function,\n-                                        clientMethod,\n-                                        restAPIMethod.getParameters(),\n-                                        clientReferenceDot,\n-                                        (exception, onError) -> {\n-                                            onError.line(String.format(\"%s.onFailure(%s, null);\", callbackParameterName, exception));\n-                                            onError.line(\"return;\");\n-                                            return null;\n-                                        },\n-                                        settings);\n-                                String retrofitAPIArgsList = String.join(\", \",\n-                                        clientMethod.getProxyMethodArguments(settings));\n-                                String retrofitAPICall = String.format(\"service.%s(%s)\",\n-                                        restAPIMethod.getName(),\n-                                        retrofitAPIArgsList);\n-\n-                                function.line(\"Call<ResponseBody> call = %s;\", retrofitAPICall);\n-                                function.anonymousClass(\"retrofit2.Callback<ResponseBody>\",\n-                                        \"retrofitCallback\",\n-                                        anonymousCls -> {\n-                                    anonymousCls.annotation(\"Override\");\n-                                    anonymousCls.publicMethod(\"void onResponse(Call<okhttp3.ResponseBody> call, retrofit2.Response<ResponseBody> response)\",\n-                                            onResponseBlock -> onResponseBlock.ifBlock(\"response.isSuccessful()\", responseSuccessBlock -> {\n-                                                List<HttpResponseStatus> successStatusCodes = clientMethod.getProxyMethod().getResponseExpectedStatusCodes();\n-                                                String successCodeExpression = successStatusCodes\n-                                                        .stream()\n-                                                        .map(statusCode -> String.format(\"response.code() == %d\", statusCode.code()))\n-                                                        .collect(Collectors.joining(\" || \"));\n-\n-\n-                                                responseSuccessBlock.ifBlock(successCodeExpression, succeededCodeBlock -> {\n-                                                    IType bodyType = callbackParameter.getTypeArguments()[0];\n-                                                    if (bodyType == PrimitiveType.Void) {\n-                                                        succeededCodeBlock.line(\"response.body().close();\");\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(null, response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    } else if (bodyType == ClassType.OkHttp3ResponseBody) {\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(response.body(), response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    } else {\n-                                                        final String bodyJvaType;\n-                                                        if (bodyType instanceof ListType || bodyType instanceof MapType) {\n-                                                            StringBuilder builder = new StringBuilder();\n-                                                            builder.append(clientReferenceDot);\n-                                                            parameterizedTypeExpression(bodyType, builder);\n-                                                            bodyJvaType = builder.toString();\n-                                                        } else {\n-                                                            bodyJvaType = String.format(\"%s.class\", bodyType);\n-                                                        }\n-\n-                                                        List<String> exceptions = new ArrayList<>();\n-                                                        exceptions.add(\"Exception\");\n-                                                        succeededCodeBlock.line(\"final %s decodedResult;\", bodyType);\n-                                                        succeededCodeBlock.tryCatch(tryBlock -> {\n-                                                                    succeededCodeBlock.line(\"decodedResult = %sdeserializeContent(response.headers(), response.body(), %s);\",\n-                                                                            clientReferenceDot,\n-                                                                            bodyJvaType);\n-                                                                },\n-                                                                exceptions,\n-                                                                \"ex\",\n-                                                                catchBlock -> {\n-                                                                    catchBlock\n-                                                                            .line(String.format(\"%s.onFailure(ex, response.raw());\",\n-                                                                                    callbackParameterName));\n-                                                                    catchBlock.line(\"return;\");\n-                                                                },\n-                                                                null);\n-\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(decodedResult, response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    }\n-                                                }).elseBlock(errorCodeBlock -> {\n-                                                    errorCodeBlock.line(\"final String strContent = %sreadAsString(response.body());\", clientReferenceDot);\n-                                                    ClassType exceptionType = clientMethod.getProxyMethod().getUnexpectedResponseExceptionType();\n-                                                    String exceptionCreateExpression = String.format(\"new %s(strContent, response.raw())\", exceptionType.getName());\n-                                                    errorCodeBlock\n-                                                            .line(String.format(\"%s.onFailure(%s, response.raw());\",\n-                                                                    callbackParameterName,\n-                                                                    exceptionCreateExpression));\n-                                                });\n-                                            }).elseBlock(responseFailureBlock -> {\n-                                                responseFailureBlock.line(\"final String strContent = %sreadAsString(response.errorBody());\", clientReferenceDot);\n-                                                responseFailureBlock.line(String.format(\"%s.onFailure(new HttpResponseException(strContent, response.raw()), response.raw());\",\n-                                                        callbackParameterName));\n-                                            }));\n-\n-                                    anonymousCls.annotation(\"Override\");\n-                                    anonymousCls.publicMethod(\"void onFailure(Call<ResponseBody> call, Throwable t)\",\n-                                            onFailureBlock -> {\n-                                                onFailureBlock.line(String.format(\"%s.onFailure(t, null);\", callbackParameterName));\n-                                            });\n-                                });\n-                                function.line(\"call.enqueue(retrofitCallback);\");\n-                            });\n-                }\n+                writeAsyncWithRestResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, false);\n                 break;\n \n             case SimpleSync:\n                 // sync method\n-                boolean generateSyncMethodWithOnlyRequiredParams = clientMethod.getOnlyRequiredParameters();\n-                if (generateSyncMethodWithOnlyRequiredParams) {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-                                // sync-method-with-only-required-params delegate call to\n-                                // sync-method-with-required-and-optional-param.\n-                                //\n-                                addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n-                                IType returnType = clientMethod.getReturnValue().getType();\n-                                if (returnType == PrimitiveType.Void) {\n-                                    function.line(\"%sWithRestResponse(%s);\",\n-                                            clientMethod.getName(), clientMethod.getArgumentList());\n-                                } else {\n-                                    function.line(\"return %sWithRestResponse(%s).getValue();\",\n-                                            clientMethod.getName(), clientMethod.getArgumentList());\n-                                }\n-                            });\n+                writeSyncWithResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, false);\n+                break;\n+\n+            case PagingSync:\n+                writePagingSyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+\n+            case PagingAsync:\n+                writePagingAsyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+            case PagingAsyncSinglePage:\n+                generatePagedAsyncSinglePage(clientMethod, typeBlock, restAPIMethod, settings);\n+                break;\n+\n+            case LongRunningSync:\n+                // LongRunningAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningAsync:\n+                // LongRunningAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningBeginAsync:\n+                // LongRunningBeginAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningBeginSync:\n+                // LongRunningBeginSync not applicable to data-plane android\n+                break;\n+\n+            case Resumable:\n+                // Resumable not applicable to data-plane android\n+                break;\n+\n+            case SimpleAsync:\n+                writeSimpleAsyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+        }\n+    }\n+\n+    private void writeSimpleAsyncMethod(ClientMethod clientMethod, JavaType typeBlock, JavaSettings settings, ProxyMethod restAPIMethod) {\n+        typeBlock.publicMethod(clientMethod.getDeclaration(), (function -> {\n+            addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n+            function.line(\"return %s(%s)\", clientMethod.getProxyMethod().getSimpleAsyncRestResponseMethodName(), clientMethod.getArgumentList());\n+            function.indent((() -> {\n+                GenericType restAPIMethodClientReturnType = (GenericType) restAPIMethod.getReturnType().getClientType();\n+                IType returnValueTypeArgumentClientType = restAPIMethodClientReturnType.getTypeArguments()[0];\n+                if (GenericType.Flux(ClassType.ByteBuffer).equals(clientMethod.getReturnValue().getType())) {\n+                    function.text(\".flatMapMany(StreamResponse::getValue);\");\n+                } else if (!GenericType.Mono(ClassType.Void).equals(clientMethod.getReturnValue().getType()) &&\n+                        !GenericType.Flux(ClassType.Void).equals(clientMethod.getReturnValue().getType())) {\n+                    function.text(\".flatMap(\");\n+                    function.lambda(returnValueTypeArgumentClientType.toString(), \"res\", lambda -> {\n+                        lambda.ifBlock(\"res.getValue() != null\", ifAction -> {\n+                            ifAction.methodReturn(\"Mono.just(res.getValue())\");\n+                        }).elseBlock(elseAction -> {\n+                            elseAction.methodReturn(\"Mono.empty()\");\n+                        });\n+                    });\n+                    function.line(\");\");\n                 } else {\n-                    // ***WithRestResponse method.\n-                    //\n+                    function.text(\".flatMap(\");\n+                    function.lambda(returnValueTypeArgumentClientType.toString(), \"res\", \"Mono.empty()\");\n+                    function.line(\");\");\n+                }\n+            }));\n+        }));\n+    }\n+\n+    private void writePagingAsyncMethod(ClientMethod clientMethod, JavaType typeBlock, JavaSettings settings, ProxyMethod restAPIMethod) {\n+        if (clientMethod.getName().contains(\"Async\")) {\n+            final Optional<ClientMethodParameter> lastParamOpt = clientMethod.getMethodRequiredParameters()\n+                    .stream()\n+                    .reduce((current, next) -> next);\n+            final ClientMethodParameter lastParam = lastParamOpt.get();\n+            final GenericType callbackParameterType = (GenericType) lastParam.getWireType();\n+\n+            typeBlock.publicMethod(clientMethod.getDeclaration(),\n+                function -> {\n+                    final IType collectionType = callbackParameterType.getTypeArguments()[0];\n+                    final IType elementType = ((GenericType) collectionType).getTypeArguments()[0];\n+\n+                    String retrieverClassName = elementType.toString() + \"PageAsyncRetriever\";\n+                    StringBuilder retrieverConstructionBuilder = new StringBuilder();\n+                    retrieverConstructionBuilder.append(String.format(\"%1$s retriever = new %1$s(\", retrieverClassName));\n+                    boolean hasPreviousParam = false;\n+                    for (ClientMethodParameter clientMethodParameter : clientMethod.getMethodParameters()) {\n+                        if (clientMethodParameter.getName().contains(\"collectionCallback\")) {\n+                            continue;\n+                        }\n+                        if (hasPreviousParam) {\n+                            retrieverConstructionBuilder.append(\", \");\n+                        }\n+                        retrieverConstructionBuilder.append(clientMethodParameter.getName());\n+                        hasPreviousParam = true;\n+                    }\n+                    if (hasPreviousParam) {\n+                        retrieverConstructionBuilder.append(\", \");\n+                    }\n+                    retrieverConstructionBuilder.append(\"this);\");\n+                    function.line(retrieverConstructionBuilder.toString());\n+                    function.line(String.format(\"%1$s.onSuccess(new AsyncPagedDataCollection<%2$s, Page<%2$s>>(retriever), null);\", lastParam.getName(), elementType));\n+                });\n+            return;\n+        }\n+        writeAsyncWithRestResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, true);\n+    }\n+\n+    private void writePagingSyncMethod(ClientMethod clientMethod, JavaType typeBlock, JavaSettings settings, ProxyMethod restAPIMethod) {\n+        if (clientMethod.getName().contains(\"WithPageResponse\")\n+                        ||  clientMethod.getName().contains(\"WithPage\")) {\n+            typeBlock.publicMethod(clientMethod.getDeclaration(), function -> {\n+                IType elementType = ((GenericType) clientMethod.getReturnValue().getType()).getTypeArguments()[0];\n+\n+                String retrieverClassName = elementType.toString() +\n+                        (clientMethod.getName().contains(\"WithPageResponse\") ? \"PageResponseRetriever\" : \"PageRetriever\");\n+                StringBuilder retrieverConstructionBuilder = new StringBuilder();\n+                retrieverConstructionBuilder.append(String.format(\"%1$s retriever = new %1$s(\", retrieverClassName));\n+                boolean hasPreviousParam = false;\n+                for (ClientMethodParameter clientMethodParameter : clientMethod.getMethodParameters()) {\n+                    if (hasPreviousParam) {\n+                        retrieverConstructionBuilder.append(\", \");\n+                    }\n+                    retrieverConstructionBuilder.append(clientMethodParameter.getName());\n+                    hasPreviousParam = true;\n+                }\n+                if (hasPreviousParam) {\n+                    retrieverConstructionBuilder.append(\", \");\n+                }\n+                retrieverConstructionBuilder.append(\"this);\");\n+                function.line(retrieverConstructionBuilder.toString());\n+                String collectionName = clientMethod.getName().contains(\"WithPageResponse\")\n+                        ? \"PagedDataResponseCollection\"\n+                        : \"PagedDataCollection\";\n+                function.line(String.format(\"return new %1$s<%2$s, Page<%2$s>>(retriever);\", collectionName, elementType));\n+            });\n+            return;\n+        }\n+        writeSyncWithResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, true);\n+    }\n+\n+    private void writeSyncWithResponseMethod(ClientMethod clientMethod,\n+                                             JavaType typeBlock,\n+                                             JavaSettings settings,\n+                                             ProxyMethod restAPIMethod,\n+                                             boolean isPaging) {\n+        boolean generateSyncMethodWithOnlyRequiredParams = clientMethod.getOnlyRequiredParameters();\n+        if (generateSyncMethodWithOnlyRequiredParams) {\n+            typeBlock.publicMethod(clientMethod.getDeclaration(),\n+                    function -> {\n+                        // sync-method-with-only-required-params delegate call to\n+                        // sync-method-with-required-and-optional-param.\n+                        //\n+                        addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n+                        IType returnType = clientMethod.getReturnValue().getType();\n+                        if (returnType == PrimitiveType.Void) {\n+                            function.line(\"%sWithRestResponse(%s);\",\n+                                    clientMethod.getName(), clientMethod.getArgumentList());\n+                        } else {\n+                            function.line(\"return %sWithRestResponse(%s).getValue();\",\n+                                    clientMethod.getName(), clientMethod.getArgumentList());\n+                        }\n+                    });\n+        } else {\n+            // ***WithRestResponse method.\n+            //\n+            typeBlock.publicMethod(clientMethod.getDeclaration(), function -> {\n \n-                    typeBlock.publicMethod(clientMethod.getDeclaration(), function -> {\n+                final String clientReferenceDot\n+                        = clientMethod.getClientReference() != null\n+                        ? clientMethod.getClientReference() + \".\"\n+                        : \"\";\n+\n+                addValidations(function,\n+                        clientMethod.getRequiredNullableParameterExpressions(),\n+                        clientMethod.getValidateExpressions(),\n+                        false,\n+                        (exception, onError) -> {\n+                            onError.line(\"throw %s;\", exception);\n+                            return null;\n+                        },\n+                        settings);\n+                addOptionalAndConstantVariables(function,\n+                        clientMethod,\n+                        restAPIMethod.getParameters(),\n+                        settings);\n+                applyParameterTransformations(function,\n+                        clientMethod,\n+                        settings);\n+                convertClientTypesToWireTypes(function,\n+                        clientMethod,\n+                        restAPIMethod.getParameters(),\n+                        clientReferenceDot,\n+                        (exception, onError) -> {\n+                            onError.line(String.format(\"throw %s;\", exception));\n+                            return null;\n+                        },\n+                        settings);\n+                String retrofitAPIArgsList = String.join(\", \",\n+                        clientMethod.getProxyMethodArguments(settings));\n+                String retrofitAPICall = String.format(\"service.%s(%s)\",\n+                        restAPIMethod.getName(),\n+                        retrofitAPIArgsList);\n+\n+                function.line(String.format(\"final retrofit2.Response<ResponseBody> response = %sexecuteRetrofitCall(%s);\",\n+                        clientReferenceDot,\n+                        retrofitAPICall));\n+\n+                function.ifBlock(\"response.isSuccessful()\", responseSuccessBlock -> {\n+                    List<HttpResponseStatus> successStatusCodes = clientMethod.getProxyMethod().getResponseExpectedStatusCodes();\n+                    String successCodeExpression = successStatusCodes\n+                            .stream()\n+                            .map(statusCode -> String.format(\"response.code() == %d\", statusCode.code()))\n+                            .collect(Collectors.joining(\" || \"));\n+\n+                    responseSuccessBlock.ifBlock(successCodeExpression, succeededCodeBlock -> {\n+                        writeSyncSuccessWithRestResponseBlock(clientMethod, clientReferenceDot, succeededCodeBlock, isPaging);\n+                    }).elseBlock(errorCodeBlock -> {\n+                        errorCodeBlock.line(\"final String strContent = %sreadAsString(response.body());\", clientReferenceDot);\n+                        ClassType exceptionType = clientMethod.getProxyMethod().getUnexpectedResponseExceptionType();\n+                        String exceptionCreateExpression = String.format(\"new %s(strContent, response.raw())\", exceptionType.getName());\n+                        errorCodeBlock.line(String.format(\"throw %s;\", exceptionCreateExpression));\n+                    });\n+                }).elseBlock(responseFailedBlock -> {\n+                    responseFailedBlock.line(\"final String strContent = %sreadAsString(response.errorBody());\", clientReferenceDot);\n+                    responseFailedBlock.line(\"throw new HttpResponseException(strContent, response.raw());\");\n+                });\n+            });\n+        }\n+    }\n \n-                        final String clientReferenceDot\n-                                = clientMethod.getClientReference() != null\n-                                ? clientMethod.getClientReference() + \".\"\n-                                : \"\";\n+    private void writeSyncSuccessWithRestResponseBlock(ClientMethod clientMethod,\n+                                                       String clientReferenceDot,\n+                                                       JavaBlock succeededCodeBlock,\n+                                                       boolean isPaging) {\n+        IType bodyType = clientMethod.getProxyMethod().getReturnType(); // responseType.getTypeArguments()[0];\n+        if (bodyType == PrimitiveType.Void) {\n+            succeededCodeBlock.line(\"response.body().close();\");\n+            succeededCodeBlock.methodReturn(\"new Response<>(response.raw().request(),\\n\" +\n+                            \"                        response.code(),\\n\" +\n+                            \"                        response.headers(),\\n\" +\n+                            \"                        null)\");\n+        } else if (bodyType == ClassType.OkHttp3ResponseBody) {\n+            succeededCodeBlock.methodReturn(\"new Response<>(response.raw().request(),\\n\" +\n+                    \"                        response.code(),\\n\" +\n+                    \"                        response.headers(),\\n\" +\n+                    \"                        response.body())\");\n+        } else {\n+            final String bodyJvaType;\n+            if (bodyType instanceof ListType || bodyType instanceof MapType) {\n+                StringBuilder builder = new StringBuilder();\n+                builder.append(clientReferenceDot);\n+                parameterizedTypeExpression(bodyType, builder);\n+                bodyJvaType = builder.toString();\n+            } else {\n+                bodyJvaType = String.format(\"%s.class\", bodyType);\n+            }\n+\n+            if (isPaging){\n+                GenericType responseType = (GenericType) clientMethod.getReturnValue().getType();\n+                GenericType pageType = (GenericType) responseType.getTypeArguments()[0];\n+                IType elementType = pageType.getTypeArguments()[0];\n+                List<String> exceptions = new ArrayList<>();\n+                exceptions.add(\"Exception\");\n+                succeededCodeBlock.line(\"final %s decodedResult;\", bodyType);\n+                succeededCodeBlock.tryCatch(tryBlock -> {\n+                            succeededCodeBlock.line(\"decodedResult = %sdeserializeContent(response.headers(), response.body(), %s);\",\n+                                    clientReferenceDot,\n+                                    bodyJvaType);\n+                        },\n+                        exceptions,\n+                        \"ex\",\n+                        catchBlock -> {\n+                            catchBlock.line(\"final String strContent = %sreadAsString(response.body());\", clientReferenceDot);\n+                            ClassType exceptionType = clientMethod.getProxyMethod().getUnexpectedResponseExceptionType();\n+                            String exceptionCreateExpression = String.format(\"new %s(strContent, response.raw())\", exceptionType.getName());\n+                            catchBlock.line(String.format(\"throw %s;\", exceptionCreateExpression));\n+                        },\n+                        null);\n+                String pageId = clientMethod.getName().contains(\"Next\") ? \"nextLink\" : \"response.raw().request().url().toString()\";", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcxMTk3OA==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497711978", "bodyText": "Find out why this change is necessary or just diff problem", "author": "JianpingChen", "createdAt": "2020-09-30T18:21:04Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/AndroidClientMethodTemplate.java", "diffHunk": "@@ -406,198 +393,353 @@ public void write(ClientMethod clientMethod, JavaType typeBlock) {\n         ProxyMethod restAPIMethod = clientMethod.getProxyMethod();\n         generateJavadoc(clientMethod, typeBlock, restAPIMethod);\n \n-\n         clientMethod.getProxyMethod().getRequestContentType();\n-        List<ClientMethodParameter> parameters = clientMethod.getMethodParameters();\n-\n-\n-\n         switch (clientMethod.getType()) {\n             case SimpleAsyncRestResponse:\n                 // async method\n-                boolean generateAsyncMethodWithOnlyRequiredParams = clientMethod.getOnlyRequiredParameters();\n-                if (generateAsyncMethodWithOnlyRequiredParams) {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-                                // async-method-with-only-required-params delegate call to\n-                                // async-method-with-required-and-optional-param.\n-                                //\n-                                addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n-                                function.line(\"%s(%s);\",\n-                                        clientMethod.getName(), clientMethod.getArgumentList());\n-                            });\n-                } else {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-\n-                                final Optional<ClientMethodParameter> lastParamOpt = clientMethod.getMethodRequiredParameters()\n-                                        .stream()\n-                                        .reduce((current, next) -> next);\n-                                final ClientMethodParameter lastParam = lastParamOpt.get();\n-                                final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n-                                final String callbackParameterName = lastParam.getName();\n-\n-                                final String clientReferenceDot;\n-                                if (clientMethod.getClientReference().equals(\"this\")) {\n-                                    // 'this' is not resolvable from callback remove it.\n-                                    clientReferenceDot = \"\";\n-                                } else {\n-                                    clientReferenceDot = clientMethod.getClientReference().replace(\"this.\", \"\") + \".\";\n-                                }\n-\n-                                addValidations(function,\n-                                        clientMethod.getRequiredNullableParameterExpressions(),\n-                                        clientMethod.getValidateExpressions(),\n-                                        true,\n-                                        (exception, onError) -> {\n-                                            onError.line(\"%s.onFailure(%s, null);\", callbackParameterName, exception);\n-                                            onError.line(\"return;\");\n-                                            return null;\n-                                        },\n-                                        settings);\n-                                addOptionalAndConstantVariables(function,\n-                                        clientMethod,\n-                                        restAPIMethod.getParameters(),\n-                                        settings);\n-                                applyParameterTransformations(function,\n-                                        clientMethod,\n-                                        settings);\n-                                convertClientTypesToWireTypes(function,\n-                                        clientMethod,\n-                                        restAPIMethod.getParameters(),\n-                                        clientReferenceDot,\n-                                        (exception, onError) -> {\n-                                            onError.line(String.format(\"%s.onFailure(%s, null);\", callbackParameterName, exception));\n-                                            onError.line(\"return;\");\n-                                            return null;\n-                                        },\n-                                        settings);\n-                                String retrofitAPIArgsList = String.join(\", \",\n-                                        clientMethod.getProxyMethodArguments(settings));\n-                                String retrofitAPICall = String.format(\"service.%s(%s)\",\n-                                        restAPIMethod.getName(),\n-                                        retrofitAPIArgsList);\n-\n-                                function.line(\"Call<ResponseBody> call = %s;\", retrofitAPICall);\n-                                function.anonymousClass(\"retrofit2.Callback<ResponseBody>\",\n-                                        \"retrofitCallback\",\n-                                        anonymousCls -> {\n-                                    anonymousCls.annotation(\"Override\");\n-                                    anonymousCls.publicMethod(\"void onResponse(Call<okhttp3.ResponseBody> call, retrofit2.Response<ResponseBody> response)\",\n-                                            onResponseBlock -> onResponseBlock.ifBlock(\"response.isSuccessful()\", responseSuccessBlock -> {\n-                                                List<HttpResponseStatus> successStatusCodes = clientMethod.getProxyMethod().getResponseExpectedStatusCodes();\n-                                                String successCodeExpression = successStatusCodes\n-                                                        .stream()\n-                                                        .map(statusCode -> String.format(\"response.code() == %d\", statusCode.code()))\n-                                                        .collect(Collectors.joining(\" || \"));\n-\n-\n-                                                responseSuccessBlock.ifBlock(successCodeExpression, succeededCodeBlock -> {\n-                                                    IType bodyType = callbackParameter.getTypeArguments()[0];\n-                                                    if (bodyType == PrimitiveType.Void) {\n-                                                        succeededCodeBlock.line(\"response.body().close();\");\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(null, response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    } else if (bodyType == ClassType.OkHttp3ResponseBody) {\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(response.body(), response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    } else {\n-                                                        final String bodyJvaType;\n-                                                        if (bodyType instanceof ListType || bodyType instanceof MapType) {\n-                                                            StringBuilder builder = new StringBuilder();\n-                                                            builder.append(clientReferenceDot);\n-                                                            parameterizedTypeExpression(bodyType, builder);\n-                                                            bodyJvaType = builder.toString();\n-                                                        } else {\n-                                                            bodyJvaType = String.format(\"%s.class\", bodyType);\n-                                                        }\n-\n-                                                        List<String> exceptions = new ArrayList<>();\n-                                                        exceptions.add(\"Exception\");\n-                                                        succeededCodeBlock.line(\"final %s decodedResult;\", bodyType);\n-                                                        succeededCodeBlock.tryCatch(tryBlock -> {\n-                                                                    succeededCodeBlock.line(\"decodedResult = %sdeserializeContent(response.headers(), response.body(), %s);\",\n-                                                                            clientReferenceDot,\n-                                                                            bodyJvaType);\n-                                                                },\n-                                                                exceptions,\n-                                                                \"ex\",\n-                                                                catchBlock -> {\n-                                                                    catchBlock\n-                                                                            .line(String.format(\"%s.onFailure(ex, response.raw());\",\n-                                                                                    callbackParameterName));\n-                                                                    catchBlock.line(\"return;\");\n-                                                                },\n-                                                                null);\n-\n-                                                        succeededCodeBlock\n-                                                                .line(String.format(\"%s.onSuccess(decodedResult, response.raw());\",\n-                                                                        callbackParameterName));\n-                                                    }\n-                                                }).elseBlock(errorCodeBlock -> {\n-                                                    errorCodeBlock.line(\"final String strContent = %sreadAsString(response.body());\", clientReferenceDot);\n-                                                    ClassType exceptionType = clientMethod.getProxyMethod().getUnexpectedResponseExceptionType();\n-                                                    String exceptionCreateExpression = String.format(\"new %s(strContent, response.raw())\", exceptionType.getName());\n-                                                    errorCodeBlock\n-                                                            .line(String.format(\"%s.onFailure(%s, response.raw());\",\n-                                                                    callbackParameterName,\n-                                                                    exceptionCreateExpression));\n-                                                });\n-                                            }).elseBlock(responseFailureBlock -> {\n-                                                responseFailureBlock.line(\"final String strContent = %sreadAsString(response.errorBody());\", clientReferenceDot);\n-                                                responseFailureBlock.line(String.format(\"%s.onFailure(new HttpResponseException(strContent, response.raw()), response.raw());\",\n-                                                        callbackParameterName));\n-                                            }));\n-\n-                                    anonymousCls.annotation(\"Override\");\n-                                    anonymousCls.publicMethod(\"void onFailure(Call<ResponseBody> call, Throwable t)\",\n-                                            onFailureBlock -> {\n-                                                onFailureBlock.line(String.format(\"%s.onFailure(t, null);\", callbackParameterName));\n-                                            });\n-                                });\n-                                function.line(\"call.enqueue(retrofitCallback);\");\n-                            });\n-                }\n+                writeAsyncWithRestResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, false);\n                 break;\n \n             case SimpleSync:\n                 // sync method\n-                boolean generateSyncMethodWithOnlyRequiredParams = clientMethod.getOnlyRequiredParameters();\n-                if (generateSyncMethodWithOnlyRequiredParams) {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(),\n-                            function -> {\n-                                // sync-method-with-only-required-params delegate call to\n-                                // sync-method-with-required-and-optional-param.\n-                                //\n-                                addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n-                                IType returnType = clientMethod.getReturnValue().getType();\n-                                if (returnType == PrimitiveType.Void) {\n-                                    function.line(\"%sWithRestResponse(%s);\",\n-                                            clientMethod.getName(), clientMethod.getArgumentList());\n-                                } else {\n-                                    function.line(\"return %sWithRestResponse(%s).getValue();\",\n-                                            clientMethod.getName(), clientMethod.getArgumentList());\n-                                }\n-                            });\n+                writeSyncWithResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, false);\n+                break;\n+\n+            case PagingSync:\n+                writePagingSyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+\n+            case PagingAsync:\n+                writePagingAsyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+            case PagingAsyncSinglePage:\n+                generatePagedAsyncSinglePage(clientMethod, typeBlock, restAPIMethod, settings);\n+                break;\n+\n+            case LongRunningSync:\n+                // LongRunningAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningAsync:\n+                // LongRunningAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningBeginAsync:\n+                // LongRunningBeginAsync not applicable to data-plane android\n+                break;\n+\n+            case LongRunningBeginSync:\n+                // LongRunningBeginSync not applicable to data-plane android\n+                break;\n+\n+            case Resumable:\n+                // Resumable not applicable to data-plane android\n+                break;\n+\n+            case SimpleAsync:\n+                writeSimpleAsyncMethod(clientMethod, typeBlock, settings, restAPIMethod);\n+                break;\n+        }\n+    }\n+\n+    private void writeSimpleAsyncMethod(ClientMethod clientMethod, JavaType typeBlock, JavaSettings settings, ProxyMethod restAPIMethod) {\n+        typeBlock.publicMethod(clientMethod.getDeclaration(), (function -> {\n+            addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n+            function.line(\"return %s(%s)\", clientMethod.getProxyMethod().getSimpleAsyncRestResponseMethodName(), clientMethod.getArgumentList());\n+            function.indent((() -> {\n+                GenericType restAPIMethodClientReturnType = (GenericType) restAPIMethod.getReturnType().getClientType();\n+                IType returnValueTypeArgumentClientType = restAPIMethodClientReturnType.getTypeArguments()[0];\n+                if (GenericType.Flux(ClassType.ByteBuffer).equals(clientMethod.getReturnValue().getType())) {\n+                    function.text(\".flatMapMany(StreamResponse::getValue);\");\n+                } else if (!GenericType.Mono(ClassType.Void).equals(clientMethod.getReturnValue().getType()) &&\n+                        !GenericType.Flux(ClassType.Void).equals(clientMethod.getReturnValue().getType())) {\n+                    function.text(\".flatMap(\");\n+                    function.lambda(returnValueTypeArgumentClientType.toString(), \"res\", lambda -> {\n+                        lambda.ifBlock(\"res.getValue() != null\", ifAction -> {\n+                            ifAction.methodReturn(\"Mono.just(res.getValue())\");\n+                        }).elseBlock(elseAction -> {\n+                            elseAction.methodReturn(\"Mono.empty()\");\n+                        });\n+                    });\n+                    function.line(\");\");\n                 } else {\n-                    // ***WithRestResponse method.\n-                    //\n+                    function.text(\".flatMap(\");\n+                    function.lambda(returnValueTypeArgumentClientType.toString(), \"res\", \"Mono.empty()\");\n+                    function.line(\");\");\n+                }\n+            }));\n+        }));\n+    }\n+\n+    private void writePagingAsyncMethod(ClientMethod clientMethod, JavaType typeBlock, JavaSettings settings, ProxyMethod restAPIMethod) {\n+        if (clientMethod.getName().contains(\"Async\")) {\n+            final Optional<ClientMethodParameter> lastParamOpt = clientMethod.getMethodRequiredParameters()\n+                    .stream()\n+                    .reduce((current, next) -> next);\n+            final ClientMethodParameter lastParam = lastParamOpt.get();\n+            final GenericType callbackParameterType = (GenericType) lastParam.getWireType();\n+\n+            typeBlock.publicMethod(clientMethod.getDeclaration(),\n+                function -> {\n+                    final IType collectionType = callbackParameterType.getTypeArguments()[0];\n+                    final IType elementType = ((GenericType) collectionType).getTypeArguments()[0];\n+\n+                    String retrieverClassName = elementType.toString() + \"PageAsyncRetriever\";\n+                    StringBuilder retrieverConstructionBuilder = new StringBuilder();\n+                    retrieverConstructionBuilder.append(String.format(\"%1$s retriever = new %1$s(\", retrieverClassName));\n+                    boolean hasPreviousParam = false;\n+                    for (ClientMethodParameter clientMethodParameter : clientMethod.getMethodParameters()) {\n+                        if (clientMethodParameter.getName().contains(\"collectionCallback\")) {\n+                            continue;\n+                        }\n+                        if (hasPreviousParam) {\n+                            retrieverConstructionBuilder.append(\", \");\n+                        }\n+                        retrieverConstructionBuilder.append(clientMethodParameter.getName());\n+                        hasPreviousParam = true;\n+                    }\n+                    if (hasPreviousParam) {\n+                        retrieverConstructionBuilder.append(\", \");\n+                    }\n+                    retrieverConstructionBuilder.append(\"this);\");\n+                    function.line(retrieverConstructionBuilder.toString());\n+                    function.line(String.format(\"%1$s.onSuccess(new AsyncPagedDataCollection<%2$s, Page<%2$s>>(retriever), null);\", lastParam.getName(), elementType));\n+                });\n+            return;\n+        }\n+        writeAsyncWithRestResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, true);\n+    }\n+\n+    private void writePagingSyncMethod(ClientMethod clientMethod, JavaType typeBlock, JavaSettings settings, ProxyMethod restAPIMethod) {\n+        if (clientMethod.getName().contains(\"WithPageResponse\")\n+                        ||  clientMethod.getName().contains(\"WithPage\")) {\n+            typeBlock.publicMethod(clientMethod.getDeclaration(), function -> {\n+                IType elementType = ((GenericType) clientMethod.getReturnValue().getType()).getTypeArguments()[0];\n+\n+                String retrieverClassName = elementType.toString() +\n+                        (clientMethod.getName().contains(\"WithPageResponse\") ? \"PageResponseRetriever\" : \"PageRetriever\");\n+                StringBuilder retrieverConstructionBuilder = new StringBuilder();\n+                retrieverConstructionBuilder.append(String.format(\"%1$s retriever = new %1$s(\", retrieverClassName));\n+                boolean hasPreviousParam = false;\n+                for (ClientMethodParameter clientMethodParameter : clientMethod.getMethodParameters()) {\n+                    if (hasPreviousParam) {\n+                        retrieverConstructionBuilder.append(\", \");\n+                    }\n+                    retrieverConstructionBuilder.append(clientMethodParameter.getName());\n+                    hasPreviousParam = true;\n+                }\n+                if (hasPreviousParam) {\n+                    retrieverConstructionBuilder.append(\", \");\n+                }\n+                retrieverConstructionBuilder.append(\"this);\");\n+                function.line(retrieverConstructionBuilder.toString());\n+                String collectionName = clientMethod.getName().contains(\"WithPageResponse\")\n+                        ? \"PagedDataResponseCollection\"\n+                        : \"PagedDataCollection\";\n+                function.line(String.format(\"return new %1$s<%2$s, Page<%2$s>>(retriever);\", collectionName, elementType));\n+            });\n+            return;\n+        }\n+        writeSyncWithResponseMethod(clientMethod, typeBlock, settings, restAPIMethod, true);\n+    }\n+\n+    private void writeSyncWithResponseMethod(ClientMethod clientMethod,\n+                                             JavaType typeBlock,\n+                                             JavaSettings settings,\n+                                             ProxyMethod restAPIMethod,\n+                                             boolean isPaging) {\n+        boolean generateSyncMethodWithOnlyRequiredParams = clientMethod.getOnlyRequiredParameters();\n+        if (generateSyncMethodWithOnlyRequiredParams) {\n+            typeBlock.publicMethod(clientMethod.getDeclaration(),\n+                    function -> {\n+                        // sync-method-with-only-required-params delegate call to\n+                        // sync-method-with-required-and-optional-param.\n+                        //\n+                        addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n+                        IType returnType = clientMethod.getReturnValue().getType();\n+                        if (returnType == PrimitiveType.Void) {\n+                            function.line(\"%sWithRestResponse(%s);\",\n+                                    clientMethod.getName(), clientMethod.getArgumentList());\n+                        } else {\n+                            function.line(\"return %sWithRestResponse(%s).getValue();\",\n+                                    clientMethod.getName(), clientMethod.getArgumentList());\n+                        }\n+                    });\n+        } else {\n+            // ***WithRestResponse method.\n+            //\n+            typeBlock.publicMethod(clientMethod.getDeclaration(), function -> {\n \n-                    typeBlock.publicMethod(clientMethod.getDeclaration(), function -> {\n+                final String clientReferenceDot\n+                        = clientMethod.getClientReference() != null\n+                        ? clientMethod.getClientReference() + \".\"\n+                        : \"\";\n+\n+                addValidations(function,\n+                        clientMethod.getRequiredNullableParameterExpressions(),\n+                        clientMethod.getValidateExpressions(),\n+                        false,\n+                        (exception, onError) -> {\n+                            onError.line(\"throw %s;\", exception);\n+                            return null;\n+                        },\n+                        settings);\n+                addOptionalAndConstantVariables(function,\n+                        clientMethod,\n+                        restAPIMethod.getParameters(),\n+                        settings);\n+                applyParameterTransformations(function,\n+                        clientMethod,\n+                        settings);\n+                convertClientTypesToWireTypes(function,\n+                        clientMethod,\n+                        restAPIMethod.getParameters(),\n+                        clientReferenceDot,\n+                        (exception, onError) -> {\n+                            onError.line(String.format(\"throw %s;\", exception));\n+                            return null;\n+                        },\n+                        settings);\n+                String retrofitAPIArgsList = String.join(\", \",\n+                        clientMethod.getProxyMethodArguments(settings));\n+                String retrofitAPICall = String.format(\"service.%s(%s)\",\n+                        restAPIMethod.getName(),\n+                        retrofitAPIArgsList);\n+\n+                function.line(String.format(\"final retrofit2.Response<ResponseBody> response = %sexecuteRetrofitCall(%s);\",\n+                        clientReferenceDot,\n+                        retrofitAPICall));\n+\n+                function.ifBlock(\"response.isSuccessful()\", responseSuccessBlock -> {\n+                    List<HttpResponseStatus> successStatusCodes = clientMethod.getProxyMethod().getResponseExpectedStatusCodes();\n+                    String successCodeExpression = successStatusCodes\n+                            .stream()\n+                            .map(statusCode -> String.format(\"response.code() == %d\", statusCode.code()))\n+                            .collect(Collectors.joining(\" || \"));\n+\n+                    responseSuccessBlock.ifBlock(successCodeExpression, succeededCodeBlock -> {\n+                        writeSyncSuccessWithRestResponseBlock(clientMethod, clientReferenceDot, succeededCodeBlock, isPaging);\n+                    }).elseBlock(errorCodeBlock -> {\n+                        errorCodeBlock.line(\"final String strContent = %sreadAsString(response.body());\", clientReferenceDot);\n+                        ClassType exceptionType = clientMethod.getProxyMethod().getUnexpectedResponseExceptionType();\n+                        String exceptionCreateExpression = String.format(\"new %s(strContent, response.raw())\", exceptionType.getName());\n+                        errorCodeBlock.line(String.format(\"throw %s;\", exceptionCreateExpression));\n+                    });\n+                }).elseBlock(responseFailedBlock -> {\n+                    responseFailedBlock.line(\"final String strContent = %sreadAsString(response.errorBody());\", clientReferenceDot);\n+                    responseFailedBlock.line(\"throw new HttpResponseException(strContent, response.raw());\");\n+                });\n+            });\n+        }\n+    }\n \n-                        final String clientReferenceDot\n-                                = clientMethod.getClientReference() != null\n-                                ? clientMethod.getClientReference() + \".\"\n-                                : \"\";\n+    private void writeSyncSuccessWithRestResponseBlock(ClientMethod clientMethod,\n+                                                       String clientReferenceDot,\n+                                                       JavaBlock succeededCodeBlock,\n+                                                       boolean isPaging) {\n+        IType bodyType = clientMethod.getProxyMethod().getReturnType(); // responseType.getTypeArguments()[0];\n+        if (bodyType == PrimitiveType.Void) {\n+            succeededCodeBlock.line(\"response.body().close();\");\n+            succeededCodeBlock.methodReturn(\"new Response<>(response.raw().request(),\\n\" +\n+                            \"                        response.code(),\\n\" +\n+                            \"                        response.headers(),\\n\" +\n+                            \"                        null)\");\n+        } else if (bodyType == ClassType.OkHttp3ResponseBody) {\n+            succeededCodeBlock.methodReturn(\"new Response<>(response.raw().request(),\\n\" +\n+                    \"                        response.code(),\\n\" +\n+                    \"                        response.headers(),\\n\" +\n+                    \"                        response.body())\");\n+        } else {\n+            final String bodyJvaType;\n+            if (bodyType instanceof ListType || bodyType instanceof MapType) {\n+                StringBuilder builder = new StringBuilder();\n+                builder.append(clientReferenceDot);\n+                parameterizedTypeExpression(bodyType, builder);\n+                bodyJvaType = builder.toString();\n+            } else {\n+                bodyJvaType = String.format(\"%s.class\", bodyType);\n+            }\n+\n+            if (isPaging){\n+                GenericType responseType = (GenericType) clientMethod.getReturnValue().getType();\n+                GenericType pageType = (GenericType) responseType.getTypeArguments()[0];\n+                IType elementType = pageType.getTypeArguments()[0];\n+                List<String> exceptions = new ArrayList<>();\n+                exceptions.add(\"Exception\");\n+                succeededCodeBlock.line(\"final %s decodedResult;\", bodyType);\n+                succeededCodeBlock.tryCatch(tryBlock -> {\n+                            succeededCodeBlock.line(\"decodedResult = %sdeserializeContent(response.headers(), response.body(), %s);\",\n+                                    clientReferenceDot,\n+                                    bodyJvaType);\n+                        },\n+                        exceptions,\n+                        \"ex\",\n+                        catchBlock -> {\n+                            catchBlock.line(\"final String strContent = %sreadAsString(response.body());\", clientReferenceDot);\n+                            ClassType exceptionType = clientMethod.getProxyMethod().getUnexpectedResponseExceptionType();\n+                            String exceptionCreateExpression = String.format(\"new %s(strContent, response.raw())\", exceptionType.getName());\n+                            catchBlock.line(String.format(\"throw %s;\", exceptionCreateExpression));\n+                        },\n+                        null);\n+                String pageId = clientMethod.getName().contains(\"Next\") ? \"nextLink\" : \"response.raw().request().url().toString()\";\n+                succeededCodeBlock.methodReturn(String.format(\"new Response<>(response.raw().request(),\\n\" +\n+                                \"                        response.code(),\\n\" +\n+                                \"                        response.headers(),\\n\" +\n+                                \"                        new Page<%1$s>(%2$s, decodedResult.getValue(), decodedResult.getNextLink()))\",\n+                        elementType, pageId));\n+            }\n+            else {\n+                succeededCodeBlock.methodReturn(String.format(\"new Response<>(response.raw().request(),\\n\" +\n+                                \"                        response.code(),\\n\" +\n+                                \"                        response.headers(),\\n\" +\n+                                \"                        %sdeserializeContent(response.headers(), response.body(), %s))\",\n+                        clientReferenceDot,\n+                        bodyJvaType));\n+            }\n+        }\n+    }\n+\n+    private void writeAsyncWithRestResponseMethod(ClientMethod clientMethod,\n+                                                  JavaType typeBlock,\n+                                                  JavaSettings settings,\n+                                                  ProxyMethod restAPIMethod,\n+                                                  boolean isPaging) {\n+        boolean generateAsyncMethodWithOnlyRequiredParams = clientMethod.getOnlyRequiredParameters();\n+        if (generateAsyncMethodWithOnlyRequiredParams) {\n+            typeBlock.publicMethod(clientMethod.getDeclaration(),\n+                    function -> {\n+                        // async-method-with-only-required-params delegate call to\n+                        // async-method-with-required-and-optional-param.\n+                        //\n+                        addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n+                        function.line(\"%s(%s);\",\n+                                clientMethod.getName(), clientMethod.getArgumentList());\n+                    });\n+        } else {\n+            typeBlock.publicMethod(clientMethod.getDeclaration(),\n+                    function -> {\n+                        final Optional<ClientMethodParameter> lastParamOpt = clientMethod.getMethodRequiredParameters()\n+                                .stream()\n+                                .reduce((current, next) -> next);\n+                        final ClientMethodParameter lastParam = lastParamOpt.get();\n+                        final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n+                        final String callbackParameterName = lastParam.getName();\n+\n+                        final String clientReferenceDot;\n+                        if (clientMethod.getClientReference().equals(\"this\")) {\n+                            // 'this' is not resolvable from callback remove it.\n+                            clientReferenceDot = \"\";\n+                        } else {\n+                            clientReferenceDot = clientMethod.getClientReference().replace(\"this.\", \"\") + \".\";\n+                        }\n \n                         addValidations(function,\n                                 clientMethod.getRequiredNullableParameterExpressions(),\n                                 clientMethod.getValidateExpressions(),\n-                                false,\n+                                true,", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcxNTYwMw==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497715603", "bodyText": "Only the page id differs in these two block. Consolidate. Also try to avoid hard coded \"nextLink\"", "author": "JianpingChen", "createdAt": "2020-09-30T18:27:31Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/AndroidClientMethodTemplate.java", "diffHunk": "@@ -623,149 +766,118 @@ public void write(ClientMethod clientMethod, JavaType typeBlock) {\n                                 restAPIMethod.getName(),\n                                 retrofitAPIArgsList);\n \n-                        function.line(String.format(\"final retrofit2.Response<ResponseBody> response = %sexecuteRetrofitCall(%s);\",\n-                                clientReferenceDot,\n-                                retrofitAPICall));\n-\n-                        function.ifBlock(\"response.isSuccessful()\", responseSuccessBlock -> {\n-                            List<HttpResponseStatus> successStatusCodes = clientMethod.getProxyMethod().getResponseExpectedStatusCodes();\n-                            String successCodeExpression = successStatusCodes\n-                                    .stream()\n-                                    .map(statusCode -> String.format(\"response.code() == %d\", statusCode.code()))\n-                                    .collect(Collectors.joining(\" || \"));\n-\n-                            responseSuccessBlock.ifBlock(successCodeExpression, succeededCodeBlock -> {\n-                                        IType methodReturnType = clientMethod.getReturnValue().getType();\n-                                GenericType responseType = (GenericType) methodReturnType;\n-                                IType bodyType = responseType.getTypeArguments()[0];\n-                                if (bodyType == PrimitiveType.Void) {\n-                                    succeededCodeBlock.line(\"response.body().close();\");\n-                                    succeededCodeBlock.methodReturn(\"new Response<>(response.raw().request(),\\n\" +\n-                                                    \"                        response.code(),\\n\" +\n-                                                    \"                        response.headers(),\\n\" +\n-                                                    \"                        null)\");\n-                                } else if (bodyType == ClassType.OkHttp3ResponseBody) {\n-                                    succeededCodeBlock.methodReturn(\"new Response<>(response.raw().request(),\\n\" +\n-                                            \"                        response.code(),\\n\" +\n-                                            \"                        response.headers(),\\n\" +\n-                                            \"                        response.body())\");\n-                                } else {\n-                                    final String bodyJvaType;\n-                                    if (bodyType instanceof ListType || bodyType instanceof MapType) {\n-                                        StringBuilder builder = new StringBuilder();\n-                                        builder.append(clientReferenceDot);\n-                                        parameterizedTypeExpression(bodyType, builder);\n-                                        bodyJvaType = builder.toString();\n-                                    } else {\n-                                        bodyJvaType = String.format(\"%s.class\", bodyType);\n-                                    }\n-\n-                                    succeededCodeBlock.methodReturn(String.format(\"new Response<>(response.raw().request(),\\n\" +\n-                                                    \"                        response.code(),\\n\" +\n-                                                    \"                        response.headers(),\\n\" +\n-                                                    \"                        %sdeserializeContent(response.headers(), response.body(), %s))\",\n-                                            clientReferenceDot,\n-                                            bodyJvaType));\n-                                }\n-                            }).elseBlock(errorCodeBlock -> {\n-                                errorCodeBlock.line(\"final String strContent = %sreadAsString(response.body());\", clientReferenceDot);\n-                                ClassType exceptionType = clientMethod.getProxyMethod().getUnexpectedResponseExceptionType();\n-                                String exceptionCreateExpression = String.format(\"new %s(strContent, response.raw())\", exceptionType.getName());\n-                                errorCodeBlock.line(String.format(\"throw %s;\", exceptionCreateExpression));\n-                            });\n-                        }).elseBlock(responseFailedBlock -> {\n-                            responseFailedBlock.line(\"final String strContent = %sreadAsString(response.errorBody());\", clientReferenceDot);\n-                            responseFailedBlock.line(\"throw new HttpResponseException(strContent, response.raw());\");\n+                        function.line(\"Call<ResponseBody> call = %s;\", retrofitAPICall);\n+                        function.anonymousClass(\"retrofit2.Callback<ResponseBody>\",\n+                                \"retrofitCallback\",\n+                                anonymousCls -> {\n+                            anonymousCls.annotation(\"Override\");\n+                            anonymousCls.publicMethod(\"void onResponse(Call<okhttp3.ResponseBody> call, retrofit2.Response<ResponseBody> response)\",\n+                                    onResponseBlock -> onResponseBlock.ifBlock(\"response.isSuccessful()\", responseSuccessBlock -> {\n+                                        List<HttpResponseStatus> successStatusCodes = clientMethod.getProxyMethod().getResponseExpectedStatusCodes();\n+                                        String successCodeExpression = successStatusCodes\n+                                                .stream()\n+                                                .map(statusCode -> String.format(\"response.code() == %d\", statusCode.code()))\n+                                                .collect(Collectors.joining(\" || \"));\n+\n+\n+                                        responseSuccessBlock.ifBlock(successCodeExpression, succeededCodeBlock -> {\n+                                            writeAsyncSuccessBlock(clientMethod, callbackParameterName, clientReferenceDot, succeededCodeBlock, (JavaClass) typeBlock, isPaging);\n+                                        }).elseBlock(errorCodeBlock -> {\n+                                            errorCodeBlock.line(\"final String strContent = %sreadAsString(response.body());\", clientReferenceDot);\n+                                            ClassType exceptionType = clientMethod.getProxyMethod().getUnexpectedResponseExceptionType();\n+                                            String exceptionCreateExpression = String.format(\"new %s(strContent, response.raw())\", exceptionType.getName());\n+                                            errorCodeBlock\n+                                                    .line(String.format(\"%s.onFailure(%s, response.raw());\",\n+                                                            callbackParameterName,\n+                                                            exceptionCreateExpression));\n+                                        });\n+                                    }).elseBlock(responseFailureBlock -> {\n+                                        responseFailureBlock.line(\"final String strContent = %sreadAsString(response.errorBody());\", clientReferenceDot);\n+                                        responseFailureBlock.line(String.format(\"%s.onFailure(new HttpResponseException(strContent, response.raw()), response.raw());\",\n+                                                callbackParameterName));\n+                                    }));\n+\n+                            anonymousCls.annotation(\"Override\");\n+                            anonymousCls.publicMethod(\"void onFailure(Call<ResponseBody> call, Throwable t)\",\n+                                    onFailureBlock -> {\n+                                        onFailureBlock.line(String.format(\"%s.onFailure(t, null);\", callbackParameterName));\n+                                    });\n                         });\n+                        function.line(\"call.enqueue(retrofitCallback);\");\n                     });\n-                }\n-                break;\n+        }\n+    }\n \n-            case PagingSync:\n-                typeBlock.publicMethod(clientMethod.getDeclaration(), function -> {\n-                    addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n-                    function.methodReturn(String.format(\"new PagedIterable<>(%s(%s))\", clientMethod.getSimpleAsyncMethodName(), clientMethod.getArgumentList()));\n-                });\n-                break;\n+    private void writeAsyncSuccessBlock(ClientMethod clientMethod,\n+                                        String callbackParameterName,\n+                                        String clientReferenceDot,\n+                                        JavaBlock succeededCodeBlock,\n+                                        JavaClass classBlock,\n+                                        boolean isPaging) {\n+        IType bodyType = clientMethod.getProxyMethod().getReturnType(); // callbackParameter.getTypeArguments()[0];\n+        if (bodyType == PrimitiveType.Void) {\n+            succeededCodeBlock.line(\"response.body().close();\");\n+            succeededCodeBlock\n+                    .line(String.format(\"%s.onSuccess(null, response.raw());\",\n+                            callbackParameterName));\n+        } else if (bodyType == ClassType.OkHttp3ResponseBody) {\n+            succeededCodeBlock\n+                    .line(String.format(\"%s.onSuccess(response.body(), response.raw());\",\n+                            callbackParameterName));\n+        } else {\n+            final String bodyJvaType;\n+            if (bodyType instanceof ListType || bodyType instanceof MapType) {\n+                StringBuilder builder = new StringBuilder();\n+                builder.append(clientReferenceDot);\n+                parameterizedTypeExpression(bodyType, builder);\n+                bodyJvaType = builder.toString();\n+            } else {\n+                bodyJvaType = String.format(\"%s.class\", bodyType);\n+            }\n \n-            case PagingAsync:\n-                if (clientMethod.getMethodPageDetails().nonNullNextLink()) {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(), function -> {\n-                        addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n-                        function.line(\"return new PagedFlux<>(\");\n-                        function.indent(() -> {\n-                            function.line(\"() -> %s(%s),\",\n-                                    clientMethod.getProxyMethod().getPagingAsyncSinglePageMethodName(),\n-                                    clientMethod.getArgumentList());\n-                            function.line(\"nextLink -> %s(%s));\",\n-                                    clientMethod.getMethodPageDetails().getNextMethod().getProxyMethod().getPagingAsyncSinglePageMethodName(),\n-                                    clientMethod.getMethodPageDetails().getNextMethod().getArgumentList());\n-                        });\n-                    });\n-                } else {\n-                    typeBlock.publicMethod(clientMethod.getDeclaration(), function -> {\n-                        addOptionalVariables(function, clientMethod, restAPIMethod.getParameters(), settings);\n-                        function.line(\"return new PagedFlux<>(\");\n-                        function.indent(() -> {\n-                            function.line(\"() -> %s(%s));\",\n-                                    clientMethod.getProxyMethod().getPagingAsyncSinglePageMethodName(),\n-                                    clientMethod.getArgumentList());\n-                        });\n-                    });\n+            List<String> exceptions = new ArrayList<>();\n+            exceptions.add(\"Exception\");\n+            succeededCodeBlock.line(\"final %s decodedResult;\", bodyType);\n+            succeededCodeBlock.tryCatch(tryBlock -> {\n+                        succeededCodeBlock.line(\"decodedResult = %sdeserializeContent(response.headers(), response.body(), %s);\",\n+                                clientReferenceDot,\n+                                bodyJvaType);\n+                    },\n+                    exceptions,\n+                    \"ex\",\n+                    catchBlock -> {\n+                        catchBlock\n+                                .line(String.format(\"%s.onFailure(ex, response.raw());\",\n+                                        callbackParameterName));\n+                        catchBlock.line(\"return;\");\n+                    },\n+                    null);\n+\n+            if (isPaging) {\n+                final Optional<ClientMethodParameter> lastParamOpt = clientMethod.getMethodRequiredParameters()\n+                        .stream()\n+                        .reduce((current, next) -> next);\n+                final ClientMethodParameter lastParam = lastParamOpt.get();\n+                final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n+                final GenericType pageType = (GenericType) callbackParameter.getTypeArguments()[0];\n+                final IType elementType = pageType.getTypeArguments()[0];\n+                MethodPageDetails pageDetails = clientMethod.getMethodPageDetails();\n+                if (pageDetails.getNextMethod() == null) {\n+                        succeededCodeBlock\n+                                .line(String.format(\"%s.onSuccess(new Page<%s>(nextLink, decodedResult.getValue(), decodedResult.getNextLink()), response.raw());\",", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcxNjYzOA==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497716638", "bodyText": "Pointless change.", "author": "JianpingChen", "createdAt": "2020-09-30T18:29:15Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/AndroidServiceAsyncClientTemplate.java", "diffHunk": "@@ -1,16 +1,16 @@\n package com.azure.autorest.android.template;\n \n import com.azure.autorest.extension.base.plugin.JavaSettings;\n-import com.azure.autorest.model.clientmodel.AsyncSyncClient;\n-import com.azure.autorest.model.clientmodel.MethodGroupClient;\n-import com.azure.autorest.model.clientmodel.ServiceClient;\n+import com.azure.autorest.model.clientmodel.*;", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcxODIyMg==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497718222", "bodyText": "Remove this condition?", "author": "JianpingChen", "createdAt": "2020-09-30T18:32:03Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/AndroidServiceClientTemplate.java", "diffHunk": "@@ -210,6 +201,24 @@ public void write(ServiceClient serviceClient, JavaFile javaFile) {\n             // Write client level API methods.\n             for (ClientMethod clientMethod : serviceClient.getClientMethods()) {\n                 Templates.getClientMethodTemplate().write(clientMethod, classBlock);\n+\n+                ClientMethodType clientMethodType = clientMethod.getType();\n+                if (clientMethodType == ClientMethodType.PagingAsync\n+                        && clientMethod.getMethodPageDetails().getNextMethod() != null) {\n+                    AsyncPageRetrieverTemplate asyncPageRetrieverTemplate = new AsyncPageRetrieverTemplate(clientMethod,\n+                            clientMethod.getMethodPageDetails().getNextMethod(), serviceClient);\n+                    asyncPageRetrieverTemplate.write(classBlock);\n+\n+                    if (settings.getSyncMethods() == JavaSettings.SyncMethodsGeneration.ALL) {", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcxOTE0MQ==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497719141", "bodyText": "Make static to ensure naming consistency", "author": "JianpingChen", "createdAt": "2020-09-30T18:33:42Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/AsyncPageRetrieverTemplate.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package com.azure.autorest.android.template;\n+\n+import com.azure.autorest.model.clientmodel.*;\n+import com.azure.autorest.model.javamodel.JavaClass;\n+import com.azure.autorest.model.javamodel.JavaVisibility;\n+\n+import java.util.Optional;\n+\n+public class AsyncPageRetrieverTemplate {\n+    private final ClientMethod getFirstPageMethod;\n+    private final ServiceClient serviceClient;\n+    private final ClientMethod getNextPageMethod;\n+    private String retrieverClassName;\n+\n+    public AsyncPageRetrieverTemplate(ClientMethod getFirstPageMethod,\n+                                      ClientMethod getNextPageMethod,\n+                                      ServiceClient serviceClient) {\n+        this.getFirstPageMethod = getFirstPageMethod;\n+        this.getNextPageMethod = getNextPageMethod;\n+        this.serviceClient = serviceClient;\n+    }\n+\n+    public String getClassName() {\n+        return retrieverClassName;", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcxOTU4OQ==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497719589", "bodyText": "Use static method to ensure consistency", "author": "JianpingChen", "createdAt": "2020-09-30T18:34:31Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/AsyncPageRetrieverTemplate.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package com.azure.autorest.android.template;\n+\n+import com.azure.autorest.model.clientmodel.*;\n+import com.azure.autorest.model.javamodel.JavaClass;\n+import com.azure.autorest.model.javamodel.JavaVisibility;\n+\n+import java.util.Optional;\n+\n+public class AsyncPageRetrieverTemplate {\n+    private final ClientMethod getFirstPageMethod;\n+    private final ServiceClient serviceClient;\n+    private final ClientMethod getNextPageMethod;\n+    private String retrieverClassName;\n+\n+    public AsyncPageRetrieverTemplate(ClientMethod getFirstPageMethod,\n+                                      ClientMethod getNextPageMethod,\n+                                      ServiceClient serviceClient) {\n+        this.getFirstPageMethod = getFirstPageMethod;\n+        this.getNextPageMethod = getNextPageMethod;\n+        this.serviceClient = serviceClient;\n+    }\n+\n+    public String getClassName() {\n+        return retrieverClassName;\n+    }\n+\n+    public void write(JavaClass clientClass) {\n+        final Optional<ClientMethodParameter> lastParamOpt = getFirstPageMethod.getMethodRequiredParameters()\n+                .stream()\n+                .reduce((current, next) -> next);\n+        final ClientMethodParameter lastParam = lastParamOpt.get();\n+        final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n+        final GenericType pageType = (GenericType) callbackParameter.getTypeArguments()[0];\n+        final IType elementType = pageType.getTypeArguments()[0];\n+        retrieverClassName = elementType.toString() + \"PageAsyncRetriever\";", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcyMjEzMQ==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497722131", "bodyText": "Try to avoid using name for logic", "author": "JianpingChen", "createdAt": "2020-09-30T18:39:14Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/AsyncPageRetrieverTemplate.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package com.azure.autorest.android.template;\n+\n+import com.azure.autorest.model.clientmodel.*;\n+import com.azure.autorest.model.javamodel.JavaClass;\n+import com.azure.autorest.model.javamodel.JavaVisibility;\n+\n+import java.util.Optional;\n+\n+public class AsyncPageRetrieverTemplate {\n+    private final ClientMethod getFirstPageMethod;\n+    private final ServiceClient serviceClient;\n+    private final ClientMethod getNextPageMethod;\n+    private String retrieverClassName;\n+\n+    public AsyncPageRetrieverTemplate(ClientMethod getFirstPageMethod,\n+                                      ClientMethod getNextPageMethod,\n+                                      ServiceClient serviceClient) {\n+        this.getFirstPageMethod = getFirstPageMethod;\n+        this.getNextPageMethod = getNextPageMethod;\n+        this.serviceClient = serviceClient;\n+    }\n+\n+    public String getClassName() {\n+        return retrieverClassName;\n+    }\n+\n+    public void write(JavaClass clientClass) {\n+        final Optional<ClientMethodParameter> lastParamOpt = getFirstPageMethod.getMethodRequiredParameters()\n+                .stream()\n+                .reduce((current, next) -> next);\n+        final ClientMethodParameter lastParam = lastParamOpt.get();\n+        final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n+        final GenericType pageType = (GenericType) callbackParameter.getTypeArguments()[0];\n+        final IType elementType = pageType.getTypeArguments()[0];\n+        retrieverClassName = elementType.toString() + \"PageAsyncRetriever\";\n+        String classSignature = retrieverClassName + String.format(\" extends AsyncPagedDataRetriever<%1$s, Page<%1$s>>\", elementType);\n+\n+        clientClass.privateStaticFinalClass(classSignature, javaClass -> {\n+            StringBuilder ctorSignatureBuilder = new StringBuilder();\n+            ctorSignatureBuilder.append(retrieverClassName).append(\"(\");\n+            boolean hasPrevious = false;\n+            for (ClientMethodParameter clientMethodParameter : getFirstPageMethod.getMethodParameters()) {\n+                if (clientMethodParameter.getName().contains(\"callback\")) {", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcyMjUwMw==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497722503", "bodyText": "Try to avoid using name for logic", "author": "JianpingChen", "createdAt": "2020-09-30T18:39:57Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/AsyncPageRetrieverTemplate.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package com.azure.autorest.android.template;\n+\n+import com.azure.autorest.model.clientmodel.*;\n+import com.azure.autorest.model.javamodel.JavaClass;\n+import com.azure.autorest.model.javamodel.JavaVisibility;\n+\n+import java.util.Optional;\n+\n+public class AsyncPageRetrieverTemplate {\n+    private final ClientMethod getFirstPageMethod;\n+    private final ServiceClient serviceClient;\n+    private final ClientMethod getNextPageMethod;\n+    private String retrieverClassName;\n+\n+    public AsyncPageRetrieverTemplate(ClientMethod getFirstPageMethod,\n+                                      ClientMethod getNextPageMethod,\n+                                      ServiceClient serviceClient) {\n+        this.getFirstPageMethod = getFirstPageMethod;\n+        this.getNextPageMethod = getNextPageMethod;\n+        this.serviceClient = serviceClient;\n+    }\n+\n+    public String getClassName() {\n+        return retrieverClassName;\n+    }\n+\n+    public void write(JavaClass clientClass) {\n+        final Optional<ClientMethodParameter> lastParamOpt = getFirstPageMethod.getMethodRequiredParameters()\n+                .stream()\n+                .reduce((current, next) -> next);\n+        final ClientMethodParameter lastParam = lastParamOpt.get();\n+        final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n+        final GenericType pageType = (GenericType) callbackParameter.getTypeArguments()[0];\n+        final IType elementType = pageType.getTypeArguments()[0];\n+        retrieverClassName = elementType.toString() + \"PageAsyncRetriever\";\n+        String classSignature = retrieverClassName + String.format(\" extends AsyncPagedDataRetriever<%1$s, Page<%1$s>>\", elementType);\n+\n+        clientClass.privateStaticFinalClass(classSignature, javaClass -> {\n+            StringBuilder ctorSignatureBuilder = new StringBuilder();\n+            ctorSignatureBuilder.append(retrieverClassName).append(\"(\");\n+            boolean hasPrevious = false;\n+            for (ClientMethodParameter clientMethodParameter : getFirstPageMethod.getMethodParameters()) {\n+                if (clientMethodParameter.getName().contains(\"callback\")) {\n+                    continue;\n+                }\n+                if (hasPrevious) {\n+                    ctorSignatureBuilder.append(\", \");\n+                }\n+                javaClass.privateFinalMemberVariable(clientMethodParameter.getClientType().toString(), clientMethodParameter.getName());\n+                ctorSignatureBuilder.append(String.format(\"%1$s %2$s\", clientMethodParameter.getClientType(), clientMethodParameter.getName()));\n+                hasPrevious = true;\n+            }\n+            if (hasPrevious) {\n+                ctorSignatureBuilder.append(\", \");\n+            }\n+            javaClass.privateFinalMemberVariable(serviceClient.getClassName(), \"serviceClient\");\n+            ctorSignatureBuilder.append(String.format(\"%s serviceClient\", serviceClient.getClassName()));\n+            ctorSignatureBuilder.append(\")\");\n+\n+            javaClass.constructor(JavaVisibility.Public, ctorSignatureBuilder.toString(), constructor -> {\n+                getFirstPageMethod.getMethodParameters().stream().forEach(parameter -> {\n+                    if (!parameter.getName().contains(\"callback\")) {", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcyMjk0NA==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497722944", "bodyText": "Try to use GenericType defined type for Callback", "author": "JianpingChen", "createdAt": "2020-09-30T18:40:41Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/AsyncPageRetrieverTemplate.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package com.azure.autorest.android.template;\n+\n+import com.azure.autorest.model.clientmodel.*;\n+import com.azure.autorest.model.javamodel.JavaClass;\n+import com.azure.autorest.model.javamodel.JavaVisibility;\n+\n+import java.util.Optional;\n+\n+public class AsyncPageRetrieverTemplate {\n+    private final ClientMethod getFirstPageMethod;\n+    private final ServiceClient serviceClient;\n+    private final ClientMethod getNextPageMethod;\n+    private String retrieverClassName;\n+\n+    public AsyncPageRetrieverTemplate(ClientMethod getFirstPageMethod,\n+                                      ClientMethod getNextPageMethod,\n+                                      ServiceClient serviceClient) {\n+        this.getFirstPageMethod = getFirstPageMethod;\n+        this.getNextPageMethod = getNextPageMethod;\n+        this.serviceClient = serviceClient;\n+    }\n+\n+    public String getClassName() {\n+        return retrieverClassName;\n+    }\n+\n+    public void write(JavaClass clientClass) {\n+        final Optional<ClientMethodParameter> lastParamOpt = getFirstPageMethod.getMethodRequiredParameters()\n+                .stream()\n+                .reduce((current, next) -> next);\n+        final ClientMethodParameter lastParam = lastParamOpt.get();\n+        final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n+        final GenericType pageType = (GenericType) callbackParameter.getTypeArguments()[0];\n+        final IType elementType = pageType.getTypeArguments()[0];\n+        retrieverClassName = elementType.toString() + \"PageAsyncRetriever\";\n+        String classSignature = retrieverClassName + String.format(\" extends AsyncPagedDataRetriever<%1$s, Page<%1$s>>\", elementType);\n+\n+        clientClass.privateStaticFinalClass(classSignature, javaClass -> {\n+            StringBuilder ctorSignatureBuilder = new StringBuilder();\n+            ctorSignatureBuilder.append(retrieverClassName).append(\"(\");\n+            boolean hasPrevious = false;\n+            for (ClientMethodParameter clientMethodParameter : getFirstPageMethod.getMethodParameters()) {\n+                if (clientMethodParameter.getName().contains(\"callback\")) {\n+                    continue;\n+                }\n+                if (hasPrevious) {\n+                    ctorSignatureBuilder.append(\", \");\n+                }\n+                javaClass.privateFinalMemberVariable(clientMethodParameter.getClientType().toString(), clientMethodParameter.getName());\n+                ctorSignatureBuilder.append(String.format(\"%1$s %2$s\", clientMethodParameter.getClientType(), clientMethodParameter.getName()));\n+                hasPrevious = true;\n+            }\n+            if (hasPrevious) {\n+                ctorSignatureBuilder.append(\", \");\n+            }\n+            javaClass.privateFinalMemberVariable(serviceClient.getClassName(), \"serviceClient\");\n+            ctorSignatureBuilder.append(String.format(\"%s serviceClient\", serviceClient.getClassName()));\n+            ctorSignatureBuilder.append(\")\");\n+\n+            javaClass.constructor(JavaVisibility.Public, ctorSignatureBuilder.toString(), constructor -> {\n+                getFirstPageMethod.getMethodParameters().stream().forEach(parameter -> {\n+                    if (!parameter.getName().contains(\"callback\")) {\n+                        constructor.line(String.format(\"this.%1$s = %1$s;\", parameter.getName()));\n+                    }\n+                });\n+                constructor.line(\"this.serviceClient = serviceClient;\");\n+            });\n+\n+            javaClass.publicMethod(String.format(\"void getFirstPage(Callback<Page<%s>> callback)\", elementType), getPageMethod -> {", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcyMzMzMw==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497723333", "bodyText": "Try to avoid using name for logic", "author": "JianpingChen", "createdAt": "2020-09-30T18:41:24Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/AsyncPageRetrieverTemplate.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package com.azure.autorest.android.template;\n+\n+import com.azure.autorest.model.clientmodel.*;\n+import com.azure.autorest.model.javamodel.JavaClass;\n+import com.azure.autorest.model.javamodel.JavaVisibility;\n+\n+import java.util.Optional;\n+\n+public class AsyncPageRetrieverTemplate {\n+    private final ClientMethod getFirstPageMethod;\n+    private final ServiceClient serviceClient;\n+    private final ClientMethod getNextPageMethod;\n+    private String retrieverClassName;\n+\n+    public AsyncPageRetrieverTemplate(ClientMethod getFirstPageMethod,\n+                                      ClientMethod getNextPageMethod,\n+                                      ServiceClient serviceClient) {\n+        this.getFirstPageMethod = getFirstPageMethod;\n+        this.getNextPageMethod = getNextPageMethod;\n+        this.serviceClient = serviceClient;\n+    }\n+\n+    public String getClassName() {\n+        return retrieverClassName;\n+    }\n+\n+    public void write(JavaClass clientClass) {\n+        final Optional<ClientMethodParameter> lastParamOpt = getFirstPageMethod.getMethodRequiredParameters()\n+                .stream()\n+                .reduce((current, next) -> next);\n+        final ClientMethodParameter lastParam = lastParamOpt.get();\n+        final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n+        final GenericType pageType = (GenericType) callbackParameter.getTypeArguments()[0];\n+        final IType elementType = pageType.getTypeArguments()[0];\n+        retrieverClassName = elementType.toString() + \"PageAsyncRetriever\";\n+        String classSignature = retrieverClassName + String.format(\" extends AsyncPagedDataRetriever<%1$s, Page<%1$s>>\", elementType);\n+\n+        clientClass.privateStaticFinalClass(classSignature, javaClass -> {\n+            StringBuilder ctorSignatureBuilder = new StringBuilder();\n+            ctorSignatureBuilder.append(retrieverClassName).append(\"(\");\n+            boolean hasPrevious = false;\n+            for (ClientMethodParameter clientMethodParameter : getFirstPageMethod.getMethodParameters()) {\n+                if (clientMethodParameter.getName().contains(\"callback\")) {\n+                    continue;\n+                }\n+                if (hasPrevious) {\n+                    ctorSignatureBuilder.append(\", \");\n+                }\n+                javaClass.privateFinalMemberVariable(clientMethodParameter.getClientType().toString(), clientMethodParameter.getName());\n+                ctorSignatureBuilder.append(String.format(\"%1$s %2$s\", clientMethodParameter.getClientType(), clientMethodParameter.getName()));\n+                hasPrevious = true;\n+            }\n+            if (hasPrevious) {\n+                ctorSignatureBuilder.append(\", \");\n+            }\n+            javaClass.privateFinalMemberVariable(serviceClient.getClassName(), \"serviceClient\");\n+            ctorSignatureBuilder.append(String.format(\"%s serviceClient\", serviceClient.getClassName()));\n+            ctorSignatureBuilder.append(\")\");\n+\n+            javaClass.constructor(JavaVisibility.Public, ctorSignatureBuilder.toString(), constructor -> {\n+                getFirstPageMethod.getMethodParameters().stream().forEach(parameter -> {\n+                    if (!parameter.getName().contains(\"callback\")) {\n+                        constructor.line(String.format(\"this.%1$s = %1$s;\", parameter.getName()));\n+                    }\n+                });\n+                constructor.line(\"this.serviceClient = serviceClient;\");\n+            });\n+\n+            javaClass.publicMethod(String.format(\"void getFirstPage(Callback<Page<%s>> callback)\", elementType), getPageMethod -> {\n+                StringBuilder getPageBuilder = new StringBuilder();\n+                getPageBuilder.append(String.format(\"serviceClient.%s(\", getFirstPageMethod.getName()));\n+                boolean hasPreviousParam = false;\n+                for(ClientMethodParameter clientMethodParameter : getFirstPageMethod.getMethodParameters()) {\n+                    if (clientMethodParameter.getName().contains(\"callback\")) {", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzcyMzgyNg==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497723826", "bodyText": "Try to use GenericType defined type for Callback", "author": "JianpingChen", "createdAt": "2020-09-30T18:42:21Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/AsyncPageRetrieverTemplate.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package com.azure.autorest.android.template;\n+\n+import com.azure.autorest.model.clientmodel.*;\n+import com.azure.autorest.model.javamodel.JavaClass;\n+import com.azure.autorest.model.javamodel.JavaVisibility;\n+\n+import java.util.Optional;\n+\n+public class AsyncPageRetrieverTemplate {\n+    private final ClientMethod getFirstPageMethod;\n+    private final ServiceClient serviceClient;\n+    private final ClientMethod getNextPageMethod;\n+    private String retrieverClassName;\n+\n+    public AsyncPageRetrieverTemplate(ClientMethod getFirstPageMethod,\n+                                      ClientMethod getNextPageMethod,\n+                                      ServiceClient serviceClient) {\n+        this.getFirstPageMethod = getFirstPageMethod;\n+        this.getNextPageMethod = getNextPageMethod;\n+        this.serviceClient = serviceClient;\n+    }\n+\n+    public String getClassName() {\n+        return retrieverClassName;\n+    }\n+\n+    public void write(JavaClass clientClass) {\n+        final Optional<ClientMethodParameter> lastParamOpt = getFirstPageMethod.getMethodRequiredParameters()\n+                .stream()\n+                .reduce((current, next) -> next);\n+        final ClientMethodParameter lastParam = lastParamOpt.get();\n+        final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n+        final GenericType pageType = (GenericType) callbackParameter.getTypeArguments()[0];\n+        final IType elementType = pageType.getTypeArguments()[0];\n+        retrieverClassName = elementType.toString() + \"PageAsyncRetriever\";\n+        String classSignature = retrieverClassName + String.format(\" extends AsyncPagedDataRetriever<%1$s, Page<%1$s>>\", elementType);\n+\n+        clientClass.privateStaticFinalClass(classSignature, javaClass -> {\n+            StringBuilder ctorSignatureBuilder = new StringBuilder();\n+            ctorSignatureBuilder.append(retrieverClassName).append(\"(\");\n+            boolean hasPrevious = false;\n+            for (ClientMethodParameter clientMethodParameter : getFirstPageMethod.getMethodParameters()) {\n+                if (clientMethodParameter.getName().contains(\"callback\")) {\n+                    continue;\n+                }\n+                if (hasPrevious) {\n+                    ctorSignatureBuilder.append(\", \");\n+                }\n+                javaClass.privateFinalMemberVariable(clientMethodParameter.getClientType().toString(), clientMethodParameter.getName());\n+                ctorSignatureBuilder.append(String.format(\"%1$s %2$s\", clientMethodParameter.getClientType(), clientMethodParameter.getName()));\n+                hasPrevious = true;\n+            }\n+            if (hasPrevious) {\n+                ctorSignatureBuilder.append(\", \");\n+            }\n+            javaClass.privateFinalMemberVariable(serviceClient.getClassName(), \"serviceClient\");\n+            ctorSignatureBuilder.append(String.format(\"%s serviceClient\", serviceClient.getClassName()));\n+            ctorSignatureBuilder.append(\")\");\n+\n+            javaClass.constructor(JavaVisibility.Public, ctorSignatureBuilder.toString(), constructor -> {\n+                getFirstPageMethod.getMethodParameters().stream().forEach(parameter -> {\n+                    if (!parameter.getName().contains(\"callback\")) {\n+                        constructor.line(String.format(\"this.%1$s = %1$s;\", parameter.getName()));\n+                    }\n+                });\n+                constructor.line(\"this.serviceClient = serviceClient;\");\n+            });\n+\n+            javaClass.publicMethod(String.format(\"void getFirstPage(Callback<Page<%s>> callback)\", elementType), getPageMethod -> {\n+                StringBuilder getPageBuilder = new StringBuilder();\n+                getPageBuilder.append(String.format(\"serviceClient.%s(\", getFirstPageMethod.getName()));\n+                boolean hasPreviousParam = false;\n+                for(ClientMethodParameter clientMethodParameter : getFirstPageMethod.getMethodParameters()) {\n+                    if (clientMethodParameter.getName().contains(\"callback\")) {\n+                        continue;\n+                    }\n+                    if (hasPreviousParam) {\n+                        getPageBuilder.append(\", \");\n+                    }\n+                    getPageBuilder.append(clientMethodParameter.getName());\n+                    hasPreviousParam = true;\n+                }\n+\n+                if (hasPreviousParam) {\n+                    getPageBuilder.append(\", \");\n+                }\n+                getPageBuilder.append(\"callback);\");\n+                getPageMethod.line(getPageBuilder.toString());\n+            });\n+\n+            javaClass.publicMethod(String.format(\"void getPage(String pageId, Callback<Page<%s>> callback)\", elementType), getPageMethod -> {", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzczMjUwMA==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497732500", "bodyText": "Create static method for naming consistency", "author": "JianpingChen", "createdAt": "2020-09-30T18:57:38Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/PageResponseRetrieverTemplate.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.azure.autorest.android.template;\n+\n+import com.azure.autorest.model.clientmodel.*;\n+import com.azure.autorest.model.javamodel.JavaClass;\n+import com.azure.autorest.model.javamodel.JavaVisibility;\n+\n+import java.util.Optional;\n+\n+public class PageResponseRetrieverTemplate {\n+    private final ClientMethod getFirstPageMethod;\n+    private final ServiceClient serviceClient;\n+    private final ClientMethod getNextPageMethod;\n+    private String retrieverClassName;\n+\n+    public PageResponseRetrieverTemplate(ClientMethod getFirstPageMethod,\n+                                      ClientMethod getNextPageMethod,\n+                                      ServiceClient serviceClient) {\n+        this.getFirstPageMethod = getFirstPageMethod;\n+        this.getNextPageMethod = getNextPageMethod;\n+        this.serviceClient = serviceClient;\n+    }\n+\n+    public String getClassName() {\n+        return retrieverClassName;", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzczMjY5Mg==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497732692", "bodyText": "Use static method to ensure naming consistency", "author": "JianpingChen", "createdAt": "2020-09-30T18:57:58Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/PageResponseRetrieverTemplate.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.azure.autorest.android.template;\n+\n+import com.azure.autorest.model.clientmodel.*;\n+import com.azure.autorest.model.javamodel.JavaClass;\n+import com.azure.autorest.model.javamodel.JavaVisibility;\n+\n+import java.util.Optional;\n+\n+public class PageResponseRetrieverTemplate {\n+    private final ClientMethod getFirstPageMethod;\n+    private final ServiceClient serviceClient;\n+    private final ClientMethod getNextPageMethod;\n+    private String retrieverClassName;\n+\n+    public PageResponseRetrieverTemplate(ClientMethod getFirstPageMethod,\n+                                      ClientMethod getNextPageMethod,\n+                                      ServiceClient serviceClient) {\n+        this.getFirstPageMethod = getFirstPageMethod;\n+        this.getNextPageMethod = getNextPageMethod;\n+        this.serviceClient = serviceClient;\n+    }\n+\n+    public String getClassName() {\n+        return retrieverClassName;\n+    }\n+\n+    public void write(JavaClass clientClass) {\n+        final Optional<ClientMethodParameter> lastParamOpt = getFirstPageMethod.getMethodRequiredParameters()\n+                .stream()\n+                .reduce((current, next) -> next);\n+        final ClientMethodParameter lastParam = lastParamOpt.get();\n+        final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n+        final GenericType pageType = (GenericType) callbackParameter.getTypeArguments()[0];\n+        final IType elementType = pageType.getTypeArguments()[0];\n+        retrieverClassName = elementType.toString() + \"PageResponseRetriever\";", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzczMzAxMg==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497733012", "bodyText": "Try to avoid using name for logic", "author": "JianpingChen", "createdAt": "2020-09-30T18:58:34Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/PageResponseRetrieverTemplate.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.azure.autorest.android.template;\n+\n+import com.azure.autorest.model.clientmodel.*;\n+import com.azure.autorest.model.javamodel.JavaClass;\n+import com.azure.autorest.model.javamodel.JavaVisibility;\n+\n+import java.util.Optional;\n+\n+public class PageResponseRetrieverTemplate {\n+    private final ClientMethod getFirstPageMethod;\n+    private final ServiceClient serviceClient;\n+    private final ClientMethod getNextPageMethod;\n+    private String retrieverClassName;\n+\n+    public PageResponseRetrieverTemplate(ClientMethod getFirstPageMethod,\n+                                      ClientMethod getNextPageMethod,\n+                                      ServiceClient serviceClient) {\n+        this.getFirstPageMethod = getFirstPageMethod;\n+        this.getNextPageMethod = getNextPageMethod;\n+        this.serviceClient = serviceClient;\n+    }\n+\n+    public String getClassName() {\n+        return retrieverClassName;\n+    }\n+\n+    public void write(JavaClass clientClass) {\n+        final Optional<ClientMethodParameter> lastParamOpt = getFirstPageMethod.getMethodRequiredParameters()\n+                .stream()\n+                .reduce((current, next) -> next);\n+        final ClientMethodParameter lastParam = lastParamOpt.get();\n+        final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n+        final GenericType pageType = (GenericType) callbackParameter.getTypeArguments()[0];\n+        final IType elementType = pageType.getTypeArguments()[0];\n+        retrieverClassName = elementType.toString() + \"PageResponseRetriever\";\n+        String classSignature = retrieverClassName + String.format(\" extends PagedDataResponseRetriever<%1$s, Page<%1$s>>\", elementType);\n+\n+        clientClass.privateStaticFinalClass(classSignature, javaClass -> {\n+            StringBuilder ctorSignatureBuilder = new StringBuilder();\n+            ctorSignatureBuilder.append(retrieverClassName).append(\"(\");\n+            boolean hasPrevious = false;\n+            for (ClientMethodParameter clientMethodParameter : getFirstPageMethod.getMethodParameters()) {\n+                if (clientMethodParameter.getName().contains(\"callback\")) {", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzczMzQwOA==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497733408", "bodyText": "Try to avoid using name for logic", "author": "JianpingChen", "createdAt": "2020-09-30T18:59:16Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/PageResponseRetrieverTemplate.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.azure.autorest.android.template;\n+\n+import com.azure.autorest.model.clientmodel.*;\n+import com.azure.autorest.model.javamodel.JavaClass;\n+import com.azure.autorest.model.javamodel.JavaVisibility;\n+\n+import java.util.Optional;\n+\n+public class PageResponseRetrieverTemplate {\n+    private final ClientMethod getFirstPageMethod;\n+    private final ServiceClient serviceClient;\n+    private final ClientMethod getNextPageMethod;\n+    private String retrieverClassName;\n+\n+    public PageResponseRetrieverTemplate(ClientMethod getFirstPageMethod,\n+                                      ClientMethod getNextPageMethod,\n+                                      ServiceClient serviceClient) {\n+        this.getFirstPageMethod = getFirstPageMethod;\n+        this.getNextPageMethod = getNextPageMethod;\n+        this.serviceClient = serviceClient;\n+    }\n+\n+    public String getClassName() {\n+        return retrieverClassName;\n+    }\n+\n+    public void write(JavaClass clientClass) {\n+        final Optional<ClientMethodParameter> lastParamOpt = getFirstPageMethod.getMethodRequiredParameters()\n+                .stream()\n+                .reduce((current, next) -> next);\n+        final ClientMethodParameter lastParam = lastParamOpt.get();\n+        final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n+        final GenericType pageType = (GenericType) callbackParameter.getTypeArguments()[0];\n+        final IType elementType = pageType.getTypeArguments()[0];\n+        retrieverClassName = elementType.toString() + \"PageResponseRetriever\";\n+        String classSignature = retrieverClassName + String.format(\" extends PagedDataResponseRetriever<%1$s, Page<%1$s>>\", elementType);\n+\n+        clientClass.privateStaticFinalClass(classSignature, javaClass -> {\n+            StringBuilder ctorSignatureBuilder = new StringBuilder();\n+            ctorSignatureBuilder.append(retrieverClassName).append(\"(\");\n+            boolean hasPrevious = false;\n+            for (ClientMethodParameter clientMethodParameter : getFirstPageMethod.getMethodParameters()) {\n+                if (clientMethodParameter.getName().contains(\"callback\")) {\n+                    continue;\n+                }\n+                if (hasPrevious) {\n+                    ctorSignatureBuilder.append(\", \");\n+                }\n+                javaClass.privateFinalMemberVariable(clientMethodParameter.getClientType().toString(), clientMethodParameter.getName());\n+                ctorSignatureBuilder.append(String.format(\"%1$s %2$s\", clientMethodParameter.getClientType(), clientMethodParameter.getName()));\n+                hasPrevious = true;\n+            }\n+            if (hasPrevious) {\n+                ctorSignatureBuilder.append(\", \");\n+            }\n+            javaClass.privateFinalMemberVariable(serviceClient.getClassName(), \"serviceClient\");\n+            ctorSignatureBuilder.append(String.format(\"%s serviceClient\", serviceClient.getClassName()));\n+            ctorSignatureBuilder.append(\")\");\n+\n+            javaClass.constructor(JavaVisibility.Public, ctorSignatureBuilder.toString(), constructor -> {\n+                getFirstPageMethod.getMethodParameters().stream().forEach(parameter -> {\n+                    if (!parameter.getName().contains(\"callback\")) {", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzczMzkwOA==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497733908", "bodyText": "Try to avoid using name for logic", "author": "JianpingChen", "createdAt": "2020-09-30T19:00:06Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/PageResponseRetrieverTemplate.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package com.azure.autorest.android.template;\n+\n+import com.azure.autorest.model.clientmodel.*;\n+import com.azure.autorest.model.javamodel.JavaClass;\n+import com.azure.autorest.model.javamodel.JavaVisibility;\n+\n+import java.util.Optional;\n+\n+public class PageResponseRetrieverTemplate {\n+    private final ClientMethod getFirstPageMethod;\n+    private final ServiceClient serviceClient;\n+    private final ClientMethod getNextPageMethod;\n+    private String retrieverClassName;\n+\n+    public PageResponseRetrieverTemplate(ClientMethod getFirstPageMethod,\n+                                      ClientMethod getNextPageMethod,\n+                                      ServiceClient serviceClient) {\n+        this.getFirstPageMethod = getFirstPageMethod;\n+        this.getNextPageMethod = getNextPageMethod;\n+        this.serviceClient = serviceClient;\n+    }\n+\n+    public String getClassName() {\n+        return retrieverClassName;\n+    }\n+\n+    public void write(JavaClass clientClass) {\n+        final Optional<ClientMethodParameter> lastParamOpt = getFirstPageMethod.getMethodRequiredParameters()\n+                .stream()\n+                .reduce((current, next) -> next);\n+        final ClientMethodParameter lastParam = lastParamOpt.get();\n+        final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n+        final GenericType pageType = (GenericType) callbackParameter.getTypeArguments()[0];\n+        final IType elementType = pageType.getTypeArguments()[0];\n+        retrieverClassName = elementType.toString() + \"PageResponseRetriever\";\n+        String classSignature = retrieverClassName + String.format(\" extends PagedDataResponseRetriever<%1$s, Page<%1$s>>\", elementType);\n+\n+        clientClass.privateStaticFinalClass(classSignature, javaClass -> {\n+            StringBuilder ctorSignatureBuilder = new StringBuilder();\n+            ctorSignatureBuilder.append(retrieverClassName).append(\"(\");\n+            boolean hasPrevious = false;\n+            for (ClientMethodParameter clientMethodParameter : getFirstPageMethod.getMethodParameters()) {\n+                if (clientMethodParameter.getName().contains(\"callback\")) {\n+                    continue;\n+                }\n+                if (hasPrevious) {\n+                    ctorSignatureBuilder.append(\", \");\n+                }\n+                javaClass.privateFinalMemberVariable(clientMethodParameter.getClientType().toString(), clientMethodParameter.getName());\n+                ctorSignatureBuilder.append(String.format(\"%1$s %2$s\", clientMethodParameter.getClientType(), clientMethodParameter.getName()));\n+                hasPrevious = true;\n+            }\n+            if (hasPrevious) {\n+                ctorSignatureBuilder.append(\", \");\n+            }\n+            javaClass.privateFinalMemberVariable(serviceClient.getClassName(), \"serviceClient\");\n+            ctorSignatureBuilder.append(String.format(\"%s serviceClient\", serviceClient.getClassName()));\n+            ctorSignatureBuilder.append(\")\");\n+\n+            javaClass.constructor(JavaVisibility.Public, ctorSignatureBuilder.toString(), constructor -> {\n+                getFirstPageMethod.getMethodParameters().stream().forEach(parameter -> {\n+                    if (!parameter.getName().contains(\"callback\")) {\n+                        constructor.line(String.format(\"this.%1$s = %1$s;\", parameter.getName()));\n+                    }\n+                });\n+                constructor.line(\"this.serviceClient = serviceClient;\");\n+            });\n+\n+            javaClass.publicMethod(String.format(\"%s getFirstPage()\", GenericType.AndroidHttpResponse(pageType)),  getPageMethod -> {\n+                StringBuilder getPageBuilder = new StringBuilder();\n+                getPageBuilder.append(String.format(\" return serviceClient.%sWithRestResponse(\", getFirstPageMethod.getName()));\n+                boolean hasPreviousParam = false;\n+                for (ClientMethodParameter clientMethodParameter : getFirstPageMethod.getMethodParameters()) {\n+                    if (clientMethodParameter.getName().contains(\"callback\")) {", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzczNTAwNQ==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497735005", "bodyText": "Create static method to ensure naming consistency", "author": "JianpingChen", "createdAt": "2020-09-30T19:02:06Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/PageRetrieverTemplate.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package com.azure.autorest.android.template;\n+\n+import com.azure.autorest.model.clientmodel.*;\n+import com.azure.autorest.model.javamodel.JavaClass;\n+import com.azure.autorest.model.javamodel.JavaVisibility;\n+\n+import java.util.Optional;\n+\n+public class PageRetrieverTemplate {\n+    private final ClientMethod getFirstPageMethod;\n+    private final ServiceClient serviceClient;\n+    private final ClientMethod getNextPageMethod;\n+    private String retrieverClassName;\n+\n+    public PageRetrieverTemplate(ClientMethod getFirstPageMethod,\n+                                         ClientMethod getNextPageMethod,\n+                                         ServiceClient serviceClient) {\n+        this.getFirstPageMethod = getFirstPageMethod;\n+        this.getNextPageMethod = getNextPageMethod;\n+        this.serviceClient = serviceClient;\n+    }\n+\n+    public String getClassName() {\n+        return retrieverClassName;", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzczNTIwNw==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497735207", "bodyText": "Use static method for naming", "author": "JianpingChen", "createdAt": "2020-09-30T19:02:28Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/PageRetrieverTemplate.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package com.azure.autorest.android.template;\n+\n+import com.azure.autorest.model.clientmodel.*;\n+import com.azure.autorest.model.javamodel.JavaClass;\n+import com.azure.autorest.model.javamodel.JavaVisibility;\n+\n+import java.util.Optional;\n+\n+public class PageRetrieverTemplate {\n+    private final ClientMethod getFirstPageMethod;\n+    private final ServiceClient serviceClient;\n+    private final ClientMethod getNextPageMethod;\n+    private String retrieverClassName;\n+\n+    public PageRetrieverTemplate(ClientMethod getFirstPageMethod,\n+                                         ClientMethod getNextPageMethod,\n+                                         ServiceClient serviceClient) {\n+        this.getFirstPageMethod = getFirstPageMethod;\n+        this.getNextPageMethod = getNextPageMethod;\n+        this.serviceClient = serviceClient;\n+    }\n+\n+    public String getClassName() {\n+        return retrieverClassName;\n+    }\n+\n+    public void write(JavaClass clientClass) {\n+        final Optional<ClientMethodParameter> lastParamOpt = getFirstPageMethod.getMethodRequiredParameters()\n+                .stream()\n+                .reduce((current, next) -> next);\n+        final ClientMethodParameter lastParam = lastParamOpt.get();\n+        final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n+        final GenericType pageType = (GenericType) callbackParameter.getTypeArguments()[0];\n+        final IType elementType = pageType.getTypeArguments()[0];\n+        retrieverClassName = elementType.toString() + \"PageRetriever\";", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzczNTM4OQ==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497735389", "bodyText": "Try to avoid using name for logic", "author": "JianpingChen", "createdAt": "2020-09-30T19:02:48Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/PageRetrieverTemplate.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package com.azure.autorest.android.template;\n+\n+import com.azure.autorest.model.clientmodel.*;\n+import com.azure.autorest.model.javamodel.JavaClass;\n+import com.azure.autorest.model.javamodel.JavaVisibility;\n+\n+import java.util.Optional;\n+\n+public class PageRetrieverTemplate {\n+    private final ClientMethod getFirstPageMethod;\n+    private final ServiceClient serviceClient;\n+    private final ClientMethod getNextPageMethod;\n+    private String retrieverClassName;\n+\n+    public PageRetrieverTemplate(ClientMethod getFirstPageMethod,\n+                                         ClientMethod getNextPageMethod,\n+                                         ServiceClient serviceClient) {\n+        this.getFirstPageMethod = getFirstPageMethod;\n+        this.getNextPageMethod = getNextPageMethod;\n+        this.serviceClient = serviceClient;\n+    }\n+\n+    public String getClassName() {\n+        return retrieverClassName;\n+    }\n+\n+    public void write(JavaClass clientClass) {\n+        final Optional<ClientMethodParameter> lastParamOpt = getFirstPageMethod.getMethodRequiredParameters()\n+                .stream()\n+                .reduce((current, next) -> next);\n+        final ClientMethodParameter lastParam = lastParamOpt.get();\n+        final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n+        final GenericType pageType = (GenericType) callbackParameter.getTypeArguments()[0];\n+        final IType elementType = pageType.getTypeArguments()[0];\n+        retrieverClassName = elementType.toString() + \"PageRetriever\";\n+        String classSignature = retrieverClassName + String.format(\" extends PagedDataRetriever<%1$s, Page<%1$s>>\", elementType);\n+\n+        clientClass.privateStaticFinalClass(classSignature, javaClass -> {\n+            StringBuilder ctorSignatureBuilder = new StringBuilder();\n+            ctorSignatureBuilder.append(retrieverClassName).append(\"(\");\n+            boolean hasPrevious = false;\n+            for (ClientMethodParameter clientMethodParameter : getFirstPageMethod.getMethodParameters()) {\n+                if (clientMethodParameter.getName().contains(\"callback\")) {", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzczNTc1OA==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497735758", "bodyText": "Try to avoid using name for logic", "author": "JianpingChen", "createdAt": "2020-09-30T19:03:30Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/PageRetrieverTemplate.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package com.azure.autorest.android.template;\n+\n+import com.azure.autorest.model.clientmodel.*;\n+import com.azure.autorest.model.javamodel.JavaClass;\n+import com.azure.autorest.model.javamodel.JavaVisibility;\n+\n+import java.util.Optional;\n+\n+public class PageRetrieverTemplate {\n+    private final ClientMethod getFirstPageMethod;\n+    private final ServiceClient serviceClient;\n+    private final ClientMethod getNextPageMethod;\n+    private String retrieverClassName;\n+\n+    public PageRetrieverTemplate(ClientMethod getFirstPageMethod,\n+                                         ClientMethod getNextPageMethod,\n+                                         ServiceClient serviceClient) {\n+        this.getFirstPageMethod = getFirstPageMethod;\n+        this.getNextPageMethod = getNextPageMethod;\n+        this.serviceClient = serviceClient;\n+    }\n+\n+    public String getClassName() {\n+        return retrieverClassName;\n+    }\n+\n+    public void write(JavaClass clientClass) {\n+        final Optional<ClientMethodParameter> lastParamOpt = getFirstPageMethod.getMethodRequiredParameters()\n+                .stream()\n+                .reduce((current, next) -> next);\n+        final ClientMethodParameter lastParam = lastParamOpt.get();\n+        final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n+        final GenericType pageType = (GenericType) callbackParameter.getTypeArguments()[0];\n+        final IType elementType = pageType.getTypeArguments()[0];\n+        retrieverClassName = elementType.toString() + \"PageRetriever\";\n+        String classSignature = retrieverClassName + String.format(\" extends PagedDataRetriever<%1$s, Page<%1$s>>\", elementType);\n+\n+        clientClass.privateStaticFinalClass(classSignature, javaClass -> {\n+            StringBuilder ctorSignatureBuilder = new StringBuilder();\n+            ctorSignatureBuilder.append(retrieverClassName).append(\"(\");\n+            boolean hasPrevious = false;\n+            for (ClientMethodParameter clientMethodParameter : getFirstPageMethod.getMethodParameters()) {\n+                if (clientMethodParameter.getName().contains(\"callback\")) {\n+                    continue;\n+                }\n+                if (hasPrevious) {\n+                    ctorSignatureBuilder.append(\", \");\n+                }\n+                javaClass.privateFinalMemberVariable(clientMethodParameter.getClientType().toString(), clientMethodParameter.getName());\n+                ctorSignatureBuilder.append(String.format(\"%1$s %2$s\", clientMethodParameter.getClientType(), clientMethodParameter.getName()));\n+                hasPrevious = true;\n+            }\n+            if (hasPrevious) {\n+                ctorSignatureBuilder.append(\", \");\n+            }\n+            javaClass.privateFinalMemberVariable(serviceClient.getClassName(), \"serviceClient\");\n+            ctorSignatureBuilder.append(String.format(\"%s serviceClient\", serviceClient.getClassName()));\n+            ctorSignatureBuilder.append(\")\");\n+\n+            javaClass.constructor(JavaVisibility.Public, ctorSignatureBuilder.toString(), constructor -> {\n+                getFirstPageMethod.getMethodParameters().stream().forEach(parameter -> {\n+                    if (!parameter.getName().contains(\"callback\")) {", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzczNjIwNQ==", "url": "https://github.com/Azure/autorest.java/pull/721#discussion_r497736205", "bodyText": "Try to avoid using name for logic", "author": "JianpingChen", "createdAt": "2020-09-30T19:04:17Z", "path": "androidgen/src/main/java/com/azure/autorest/android/template/PageRetrieverTemplate.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package com.azure.autorest.android.template;\n+\n+import com.azure.autorest.model.clientmodel.*;\n+import com.azure.autorest.model.javamodel.JavaClass;\n+import com.azure.autorest.model.javamodel.JavaVisibility;\n+\n+import java.util.Optional;\n+\n+public class PageRetrieverTemplate {\n+    private final ClientMethod getFirstPageMethod;\n+    private final ServiceClient serviceClient;\n+    private final ClientMethod getNextPageMethod;\n+    private String retrieverClassName;\n+\n+    public PageRetrieverTemplate(ClientMethod getFirstPageMethod,\n+                                         ClientMethod getNextPageMethod,\n+                                         ServiceClient serviceClient) {\n+        this.getFirstPageMethod = getFirstPageMethod;\n+        this.getNextPageMethod = getNextPageMethod;\n+        this.serviceClient = serviceClient;\n+    }\n+\n+    public String getClassName() {\n+        return retrieverClassName;\n+    }\n+\n+    public void write(JavaClass clientClass) {\n+        final Optional<ClientMethodParameter> lastParamOpt = getFirstPageMethod.getMethodRequiredParameters()\n+                .stream()\n+                .reduce((current, next) -> next);\n+        final ClientMethodParameter lastParam = lastParamOpt.get();\n+        final GenericType callbackParameter = (GenericType) lastParam.getWireType();\n+        final GenericType pageType = (GenericType) callbackParameter.getTypeArguments()[0];\n+        final IType elementType = pageType.getTypeArguments()[0];\n+        retrieverClassName = elementType.toString() + \"PageRetriever\";\n+        String classSignature = retrieverClassName + String.format(\" extends PagedDataRetriever<%1$s, Page<%1$s>>\", elementType);\n+\n+        clientClass.privateStaticFinalClass(classSignature, javaClass -> {\n+            StringBuilder ctorSignatureBuilder = new StringBuilder();\n+            ctorSignatureBuilder.append(retrieverClassName).append(\"(\");\n+            boolean hasPrevious = false;\n+            for (ClientMethodParameter clientMethodParameter : getFirstPageMethod.getMethodParameters()) {\n+                if (clientMethodParameter.getName().contains(\"callback\")) {\n+                    continue;\n+                }\n+                if (hasPrevious) {\n+                    ctorSignatureBuilder.append(\", \");\n+                }\n+                javaClass.privateFinalMemberVariable(clientMethodParameter.getClientType().toString(), clientMethodParameter.getName());\n+                ctorSignatureBuilder.append(String.format(\"%1$s %2$s\", clientMethodParameter.getClientType(), clientMethodParameter.getName()));\n+                hasPrevious = true;\n+            }\n+            if (hasPrevious) {\n+                ctorSignatureBuilder.append(\", \");\n+            }\n+            javaClass.privateFinalMemberVariable(serviceClient.getClassName(), \"serviceClient\");\n+            ctorSignatureBuilder.append(String.format(\"%s serviceClient\", serviceClient.getClassName()));\n+            ctorSignatureBuilder.append(\")\");\n+\n+            javaClass.constructor(JavaVisibility.Public, ctorSignatureBuilder.toString(), constructor -> {\n+                getFirstPageMethod.getMethodParameters().stream().forEach(parameter -> {\n+                    if (!parameter.getName().contains(\"callback\")) {\n+                        constructor.line(String.format(\"this.%1$s = %1$s;\", parameter.getName()));\n+                    }\n+                });\n+                constructor.line(\"this.serviceClient = serviceClient;\");\n+            });\n+\n+            javaClass.publicMethod(String.format(\"%s getFirstPage()\", pageType), getPageMethod -> {\n+                StringBuilder getPageBuilder = new StringBuilder();\n+                getPageBuilder.append(String.format(\" return serviceClient.%sWithRestResponse(\", getFirstPageMethod.getName()));\n+                boolean hasPreviousParam = false;\n+                for (ClientMethodParameter clientMethodParameter : getFirstPageMethod.getMethodParameters()) {\n+                    if (clientMethodParameter.getName().contains(\"callback\")) {", "originalCommit": "b96e404d81dc82a9c8950c5aa30ffae384b49830", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e6b7c42ce1db8b80a063942326918fe86eebce9b", "url": "https://github.com/Azure/autorest.java/commit/e6b7c42ce1db8b80a063942326918fe86eebce9b", "message": "Resolve method name clash in async client", "committedDate": "2020-09-30T19:30:41Z", "type": "commit"}, {"oid": "3b4cb2b6828edebd9db282c79bdd14defe9295bb", "url": "https://github.com/Azure/autorest.java/commit/3b4cb2b6828edebd9db282c79bdd14defe9295bb", "message": "Remove name based logic wherever appropriate", "committedDate": "2020-09-30T23:02:26Z", "type": "commit"}, {"oid": "7cde5697a03be16780a2bc47d4e7d65f2d2ce977", "url": "https://github.com/Azure/autorest.java/commit/7cde5697a03be16780a2bc47d4e7d65f2d2ce977", "message": "Remove name based logic", "committedDate": "2020-10-01T00:27:55Z", "type": "commit"}, {"oid": "f6e5b166d47af1332da4307113689c5d1ef0e4bb", "url": "https://github.com/Azure/autorest.java/commit/f6e5b166d47af1332da4307113689c5d1ef0e4bb", "message": "Only generate async method for all parameter version of the paging function; Fix a bug", "committedDate": "2020-10-01T02:01:51Z", "type": "commit"}]}