{"pr_number": 3870, "pr_title": "DB-9807 use info in tabledescriptor to colllect the ddl info for \"sho\u2026", "pr_createdAt": "2020-07-21T22:07:45Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/3870", "timeline": [{"oid": "41c73f6adc553103cbcea3d9b974b6c91124fe97", "url": "https://github.com/splicemachine/spliceengine/commit/41c73f6adc553103cbcea3d9b974b6c91124fe97", "message": "DB-9807 use info in tabledescriptor to colllect the ddl info for \"show create table\"", "committedDate": "2020-07-21T22:25:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk5MDkxMg==", "url": "https://github.com/splicemachine/spliceengine/pull/3870#discussion_r460990912", "bodyText": "I happened to touch system procedures too when implementing local temporary tables, so I think maybe I should to put the questions and observations I had here. None of them are really critical and you can just ignore if you think it's not worth implementing.", "author": "ascend1", "createdAt": "2020-07-27T15:50:46Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/utils/SpliceAdmin.java", "diffHunk": "@@ -2148,276 +2149,218 @@ public static void SHOW_CREATE_TABLE(String schemaName, String tableName, Result\n     {", "originalCommit": "a964abd818ddeebed8815c4903e60edae0d1ea09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk5NjMwNQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3870#discussion_r460996305", "bodyText": "I found some system procedures call schemaName = EngineUtils.validateSchema(schemaName) and tableName = EngineUtils.validateTable(tableName) before doing the actual logic but some don't, likely 50/50.\nThese validations kind of normalize the names and I think it's good to call them. Most observable effect is that without calling them, we have to provide schema name and table name always in upper case. Otherwise they cannot be resolved.", "author": "ascend1", "createdAt": "2020-07-27T15:58:39Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/utils/SpliceAdmin.java", "diffHunk": "@@ -2148,276 +2149,218 @@ public static void SHOW_CREATE_TABLE(String schemaName, String tableName, Result\n     {\n         Connection connection = getDefaultConn();\n         try {\n-            EngineUtils.verifyTableExists(connection, schemaName, tableName);\n-\n-            String getTableId = \"SELECT T.TABLEID, T.TABLETYPE, T.COMPRESSION, T.DELIMITED, \" +\n-                    \"T.ESCAPED, T.LINES, T.STORED, T.LOCATION\" +\n-                    \" FROM SYSVW.SYSTABLESVIEW T \" +\n-                    \"WHERE T.TABLETYPE IN ('T','E','S','V') \" +\n-                    \"AND T.TABLENAME LIKE '\" + tableName + \"' AND T.SCHEMANAME = '\" + schemaName + \"'\";\n-\n-            String tableId = \"\" ;\n-            boolean firstCol = true;\n+            TableDescriptor td = EngineUtils.verifyTableExists(connection, schemaName, tableName);", "originalCommit": "a964abd818ddeebed8815c4903e60edae0d1ea09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA1MjY0Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3870#discussion_r461052646", "bodyText": "The system procedure call SHOW_CREATE_TABLE() takes quoted schemaname and tablename, so the names are expected to be in the exact form matching that in the data dictionary table. For example:\ncreate table \"t1\" (a1 int, b1 int, c1 int);\nsplice> call syscs_util.show_create_table('SPLICE','t1');\nDDL                                                                      \n-------------------------------------------------------------------------\nCREATE TABLE \"SPLICE\".\"t1\" (\n\"A1\" INTEGER\n,\"B1\" INTEGER\n,\"C1\" INTEGER\n) ;\n\n1 row selected\n\nFor the ij command \"show create table\", it actually does some normalization(fill in scheme name, changing the name to upper case) in the below code in ij.jj:\n|   <CREATE> <TABLE> ( i = caIdentifier() ( <PERIOD> i2 = caIdentifier() )?\n\n\n\t\t{\n\t\t\tif (i2 == null) {\n\t\t\t\tschema = null;\n\t\t\t\ttblname = i;\n\t\t\t} else {\n\t\t\t\tschema = i;\n\t\t\t\ttblname = i2;\n\t\t\t}\n            if (schema == null) {\n                schema = util.getSelectedSchema(theConnection);\n            }\n\t\t\treturn showCreateTable(schema, tblname);\n\nHowever, there seems a general ij command issue that it cannot handle quoted names for the case-sensitive names. I've opened DB-9928 to track it.", "author": "yxia92", "createdAt": "2020-07-27T17:29:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk5NjMwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUwNTMyNw==", "url": "https://github.com/splicemachine/spliceengine/pull/3870#discussion_r461505327", "bodyText": "Got it. Thanks for the reply.", "author": "ascend1", "createdAt": "2020-07-28T11:19:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDk5NjMwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAwNzM4MA==", "url": "https://github.com/splicemachine/spliceengine/pull/3870#discussion_r461007380", "bodyText": "The new code here might introduce a behavior change. It's tricky. In the old query, predicate on table type is T.TABLETYPE IN ('T','E','S','V'), and that actually excludes temporary tables whose value in TABLETYPE column is 'X'. As a result, if we call show_create_table on a global temporary table, it runs through but return no SQL create statement.\nThe new code would get the TableDescriptor of a global temporary table just as a base table and eventually reaches line 2225 and below. But CREATE (LOCAL|GLOBAL) TEMPORARY TABLE statement has two special terms [NOLOGGING | ON COMMIT PRESERVE ROWS]. So maybe we should have an extra branch for temporary tables and check these two properties. Or we can keep the old behavior and silently skip for temporary tables.", "author": "ascend1", "createdAt": "2020-07-27T16:16:00Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/utils/SpliceAdmin.java", "diffHunk": "@@ -2148,276 +2149,218 @@ public static void SHOW_CREATE_TABLE(String schemaName, String tableName, Result\n     {\n         Connection connection = getDefaultConn();\n         try {\n-            EngineUtils.verifyTableExists(connection, schemaName, tableName);\n-\n-            String getTableId = \"SELECT T.TABLEID, T.TABLETYPE, T.COMPRESSION, T.DELIMITED, \" +\n-                    \"T.ESCAPED, T.LINES, T.STORED, T.LOCATION\" +\n-                    \" FROM SYSVW.SYSTABLESVIEW T \" +\n-                    \"WHERE T.TABLETYPE IN ('T','E','S','V') \" +\n-                    \"AND T.TABLENAME LIKE '\" + tableName + \"' AND T.SCHEMANAME = '\" + schemaName + \"'\";\n-\n-            String tableId = \"\" ;\n-            boolean firstCol = true;\n+            TableDescriptor td = EngineUtils.verifyTableExists(connection, schemaName, tableName);\n \n             //External Table\n             String isExternal = \"\";\n             StringBuilder extTblString = new StringBuilder(\"\");\n \n-            try (Statement stmt = connection.createStatement()) {\n-                try (ResultSet tableIdRs = stmt.executeQuery(getTableId)) {\n-                    if (tableIdRs.next()) {\n-                        tableId = tableIdRs.getString(1);\n-                        String tableType = tableIdRs.getString(2);\n-                        //Process external table definition\n-                        if (\"E\".equals(tableType)) {\n-                            PreparedStatement getPartitionedColsStmt = connection.prepareStatement(\"SELECT C.COLUMNNAME \" +\n-                                    \"FROM SYSVW.SYSCOLUMNSVIEW C WHERE C.REFERENCEID = ? \" +\n-                                    \"AND C.PARTITIONPOSITION > -1 ORDER BY C.PARTITIONPOSITION\");\n-                            String tmpStr;\n-                            isExternal = \"EXTERNAL \";\n-                            tmpStr = tableIdRs.getString(3);\n-                            if (tmpStr != null && !tmpStr.equals(\"none\"))\n-                                extTblString.append(\"\\nCOMPRESSED WITH \" + tmpStr);\n-\n-                            // Partitioned Columns\n-                            getPartitionedColsStmt.setString(1, tableId);\n-                            try (ResultSet pcRS = getPartitionedColsStmt.executeQuery()) {\n-                                while (pcRS.next()) {\n-                                    extTblString.append(firstCol ? \"\\nPARTITIONED BY (\" + pcRS.getString(1) : \",\" + pcRS.getString(1));\n-                                    firstCol = false;\n-                                }\n-                            }\n-                            getPartitionedColsStmt.close();\n-                            if (!firstCol)\n-                                extTblString.append(\")\");\n-\n-                            // Row Format\n-                            if (tableIdRs.getString(4) != null || tableIdRs.getString(6) != null) {\n-                                extTblString.append(\"\\nROW FORMAT DELIMITED\");\n-                                if ((tmpStr = tableIdRs.getString(4)) != null)\n-                                    extTblString.append(\" FIELDS TERMINATED BY ''\" + tmpStr + \"''\");\n-                                if ((tmpStr = tableIdRs.getString(5)) != null)\n-                                    extTblString.append(\" ESCAPED BY ''\" + tmpStr + \"''\");\n-                                if ((tmpStr = tableIdRs.getString(6)) != null)\n-                                    extTblString.append(\" LINES TERMINATED BY ''\" + tmpStr + \"''\");\n-                            }\n-                            // Storage type\n-                            if ((tmpStr = tableIdRs.getString(7)) != null) {\n-                                extTblString.append(\"\\nSTORED AS \");\n-                                switch (tmpStr) {\n-                                    case \"T\":\n-                                        extTblString.append(\"TEXTFILE\");\n-                                        break;\n-                                    case \"P\":\n-                                        extTblString.append(\"PARQUET\");\n-                                        break;\n-                                    case \"A\":\n-                                        extTblString.append(\"AVRO\");\n-                                        break;\n-                                    case \"O\":\n-                                        extTblString.append(\"ORC\");\n-                                        break;\n-                                    default:\n-                                        throw new SQLException(\"Invalid stored format\");\n-                                }\n-                            }\n-                            // Location\n-                            if ((tmpStr = tableIdRs.getString(8)) != null) {\n-                                extTblString.append(\"\\nLOCATION ''\" + tmpStr + \"''\");\n-                            }\n-                        }//End External Table\n-                        else if (\"V\".equals(tableType)) {\n-                            //Target table is a View\n-                            throw ErrorState.LANG_INVALID_OPERATION_ON_VIEW.newException(\"SHOW CREATE TABLE\", \"\\\"\" + schemaName + \"\\\".\\\"\" + tableName + \"\\\"\");\n-                        } else if (\"S\".equals(tableType)) {\n-                            //Target table is a system table\n-                            throw ErrorState.LANG_NO_USER_DDL_IN_SYSTEM_SCHEMA.newException(\"SHOW CREATE TABLE\", schemaName);\n-                        }\n-                        // Get column list, and write DDL for each column.\n-                        StringBuilder colStringBuilder = new StringBuilder(\"\");\n-                        String createColString = \"\";\n-\n-                        PreparedStatement getColumnInfoStmt = connection.prepareStatement(\"SELECT C.COLUMNNAME, C.REFERENCEID, \" +\n-                                \"C.COLUMNNUMBER FROM SYSVW.SYSCOLUMNSVIEW C WHERE C.REFERENCEID = ? \" +\n-                                \"ORDER BY C.COLUMNNUMBER\");\n-                        getColumnInfoStmt.setString(1, tableId);\n-                        ResultSet columnRS = getColumnInfoStmt.executeQuery();\n-\n-                        firstCol = true;\n-                        while (columnRS.next()) {\n-                            String colName = columnRS.getString(1);\n-                            createColString = createColumn(connection, colName, columnRS.getString(2), columnRS.getInt(3));\n-                            colStringBuilder.append(firstCol ? createColString : \",\" + createColString).append(\"\\n\");\n-                            firstCol = false;\n-                        }\n-                        columnRS.close();\n-                        getColumnInfoStmt.close();\n-\n-                        colStringBuilder.append(createConstraint((EmbedConnection) connection, schemaName, tableName));\n-                        String DDL = \"CREATE \" + isExternal + \"TABLE \\\"\" + schemaName + \"\\\".\\\"\" + tableName + \"\\\" (\\n\" + colStringBuilder.toString() + \") \";\n-                        StringBuilder sb = new StringBuilder(\"SELECT * FROM (VALUES '\");\n-                        sb.append(DDL);\n-                        String extStr = extTblString.toString();\n-                        if (extStr.length() > 0)\n-                            sb.append(extStr);\n-                        sb.append(\";') FOO (DDL)\");\n-                        resultSet[0] = executeStatement(sb);\n+            ColumnDescriptorList cdl = td.getColumnDescriptorList();\n+            //Process external table definition\n+            if (td.isExternal()) {\n+                List<ColumnDescriptor> partitionColumns = cdl.stream()\n+                        .filter(columnDescriptor -> columnDescriptor.getPartitionPosition() > -1)\n+                        .collect(Collectors.toList());\n+                partitionColumns.sort(Comparator.comparing(columnDescriptor -> columnDescriptor.getPartitionPosition()));\n+\n+                String tmpStr;\n+                isExternal = \"EXTERNAL \";\n+                tmpStr = td.getCompression();\n+                if (tmpStr != null && !tmpStr.equals(\"none\"))\n+                    extTblString.append(\"\\nCOMPRESSED WITH \" + tmpStr);\n+\n+                // Partitioned Columns\n+                boolean firstCol = true;\n+                for (ColumnDescriptor col: partitionColumns) {\n+                    extTblString.append(firstCol ? \"\\nPARTITIONED BY (\\\"\" + col.getColumnName()+\"\\\"\" : \",\\\"\" + col.getColumnName()+\"\\\"\");\n+                    firstCol = false;\n+                }\n+\n+                if (!firstCol)\n+                    extTblString.append(\")\");\n+\n+                // Row Format\n+                if (td.getDelimited() != null || td.getLines() != null) {\n+                    extTblString.append(\"\\nROW FORMAT DELIMITED\");\n+                    if ((tmpStr = td.getDelimited()) != null)\n+                        extTblString.append(\" FIELDS TERMINATED BY ''\" + tmpStr + \"''\");\n+                    if ((tmpStr = td.getEscaped()) != null)\n+                        extTblString.append(\" ESCAPED BY ''\" + tmpStr + \"''\");\n+                    if ((tmpStr = td.getLines()) != null)\n+                        extTblString.append(\" LINES TERMINATED BY ''\" + tmpStr + \"''\");\n+                }\n+                // Storage type\n+                if ((tmpStr = td.getStoredAs()) != null) {\n+                    extTblString.append(\"\\nSTORED AS \");\n+                    switch (tmpStr) {\n+                        case \"T\":\n+                            extTblString.append(\"TEXTFILE\");\n+                            break;\n+                        case \"P\":\n+                            extTblString.append(\"PARQUET\");\n+                            break;\n+                        case \"A\":\n+                            extTblString.append(\"AVRO\");\n+                            break;\n+                        case \"O\":\n+                            extTblString.append(\"ORC\");\n+                            break;\n+                        default:\n+                            throw new SQLException(\"Invalid stored format\");\n                     }\n                 }\n+                // Location\n+                if ((tmpStr = td.getLocation()) != null) {\n+                    extTblString.append(\"\\nLOCATION ''\" + tmpStr + \"''\");\n+                }\n+            }//End External Table\n+            else if (td.getTableType() == TableDescriptor.VIEW_TYPE) {\n+                //Target table is a View\n+                throw ErrorState.LANG_INVALID_OPERATION_ON_VIEW.newException(\"SHOW CREATE TABLE\", \"\\\"\" + schemaName + \"\\\".\\\"\" + tableName + \"\\\"\");\n+            } else if (td.getTableType() == TableDescriptor.SYSTEM_TABLE_TYPE) {\n+                //Target table is a system table\n+                throw ErrorState.LANG_NO_USER_DDL_IN_SYSTEM_SCHEMA.newException(\"SHOW CREATE TABLE\", schemaName);\n+            }\n+            // Get column list, and write DDL for each column.", "originalCommit": "a964abd818ddeebed8815c4903e60edae0d1ea09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAyNTU4OA==", "url": "https://github.com/splicemachine/spliceengine/pull/3870#discussion_r461025588", "bodyText": "Thanks @ascend1 ! I think it makes sense to support show create table for temp table also. I'll add the code to handle the options.", "author": "yxia92", "createdAt": "2020-07-27T16:45:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAwNzM4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTI0MTIyOA==", "url": "https://github.com/splicemachine/spliceengine/pull/3870#discussion_r461241228", "bodyText": "I've added the code to support temporary table.", "author": "yxia92", "createdAt": "2020-07-28T00:10:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTAwNzM4MA=="}], "type": "inlineReview"}, {"oid": "5917ef5c33869b6a7a29bf6f56414ec6e811e159", "url": "https://github.com/splicemachine/spliceengine/commit/5917ef5c33869b6a7a29bf6f56414ec6e811e159", "message": "DB-9807 use info in tabledescriptor to colllect the ddl info for \"show create table\"", "committedDate": "2020-07-30T18:57:07Z", "type": "commit"}, {"oid": "918421e91d696d01c391d9898c3267353d860186", "url": "https://github.com/splicemachine/spliceengine/commit/918421e91d696d01c391d9898c3267353d860186", "message": "DB-9807 fix non-deterministic behavior in IT", "committedDate": "2020-07-30T18:57:07Z", "type": "commit"}, {"oid": "d220c46fccc9dc8075682111685cd33a3cbc9bc7", "url": "https://github.com/splicemachine/spliceengine/commit/d220c46fccc9dc8075682111685cd33a3cbc9bc7", "message": "DB-9807 support tempoary table for show create table.", "committedDate": "2020-07-30T18:57:07Z", "type": "commit"}, {"oid": "f407c28323c195d83c45e48112424e5678c78a87", "url": "https://github.com/splicemachine/spliceengine/commit/f407c28323c195d83c45e48112424e5678c78a87", "message": "DB-9807 fix IT to correctly ignore constraint order difference", "committedDate": "2020-07-30T18:57:07Z", "type": "commit"}, {"oid": "f407c28323c195d83c45e48112424e5678c78a87", "url": "https://github.com/splicemachine/spliceengine/commit/f407c28323c195d83c45e48112424e5678c78a87", "message": "DB-9807 fix IT to correctly ignore constraint order difference", "committedDate": "2020-07-30T18:57:07Z", "type": "forcePushed"}]}