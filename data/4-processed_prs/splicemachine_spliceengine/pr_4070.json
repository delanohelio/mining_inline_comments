{"pr_number": 4070, "pr_title": "DB-10084 HBase flush and compactions are aware of min retention period", "pr_createdAt": "2020-09-01T13:53:09Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4070", "timeline": [{"oid": "2ad7e931410d4af9ec3fd3f090b2732a36ca552e", "url": "https://github.com/splicemachine/spliceengine/commit/2ad7e931410d4af9ec3fd3f090b2732a36ca552e", "message": "DB-10084 tolerate having Splice flusher not set properly.", "committedDate": "2020-09-01T15:02:04Z", "type": "forcePushed"}, {"oid": "dd17493653ccb8ba06a1235ea8750612ba262185", "url": "https://github.com/splicemachine/spliceengine/commit/dd17493653ccb8ba06a1235ea8750612ba262185", "message": "DB-10084 tolerate having Splice flusher not set properly.", "committedDate": "2020-09-09T09:18:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ4OTIzOA==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r485489238", "bodyText": "Shouldn't we add the new column at the end of the view columns?\n@yxia92 what do you think?", "author": "arnaud-splice", "createdAt": "2020-09-09T09:56:34Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/SYSTABLESRowFactory.java", "diffHunk": "@@ -52,661 +52,666 @@\n /**\n  * Factory for creating a SYSTABLES row.\n  *\n- *\n  * @version 0.1\n  */\n-\n-public class SYSTABLESRowFactory extends CatalogRowFactory\n-{\n-\tpublic static final String\t\tTABLENAME_STRING = \"SYSTABLES\";\n-\n-\tpublic static final int\t\tSYSTABLES_COLUMN_COUNT = 15;\n-\t/* Column #s for systables (1 based) */\n-\tpublic static final int\t\tSYSTABLES_TABLEID = 1;\n-\tpublic static final int\t\tSYSTABLES_TABLENAME = 2;\n-\tprotected static final int\t\tSYSTABLES_TABLETYPE = 3;\n-\tpublic static final int\t\tSYSTABLES_SCHEMAID = 4;\n-\tprotected static final int\t\tSYSTABLES_LOCKGRANULARITY = 5;\n-\tprotected static final int\t\tSYSTABLES_VERSION = 6;\n+public class SYSTABLESRowFactory extends CatalogRowFactory {\n+    public static final String TABLENAME_STRING = \"SYSTABLES\";\n+\n+    public static final int SYSTABLES_COLUMN_COUNT = 16;\n+\n+    /* Column #s for systables (1 based) */\n+    public    static final int SYSTABLES_TABLEID                = 1;\n+    public    static final int SYSTABLES_TABLENAME              = 2;\n+    protected static final int SYSTABLES_TABLETYPE              = 3;\n+    public    static final int SYSTABLES_SCHEMAID               = 4;\n+    protected static final int SYSTABLES_LOCKGRANULARITY        = 5;\n+    protected static final int SYSTABLES_VERSION                = 6;\n     /* Sequence for understanding coding/decoding with altering tables*/\n-    protected static final int\t\tSYSTABLES_COLUMN_SEQUENCE = 7;\n-\t/* External Tables Columns\t*/\n-\tprotected static final int\t\tSYSTABLES_DELIMITED_BY = 8;\n-\tprotected static final int\t\tSYSTABLES_ESCAPED_BY = 9;\n-\tprotected static final int\t\tSYSTABLES_LINES_BY = 10;\n-\tprotected static final int\t\tSYSTABLES_STORED_AS = 11;\n-\tprotected static final int\t\tSYSTABLES_LOCATION = 12;\n-\tprotected static final int\t\tSYSTABLES_COMPRESSION = 13;\n-\t// SYSTABLES_IS_PINNED : NOT USED ANYMORE, for backward compatibility only\n-\t@Deprecated\n-\tprotected static final int \t\tSYSTABLES_IS_PINNED = 14;\n-\tprotected static final int      SYSTABLES_PURGE_DELETED_ROWS = 15;\n-\t/* End External Tables Columns\t*/\n-\tprotected static final int\t\tSYSTABLES_INDEX1_ID = 0;\n-\tprotected static final int\t\tSYSTABLES_INDEX1_TABLENAME = 1;\n-\tprotected static final int\t\tSYSTABLES_INDEX1_SCHEMAID = 2;\n-\n-\tprotected static final int\t\tSYSTABLES_INDEX2_ID = 1;\n-\tprotected static final int\t\tSYSTABLES_INDEX2_TABLEID = 1;\n-\n-\n-    public static final String      PURGE_DELETED_ROWS = \"PURGE_DELETED_ROWS\";\n-\t/*\n-\t * The first version of any tables. Use this for System tables and\n-\t * any time that you don't know what the version is.\n-\t */\n-\tpublic static final String ORIGINAL_TABLE_VERSION = \"1.0\";\n-\t//the current version for creating new tables with\n-\tpublic static final String CURRENT_TABLE_VERSION = \"4.0\";\n-\t\n-\t// all indexes are unique.\n-\n-\tprivate\tstatic\tfinal\tString[]\tuuids =\n-\t{\n-\t\t \"80000018-00d0-fd77-3ed8-000a0a0b1900\"\t// catalog UUID\n-\t\t,\"80000028-00d0-fd77-3ed8-000a0a0b1900\"\t// heap UUID\n-\t\t,\"8000001a-00d0-fd77-3ed8-000a0a0b1900\"\t// SYSTABLES_INDEX1\n-\t\t,\"8000001c-00d0-fd77-3ed8-000a0a0b1900\"\t// SYSTABLES_INDEX2\n-\t};\n-\n-\tprivate static final int[][] indexColumnPositions = \n-\t{ \n-\t\t{ SYSTABLES_TABLENAME, SYSTABLES_SCHEMAID},\n-\t\t{ SYSTABLES_TABLEID }\n-\t};\n-\n-\t/////////////////////////////////////////////////////////////////////////////\n-\t//\n-\t//\tCONSTRUCTORS\n-\t//\n-\t/////////////////////////////////////////////////////////////////////////////\n-\n-    SYSTABLESRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf)\n-\t{\n-\t\tsuper(uuidf,ef,dvf);\n-\t\tinitInfo(SYSTABLES_COLUMN_COUNT, TABLENAME_STRING, indexColumnPositions, (boolean[]) null, uuids);\n-\t}\n-\n-\tSYSTABLESRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf, DataDictionary dd)\n-\t{\n-\t\tsuper(uuidf,ef,dvf, dd);\n-\t\tinitInfo(SYSTABLES_COLUMN_COUNT, TABLENAME_STRING, indexColumnPositions, (boolean[]) null, uuids);\n-\t}\n-\t/////////////////////////////////////////////////////////////////////////////\n-\t//\n-\t//\tMETHODS\n-\t//\n-\t/////////////////////////////////////////////////////////////////////////////\n-\n-\t/**\n-\t * Make a SYSTABLES row\n-\t *\n-\t * @return\tRow suitable for inserting into SYSTABLES.\n-\t *\n-\t * @exception   StandardException thrown on failure\n-\t */\n-\n-\t@SuppressFBWarnings(value = \"BC_UNCONFIRMED_CAST\", justification = \"DB-9844\")\n-\tpublic ExecRow makeRow(boolean latestVersion, TupleDescriptor td,\n-\t\t\t\t\t\t   TupleDescriptor\tparent)\n-\t\t\t\t\tthrows StandardException\n-\t{\n-\t\tUUID\t\t\t\t\t\toid;\n-\t\tString\t   \t\t\t\ttabSType = null;\n-\t\tint\t   \t\t\t\t\ttabIType;\n-\t\tExecRow        \t\t\trow;\n-\t\tString\t\t\t\t\tlockGranularity = null;\n-\t\tString\t\t\t\t\ttableID = null;\n-\t\tString\t\t\t\t\tschemaID = null;\n-\t\tString\t\t\t\t\ttableName = null;\n-        int                     columnSequence = 0;\n-\t\tString \t\t\t\t\tdelimited = null;\n-\t\tString \t\t\t\t\tescaped = null;\n-\t\tString \t\t\t\t\tlines = null;\n-\t\tString \t\t\t\t\tstoredAs = null;\n-\t\tString \t\t\t\t\tlocation = null;\n-\t\tString \t\t\t\t\tcompression = null;\n-\t\tSQLVarchar              tableVersion = null;\n-\t\t// NOT USED ANYMORE, for backward compatibility only\n-\t\t@Deprecated\n-\t\tboolean \t\t\t\tisPinned = false;\n-\t\tboolean                 purgeDeletedRows = false;\n-\n-\t\tif (td != null)\n-\t\t{\n-\t\t\t/*\n-\t\t\t** We only allocate a new UUID if the descriptor doesn't already have one.\n-\t\t\t** For descriptors replicated from a Source system, we already have an UUID.\n-\t\t\t*/\n-\t\t\tif (!(td instanceof TableDescriptor))\n-\t\t\t\tthrow new RuntimeException(\"Unexpected TableDescriptor \" + td.getClass().getName());\n-\t\t\tif (!(parent instanceof SchemaDescriptor))\n-\t\t\t\tthrow new RuntimeException(\"Unexpected SchemaDescriptor \" + parent.getClass().getName());\n-\t\t\tTableDescriptor descriptor = (TableDescriptor)td;\n-\t\t\tSchemaDescriptor schema = (SchemaDescriptor)parent;\n+    protected static final int SYSTABLES_COLUMN_SEQUENCE        = 7;\n+    /* External Tables Columns */\n+    protected static final int SYSTABLES_DELIMITED_BY           = 8;\n+    protected static final int SYSTABLES_ESCAPED_BY             = 9;\n+    protected static final int SYSTABLES_LINES_BY               = 10;\n+    protected static final int SYSTABLES_STORED_AS              = 11;\n+    protected static final int SYSTABLES_LOCATION               = 12;\n+    protected static final int SYSTABLES_COMPRESSION            = 13;\n+    // SYSTABLES_IS_PINNED : NOT USED ANYMORE, for backward compatibility only\n+    @Deprecated\n+    protected static final int SYSTABLES_IS_PINNED              = 14;\n+    protected static final int SYSTABLES_PURGE_DELETED_ROWS     = 15;\n+    protected static final int SYSTABLES_MIN_RETENTION_PERIOD   = 16;\n+    /* End External Tables Columns */\n+\n+    protected static final int SYSTABLES_INDEX1_ID        = 0;\n+    protected static final int SYSTABLES_INDEX1_TABLENAME = 1;\n+    protected static final int SYSTABLES_INDEX1_SCHEMAID  = 2;\n+\n+    protected static final int SYSTABLES_INDEX2_ID        = 1;\n+    protected static final int SYSTABLES_INDEX2_TABLEID   = 1;\n+\n+    /* Column names */\n+    public static final String IS_PINNED            = \"IS_PINNED\";\n+    public static final String COMPRESSION          = \"COMPRESSION\";\n+    public static final String LOCATION             = \"LOCATION\";\n+    public static final String STORED               = \"STORED\";\n+    public static final String LINES                = \"LINES\";\n+    public static final String ESCAPED              = \"ESCAPED\";\n+    public static final String DELIMITED            = \"DELIMITED\";\n+    public static final String COLSEQUENCE          = \"COLSEQUENCE\";\n+    public static final String VERSION              = \"VERSION\";\n+    public static final String LOCKGRANULARITY      = \"LOCKGRANULARITY\";\n+    public static final String SCHEMAID             = \"SCHEMAID\";\n+    public static final String TABLETYPE            = \"TABLETYPE\";\n+    public static final String TABLENAME            = \"TABLENAME\";\n+    public static final String TABLEID              = \"TABLEID\";\n+    public static final String PURGE_DELETED_ROWS   = \"PURGE_DELETED_ROWS\";\n+    public static final String MIN_RETENTION_PERIOD = \"MIN_RETENTION_PERIOD\";\n+    /*\n+     * The first version of any tables. Use this for System tables and\n+     * any time that you don't know what the version is.\n+     */\n+    public static final String ORIGINAL_TABLE_VERSION = \"1.0\";\n+    //the current version for creating new tables with\n+    public static final String CURRENT_TABLE_VERSION = \"4.0\";\n+\n+    // all indexes are unique.\n+\n+    private static final String[] uuids =\n+        {\n+            \"80000018-00d0-fd77-3ed8-000a0a0b1900\", // catalog UUID\n+            \"80000028-00d0-fd77-3ed8-000a0a0b1900\", // heap UUID\n+            \"8000001a-00d0-fd77-3ed8-000a0a0b1900\", // SYSTABLES_INDEX1\n+            \"8000001c-00d0-fd77-3ed8-000a0a0b1900\", // SYSTABLES_INDEX2\n+        };\n+\n+    private static final int[][] indexColumnPositions =\n+        {\n+            {SYSTABLES_TABLENAME, SYSTABLES_SCHEMAID},\n+            {SYSTABLES_TABLEID}\n+        };\n+\n+\n+    /////////////////////////////////////////////////////////////////////////////\n+    //\n+    //\tCONSTRUCTORS\n+    //\n+    /////////////////////////////////////////////////////////////////////////////\n+\n+    SYSTABLESRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf) {\n+        super(uuidf, ef, dvf);\n+        initInfo(SYSTABLES_COLUMN_COUNT, TABLENAME_STRING, indexColumnPositions, (boolean[]) null, uuids);\n+    }\n+\n+    SYSTABLESRowFactory(UUIDFactory uuidf, ExecutionFactory ef, DataValueFactory dvf, DataDictionary dd)\n+    {\n+        super(uuidf,ef,dvf, dd);\n+        initInfo(SYSTABLES_COLUMN_COUNT, TABLENAME_STRING, indexColumnPositions, (boolean[]) null, uuids);\n+    }\n+\n+    /////////////////////////////////////////////////////////////////////////////\n+    //\n+    //\tMETHODS\n+    //\n+    /////////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     * Make a SYSTABLES row\n+     *\n+     * @throws StandardException thrown on failure\n+     * @return Row suitable for inserting into SYSTABLES.\n+     */\n+    @SuppressFBWarnings(value = \"BC_UNCONFIRMED_CAST\", justification = \"DB-9844\")\n+    public ExecRow makeRow(boolean latestVersion,\n+                           TupleDescriptor td,\n+                           TupleDescriptor parent)\n+            throws StandardException {\n+        UUID oid;\n+        String tabSType = null;\n+        int tabIType;\n+        ExecRow row;\n+        String lockGranularity = null;\n+        String tableID = null;\n+        String schemaID = null;\n+        String tableName = null;\n+        int columnSequence = 0;\n+        String delimited = null;\n+        String escaped = null;\n+        String lines = null;\n+        String storedAs = null;\n+        String location = null;\n+        String compression = null;\n+        SQLVarchar tableVersion = null;\n+        // NOT USED ANYMORE, for backward compatibility only\n+        @Deprecated\n+        boolean isPinned = false;\n+        boolean purgeDeletedRows = false;\n+        Long minRetentionPeriod = null;\n+\n+        if (td != null) {\n+            /*\n+             ** We only allocate a new UUID if the descriptor doesn't already have one.\n+             ** For descriptors replicated from a Source system, we already have an UUID.\n+             */\n+            if (!(td instanceof TableDescriptor))\n+                throw new RuntimeException(\"Unexpected TableDescriptor \" + td.getClass().getName());\n+            if (!(parent instanceof SchemaDescriptor))\n+                throw new RuntimeException(\"Unexpected SchemaDescriptor \" + parent.getClass().getName());\n+            TableDescriptor descriptor = (TableDescriptor) td;\n+            SchemaDescriptor schema = (SchemaDescriptor) parent;\n \n             columnSequence = descriptor.getColumnSequence();\n-\t\t\toid = descriptor.getUUID();\n-\t\t\tif ( oid == null )\n-\t\t    {\n-\t\t\t\toid = getUUIDFactory().createUUID();\n-\t\t\t\tdescriptor.setUUID(oid);\n-\t\t\t}\n-\t\t\ttableID = oid.toString();\n-\t\t\t\n-\t\t\tif (SanityManager.DEBUG)\n-\t\t\t{\n-\t\t\t\tSanityManager.ASSERT(schema != null, \n-\t\t\t\t\t\t\t\"Schema should not be null unless empty row is true\");\n-\t\t\t\tif (schema.getUUID() == null)\n-\t\t\t\t{\n-\t\t\t\t\tSanityManager.THROWASSERT(\"schema \" + schema + \" has a null OID\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\n-\t\t\tschemaID = schema.getUUID().toString();\n-\n-\t\t\ttableName = descriptor.getName();\n-\n-\t\t\t/* RESOLVE - Table Type should really be a char in the descriptor\n-\t\t\t * T, S, V, S instead of 0, 1, 2, 3\n-\t\t\t */\n-\t\t\ttabIType = descriptor.getTableType();\n-\t\t\tswitch (tabIType)\n-\t\t\t{\n-\t\t\t    case TableDescriptor.BASE_TABLE_TYPE:\n-\t\t\t\t\ttabSType = \"T\";\n-\t\t\t\t\tbreak;\n-\t\t\t    case TableDescriptor.SYSTEM_TABLE_TYPE:\n-\t\t\t\t\ttabSType = \"S\";\n-\t\t\t\t\tbreak;\n-\t\t\t    case TableDescriptor.VIEW_TYPE:\n-\t\t\t\t\ttabSType = \"V\";\n-\t\t\t\t\tbreak;\t\t\n-\n-\t\t\t    case TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE:\n-\t\t\t\t\ttabSType = \"X\";\n-\t\t\t\t\tbreak;\t\t\n-\n-\t\t\t    case TableDescriptor.SYNONYM_TYPE:\n-\t\t\t\t\ttabSType = \"A\";\n-\t\t\t\t\tbreak;\n-\t\t\t\tcase TableDescriptor.EXTERNAL_TYPE:\n-\t\t\t\t\ttabSType = \"E\";\n-\t\t\t\t\tbreak;\n-\n-\n-\t\t\t    default:\n-\t\t\t\t\tif (SanityManager.DEBUG)\n-\t\t\t\t\t\tSanityManager.THROWASSERT(\"invalid table type\");\n-\t\t\t}\n-\t\t\tchar[] lockGChar = new char[1];\n-\t\t\tlockGChar[0] = descriptor.getLockGranularity();\n-\t\t\tlockGranularity = new String(lockGChar);\n-\t\t\tdelimited = descriptor.getDelimited();\n-\t\t\tescaped = descriptor.getEscaped();\n-\t\t\tlines = descriptor.getLines();\n-\t\t\tstoredAs = descriptor.getStoredAs();\n-\t\t\tlocation = descriptor.getLocation();\n-\t\t\tcompression = descriptor.getCompression();\n-\t\t\t//NOT USED ANYMORE, for backward compatibility only\n-\t\t\tisPinned = descriptor.isPinned();\n+            oid = descriptor.getUUID();\n+            if (oid == null) {\n+                oid = getUUIDFactory().createUUID();\n+                descriptor.setUUID(oid);\n+            }\n+            tableID = oid.toString();\n+\n+            if (SanityManager.DEBUG) {\n+                SanityManager.ASSERT(schema != null,\n+                        \"Schema should not be null unless empty row is true\");\n+                if (schema.getUUID() == null) {\n+                    SanityManager.THROWASSERT(\"schema \" + schema + \" has a null OID\");\n+                }\n+            }\n+\n+            schemaID = schema.getUUID().toString();\n+\n+            tableName = descriptor.getName();\n+\n+            /* RESOLVE - Table Type should really be a char in the descriptor\n+             * T, S, V, S instead of 0, 1, 2, 3\n+             */\n+            tabIType = descriptor.getTableType();\n+            switch (tabIType) {\n+                case TableDescriptor.BASE_TABLE_TYPE:\n+                    tabSType = \"T\";\n+                    break;\n+                case TableDescriptor.SYSTEM_TABLE_TYPE:\n+                    tabSType = \"S\";\n+                    break;\n+                case TableDescriptor.VIEW_TYPE:\n+                    tabSType = \"V\";\n+                    break;\n+\n+                case TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE:\n+                    tabSType = \"X\";\n+                    break;\n+\n+                case TableDescriptor.SYNONYM_TYPE:\n+                    tabSType = \"A\";\n+                    break;\n+                case TableDescriptor.EXTERNAL_TYPE:\n+                    tabSType = \"E\";\n+                    break;\n+\n+\n+                default:\n+                    if (SanityManager.DEBUG)\n+                        SanityManager.THROWASSERT(\"invalid table type\");\n+            }\n+            char[] lockGChar = new char[1];\n+            lockGChar[0] = descriptor.getLockGranularity();\n+            lockGranularity = new String(lockGChar);\n+            delimited = descriptor.getDelimited();\n+            escaped = descriptor.getEscaped();\n+            lines = descriptor.getLines();\n+            storedAs = descriptor.getStoredAs();\n+            location = descriptor.getLocation();\n+            compression = descriptor.getCompression();\n+            //NOT USED ANYMORE, for backward compatibility only\n+            isPinned = descriptor.isPinned();\n             purgeDeletedRows = descriptor.purgeDeletedRows();\n-\t\t\ttableVersion = descriptor.getVersion() == null ?\n-\t\t                 \tnew SQLVarchar(CURRENT_TABLE_VERSION) :\n-\t\t\t                new SQLVarchar(descriptor.getVersion());\n-\t\t}\n-\t\telse\n-\t\t\ttableVersion = new SQLVarchar(CURRENT_TABLE_VERSION);\n-\n-\t\t/* Insert info into systables */\n-\n-\t\t/* RESOLVE - It would be nice to require less knowledge about systables\n-\t\t * and have this be more table driven.\n-\t\t */\n-\n-\t\t/* Build the row to insert  */\n-\t\trow = getExecutionFactory().getValueRow(SYSTABLES_COLUMN_COUNT);\n-\n-\t\tsetRowColumns(row, tableID, tableName, tabSType, schemaID, lockGranularity, tableVersion, columnSequence,\n-\t\t\t\tdelimited, escaped, lines, storedAs, location, compression, isPinned, purgeDeletedRows);\n-\t\treturn row;\n-\t}\n-\n-\tpublic static void setRowColumns(ExecRow row,\n-\t\t\t\t\t\t\t\t\t String tableID,\n-\t\t\t\t\t\t\t\t\t String tableName,\n-\t\t\t\t\t\t\t\t\t String tabSType,\n-\t\t\t\t\t\t\t\t\t String schemaID,\n-\t\t\t\t\t\t\t\t\t String lockGranularity,\n-\t\t\t\t\t\t\t\t\t SQLVarchar tableVersion,\n-\t\t\t\t\t\t\t\t\t int columnSequence,\n-\t\t\t\t\t\t\t\t\t String delimited,\n-\t\t\t\t\t\t\t\t\t String escaped,\n-\t\t\t\t\t\t\t\t\t String lines,\n-\t\t\t\t\t\t\t\t\t String storedAs,\n-\t\t\t\t\t\t\t\t\t String location,\n-\t\t\t\t\t\t\t\t\t String compression,\n-\t\t\t\t\t\t\t\t\t boolean isPinned,\n-\t\t\t\t\t\t\t\t\t boolean purgeDeletedRows) {\n-\t\t/* 1st column is TABLEID (UUID - char(36)) */\n-\t\trow.setColumn(SYSTABLES_TABLEID, new SQLChar(tableID));\n-\n-\t\t/* 2nd column is NAME (varchar(30)) */\n-\t\trow.setColumn(SYSTABLES_TABLENAME, new SQLVarchar(tableName));\n-\n-\t\t/* 3rd column is TABLETYPE (char(1)) */\n-\t\trow.setColumn(SYSTABLES_TABLETYPE, new SQLChar(tabSType));\n-\n-\t\t/* 4th column is SCHEMAID (UUID - char(36)) */\n-\t\trow.setColumn(SYSTABLES_SCHEMAID, new SQLChar(schemaID));\n-\n-\t\t/* 5th column is LOCKGRANULARITY (char(1)) */\n-\t\trow.setColumn(SYSTABLES_LOCKGRANULARITY, new SQLChar(lockGranularity));\n-\n-\t\t/* 6th column is VERSION (varchar(128)) */\n-\t\trow.setColumn(SYSTABLES_VERSION, tableVersion);\n-\n-\t\trow.setColumn(SYSTABLES_COLUMN_SEQUENCE, new SQLInteger(columnSequence));\n-\n-\t\trow.setColumn(SYSTABLES_DELIMITED_BY, new SQLVarchar(delimited));\n-\t\trow.setColumn(SYSTABLES_ESCAPED_BY, new SQLVarchar(escaped));\n-\t\trow.setColumn(SYSTABLES_LINES_BY, new SQLVarchar(lines));\n-\t\trow.setColumn(SYSTABLES_STORED_AS, new SQLVarchar(storedAs));\n-\t\trow.setColumn(SYSTABLES_LOCATION, new SQLVarchar(location));\n-\t\trow.setColumn(SYSTABLES_COMPRESSION, new SQLVarchar(compression));\n-\t\t//NOT USED ANYMORE, for backward compatibility only\n-\t\trow.setColumn(SYSTABLES_IS_PINNED, new SQLBoolean(isPinned));\n-\t\trow.setColumn(SYSTABLES_PURGE_DELETED_ROWS, new SQLBoolean(purgeDeletedRows));\n-\t}\n-\n-\t/**\n-\t * Builds an empty index row.\n-\t *\n-\t *\t@param\tindexNumber\tIndex to build empty row for.\n-\t *  @param  rowLocation\tRow location for last column of index row\n-\t *\n-\t * @return corresponding empty index row\n-\t * @exception   StandardException thrown on failure\n-\t */\n-\t@SuppressFBWarnings(value = \"SF_SWITCH_NO_DEFAULT\", justification = \"DB-9844\")\n-\tExecIndexRow\tbuildEmptyIndexRow( int indexNumber,\n-\t\t\t\t\t\t\t\t\t\t\tRowLocation rowLocation)\n-\t\t\tthrows StandardException\n-\t{\n-\t\tint ncols = getIndexColumnCount(indexNumber);\n-\t\tExecIndexRow row = getExecutionFactory().getIndexableRow(ncols + 1);\n-\n-\t\trow.setColumn(ncols + 1, rowLocation);\n-\n-\t\tswitch( indexNumber )\n-\t\t{\n-\t\t    case SYSTABLES_INDEX1_ID:\n-\t\t\t\t/* 1st column is TABLENAME (varchar(128)) */\n-\t\t\t\trow.setColumn(1, new SQLVarchar());\n-\n-\t\t\t\t/* 2nd column is SCHEMAID (UUID - char(36)) */\n-\t\t\t\trow.setColumn(2, new SQLChar());\n-\n-\t\t\t\tbreak;\n-\n-\t\t    case SYSTABLES_INDEX2_ID:\n-\t\t\t\t/* 1st column is TABLEID (UUID - char(36)) */\n-\t\t\t\trow.setColumn(1,new SQLChar());\n-\t\t\t\tbreak;\n-\n-\t\t\tdefault:\n-\t\t\t\tthrow new IllegalArgumentException(\"unexpected indexNumber: \" + indexNumber);\n-\t\t}\t// end switch\n-\n-\t\treturn\trow;\n-\t}\n-\n-\t/**\n-\t * Make a TableDescriptor out of a SYSTABLES row\n-\t *\n-\t * @param row a SYSTABLES row\n-\t * @param parentTupleDescriptor\tNull for this kind of descriptor.\n-\t * @param dd dataDictionary\n-\t * @param isolationLevel use this explicit isolation level. Only\n-\t *                       ISOLATION_REPEATABLE_READ (normal usage)\n-\t *                       or ISOLATION_READ_UNCOMMITTED (corner\n-\t *                       cases) supported for now.\n-\t * @exception   StandardException thrown on failure\n-\t */\n-\tTupleDescriptor buildDescriptor(\n-\t\tExecRow\t\t\t\t\trow,\n-\t\tTupleDescriptor\t\t\tparentTupleDescriptor,\n-\t\tDataDictionary \t\t\tdd,\n-\t\tint                     isolationLevel)\n-\t\t\t\t\tthrows StandardException\n-\t{\n-\t\treturn buildDescriptorBody(row,\n-\t\t\t\t\t\t\t\t   parentTupleDescriptor,\n-\t\t\t\t\t\t\t\t   dd,\n-\t\t\t\t\t\t\t\t   isolationLevel);\n-\t}\n-\n-\n-\t///////////////////////////////////////////////////////////////////////////\n-\t//\n-\t//\tABSTRACT METHODS TO BE IMPLEMENTED BY CHILDREN OF CatalogRowFactory\n-\t//\n-\t///////////////////////////////////////////////////////////////////////////\n-\n-\t/**\n-\t * Make a TableDescriptor out of a SYSTABLES row\n-\t *\n-\t * @param row a SYSTABLES row\n-\t * @param parentTupleDescriptor\tNull for this kind of descriptor.\n-\t * @param dd dataDictionary\n-\t *\n-\t * @return\ta table descriptor equivalent to a SYSTABLES row\n-\t *\n-\t * @exception   StandardException thrown on failure\n-\t */\n-\n-\tpublic TupleDescriptor buildDescriptor(\n-\t\tExecRow\t\t\t\t\trow,\n-\t\tTupleDescriptor\t\t\tparentTupleDescriptor,\n-\t\tDataDictionary \t\t\tdd )\n-\t\t\t\t\tthrows StandardException\n-\t{\n-\t\treturn buildDescriptorBody(\n-\t\t\trow,\n-\t\t\tparentTupleDescriptor,\n-\t\t\tdd,\n-\t\t\tTransactionController.ISOLATION_REPEATABLE_READ);\n-\t}\n-\n-\n-\tpublic TupleDescriptor buildDescriptorBody(\n-\t\tExecRow\t\t\t\t\trow,\n-\t\tTupleDescriptor\t\t\tparentTupleDescriptor,\n-\t\tDataDictionary \t\t\tdd,\n-\t\tint                     isolationLevel)\n-\t\t\t\t\tthrows StandardException\n-\t{\n-\t\tif (SanityManager.DEBUG)\n-\t\tSanityManager.ASSERT(row.nColumns() == SYSTABLES_COLUMN_COUNT, \"Wrong number of columns for a SYSTABLES row\");\n-\n-\t\tDataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();\n-\n-\t\tString\ttableUUIDString; \n-\t\tString\tschemaUUIDString; \n-\t\tint\t\ttableTypeEnum;\n-\t\tString\tlockGranularity;\n-\t\tString\ttableName, tableType;\n-\t\tDataValueDescriptor\tcol;\n-\t\tUUID\t\ttableUUID;\n-\t\tUUID\t\tschemaUUID;\n-\t\tSchemaDescriptor\tschema;\n-\t\tTableDescriptor\t\ttabDesc;\n-\n-\t\t/* 1st column is TABLEID (UUID - char(36)) */\n-\t\tcol = row.getColumn(SYSTABLES_TABLEID);\n-\t\ttableUUIDString = col.getString();\n-\t\ttableUUID = getUUIDFactory().recreateUUID(tableUUIDString);\n-\n-\n-\t\t/* 2nd column is TABLENAME (varchar(128)) */\n-\t\tcol = row.getColumn(SYSTABLES_TABLENAME);\n-\t\ttableName = col.getString();\n-\n-\t\t/* 3rd column is TABLETYPE (char(1)) */\n-\t\tcol = row.getColumn(SYSTABLES_TABLETYPE);\n-\t\ttableType = col.getString();\n-\t\tif (SanityManager.DEBUG)\n-\t\t{\n-\t\t\tSanityManager.ASSERT(tableType.length() == 1, \"Fourth column type incorrect\");\n-\t\t}\n-\t\tswitch (tableType.charAt(0))\n-\t\t{\n-\t\t\tcase 'T' : \n-\t\t\t\ttableTypeEnum = TableDescriptor.BASE_TABLE_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tcase 'S' :\n-\t\t\t\ttableTypeEnum = TableDescriptor.SYSTEM_TABLE_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tcase 'V' :\n-\t\t\t\ttableTypeEnum = TableDescriptor.VIEW_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tcase 'A' :\n-\t\t\t\ttableTypeEnum = TableDescriptor.SYNONYM_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tcase 'X' :\n-\t\t\t\ttableTypeEnum = TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tcase 'E' :\n-\t\t\t\ttableTypeEnum = TableDescriptor.EXTERNAL_TYPE;\n-\t\t\t\tbreak;\n-\t\t\tdefault:\n-\t\t\t\tif (SanityManager.DEBUG)\n-\t\t\t\tSanityManager.THROWASSERT(\"Fourth column value invalid\");\n-\t\t\t\ttableTypeEnum = -1;\n-\t\t}\n-\n-\t\t/* 4th column is SCHEMAID (UUID - char(36)) */\n-\t\tcol = row.getColumn(SYSTABLES_SCHEMAID);\n-\t\tschemaUUIDString = col.getString();\n-\t\tschemaUUID = getUUIDFactory().recreateUUID(schemaUUIDString);\n-\t\t\n-\t\tschema = dd.getSchemaDescriptor(schemaUUID, isolationLevel, null);\n+            minRetentionPeriod = descriptor.minRetainedPeriod();\n+            tableVersion = descriptor.getVersion() == null ?\n+                    new SQLVarchar(CURRENT_TABLE_VERSION) :\n+                    new SQLVarchar(descriptor.getVersion());\n+        } else\n+            tableVersion = new SQLVarchar(CURRENT_TABLE_VERSION);\n+\n+        /* Insert info into systables */\n+\n+        /* RESOLVE - It would be nice to require less knowledge about systables\n+         * and have this be more table driven.\n+         */\n+\n+        /* Build the row to insert  */\n+        row = getExecutionFactory().getValueRow(SYSTABLES_COLUMN_COUNT);\n+\n+        setRowColumns(row, tableID, tableName, tabSType, schemaID, lockGranularity, tableVersion, columnSequence,\n+                delimited, escaped, lines, storedAs, location, compression, isPinned, purgeDeletedRows, minRetentionPeriod);\n+        return row;\n+    }\n+\n+    public static void setRowColumns(ExecRow row,\n+                                     String tableID,\n+                                     String tableName,\n+                                     String tabSType,\n+                                     String schemaID,\n+                                     String lockGranularity,\n+                                     SQLVarchar tableVersion,\n+                                     int columnSequence,\n+                                     String delimited,\n+                                     String escaped,\n+                                     String lines,\n+                                     String storedAs,\n+                                     String location,\n+                                     String compression,\n+                                     boolean isPinned,\n+                                     boolean purgeDeletedRows,\n+                                     Long minRetentionPeriod) {\n+        /* 1st column is TABLEID (UUID - char(36)) */\n+        row.setColumn(SYSTABLES_TABLEID, new SQLChar(tableID));\n+\n+        /* 2nd column is NAME (varchar(30)) */\n+        row.setColumn(SYSTABLES_TABLENAME, new SQLVarchar(tableName));\n+\n+        /* 3rd column is TABLETYPE (char(1)) */\n+        row.setColumn(SYSTABLES_TABLETYPE, new SQLChar(tabSType));\n+\n+        /* 4th column is SCHEMAID (UUID - char(36)) */\n+        row.setColumn(SYSTABLES_SCHEMAID, new SQLChar(schemaID));\n+\n+        /* 5th column is LOCKGRANULARITY (char(1)) */\n+        row.setColumn(SYSTABLES_LOCKGRANULARITY, new SQLChar(lockGranularity));\n+\n+        /* 6th column is VERSION (varchar(128)) */\n+        row.setColumn(SYSTABLES_VERSION, tableVersion);\n+\n+        row.setColumn(SYSTABLES_COLUMN_SEQUENCE, new SQLInteger(columnSequence));\n+\n+        row.setColumn(SYSTABLES_DELIMITED_BY, new SQLVarchar(delimited));\n+        row.setColumn(SYSTABLES_ESCAPED_BY, new SQLVarchar(escaped));\n+        row.setColumn(SYSTABLES_LINES_BY, new SQLVarchar(lines));\n+        row.setColumn(SYSTABLES_STORED_AS, new SQLVarchar(storedAs));\n+        row.setColumn(SYSTABLES_LOCATION, new SQLVarchar(location));\n+        row.setColumn(SYSTABLES_COMPRESSION, new SQLVarchar(compression));\n+        //NOT USED ANYMORE, for backward compatibility only\n+        row.setColumn(SYSTABLES_IS_PINNED, new SQLBoolean(isPinned));\n+        row.setColumn(SYSTABLES_PURGE_DELETED_ROWS, new SQLBoolean(purgeDeletedRows));\n+        row.setColumn(SYSTABLES_MIN_RETENTION_PERIOD, new SQLLongint(minRetentionPeriod));\n+    }\n+\n+    /**\n+     * Builds an empty index row.\n+     *\n+     * @param rowLocation Row location for last column of index row\n+     * @return corresponding empty index row\n+     * @throws StandardException thrown on failure\n+     * @param    indexNumber    Index to build empty row for.\n+     */\n+    @SuppressFBWarnings(value = \"SF_SWITCH_NO_DEFAULT\", justification = \"DB-9844\")\n+    ExecIndexRow buildEmptyIndexRow(int indexNumber,\n+                                    RowLocation rowLocation)\n+            throws StandardException {\n+        int ncols = getIndexColumnCount(indexNumber);\n+        ExecIndexRow row = getExecutionFactory().getIndexableRow(ncols + 1);\n+\n+        row.setColumn(ncols + 1, rowLocation);\n+\n+        switch (indexNumber) {\n+            case SYSTABLES_INDEX1_ID:\n+                /* 1st column is TABLENAME (varchar(128)) */\n+                row.setColumn(1, new SQLVarchar());\n+\n+                /* 2nd column is SCHEMAID (UUID - char(36)) */\n+                row.setColumn(2, new SQLChar());\n+\n+                break;\n+\n+            case SYSTABLES_INDEX2_ID:\n+                /* 1st column is TABLEID (UUID - char(36)) */\n+                row.setColumn(1, new SQLChar());\n+                break;\n+\n+            default:\n+                throw new IllegalArgumentException(\"unexpected indexNumber: \" + indexNumber);\n+        }    // end switch\n+\n+        return row;\n+    }\n+\n+    /**\n+     * Make a TableDescriptor out of a SYSTABLES row\n+     *\n+     * @param row                   a SYSTABLES row\n+     * @param parentTupleDescriptor Null for this kind of descriptor.\n+     * @param dd                    dataDictionary\n+     * @param isolationLevel        use this explicit isolation level. Only\n+     *                              ISOLATION_REPEATABLE_READ (normal usage)\n+     *                              or ISOLATION_READ_UNCOMMITTED (corner\n+     *                              cases) supported for now.\n+     * @throws StandardException thrown on failure\n+     */\n+    TupleDescriptor buildDescriptor(\n+            ExecRow row,\n+            TupleDescriptor parentTupleDescriptor,\n+            DataDictionary dd,\n+            int isolationLevel)\n+            throws StandardException {\n+        return buildDescriptorBody(row,\n+                parentTupleDescriptor,\n+                dd,\n+                isolationLevel);\n+    }\n+\n+\n+    ///////////////////////////////////////////////////////////////////////////\n+    //\n+    //\tABSTRACT METHODS TO BE IMPLEMENTED BY CHILDREN OF CatalogRowFactory\n+    //\n+    ///////////////////////////////////////////////////////////////////////////\n+\n+    /**\n+     * Make a TableDescriptor out of a SYSTABLES row\n+     *\n+     * @param row                   a SYSTABLES row\n+     * @param parentTupleDescriptor Null for this kind of descriptor.\n+     * @param dd                    dataDictionary\n+     * @throws StandardException thrown on failure\n+     * @return a table descriptor equivalent to a SYSTABLES row\n+     */\n+\n+    public TupleDescriptor buildDescriptor(\n+            ExecRow row,\n+            TupleDescriptor parentTupleDescriptor,\n+            DataDictionary dd)\n+            throws StandardException {\n+        return buildDescriptorBody(\n+                row,\n+                parentTupleDescriptor,\n+                dd,\n+                TransactionController.ISOLATION_REPEATABLE_READ);\n+    }\n+\n+\n+    public TupleDescriptor buildDescriptorBody(\n+            ExecRow row,\n+            TupleDescriptor parentTupleDescriptor,\n+            DataDictionary dd,\n+            int isolationLevel)\n+            throws StandardException {\n+        if (SanityManager.DEBUG)\n+            SanityManager.ASSERT(row.nColumns() == SYSTABLES_COLUMN_COUNT, \"Wrong number of columns for a SYSTABLES row\");\n+\n+        DataDescriptorGenerator ddg = dd.getDataDescriptorGenerator();\n+\n+        String tableUUIDString;\n+        String schemaUUIDString;\n+        int tableTypeEnum;\n+        String lockGranularity;\n+        String tableName, tableType;\n+        DataValueDescriptor col;\n+        UUID tableUUID;\n+        UUID schemaUUID;\n+        SchemaDescriptor schema;\n+        TableDescriptor tabDesc;\n+\n+        /* 1st column is TABLEID (UUID - char(36)) */\n+        col = row.getColumn(SYSTABLES_TABLEID);\n+        tableUUIDString = col.getString();\n+        tableUUID = getUUIDFactory().recreateUUID(tableUUIDString);\n+\n+\n+        /* 2nd column is TABLENAME (varchar(128)) */\n+        col = row.getColumn(SYSTABLES_TABLENAME);\n+        tableName = col.getString();\n+\n+        /* 3rd column is TABLETYPE (char(1)) */\n+        col = row.getColumn(SYSTABLES_TABLETYPE);\n+        tableType = col.getString();\n+        if (SanityManager.DEBUG) {\n+            SanityManager.ASSERT(tableType.length() == 1, \"Fourth column type incorrect\");\n+        }\n+        switch (tableType.charAt(0)) {\n+            case 'T':\n+                tableTypeEnum = TableDescriptor.BASE_TABLE_TYPE;\n+                break;\n+            case 'S':\n+                tableTypeEnum = TableDescriptor.SYSTEM_TABLE_TYPE;\n+                break;\n+            case 'V':\n+                tableTypeEnum = TableDescriptor.VIEW_TYPE;\n+                break;\n+            case 'A':\n+                tableTypeEnum = TableDescriptor.SYNONYM_TYPE;\n+                break;\n+            case 'X':\n+                tableTypeEnum = TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE;\n+                break;\n+            case 'E':\n+                tableTypeEnum = TableDescriptor.EXTERNAL_TYPE;\n+                break;\n+            default:\n+                if (SanityManager.DEBUG)\n+                    SanityManager.THROWASSERT(\"Fourth column value invalid\");\n+                tableTypeEnum = -1;\n+        }\n+\n+        /* 4th column is SCHEMAID (UUID - char(36)) */\n+        col = row.getColumn(SYSTABLES_SCHEMAID);\n+        schemaUUIDString = col.getString();\n+        schemaUUID = getUUIDFactory().recreateUUID(schemaUUIDString);\n+\n+        schema = dd.getSchemaDescriptor(schemaUUID, isolationLevel, null);\n \n         // If table is temp table, (SESSION) schema will be null\n         if (schema == null && (tableTypeEnum == TableDescriptor.GLOBAL_TEMPORARY_TABLE_TYPE)) {\n             schema = dd.getDeclaredGlobalTemporaryTablesSchemaDescriptor();\n         }\n \n-\t\t/* 5th column is LOCKGRANULARITY (char(1)) */\n-\t\tcol = row.getColumn(SYSTABLES_LOCKGRANULARITY);\n-\t\tlockGranularity = col.getString();\n-\t\tif (SanityManager.DEBUG)\n-\t\t{\n-\t\t\tSanityManager.ASSERT(lockGranularity.length() == 1, \"Fifth column type incorrect\");\n-\t\t}\n-\n-\t\t//TODO -sf- place version into tuple descriptor\n-\t\tDataValueDescriptor versionDescriptor = row.getColumn(SYSTABLES_VERSION);\n-\n-\t\tDataValueDescriptor delimitedDVD = row.getColumn(SYSTABLES_DELIMITED_BY);\n-\t\tDataValueDescriptor escapedDVD = row.getColumn(SYSTABLES_ESCAPED_BY);\n-\t\tDataValueDescriptor linesDVD = row.getColumn(SYSTABLES_LINES_BY);\n-\t\tDataValueDescriptor storedDVD = row.getColumn(SYSTABLES_STORED_AS);\n-\t\tDataValueDescriptor locationDVD = row.getColumn(SYSTABLES_LOCATION);\n-\t\tDataValueDescriptor compressionDVD = row.getColumn(SYSTABLES_COMPRESSION);\n-\t\t// NOT USED ANYMORE, for backward compatibility only\n-\t\t@Deprecated\n-\t\tDataValueDescriptor isPinnedDVD = row.getColumn(SYSTABLES_IS_PINNED);\n-        DataValueDescriptor purgeDeletedRowsDVD = row.getColumn(SYSTABLES_PURGE_DELETED_ROWS);\n+        /* 5th column is LOCKGRANULARITY (char(1)) */\n+        col = row.getColumn(SYSTABLES_LOCKGRANULARITY);\n+        lockGranularity = col.getString();\n+        if (SanityManager.DEBUG) {\n+            SanityManager.ASSERT(lockGranularity.length() == 1, \"Fifth column type incorrect\");\n+        }\n \n-\t\t// RESOLVE - Deal with lock granularity\n-\t\ttabDesc = ddg.newTableDescriptor(tableName, schema, tableTypeEnum, lockGranularity.charAt(0),\n-\t\t\t\trow.getColumn(SYSTABLES_COLUMN_SEQUENCE).getInt(),\n-\t\t\t\tdelimitedDVD!=null?delimitedDVD.getString():null,\n-\t\t\t\tescapedDVD!=null?escapedDVD.getString():null,\n-\t\t\t\tlinesDVD!=null?linesDVD.getString():null,\n-\t\t\t\tstoredDVD!=null?storedDVD.getString():null,\n-\t\t\t\tlocationDVD!=null?locationDVD.getString():null,\n-\t\t\t\tcompressionDVD!=null?compressionDVD.getString():null,\n-\t\t\t\tisPinnedDVD.getBoolean(),\n-                purgeDeletedRowsDVD.getBoolean()\n-\t\t\t\t);\n-\t\ttabDesc.setUUID(tableUUID);\n-\n-\t\tif(versionDescriptor!=null){\n-\t\t\ttabDesc.setVersion(versionDescriptor.getString());\n-\t\t}else\n-\t\t\t\t\t\ttabDesc.setVersion(ORIGINAL_TABLE_VERSION);\n-\t\treturn tabDesc;\n-\t}\n-\n-\t/**\n-\t *\tGet the table name out of this SYSTABLES row\n-\t *\n-\t * @param row a SYSTABLES row\n-\t *\n-\t * @return\tstring, the table name\n-\t *\n-\t * @exception   StandardException thrown on failure\n-\t */\n-\tprotected String getTableName(ExecRow\trow)\n-\t\t\t\t\tthrows StandardException\n-\t{\n-\t\tDataValueDescriptor\tcol;\n-\n-\t\tcol = row.getColumn(SYSTABLES_TABLENAME);\n-\t\treturn col.getString();\n-\t}\n-\n-\n-\t/**\n-\t * builds a list of columns suitable for creating this catalog.\n-\t *\n-\t *\n-\t * @return array of systemcolumn suitable for making this catalog.\n-\t */\n-\tpublic SystemColumn[]\tbuildColumnList()\n-        throws StandardException\n-\t{\n-        return new SystemColumn[] {\n-                SystemColumnImpl.getUUIDColumn(\"TABLEID\", false),\n-                SystemColumnImpl.getIdentifierColumn(\"TABLENAME\", false),\n-                SystemColumnImpl.getIndicatorColumn(\"TABLETYPE\"),\n-                SystemColumnImpl.getUUIDColumn(\"SCHEMAID\", false),\n-                SystemColumnImpl.getIndicatorColumn(\"LOCKGRANULARITY\"),\n-                SystemColumnImpl.getIdentifierColumn(\"VERSION\",true),\n-                SystemColumnImpl.getColumn(\"COLSEQUENCE\", Types.INTEGER, false),\n-                SystemColumnImpl.getColumn(\"DELIMITED\", Types.VARCHAR,  true),\n-                SystemColumnImpl.getColumn(\"ESCAPED\", Types.VARCHAR, true),\n-                SystemColumnImpl.getColumn(\"LINES\", Types.VARCHAR, true),\n-                SystemColumnImpl.getColumn(\"STORED\", Types.VARCHAR, true),\n-                SystemColumnImpl.getColumn(\"LOCATION\", Types.VARCHAR, true),\n-                SystemColumnImpl.getColumn(\"COMPRESSION\", Types.VARCHAR, true),\n-                SystemColumnImpl.getColumn(\"IS_PINNED\", Types.BOOLEAN, false),\n+        //TODO -sf- place version into tuple descriptor\n+        DataValueDescriptor versionDescriptor = row.getColumn(SYSTABLES_VERSION);\n+\n+        DataValueDescriptor delimitedDVD = row.getColumn(SYSTABLES_DELIMITED_BY);\n+        DataValueDescriptor escapedDVD = row.getColumn(SYSTABLES_ESCAPED_BY);\n+        DataValueDescriptor linesDVD = row.getColumn(SYSTABLES_LINES_BY);\n+        DataValueDescriptor storedDVD = row.getColumn(SYSTABLES_STORED_AS);\n+        DataValueDescriptor locationDVD = row.getColumn(SYSTABLES_LOCATION);\n+        DataValueDescriptor compressionDVD = row.getColumn(SYSTABLES_COMPRESSION);\n+        // NOT USED ANYMORE, for backward compatibility only\n+        @Deprecated\n+        DataValueDescriptor isPinnedDVD = row.getColumn(SYSTABLES_IS_PINNED);\n+        DataValueDescriptor purgeDeletedRowsDVD = row.getColumn(SYSTABLES_PURGE_DELETED_ROWS);\n+        DataValueDescriptor minRetentionPeriodDVD = row.getColumn(SYSTABLES_MIN_RETENTION_PERIOD);\n+\n+        // RESOLVE - Deal with lock granularity\n+        tabDesc = ddg.newTableDescriptor(tableName, schema, tableTypeEnum, lockGranularity.charAt(0),\n+                row.getColumn(SYSTABLES_COLUMN_SEQUENCE).getInt(),\n+                delimitedDVD != null ? delimitedDVD.getString() : null,\n+                escapedDVD != null ? escapedDVD.getString() : null,\n+                linesDVD != null ? linesDVD.getString() : null,\n+                storedDVD != null ? storedDVD.getString() : null,\n+                locationDVD != null ? locationDVD.getString() : null,\n+                compressionDVD != null ? compressionDVD.getString() : null,\n+                isPinnedDVD.getBoolean(),\n+                purgeDeletedRowsDVD.getBoolean(),\n+                minRetentionPeriodDVD != null ? minRetentionPeriodDVD.getLong() : null\n+        );\n+        tabDesc.setUUID(tableUUID);\n+\n+        if (versionDescriptor != null) {\n+            tabDesc.setVersion(versionDescriptor.getString());\n+        } else\n+            tabDesc.setVersion(ORIGINAL_TABLE_VERSION);\n+        return tabDesc;\n+    }\n+\n+    /**\n+     * Get the table name out of this SYSTABLES row\n+     *\n+     * @param row a SYSTABLES row\n+     * @throws StandardException thrown on failure\n+     * @return string, the table name\n+     */\n+    protected String getTableName(ExecRow row)\n+            throws StandardException {\n+        DataValueDescriptor col;\n+\n+        col = row.getColumn(SYSTABLES_TABLENAME);\n+        return col.getString();\n+    }\n+\n+\n+    /**\n+     * builds a list of columns suitable for creating this catalog.\n+     *\n+     * @return array of systemcolumn suitable for making this catalog.\n+     */\n+    public SystemColumn[] buildColumnList()\n+            throws StandardException {\n+        return new SystemColumn[]{\n+                SystemColumnImpl.getUUIDColumn(TABLEID, false),\n+                SystemColumnImpl.getIdentifierColumn(TABLENAME, false),\n+                SystemColumnImpl.getIndicatorColumn(TABLETYPE),\n+                SystemColumnImpl.getUUIDColumn(SCHEMAID, false),\n+                SystemColumnImpl.getIndicatorColumn(LOCKGRANULARITY),\n+                SystemColumnImpl.getIdentifierColumn(VERSION, true),\n+                SystemColumnImpl.getColumn(COLSEQUENCE, Types.INTEGER, false),\n+                SystemColumnImpl.getColumn(DELIMITED, Types.VARCHAR, true),\n+                SystemColumnImpl.getColumn(ESCAPED, Types.VARCHAR, true),\n+                SystemColumnImpl.getColumn(LINES, Types.VARCHAR, true),\n+                SystemColumnImpl.getColumn(STORED, Types.VARCHAR, true),\n+                SystemColumnImpl.getColumn(LOCATION, Types.VARCHAR, true),\n+                SystemColumnImpl.getColumn(COMPRESSION, Types.VARCHAR, true),\n+                SystemColumnImpl.getColumn(IS_PINNED, Types.BOOLEAN, false),\n                 SystemColumnImpl.getColumn(PURGE_DELETED_ROWS, Types.BOOLEAN, false),\n+                SystemColumnImpl.getColumn(MIN_RETENTION_PERIOD, Types.BIGINT, true),\n         };\n-\t}\n-\n-\tpublic List<ColumnDescriptor[]> getViewColumns(TableDescriptor view, UUID viewId) throws StandardException {\n-\t\tList<ColumnDescriptor[]> cdsl = new ArrayList<>();\n-\t\tcdsl.add(\n-\t\t    new ColumnDescriptor[]{\n-\t\t\t\tnew ColumnDescriptor(\"TABLEID\",1,1,DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, false, 36),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"TABLENAME\"               ,2,2,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, false, 128),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"TABLETYPE\"               ,3,3,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, false, 1),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"SCHEMAID\"               ,4,4,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, false, 36),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"LOCKGRANULARITY\"               ,5,5,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, false, 1),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"VERSION\"               ,6,6,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, false, 128),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"COLSEQUENCE\"               ,7,7,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.INTEGER, false),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"DELIMITED\"               ,8,8,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, false),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"ESCAPED\"               ,9,9,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, false),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"LINES\"               ,10,10,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"STORED\"               ,11,11,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"LOCATION\"               ,12,12,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"COMPRESSION\"               ,13,13,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"IS_PINNED\"               ,14,14,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.BOOLEAN, false),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"PURGE_DELETED_ROWS\"               ,15,15,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.BOOLEAN, false),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0),\n-\t\t\t\tnew ColumnDescriptor(\"SCHEMANAME\"               ,16,16,\n-\t\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, false, 128),\n-\t\t\t\t\t\tnull,null,view,viewId,0,0,0)\n-\t\t});\n-\n-\t\t// add columnlist for the systables view in sysibm schema\n-\t\tCollection<Object[]> colList = Lists.newArrayListWithCapacity(66);\n-\t\tcolList.add(new Object[]{\"NAME\", Types.VARCHAR, false, 128});\n-\t\tcolList.add(new Object[]{\"CREATOR\", Types.VARCHAR, false, 128});\n-\t\tcolList.add(new Object[]{\"TYPE\", Types.CHAR, false, 1});\n-       colList.add(new Object[]{\"COLCOUNT\", Types.SMALLINT, false, null});\n+    }\n+\n+    public List<ColumnDescriptor[]> getViewColumns(TableDescriptor view, UUID viewId) throws StandardException {\n+        List<ColumnDescriptor[]> cdsl = new ArrayList<>();\n+        cdsl.add(\n+                new ColumnDescriptor[]{\n+                        new ColumnDescriptor(TABLEID, 1, 1, DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, false, 36),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(TABLENAME, 2, 2,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, false, 128),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(TABLETYPE, 3, 3,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, false, 1),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(SCHEMAID, 4, 4,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, false, 36),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(LOCKGRANULARITY, 5, 5,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.CHAR, false, 1),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(VERSION, 6, 6,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, false, 128),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(COLSEQUENCE, 7, 7,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.INTEGER, false),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(DELIMITED, 8, 8,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, false),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(ESCAPED, 9, 9,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, false),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(LINES, 10, 10,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(STORED, 11, 11,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(LOCATION, 12, 12,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(COMPRESSION, 13, 13,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.VARCHAR, true),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(IS_PINNED, 14, 14,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.BOOLEAN, false),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(PURGE_DELETED_ROWS, 15, 15,\n+                                DataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.BOOLEAN, false),\n+                                null, null, view, viewId, 0, 0, 0),\n+                        new ColumnDescriptor(MIN_RETENTION_PERIOD, 16, 16,", "originalCommit": "dd17493653ccb8ba06a1235ea8750612ba262185", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5MTkxMg==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r485491912", "bodyText": "I don't have the whole picture: does this account for time zone differences or is that not necessary?", "author": "arnaud-splice", "createdAt": "2020-09-09T10:00:57Z", "path": "hbase_sql/src/main/java/com/splicemachine/hbase/SpliceCompactionUtils.java", "diffHunk": "@@ -69,6 +73,46 @@ public static boolean forcePurgeDeletes(Store store) throws IOException {\n                 txn.commit();\n         }\n \n-        return false;\n+        return t.getDefaultValue();\n+    }\n+\n+    public static boolean forcePurgeDeletes(Store store) throws IOException {\n+        return extract(store, new TableDescriptorExtractor<Boolean>() {\n+            @Override\n+            public Boolean get(TableDescriptor td) {\n+                return td.purgeDeletedRows();\n+            }\n+            @Override\n+            public Boolean getDefaultValue() {\n+                return false;\n+            }\n+        });\n+    }\n+\n+    private static Long minRetentionPeriod(Store store) throws IOException { ;\n+        return extract(store, new TableDescriptorExtractor<Long>() {\n+            @Override\n+            public Long get(TableDescriptor td) {\n+                return td.minRetainedPeriod();\n+            }\n+            @Override\n+            public Long getDefaultValue() {\n+                return 0L;\n+            }\n+        });\n+    }\n+\n+    public static long getTxnLowWatermark(Store store) throws IOException {\n+        long lowTxnWatermark = TransactionsWatcher.getLowWatermarkTransaction();\n+        Long minRetentionPeriod = SpliceCompactionUtils.minRetentionPeriod(store);\n+        if(minRetentionPeriod == null || minRetentionPeriod == 0L) {\n+            return lowTxnWatermark;\n+        }\n+        long minRetentionTs = System.currentTimeMillis() - minRetentionPeriod * 1000;", "originalCommit": "dd17493653ccb8ba06a1235ea8750612ba262185", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1MzQzNQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r486153435", "bodyText": "I think AS OF feature is based on server-time, this follows the same logic.", "author": "hatyo", "createdAt": "2020-09-10T08:18:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5MTkxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5MjY4Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r485492686", "bodyText": "Neat!", "author": "arnaud-splice", "createdAt": "2020-09-09T10:02:18Z", "path": "hbase_sql/src/main/java/com/splicemachine/hbase/SpliceCompactionUtils.java", "diffHunk": "@@ -69,6 +73,46 @@ public static boolean forcePurgeDeletes(Store store) throws IOException {\n                 txn.commit();\n         }\n \n-        return false;\n+        return t.getDefaultValue();\n+    }\n+\n+    public static boolean forcePurgeDeletes(Store store) throws IOException {\n+        return extract(store, new TableDescriptorExtractor<Boolean>() {\n+            @Override\n+            public Boolean get(TableDescriptor td) {\n+                return td.purgeDeletedRows();\n+            }\n+            @Override\n+            public Boolean getDefaultValue() {\n+                return false;\n+            }\n+        });\n+    }\n+\n+    private static Long minRetentionPeriod(Store store) throws IOException { ;\n+        return extract(store, new TableDescriptorExtractor<Long>() {\n+            @Override\n+            public Long get(TableDescriptor td) {\n+                return td.minRetainedPeriod();\n+            }\n+            @Override\n+            public Long getDefaultValue() {\n+                return 0L;\n+            }\n+        });\n+    }", "originalCommit": "dd17493653ccb8ba06a1235ea8750612ba262185", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1MzYyNQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r486153625", "bodyText": "\ud83d\udc4d", "author": "hatyo", "createdAt": "2020-09-10T08:18:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5MjY4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5NDIwNg==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r485494206", "bodyText": "Please add documentation for this class and how we use it to smuggle the purgeConfig to SIObserver", "author": "arnaud-splice", "createdAt": "2020-09-09T10:04:52Z", "path": "hbase_sql/src/main/java/com/splicemachine/compactions/SpliceDefaultFlusher.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ *\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.compactions;\n+\n+import com.splicemachine.access.api.SConfiguration;\n+import com.splicemachine.hbase.SpliceCompactionUtils;\n+import com.splicemachine.si.impl.driver.SIDriver;\n+import com.splicemachine.si.impl.server.FlushLifeCycleTrackerWithConfig;\n+import com.splicemachine.si.impl.server.PurgeConfigBuilder;\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hadoop.hbase.monitoring.MonitoredTask;\n+import org.apache.hadoop.hbase.regionserver.DefaultStoreFlusher;\n+import org.apache.hadoop.hbase.regionserver.FlushLifeCycleTracker;\n+import org.apache.hadoop.hbase.regionserver.HStore;\n+import org.apache.hadoop.hbase.regionserver.MemStoreSnapshot;\n+import org.apache.hadoop.hbase.regionserver.throttle.ThroughputController;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+public class SpliceDefaultFlusher extends DefaultStoreFlusher {", "originalCommit": "dd17493653ccb8ba06a1235ea8750612ba262185", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5MDk4Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r486490986", "bodyText": "done.", "author": "hatyo", "createdAt": "2020-09-10T16:50:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5NDIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5NjUyNA==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r485496524", "bodyText": "Can you also add a test that makes sure that purging does/doesn't happen during flush when we specify a retention period", "author": "arnaud-splice", "createdAt": "2020-09-09T10:08:41Z", "path": "hbase_sql/src/test/java/com/splicemachine/hbase/PhysicalDeletionIT.java", "diffHunk": "@@ -84,14 +94,14 @@ public void testPhysicalDelete() throws Exception {\n         Thread.sleep(2000); // wait for commit markers to be written\n \n         try (Connection connection = ConnectionFactory.createConnection(HConfiguration.unwrapDelegate())) {\n-            methodWatcher.execute(\"CALL SYSCS_UTIL.SYSCS_FLUSH_TABLE('PHYSICALDELETIONIT','A')\");\n-            methodWatcher.execute(\"CALL SYSCS_UTIL.SET_PURGE_DELETED_ROWS('PHYSICALDELETIONIT','A',true)\");\n-            methodWatcher.execute(\"CALL SYSCS_UTIL.SYSCS_PERFORM_MAJOR_COMPACTION_ON_TABLE('PHYSICALDELETIONIT','A')\");\n+            methodWatcher.execute(\"CALL SYSCS_UTIL.SYSCS_FLUSH_TABLE('\" + SCHEMA1 + \"','A')\");\n+            methodWatcher.execute(\"CALL SYSCS_UTIL.SET_PURGE_DELETED_ROWS('\" + SCHEMA1 + \"','A',true)\");\n+            methodWatcher.execute(\"CALL SYSCS_UTIL.SYSCS_PERFORM_MAJOR_COMPACTION_ON_TABLE('\" + SCHEMA1 + \"','A')\");", "originalCommit": "dd17493653ccb8ba06a1235ea8750612ba262185", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5ODk1MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r485498950", "bodyText": "I like the fact that we don't break if the SpliceStoreFlusher isn't set, but we do risk having configurations out there that forget to set it for a long period of time. Is it possible to issue a warning as well when calling the SET_MIN_RETENTION_PERIOD system call?", "author": "arnaud-splice", "createdAt": "2020-09-09T10:13:00Z", "path": "hbase_storage/src/main/java/com/splicemachine/si/data/hbase/coprocessor/SIObserver.java", "diffHunk": "@@ -193,6 +172,29 @@ public void postCompact(ObserverContext<RegionCoprocessorEnvironment> c, Store s\n         }\n     }\n \n+    private PurgeConfig getPurgeConfig(final FlushLifeCycleTracker tracker, final SConfiguration conf) throws IOException {\n+        PurgeConfig purgeConfig;\n+        if(tracker instanceof FlushLifeCycleTrackerWithConfig) {\n+            purgeConfig = ((FlushLifeCycleTrackerWithConfig) tracker).getConfig();\n+        } else {\n+            SpliceLogUtils.warn(LOG, \"Splice store flusher is not set, as a result flush will ignore minimum retention period \" +\n+                    \"and time travel queries may return inconsistent results. To set Splice flusher review documentation and revise HBase configuration: \" +\n+                    DefaultStoreEngine.DEFAULT_STORE_FLUSHER_CLASS_KEY);\n+\n+            PurgeConfigBuilder purgeConfigBuilder = new PurgeConfigBuilder();\n+            if (conf.getOlapCompactionAutomaticallyPurgeDeletedRows()) {\n+                purgeConfigBuilder.purgeDeletesDuringFlush();\n+            } else {\n+                purgeConfigBuilder.noPurgeDeletes();\n+            }\n+            purgeConfigBuilder.transactionLowWatermark(TransactionsWatcher.getLowWatermarkTransaction());\n+            purgeConfigBuilder.purgeUpdates(conf.getOlapCompactionAutomaticallyPurgeOldUpdates());\n+            purgeConfig = purgeConfigBuilder.build();\n+        }\n+        assert purgeConfig != null;\n+        return purgeConfig;", "originalCommit": "dd17493653ccb8ba06a1235ea8750612ba262185", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAzODE3NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r488038174", "bodyText": "done.", "author": "hatyo", "createdAt": "2020-09-14T15:47:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5ODk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwNDY1Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r485504656", "bodyText": "Do we mark main tables only? Or do we have to mark indices as well?", "author": "arnaud-splice", "createdAt": "2020-09-09T10:23:48Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/utils/SpliceAdmin.java", "diffHunk": "@@ -1418,6 +1435,53 @@ public static void SET_PURGE_DELETED_ROWS (String schemaName, String tableName,\n         dd.addDescriptor(td, sd, DataDictionary.SYSTABLES_CATALOG_NUM, false, tc, false);\n     }\n \n+    /**\n+     * Sets the minimum retention period for a table, or a set of tables in a schema.\n+     *\n+     * @param schemaName Name of the schema.\n+     * @param tableName Name of the table, if NULL, then `retentionPeriod` will be set for all tables in `schema`.\n+     * @param retentionPeriod Retention period (in seconds).\n+     * @throws StandardException If table or schema does not exist.\n+     * @throws SQLException is table name or schema name is not valid.\n+     */\n+    public static void SET_MIN_RETENTION_PERIOD(String schemaName, String tableName, long retentionPeriod) throws StandardException, SQLException {\n+        // if schemaName was null => get the current schema.\n+        schemaName = EngineUtils.validateSchema(schemaName);\n+        // if tableName is null => set min. retention period for all tables in schemaName.\n+        tableName = tableName == null ? null : EngineUtils.validateTable(tableName);\n+        if(retentionPeriod < 0) {\n+            throw StandardException.newException(SQLState.LANG_INVALID_VALUE_RANGE, retentionPeriod, \"non-negative number\");\n+        }\n+\n+        LanguageConnectionContext lcc = ConnectionUtil.getCurrentLCC();\n+        TransactionController tc = lcc.getTransactionExecute();\n+        DataDictionary dd = lcc.getDataDictionary();\n+        SchemaDescriptor sd = dd.getSchemaDescriptor(schemaName, tc, true);\n+        if (sd == null) {\n+            throw StandardException.newException(SQLState.LANG_SCHEMA_DOES_NOT_EXIST, schemaName);\n+        }\n+        List<TableDescriptor> affectedTables = new ArrayList<>();\n+        if (tableName != null) {\n+            TableDescriptor td = dd.getTableDescriptor(tableName, sd, tc);\n+            if (td == null) {\n+                throw StandardException.newException(SQLState.TABLE_NOT_FOUND, tableName);\n+            }\n+            affectedTables.add(td);\n+        } else { // set for all tables in schema\n+            affectedTables.addAll(getTablesInSchema(dd, getDefaultConn(), sd.getUUID().toString()));", "originalCommit": "dd17493653ccb8ba06a1235ea8750612ba262185", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwNTA2Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r485505063", "bodyText": "Please write a test for this one", "author": "arnaud-splice", "createdAt": "2020-09-09T10:24:40Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/utils/SpliceAdmin.java", "diffHunk": "@@ -1090,6 +1090,23 @@ public static String getSqlConglomsInSchema(){\n         return sqlConglomsInSchema;\n     }\n \n+    private static final String sqlGetTablesInSchema= \"SELECT TABLEID FROM SYSVW.SYSTABLESVIEW WHERE SCHEMAID = ?\";\n+\n+    private static List<TableDescriptor> getTablesInSchema(DataDictionary dataDictionary,", "originalCommit": "dd17493653ccb8ba06a1235ea8750612ba262185", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk4NTEyOA==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r486985128", "bodyText": "done.", "author": "hatyo", "createdAt": "2020-09-11T11:32:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUwNTA2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUxMDM3OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r485510379", "bodyText": "Adding a column should follow this example:\n3cbd29d\nSee DB-9745", "author": "arnaud-splice", "createdAt": "2020-09-09T10:34:56Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/catalog/SpliceDataDictionary.java", "diffHunk": "@@ -1645,4 +1645,51 @@ public void addCatalogVersion(TransactionController tc) throws StandardException\n \n         }\n     }\n+\n+    public void addMinRetentionPeriodColumn(TransactionController tc) throws StandardException {", "originalCommit": "dd17493653ccb8ba06a1235ea8750612ba262185", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1NTQwNg==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r486155406", "bodyText": "This is an old PR that was already approved by Jun.", "author": "hatyo", "createdAt": "2020-09-10T08:21:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUxMDM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUxMTE1MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r485511151", "bodyText": "You replaced varchar with catalog in SET_PURGE_DELETED_ROWS, but not here.", "author": "arnaud-splice", "createdAt": "2020-09-09T10:36:19Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/catalog/SpliceSystemProcedures.java", "diffHunk": "@@ -1177,15 +1177,25 @@ public SpliceSystemProcedures(DataDictionary dictionary) {\n                             .build());\n \n                     Procedure purgeDeletedRows = Procedure.newBuilder().name(\"SET_PURGE_DELETED_ROWS\")\n-                            .varchar(\"schemaName\", 128)\n-                            .varchar(\"tableName\", 128)\n+                            .catalog(\"schemaName\")\n+                            .catalog(\"tableName\")\n                             .varchar(\"enable\", 5)\n                             .numOutputParams(0)\n                             .numResultSets(0)\n                             .ownerClass(SpliceAdmin.class.getCanonicalName())\n                             .build();\n                     procedures.add(purgeDeletedRows);\n \n+                    Procedure minRetentionPeriod = Procedure.newBuilder().name(\"SET_MIN_RETENTION_PERIOD\")\n+                            .varchar(\"schemaName\", 128)", "originalCommit": "dd17493653ccb8ba06a1235ea8750612ba262185", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1NTc5NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r486155795", "bodyText": "It is not a big deal since catalog is aliasing varchar(128) type. I will fix it anyway, thanks for spotting it!", "author": "hatyo", "createdAt": "2020-09-10T08:22:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUxMTE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc1MzUzNw==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r485753537", "bodyText": "This method has some overhead, and we'd be using it to extract the purgeDeletedRows flag and the minRetentionPeriod, calling it twice per compaction/flush. Could we call it only once and get the two parameters at once?", "author": "dgomezferro", "createdAt": "2020-09-09T16:31:03Z", "path": "hbase_sql/src/main/java/com/splicemachine/hbase/SpliceCompactionUtils.java", "diffHunk": "@@ -31,8 +31,12 @@\n  */\n public class SpliceCompactionUtils {\n \n-    public static boolean forcePurgeDeletes(Store store) throws IOException {\n+    private interface TableDescriptorExtractor<T> {\n+        T get(TableDescriptor td);\n+        T getDefaultValue();\n+    }\n \n+    private static <T> T extract(Store store, TableDescriptorExtractor<T> t) throws IOException {", "originalCommit": "dd17493653ccb8ba06a1235ea8750612ba262185", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAxMzQwMQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r488013401", "bodyText": "Yes, that makes sense, but requires some refactoring, if it is ok, I will do it in a separate JIRA.", "author": "hatyo", "createdAt": "2020-09-14T15:15:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc1MzUzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU1MzQ5NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r489553495", "bodyText": "I created a JIRA ticket to track the comment.", "author": "hatyo", "createdAt": "2020-09-16T16:03:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTc1MzUzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgxNDgyMQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r485814821", "bodyText": "Does it make sense to set a default retention period for all system tables of several days or a week?", "author": "dgomezferro", "createdAt": "2020-09-09T18:04:48Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/catalog/upgrade/UpgradeScriptToAddMinRetentionPeriodColumnToSYSTABLES.java", "diffHunk": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ *\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.derby.impl.sql.catalog.upgrade;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.store.access.TransactionController;\n+import com.splicemachine.derby.impl.sql.catalog.SpliceDataDictionary;\n+import com.splicemachine.utils.SpliceLogUtils;\n+\n+public class UpgradeScriptToAddMinRetentionPeriodColumnToSYSTABLES extends UpgradeScriptBase {\n+    public UpgradeScriptToAddMinRetentionPeriodColumnToSYSTABLES(SpliceDataDictionary sdd, TransactionController tc) {\n+        super(sdd, tc);\n+    }\n+\n+    @Override\n+    protected void upgradeSystemTables() throws StandardException {\n+        SpliceLogUtils.info(LOG, \"Adding minRetentionPeriod column to system table SYSTABLES and updating SYSTABLESVIEW\");\n+        sdd.addMinRetentionPeriodColumn(tc);", "originalCommit": "dd17493653ccb8ba06a1235ea8750612ba262185", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAxMzE2MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r488013160", "bodyText": "done.", "author": "hatyo", "createdAt": "2020-09-14T15:15:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTgxNDgyMQ=="}], "type": "inlineReview"}, {"oid": "2f9301a293e77bf200ed01b410950a217416734e", "url": "https://github.com/splicemachine/spliceengine/commit/2f9301a293e77bf200ed01b410950a217416734e", "message": "DB-10084 WIP.", "committedDate": "2020-09-10T12:23:35Z", "type": "commit"}, {"oid": "a29fb0ce25433b46af4134a8711d4db5b6849c79", "url": "https://github.com/splicemachine/spliceengine/commit/a29fb0ce25433b46af4134a8711d4db5b6849c79", "message": "DB-10084 flush/compaction are aware of minRetentionPeriod.", "committedDate": "2020-09-10T12:23:35Z", "type": "commit"}, {"oid": "3f8fa905f17418188309ae407c6520a4b2008537", "url": "https://github.com/splicemachine/spliceengine/commit/3f8fa905f17418188309ae407c6520a4b2008537", "message": "DB-10084 Add default flusher to known places.", "committedDate": "2020-09-10T12:23:35Z", "type": "commit"}, {"oid": "2d6e6f14c3729d3b742bc9866289757e7791b62a", "url": "https://github.com/splicemachine/spliceengine/commit/2d6e6f14c3729d3b742bc9866289757e7791b62a", "message": "DB-10084 tolerate having Splice flusher not set properly.", "committedDate": "2020-09-10T12:23:35Z", "type": "commit"}, {"oid": "4c8dd1d46c8174a1652b736783bd758522fc2cb4", "url": "https://github.com/splicemachine/spliceengine/commit/4c8dd1d46c8174a1652b736783bd758522fc2cb4", "message": "DB-10084 address comments.", "committedDate": "2020-09-11T12:17:05Z", "type": "commit"}, {"oid": "5fac4f1f5417084bf5034bef2a0d36e08339fdb8", "url": "https://github.com/splicemachine/spliceengine/commit/5fac4f1f5417084bf5034bef2a0d36e08339fdb8", "message": "DB-10084 address comments.", "committedDate": "2020-09-14T14:25:52Z", "type": "commit"}, {"oid": "5fac4f1f5417084bf5034bef2a0d36e08339fdb8", "url": "https://github.com/splicemachine/spliceengine/commit/5fac4f1f5417084bf5034bef2a0d36e08339fdb8", "message": "DB-10084 address comments.", "committedDate": "2020-09-14T14:25:52Z", "type": "forcePushed"}, {"oid": "028751068fc4e7ab01d8b79e7b3fde2f51f95429", "url": "https://github.com/splicemachine/spliceengine/commit/028751068fc4e7ab01d8b79e7b3fde2f51f95429", "message": "Merge remote-tracking branch 'origin/master' into DB-10084", "committedDate": "2020-09-14T16:10:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA1NDA3Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r488054072", "bodyText": "I think we should be conservative here and when this is not set, we shouldn't do any purging during flush.", "author": "dgomezferro", "createdAt": "2020-09-14T16:10:48Z", "path": "hbase_storage/src/main/java/com/splicemachine/si/data/hbase/coprocessor/SIObserver.java", "diffHunk": "@@ -193,6 +172,29 @@ public void postCompact(ObserverContext<RegionCoprocessorEnvironment> c, Store s\n         }\n     }\n \n+    private PurgeConfig getPurgeConfig(final FlushLifeCycleTracker tracker, final SConfiguration conf) throws IOException {\n+        PurgeConfig purgeConfig;\n+        if(tracker instanceof FlushLifeCycleTrackerWithConfig) {\n+            purgeConfig = ((FlushLifeCycleTrackerWithConfig) tracker).getConfig();\n+        } else {\n+            SpliceLogUtils.warn(LOG, \"Splice store flusher is not set, as a result flush will ignore minimum retention period \" +", "originalCommit": "5fac4f1f5417084bf5034bef2a0d36e08339fdb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA5NDk1NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r488094955", "bodyText": "That's definitely much better. I will still issue a warning that purge during flush will not take place and the configuration should be fixed.\nThanks!", "author": "hatyo", "createdAt": "2020-09-14T17:14:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODA1NDA3Mg=="}], "type": "inlineReview"}, {"oid": "3958379e4841b66c79a06d419f93c09fdc15ae1d", "url": "https://github.com/splicemachine/spliceengine/commit/3958379e4841b66c79a06d419f93c09fdc15ae1d", "message": "DB-10084 address further comments.", "committedDate": "2020-09-14T17:46:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU4MjkyOA==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r489582928", "bodyText": "This is testing that flush or major compaction is keeping / purging data.\nIt would be nice to test compaction and flush separately, since we have different code paths for those.", "author": "arnaud-splice", "createdAt": "2020-09-16T16:52:11Z", "path": "hbase_sql/src/test/java/com/splicemachine/hbase/PhysicalDeletionIT.java", "diffHunk": "@@ -171,4 +154,39 @@ public void testSettingMinRetentionPeriodToInvalidMinRetentionPeriodThrows() thr\n             Assert.assertEquals(\"'-400' is not in the valid range 'non-negative number'.\", e.getMessage());\n         }\n     }\n+\n+    private void shouldContainAfterPurge(String table, int numCells, boolean forcePurge) throws Exception {\n+        TestConnection conn = classWatcher.getOrCreateConnection();\n+        try (Connection connection = ConnectionFactory.createConnection(HConfiguration.unwrapDelegate())) {\n+            methodWatcher.execute(String.format(\"CALL SYSCS_UTIL.SYSCS_FLUSH_TABLE('%s', '%s')\", PhysicalDeletionIT.SCHEMA1, table));\n+            methodWatcher.execute(String.format(\"CALL SYSCS_UTIL.SET_PURGE_DELETED_ROWS('%s', '%s', %b)\", PhysicalDeletionIT.SCHEMA1, table, forcePurge));\n+            methodWatcher.execute(String.format(\"CALL SYSCS_UTIL.SYSCS_PERFORM_MAJOR_COMPACTION_ON_TABLE('%s', '%s')\", PhysicalDeletionIT.SCHEMA1, table));\n+            Scan s = new Scan();\n+            long[] conglomId = SpliceAdmin.getConglomNumbers(conn, PhysicalDeletionIT.SCHEMA1, table);\n+            TableName hTableName = TableName.valueOf(\"splice:\" + conglomId[0]);\n+            Table t = connection.getTable(hTableName);\n+            ResultScanner scanner = t.getScanner(s);\n+            int count = 0;\n+            for (Result rr = scanner.next(); rr != null; rr = scanner.next()) {\n+                count++;\n+            }\n+            Assert.assertEquals(numCells, count);\n+        }\n+    }\n+\n+    @Test\n+    public void testMinRetentionPeriodKeepsHistory() throws Exception {\n+        methodWatcher.execute(String.format(\"CALL SYSCS_UTIL.SET_MIN_RETENTION_PERIOD('%s','%s', 3600)\", SCHEMA1, MRP31));\n+        // add some data\n+        methodWatcher.executeUpdate(String.format(\"INSERT INTO %s.%s VALUES (1),(2),(3),(4),(5),(6),(7)\", SCHEMA1, MRP31));\n+        methodWatcher.executeUpdate(String.format(\"DELETE FROM %s.%s\", SCHEMA1, MRP31));\n+        methodWatcher.executeUpdate(String.format(\"INSERT INTO %s.%s VALUES (10),(20)\", SCHEMA1, MRP31));\n+        Thread.sleep(2000); // wait for commit markers to be written\n+        shouldContainAfterPurge(MRP31, 9, false);\n+        methodWatcher.execute(String.format(\"CALL SYSCS_UTIL.SET_MIN_RETENTION_PERIOD('%s','%s', 0)\", SCHEMA1, MRP31));\n+        SConfiguration config = HConfiguration.getConfiguration();\n+        long updateInterval = config.getTransactionsWatcherUpdateInterval();\n+        Thread.sleep(updateInterval * 1000 + 1000);\n+        shouldContainAfterPurge(MRP31, 2, false);", "originalCommit": "3958379e4841b66c79a06d419f93c09fdc15ae1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc4NDk4OA==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r489784988", "bodyText": "Let's discuss this again.", "author": "hatyo", "createdAt": "2020-09-16T22:17:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU4MjkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU4NTc5NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r489585795", "bodyText": "This warning could/should be display in sqlshell.\nOn top of that, we could add an extra warning if the hbase class is not set to SpliceDefaultFlusher", "author": "arnaud-splice", "createdAt": "2020-09-16T16:57:07Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/utils/SpliceAdmin.java", "diffHunk": "@@ -1476,7 +1479,11 @@ public static void SET_MIN_RETENTION_PERIOD(String schemaName, String tableName,\n             DependencyManager dm = dd.getDependencyManager();\n             dm.invalidateFor(td, DependencyManager.ALTER_TABLE, lcc);\n             tc.prepareDataDictionaryChange(DDLUtils.notifyMetadataChange(ddlChange));\n-            td.setMinRetainedVersions(retentionPeriod);\n+            if(td.purgeDeletedRows()) {", "originalCommit": "3958379e4841b66c79a06d419f93c09fdc15ae1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc4NjQ4MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4070#discussion_r489786481", "bodyText": "we could add an extra warning if the hbase class is not set to SpliceDefaultFlusher\n\ncreated a JIRA ticket for that.", "author": "hatyo", "createdAt": "2020-09-16T22:21:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU4NTc5NQ=="}], "type": "inlineReview"}]}