{"pr_number": 3163, "pr_title": "DB-9079 Support CURRENT SERVER", "pr_createdAt": "2020-01-28T01:06:04Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/3163", "timeline": [{"oid": "1e8496fec1935243346d1fecde3fd33ee5ed241b", "url": "https://github.com/splicemachine/spliceengine/commit/1e8496fec1935243346d1fecde3fd33ee5ed241b", "message": "DB-9079 Support CURRENT SERVER", "committedDate": "2020-01-28T01:04:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY3OTcxNw==", "url": "https://github.com/splicemachine/spliceengine/pull/3163#discussion_r371679717", "bodyText": "You can use \"try-with-resources\" to ensure resultsets get closed:\ntry(ResultSet rs = methodWatcher.executeQuery(sqlText)) {\nassertEquals(\"\\n\" + sqlText + \"\\n\", expected, TestUtils.FormattedResult.ResultFactory.toString(rs));\n}", "author": "dgomezferro", "createdAt": "2020-01-28T09:10:18Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/FunctionIT.java", "diffHunk": "@@ -99,149 +99,164 @@ public void testSinFunction() throws Exception{\n         Assert.assertTrue(\"Incorrect rows returned!\",rows>0);\n     }\n \n-\t/**\n-\t * Tests the ROUND function which rounds the input value to the nearest whole LONG\n-\t * <p>\n-\t * If the input value is NULL, the result of this function is NULL. If the\n-\t * input value is equal to a mathematical integer, the result of this\n-\t * function is the same as the input number. If the input value is zero (0),\n-\t * the result of this function is zero.\n-\t * <p>\n-\t * The returned value is the closest (closest to positive infinity) long\n-\t * value to the input value. The\n-\t * returned value is equal to a mathematical long. The data type of the\n-\t *\n-\t * @throws Exception\n-\t */\n-\t@Test\n-\tpublic void testRound() throws Exception {\n-\t\tResultSet rs;\n-\t\t//testing round to Long\n- \t\tfor(double val : roundVals){\n-\t\t\trs = methodWatcher.executeQuery(\"values ROUND(\"+val+\")\");\n-\t\t\tAssert.assertTrue(rs.next());\n-\t\t\tAssert.assertEquals(Math.round(val),rs.getLong(1));\n-\t\t}\n-\t}\n+    /**\n+     * Tests the ROUND function which rounds the input value to the nearest whole LONG\n+     * <p>\n+     * If the input value is NULL, the result of this function is NULL. If the\n+     * input value is equal to a mathematical integer, the result of this\n+     * function is the same as the input number. If the input value is zero (0),\n+     * the result of this function is zero.\n+     * <p>\n+     * The returned value is the closest (closest to positive infinity) long\n+     * value to the input value. The\n+     * returned value is equal to a mathematical long. The data type of the\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRound() throws Exception {\n+        ResultSet rs;\n+        //testing round to Long\n+         for(double val : roundVals){\n+            rs = methodWatcher.executeQuery(\"values ROUND(\"+val+\")\");\n+            Assert.assertTrue(rs.next());\n+            Assert.assertEquals(Math.round(val),rs.getLong(1));\n+        }\n+    }\n \n-\t@Test\n-\tpublic void testRoundEdgeCase() throws Exception{\n-\t\tResultSet rs = methodWatcher.executeQuery(\"values ROUND(null)\");\n-\t\tAssert.assertTrue(rs.next());\n-\t\tAssert.assertEquals(null,rs.getObject(1));\n-\n-\t\trs = methodWatcher.executeQuery(\"values ROUND(0)\");\n-\t\tAssert.assertTrue(rs.next());\n-\t\tAssert.assertEquals(0, rs.getDouble(1), 0.0);\n-\t}\n+    @Test\n+    public void testRoundEdgeCase() throws Exception{\n+        ResultSet rs = methodWatcher.executeQuery(\"values ROUND(null)\");\n+        Assert.assertTrue(rs.next());\n+        Assert.assertEquals(null,rs.getObject(1));\n \n-\t/**\n-\t * This tests the ROUND function when the user inputs 2 parameters, where the second is the number of decimal places to round to\n-\t * @returns double rounded to the given number of decimal places\n-\t * @throws Exception\n-\t */\n-\t@Test\n-\tpublic void testRoundVaryScale() throws Exception{\n-\t\tResultSet rs;\n-\t\tdouble longNumber = 1347593487534897908346789398700763453456786.9082847283940982746172849098273647589099;\n-\t\t//testing round to Long\n-\t\tfor(int i = -40; i < 40; i++){\n-\t\t\trs = methodWatcher.executeQuery(\"values ROUND(\"+longNumber+\",\"+i+\")\");\n-\t\t\tAssert.assertTrue(rs.next());\n-\t\t\tdouble mult = i < 18 ? i : 18;\n-\t\t\tmult = Math.pow(10,mult);\n-\t\t\tdouble x = Math.round(longNumber*mult)/(mult*1.0);\n-\t\t\tAssert.assertEquals(x,rs.getDouble(1),0.0);\n-\t\t}\n-\t}\n+        rs = methodWatcher.executeQuery(\"values ROUND(0)\");\n+        Assert.assertTrue(rs.next());\n+        Assert.assertEquals(0, rs.getDouble(1), 0.0);\n+    }\n \n-\t    /**\n-\t      * If more than one of the arguments passed to COALESCE are untyped\n-\t      * parameter markers, compilation used to fail with a NullPointerException.\n-\t      * Fixed in DERBY-6273.\n-\t      */\n-\t\t@Test\n-\tpublic void testMultipleUntypedParametersAndNVL() throws Exception {\n-\t\t// All parameters cannot be untyped. This should still fail.\n-\t\ttry {\n-\t\t\tmethodWatcher.prepareStatement(\"values coalesce(?,?,?)\");\n-\t\t} catch (SQLException se) {\n-\t\t\tAssert.assertEquals(\"Invalid sql state!\", ErrorState.LANG_DB2_COALESCE_FUNCTION_ALL_PARAMS.getSqlState(),se.getSQLState());\n-\t\t}\n-\t\t// But as long as we know the type of one parameter, it should be\n-\t\t// possible to have multiple parameters whose types are determined\n-\t\t// from the context. These queries used to raise NullPointerException\n-\t\t// before DERBY-6273.\n-\t\tvetThreeArgCoalesce(\"values coalesce(cast(? as char(1)), ?, ?)\");\n-\t\tvetThreeArgCoalesce(\"values coalesce(?, cast(? as char(1)), ?)\");\n-\t\tvetThreeArgCoalesce(\"values coalesce(?, ?, cast(? as char(1)))\");\n-\t\tvetThreeArgCoalesce(\"values nvl(cast(? as char(1)), ?, ?)\");\n-\t\tvetThreeArgCoalesce(\"values nvl(?, cast(? as char(1)), ?)\");\n-\t\tvetThreeArgCoalesce(\"values nvl(?, ?, cast(? as char(1)))\");\n+    /**\n+     * This tests the ROUND function when the user inputs 2 parameters, where the second is the number of decimal places to round to\n+     * @returns double rounded to the given number of decimal places\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRoundVaryScale() throws Exception{\n+        ResultSet rs;\n+        double longNumber = 1347593487534897908346789398700763453456786.9082847283940982746172849098273647589099;\n+        //testing round to Long\n+        for(int i = -40; i < 40; i++){\n+            rs = methodWatcher.executeQuery(\"values ROUND(\"+longNumber+\",\"+i+\")\");\n+            Assert.assertTrue(rs.next());\n+            double mult = i < 18 ? i : 18;\n+            mult = Math.pow(10,mult);\n+            double x = Math.round(longNumber*mult)/(mult*1.0);\n+            Assert.assertEquals(x,rs.getDouble(1),0.0);\n+        }\n+    }\n \n-\t}\n+        /**\n+          * If more than one of the arguments passed to COALESCE are untyped\n+          * parameter markers, compilation used to fail with a NullPointerException.\n+          * Fixed in DERBY-6273.\n+          */\n+        @Test\n+    public void testMultipleUntypedParametersAndNVL() throws Exception {\n+        // All parameters cannot be untyped. This should still fail.\n+        try {\n+            methodWatcher.prepareStatement(\"values coalesce(?,?,?)\");\n+        } catch (SQLException se) {\n+            Assert.assertEquals(\"Invalid sql state!\", ErrorState.LANG_DB2_COALESCE_FUNCTION_ALL_PARAMS.getSqlState(),se.getSQLState());\n+        }\n+        // But as long as we know the type of one parameter, it should be\n+        // possible to have multiple parameters whose types are determined\n+        // from the context. These queries used to raise NullPointerException\n+        // before DERBY-6273.\n+        vetThreeArgCoalesce(\"values coalesce(cast(? as char(1)), ?, ?)\");\n+        vetThreeArgCoalesce(\"values coalesce(?, cast(? as char(1)), ?)\");\n+        vetThreeArgCoalesce(\"values coalesce(?, ?, cast(? as char(1)))\");\n+        vetThreeArgCoalesce(\"values nvl(cast(? as char(1)), ?, ?)\");\n+        vetThreeArgCoalesce(\"values nvl(?, cast(? as char(1)), ?)\");\n+        vetThreeArgCoalesce(\"values nvl(?, ?, cast(? as char(1)))\");\n \n-\t@Test\n-\tpublic void testCallToSystemFunctionFromUserWithoutDefaultSchema() throws Exception {\n-\t\tTestConnection user1Conn = spliceClassWatcher.createConnection(USER1, PASSWORD1);\n-\n-\t\tPreparedStatement ps = user1Conn.prepareStatement(\"VALUES rand(10)\");\n-\t\tResultSet rs = ps.executeQuery();\n-\t\tint count = 0;\n-\t\twhile (rs.next()) {\n-\t\t\tcount++;\n-\t\t}\n-\t\tAssert.assertEquals(1, count);\n-\t\trs.close();\n-\n-\n-\t\tps = user1Conn.prepareStatement(\"VALUES random()\");\n-\t\trs = ps.executeQuery();\n-\t\tcount = 0;\n-\t\twhile (rs.next()) {\n-\t\t\tcount++;\n-\t\t}\n-\t\tAssert.assertEquals(1, count);\n-\t\trs.close();\n+    }\n \n-\t}\n+    @Test\n+    public void testCallToSystemFunctionFromUserWithoutDefaultSchema() throws Exception {\n+        TestConnection user1Conn = spliceClassWatcher.createConnection(USER1, PASSWORD1);\n+\n+        PreparedStatement ps = user1Conn.prepareStatement(\"VALUES rand(10)\");\n+        ResultSet rs = ps.executeQuery();\n+        int count = 0;\n+        while (rs.next()) {\n+            count++;\n+        }\n+        Assert.assertEquals(1, count);\n+        rs.close();\n+\n+\n+        ps = user1Conn.prepareStatement(\"VALUES random()\");\n+        rs = ps.executeQuery();\n+        count = 0;\n+        while (rs.next()) {\n+            count++;\n+        }\n+        Assert.assertEquals(1, count);\n+        rs.close();\n+\n+    }\n+\n+    @Test\n+    public void testNvlWithDecimalZero() throws Exception {\n+        String sqlText = format(\"select sum(val_no_null)\\n\" +\n+                \"from (select nvl(col, 0) as val_no_null from %1$s.B) dt, %1$s.A --splice-properties useSpark=true\", FunctionIT.class.getSimpleName());\n+\n+        String expected = \"1   |\\n\" +\n+                \"--------\\n\" +\n+                \"2.0000 |\";\n+        ResultSet rs = methodWatcher.executeQuery(sqlText);\n+        assertEquals(\"\\n\" + sqlText + \"\\n\", expected, TestUtils.FormattedResult.ResultFactory.toString(rs));\n+    }\n+\n+        private void vetThreeArgCoalesce(String sql) throws Exception {\n+        // First three values in each row are arguments to COALESCE. The\n+                // last value is the expected return value.\n+                        String[][] data = {\n+                    {\"a\",  \"b\",  \"c\",  \"a\"},\n+                    {null, \"b\",  \"c\",  \"b\"},\n+                    {\"a\",  null, \"c\",  \"a\"},\n+                    {\"a\",  \"b\",  null, \"a\"},\n+                    {null, null, \"c\",  \"c\"},\n+                    {\"a\",  null, null, \"a\"},\n+                    {null, \"b\",  null, \"b\"},\n+                    {null, null, null, null},\n+                };\n+            PreparedStatement ps = methodWatcher.prepareStatement(sql);\n+            for (int i = 0; i < data.length; i++) {\n+                ps.setString(1, data[i][0]);\n+                ps.setString(2, data[i][1]);\n+                ps.setString(3, data[i][2]);\n+                ResultSet rs = ps.executeQuery();\n+                Assert.assertTrue(rs.next());\n+                Assert.assertEquals(\"Values do not match\",rs.getString(1),data[i][3]);\n+                Assert.assertFalse(rs.next());\n+            }\n+    }\n \n \t@Test\n-\tpublic void testNvlWithDecimalZero() throws Exception {\n-\t\tString sqlText = format(\"select sum(val_no_null)\\n\" +\n-\t\t\t\t\"from (select nvl(col, 0) as val_no_null from %1$s.B) dt, %1$s.A --splice-properties useSpark=true\", FunctionIT.class.getSimpleName());\n-\n-\t\tString expected = \"1   |\\n\" +\n-\t\t\t\t\"--------\\n\" +\n-\t\t\t\t\"2.0000 |\";\n-\t\tResultSet rs = methodWatcher.executeQuery(sqlText);\n-\t\tassertEquals(\"\\n\" + sqlText + \"\\n\", expected, TestUtils.FormattedResult.ResultFactory.toString(rs));\n-\t}\n+\tpublic void testCurrentServer() throws Exception {\n+        String sqlText = \"values current server\";\n+        String sqlTextAlt = \"values current_server\";\n+        String expected = \"1    |\\n\" +\n+                \"----------\\n\" +\n+                \"splicedb |\";\n \n-\t\tprivate void vetThreeArgCoalesce(String sql) throws Exception {\n-\t\t// First three values in each row are arguments to COALESCE. The\n-\t\t\t\t// last value is the expected return value.\n-\t\t\t\t\t\tString[][] data = {\n-\t\t\t\t\t{\"a\",  \"b\",  \"c\",  \"a\"},\n-\t\t\t\t\t{null, \"b\",  \"c\",  \"b\"},\n-\t\t\t\t\t{\"a\",  null, \"c\",  \"a\"},\n-\t\t\t\t\t{\"a\",  \"b\",  null, \"a\"},\n-\t\t\t\t\t{null, null, \"c\",  \"c\"},\n-\t\t\t\t\t{\"a\",  null, null, \"a\"},\n-\t\t\t\t\t{null, \"b\",  null, \"b\"},\n-\t\t\t\t\t{null, null, null, null},\n-\t\t\t\t};\n-\t\t\tPreparedStatement ps = methodWatcher.prepareStatement(sql);\n-\t\t\tfor (int i = 0; i < data.length; i++) {\n-\t\t\t\tps.setString(1, data[i][0]);\n-\t\t\t\tps.setString(2, data[i][1]);\n-\t\t\t\tps.setString(3, data[i][2]);\n-\t\t\t\tResultSet rs = ps.executeQuery();\n-\t\t\t\tAssert.assertTrue(rs.next());\n-\t\t\t\tAssert.assertEquals(\"Values do not match\",rs.getString(1),data[i][3]);\n-\t\t\t\tAssert.assertFalse(rs.next());\n-\t\t\t}\n-\t}\n+        ResultSet rs = methodWatcher.executeQuery(sqlText);", "originalCommit": "1e8496fec1935243346d1fecde3fd33ee5ed241b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc1NDA1NA==", "url": "https://github.com/splicemachine/spliceengine/pull/3163#discussion_r371754054", "bodyText": "Done", "author": "arnaud-splice", "createdAt": "2020-01-28T11:44:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY3OTcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY3OTgwMg==", "url": "https://github.com/splicemachine/spliceengine/pull/3163#discussion_r371679802", "bodyText": "close this rs", "author": "dgomezferro", "createdAt": "2020-01-28T09:10:29Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/FunctionIT.java", "diffHunk": "@@ -99,149 +99,164 @@ public void testSinFunction() throws Exception{\n         Assert.assertTrue(\"Incorrect rows returned!\",rows>0);\n     }\n \n-\t/**\n-\t * Tests the ROUND function which rounds the input value to the nearest whole LONG\n-\t * <p>\n-\t * If the input value is NULL, the result of this function is NULL. If the\n-\t * input value is equal to a mathematical integer, the result of this\n-\t * function is the same as the input number. If the input value is zero (0),\n-\t * the result of this function is zero.\n-\t * <p>\n-\t * The returned value is the closest (closest to positive infinity) long\n-\t * value to the input value. The\n-\t * returned value is equal to a mathematical long. The data type of the\n-\t *\n-\t * @throws Exception\n-\t */\n-\t@Test\n-\tpublic void testRound() throws Exception {\n-\t\tResultSet rs;\n-\t\t//testing round to Long\n- \t\tfor(double val : roundVals){\n-\t\t\trs = methodWatcher.executeQuery(\"values ROUND(\"+val+\")\");\n-\t\t\tAssert.assertTrue(rs.next());\n-\t\t\tAssert.assertEquals(Math.round(val),rs.getLong(1));\n-\t\t}\n-\t}\n+    /**\n+     * Tests the ROUND function which rounds the input value to the nearest whole LONG\n+     * <p>\n+     * If the input value is NULL, the result of this function is NULL. If the\n+     * input value is equal to a mathematical integer, the result of this\n+     * function is the same as the input number. If the input value is zero (0),\n+     * the result of this function is zero.\n+     * <p>\n+     * The returned value is the closest (closest to positive infinity) long\n+     * value to the input value. The\n+     * returned value is equal to a mathematical long. The data type of the\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRound() throws Exception {\n+        ResultSet rs;\n+        //testing round to Long\n+         for(double val : roundVals){\n+            rs = methodWatcher.executeQuery(\"values ROUND(\"+val+\")\");\n+            Assert.assertTrue(rs.next());\n+            Assert.assertEquals(Math.round(val),rs.getLong(1));\n+        }\n+    }\n \n-\t@Test\n-\tpublic void testRoundEdgeCase() throws Exception{\n-\t\tResultSet rs = methodWatcher.executeQuery(\"values ROUND(null)\");\n-\t\tAssert.assertTrue(rs.next());\n-\t\tAssert.assertEquals(null,rs.getObject(1));\n-\n-\t\trs = methodWatcher.executeQuery(\"values ROUND(0)\");\n-\t\tAssert.assertTrue(rs.next());\n-\t\tAssert.assertEquals(0, rs.getDouble(1), 0.0);\n-\t}\n+    @Test\n+    public void testRoundEdgeCase() throws Exception{\n+        ResultSet rs = methodWatcher.executeQuery(\"values ROUND(null)\");\n+        Assert.assertTrue(rs.next());\n+        Assert.assertEquals(null,rs.getObject(1));\n \n-\t/**\n-\t * This tests the ROUND function when the user inputs 2 parameters, where the second is the number of decimal places to round to\n-\t * @returns double rounded to the given number of decimal places\n-\t * @throws Exception\n-\t */\n-\t@Test\n-\tpublic void testRoundVaryScale() throws Exception{\n-\t\tResultSet rs;\n-\t\tdouble longNumber = 1347593487534897908346789398700763453456786.9082847283940982746172849098273647589099;\n-\t\t//testing round to Long\n-\t\tfor(int i = -40; i < 40; i++){\n-\t\t\trs = methodWatcher.executeQuery(\"values ROUND(\"+longNumber+\",\"+i+\")\");\n-\t\t\tAssert.assertTrue(rs.next());\n-\t\t\tdouble mult = i < 18 ? i : 18;\n-\t\t\tmult = Math.pow(10,mult);\n-\t\t\tdouble x = Math.round(longNumber*mult)/(mult*1.0);\n-\t\t\tAssert.assertEquals(x,rs.getDouble(1),0.0);\n-\t\t}\n-\t}\n+        rs = methodWatcher.executeQuery(\"values ROUND(0)\");\n+        Assert.assertTrue(rs.next());\n+        Assert.assertEquals(0, rs.getDouble(1), 0.0);\n+    }\n \n-\t    /**\n-\t      * If more than one of the arguments passed to COALESCE are untyped\n-\t      * parameter markers, compilation used to fail with a NullPointerException.\n-\t      * Fixed in DERBY-6273.\n-\t      */\n-\t\t@Test\n-\tpublic void testMultipleUntypedParametersAndNVL() throws Exception {\n-\t\t// All parameters cannot be untyped. This should still fail.\n-\t\ttry {\n-\t\t\tmethodWatcher.prepareStatement(\"values coalesce(?,?,?)\");\n-\t\t} catch (SQLException se) {\n-\t\t\tAssert.assertEquals(\"Invalid sql state!\", ErrorState.LANG_DB2_COALESCE_FUNCTION_ALL_PARAMS.getSqlState(),se.getSQLState());\n-\t\t}\n-\t\t// But as long as we know the type of one parameter, it should be\n-\t\t// possible to have multiple parameters whose types are determined\n-\t\t// from the context. These queries used to raise NullPointerException\n-\t\t// before DERBY-6273.\n-\t\tvetThreeArgCoalesce(\"values coalesce(cast(? as char(1)), ?, ?)\");\n-\t\tvetThreeArgCoalesce(\"values coalesce(?, cast(? as char(1)), ?)\");\n-\t\tvetThreeArgCoalesce(\"values coalesce(?, ?, cast(? as char(1)))\");\n-\t\tvetThreeArgCoalesce(\"values nvl(cast(? as char(1)), ?, ?)\");\n-\t\tvetThreeArgCoalesce(\"values nvl(?, cast(? as char(1)), ?)\");\n-\t\tvetThreeArgCoalesce(\"values nvl(?, ?, cast(? as char(1)))\");\n+    /**\n+     * This tests the ROUND function when the user inputs 2 parameters, where the second is the number of decimal places to round to\n+     * @returns double rounded to the given number of decimal places\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRoundVaryScale() throws Exception{\n+        ResultSet rs;\n+        double longNumber = 1347593487534897908346789398700763453456786.9082847283940982746172849098273647589099;\n+        //testing round to Long\n+        for(int i = -40; i < 40; i++){\n+            rs = methodWatcher.executeQuery(\"values ROUND(\"+longNumber+\",\"+i+\")\");\n+            Assert.assertTrue(rs.next());\n+            double mult = i < 18 ? i : 18;\n+            mult = Math.pow(10,mult);\n+            double x = Math.round(longNumber*mult)/(mult*1.0);\n+            Assert.assertEquals(x,rs.getDouble(1),0.0);\n+        }\n+    }\n \n-\t}\n+        /**\n+          * If more than one of the arguments passed to COALESCE are untyped\n+          * parameter markers, compilation used to fail with a NullPointerException.\n+          * Fixed in DERBY-6273.\n+          */\n+        @Test\n+    public void testMultipleUntypedParametersAndNVL() throws Exception {\n+        // All parameters cannot be untyped. This should still fail.\n+        try {\n+            methodWatcher.prepareStatement(\"values coalesce(?,?,?)\");\n+        } catch (SQLException se) {\n+            Assert.assertEquals(\"Invalid sql state!\", ErrorState.LANG_DB2_COALESCE_FUNCTION_ALL_PARAMS.getSqlState(),se.getSQLState());\n+        }\n+        // But as long as we know the type of one parameter, it should be\n+        // possible to have multiple parameters whose types are determined\n+        // from the context. These queries used to raise NullPointerException\n+        // before DERBY-6273.\n+        vetThreeArgCoalesce(\"values coalesce(cast(? as char(1)), ?, ?)\");\n+        vetThreeArgCoalesce(\"values coalesce(?, cast(? as char(1)), ?)\");\n+        vetThreeArgCoalesce(\"values coalesce(?, ?, cast(? as char(1)))\");\n+        vetThreeArgCoalesce(\"values nvl(cast(? as char(1)), ?, ?)\");\n+        vetThreeArgCoalesce(\"values nvl(?, cast(? as char(1)), ?)\");\n+        vetThreeArgCoalesce(\"values nvl(?, ?, cast(? as char(1)))\");\n \n-\t@Test\n-\tpublic void testCallToSystemFunctionFromUserWithoutDefaultSchema() throws Exception {\n-\t\tTestConnection user1Conn = spliceClassWatcher.createConnection(USER1, PASSWORD1);\n-\n-\t\tPreparedStatement ps = user1Conn.prepareStatement(\"VALUES rand(10)\");\n-\t\tResultSet rs = ps.executeQuery();\n-\t\tint count = 0;\n-\t\twhile (rs.next()) {\n-\t\t\tcount++;\n-\t\t}\n-\t\tAssert.assertEquals(1, count);\n-\t\trs.close();\n-\n-\n-\t\tps = user1Conn.prepareStatement(\"VALUES random()\");\n-\t\trs = ps.executeQuery();\n-\t\tcount = 0;\n-\t\twhile (rs.next()) {\n-\t\t\tcount++;\n-\t\t}\n-\t\tAssert.assertEquals(1, count);\n-\t\trs.close();\n+    }\n \n-\t}\n+    @Test\n+    public void testCallToSystemFunctionFromUserWithoutDefaultSchema() throws Exception {\n+        TestConnection user1Conn = spliceClassWatcher.createConnection(USER1, PASSWORD1);\n+\n+        PreparedStatement ps = user1Conn.prepareStatement(\"VALUES rand(10)\");\n+        ResultSet rs = ps.executeQuery();\n+        int count = 0;\n+        while (rs.next()) {\n+            count++;\n+        }\n+        Assert.assertEquals(1, count);\n+        rs.close();\n+\n+\n+        ps = user1Conn.prepareStatement(\"VALUES random()\");\n+        rs = ps.executeQuery();\n+        count = 0;\n+        while (rs.next()) {\n+            count++;\n+        }\n+        Assert.assertEquals(1, count);\n+        rs.close();\n+\n+    }\n+\n+    @Test\n+    public void testNvlWithDecimalZero() throws Exception {\n+        String sqlText = format(\"select sum(val_no_null)\\n\" +\n+                \"from (select nvl(col, 0) as val_no_null from %1$s.B) dt, %1$s.A --splice-properties useSpark=true\", FunctionIT.class.getSimpleName());\n+\n+        String expected = \"1   |\\n\" +\n+                \"--------\\n\" +\n+                \"2.0000 |\";\n+        ResultSet rs = methodWatcher.executeQuery(sqlText);\n+        assertEquals(\"\\n\" + sqlText + \"\\n\", expected, TestUtils.FormattedResult.ResultFactory.toString(rs));\n+    }\n+\n+        private void vetThreeArgCoalesce(String sql) throws Exception {\n+        // First three values in each row are arguments to COALESCE. The\n+                // last value is the expected return value.\n+                        String[][] data = {\n+                    {\"a\",  \"b\",  \"c\",  \"a\"},\n+                    {null, \"b\",  \"c\",  \"b\"},\n+                    {\"a\",  null, \"c\",  \"a\"},\n+                    {\"a\",  \"b\",  null, \"a\"},\n+                    {null, null, \"c\",  \"c\"},\n+                    {\"a\",  null, null, \"a\"},\n+                    {null, \"b\",  null, \"b\"},\n+                    {null, null, null, null},\n+                };\n+            PreparedStatement ps = methodWatcher.prepareStatement(sql);\n+            for (int i = 0; i < data.length; i++) {\n+                ps.setString(1, data[i][0]);\n+                ps.setString(2, data[i][1]);\n+                ps.setString(3, data[i][2]);\n+                ResultSet rs = ps.executeQuery();\n+                Assert.assertTrue(rs.next());\n+                Assert.assertEquals(\"Values do not match\",rs.getString(1),data[i][3]);\n+                Assert.assertFalse(rs.next());\n+            }\n+    }\n \n \t@Test\n-\tpublic void testNvlWithDecimalZero() throws Exception {\n-\t\tString sqlText = format(\"select sum(val_no_null)\\n\" +\n-\t\t\t\t\"from (select nvl(col, 0) as val_no_null from %1$s.B) dt, %1$s.A --splice-properties useSpark=true\", FunctionIT.class.getSimpleName());\n-\n-\t\tString expected = \"1   |\\n\" +\n-\t\t\t\t\"--------\\n\" +\n-\t\t\t\t\"2.0000 |\";\n-\t\tResultSet rs = methodWatcher.executeQuery(sqlText);\n-\t\tassertEquals(\"\\n\" + sqlText + \"\\n\", expected, TestUtils.FormattedResult.ResultFactory.toString(rs));\n-\t}\n+\tpublic void testCurrentServer() throws Exception {\n+        String sqlText = \"values current server\";\n+        String sqlTextAlt = \"values current_server\";\n+        String expected = \"1    |\\n\" +\n+                \"----------\\n\" +\n+                \"splicedb |\";\n \n-\t\tprivate void vetThreeArgCoalesce(String sql) throws Exception {\n-\t\t// First three values in each row are arguments to COALESCE. The\n-\t\t\t\t// last value is the expected return value.\n-\t\t\t\t\t\tString[][] data = {\n-\t\t\t\t\t{\"a\",  \"b\",  \"c\",  \"a\"},\n-\t\t\t\t\t{null, \"b\",  \"c\",  \"b\"},\n-\t\t\t\t\t{\"a\",  null, \"c\",  \"a\"},\n-\t\t\t\t\t{\"a\",  \"b\",  null, \"a\"},\n-\t\t\t\t\t{null, null, \"c\",  \"c\"},\n-\t\t\t\t\t{\"a\",  null, null, \"a\"},\n-\t\t\t\t\t{null, \"b\",  null, \"b\"},\n-\t\t\t\t\t{null, null, null, null},\n-\t\t\t\t};\n-\t\t\tPreparedStatement ps = methodWatcher.prepareStatement(sql);\n-\t\t\tfor (int i = 0; i < data.length; i++) {\n-\t\t\t\tps.setString(1, data[i][0]);\n-\t\t\t\tps.setString(2, data[i][1]);\n-\t\t\t\tps.setString(3, data[i][2]);\n-\t\t\t\tResultSet rs = ps.executeQuery();\n-\t\t\t\tAssert.assertTrue(rs.next());\n-\t\t\t\tAssert.assertEquals(\"Values do not match\",rs.getString(1),data[i][3]);\n-\t\t\t\tAssert.assertFalse(rs.next());\n-\t\t\t}\n-\t}\n+        ResultSet rs = methodWatcher.executeQuery(sqlText);\n+        assertEquals(\"\\n\" + sqlText + \"\\n\", expected, TestUtils.FormattedResult.ResultFactory.toString(rs));\n+        rs.close();\n \n+        rs = methodWatcher.executeQuery(sqlTextAlt);", "originalCommit": "1e8496fec1935243346d1fecde3fd33ee5ed241b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTc1NDA4Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3163#discussion_r371754086", "bodyText": "Done", "author": "arnaud-splice", "createdAt": "2020-01-28T11:44:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTY3OTgwMg=="}], "type": "inlineReview"}, {"oid": "5b4be9e0b354f95e0ef9b502ca0f44ef3822103e", "url": "https://github.com/splicemachine/spliceengine/commit/5b4be9e0b354f95e0ef9b502ca0f44ef3822103e", "message": "DB-9079 Address comments", "committedDate": "2020-01-28T11:43:59Z", "type": "commit"}, {"oid": "18b5ad736aef0cb24199eee76d9071aaa7179243", "url": "https://github.com/splicemachine/spliceengine/commit/18b5ad736aef0cb24199eee76d9071aaa7179243", "message": "Merge branch 'master' into DB-9079", "committedDate": "2020-01-30T04:48:23Z", "type": "commit"}]}