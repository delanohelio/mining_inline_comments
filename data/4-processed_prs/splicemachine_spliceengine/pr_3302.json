{"pr_number": 3302, "pr_title": "DB-8109 Support Multistatement Triggers", "pr_createdAt": "2020-03-05T18:43:59Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/3302", "timeline": [{"oid": "ecb4562f1a8b2754db604ef4350df04b2829a5f9", "url": "https://github.com/splicemachine/spliceengine/commit/ecb4562f1a8b2754db604ef4350df04b2829a5f9", "message": "DB-8109 Store actions in a list in CreateTriggerNode", "committedDate": "2020-03-05T18:45:36Z", "type": "commit"}, {"oid": "1b90044d8be5062399ce7a8f5cb2b457b51b6be7", "url": "https://github.com/splicemachine/spliceengine/commit/1b90044d8be5062399ce7a8f5cb2b457b51b6be7", "message": "DB-8109 Create StatementListNode", "committedDate": "2020-03-05T18:45:36Z", "type": "commit"}, {"oid": "abd4b3f573bdc70c710966d38f9c7054da6ea4b3", "url": "https://github.com/splicemachine/spliceengine/commit/abd4b3f573bdc70c710966d38f9c7054da6ea4b3", "message": "DB-8109 Support ActionList for lists of size 1", "committedDate": "2020-03-05T18:45:36Z", "type": "commit"}, {"oid": "8a3412942be6a822e6f900ec218dab1ac9f3f0d9", "url": "https://github.com/splicemachine/spliceengine/commit/8a3412942be6a822e6f900ec218dab1ac9f3f0d9", "message": "DB-8109 Refactor sqlgrammar.jj", "committedDate": "2020-03-05T18:45:36Z", "type": "commit"}, {"oid": "969d94ccf0dd4c223e76a4fef61cf06dc73945dd", "url": "https://github.com/splicemachine/spliceengine/commit/969d94ccf0dd4c223e76a4fef61cf06dc73945dd", "message": "DB-8109 Support multiple trigger actions in the grammar", "committedDate": "2020-03-05T18:45:36Z", "type": "commit"}, {"oid": "7cd8828f9453b2d2d79a31e0c82d101037722e53", "url": "https://github.com/splicemachine/spliceengine/commit/7cd8828f9453b2d2d79a31e0c82d101037722e53", "message": "DB-8109 Introduce early dependence steps", "committedDate": "2020-03-05T18:45:36Z", "type": "commit"}, {"oid": "2aa8e4fff2bf3080a24c8864004c582b5b20d3ae", "url": "https://github.com/splicemachine/spliceengine/commit/2aa8e4fff2bf3080a24c8864004c582b5b20d3ae", "message": "DB-8109 Support multiple statements in execution", "committedDate": "2020-03-05T18:45:36Z", "type": "commit"}, {"oid": "2aa8e4fff2bf3080a24c8864004c582b5b20d3ae", "url": "https://github.com/splicemachine/spliceengine/commit/2aa8e4fff2bf3080a24c8864004c582b5b20d3ae", "message": "DB-8109 Support multiple statements in execution", "committedDate": "2020-03-05T18:45:36Z", "type": "forcePushed"}, {"oid": "ec9fb0270e5172ba41544a5e2d0aa66d2e628575", "url": "https://github.com/splicemachine/spliceengine/commit/ec9fb0270e5172ba41544a5e2d0aa66d2e628575", "message": "DB-9259 Fix spotbugs errors in DataDictionaryImpl.java", "committedDate": "2020-03-09T13:04:42Z", "type": "commit"}, {"oid": "4b975e3e9cdddf17540422a4a5d1a69560275207", "url": "https://github.com/splicemachine/spliceengine/commit/4b975e3e9cdddf17540422a4a5d1a69560275207", "message": "DB-8109 Add tests", "committedDate": "2020-03-12T16:54:16Z", "type": "commit"}, {"oid": "7547222cc9f7c96e8bdde51b56fcd46d5dd60930", "url": "https://github.com/splicemachine/spliceengine/commit/7547222cc9f7c96e8bdde51b56fcd46d5dd60930", "message": "Merge branch 'master' into DB-8109", "committedDate": "2020-03-20T16:06:32Z", "type": "commit"}, {"oid": "7547222cc9f7c96e8bdde51b56fcd46d5dd60930", "url": "https://github.com/splicemachine/spliceengine/commit/7547222cc9f7c96e8bdde51b56fcd46d5dd60930", "message": "Merge branch 'master' into DB-8109", "committedDate": "2020-03-20T16:06:32Z", "type": "forcePushed"}, {"oid": "6d7a05c97e2067ed625da18d75dab6b64d330aae", "url": "https://github.com/splicemachine/spliceengine/commit/6d7a05c97e2067ed625da18d75dab6b64d330aae", "message": "DB-8109 Fix spotbugs errors", "committedDate": "2020-03-20T17:28:17Z", "type": "commit"}, {"oid": "a503f0aae8b918610607436cc6aef24320b86736", "url": "https://github.com/splicemachine/spliceengine/commit/a503f0aae8b918610607436cc6aef24320b86736", "message": "DB-8109 Place new serialized fields in TriggerDescriptorV3", "committedDate": "2020-03-23T14:12:55Z", "type": "commit"}, {"oid": "a503f0aae8b918610607436cc6aef24320b86736", "url": "https://github.com/splicemachine/spliceengine/commit/a503f0aae8b918610607436cc6aef24320b86736", "message": "DB-8109 Place new serialized fields in TriggerDescriptorV3", "committedDate": "2020-03-23T14:12:55Z", "type": "forcePushed"}, {"oid": "46bf2c90a3f120c759267776141c8fcd4418cd67", "url": "https://github.com/splicemachine/spliceengine/commit/46bf2c90a3f120c759267776141c8fcd4418cd67", "message": "DB-8109 Add two new columns in upgrade script", "committedDate": "2020-03-25T13:15:37Z", "type": "commit"}, {"oid": "4e512d1f1580ae53e3b4deccb117d0855c98bf35", "url": "https://github.com/splicemachine/spliceengine/commit/4e512d1f1580ae53e3b4deccb117d0855c98bf35", "message": "Merge remote-tracking branch 'origin/master' into DB-9259", "committedDate": "2020-03-26T11:44:00Z", "type": "commit"}, {"oid": "4ee751b400a0bb4ff0ea5113faa982d92a839353", "url": "https://github.com/splicemachine/spliceengine/commit/4ee751b400a0bb4ff0ea5113faa982d92a839353", "message": "DB-9259 Remove nonsensical assertion", "committedDate": "2020-03-26T11:58:04Z", "type": "commit"}, {"oid": "30887758912e8c2be3983fc9f6b882d0da19a34d", "url": "https://github.com/splicemachine/spliceengine/commit/30887758912e8c2be3983fc9f6b882d0da19a34d", "message": "Merge branch 'DB-9259' into DB-8109", "committedDate": "2020-03-26T12:02:24Z", "type": "commit"}, {"oid": "b32140fa707eebdd9a48d1742667bfdb14b9ea41", "url": "https://github.com/splicemachine/spliceengine/commit/b32140fa707eebdd9a48d1742667bfdb14b9ea41", "message": "Merge remote-tracking branch 'origin/master' into DB-8109", "committedDate": "2020-03-26T14:37:22Z", "type": "commit"}, {"oid": "debb40ced43dbe4319391fa5f12a05765adf754d", "url": "https://github.com/splicemachine/spliceengine/commit/debb40ced43dbe4319391fa5f12a05765adf754d", "message": "DB-9279 Disable failing tests in OlapClientTest", "committedDate": "2020-03-28T14:04:06Z", "type": "commit"}, {"oid": "ab4f55ca95a3da8b62e90a34703bb5c9a8088763", "url": "https://github.com/splicemachine/spliceengine/commit/ab4f55ca95a3da8b62e90a34703bb5c9a8088763", "message": "Merge branch 'master' into DB-8109", "committedDate": "2020-03-30T12:52:46Z", "type": "commit"}, {"oid": "337a31f0331b8b199e671b76726e01cb8d62b1c1", "url": "https://github.com/splicemachine/spliceengine/commit/337a31f0331b8b199e671b76726e01cb8d62b1c1", "message": "Merge branch 'master' into DB-8109", "committedDate": "2020-03-31T08:52:04Z", "type": "commit"}, {"oid": "d3c4e39e888cd9f99a6b50e01d4673162871809b", "url": "https://github.com/splicemachine/spliceengine/commit/d3c4e39e888cd9f99a6b50e01d4673162871809b", "message": "Merge branch 'master' into DB-8109", "committedDate": "2020-04-07T11:58:41Z", "type": "commit"}, {"oid": "80c87544b371e3ecc75b9302cc00ea9d4a326cb5", "url": "https://github.com/splicemachine/spliceengine/commit/80c87544b371e3ecc75b9302cc00ea9d4a326cb5", "message": "DB-8109 Update version in upgrade script", "committedDate": "2020-04-07T11:59:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA1MTcyMA==", "url": "https://github.com/splicemachine/spliceengine/pull/3302#discussion_r408051720", "bodyText": "I think we should have a \"hardcoded\" value here, instead of referring to SYSTRIGGERSRowFactory.SYSTRIGGERS_COLUMN_COUNT (it could be a static value that just copies the current SYSTRIGGERSRowFactory.SYSTRIGGERS_COLUMN_COUNT value)\nOtherwise if we add more columns to systriggers this code could be triggered again.", "author": "dgomezferro", "createdAt": "2020-04-14T11:04:00Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/catalog/upgrade/UpgradeScriptForTriggerMultipleStatements.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package com.splicemachine.derby.impl.sql.catalog.upgrade;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.sql.dictionary.DataDictionary;\n+import com.splicemachine.db.iapi.sql.dictionary.TableDescriptor;\n+import com.splicemachine.db.iapi.store.access.ConglomerateController;\n+import com.splicemachine.db.iapi.store.access.TransactionController;\n+import com.splicemachine.db.impl.sql.catalog.SYSTRIGGERSRowFactory;\n+import com.splicemachine.db.impl.sql.catalog.TabInfoImpl;\n+import com.splicemachine.derby.impl.sql.catalog.SpliceDataDictionary;\n+import com.splicemachine.derby.impl.store.access.hbase.HBaseController;\n+import com.splicemachine.utils.SpliceLogUtils;\n+\n+/**\n+ * Created by msirek on 11/5/19.\n+ */\n+public class UpgradeScriptForTriggerMultipleStatements extends UpgradeScriptBase {\n+    public UpgradeScriptForTriggerMultipleStatements(SpliceDataDictionary sdd, TransactionController tc) {\n+        super(sdd, tc);\n+    }\n+\n+    @Override\n+    protected void upgradeSystemTables() throws StandardException {\n+        ConglomerateController heapCC = null;\n+        try {\n+            TabInfoImpl tII = sdd.getNonCoreTIByNumber(DataDictionary.SYSTRIGGERS_CATALOG_NUM);\n+            TableDescriptor td =\n+               sdd.getTableDescriptor( tII.getCatalogRowFactory().getCatalogName(),\n+                                       sdd.getSystemSchemaDescriptor(), tc );\n+            long conglomID = td.getHeapConglomerateId();\n+            heapCC=tc.openConglomerate(conglomID,\n+                                       false,0,\n+                                       TransactionController.MODE_RECORD,\n+                                       TransactionController.ISOLATION_REPEATABLE_READ);\n+            // If upgrade has already been done, and we somehow got here again by\n+            // mistake, don't re-add the multistatement triggers columns to the systriggers\n+            // conglomerate descriptor.\n+            if (heapCC instanceof HBaseController) {\n+                HBaseController hCC = (HBaseController)heapCC;\n+                if (hCC.getConglomerate().getFormat_ids().length >=\n+                    SYSTRIGGERSRowFactory.SYSTRIGGERS_COLUMN_COUNT) {", "originalCommit": "46bf2c90a3f120c759267776141c8fcd4418cd67", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTUyNjA4Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/3302#discussion_r409526087", "bodyText": "That's an excellent point, we hardcode 19 and 20 below anyway, so we can do the same here.\nI will also modify it in UpgradeScriptForTriggerWhenClause.java\nThanks!", "author": "arnaud-splice", "createdAt": "2020-04-16T12:45:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA1MTcyMA=="}], "type": "inlineReview"}, {"oid": "5c8809f82fd714f3281d49291adf6820fd6fa957", "url": "https://github.com/splicemachine/spliceengine/commit/5c8809f82fd714f3281d49291adf6820fd6fa957", "message": "Merge remote-tracking branch 'origin/master' into DB-8109", "committedDate": "2020-04-16T12:40:58Z", "type": "commit"}, {"oid": "326917d72cb453b43b1b891f093d3b00a61ff531", "url": "https://github.com/splicemachine/spliceengine/commit/326917d72cb453b43b1b891f093d3b00a61ff531", "message": "DB-8109 Hardcode number of columns in upgrade script", "committedDate": "2020-04-16T12:46:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI3NTg3NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3302#discussion_r416275875", "bodyText": "2020 now?", "author": "carolp-503", "createdAt": "2020-04-28T02:13:54Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/TriggerDescriptorV3.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ * Some parts of this source code are based on Apache Derby, and the following notices apply to\n+ * Apache Derby:\n+ *\n+ * Apache Derby is a subproject of the Apache DB project, and is licensed under\n+ * the Apache License, Version 2.0 (the \"License\"); you may not use these files\n+ * except in compliance with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed\n+ * under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n+ * CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * Splice Machine, Inc. has modified the Apache Derby code in this file.\n+ *\n+ * All such Splice Machine modifications are Copyright 2012 - 2019 Splice Machine, Inc.,", "originalCommit": "326917d72cb453b43b1b891f093d3b00a61ff531", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUxNTY3Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/3302#discussion_r416515673", "bodyText": "Done", "author": "arnaud-splice", "createdAt": "2020-04-28T10:47:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI3NTg3NQ=="}], "type": "inlineReview"}, {"oid": "e55ae2ef2785045864db82b71b7f10d001ea546e", "url": "https://github.com/splicemachine/spliceengine/commit/e55ae2ef2785045864db82b71b7f10d001ea546e", "message": "DB-8109 Fix copyright and update upgradescript version", "committedDate": "2020-04-28T10:51:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5MTg3NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3302#discussion_r417091875", "bodyText": "the correct number of columns should be updated to 19 and 20.", "author": "yxia92", "createdAt": "2020-04-29T06:28:16Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/catalog/upgrade/UpgradeScriptForTriggerMultipleStatements.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.splicemachine.derby.impl.sql.catalog.upgrade;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.sql.dictionary.DataDictionary;\n+import com.splicemachine.db.iapi.sql.dictionary.TableDescriptor;\n+import com.splicemachine.db.iapi.store.access.ConglomerateController;\n+import com.splicemachine.db.iapi.store.access.TransactionController;\n+import com.splicemachine.db.impl.sql.catalog.SYSTRIGGERSRowFactory;\n+import com.splicemachine.db.impl.sql.catalog.TabInfoImpl;\n+import com.splicemachine.derby.impl.sql.catalog.SpliceDataDictionary;\n+import com.splicemachine.derby.impl.store.access.hbase.HBaseController;\n+import com.splicemachine.utils.SpliceLogUtils;\n+\n+/**\n+ * Created by msirek on 11/5/19.\n+ */\n+public class UpgradeScriptForTriggerMultipleStatements extends UpgradeScriptBase {\n+    public UpgradeScriptForTriggerMultipleStatements(SpliceDataDictionary sdd, TransactionController tc) {\n+        super(sdd, tc);\n+    }\n+\n+    @Override\n+    protected void upgradeSystemTables() throws StandardException {\n+        ConglomerateController heapCC = null;\n+        try {\n+            TabInfoImpl tII = sdd.getNonCoreTIByNumber(DataDictionary.SYSTRIGGERS_CATALOG_NUM);\n+            TableDescriptor td =\n+               sdd.getTableDescriptor( tII.getCatalogRowFactory().getCatalogName(),\n+                                       sdd.getSystemSchemaDescriptor(), tc );\n+            long conglomID = td.getHeapConglomerateId();\n+            heapCC=tc.openConglomerate(conglomID,\n+                                       false,0,\n+                                       TransactionController.MODE_RECORD,\n+                                       TransactionController.ISOLATION_REPEATABLE_READ);\n+            // If upgrade has already been done, and we somehow got here again by\n+            // mistake, don't re-add the multistatement triggers columns to the systriggers\n+            // conglomerate descriptor.\n+            if (heapCC instanceof HBaseController) {\n+                HBaseController hCC = (HBaseController)heapCC;\n+                if (hCC.getConglomerate().getFormat_ids().length >= 20) {\n+                    return;\n+                }\n+            }\n+            heapCC.close();\n+            heapCC = null;\n+            sdd.upgrade_addColumns(tII.getCatalogRowFactory(), new int[]{19,20}, tc);\n+            SpliceLogUtils.info(LOG, \"Catalog upgraded: updated system table sys.systriggers\");\n+        }\n+        catch (Exception e) {\n+            SpliceLogUtils.info(LOG, \"Attempt to upgrade sys.systriggers failed.  Please check if it has already been upgraded and contains the correct number of columns: 18.\");", "originalCommit": "e55ae2ef2785045864db82b71b7f10d001ea546e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMxMTYzMA==", "url": "https://github.com/splicemachine/spliceengine/pull/3302#discussion_r419311630", "bodyText": "Done", "author": "arnaud-splice", "createdAt": "2020-05-04T09:25:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5MTg3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5NTg0NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3302#discussion_r417095845", "bodyText": "Shouldn't we move this call out of the loop?", "author": "yxia92", "createdAt": "2020-04-29T06:39:08Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/TriggerDescriptor.java", "diffHunk": "@@ -720,17 +739,18 @@ public void drop(LanguageConnectionContext lcc) throws StandardException {\n         dm.clearDependencies(lcc, this);\n \n         // Drop the spses\n-        SPSDescriptor spsd = dd.getSPSDescriptor(this.getActionId());\n-\n-        // there shouldn't be any dependencies, but in case there are, lets clear them\n-        dm.invalidateFor(spsd, DependencyManager.DROP_TRIGGER, lcc);\n-        dm.clearDependencies(lcc, spsd);\n-        dd.dropSPSDescriptor(spsd, tc);\n-        // Remove all TECs from trigger stack. They will need to be rebuilt.\n-        lcc.popAllTriggerExecutionContexts();\n+        for (UUID actionId: this.actionSPSIdList) {\n+            SPSDescriptor spsd = dd.getSPSDescriptor(actionId);\n \n+            // there shouldn't be any dependencies, but in case there are, lets clear them\n+            dm.invalidateFor(spsd, DependencyManager.DROP_TRIGGER, lcc);\n+            dm.clearDependencies(lcc, spsd);\n+            dd.dropSPSDescriptor(spsd, tc);\n+            // Remove all TECs from trigger stack. They will need to be rebuilt.\n+            lcc.popAllTriggerExecutionContexts(); //XXX arnaud move out of the loop?", "originalCommit": "e55ae2ef2785045864db82b71b7f10d001ea546e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMxNjE0OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3302#discussion_r419316149", "bodyText": "Done", "author": "arnaud-splice", "createdAt": "2020-05-04T09:34:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzA5NTg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEwNjcwOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3302#discussion_r417106709", "bodyText": "Should we move these statements out of the loop?", "author": "yxia92", "createdAt": "2020-04-29T07:05:44Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/actions/DropTriggerConstantOperation.java", "diffHunk": "@@ -35,124 +35,126 @@\n import com.splicemachine.protobuf.ProtoUtil;\n \n /**\n- *\tThis class  describes actions that are ALWAYS performed for a\n- *\tDROP TRIGGER Statement at Execution time.\n+ *    This class  describes actions that are ALWAYS performed for a\n+ *    DROP TRIGGER Statement at Execution time.\n  *\n  */\n public class DropTriggerConstantOperation extends DDLSingleTableConstantOperation {\n-\tprivate final String triggerName;\n-\tprivate final SchemaDescriptor sd;\n-\n-\t/**\n-\t *\tMake the ConstantAction for a DROP TRIGGER statement.\n-\t *\n-\t * @param\tsd\t\t\t\t\tSchema that stored prepared statement lives in.\n-\t * @param\ttriggerName\t\t\tName of the Trigger\n-\t * @param\ttableId\t\t\t\tThe table upon which the trigger is defined\n-\t *\n-\t */\n-\tpublic DropTriggerConstantOperation(SchemaDescriptor sd, String triggerName, UUID tableId) {\n-\t\tsuper(tableId);\n-\t\tthis.sd = sd;\n-\t\tthis.triggerName = triggerName;\n-\t\tif (SanityManager.DEBUG)\n-\t\t\tSanityManager.ASSERT(sd != null, \"SchemaDescriptor is null\");\n-\t}\n-\n-\t/**\n-\t *\tThis is the guts of the Execution-time logic for DROP STATEMENT.\n-\t *\n-\t *\t@see ConstantAction#executeConstantAction\n-\t *\n-\t * @exception StandardException\t\tThrown on failure\n-\t */\n-\tpublic void executeConstantAction( Activation activation ) throws StandardException {\n-\t\tTriggerDescriptor \t\t\ttriggerd;\n-\t\tLanguageConnectionContext lcc = activation.getLanguageConnectionContext();\n-\t\tDataDictionary dd = lcc.getDataDictionary();\n-\t\t/*\n-\t\t** Inform the data dictionary that we are about to write to it.\n-\t\t** There are several calls to data dictionary \"get\" methods here\n-\t\t** that might be done in \"read\" mode in the data dictionary, but\n-\t\t** it seemed safer to do this whole operation in \"write\" mode.\n-\t\t**\n-\t\t** We tell the data dictionary we're done writing at the end of\n-\t\t** the transaction.\n-\t\t*/\n-\t\tdd.startWriting(lcc);\n-\n-\t\tTableDescriptor td = dd.getTableDescriptor(tableId);\n-\t\tif (td == null) {\n-\t\t\tthrow StandardException.newException(\n-\t\t\t\t\t\t\t\tSQLState.LANG_TABLE_NOT_FOUND_DURING_EXECUTION,\n-\t\t\t\t\t\t\t\ttableId.toString());\n-\t\t}\n-\t\tTransactionController tc = lcc.getTransactionExecute();\n-\t\t// XXX - TODO NO LOCKING lockTableForDDL(tc, td.getHeapConglomerateId(), true);\n-\t\t// get td again in case table shape is changed before lock is acquired\n-\t\ttd = dd.getTableDescriptor(tableId);\n-\t\tif (td == null)\n-\t\t{\n-\t\t\tthrow StandardException.newException(\n-\t\t\t\t\t\t\t\tSQLState.LANG_TABLE_NOT_FOUND_DURING_EXECUTION,\n-\t\t\t\t\t\t\t\ttableId.toString());\n-\t\t}\n-\n-\t\t/* \n-\t\t** Get the trigger descriptor.  We're responsible for raising\n-\t\t** the error if it isn't found \n-\t\t*/\n-\t\ttriggerd = dd.getTriggerDescriptor(triggerName, sd);\n-\n-\t\tif (triggerd == null) {\n-\t\t\tthrow StandardException.newException(SQLState.LANG_OBJECT_NOT_FOUND_DURING_EXECUTION, \"TRIGGER\",\n-\t\t\t\t\t(sd.getSchemaName() + \".\" + triggerName));\n-\t\t}\n-\n-\t\t/* \n-\t \t** Prepare all dependents to invalidate.  (This is there chance\n-\t\t** to say that they can't be invalidated.  For example, an open\n-\t\t** cursor referencing a table/trigger that the user is attempting to\n-\t\t** drop.) If no one objects, then invalidate any dependent objects.\n-\t\t*/\n+    private final String triggerName;\n+    private final SchemaDescriptor sd;\n+\n+    /**\n+     *    Make the ConstantAction for a DROP TRIGGER statement.\n+     *\n+     * @param    sd                    Schema that stored prepared statement lives in.\n+     * @param    triggerName            Name of the Trigger\n+     * @param    tableId                The table upon which the trigger is defined\n+     *\n+     */\n+    public DropTriggerConstantOperation(SchemaDescriptor sd, String triggerName, UUID tableId) {\n+        super(tableId);\n+        this.sd = sd;\n+        this.triggerName = triggerName;\n+        if (SanityManager.DEBUG)\n+            SanityManager.ASSERT(sd != null, \"SchemaDescriptor is null\");\n+    }\n+\n+    /**\n+     *    This is the guts of the Execution-time logic for DROP STATEMENT.\n+     *\n+     *    @see ConstantAction#executeConstantAction\n+     *\n+     * @exception StandardException        Thrown on failure\n+     */\n+    public void executeConstantAction( Activation activation ) throws StandardException {\n+        TriggerDescriptor             triggerd;\n+        LanguageConnectionContext lcc = activation.getLanguageConnectionContext();\n+        DataDictionary dd = lcc.getDataDictionary();\n+        /*\n+        ** Inform the data dictionary that we are about to write to it.\n+        ** There are several calls to data dictionary \"get\" methods here\n+        ** that might be done in \"read\" mode in the data dictionary, but\n+        ** it seemed safer to do this whole operation in \"write\" mode.\n+        **\n+        ** We tell the data dictionary we're done writing at the end of\n+        ** the transaction.\n+        */\n+        dd.startWriting(lcc);\n+\n+        TableDescriptor td = dd.getTableDescriptor(tableId);\n+        if (td == null) {\n+            throw StandardException.newException(\n+                                SQLState.LANG_TABLE_NOT_FOUND_DURING_EXECUTION,\n+                                tableId.toString());\n+        }\n+        TransactionController tc = lcc.getTransactionExecute();\n+        // XXX - TODO NO LOCKING lockTableForDDL(tc, td.getHeapConglomerateId(), true);\n+        // get td again in case table shape is changed before lock is acquired\n+        td = dd.getTableDescriptor(tableId);\n+        if (td == null)\n+        {\n+            throw StandardException.newException(\n+                                SQLState.LANG_TABLE_NOT_FOUND_DURING_EXECUTION,\n+                                tableId.toString());\n+        }\n+\n+        /*\n+        ** Get the trigger descriptor.  We're responsible for raising\n+        ** the error if it isn't found\n+        */\n+        triggerd = dd.getTriggerDescriptor(triggerName, sd);\n+\n+        if (triggerd == null) {\n+            throw StandardException.newException(SQLState.LANG_OBJECT_NOT_FOUND_DURING_EXECUTION, \"TRIGGER\",\n+                    (sd.getSchemaName() + \".\" + triggerName));\n+        }\n+\n+        /*\n+         ** Prepare all dependents to invalidate.  (This is there chance\n+        ** to say that they can't be invalidated.  For example, an open\n+        ** cursor referencing a table/trigger that the user is attempting to\n+        ** drop.) If no one objects, then invalidate any dependent objects.\n+        */\n \n         DependencyManager dm = dd.getDependencyManager();\n         dm.invalidateFor(triggerd, DependencyManager.DROP_TRIGGER, lcc);\n \n         // Drop the spses\n-        SPSDescriptor spsd = dd.getSPSDescriptor(triggerd.getActionId());\n-        dm.invalidateFor(spsd, DependencyManager.DROP_TRIGGER, lcc);\n+        for (UUID actionId: triggerd.getActionIdList()) {\n+            SPSDescriptor spsd = dd.getSPSDescriptor(actionId);\n+            dm.invalidateFor(spsd, DependencyManager.DROP_TRIGGER, lcc);\n \n-        DDLMessage.DDLChange ddlChange = ProtoUtil.dropTrigger(((SpliceTransactionManager) tc).getActiveStateTxn().getTxnId(),\n-                (BasicUUID) this.tableId, (BasicUUID) triggerd.getUUID(),\n-                (BasicUUID) triggerd.getActionId());\n-        // Run Remotely\n-        tc.prepareDataDictionaryChange(DDLUtils.notifyMetadataChange(ddlChange));\n+            DDLMessage.DDLChange ddlChange = ProtoUtil.dropTrigger(((SpliceTransactionManager) tc).getActiveStateTxn().getTxnId(),\n+                    (BasicUUID) this.tableId, (BasicUUID) triggerd.getUUID(),\n+                    (BasicUUID) actionId);\n+            // Run Remotely\n+            tc.prepareDataDictionaryChange(DDLUtils.notifyMetadataChange(ddlChange));\n \n-        dm.clearDependencies(lcc, triggerd);\n-        dm.clearDependencies(lcc, spsd);\n+            dm.clearDependencies(lcc, triggerd); // XXX arnaud get some stuff out of the loop\n+            dm.clearDependencies(lcc, spsd);\n \n-        // Drop the trigger\n-        dd.dropTriggerDescriptor(triggerd, tc);\n+            // Drop the trigger\n+            dd.dropTriggerDescriptor(triggerd, tc);\n \n-        // there shouldn't be any dependencies, but in case there are, lets clear them\n-        dd.dropSPSDescriptor(spsd, tc);\n-        // Remove all TECs from trigger stack. They will need to be rebuilt.\n-        lcc.popAllTriggerExecutionContexts();\n+            // there shouldn't be any dependencies, but in case there are, lets clear them\n+            dd.dropSPSDescriptor(spsd, tc);\n+            // Remove all TECs from trigger stack. They will need to be rebuilt.", "originalCommit": "e55ae2ef2785045864db82b71b7f10d001ea546e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTMyNTg3Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/3302#discussion_r419325872", "bodyText": "Done", "author": "arnaud-splice", "createdAt": "2020-05-04T09:52:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEwNjcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyNjExMQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3302#discussion_r417126111", "bodyText": "I have some concern about having null at the end of the write stream. How do we guarantee that we won't be reading fields from another object when calling readExternal() if these two fields are null ?", "author": "yxia92", "createdAt": "2020-04-29T07:46:12Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/TriggerDescriptorV3.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ *\n+ * Some parts of this source code are based on Apache Derby, and the following notices apply to\n+ * Apache Derby:\n+ *\n+ * Apache Derby is a subproject of the Apache DB project, and is licensed under\n+ * the Apache License, Version 2.0 (the \"License\"); you may not use these files\n+ * except in compliance with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed\n+ * under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR\n+ * CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * Splice Machine, Inc. has modified the Apache Derby code in this file.\n+ *\n+ * All such Splice Machine modifications are Copyright 2012 - 2020 Splice Machine, Inc.,\n+ * and are licensed to you under the GNU Affero General Public License.\n+ */\n+\n+package com.splicemachine.db.iapi.sql.dictionary;\n+\n+import com.splicemachine.db.catalog.UUID;\n+import com.splicemachine.db.impl.sql.execute.TriggerEventDML;\n+\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.sql.Timestamp;\n+import java.util.List;\n+\n+/**\n+ * Version 2 of the Trigger Descriptor class.\n+ * Added because SerDe doesn't have a version number stored in it,\n+ * to know how many fields to deserialize, and this could be stored\n+ * on disk in sys.sysstatements.\n+ * Instead, we store the version number in the class name, and\n+ * add the new fields to serialize in this class.\n+ */\n+public class TriggerDescriptorV3 extends TriggerDescriptor {\n+\n+    /**\n+     * Default constructor for formatable\n+     */\n+    public TriggerDescriptorV3() {\n+    }\n+\n+    /**\n+     * Constructor.  Used when creating a trigger from SYS.SYSTRIGGERS\n+     *\n+     * @param dataDictionary                the data dictionary\n+     * @param sd                            the schema descriptor for this trigger\n+     * @param id                            the trigger id\n+     * @param name                          the trigger name\n+     * @param eventMask                     TriggerDescriptor.TRIGGER_EVENT_XXXX\n+     * @param isBefore                      is this a before (as opposed to after) trigger\n+     * @param isRow                         is this a row trigger or statement trigger\n+     * @param isEnabled                     is this trigger enabled or disabled\n+     * @param td                            the table upon which this trigger is defined\n+     * @param whenSPSId                     the sps id for the when clause (may be null)\n+     * @param actionSPSIdList               the spsid for the trigger action (may be null)\n+     * @param creationTimestamp             when was this trigger created?\n+     * @param referencedCols                what columns does this trigger reference (may be null)\n+     * @param referencedColsInTriggerAction what columns does the trigger\n+     *                                      action reference through old/new transition variables (may be null)\n+     * @param triggerDefinitionList         The original user text of the trigger action\n+     * @param referencingOld                whether or not OLD appears in REFERENCING clause\n+     * @param referencingNew                whether or not NEW appears in REFERENCING clause\n+     * @param oldReferencingName            old referencing table name, if any, that appears in REFERCING clause\n+     * @param newReferencingName            new referencing table name, if any, that appears in REFERCING clause\n+     * @param whenClauseText                the SQL text of the WHEN clause, or {@code null}\n+     *                                      if there is no WHEN clause\n+     */\n+    public TriggerDescriptorV3(\n+            DataDictionary dataDictionary,\n+            SchemaDescriptor sd,\n+            UUID id,\n+            String name,\n+            TriggerEventDML eventMask,\n+            boolean isBefore,\n+            boolean isRow,\n+            boolean isEnabled,\n+            TableDescriptor td,\n+            UUID whenSPSId,\n+            List<UUID> actionSPSIdList,\n+            Timestamp creationTimestamp,\n+            int[] referencedCols,\n+            int[] referencedColsInTriggerAction,\n+            List<String> triggerDefinitionList,\n+            boolean referencingOld,\n+            boolean referencingNew,\n+            String oldReferencingName,\n+            String newReferencingName,\n+            String whenClauseText) {\n+        super(\n+            dataDictionary,\n+            sd,\n+            id,\n+            name,\n+            eventMask,\n+            isBefore,\n+            isRow,\n+            isEnabled,\n+            td,\n+            whenSPSId,\n+            actionSPSIdList,\n+            creationTimestamp,\n+            referencedCols,\n+            referencedColsInTriggerAction,\n+            triggerDefinitionList,\n+            referencingOld,\n+            referencingNew,\n+            oldReferencingName,\n+            newReferencingName,\n+            whenClauseText);\n+        this.version = 3;\n+    }\n+\n+    //////////////////////////////////////////////////////////////\n+    //\n+    // FORMATABLE\n+    //\n+    //////////////////////////////////////////////////////////////\n+    /**\n+     * WARNING - If adding new fields to readExternal/writeExternal\n+     * you must create a new subclass, and add the fields there.\n+     * Otherwise old SPSDescriptors stored in sys.sysstatements may\n+     * fail to deserialize properly.\n+     *\n+     * @param in read this.\n+     * @throws IOException            thrown on error\n+     * @throws ClassNotFoundException thrown on error\n+     */\n+    /**\n+     * Read this object from a stream of stored objects.\n+     *\n+     * @param in read this.\n+     * @throws IOException            thrown on error\n+     * @throws ClassNotFoundException thrown on error\n+     */\n+    @Override\n+    public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+        super.readExternal(in);\n+        version = in.readInt();\n+\n+        Object obj = in.readObject();\n+        if (obj instanceof List) {\n+            assert triggerDefinitionList == null : \"triggerDefinition and triggerDefinitionList cannot both be defined\";\n+            triggerDefinitionList = (List<String>) obj;\n+        }\n+\n+        obj = in.readObject();\n+        if (obj instanceof List) {\n+            assert actionSPSIdList == null : \"actionSPSIdList and actionSPSId cannot both be defined\";\n+            actionSPSIdList= (List<UUID>) obj;\n+        }\n+\n+    }\n+\n+    /**\n+     * Write this object to a stream of stored objects.\n+     *\n+     * @param out write bytes here.\n+     */\n+    @Override\n+    public void writeExternal(ObjectOutput out) throws IOException {\n+        super.writeExternal(out);\n+        out.writeInt(version);\n+        out.writeObject(triggerDefinitionList.size() > 1 ? triggerDefinitionList : null);\n+        out.writeObject(actionSPSIdList.size() > 1 ? actionSPSIdList : null);\n+    }", "originalCommit": "e55ae2ef2785045864db82b71b7f10d001ea546e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTU4ODQyOA==", "url": "https://github.com/splicemachine/spliceengine/pull/3302#discussion_r419588428", "bodyText": "The original concern was that we cannot differentiate the two scenarios 1) TriggerDescriptorV3 with null for triggerDefinitionList and actionSPSIdList followed by O1 starting with an List object, or 2) TriggerDescriptorV3 with non-null triggerDefinitionList and actionSPSIdList followed by O1. Based on a discussion with Arnaud, this is is a no issue, so closing this comment.", "author": "yxia92", "createdAt": "2020-05-04T17:05:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEyNjExMQ=="}], "type": "inlineReview"}, {"oid": "cd5f1183530319716aae33895d62e253871ba54f", "url": "https://github.com/splicemachine/spliceengine/commit/cd5f1183530319716aae33895d62e253871ba54f", "message": "Merge remote-tracking branch 'origin/master' into DB-8109", "committedDate": "2020-05-04T09:27:04Z", "type": "commit"}, {"oid": "f464c4d5e6a1763f067f12cc04e4221dcb36228c", "url": "https://github.com/splicemachine/spliceengine/commit/f464c4d5e6a1763f067f12cc04e4221dcb36228c", "message": "DB-8109 Address comments", "committedDate": "2020-05-04T09:56:59Z", "type": "commit"}, {"oid": "9bed4bc059cbb7a9b88a795f4effa914e01ad577", "url": "https://github.com/splicemachine/spliceengine/commit/9bed4bc059cbb7a9b88a795f4effa914e01ad577", "message": "Merge remote-tracking branch 'origin/master' into DB-8109", "committedDate": "2020-05-12T15:40:52Z", "type": "commit"}, {"oid": "3b29dde82a42942577d4c2a672f177ff1b070095", "url": "https://github.com/splicemachine/spliceengine/commit/3b29dde82a42942577d4c2a672f177ff1b070095", "message": "DB-8109 Update sprint version in UpgradeScript", "committedDate": "2020-05-12T15:42:14Z", "type": "commit"}]}