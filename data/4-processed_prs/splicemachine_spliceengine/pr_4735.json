{"pr_number": 4735, "pr_title": "DB-10914 + DB-10926 Long varchar to timestamp in prepared statements ", "pr_createdAt": "2020-11-30T16:05:05Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4735", "timeline": [{"oid": "ea915ecb1d1b9cdda59d132e9c8289bd7e41d972", "url": "https://github.com/splicemachine/spliceengine/commit/ea915ecb1d1b9cdda59d132e9c8289bd7e41d972", "message": "DB-10914 Autocast string to timestamp in prepared statements", "committedDate": "2020-11-30T15:59:56Z", "type": "commit"}, {"oid": "763ed9e2584f400a2a529ce445d0fb9ed030b17f", "url": "https://github.com/splicemachine/spliceengine/commit/763ed9e2584f400a2a529ce445d0fb9ed030b17f", "message": "DB-10914 Cast only when necessary", "committedDate": "2020-11-30T19:01:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI0OTExMw==", "url": "https://github.com/splicemachine/spliceengine/pull/4735#discussion_r533249113", "bodyText": "Should this be like this instead?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        leftOperand.addCastNodeForStringToNonStringComparison(rightOperand, leftOperand);\n          \n          \n            \n                        leftOperand = addCastNodeForStringToNonStringComparison(rightOperand, leftOperand);\n          \n      \n    \n    \n  \n\nIs it possible we are not testing this branch? Can we add a test?", "author": "dgomezferro", "createdAt": "2020-12-01T09:52:57Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryComparisonOperatorNode.java", "diffHunk": "@@ -55,154 +55,101 @@\n \n public abstract class BinaryComparisonOperatorNode extends BinaryOperatorNode\n {\n-\t// Use between selectivity?\n-\tprivate boolean forQueryRewrite;\n-\tprivate boolean betweenSelectivity;\n-\n-\t/**\n-\t * Initializer for a BinaryComparisonOperatorNode\n-\t *\n-\t * @param leftOperand\tThe left operand of the comparison\n-\t * @param rightOperand\tThe right operand of the comparison\n-\t * @param operator\t\tThe name of the operator\n-\t * @param methodName\tThe name of the method to call in the generated\n-\t *\t\t\t\t\t\tclass\n-\t */\n-\n-\tpublic void init(\n-\t\t\t\tObject\tleftOperand,\n-\t\t\t\tObject\trightOperand,\n-\t\t\t\tObject\t\toperator,\n-\t\t\t\tObject\t\tmethodName)\n-\t{\n-\t\tsuper.init(leftOperand, rightOperand, operator, methodName,\n-\t\t\t\tClassName.DataValueDescriptor, ClassName.DataValueDescriptor);\n-\t}\n-\n-\t/**\n-\t * This node was generated as part of a query rewrite. Bypass the\n-\t * normal comparability checks.\n-\t * @param val  true if this was for a query rewrite\n-\t */\n-\tpublic void setForQueryRewrite(boolean val)\n-\t{\n-\t\tforQueryRewrite=val;\n-\t}\n-\n-\t/**\n-\t * Was this node generated in a query rewrite?\n-\t *\n-\t * @return  true if it was generated in a query rewrite.\n-\t */\n-\tpublic boolean getForQueryRewrite()\n-\t{\n-\t\treturn forQueryRewrite;\n-\t}\n-\n-\t/**\n-\t * Use between selectivity when calculating the selectivity.\n-\t */\n-\tvoid setBetweenSelectivity()\n-\t{\n-\t\tbetweenSelectivity = true;\n-\t}\n-\n-\t/**\n-\t * Return whether or not to use the between selectivity for this node.\n-\t *\n-\t * @return Whether or not to use the between selectivity for this node.\n-\t */\n-\tboolean getBetweenSelectivity() {\n-\t\treturn betweenSelectivity;\n-\t}\n-\n-\n-\t/**\n-\t * Bind this comparison operator.  All that has to be done for binding\n-\t * a comparison operator is to bind the operands, check the compatibility\n-\t * of the types, and set the result type to SQLBoolean.\n-\t *\n-\t * @param fromList\t\t\tThe query's FROM list\n-\t * @param subqueryList\t\tThe subquery list being built as we find SubqueryNodes\n-\t * @param aggregateVector\tThe aggregate vector being built as we find AggregateNodes\n-\t *\n-\t * @return\tThe new top of the expression tree.\n-\t *\n-\t * @exception StandardException\t\tThrown on error\n-\t */\n+    // Use between selectivity?\n+    private boolean forQueryRewrite;\n+    private boolean betweenSelectivity;\n+\n+    /**\n+     * Initializer for a BinaryComparisonOperatorNode\n+     *\n+     * @param leftOperand    The left operand of the comparison\n+     * @param rightOperand    The right operand of the comparison\n+     * @param operator        The name of the operator\n+     * @param methodName    The name of the method to call in the generated\n+     *                        class\n+     */\n+\n+    public void init(\n+                Object    leftOperand,\n+                Object    rightOperand,\n+                Object        operator,\n+                Object        methodName)\n+    {\n+        super.init(leftOperand, rightOperand, operator, methodName,\n+                ClassName.DataValueDescriptor, ClassName.DataValueDescriptor);\n+    }\n+\n+    /**\n+     * This node was generated as part of a query rewrite. Bypass the\n+     * normal comparability checks.\n+     * @param val  true if this was for a query rewrite\n+     */\n+    public void setForQueryRewrite(boolean val)\n+    {\n+        forQueryRewrite=val;\n+    }\n+\n+    /**\n+     * Was this node generated in a query rewrite?\n+     *\n+     * @return  true if it was generated in a query rewrite.\n+     */\n+    public boolean getForQueryRewrite()\n+    {\n+        return forQueryRewrite;\n+    }\n+\n+    /**\n+     * Use between selectivity when calculating the selectivity.\n+     */\n+    void setBetweenSelectivity()\n+    {\n+        betweenSelectivity = true;\n+    }\n+\n+    /**\n+     * Return whether or not to use the between selectivity for this node.\n+     *\n+     * @return Whether or not to use the between selectivity for this node.\n+     */\n+    boolean getBetweenSelectivity() {\n+        return betweenSelectivity;\n+    }\n+\n+\n+    /**\n+     * Bind this comparison operator.  All that has to be done for binding\n+     * a comparison operator is to bind the operands, check the compatibility\n+     * of the types, and set the result type to SQLBoolean.\n+     *\n+     * @param fromList            The query's FROM list\n+     * @param subqueryList        The subquery list being built as we find SubqueryNodes\n+     * @param aggregateVector    The aggregate vector being built as we find AggregateNodes\n+     *\n+     * @return    The new top of the expression tree.\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n \n     @Override\n-\tpublic ValueNode bindExpression(FromList fromList,\n+    public ValueNode bindExpression(FromList fromList,\n                                     SubqueryList subqueryList,\n                                     List<AggregateNode> aggregateVector) throws StandardException {\n-\t\tsuper.bindExpression(fromList, subqueryList, aggregateVector);\n+        super.bindExpression(fromList, subqueryList, aggregateVector);\n \n         TypeId leftTypeId = leftOperand.getTypeId();\n-\t\tTypeId rightTypeId = rightOperand.getTypeId();\n-\n-\t\t/*\n-\t\t * If we are comparing a non-string with a string type, then we\n-\t\t * must prevent the non-string value from being used to probe into\n-\t\t * an index on a string column. This is because the string types\n-\t\t * are all of low precedence, so the comparison rules of the non-string\n-\t\t * value are used, so it may not find values in a string index because\n-\t\t * it will be in the wrong order. So, cast the string value to its\n-\t\t * own type. This is easier than casting it to the non-string type,\n-\t\t * because we would have to figure out the right length to cast it to.\n-\t\t */\n-\t\tif (! leftTypeId.isStringTypeId() && rightTypeId.isStringTypeId())\n-\t\t{\n-\t\t\tif (leftTypeId.isBooleanTypeId() || leftTypeId.isDateTimeTimeStampTypeId()) {\n-\t\t\t\trightOperand = (ValueNode)\n-\t\t\t\t\t\tgetNodeFactory().getNode(\n-\t\t\t\t\t\t\t\tC_NodeTypes.CAST_NODE,\n-\t\t\t\t\t\t\t\trightOperand,\n-\t\t\t\t\t\t\t\tnew DataTypeDescriptor(\n-\t\t\t\t\t\t\t\t\t\tleftTypeId,\n-\t\t\t\t\t\t\t\t\t\ttrue,leftOperand.getTypeServices().getMaximumWidth()),\n-\t\t\t\t\t\t\t\tgetContextManager());\n-\t\t\t\t((CastNode) rightOperand).bindCastNodeOnly();\n-\t\t\t\trightTypeId = rightOperand.getTypeId();\n-\t\t\t}\n-\t\t\telse if (leftTypeId.isNumericTypeId() &&\n-\t\t\t\t     rightTypeId.isCharOrVarChar()) {\n-\n-\t\t\t\trightOperand = (ValueNode) getNodeFactory().getNode(\n-\t\t\t\t\tC_NodeTypes.CAST_NODE,\n-\t\t\t\t\trightOperand,\n-\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.DOUBLE),\n-\t\t\t\t\tgetContextManager());\n-\t\t\t\t((CastNode) rightOperand).bindCastNodeOnly();\n-\t\t\t\trightTypeId = rightOperand.getTypeId();\n-\t\t\t}\n-\t\t}\n-\t\telse if (! rightTypeId.isStringTypeId() && leftTypeId.isStringTypeId())\n-\t\t{\n-\t\t\tif (rightTypeId.isBooleanTypeId() || rightTypeId.isDateTimeTimeStampTypeId()) {\n-\t\t\t\tleftOperand =  (ValueNode)\n-\t\t\t\t\t\tgetNodeFactory().getNode(\n-\t\t\t\t\t\t\t\tC_NodeTypes.CAST_NODE,\n-\t\t\t\t\t\t\t\tleftOperand,\n-\t\t\t\t\t\t\t\tnew DataTypeDescriptor(\n-\t\t\t\t\t\t\t\t\t\trightTypeId,\n-\t\t\t\t\t\t\t\t\t\ttrue,\n-\t\t\t\t\t\t\t\t\t\trightOperand.getTypeServices().getMaximumWidth()),\n-\t\t\t\t\t\t\t\tgetContextManager());\n-\t\t\t\t((CastNode) leftOperand).bindCastNodeOnly();\n-\t\t\t\tleftTypeId = leftOperand.getTypeId();\n-\t\t\t}\n-\t\t\telse if (rightTypeId.isNumericTypeId() &&\n-\t\t\t\t     leftTypeId.isCharOrVarChar()) {\n-\n-\t\t\t\tleftOperand = (ValueNode) getNodeFactory().getNode(\n-\t\t\t\t\tC_NodeTypes.CAST_NODE,\n-\t\t\t\t\tleftOperand,\n-\t\t\t\t\tDataTypeDescriptor.getBuiltInDataTypeDescriptor(Types.DOUBLE),\n-\t\t\t\t\tgetContextManager());\n-\t\t\t\t((CastNode) leftOperand).bindCastNodeOnly();\n-\t\t\t\tleftTypeId = leftOperand.getTypeId();\n-\t\t\t}\n-\t\t}\n+        TypeId rightTypeId = rightOperand.getTypeId();\n+\n+        if (! leftTypeId.isStringTypeId() && rightTypeId.isStringTypeId())\n+        {\n+            rightOperand = addCastNodeForStringToNonStringComparison(leftOperand, rightOperand);\n+            rightTypeId = rightOperand.getTypeId();\n+        }\n+        else if (! rightTypeId.isStringTypeId() && leftTypeId.isStringTypeId())\n+        {\n+            leftOperand.addCastNodeForStringToNonStringComparison(rightOperand, leftOperand);", "originalCommit": "763ed9e2584f400a2a529ce445d0fb9ed030b17f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI2OTQwMg==", "url": "https://github.com/splicemachine/spliceengine/pull/4735#discussion_r533269402", "bodyText": "Good point, I will add a test and fix that.", "author": "arnaud-splice", "createdAt": "2020-12-01T10:09:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI0OTExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1MTU3MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4735#discussion_r533251571", "bodyText": "We already checked this before calling this function, do you want it here too to emphasize it?", "author": "dgomezferro", "createdAt": "2020-12-01T09:54:51Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryListOperatorNode.java", "diffHunk": "@@ -240,6 +240,20 @@ public ValueNode bindExpression(FromList fromList,\n         return this;\n     }\n \n+    private void addCastOnRightOperandForStringToNonStringComparison() throws StandardException {\n+        if (singleLeftOperand) {", "originalCommit": "763ed9e2584f400a2a529ce445d0fb9ed030b17f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI2NjE1NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4735#discussion_r533266155", "bodyText": "Yes. Would you rather I make that an assertion?", "author": "arnaud-splice", "createdAt": "2020-12-01T10:06:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1MTU3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI3OTE3Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/4735#discussion_r533279176", "bodyText": "Either is fine with me, just wanted to make sure it was intended.", "author": "dgomezferro", "createdAt": "2020-12-01T10:17:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1MTU3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI1NzE2Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/4735#discussion_r533257166", "bodyText": "ValueNodeList.comparable() is only used here, I'd rather make it always return a boolean and explicitly raise an exception here (instead of adding the extra boolean parameter), to me it's surprising that comparable() would raise an exception instead of returning true/false", "author": "dgomezferro", "createdAt": "2020-12-01T09:59:14Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryListOperatorNode.java", "diffHunk": "@@ -252,8 +266,13 @@ public void bindComparisonOperator() throws StandardException{\n \n         /* Can the types be compared to each other? */\n         /* Multicolumn IN list cannot currently be constructed before bind time. */\n-        if (singleLeftOperand)\n-            rightOperandList.comparable(getLeftOperand());\n+        if (singleLeftOperand) {\n+            if (!rightOperandList.comparable(getLeftOperand(), false)) {", "originalCommit": "763ed9e2584f400a2a529ce445d0fb9ed030b17f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI3NzI1Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4735#discussion_r533277253", "bodyText": "Does it make sense to put this function in BinaryOperatorNode? It seems not used in any other context.", "author": "ascend1", "createdAt": "2020-12-01T10:16:24Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/ValueNode.java", "diffHunk": "@@ -1622,6 +1624,46 @@ public boolean collectExpressions(Map<Integer, Set<ValueNode>> exprMap) {\n         return collectSingleExpression(exprMap);\n     }\n \n+    /*\n+     * Add a cast node to the rightOperand if it's of string type and need to be compared\n+     * to leftOperand\n+     * If we are comparing a non-string with a string type, then we\n+     * must prevent the non-string value from being used to probe into\n+     * an index on a string column. This is because the string types\n+     * are all of low precedence, so the comparison rules of the non-string\n+     * value are used, so it may not find values in a string index because\n+     * it will be in the wrong order. So, cast the string value to its\n+     * own type. This is easier than casting it to the non-string type,\n+     * because we would have to figure out the right length to cast it to.\n+     * @return the new rightOperand\n+     */\n+    protected ValueNode addCastNodeForStringToNonStringComparison(\n+            ValueNode leftOperand, ValueNode rightOperand) throws StandardException {", "originalCommit": "763ed9e2584f400a2a529ce445d0fb9ed030b17f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzMyMzMyNw==", "url": "https://github.com/splicemachine/spliceengine/pull/4735#discussion_r533323327", "bodyText": "It is used in both BinaryComparisonOperatorNode and BinaryListOperatorNode whose closest common ancestor is ValueNode", "author": "arnaud-splice", "createdAt": "2020-12-01T11:03:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzI3NzI1Mw=="}], "type": "inlineReview"}, {"oid": "07ad5e53c4cf6efc64e1362e05badabe097c1e77", "url": "https://github.com/splicemachine/spliceengine/commit/07ad5e53c4cf6efc64e1362e05badabe097c1e77", "message": "DB-10914 Address comments", "committedDate": "2020-12-01T10:53:56Z", "type": "commit"}, {"oid": "db0cc47fe53024cb8195999c3d7176356ceb2d32", "url": "https://github.com/splicemachine/spliceengine/commit/db0cc47fe53024cb8195999c3d7176356ceb2d32", "message": "DB-10926 Support timestamp(LONG VARCHAR)", "committedDate": "2020-12-01T11:01:14Z", "type": "commit"}]}