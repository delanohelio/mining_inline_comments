{"pr_number": 4110, "pr_title": "DB-10175 Qualify expression-based indexes", "pr_createdAt": "2020-09-10T20:52:27Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4110", "timeline": [{"oid": "198a53e02ead69b95bf102b6df95704ea706d167", "url": "https://github.com/splicemachine/spliceengine/commit/198a53e02ead69b95bf102b6df95704ea706d167", "message": "DB-10175 Fix SpotBugs", "committedDate": "2020-09-17T12:39:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYxODg2Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r490618867", "bodyText": "Here we set proper ordering to base table columns according to index column ordering. For expression-based indexes, however, I'm not sure what to do here since whether an index column is ascending or descending doesn't really mean anything to the ordering of base table columns.", "author": "ascend1", "createdAt": "2020-09-17T23:36:47Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java", "diffHunk": "@@ -436,18 +435,20 @@ public boolean nextAccessPath(Optimizer optimizer,\n                 boolean[] isAscending=irg.isAscending();\n \n                 for(int i=0;i<baseColumnPositions.length;i++){\n-                    int rowOrderDirection=isAscending[i]?RowOrdering.ASCENDING:RowOrdering.DESCENDING;\n-                    int pos = rowOrdering.orderedPositionForColumn(rowOrderDirection,getTableNumber(),baseColumnPositions[i]);\n-                    if (pos == -1) {\n-                        rowOrdering.nextOrderPosition(rowOrderDirection);\n-                        pos = rowOrdering.addOrderedColumn(rowOrderDirection,getTableNumber(),baseColumnPositions[i]);\n-                    }\n-                    // check if the column has a constant predicate like \"col=constant\" defined on it,\n-                    // if so, we can treat it as sorted as it has only one value\n-                    if (pos >=0 &&    /* a column ordering is added or exists */\n-                        hasConstantPredicate(getTableNumber(), baseColumnPositions[i], predList)) {\n-                        ColumnOrdering co = rowOrdering.getOrderedColumn(pos);\n-                        co.setBoundByConstant(true);\n+                    if (!irg.isOnExpression()) {", "originalCommit": "198a53e02ead69b95bf102b6df95704ea706d167", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA4Njc1MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r493086750", "bodyText": "I think we are not leveraging the sortorder of the index on expression right now (which could be useful for qualifying merge join and to do orderby elimination), that is fine, but we should track this as a limitation or future enhancement.", "author": "yxia92", "createdAt": "2020-09-22T23:21:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYxODg2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU3NTE1MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r493575151", "bodyText": "OK, I created a Jira ticket to track this issue. I need to investigate a bit more on how we can respect the sort order defined on index expressions.", "author": "ascend1", "createdAt": "2020-09-23T13:15:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYxODg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyMDI5MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r490620291", "bodyText": "For now, simply take all expression-based indexes as non-covering indexes. Doing so limits the scope of this change to a manageable size for code review. Treating an expression-based index as a covering index is DB-10236 and will have its own PR.", "author": "ascend1", "createdAt": "2020-09-17T23:41:26Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java", "diffHunk": "@@ -516,8 +517,11 @@ public boolean isCoveringIndex(ConglomerateDescriptor cd) throws StandardExcepti\n             return false;\n \n         IndexRowGenerator irg=cd.getIndexDescriptor();\n-        int[] baseCols=irg.baseColumnPositions();\n \n+        if (irg.isOnExpression())\n+            return false;", "originalCommit": "198a53e02ead69b95bf102b6df95704ea706d167", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYyMTYwNA==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r490621604", "bodyText": "This comment is true only for this change because all expression-based indexes are non-covering indexes. In next step, to rewrite an index expression to a column reference, we do the following:\nrc.setIndexExpression(exprAst);\nrc.setReferenced();\nrc.setVirtualColumnId(i + 1);  // virtual column IDs are 1-based\nrc.setName(idxCD.getConglomerateName() + \"_col\" + rc.getColumnPosition());", "author": "ascend1", "createdAt": "2020-09-17T23:45:38Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java", "diffHunk": "@@ -1952,43 +1980,61 @@ private ResultColumnList newResultColumns(\n             boolean cloneRCs)\n             throws StandardException{\n         IndexRowGenerator irg=idxCD.getIndexDescriptor();\n-        int[] baseCols=irg.baseColumnPositions();\n-        ResultColumnList newCols=\n-                (ResultColumnList)getNodeFactory().getNode(\n+        ResultColumnList newCols =\n+                (ResultColumnList) getNodeFactory().getNode(\n                         C_NodeTypes.RESULT_COLUMN_LIST,\n                         getContextManager());\n \n-        for(int basePosition : baseCols){\n-            ResultColumn oldCol=oldColumns.getResultColumn(basePosition);\n-            ResultColumn newCol;\n+        if (irg.isOnExpression()) {\n+            // When building new ResultColumn instances, we don't need to set expression\n+            // or virtual column number as they are not needed. In case of a scan on an\n+            // expression-based index, these are just placeholders. All we care about is\n+            // that they should all be referenced for now so that we can build the\n+            // template row, then we will clear reference status and set them properly.", "originalCommit": "198a53e02ead69b95bf102b6df95704ea706d167", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f5f3a3b8c1b41b91e877b949971df30bb4f1fe1d", "url": "https://github.com/splicemachine/spliceengine/commit/f5f3a3b8c1b41b91e877b949971df30bb4f1fe1d", "message": "DB-10175 Fix SpotBugs", "committedDate": "2020-09-21T09:40:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NzU3NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r493067575", "bodyText": "This logic is not consistent with the original logic. When forIndexExpression is false, the logic will still set otherSide if left has more than one column reference, as long as the first column reference matches the input column reference. With the original logic, otherSide won't be set if there are more than one column references. Is this change intended?", "author": "yxia92", "createdAt": "2020-09-22T22:24:58Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryRelationalOperatorNode.java", "diffHunk": "@@ -502,12 +523,27 @@ public boolean selfComparison(ColumnReference cr)\n         ** Figure out which side the given ColumnReference is on,\n         ** and look for the same table on the other side.\n         */\n-        if(lcr != null && lcr.size() == 1 && lcr.get(0) == cr){\n-            otherSide=rightOperand;\n-        }else {\n+        if(lcr != null && !lcr.isEmpty()){\n+            int bound = forIndexExpression ? lcr.size() : 1;\n+            for (int i = 0; i < bound; i++) {\n+                if (lcr.get(i) == cr) {\n+                    otherSide = rightOperand;\n+                    break;\n+                }\n+            }\n+        }", "originalCommit": "f5f3a3b8c1b41b91e877b949971df30bb4f1fe1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzU3OTQ0NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r493579445", "bodyText": "You are right, behavior of this function is changed and it's not intended. It's fixed in next commit.", "author": "ascend1", "createdAt": "2020-09-23T13:20:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA2NzU3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA4ODI2NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r493088264", "bodyText": "It seems that usefulStartKey() calls BinaryRelationalOperatorNode.usefulStartKey() which relies on leftMatchIndexExpr and rightMatchIndexExpr, however, these two variables are only set in matchIndexExpression() which is called a few lines below.", "author": "yxia92", "createdAt": "2020-09-22T23:26:54Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/PredicateList.java", "diffHunk": "@@ -183,7 +200,7 @@ public boolean useful(Optimizable optTable,ConglomerateDescriptor cd) throws Sta\n             ** nor a useful stop key for this table, it is not useful\n             ** for limiting an index scan.\n             */\n-            if((!isIn) && (!relop.usefulStartKey(optTable)) && (!relop.usefulStopKey(optTable))){\n+            if((!isIn) && (!relop.usefulStartKey(optTable, id)) && (!relop.usefulStopKey(optTable, id))){", "originalCommit": "f5f3a3b8c1b41b91e877b949971df30bb4f1fe1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYwOTI3NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r493609275", "bodyText": "Oh, that's a good catch! In next commit, I have moved this check down below, after matchIndexExpression is called.", "author": "ascend1", "createdAt": "2020-09-23T13:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA4ODI2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5Mzk2MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r493093960", "bodyText": "Looking at the caller of matchIndexExpression(), the list of column references found does not seem to be really useful, would a boolean as returned value sufficient?", "author": "yxia92", "createdAt": "2020-09-22T23:44:51Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/PredicateList.java", "diffHunk": "@@ -564,6 +612,58 @@ public static Integer isIndexUseful(Predicate pred,\n         return indexPosition;\n     }\n \n+    // Return an empty list if relOp doesn't match index expression. This is OK because an index expression must\n+    // have at least one column reference. Also, since an index is defined on one table, an index expression\n+    // cannot have column references referencing different tables.\n+    private static List<ColumnReference> matchIndexExpression(RelationalOperator relOp, InListOperatorNode inNode,\n+                                                              boolean isIn, boolean isProbe,\n+                                                              ValueNode indexExprAst, Optimizable optTable)\n+            throws StandardException\n+    {\n+        CollectNodesVisitor cnv = new CollectNodesVisitor(ColumnReference.class);\n+        int tableNumber = optTable.getTableNumber();  // OK to be -1, will be checked when use\n+        if (isIn) {\n+            if (inNode.getLeftOperand().equals(indexExprAst)) {\n+                inNode.getLeftOperand().accept(cnv);\n+                if (isProbe) {\n+                    assert relOp instanceof BinaryOperatorNode;\n+                    BinaryOperatorNode binOp = (BinaryOperatorNode) relOp;\n+                    binOp.setMatchIndexExpr(tableNumber, true);\n+                }\n+            }\n+        } else {\n+            if (relOp instanceof BinaryOperatorNode) {\n+                BinaryOperatorNode binOp = (BinaryOperatorNode) relOp;\n+                if (binOp.getLeftOperand().equals(indexExprAst)) {\n+                    binOp.getLeftOperand().accept(cnv);\n+                    binOp.setMatchIndexExpr(tableNumber, true);\n+                } else if (binOp.getRightOperand().equals(indexExprAst)) {\n+                    binOp.getRightOperand().accept(cnv);\n+                    binOp.setMatchIndexExpr(tableNumber, false);\n+                }\n+            } else if (relOp instanceof IsNullNode) {\n+                IsNullNode isNull = (IsNullNode) relOp;\n+                if (isNull.getOperand().equals(indexExprAst)) {\n+                    isNull.getOperand().accept(cnv);\n+                    // No need to set any matchIndexExpr flag since it won't be used in code generation.\n+                }\n+            }\n+        }\n+        return cnv.getList();", "originalCommit": "f5f3a3b8c1b41b91e877b949971df30bb4f1fe1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzYyMDY5Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r493620692", "bodyText": "Right, the list is not useful. I changed the return value to boolean in the next commit.\nI was thinking that we have to pass in a valid ColumnReference to selfReference() and selfComparison(), otherwise the logic might be broken. But I just checked again these two functions and it seems they only care about tableNumber, which is correctly set in the index expression AST.", "author": "ascend1", "createdAt": "2020-09-23T14:05:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5Mzk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NjI4Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r493096287", "bodyText": "Is it possible to cache the constructed AST tree? It seems expensive to re-construct the tree every time we evaluate the predicate list for an index. When there are N-way join and the number of join order permutations goes up, we could get here very frequently.", "author": "yxia92", "createdAt": "2020-09-22T23:52:51Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/PredicateList.java", "diffHunk": "@@ -522,21 +549,42 @@ public static Integer isIndexUseful(Predicate pred,\n             return null;\n \n         /* Look for an index column on one side of the relop */\n-        if (baseColumnPositions != null) {\n-            for (indexPosition = 0; indexPosition < baseColumnPositions.length; indexPosition++) {\n-                if (isIn) {\n-                    if (inNode.getLeftOperand() instanceof ColumnReference) {\n-                        indexCol = (ColumnReference) inNode.getLeftOperand();\n-                        if ((optTable.getTableNumber() != indexCol.getTableNumber())\n-                                || (indexCol.getColumnNumber() != baseColumnPositions[indexPosition])\n-                                || inNode.selfReference(indexCol))\n-                            indexCol = null;\n+        if (isIndexOnExpr) {\n+            LanguageConnectionContext lcc = pred.getLanguageConnectionContext();\n+            CompilerContext newCC = lcc.pushCompilerContext();\n+            Parser p = newCC.getParser();\n+\n+            String[] exprTexts = indexDescriptor.getExprTexts();\n+            for (indexPosition = 0; indexPosition < exprTexts.length; indexPosition++) {", "originalCommit": "f5f3a3b8c1b41b91e877b949971df30bb4f1fe1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY3MzgwMQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r493673801", "bodyText": "Yes, we definitely need to cache them. I have been thinking about it and created a Jira ticket to track things that could be improved: https://splicemachine.atlassian.net/browse/DB-10312.\nI didn't do it in this PR because I was not sure about where to cache these ASTs. I was thinking that they would be required in many other places not touched in this change, and if I implement something back then, it probably needs to be changed later.\nNow that I'm almost in the last major piece of this whole story, my idea is to cache the index expression ASTs in ConglomerateDescriptor. They will not be serialized or deserialized with other fields. Instead, we have always an empty Valuenode array when getting an instance either by constructing or deserialzing. Index expression will be parsed and stored in the array in the first time we use them, and later we just get from the array.\nI think it's a good place because we set ConglomerateDescriptor in access path once and almost every following operations on this access path get this instance. It's global enough, yet much better scoped than the context.\nI'd like to have your opinions on this before I start the implementation.", "author": "ascend1", "createdAt": "2020-09-23T15:11:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NjI4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDcyNDMzNA==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r500724334", "bodyText": "Thanks @ascend1 ! It makes sense to me to cache it in the ConglomerateDescriptor. I couldn't think of any side effect of this approach, but it would be great to run through @dgomezferro and @jyuanca also and see if they see any downside about this approach.", "author": "yxia92", "createdAt": "2020-10-07T04:01:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5NjI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5OTU2MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r493099561", "bodyText": "Can you reset the flag matchIndexExpression in clearScanFlags()?", "author": "yxia92", "createdAt": "2020-09-23T00:03:56Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/Predicate.java", "diffHunk": "@@ -81,6 +81,8 @@\n     // getPredScopedForResultSet() method of this class for more.\n     private boolean scoped;\n \n+    private boolean matchIndexExpression;", "originalCommit": "f5f3a3b8c1b41b91e877b949971df30bb4f1fe1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzY1NDEzOA==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r493654138", "bodyText": "Done.", "author": "ascend1", "createdAt": "2020-09-23T14:47:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzA5OTU2MQ=="}], "type": "inlineReview"}, {"oid": "f2259ad89ece5e2bbbe977981c5511bb4becbc3a", "url": "https://github.com/splicemachine/spliceengine/commit/f2259ad89ece5e2bbbe977981c5511bb4becbc3a", "message": "DB-10175 Address comments", "committedDate": "2020-09-23T16:09:03Z", "type": "forcePushed"}, {"oid": "5c7e264195c5cd1059332c52d5307791bf296e95", "url": "https://github.com/splicemachine/spliceengine/commit/5c7e264195c5cd1059332c52d5307791bf296e95", "message": "DB-10175 Expression-based index scan with relational operator preds", "committedDate": "2020-10-07T14:08:11Z", "type": "commit"}, {"oid": "e22d448f521f0b4e81a9edae44a00a40fbe90cfd", "url": "https://github.com/splicemachine/spliceengine/commit/e22d448f521f0b4e81a9edae44a00a40fbe90cfd", "message": "DB-10175 Expression-based index scan with in-list predicates", "committedDate": "2020-10-07T14:08:11Z", "type": "commit"}, {"oid": "57ce9e16fc3de1c64638575483938d57d6795e42", "url": "https://github.com/splicemachine/spliceengine/commit/57ce9e16fc3de1c64638575483938d57d6795e42", "message": "DB-10175 Fix SpotBugs", "committedDate": "2020-10-07T14:08:11Z", "type": "commit"}, {"oid": "44ec6f37735acf851ff4a82268c0d544693b4790", "url": "https://github.com/splicemachine/spliceengine/commit/44ec6f37735acf851ff4a82268c0d544693b4790", "message": "DB-10175 Address comments", "committedDate": "2020-10-07T14:08:11Z", "type": "commit"}, {"oid": "44ec6f37735acf851ff4a82268c0d544693b4790", "url": "https://github.com/splicemachine/spliceengine/commit/44ec6f37735acf851ff4a82268c0d544693b4790", "message": "DB-10175 Address comments", "committedDate": "2020-10-07T14:08:11Z", "type": "forcePushed"}, {"oid": "b965fdf6ac44f431b541813d79344aec6776bde4", "url": "https://github.com/splicemachine/spliceengine/commit/b965fdf6ac44f431b541813d79344aec6776bde4", "message": "Merge branch 'master' into DB-10175", "committedDate": "2020-10-15T11:22:30Z", "type": "commit"}, {"oid": "1516c436841f204c294d1ac4329eeea983ef3802", "url": "https://github.com/splicemachine/spliceengine/commit/1516c436841f204c294d1ac4329eeea983ef3802", "message": "Merge branch 'master' into DB-10175", "committedDate": "2020-10-22T09:06:54Z", "type": "commit"}, {"oid": "c5d12ed61478bccf565395f8029144a5314879b4", "url": "https://github.com/splicemachine/spliceengine/commit/c5d12ed61478bccf565395f8029144a5314879b4", "message": "Merge branch 'master' into DB-10175", "committedDate": "2020-10-23T12:46:54Z", "type": "commit"}, {"oid": "4c65948d27940e0e3567baa1adc0839afc56da45", "url": "https://github.com/splicemachine/spliceengine/commit/4c65948d27940e0e3567baa1adc0839afc56da45", "message": "Merge branch 'master' into DB-10175", "committedDate": "2020-10-26T08:16:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQyMTE0MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r512421140", "bodyText": "The variable declaration of cnv should be moved inside the for loop, otherwise, we won't be able to detect empty column references correctly for second element and upper.", "author": "yxia92", "createdAt": "2020-10-27T05:13:54Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryListOperatorNode.java", "diffHunk": "@@ -110,9 +110,11 @@ public ValueNode getLeftOperand() {\n         return (ValueNode) (singleLeftOperand ? leftOperandList.elementAt(0) : null);\n     }\n     \n-    public boolean allLeftOperandsColumnReferences() {\n-        for (Object obj:leftOperandList) {\n-            if (!(obj instanceof  ColumnReference))\n+    public boolean allLeftOperandsContainColumnReferences() throws StandardException {\n+        CollectNodesVisitor cnv = new CollectNodesVisitor(ColumnReference.class);\n+        for (int i = 0; i < leftOperandList.size(); i++) {\n+            leftOperandList.elementAt(i).accept(cnv);\n+            if (cnv.getList().isEmpty())", "originalCommit": "4c65948d27940e0e3567baa1adc0839afc56da45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjgzMDcxNQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r512830715", "bodyText": "Ah, yes, this is buggy. I add cnv.getList().clear() in the loop. It should clear the vector and avoid constructing new object for each iteration.", "author": "ascend1", "createdAt": "2020-10-27T16:13:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQyMTE0MA=="}], "type": "inlineReview"}, {"oid": "d9f90256bb404ab2ad137a4fee677c2b0dc3a3d5", "url": "https://github.com/splicemachine/spliceengine/commit/d9f90256bb404ab2ad137a4fee677c2b0dc3a3d5", "message": "Merge branch 'master' into DB-10175", "committedDate": "2020-10-27T15:47:00Z", "type": "commit"}, {"oid": "bf9602776fbe57fac0d07cbe0dff0c086932f8e4", "url": "https://github.com/splicemachine/spliceengine/commit/bf9602776fbe57fac0d07cbe0dff0c086932f8e4", "message": "DB-10175 Address comments", "committedDate": "2020-10-27T15:56:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc1OTkxMA==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r512759910", "bodyText": "Method keyColumnOnLeft should be updated to handle all types of expressions.  It relies on getHashableJoinColumnReference() to collect the columns in the expression, but it doesn't seem to be working.\nExample:\n\ncreate table t1 (a int, b int, primary key(a));\ncreate index t1_idx on t1(a+b);\nexplain select * from t1 where a+b = 1;\nERROR XJ001: DERBY SQL error: SQLCODE: -1, SQLSTATE: XJ001, SQLERRMC: java.lang.IllegalStateExceptionASSERT FAILED Key column not found on either side.XJ001.U", "author": "msirek", "createdAt": "2020-10-27T14:51:46Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryRelationalOperatorNode.java", "diffHunk": "@@ -527,19 +565,34 @@ public boolean selfComparison(ColumnReference cr)\n     /**\n      * @see RelationalOperator#usefulStartKey\n      */\n-    public boolean usefulStartKey(Optimizable optTable) {\n+    public boolean usefulStartKey(Optimizable optTable, IndexDescriptor id) {\n \n         BinaryRelationalOperatorNodeUtil.coerceDataTypeIfNecessary(this);\n \n         /*\n         ** Determine whether this operator is a useful start operator\n         ** with knowledge of whether the key column is on the left or right.\n         */\n-        int columnSide = columnOnOneSide(optTable);\n+        boolean isIndexOnExpr = id != null && id.isOnExpression();\n+        int columnSide = isIndexOnExpr ? indexExprOnOneSide(optTable) : columnOnOneSide(optTable);\n \n         return columnSide != NEITHER && usefulStartKey(columnSide == LEFT);\n     }\n \n+     /**\n+      * @see RelationalOperator#usefulStopKey\n+      */\n+     public boolean usefulStopKey(Optimizable optTable, IndexDescriptor id) {\n+         /*\n+          ** Determine whether this operator is a useful start operator\n+          ** with knowledge of whether the key column is on the left or right.\n+          */\n+         boolean isIndexOnExpr = id != null && id.isOnExpression();\n+         int columnSide = isIndexOnExpr ? indexExprOnOneSide(optTable) : columnOnOneSide(optTable);\n+\n+         return columnSide != NEITHER && usefulStopKey(columnSide == LEFT);\n+     }\n+\n     /**\n      * Return true if a key column for the given table is found on the\n      * left side of this operator, false if it is found on the right", "originalCommit": "4c65948d27940e0e3567baa1adc0839afc56da45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU0NDU5Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r513544597", "bodyText": "Yes, I encountered this problem and adapted this method in a later change: https://github.com/splicemachine/spliceengine/pull/4302/files#diff-1a44e74c70698678a5e81411dcd41091a5b75308c80a5717a30f842b31256dfc. But still, I think it's better to apply the fix here and I make a new test for a case like a+b.", "author": "ascend1", "createdAt": "2020-10-28T15:35:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjc1OTkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg5MjE5MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r512892191", "bodyText": "The equals method will only match 2 different JavaToSQLValueNodes if they are the exact same object:\n\nprotected boolean isEquivalent(ValueNode o)\n{\n    // anything in the java domain is not equiavlent.\n    return false;//this == o;\n}\n\n\nTherefore, if you have something like:\n\ncreate index t1_idx on t1(ln(a));\nexplain select * from t1 --splice-properties index=t1_idx\nwhere ln(a) > 1;\n\nIt cannot take advantage of the index.  It may be better to write a new method for comparing expressions, that defaults to using the equals method for all nodes, but then for JavaToSQLValueNode we could override the implementation and do the proper expression comparison.  Note that non-deterministic functions should not ever be considered the same expression.", "author": "msirek", "createdAt": "2020-10-27T17:34:31Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/PredicateList.java", "diffHunk": "@@ -564,6 +613,53 @@ public static Integer isIndexUseful(Predicate pred,\n         return indexPosition;\n     }\n \n+    private static boolean matchIndexExpression(RelationalOperator relOp, InListOperatorNode inNode,\n+                                                boolean isIn, boolean isProbe,\n+                                                ValueNode indexExprAst, Optimizable optTable) {\n+        boolean match = false;\n+        int tableNumber = optTable.getTableNumber();  // OK to be -1, will be checked when use\n+        if (isIn) {\n+            if (inNode.getLeftOperand().equals(indexExprAst)) {\n+                match = true;\n+                if (isProbe) {\n+                    assert relOp instanceof BinaryOperatorNode;\n+                    BinaryOperatorNode binOp = (BinaryOperatorNode) relOp;\n+                    binOp.setMatchIndexExpr(tableNumber, true);\n+                }\n+            }\n+        } else {\n+            if (relOp instanceof BinaryOperatorNode) {\n+                BinaryOperatorNode binOp = (BinaryOperatorNode) relOp;\n+                if (binOp.getLeftOperand().equals(indexExprAst)) {", "originalCommit": "bf9602776fbe57fac0d07cbe0dff0c086932f8e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU0OTkxOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r513549919", "bodyText": "Absolutely. I just found this yesterday when implementing hashCode() and it made my eyes open. There are also some other classes compare using ==. I'm working on a fix.", "author": "ascend1", "createdAt": "2020-10-28T15:42:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjg5MjE5MQ=="}], "type": "inlineReview"}, {"oid": "4236cac5c473ac58a99061323b366d5edc70eda8", "url": "https://github.com/splicemachine/spliceengine/commit/4236cac5c473ac58a99061323b366d5edc70eda8", "message": "Merge branch 'master' into DB-10175\n\nConflicts:\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/Predicate.java", "committedDate": "2020-10-28T14:38:13Z", "type": "commit"}, {"oid": "2cf8db9f4c07e7ecbdf84a340c73c407a3ee70ca", "url": "https://github.com/splicemachine/spliceengine/commit/2cf8db9f4c07e7ecbdf84a340c73c407a3ee70ca", "message": "DB-10175 Address comments / add semanticallyEquals()\n\nDB-10312 Cache index expression ASTs is partially applied here so that\nthe code binding index expressions is not duplicated everywhere.", "committedDate": "2020-10-29T20:24:59Z", "type": "commit"}, {"oid": "83a20d4c2342308c196697fa55929e49e997c901", "url": "https://github.com/splicemachine/spliceengine/commit/83a20d4c2342308c196697fa55929e49e997c901", "message": "Merge branch 'master' into DB-10175", "committedDate": "2020-10-29T20:26:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkxNzQwOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r514917409", "bodyText": "@ascend1 Could you check if IndexDescriptorImpl is cached as part of the TableDescriptor in dictionary cache? If so, it is shared among all the queries and the these code could cause the data structure to be modified concurrently, and that could be problematic.", "author": "yxia92", "createdAt": "2020-10-30T07:40:16Z", "path": "db-engine/src/main/java/com/splicemachine/db/catalog/types/IndexDescriptorImpl.java", "diffHunk": "@@ -553,10 +564,90 @@ public BaseExecutableIndexExpression getExecutableIndexExpression(int indexColum\n                 : \"index has expression but generated class name is unknown\";\n         LanguageConnectionContext lcc = (LanguageConnectionContext) ContextService.getContext\n                 (LanguageConnectionContext.CONTEXT_ID);\n+        assert lcc != null;\n         ClassFactory classFactory = lcc.getLanguageConnectionFactory().getClassFactory();\n         GeneratedClass gc = classFactory.loadGeneratedClass(\n                 generatedClassNames[indexColumnPosition], exprBytecode[indexColumnPosition]);\n         executableExprs[indexColumnPosition] = (BaseExecutableIndexExpression) gc.newInstance(lcc);\n         return executableExprs[indexColumnPosition];\n     }\n+\n+    /** @see IndexDescriptor#getParsedIndexExpressions */\n+    @Override\n+    public ValueNode[] getParsedIndexExpressions(LanguageConnectionContext context, Optimizable optTable)\n+            throws StandardException\n+    {\n+        LanguageConnectionContext lcc = context;\n+        if (lcc == null) {\n+            lcc = (LanguageConnectionContext) ContextService.getContext(LanguageConnectionContext.CONTEXT_ID);\n+        }\n+        assert lcc != null;\n+\n+        if (exprAsts != null) {\n+            for (ValueNode ast : exprAsts) {\n+                setTableNumberToIndexExpr(ast, optTable);\n+                bindNecessaryNodesInIndexExpr(ast, optTable, lcc);", "originalCommit": "2cf8db9f4c07e7ecbdf84a340c73c407a3ee70ca", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk4Mzk5OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r514983999", "bodyText": "@yxia92 I looked into the code again and I think IndexDescriptorImpl will be effectively cached because it's part of ConglomerateDescriptor, and TableDescriptor has a conglomerateDescriptorList. Thanks for pointing this out, it's indeed a serious problem.\nFor this change, I can remove the cache and let the method always parse. I mean, at this point, it doesn't seem to be a bad idea because it's correct and simple. Options to improve it could be:\n\nCache the ASTs in a statement-level cache so that different queries do not step on each other's feet. I'm not sure which objects' life cycle align with a statement and are always accessible during optimization. Maybe CompilerContext? It's managed in a stack, doesn't seem to be per statement. LCC? It's probably alive for the whole session?\nImplement clone() method to ValueNode class hierarchy and always return a deep copy of ASTs. IMHO, code would be more readable and maintainable in this way. Also, clone() is needed (I encountered two places) by some logic and currently we cannot do that for index expressions. But then back to the beginning, this probably has only marginal performance improvement comparing to always parsing since in both way we need to construct the same amount of objects. Only the grammar matching of parsing is saved, which is probably not much anyway, since javacc doesn't do backtracking and index expressions are usually short.", "author": "ascend1", "createdAt": "2020-10-30T09:56:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkxNzQwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIwMDM1MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4110#discussion_r515200350", "bodyText": "Thanks @ascend1 for checking! I'm good with moving this change out from the current PR. CompilerContext as I understand is per-query, and it should be like a global structure visible during the query compilation phase for a particular query.", "author": "yxia92", "createdAt": "2020-10-30T15:52:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDkxNzQwOQ=="}], "type": "inlineReview"}, {"oid": "35654b5f5111273d24a3a795f0ab4adcca2f8f70", "url": "https://github.com/splicemachine/spliceengine/commit/35654b5f5111273d24a3a795f0ab4adcca2f8f70", "message": "DB-10175 Address comments / fix potential concurrent issue\n\nIndex expression ASTs should not be cached in IndexDescriptor because\nit is in turns cached in data dictionary cache, which is global to all\nqueries. For now, always return a copy of ASTs.", "committedDate": "2020-10-30T10:09:08Z", "type": "commit"}, {"oid": "86df5f4b3bda233a95c8e656ae2508c3b8d9cb7a", "url": "https://github.com/splicemachine/spliceengine/commit/86df5f4b3bda233a95c8e656ae2508c3b8d9cb7a", "message": "DB-10175 Fix Spotbugs", "committedDate": "2020-10-30T11:32:58Z", "type": "commit"}, {"oid": "dd55b56d0814b85960768b2b73ba68ec42f8eb38", "url": "https://github.com/splicemachine/spliceengine/commit/dd55b56d0814b85960768b2b73ba68ec42f8eb38", "message": "Merge branch 'master' into DB-10175", "committedDate": "2020-11-03T08:43:46Z", "type": "commit"}]}