{"pr_number": 4807, "pr_title": "DB-10579 Use truly nested transactions for triggers.", "pr_createdAt": "2020-12-08T07:52:58Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4807", "timeline": [{"oid": "da1c1caa4fd730fe7d1dbafc29ee305b0691fbb4", "url": "https://github.com/splicemachine/spliceengine/commit/da1c1caa4fd730fe7d1dbafc29ee305b0691fbb4", "message": "DB-10579 Use truly nested transactions for triggers.", "committedDate": "2020-12-08T07:54:33Z", "type": "forcePushed"}, {"oid": "2f2becd2604b9a227fa25f2d6a3711bf816b6b0b", "url": "https://github.com/splicemachine/spliceengine/commit/2f2becd2604b9a227fa25f2d6a3711bf816b6b0b", "message": "DB-10579 Use truly nested transactions for triggers.", "committedDate": "2020-12-08T21:45:16Z", "type": "commit"}, {"oid": "2a0f7816631550427223453c183fbcecc39c5b26", "url": "https://github.com/splicemachine/spliceengine/commit/2a0f7816631550427223453c183fbcecc39c5b26", "message": "DB-10579 Cleanup", "committedDate": "2020-12-08T21:45:25Z", "type": "commit"}, {"oid": "7f844a9368531c311ba3c7fc07ff329ca61a3333", "url": "https://github.com/splicemachine/spliceengine/commit/7f844a9368531c311ba3c7fc07ff329ca61a3333", "message": "DB-10579 Fix Spotbugs", "committedDate": "2020-12-08T21:45:36Z", "type": "commit"}, {"oid": "7f844a9368531c311ba3c7fc07ff329ca61a3333", "url": "https://github.com/splicemachine/spliceengine/commit/7f844a9368531c311ba3c7fc07ff329ca61a3333", "message": "DB-10579 Fix Spotbugs", "committedDate": "2020-12-08T21:45:36Z", "type": "forcePushed"}, {"oid": "211edba5647ee24ab8b38a66331ff3923e7b0ee6", "url": "https://github.com/splicemachine/spliceengine/commit/211edba5647ee24ab8b38a66331ff3923e7b0ee6", "message": "DB-10579 Fix leak checks.", "committedDate": "2020-12-09T03:35:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDEwNjYwMQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4807#discussion_r554106601", "bodyText": "Indentation is weird in this newly added block. Comment lines start to shift to the right and method parameters are not aligned.", "author": "ascend1", "createdAt": "2021-01-08T18:06:08Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/store/access/TransactionController.java", "diffHunk": "@@ -804,6 +804,52 @@ TransactionController startNestedUserTransaction(\n \t\t\tboolean flush_log_on_xact_end)\n         throws StandardException;\n \n+    /**\n+     * Get a nested internal transaction.\n+     * <p>\n+     * A nested internal transaction is used in place of a user transaction\n+\t * when a DML statement is executing its operation tree and a new writable\n+\t * child transaction needs to be created with the possibility that within", "originalCommit": "211edba5647ee24ab8b38a66331ff3923e7b0ee6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI1OTExNQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4807#discussion_r554259115", "bodyText": "Thanks, I've fixed the indentation in the whole file.", "author": "msirek", "createdAt": "2021-01-09T00:25:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDEwNjYwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDExMTgzMg==", "url": "https://github.com/splicemachine/spliceengine/pull/4807#discussion_r554111832", "bodyText": "I don't quite understand this branch. It seems right in case of !needsfullyNestedTransaction. But if it's needsfullyNestedTransaction && lcc.hasNestedTransaction(), I assume that's because some other write operation enters the branch above earlier? In that case, what does the code mean in this branch? Does it start a child transaction in a different way and push into a different stack? But what happens if a third write operation comes?\nSorry this might be a stupid question. I haven't worked on transactions in Splice yet.", "author": "ascend1", "createdAt": "2021-01-08T18:16:31Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/operations/DMLWriteOperation.java", "diffHunk": "@@ -179,15 +182,44 @@ protected TxnView getTransactionForWrite(DataSetProcessor dsp) throws StandardEx\n         try {\n             if (dsp.getType() == DataSetProcessor.Type.SPARK || isOlapServer())\n             {\n-                nestedTxn =\n+                WriteCursorConstantOperation constantAction=(WriteCursorConstantOperation)writeInfo.getConstantAction();\n+                TriggerInfo triggerInfo=constantAction.getTriggerInfo();\n+                boolean needsfullyNestedTransaction = triggerInfo != null;\n+\n+                LanguageConnectionContext lcc = getActivation().getLanguageConnectionContext();\n+                TransactionController transactionExecute = lcc.getTransactionExecute();\n+                if (needsfullyNestedTransaction && !lcc.hasNestedTransaction()) {\n+                    // Start a nested transaction controller that deals only with internal\n+                    // transactions, not savepoints.\n+                    transactionController =\n+                        transactionExecute.startNestedInternalTransaction(false,\n+                                            Bytes.toBytes(Long.toString(heapConglom)),\n+                                            false);\n+                    lcc.pushNestedTransaction(transactionController);\n+                    Transaction rawStoreXact = ((TransactionManager) transactionController).getRawStoreXact();\n+                    if (!(((BaseSpliceTransaction) rawStoreXact).getActiveStateTxn() instanceof Txn))\n+                        throw StandardException.newException(LANG_INTERNAL_ERROR,\n+                                        \"DMLWriteOperation cannot make child Txn out of TxnView.\");\n+                    Txn childTxn = (Txn) ((BaseSpliceTransaction) rawStoreXact).getActiveStateTxn();\n+                    nestedTxn = childTxn;\n+                    txn = (TxnView) childTxn;\n+                }\n+                else {\n+                    nestedTxn =\n                     SIDriver.driver().lifecycleManager().beginChildTransaction(\n-                            parent,\n-                            parent.getIsolationLevel(),\n-                            parent.isAdditive(),", "originalCommit": "211edba5647ee24ab8b38a66331ff3923e7b0ee6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI5NTExOA==", "url": "https://github.com/splicemachine/spliceengine/pull/4807#discussion_r554295118", "bodyText": "@ascend1 Not a stupid question at all.  The first time around, lcc.pushNestedTransaction needs to be called to create a SpliceInternalTransactionManager instead of the default transaction manager.  This special transaction manager has the ability to do full nesting of transactions.  The first time around, we don't need to create a nested transaction, we are just using the main transaction that was elevated to writable on line 85 of QueryJob.java:\nTxnView parent = root.getCurrentTransaction();\nEvery time after this that we create a new child transaction (because we have a new nested operation), the new transaction is pushed onto the transaction manager's transaction stack at line 220:\ninternalTransaction.pushInternalTransaction((Txn) txn);\nSo, we can go to the else branch once the transaction manager that supports fully nested transactions is set up and has a transaction pushed to it that can act as a parent transaction.  We only create the child transaction on the 2nd, 3rd, 4th, etc. nested operations.", "author": "msirek", "createdAt": "2021-01-09T05:37:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDExMTgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDExNDk5Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4807#discussion_r554114993", "bodyText": "Also weird indentation here.", "author": "ascend1", "createdAt": "2021-01-08T18:22:51Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/store/access/SpliceTransactionFactory.java", "diffHunk": "@@ -119,16 +119,27 @@ public Transaction startTransaction(HBaseStore hbaseStore,ContextManager context\n      * @param hbaseStore the hbase store relevant to the transaction\n      * @param contextMgr the context manager\n      * @param parentTxn  the parent transaction\n+\t * @param destinationTable The byte representation of the conglomerate\n+\t *                         number of the target table as a String.\n+\t * @param inMemoryTxn If true, attempt to begin the child transaction\n+\t *                    as an in-memory transaction.  This is only\n+\t *                    applicable to non-Spark queries.", "originalCommit": "211edba5647ee24ab8b38a66331ff3923e7b0ee6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI1OTQwNw==", "url": "https://github.com/splicemachine/spliceengine/pull/4807#discussion_r554259407", "bodyText": "I've removed all tabs in this file.", "author": "msirek", "createdAt": "2021-01-09T00:26:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDExNDk5Mw=="}], "type": "inlineReview"}, {"oid": "ced514bc49333b71b7095f44ed21b9953c365e89", "url": "https://github.com/splicemachine/spliceengine/commit/ced514bc49333b71b7095f44ed21b9953c365e89", "message": "DB-10579 Address review comments.", "committedDate": "2021-01-09T05:38:26Z", "type": "commit"}, {"oid": "24f563afcc0ee2e47b77d1e8ff9b404a2841d459", "url": "https://github.com/splicemachine/spliceengine/commit/24f563afcc0ee2e47b77d1e8ff9b404a2841d459", "message": "Merge branch 'master' into DB-10579", "committedDate": "2021-01-09T05:42:54Z", "type": "commit"}, {"oid": "9ca55752f275d1930621155dc8b525125727fc82", "url": "https://github.com/splicemachine/spliceengine/commit/9ca55752f275d1930621155dc8b525125727fc82", "message": "DB-10579 Fix compilation error", "committedDate": "2021-01-09T15:19:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY0NDI5OA==", "url": "https://github.com/splicemachine/spliceengine/pull/4807#discussion_r555644298", "bodyText": "Awesome notes!", "author": "arnaud-splice", "createdAt": "2021-01-12T09:53:53Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/store/access/TransactionController.java", "diffHunk": "@@ -799,15 +799,61 @@ long findContainerid(long conglomid)\n      *                                 works correctly if a commit can be lost\n      *                                 on system crash.\n      *\n-\t * @return The new nested user transaction.\n+     * @return The new nested user transaction.\n      *\n-\t * @exception  StandardException  Standard exception policy.\n+     * @exception  StandardException  Standard exception policy.\n      **/\n \tTransactionController startNestedUserTransaction(\n \t\t\tboolean readOnly,\n \t\t\tboolean flush_log_on_xact_end)\n         throws StandardException;\n \n+    /**\n+     * Get a nested internal transaction.\n+     * <p>\n+     * A nested internal transaction is used in place of a user transaction\n+     * when a DML statement is executing its operation tree and a new writable\n+     * child transaction needs to be created with the possibility that within\n+     * that statement another substatement may be run, requiring a nested transaction.\n+     *\n+     * @param readOnly True to begin a readOnly transaction, otherwise false.\n+     * @param destinationTable The byte representation of the conglomerate\n+     *                         number of the target table as a String.\n+     * @param inMemoryTxn If true, attempt to begin the child transaction\n+     *                    as an in-memory transaction.  This is only\n+     *                    applicable to non-Spark queries.\n+     * @return SpliceInternalTransactionManager object for tracking the latest child transaction.\n+     *\n+     * @notes The purpose of this method is to produce a new SpliceInternalTransactionManager", "originalCommit": "9ca55752f275d1930621155dc8b525125727fc82", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY2NzYxOA==", "url": "https://github.com/splicemachine/spliceengine/pull/4807#discussion_r555667618", "bodyText": "Why is !SpliceClient.isClient needed here? (And why wasn't it needed before this PR?)", "author": "arnaud-splice", "createdAt": "2021-01-12T10:29:39Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/stream/control/ControlDataSetWriter.java", "diffHunk": "@@ -64,26 +76,59 @@ public ControlDataSetWriter(ControlDataSet<ExecRow> dataSet, AbstractPipelineWri\n     @Override\n     public DataSet<ExecRow> write() throws StandardException{\n         SpliceOperation operation=operationContext.getOperation();\n-\n+        LanguageConnectionContext lcc =\n+            operationContext.getActivation().getLanguageConnectionContext();\n         try{\n-            boolean inMemoryTxn = !operation.isOlapServer();\n+            boolean inMemoryTxn = !operation.isOlapServer() && !SpliceClient.isClient();", "originalCommit": "9ca55752f275d1930621155dc8b525125727fc82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTk0OTgwNg==", "url": "https://github.com/splicemachine/spliceengine/pull/4807#discussion_r555949806", "bodyText": "There was another Jira where we didn't properly detect we're running on Spark using just the isOlapServer() check.  SpliceClient.isClient() is true for nsds, so the combination of the two is used to detect we're running on Spark (in the spark driver, not the executor).  This code is likely needed even before this PR.  Spark does not use in-memory transactions.", "author": "msirek", "createdAt": "2021-01-12T17:30:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTY2NzYxOA=="}], "type": "inlineReview"}]}