{"pr_number": 4395, "pr_title": "DB-10521 Allow SSQs with correlation on Group By column(s)", "pr_createdAt": "2020-10-27T15:40:31Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4395", "timeline": [{"oid": "617d45a6815998dff6522f9c78c2299b4b6b10a4", "url": "https://github.com/splicemachine/spliceengine/commit/617d45a6815998dff6522f9c78c2299b4b6b10a4", "message": "DB-10521 allow SSQs with correlation on Group By column.", "committedDate": "2020-10-27T12:48:22Z", "type": "commit"}, {"oid": "c936b057a06012cfa7b79d98b5a2375838b8ee99", "url": "https://github.com/splicemachine/spliceengine/commit/c936b057a06012cfa7b79d98b5a2375838b8ee99", "message": "DB-10521 cleanup and refactoring.", "committedDate": "2020-10-27T13:23:13Z", "type": "commit"}, {"oid": "9df7a8131d94febd2100ab521b981aab4eb7cb4b", "url": "https://github.com/splicemachine/spliceengine/commit/9df7a8131d94febd2100ab521b981aab4eb7cb4b", "message": "DB-10521 Add tests.", "committedDate": "2020-10-27T15:37:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkwNTEwOA==", "url": "https://github.com/splicemachine/spliceengine/pull/4395#discussion_r512905108", "bodyText": "I'm not sure why we cannot handle aggregate in the subquery, it seems perfectly fine for both scenarios below:\nselect a1, (select max(b2) from t2), count(*) from t1 group by a1;\nselect a1, (select max(b2) from t2 where a2=t1.a1), count(*) from t1 group by a1;\n\nCan you lift this restriction?", "author": "yxia92", "createdAt": "2020-10-27T17:50:53Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/VerifyAggregateExpressionsVisitor.java", "diffHunk": "@@ -36,137 +36,142 @@\n import com.splicemachine.db.iapi.sql.compile.Visitable;\n import com.splicemachine.db.iapi.sql.compile.Visitor;\n \n+import java.util.List;\n+\n /**\n  * If a RCL (SELECT list) contains an aggregate, then we must verify\n- * that the RCL (SELECT list) is valid.  \n+ * that the RCL (SELECT list) is valid.\n  * For ungrouped queries,\n  * the RCL must be composed entirely of valid aggregate expressions -\n  * in this case, no column references outside of an aggregate.\n  * For grouped aggregates,\n  * the RCL must be composed of grouping columns or valid aggregate\n  * expressions - in this case, the only column references allowed outside of\n- * an aggregate are grouping columns.\n- *\n+ * an aggregate are grouping columns and SSQs correlating on the grouping columns.\n  */\n-public class VerifyAggregateExpressionsVisitor implements Visitor\n-{\n-\tprivate GroupByList groupByList;\n-\n-\tpublic VerifyAggregateExpressionsVisitor(GroupByList groupByList)\n-\t{\n-\t\tthis.groupByList = groupByList;\n-\t}\n-\n-\n-\t////////////////////////////////////////////////\n-\t//\n-\t// VISITOR INTERFACE\n-\t//\n-\t////////////////////////////////////////////////\n-\n-\t/**\n-\t * Verify that this expression is ok\n-\t * for an aggregate query.  \n-\t *\n-\t * @param node \tthe node to process\n-\t *\n-\t * @return me\n-\t *\n-\t * @exception StandardException on ColumnReference not\n-\t * \tin group by list, ValueNode or\t\n-\t * \tJavaValueNode that isn't under an\n-\t * \taggregate\n-\t */\n+public class VerifyAggregateExpressionsVisitor implements Visitor {\n+    private GroupByList groupByList;\n+\n+    public VerifyAggregateExpressionsVisitor(GroupByList groupByList) {\n+        this.groupByList = groupByList;\n+    }\n+\n+\n+    ////////////////////////////////////////////////\n+    //\n+    // VISITOR INTERFACE\n+    //\n+    ////////////////////////////////////////////////\n+\n+    /**\n+     * Verify that this expression is ok\n+     * for an aggregate query.\n+     *\n+     * @param node the node to process\n+     * @throws StandardException on ColumnReference not in group by list,\n+     * ValueNode or JavaValueNode that isn't under an aggregate.\n+     */\n     @Override\n-\tpublic Visitable visit(Visitable node, QueryTreeNode parent) throws StandardException {\n-\t\tif (node instanceof ColumnReference)\n-\t\t{\n-\t\t\tColumnReference cr = (ColumnReference)node;\n-\t\t\n-\t\t\tif (groupByList == null)\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException(SQLState.LANG_INVALID_COL_REF_NON_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n-\t\t\t}\n-\n-\t\t\tif (groupByList.findGroupingColumn(cr) == null)\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException(SQLState.LANG_INVALID_COL_REF_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n-\t\t\t}\n-\t\t} \n-\t\t\n-\t\t/*\n-\t\t** Subqueries are only valid if they do not have\n-\t\t** correlations and are expression subqueries.  RESOLVE:\n-\t\t** this permits VARIANT expressions in the subquery --\n-\t\t** should this be allowed?  may be confusing to\n-\t\t** users to complain about:\n-\t\t**\n-\t\t**\tselect max(x), (select sum(y).toString() from y) from x\n-\t\t*/\n-\t\telse if (node instanceof SubqueryNode)\n-\t\t{\n-\t\t\tSubqueryNode subq = (SubqueryNode)node;\n-\t\t\n-\t\t\tif ((subq.getSubqueryType() != SubqueryNode.EXPRESSION_SUBQUERY) ||\n-\t\t\t\t subq.hasCorrelatedCRs())\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException( (groupByList == null) ?\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_NON_GROUPED_SELECT_LIST :\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_GROUPED_SELECT_LIST);\n-\t\t\t}\n-\n-\t\t\t/*\n-\t\t\t** TEMPORARY RESTRICTION: we cannot handle an aggregate\n-\t\t\t** in the subquery \n-\t\t\t*/\n-\t\t\tHasNodeVisitor visitor = new HasNodeVisitor(AggregateNode.class);\n-\t\t\tsubq.accept(visitor);\n-\t\t\tif (visitor.hasNode())\n-\t\t\t{\t\n-\t\t\t\tthrow StandardException.newException( (groupByList == null) ?\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_NON_GROUPED_SELECT_LIST :\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_GROUPED_SELECT_LIST);\n-\t\t\t}\n-\t\t} else if (node instanceof GroupingFunctionNode) {\n-\t\t\tif (groupByList == null || !groupByList.isRollup()) {\n-\t\t\t\tthrow StandardException.newException(com.splicemachine.db.shared.common.reference.SQLState.LANG_FUNCTION_NOT_ALLOWED,\n-\t\t\t\t\t\t\"GROUPING\",\n-\t\t\t\t\t\t\"Query without OLAP operations like rollup, cube, groupingsets\");\n-\t\t\t} else if (!((GroupingFunctionNode) node).isSingleColumnExpression()) {\n-\t\t\t\tthrow StandardException.newException(com.splicemachine.db.shared.common.reference.SQLState.LANG_INVALID_FUNCTION_ARGUMENT,\n-\t\t\t\t\t\tnode.toString(),\n-\t\t\t\t\t\t\"GROUPING\");\n-\t\t\t}\n-\t\t}\n-\t\treturn node;\n-\t}\n-\n-\t/**\n-\t * Don't visit children under an aggregate, subquery or any node which\n-\t * is equivalent to any of the group by expressions.\n-\t *\n-\t * @param node \tthe node to process\n-\t *\n-\t * @return true/false\n-\t * @throws StandardException \n-\t */\n-\tpublic boolean skipChildren(Visitable node) throws StandardException \n-\t{\n-\t\t// skip aggregate node but not window function node\n-\t\treturn ((node instanceof AggregateNode && !(node instanceof WindowFunctionNode)) ||\n-\t\t\t\t(node instanceof SubqueryNode) ||\n-\t\t\t\t(node instanceof ValueNode &&\n-\t\t\t\t\t\tgroupByList != null \n-\t\t\t\t\t\t&& groupByList.findGroupingColumn((ValueNode)node) != null));\n-\t}\n-\t\n-\tpublic boolean stopTraversal()\n-\t{\n-\t\treturn false;\n-\t}\n-\n-\tpublic boolean visitChildrenFirst(Visitable node)\n-\t{\n-\t\treturn false;\n-\t}\n+    public Visitable visit(Visitable node, QueryTreeNode parent) throws StandardException {\n+        if (node instanceof ColumnReference) {\n+            ColumnReference cr = (ColumnReference) node;\n+\n+            if (groupByList == null) {\n+                throw StandardException.newException(SQLState.LANG_INVALID_COL_REF_NON_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n+            }\n+\n+            if (groupByList.findGroupingColumn(cr) == null) {\n+                throw StandardException.newException(SQLState.LANG_INVALID_COL_REF_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n+            }\n+        }\n+\n+        /*\n+         ** Subqueries are only valid if they do not have\n+         ** correlations and are expression subqueries.  RESOLVE:\n+         ** this permits VARIANT expressions in the subquery --\n+         ** should this be allowed?  may be confusing to\n+         ** users to complain about:\n+         **\n+         ** select max(x), (select sum(y).toString() from y) from x\n+         */\n+        else if (node instanceof SubqueryNode) {\n+            SubqueryNode subquery = (SubqueryNode) node;\n+\n+            if ((subquery.getSubqueryType() != SubqueryNode.EXPRESSION_SUBQUERY) ||\n+                    subquery.hasCorrelatedCRs()) {\n+                if (groupByList != null) {\n+                    /*\n+                     ** Check if the SSQ's correlated columns are referencing the grouping columns, if so, allow it.\n+                     */\n+                    List<ValueNode> correlationCRs = subquery.getCorrelationCRs();\n+                    for (ValueNode correlationCR : correlationCRs) {\n+                        if (correlationCR instanceof ColumnReference) {\n+                            boolean included = false;\n+                            for (OrderedColumn column : groupByList.getNodes()) {\n+                                if (column.getValueNode().equals(correlationCR)) {\n+                                    included = true;\n+                                    break;\n+                                }\n+                            }\n+                            if (!included) {\n+                                throw StandardException.newException(SQLState.LANG_INVALID_GROUPED_SELECT_LIST);\n+                            }\n+                        } else {\n+                            throw StandardException.newException(SQLState.LANG_INVALID_GROUPED_SELECT_LIST);\n+                        }\n+                    }\n+                } else {\n+                    throw StandardException.newException(SQLState.LANG_INVALID_NON_GROUPED_SELECT_LIST);\n+                }\n+            }\n+\n+            if (!subquery.hasCorrelatedCRs()) {", "originalCommit": "9df7a8131d94febd2100ab521b981aab4eb7cb4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI1MzY4Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4395#discussion_r517253682", "bodyText": "I was also wondering why subquery aggregations were, as commented, \"temporarily\" disabled. I thought I would keep it this way since addressing it is probably outside the scope of this PR. Anyway, I remove the restriction and added a test for it.", "author": "hatyo", "createdAt": "2020-11-04T10:45:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkwNTEwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU2MDcxMg==", "url": "https://github.com/splicemachine/spliceengine/pull/4395#discussion_r517560712", "bodyText": "Thanks!", "author": "yxia92", "createdAt": "2020-11-04T18:52:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkwNTEwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkwNjg5MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4395#discussion_r512906890", "bodyText": "Can you add an additional check subquery.getSubqueryType()==SubqueryNode.EXPRESSION_SUBQUERY) to ensure that we only allow Scalar subquery?", "author": "yxia92", "createdAt": "2020-10-27T17:53:09Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/VerifyAggregateExpressionsVisitor.java", "diffHunk": "@@ -36,137 +36,142 @@\n import com.splicemachine.db.iapi.sql.compile.Visitable;\n import com.splicemachine.db.iapi.sql.compile.Visitor;\n \n+import java.util.List;\n+\n /**\n  * If a RCL (SELECT list) contains an aggregate, then we must verify\n- * that the RCL (SELECT list) is valid.  \n+ * that the RCL (SELECT list) is valid.\n  * For ungrouped queries,\n  * the RCL must be composed entirely of valid aggregate expressions -\n  * in this case, no column references outside of an aggregate.\n  * For grouped aggregates,\n  * the RCL must be composed of grouping columns or valid aggregate\n  * expressions - in this case, the only column references allowed outside of\n- * an aggregate are grouping columns.\n- *\n+ * an aggregate are grouping columns and SSQs correlating on the grouping columns.\n  */\n-public class VerifyAggregateExpressionsVisitor implements Visitor\n-{\n-\tprivate GroupByList groupByList;\n-\n-\tpublic VerifyAggregateExpressionsVisitor(GroupByList groupByList)\n-\t{\n-\t\tthis.groupByList = groupByList;\n-\t}\n-\n-\n-\t////////////////////////////////////////////////\n-\t//\n-\t// VISITOR INTERFACE\n-\t//\n-\t////////////////////////////////////////////////\n-\n-\t/**\n-\t * Verify that this expression is ok\n-\t * for an aggregate query.  \n-\t *\n-\t * @param node \tthe node to process\n-\t *\n-\t * @return me\n-\t *\n-\t * @exception StandardException on ColumnReference not\n-\t * \tin group by list, ValueNode or\t\n-\t * \tJavaValueNode that isn't under an\n-\t * \taggregate\n-\t */\n+public class VerifyAggregateExpressionsVisitor implements Visitor {\n+    private GroupByList groupByList;\n+\n+    public VerifyAggregateExpressionsVisitor(GroupByList groupByList) {\n+        this.groupByList = groupByList;\n+    }\n+\n+\n+    ////////////////////////////////////////////////\n+    //\n+    // VISITOR INTERFACE\n+    //\n+    ////////////////////////////////////////////////\n+\n+    /**\n+     * Verify that this expression is ok\n+     * for an aggregate query.\n+     *\n+     * @param node the node to process\n+     * @throws StandardException on ColumnReference not in group by list,\n+     * ValueNode or JavaValueNode that isn't under an aggregate.\n+     */\n     @Override\n-\tpublic Visitable visit(Visitable node, QueryTreeNode parent) throws StandardException {\n-\t\tif (node instanceof ColumnReference)\n-\t\t{\n-\t\t\tColumnReference cr = (ColumnReference)node;\n-\t\t\n-\t\t\tif (groupByList == null)\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException(SQLState.LANG_INVALID_COL_REF_NON_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n-\t\t\t}\n-\n-\t\t\tif (groupByList.findGroupingColumn(cr) == null)\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException(SQLState.LANG_INVALID_COL_REF_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n-\t\t\t}\n-\t\t} \n-\t\t\n-\t\t/*\n-\t\t** Subqueries are only valid if they do not have\n-\t\t** correlations and are expression subqueries.  RESOLVE:\n-\t\t** this permits VARIANT expressions in the subquery --\n-\t\t** should this be allowed?  may be confusing to\n-\t\t** users to complain about:\n-\t\t**\n-\t\t**\tselect max(x), (select sum(y).toString() from y) from x\n-\t\t*/\n-\t\telse if (node instanceof SubqueryNode)\n-\t\t{\n-\t\t\tSubqueryNode subq = (SubqueryNode)node;\n-\t\t\n-\t\t\tif ((subq.getSubqueryType() != SubqueryNode.EXPRESSION_SUBQUERY) ||\n-\t\t\t\t subq.hasCorrelatedCRs())\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException( (groupByList == null) ?\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_NON_GROUPED_SELECT_LIST :\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_GROUPED_SELECT_LIST);\n-\t\t\t}\n-\n-\t\t\t/*\n-\t\t\t** TEMPORARY RESTRICTION: we cannot handle an aggregate\n-\t\t\t** in the subquery \n-\t\t\t*/\n-\t\t\tHasNodeVisitor visitor = new HasNodeVisitor(AggregateNode.class);\n-\t\t\tsubq.accept(visitor);\n-\t\t\tif (visitor.hasNode())\n-\t\t\t{\t\n-\t\t\t\tthrow StandardException.newException( (groupByList == null) ?\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_NON_GROUPED_SELECT_LIST :\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_GROUPED_SELECT_LIST);\n-\t\t\t}\n-\t\t} else if (node instanceof GroupingFunctionNode) {\n-\t\t\tif (groupByList == null || !groupByList.isRollup()) {\n-\t\t\t\tthrow StandardException.newException(com.splicemachine.db.shared.common.reference.SQLState.LANG_FUNCTION_NOT_ALLOWED,\n-\t\t\t\t\t\t\"GROUPING\",\n-\t\t\t\t\t\t\"Query without OLAP operations like rollup, cube, groupingsets\");\n-\t\t\t} else if (!((GroupingFunctionNode) node).isSingleColumnExpression()) {\n-\t\t\t\tthrow StandardException.newException(com.splicemachine.db.shared.common.reference.SQLState.LANG_INVALID_FUNCTION_ARGUMENT,\n-\t\t\t\t\t\tnode.toString(),\n-\t\t\t\t\t\t\"GROUPING\");\n-\t\t\t}\n-\t\t}\n-\t\treturn node;\n-\t}\n-\n-\t/**\n-\t * Don't visit children under an aggregate, subquery or any node which\n-\t * is equivalent to any of the group by expressions.\n-\t *\n-\t * @param node \tthe node to process\n-\t *\n-\t * @return true/false\n-\t * @throws StandardException \n-\t */\n-\tpublic boolean skipChildren(Visitable node) throws StandardException \n-\t{\n-\t\t// skip aggregate node but not window function node\n-\t\treturn ((node instanceof AggregateNode && !(node instanceof WindowFunctionNode)) ||\n-\t\t\t\t(node instanceof SubqueryNode) ||\n-\t\t\t\t(node instanceof ValueNode &&\n-\t\t\t\t\t\tgroupByList != null \n-\t\t\t\t\t\t&& groupByList.findGroupingColumn((ValueNode)node) != null));\n-\t}\n-\t\n-\tpublic boolean stopTraversal()\n-\t{\n-\t\treturn false;\n-\t}\n-\n-\tpublic boolean visitChildrenFirst(Visitable node)\n-\t{\n-\t\treturn false;\n-\t}\n+    public Visitable visit(Visitable node, QueryTreeNode parent) throws StandardException {\n+        if (node instanceof ColumnReference) {\n+            ColumnReference cr = (ColumnReference) node;\n+\n+            if (groupByList == null) {\n+                throw StandardException.newException(SQLState.LANG_INVALID_COL_REF_NON_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n+            }\n+\n+            if (groupByList.findGroupingColumn(cr) == null) {\n+                throw StandardException.newException(SQLState.LANG_INVALID_COL_REF_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n+            }\n+        }\n+\n+        /*\n+         ** Subqueries are only valid if they do not have\n+         ** correlations and are expression subqueries.  RESOLVE:\n+         ** this permits VARIANT expressions in the subquery --\n+         ** should this be allowed?  may be confusing to\n+         ** users to complain about:\n+         **\n+         ** select max(x), (select sum(y).toString() from y) from x\n+         */\n+        else if (node instanceof SubqueryNode) {\n+            SubqueryNode subquery = (SubqueryNode) node;\n+\n+            if ((subquery.getSubqueryType() != SubqueryNode.EXPRESSION_SUBQUERY) ||\n+                    subquery.hasCorrelatedCRs()) {\n+                if (groupByList != null) {", "originalCommit": "9df7a8131d94febd2100ab521b981aab4eb7cb4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI1NTE0MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4395#discussion_r517255140", "bodyText": "Strengthened the condition, thanks!", "author": "hatyo", "createdAt": "2020-11-04T10:47:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkwNjg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU2MDc4MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4395#discussion_r517560781", "bodyText": "Thanks!", "author": "yxia92", "createdAt": "2020-11-04T18:52:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkwNjg5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkwODA5Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/4395#discussion_r512908097", "bodyText": "Can you use groupByList.findGroupingColumn(cr) instead like we do above for ColumnReference?", "author": "yxia92", "createdAt": "2020-10-27T17:54:37Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/VerifyAggregateExpressionsVisitor.java", "diffHunk": "@@ -36,137 +36,142 @@\n import com.splicemachine.db.iapi.sql.compile.Visitable;\n import com.splicemachine.db.iapi.sql.compile.Visitor;\n \n+import java.util.List;\n+\n /**\n  * If a RCL (SELECT list) contains an aggregate, then we must verify\n- * that the RCL (SELECT list) is valid.  \n+ * that the RCL (SELECT list) is valid.\n  * For ungrouped queries,\n  * the RCL must be composed entirely of valid aggregate expressions -\n  * in this case, no column references outside of an aggregate.\n  * For grouped aggregates,\n  * the RCL must be composed of grouping columns or valid aggregate\n  * expressions - in this case, the only column references allowed outside of\n- * an aggregate are grouping columns.\n- *\n+ * an aggregate are grouping columns and SSQs correlating on the grouping columns.\n  */\n-public class VerifyAggregateExpressionsVisitor implements Visitor\n-{\n-\tprivate GroupByList groupByList;\n-\n-\tpublic VerifyAggregateExpressionsVisitor(GroupByList groupByList)\n-\t{\n-\t\tthis.groupByList = groupByList;\n-\t}\n-\n-\n-\t////////////////////////////////////////////////\n-\t//\n-\t// VISITOR INTERFACE\n-\t//\n-\t////////////////////////////////////////////////\n-\n-\t/**\n-\t * Verify that this expression is ok\n-\t * for an aggregate query.  \n-\t *\n-\t * @param node \tthe node to process\n-\t *\n-\t * @return me\n-\t *\n-\t * @exception StandardException on ColumnReference not\n-\t * \tin group by list, ValueNode or\t\n-\t * \tJavaValueNode that isn't under an\n-\t * \taggregate\n-\t */\n+public class VerifyAggregateExpressionsVisitor implements Visitor {\n+    private GroupByList groupByList;\n+\n+    public VerifyAggregateExpressionsVisitor(GroupByList groupByList) {\n+        this.groupByList = groupByList;\n+    }\n+\n+\n+    ////////////////////////////////////////////////\n+    //\n+    // VISITOR INTERFACE\n+    //\n+    ////////////////////////////////////////////////\n+\n+    /**\n+     * Verify that this expression is ok\n+     * for an aggregate query.\n+     *\n+     * @param node the node to process\n+     * @throws StandardException on ColumnReference not in group by list,\n+     * ValueNode or JavaValueNode that isn't under an aggregate.\n+     */\n     @Override\n-\tpublic Visitable visit(Visitable node, QueryTreeNode parent) throws StandardException {\n-\t\tif (node instanceof ColumnReference)\n-\t\t{\n-\t\t\tColumnReference cr = (ColumnReference)node;\n-\t\t\n-\t\t\tif (groupByList == null)\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException(SQLState.LANG_INVALID_COL_REF_NON_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n-\t\t\t}\n-\n-\t\t\tif (groupByList.findGroupingColumn(cr) == null)\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException(SQLState.LANG_INVALID_COL_REF_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n-\t\t\t}\n-\t\t} \n-\t\t\n-\t\t/*\n-\t\t** Subqueries are only valid if they do not have\n-\t\t** correlations and are expression subqueries.  RESOLVE:\n-\t\t** this permits VARIANT expressions in the subquery --\n-\t\t** should this be allowed?  may be confusing to\n-\t\t** users to complain about:\n-\t\t**\n-\t\t**\tselect max(x), (select sum(y).toString() from y) from x\n-\t\t*/\n-\t\telse if (node instanceof SubqueryNode)\n-\t\t{\n-\t\t\tSubqueryNode subq = (SubqueryNode)node;\n-\t\t\n-\t\t\tif ((subq.getSubqueryType() != SubqueryNode.EXPRESSION_SUBQUERY) ||\n-\t\t\t\t subq.hasCorrelatedCRs())\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException( (groupByList == null) ?\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_NON_GROUPED_SELECT_LIST :\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_GROUPED_SELECT_LIST);\n-\t\t\t}\n-\n-\t\t\t/*\n-\t\t\t** TEMPORARY RESTRICTION: we cannot handle an aggregate\n-\t\t\t** in the subquery \n-\t\t\t*/\n-\t\t\tHasNodeVisitor visitor = new HasNodeVisitor(AggregateNode.class);\n-\t\t\tsubq.accept(visitor);\n-\t\t\tif (visitor.hasNode())\n-\t\t\t{\t\n-\t\t\t\tthrow StandardException.newException( (groupByList == null) ?\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_NON_GROUPED_SELECT_LIST :\n-\t\t\t\t\t\t\tSQLState.LANG_INVALID_GROUPED_SELECT_LIST);\n-\t\t\t}\n-\t\t} else if (node instanceof GroupingFunctionNode) {\n-\t\t\tif (groupByList == null || !groupByList.isRollup()) {\n-\t\t\t\tthrow StandardException.newException(com.splicemachine.db.shared.common.reference.SQLState.LANG_FUNCTION_NOT_ALLOWED,\n-\t\t\t\t\t\t\"GROUPING\",\n-\t\t\t\t\t\t\"Query without OLAP operations like rollup, cube, groupingsets\");\n-\t\t\t} else if (!((GroupingFunctionNode) node).isSingleColumnExpression()) {\n-\t\t\t\tthrow StandardException.newException(com.splicemachine.db.shared.common.reference.SQLState.LANG_INVALID_FUNCTION_ARGUMENT,\n-\t\t\t\t\t\tnode.toString(),\n-\t\t\t\t\t\t\"GROUPING\");\n-\t\t\t}\n-\t\t}\n-\t\treturn node;\n-\t}\n-\n-\t/**\n-\t * Don't visit children under an aggregate, subquery or any node which\n-\t * is equivalent to any of the group by expressions.\n-\t *\n-\t * @param node \tthe node to process\n-\t *\n-\t * @return true/false\n-\t * @throws StandardException \n-\t */\n-\tpublic boolean skipChildren(Visitable node) throws StandardException \n-\t{\n-\t\t// skip aggregate node but not window function node\n-\t\treturn ((node instanceof AggregateNode && !(node instanceof WindowFunctionNode)) ||\n-\t\t\t\t(node instanceof SubqueryNode) ||\n-\t\t\t\t(node instanceof ValueNode &&\n-\t\t\t\t\t\tgroupByList != null \n-\t\t\t\t\t\t&& groupByList.findGroupingColumn((ValueNode)node) != null));\n-\t}\n-\t\n-\tpublic boolean stopTraversal()\n-\t{\n-\t\treturn false;\n-\t}\n-\n-\tpublic boolean visitChildrenFirst(Visitable node)\n-\t{\n-\t\treturn false;\n-\t}\n+    public Visitable visit(Visitable node, QueryTreeNode parent) throws StandardException {\n+        if (node instanceof ColumnReference) {\n+            ColumnReference cr = (ColumnReference) node;\n+\n+            if (groupByList == null) {\n+                throw StandardException.newException(SQLState.LANG_INVALID_COL_REF_NON_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n+            }\n+\n+            if (groupByList.findGroupingColumn(cr) == null) {\n+                throw StandardException.newException(SQLState.LANG_INVALID_COL_REF_GROUPED_SELECT_LIST, cr.getSQLColumnName());\n+            }\n+        }\n+\n+        /*\n+         ** Subqueries are only valid if they do not have\n+         ** correlations and are expression subqueries.  RESOLVE:\n+         ** this permits VARIANT expressions in the subquery --\n+         ** should this be allowed?  may be confusing to\n+         ** users to complain about:\n+         **\n+         ** select max(x), (select sum(y).toString() from y) from x\n+         */\n+        else if (node instanceof SubqueryNode) {\n+            SubqueryNode subquery = (SubqueryNode) node;\n+\n+            if ((subquery.getSubqueryType() != SubqueryNode.EXPRESSION_SUBQUERY) ||\n+                    subquery.hasCorrelatedCRs()) {\n+                if (groupByList != null) {\n+                    /*\n+                     ** Check if the SSQ's correlated columns are referencing the grouping columns, if so, allow it.\n+                     */\n+                    List<ValueNode> correlationCRs = subquery.getCorrelationCRs();\n+                    for (ValueNode correlationCR : correlationCRs) {\n+                        if (correlationCR instanceof ColumnReference) {\n+                            boolean included = false;\n+                            for (OrderedColumn column : groupByList.getNodes()) {\n+                                if (column.getValueNode().equals(correlationCR)) {\n+                                    included = true;\n+                                    break;\n+                                }\n+                            }\n+                            if (!included) {\n+                                throw StandardException.newException(SQLState.LANG_INVALID_GROUPED_SELECT_LIST);\n+                            }", "originalCommit": "9df7a8131d94febd2100ab521b981aab4eb7cb4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI1NzkxOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4395#discussion_r517257919", "bodyText": "done.", "author": "hatyo", "createdAt": "2020-11-04T10:52:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkwODA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkwOTEwNA==", "url": "https://github.com/splicemachine/spliceengine/pull/4395#discussion_r512909104", "bodyText": "In addition, could you test a non-correlated Scalar subquery case? Also a case where the Scalar subquery does not contain aggregation?", "author": "yxia92", "createdAt": "2020-10-27T17:55:51Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/GroupByCorreltionIT.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.SpliceDataWatcher;\n+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;\n+import com.splicemachine.derby.test.framework.SpliceTableWatcher;\n+import com.splicemachine.derby.test.framework.SpliceWatcher;\n+import org.junit.Assert;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+\n+public class GroupByCorreltionIT {\n+    protected static SpliceWatcher spliceClassWatcher = new SpliceWatcher();\n+    protected static SpliceSchemaWatcher schemaWatcher = new SpliceSchemaWatcher(GroupByOrderByIT.class.getSimpleName());\n+    protected static SpliceTableWatcher otWatcher = new SpliceTableWatcher(\"OUTER_TABLE\", schemaWatcher.schemaName, \"(oc1 VARCHAR(3), oc2 VARCHAR(3), oc3 INT)\");\n+    protected static SpliceTableWatcher itWatcher = new SpliceTableWatcher(\"INNER_TABLE\", schemaWatcher.schemaName, \"(ic1 INTEGER, ic2 VARCHAR(3))\");\n+    private static List<String> otValues = Arrays.asList(\n+            \"('E1','P1',40)\",\n+            \"('E1','P2',20)\",\n+            \"('E1','P3',80)\",\n+            \"('E1','P4',20)\",\n+            \"('E1','P5',12)\",\n+            \"('E1','P6',12)\",\n+            \"('E2','P1',40)\",\n+            \"('E2','P2',80)\",\n+            \"('E3','P2',20)\",\n+            \"('E4','P2',20)\",\n+            \"('E4','P4',40)\",\n+            \"('E4','P5',80)\");\n+    private static List<String> itValues = Arrays.asList(\n+            \"(2, 'E1')\",\n+            \"(2, 'E1')\",\n+            \"(2, 'E1')\",\n+            \"(2, 'E1')\",\n+            \"(2, 'E1')\",\n+            \"(2, 'E1')\",\n+            \"(4, 'E2')\",\n+            \"(4, 'E2')\",\n+            \"(4, 'E2')\",\n+            \"(4, 'E2')\",\n+            \"(4, 'E2')\",\n+            \"(5, 'E3')\");\n+    @ClassRule\n+    public static TestRule chain = RuleChain.outerRule(spliceClassWatcher)\n+            .around(schemaWatcher)\n+            .around(otWatcher)\n+            .around(itWatcher)\n+            .around(new SpliceDataWatcher() {\n+                @Override\n+                protected void starting(Description description) {\n+                    try {\n+                        //  load OUTER_TABLE\n+                        for (String rowVal : otValues) {\n+                            spliceClassWatcher.getStatement().executeUpdate(\"insert into \" + otWatcher.toString() + \" values \" + rowVal);\n+                        }\n+                        //  load INNER_TABLE\n+                        for (String rowVal : itValues) {\n+                            spliceClassWatcher.getStatement().executeUpdate(\"insert into \" + itWatcher.toString() + \" values \" + rowVal);\n+                        }\n+                    } catch (Exception e) {\n+                        throw new RuntimeException(e);\n+                    } finally {\n+                        spliceClassWatcher.closeAll();\n+                    }\n+                }\n+            });\n+\n+    @Rule\n+    public SpliceWatcher methodWatcher = new SpliceWatcher();\n+\n+    @Test\n+    public void ssqWithCorrelationOnGroupByColumnWorksCorrectly() throws Exception {\n+        try(ResultSet resultSet = methodWatcher.executeQuery(\"SELECT oc1, (SELECT MAX(ic1) FROM INNER_TABLE WHERE ic2 = outer_table.oc1) FROM OUTER_TABLE GROUP BY oc1 ORDER BY oc1 asc\")) {\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(2, resultSet.getInt(2));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E2\", resultSet.getString(1));Assert.assertEquals(4, resultSet.getInt(2));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E3\", resultSet.getString(1));Assert.assertEquals(5, resultSet.getInt(2));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E4\", resultSet.getString(1));resultSet.getInt(2); Assert.assertTrue(resultSet.wasNull());\n+            Assert.assertFalse(resultSet.next());\n+        }\n+        try(ResultSet resultSet = methodWatcher.executeQuery(\"SELECT oc1, oc2, (SELECT MAX(ic1) FROM INNER_TABLE WHERE ic2 = outer_table.oc1) FROM OUTER_TABLE GROUP BY oc1, oc2 order by oc1 asc, oc2 asc\")) {\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P1\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P2\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P3\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P4\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P5\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P6\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E2\", resultSet.getString(1));Assert.assertEquals(\"P1\", resultSet.getString(2));Assert.assertEquals(4, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E2\", resultSet.getString(1));Assert.assertEquals(\"P2\", resultSet.getString(2));Assert.assertEquals(4, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E3\", resultSet.getString(1));Assert.assertEquals(\"P2\", resultSet.getString(2));Assert.assertEquals(5, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E4\", resultSet.getString(1));Assert.assertEquals(\"P2\", resultSet.getString(2));resultSet.getInt(3); Assert.assertTrue(resultSet.wasNull());\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E4\", resultSet.getString(1));Assert.assertEquals(\"P4\", resultSet.getString(2));resultSet.getInt(3); Assert.assertTrue(resultSet.wasNull());\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E4\", resultSet.getString(1));Assert.assertEquals(\"P5\", resultSet.getString(2));resultSet.getInt(3); Assert.assertTrue(resultSet.wasNull());\n+            Assert.assertFalse(resultSet.next());\n+        }\n+    }\n+\n+    @Test\n+    public void ssqWithoutCorrelationOnGroupByColumnThrows() throws Exception {\n+        try(ResultSet resultSet = methodWatcher.executeQuery(\"SELECT oc1, (SELECT MAX(ic1) FROM INNER_TABLE WHERE ic2 = outer_table.oc2) FROM OUTER_TABLE GROUP BY oc1 order by oc1 asc\")) {\n+            Assert.fail(\"expected exception containing message: The SELECT list of a non-grouped query contains at least one invalid expression. When the SELECT list contains at least one \" +\n+                    \"aggregate then all entries must be valid aggregate expressions\");\n+        } catch(Exception se) {\n+            Assert.assertTrue(se instanceof SQLException);\n+            Assert.assertEquals(\"42Y29\", ((SQLException)se).getSQLState());\n+            Assert.assertTrue(se.getMessage().contains(\"The SELECT list of a non-grouped query contains at least one invalid expression. When the SELECT list contains at least one aggregate \" +\n+                    \"then all entries must be valid aggregate expressions\"));\n+        }\n+    }\n+}", "originalCommit": "9df7a8131d94febd2100ab521b981aab4eb7cb4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI4MjA2NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4395#discussion_r517282065", "bodyText": "The test for a non-correlated SSQ case is added to GroupByOrderByIT test suite, I also added here a negative test for a scenario where subquery does not contain aggregation as suggested.", "author": "hatyo", "createdAt": "2020-11-04T11:36:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjkwOTEwNA=="}], "type": "inlineReview"}, {"oid": "5dda2d501e34cbc1d589ed03c4bcd740643459cc", "url": "https://github.com/splicemachine/spliceengine/commit/5dda2d501e34cbc1d589ed03c4bcd740643459cc", "message": "DB-10521 group by tests cleanup.\n\n- correct GroupByCorreltionIT.java name to GroupByCorrelationIT.java\n- remove unnecessary System.out.println from GroupByOrderByIT.java", "committedDate": "2020-11-04T10:15:05Z", "type": "commit"}, {"oid": "231060ca985a1572df90dfa84cac9477c6e4ee1c", "url": "https://github.com/splicemachine/spliceengine/commit/231060ca985a1572df90dfa84cac9477c6e4ee1c", "message": "DB-10521 allow aggregations in non-correlated SSQ.\n\n- add test.\n- cleanup GroupByOrderByIT test suite.", "committedDate": "2020-11-04T10:44:11Z", "type": "commit"}, {"oid": "85c0e4117559d94b7a97877ff8eb45ac94928707", "url": "https://github.com/splicemachine/spliceengine/commit/85c0e4117559d94b7a97877ff8eb45ac94928707", "message": "DB-10521 address comments.", "committedDate": "2020-11-04T11:12:41Z", "type": "commit"}, {"oid": "96efe884376814f8f163fc61d213d1f2e4415764", "url": "https://github.com/splicemachine/spliceengine/commit/96efe884376814f8f163fc61d213d1f2e4415764", "message": "Merge remote-tracking branch 'origin/master' into DB-10521", "committedDate": "2020-11-04T11:12:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU2NzA0OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4395#discussion_r517567049", "bodyText": "This is a typo, use GroupByCorrelationIT.class.getSimpleName() instead.", "author": "yxia92", "createdAt": "2020-11-04T19:03:13Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/GroupByCorrelationIT.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.SpliceDataWatcher;\n+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;\n+import com.splicemachine.derby.test.framework.SpliceTableWatcher;\n+import com.splicemachine.derby.test.framework.SpliceWatcher;\n+import org.junit.Assert;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class GroupByCorrelationIT {\n+    protected static SpliceWatcher spliceClassWatcher = new SpliceWatcher();\n+    protected static SpliceSchemaWatcher schemaWatcher = new SpliceSchemaWatcher(GroupByOrderByIT.class.getSimpleName());", "originalCommit": "96efe884376814f8f163fc61d213d1f2e4415764", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU4Nzg5OA==", "url": "https://github.com/splicemachine/spliceengine/pull/4395#discussion_r517587898", "bodyText": "Oh thanks a lot! I will fix it", "author": "hatyo", "createdAt": "2020-11-04T19:42:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU2NzA0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU2NzUzMA==", "url": "https://github.com/splicemachine/spliceengine/pull/4395#discussion_r517567530", "bodyText": "I think c2 should be ic2, this way, we should expect the error message ERROR 21000: Scalar subquery is only allowed to return a single row. at runtime instead of c2 not found. Thanks!", "author": "yxia92", "createdAt": "2020-11-04T19:04:10Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/GroupByCorrelationIT.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.derby.impl.sql.execute.operations;\n+\n+import com.splicemachine.derby.test.framework.SpliceDataWatcher;\n+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;\n+import com.splicemachine.derby.test.framework.SpliceTableWatcher;\n+import com.splicemachine.derby.test.framework.SpliceWatcher;\n+import org.junit.Assert;\n+import org.junit.ClassRule;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.RuleChain;\n+import org.junit.rules.TestRule;\n+import org.junit.runner.Description;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+public class GroupByCorrelationIT {\n+    protected static SpliceWatcher spliceClassWatcher = new SpliceWatcher();\n+    protected static SpliceSchemaWatcher schemaWatcher = new SpliceSchemaWatcher(GroupByOrderByIT.class.getSimpleName());\n+    protected static SpliceTableWatcher otWatcher = new SpliceTableWatcher(\"OUTER_TABLE\", schemaWatcher.schemaName, \"(oc1 VARCHAR(3), oc2 VARCHAR(3), oc3 INT)\");\n+    protected static SpliceTableWatcher itWatcher = new SpliceTableWatcher(\"INNER_TABLE\", schemaWatcher.schemaName, \"(ic1 INTEGER, ic2 VARCHAR(3))\");\n+    private static List<String> otValues = Arrays.asList(\n+            \"('E1','P1',40)\",\n+            \"('E1','P2',20)\",\n+            \"('E1','P3',80)\",\n+            \"('E1','P4',20)\",\n+            \"('E1','P5',12)\",\n+            \"('E1','P6',12)\",\n+            \"('E2','P1',40)\",\n+            \"('E2','P2',80)\",\n+            \"('E3','P2',20)\",\n+            \"('E4','P2',20)\",\n+            \"('E4','P4',40)\",\n+            \"('E4','P5',80)\");\n+    private static List<String> itValues = Arrays.asList(\n+            \"(2, 'E1')\",\n+            \"(2, 'E1')\",\n+            \"(2, 'E1')\",\n+            \"(2, 'E1')\",\n+            \"(2, 'E1')\",\n+            \"(2, 'E1')\",\n+            \"(4, 'E2')\",\n+            \"(4, 'E2')\",\n+            \"(4, 'E2')\",\n+            \"(4, 'E2')\",\n+            \"(4, 'E2')\",\n+            \"(5, 'E3')\");\n+    @ClassRule\n+    public static TestRule chain = RuleChain.outerRule(spliceClassWatcher)\n+            .around(schemaWatcher)\n+            .around(otWatcher)\n+            .around(itWatcher)\n+            .around(new SpliceDataWatcher() {\n+                @Override\n+                protected void starting(Description description) {\n+                    try {\n+                        // load OUTER_TABLE\n+                        for (String rowVal : otValues) {\n+                            spliceClassWatcher.getStatement().executeUpdate(\"insert into \" + otWatcher.toString() + \" values \" + rowVal);\n+                        }\n+                        // load INNER_TABLE\n+                        for (String rowVal : itValues) {\n+                            spliceClassWatcher.getStatement().executeUpdate(\"insert into \" + itWatcher.toString() + \" values \" + rowVal);\n+                        }\n+                    } catch (Exception e) {\n+                        throw new RuntimeException(e);\n+                    } finally {\n+                        spliceClassWatcher.closeAll();\n+                    }\n+                }\n+            });\n+\n+    @Rule\n+    public SpliceWatcher methodWatcher = new SpliceWatcher();\n+\n+    @Test\n+    public void ssqWithCorrelationOnGroupByColumnWorksCorrectly() throws Exception {\n+        try(ResultSet resultSet = methodWatcher.executeQuery(String.format(\"SELECT oc1, (SELECT MAX(ic1) FROM %s WHERE ic2 = %s.oc1) FROM %s GROUP BY oc1 ORDER BY oc1 asc\",\n+                                                                           itWatcher.toString(), otWatcher.toString(), otWatcher.toString()))) {\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(2, resultSet.getInt(2));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E2\", resultSet.getString(1));Assert.assertEquals(4, resultSet.getInt(2));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E3\", resultSet.getString(1));Assert.assertEquals(5, resultSet.getInt(2));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E4\", resultSet.getString(1));resultSet.getInt(2); Assert.assertTrue(resultSet.wasNull());\n+            Assert.assertFalse(resultSet.next());\n+        }\n+        try(ResultSet resultSet = methodWatcher.executeQuery(String.format(\"SELECT oc1, oc2, (SELECT MAX(ic1) FROM %s WHERE ic2 = %s.oc1) FROM %s GROUP BY oc1, oc2 order by oc1 asc, oc2 asc\",\n+                                                                           itWatcher.toString(), otWatcher.toString(), otWatcher.toString()))) {\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P1\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P2\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P3\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P4\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P5\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E1\", resultSet.getString(1));Assert.assertEquals(\"P6\", resultSet.getString(2));Assert.assertEquals(2, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E2\", resultSet.getString(1));Assert.assertEquals(\"P1\", resultSet.getString(2));Assert.assertEquals(4, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E2\", resultSet.getString(1));Assert.assertEquals(\"P2\", resultSet.getString(2));Assert.assertEquals(4, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E3\", resultSet.getString(1));Assert.assertEquals(\"P2\", resultSet.getString(2));Assert.assertEquals(5, resultSet.getInt(3));\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E4\", resultSet.getString(1));Assert.assertEquals(\"P2\", resultSet.getString(2));resultSet.getInt(3); Assert.assertTrue(resultSet.wasNull());\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E4\", resultSet.getString(1));Assert.assertEquals(\"P4\", resultSet.getString(2));resultSet.getInt(3); Assert.assertTrue(resultSet.wasNull());\n+            Assert.assertTrue(resultSet.next());\n+            Assert.assertEquals(\"E4\", resultSet.getString(1));Assert.assertEquals(\"P5\", resultSet.getString(2));resultSet.getInt(3); Assert.assertTrue(resultSet.wasNull());\n+            Assert.assertFalse(resultSet.next());\n+        }\n+    }\n+\n+    @Test\n+    public void ssqWithoutCorrelationOnGroupByColumnThrows() throws Exception {\n+        try(ResultSet resultSet = methodWatcher.executeQuery(String.format(\"SELECT oc1, (SELECT MAX(ic1) FROM %s WHERE ic2 = %s.oc2) FROM %s GROUP BY oc1 order by oc1 asc\",\n+                                                             itWatcher.toString(), otWatcher.toString(), otWatcher.toString()))) {\n+            Assert.fail(\"expected exception containing message: The SELECT list of a grouped query contains at least one invalid expression. \" +\n+                                \"If a SELECT list has a GROUP BY, the list may only contain valid grouping expressions and valid aggregate expressions.\");\n+        } catch(Exception se) {\n+            Assert.assertTrue(se instanceof SQLException);\n+            Assert.assertEquals(\"42Y30\", ((SQLException)se).getSQLState());\n+            Assert.assertTrue(se.getMessage().contains(\"The SELECT list of a grouped query contains at least one invalid expression. If a SELECT list has a GROUP BY, \" +\n+                                                               \"the list may only contain valid grouping expressions and valid aggregate expressions.\"));\n+        }\n+    }\n+\n+    @Test\n+    public void subqueryWithCorrelationOnGroupByColumnThrows() throws Exception {\n+        try(ResultSet resultSet = methodWatcher.executeQuery(String.format(\"SELECT oc1, (SELECT c2 FROM %s WHERE ic2 = %s.oc1) FROM %s GROUP BY oc1 order by oc1 asc\",", "originalCommit": "96efe884376814f8f163fc61d213d1f2e4415764", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE1NzQ2Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/4395#discussion_r518157466", "bodyText": "fixed it.", "author": "hatyo", "createdAt": "2020-11-05T15:51:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzU2NzUzMA=="}], "type": "inlineReview"}, {"oid": "f6613e3ad2dcdebd4e95e8516c43abfd7bf6772f", "url": "https://github.com/splicemachine/spliceengine/commit/f6613e3ad2dcdebd4e95e8516c43abfd7bf6772f", "message": "DB-10521 address further comments.", "committedDate": "2020-11-05T15:52:22Z", "type": "commit"}]}