{"pr_number": 4348, "pr_title": "DB-10534 fix VacuumIT / unclosed Transactions in Tests", "pr_createdAt": "2020-10-22T07:47:37Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4348", "timeline": [{"oid": "bc86579b9617669350b8f5cc83f46dfb21bcef59", "url": "https://github.com/splicemachine/spliceengine/commit/bc86579b9617669350b8f5cc83f46dfb21bcef59", "message": "DB-10534 don't always fail when detecting open transactions (parallel tests false positives)", "committedDate": "2020-10-22T08:15:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk3MDkyMg==", "url": "https://github.com/splicemachine/spliceengine/pull/4348#discussion_r509970922", "bodyText": "missing try-with-resources for this ResultSet", "author": "dgomezferro", "createdAt": "2020-10-22T08:22:17Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/impl/sql/execute/operations/SpliceUDTIT.java", "diffHunk": "@@ -57,159 +57,147 @@\n     public static TestRule chain = RuleChain.outerRule(spliceClassWatcher)\n             .around(spliceSchemaWatcher);\n     @ClassRule\n-    public static SpliceWatcher methodWatcher = new SpliceWatcher(CLASS_NAME);\n+    public static final SpliceWatcher methodWatcher = new SpliceWatcher(CLASS_NAME);\n \n     @BeforeClass\n     public static void setup() throws Exception {\n-        createData(spliceClassWatcher.getOrCreateConnection());\n+        createData(spliceClassWatcher);\n     }\n \n-    @AfterClass\n-    public static void tearDown() throws Exception {\n-        methodWatcher.execute(String.format(CALL_REMOVE_JAR_FORMAT_STRING, JAR_FILE_SQL_NAME));\n-        methodWatcher.execute(\"DROP DERBY AGGREGATE Median RESTRICT\");\n-        methodWatcher.execute(\"DROP DERBY AGGREGATE string_concat RESTRICT\");\n-        methodWatcher.execute(\"DROP table orders\");\n-        methodWatcher.execute(\"DROP FUNCTION makePrice\");\n-        methodWatcher.execute(\"DROP FUNCTION getAmount\");\n-        methodWatcher.execute(\"DROP TYPE price restrict\");\n-        methodWatcher.execute(\"drop function testConnection\");\n-        methodWatcher.execute(\"drop table test\");\n-        methodWatcher.execute(\"drop table t\");\n-        methodWatcher.execute(\"drop table t1\");\n-        methodWatcher.execute(\"drop table strings\");\n-    }\n-\n-    private static void createData(Connection conn) throws Exception {\n-        try(Statement s = conn.createStatement()){\n-            s.execute(String.format(CALL_INSTALL_JAR_FORMAT_STRING, STORED_PROCS_JAR_FILE, JAR_FILE_SQL_NAME));\n+    private static void createData(SpliceWatcher w) throws Exception {\n+        try {\n+            w.execute(String.format(CALL_INSTALL_JAR_FORMAT_STRING, STORED_PROCS_JAR_FILE, JAR_FILE_SQL_NAME));\n         }catch(SQLException se){\n             if(!\"SE014\".equals(se.getSQLState())){\n                 //write-conflict. That means someone ELSE is loading this same jar. That's cool, just keep going\n                 throw se;\n             }\n         }\n-        try(Statement s = conn.createStatement()){\n-            s.execute(String.format(CALL_SET_CLASSPATH_FORMAT_STRING,JAR_FILE_SQL_NAME));\n-            s.execute(\"create derby aggregate median for int external name 'com.splicemachine.customer.Median'\");\n-\n-            new TableCreator(conn)\n-                    .withCreate(\"create table t(i int)\")\n-                    .withInsert(\"insert into t values(?)\")\n-                    .withRows(rows(\n-                            row(1),\n-                            row(2),\n-                            row(3),\n-                            row(4),\n-                            row(5)))\n-                    .create();\n-\n-            new TableCreator(conn)\n-                    .withCreate(\"create table t1(itemName varchar(30), rawPrice int)\")\n-                    .withInsert(\"insert into t1 values(?, ?)\")\n-                    .withRows(rows(\n-                    row(\"Coffee\", 4),\n-                    row(\"Tea\", 3),\n-                    row(\"Milk\", 2),\n-                    row(\"Soda\", 2),\n-                    row(\"Bagel\", 1),\n-                    row(\"Donut\", 1)))\n-                    .create();\n-\n-            s.execute(\"CREATE TYPE price EXTERNAL NAME 'com.splicemachine.customer.Price' language Java\");\n-            s.execute(\"CREATE FUNCTION makePrice(varchar(30), double)\\n\"+\n-                    \"RETURNS Price\\n\"+\n-                    \"LANGUAGE JAVA\\n\"+\n-                    \"PARAMETER STYLE JAVA\\n\"+\n-                    \"NO SQL EXTERNAL NAME 'com.splicemachine.customer.CreatePrice.createPriceObject'\");\n-\n-            s.execute(\"create function getAmount( int ) returns double language java parameter style java no sql\\n\" +\n-                           \"external name 'com.splicemachine.customer.Price.getAmount'\\n\" );\n-\n-            s.execute(\"create table orders(orderID INT,customerID INT,totalPrice price)\");\n-            s.execute(\"insert into orders values (12345, 12, makePrice('USD', 12))\");\n-\n-            s.execute(\"CREATE FUNCTION testConnection()\\n\" +\n-                    \"RETURNS VARCHAR(100)\\n\" +\n-                    \"LANGUAGE JAVA\\n\" +\n-                    \"PARAMETER STYLE JAVA \\n\" +\n-                    \"EXTERNAL NAME 'com.splicemachine.customer.NielsenTesting.testInternalConnection'\");\n-            s.execute(\"create table test(id integer, name varchar(30))\");\n-            s.execute(\"insert into test values(1,'erin')\");\n-        }\n+        w.execute(String.format(CALL_SET_CLASSPATH_FORMAT_STRING,JAR_FILE_SQL_NAME));\n+        w.execute(\"create derby aggregate median for int external name 'com.splicemachine.customer.Median'\");\n+\n+        Connection conn = w.getOrCreateConnection();\n+        new TableCreator(conn)\n+                .withCreate(\"create table t(i int)\")\n+                .withInsert(\"insert into t values(?)\")\n+                .withRows(rows(\n+                        row(1),\n+                        row(2),\n+                        row(3),\n+                        row(4),\n+                        row(5)))\n+                .create();\n+\n+        new TableCreator(conn)\n+                .withCreate(\"create table t1(itemName varchar(30), rawPrice int)\")\n+                .withInsert(\"insert into t1 values(?, ?)\")\n+                .withRows(rows(\n+                row(\"Coffee\", 4),\n+                row(\"Tea\", 3),\n+                row(\"Milk\", 2),\n+                row(\"Soda\", 2),\n+                row(\"Bagel\", 1),\n+                row(\"Donut\", 1)))\n+                .create();\n+\n+        w.execute(\"CREATE TYPE price EXTERNAL NAME 'com.splicemachine.customer.Price' language Java\");\n+        w.execute(\"CREATE FUNCTION makePrice(varchar(30), double)\\n\"+\n+                \"RETURNS Price\\n\"+\n+                \"LANGUAGE JAVA\\n\"+\n+                \"PARAMETER STYLE JAVA\\n\"+\n+                \"NO SQL EXTERNAL NAME 'com.splicemachine.customer.CreatePrice.createPriceObject'\");\n+\n+        w.execute(\"create function getAmount( int ) returns double language java parameter style java no sql\\n\" +\n+                       \"external name 'com.splicemachine.customer.Price.getAmount'\\n\" );\n+\n+        w.execute(\"create table orders(orderID INT,customerID INT,totalPrice price)\");\n+        w.execute(\"insert into orders values (12345, 12, makePrice('USD', 12))\");\n+\n+        w.execute(\"CREATE FUNCTION testConnection()\\n\" +\n+                \"RETURNS VARCHAR(100)\\n\" +\n+                \"LANGUAGE JAVA\\n\" +\n+                \"PARAMETER STYLE JAVA \\n\" +\n+                \"EXTERNAL NAME 'com.splicemachine.customer.NielsenTesting.testInternalConnection'\");\n+        w.execute(\"create table test(id integer, name varchar(30))\");\n+        w.execute(\"insert into test values(1,'erin')\");\n \n     }\n \n     @Test\n     public void testAggregationReferencingUDF() throws Exception {\n-        ResultSet rs;\n-        rs =  methodWatcher.executeQuery(\"SELECT count(*) FROM\\n\" +\n+        try(ResultSet rs =  methodWatcher.executeQuery(\"SELECT count(*) FROM\\n\" +\n                                                 \"(\\n\" +\n                                                 \"SELECT makePrice('USD', t1.rawPrice) AS ItemPrice\\n\" +\n                                                 \"FROM t1\" +\n-                                                \") x\");\n-        Assert.assertTrue(rs.next());\n-        Assert.assertEquals(6, rs.getInt(1));\n-\n-        rs =  methodWatcher.executeQuery(\"SELECT count(*) FROM\\n\" +\n-        \"(\\n\" +\n-        \"SELECT makePrice('USD', t1.rawPrice) AS ItemPrice\\n\" +\n-        \"FROM t1 JOIN t\\n\" +\n-        \"ON t.i = t1.rawPrice\\n\" +\n-        \") x\");\n-        Assert.assertTrue(rs.next());\n-        Assert.assertEquals(6, rs.getInt(1));\n-\n-        rs =  methodWatcher.executeQuery(\"SELECT count(*) from t1 where testconnection() < 'a'\");\n-        Assert.assertTrue(rs.next());\n-        Assert.assertEquals(6, rs.getInt(1));\n-\n-        rs =  methodWatcher.executeQuery(\"SELECT count(testconnection()) from t1\");\n-        Assert.assertTrue(rs.next());\n-        Assert.assertEquals(6, rs.getInt(1));\n+                                                \") x\")) {\n+            Assert.assertTrue(rs.next());\n+            Assert.assertEquals(6, rs.getInt(1));\n+        }\n+\n+        try(ResultSet rs =  methodWatcher.executeQuery(\"SELECT count(*) FROM\\n\" +\n+            \"(\\n\" +\n+            \"SELECT makePrice('USD', t1.rawPrice) AS ItemPrice\\n\" +\n+            \"FROM t1 JOIN t\\n\" +\n+            \"ON t.i = t1.rawPrice\\n\" +\n+            \") x\") ) {\n+            Assert.assertTrue(rs.next());\n+            Assert.assertEquals(6, rs.getInt(1));\n+        }\n+\n+        try(ResultSet rs =  methodWatcher.executeQuery(\"SELECT count(*) from t1 where testconnection() < 'a'\") ) {\n+            Assert.assertTrue(rs.next());\n+            Assert.assertEquals(6, rs.getInt(1));\n+        }\n+\n+        try(ResultSet rs =  methodWatcher.executeQuery(\"SELECT count(testconnection()) from t1\")) {\n+            Assert.assertTrue(rs.next());\n+            Assert.assertEquals(6, rs.getInt(1));\n+        }\n     }\n \n     @Test\n     public void testUDA() throws Exception {\n-        ResultSet rs = methodWatcher.executeQuery(\"select median(i) from t\");\n-        Assert.assertTrue(rs.next());\n-        Assert.assertEquals(3, rs.getInt(1));\n+        try(ResultSet rs = methodWatcher.executeQuery(\"select median(i) from t\")) {\n+            Assert.assertTrue(rs.next());\n+            Assert.assertEquals(3, rs.getInt(1));\n+        }\n     }\n \n     @Test\n     public void testUDT() throws Exception {\n-        ResultSet rs = methodWatcher.executeQuery(\"select orderID, customerID, totalPrice from orders\");\n-        Assert.assertTrue(rs.next());\n-        int oid = rs.getInt(1);\n-        int cid = rs.getInt(2);\n-        Price price = (Price)rs.getObject(3);\n-        Assert.assertEquals(12345, oid);\n-        Assert.assertEquals(12, cid);\n-        Assert.assertEquals(12, price.amount, 0.01);\n-        Assert.assertTrue(price.currencyCode.compareTo(\"USD\") == 0);\n+        try(ResultSet rs = methodWatcher.executeQuery(\"select orderID, customerID, totalPrice from orders\")) {\n+            Assert.assertTrue(rs.next());\n+            int oid = rs.getInt(1);\n+            int cid = rs.getInt(2);\n+            Price price = (Price) rs.getObject(3);\n+            Assert.assertEquals(12345, oid);\n+            Assert.assertEquals(12, cid);\n+            Assert.assertEquals(12, price.amount, 0.01);\n+            Assert.assertTrue(price.currencyCode.compareTo(\"USD\") == 0);\n+        }\n     }\n \n     @Test\n-    public void TestSelectStatistics() throws Exception {\n+    public void testSelectStatistics() throws Exception {\n         methodWatcher.execute(\"analyze schema \" + CLASS_NAME);\n-        ResultSet rs = methodWatcher.executeQuery(\"select count(*) from sysvw.syscolumnstatistics\");\n-        Assert.assertTrue(rs.next());\n-        Assert.assertTrue(rs.getInt(1)>0);\n+        try(ResultSet rs = methodWatcher.executeQuery(\"select count(*) from sysvw.syscolumnstatistics\") ) {\n+            Assert.assertTrue(rs.next());\n+            Assert.assertTrue(rs.getInt(1) > 0);\n+        }\n     }\n \n     @Test\n     public void testConnection() throws Exception {\n-        String url = \"jdbc:splice://localhost:1527/splicedb;create=true;user=splice;password=admin;useSpark=true\";\n-        Connection connection = DriverManager.getConnection(url, new Properties());\n-        connection.setSchema(CLASS_NAME.toUpperCase());\n-        Statement s = connection.createStatement();\n-        ResultSet rs = s.executeQuery(\"select testConnection() from test\");\n-        String result = rs.next() ? rs.getString(1) : null;\n-        Assert.assertNotNull(result);\n-        Assert.assertTrue(result, result.compareTo(\"Got an internal connection\")==0);\n+        try(SpliceWatcher watcher2 = new SpliceWatcher(CLASS_NAME))\n+        {\n+            watcher2.setConnection( watcher2.connectionBuilder().useOLAP(true).build() );\n+            ResultSet rs = watcher2.executeQuery(\"select testConnection() from test\");", "originalCommit": "bc86579b9617669350b8f5cc83f46dfb21bcef59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDQzNTU3NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4348#discussion_r510435574", "bodyText": "done", "author": "martinrupp", "createdAt": "2020-10-22T20:25:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk3MDkyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk3NzE2Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4348#discussion_r509977163", "bodyText": "This adds 5 seconds per class, at 311 ITs that's 25 more minutes of runtime. Maybe we should disable this by default and only enable it if VacuumIT is failing to debug?", "author": "dgomezferro", "createdAt": "2020-10-22T08:31:36Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/test/framework/SpliceUnitTest.java", "diffHunk": "@@ -1018,27 +1031,85 @@ public static int getNumberOfFiles(String dirPath)\n     }\n \n     /// execute sql query 'sqlText' and expect an exception of certain state being thrown\n-    public static void SqlExpectException( SpliceWatcher methodWatcher, String sqlText, String expectedState )\n+    public static void sqlExpectException(SpliceWatcher methodWatcher, String sqlText, String expectedState, boolean update)\n     {\n         try {\n-            ResultSet rs = methodWatcher.executeQuery(sqlText);\n-            rs.close();\n+            if( update )\n+                methodWatcher.executeUpdate(sqlText);\n+            else {\n+                ResultSet rs = methodWatcher.executeQuery(sqlText);\n+                rs.close();\n+            }\n             Assert.fail(\"Exception not thrown for \" + sqlText);\n \n         } catch (SQLException e) {\n-            System.out.println( e );\n             Assert.assertEquals(\"Wrong Exception for \" + sqlText, expectedState, e.getSQLState());\n+        } catch (Exception e) {\n+            Assert.assertEquals(\"Wrong Exception for \" + sqlText, expectedState, e.getClass().getName());\n         }\n     }\n \n     /// execute sql query 'sqlText' and expect a certain formatted result\n-    public static void SqlExpectToString( SpliceWatcher methodWatcher, String sqlText, String expected, boolean sort ) throws Exception\n+    public static void sqlExpectToString(SpliceWatcher methodWatcher, String sqlText, String expected, boolean sort ) throws Exception\n     {\n         try( ResultSet rs = methodWatcher.executeQuery(sqlText) ) {\n             String val = sort\n                     ? TestUtils.FormattedResult.ResultFactory.toString(rs)\n                     : TestUtils.FormattedResult.ResultFactory.toStringUnsorted(rs);\n-            Assert.assertEquals(expected, val);\n+            Assert.assertEquals(sqlText, expected, val);\n+        }\n+    }\n+\n+\n+    /**\n+     * check if there's any transactions still open\n+     * if getOldestActiveTransaction is two times the same in a row, there's a stale transaction\n+     * otherwise, we will get every time different ids since also the CALL SYSUTIL_... will open a mini-transaction\n+     *\n+     * Note that this is only correct if the test ends and nothing else is running anymore\n+     * (e.g. @Category({SerialTest.class}) ). Because of this, the default should be failOnError = false.\n+     * @param failOnError if true, fail on error (don't do this on parallel tests). otherwise, just LOG.\n+     */\n+    public static void waitForStaleTransactions(SpliceWatcher methodWatcher, String name, int numSeconds,\n+                                                boolean failOnError) throws Exception\n+    {\n+        Logger LOG = Logger.getLogger(\"SpliceUnitTest\");\n+        LOG.info(\"checking for stale transactions\");\n+\n+        int oldest1 = getOldestActiveTransaction(methodWatcher);\n+        for(int i=0; i < numSeconds; i++) {\n+            int oldest2 = getOldestActiveTransaction(methodWatcher);\n+            if( oldest1 != oldest2 )\n+                return;\n+            Thread.sleep(1000);\n+            oldest1 = oldest2;\n+        }\n+        if( failOnError ) {\n+            Assert.fail(name + \" failed to close all transactions.\");\n         }\n+        else {\n+            // if you see this error, this is a hint that something might be left open, especially if you see\n+            // multiple of these messages. turn failOnError=true and check tests one by one.\n+            LOG.info(\"WARNING: \" + name + \" failed to close all transactions. This might be due to multiple \" +\n+                \"tests running in parallel.\");\n+        }\n+    }\n+\n+    public static int getOldestActiveTransaction(SpliceWatcher methodWatcher) throws SQLException {\n+        try (ResultSet rs = methodWatcher.executeQuery(\"call SYSCS_UTIL.SYSCS_GET_OLDEST_ACTIVE_TRANSACTION()\"))\n+        {\n+            Assert.assertEquals(true, rs.next());\n+            return rs.getInt(1);\n+        }\n+    }\n+\n+    @AfterClass\n+    public static void waitForStaleTransactions() throws Exception {", "originalCommit": "bc86579b9617669350b8f5cc83f46dfb21bcef59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDAxMzU5OA==", "url": "https://github.com/splicemachine/spliceengine/pull/4348#discussion_r510013598", "bodyText": "@martinrupp explained on the normal case this shouldn't wait at all", "author": "dgomezferro", "createdAt": "2020-10-22T09:25:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTk3NzE2Mw=="}], "type": "inlineReview"}, {"oid": "94ee68628958dd0ee58e80ed02467739f923db8a", "url": "https://github.com/splicemachine/spliceengine/commit/94ee68628958dd0ee58e80ed02467739f923db8a", "message": "DB-10534 fix for database closed (e.g. RestoreIT)", "committedDate": "2020-10-27T12:45:29Z", "type": "forcePushed"}, {"oid": "988841580d8d17387755be76a35e83dca6b7d256", "url": "https://github.com/splicemachine/spliceengine/commit/988841580d8d17387755be76a35e83dca6b7d256", "message": "DB-10534 fix VacuumIT", "committedDate": "2020-10-29T08:21:55Z", "type": "commit"}, {"oid": "173fb2284046c7a95a70d7c0ab07721a78f64c58", "url": "https://github.com/splicemachine/spliceengine/commit/173fb2284046c7a95a70d7c0ab07721a78f64c58", "message": "DB-10534 more unclosed Transaction fixes", "committedDate": "2020-10-29T08:21:55Z", "type": "commit"}, {"oid": "a4d35ab492dc2583ff1e2cea95335d7762041f59", "url": "https://github.com/splicemachine/spliceengine/commit/a4d35ab492dc2583ff1e2cea95335d7762041f59", "message": "DB-10534 fix Spotbugs", "committedDate": "2020-10-29T08:21:55Z", "type": "commit"}, {"oid": "268f5c78108b5e1dbf66846ee76b60ad11edcdb8", "url": "https://github.com/splicemachine/spliceengine/commit/268f5c78108b5e1dbf66846ee76b60ad11edcdb8", "message": "DB-10534 fix another issue in SpliceUDT", "committedDate": "2020-10-29T08:21:55Z", "type": "commit"}, {"oid": "1133b377e1fe702659dfa8e555a74571ed68d002", "url": "https://github.com/splicemachine/spliceengine/commit/1133b377e1fe702659dfa8e555a74571ed68d002", "message": "DB-10534 don't always fail when detecting open transactions (parallel tests false positives)", "committedDate": "2020-10-29T08:21:55Z", "type": "commit"}, {"oid": "39160051e97a569c9e274a62c5f63c651cfbf466", "url": "https://github.com/splicemachine/spliceengine/commit/39160051e97a569c9e274a62c5f63c651cfbf466", "message": "DB-10534 address comment", "committedDate": "2020-10-29T08:21:55Z", "type": "commit"}, {"oid": "b73f9ce466cddab0525fcae47ecea37cf23c502f", "url": "https://github.com/splicemachine/spliceengine/commit/b73f9ce466cddab0525fcae47ecea37cf23c502f", "message": "DB-10534 fix mem ITs", "committedDate": "2020-10-29T08:21:55Z", "type": "commit"}, {"oid": "c1a8653a683afd1edbce4821c5ac6378e5ea5629", "url": "https://github.com/splicemachine/spliceengine/commit/c1a8653a683afd1edbce4821c5ac6378e5ea5629", "message": "DB-10534 fix for database closed (e.g. RestoreIT)", "committedDate": "2020-10-29T08:21:55Z", "type": "commit"}, {"oid": "c1a8653a683afd1edbce4821c5ac6378e5ea5629", "url": "https://github.com/splicemachine/spliceengine/commit/c1a8653a683afd1edbce4821c5ac6378e5ea5629", "message": "DB-10534 fix for database closed (e.g. RestoreIT)", "committedDate": "2020-10-29T08:21:55Z", "type": "forcePushed"}]}