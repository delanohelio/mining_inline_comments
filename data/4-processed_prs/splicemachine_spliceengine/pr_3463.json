{"pr_number": 3463, "pr_title": "DB-9361: remove duplicate indexes", "pr_createdAt": "2020-04-21T23:17:04Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/3463", "timeline": [{"oid": "988ba9edfcc2984c9c2cb9a8ec63f88bcdaac9ac", "url": "https://github.com/splicemachine/spliceengine/commit/988ba9edfcc2984c9c2cb9a8ec63f88bcdaac9ac", "message": "DB-9361: remove duplicate indexes", "committedDate": "2020-04-22T22:17:11Z", "type": "forcePushed"}, {"oid": "d0cbc26fb625b5340e458eaa852e54d255643c68", "url": "https://github.com/splicemachine/spliceengine/commit/d0cbc26fb625b5340e458eaa852e54d255643c68", "message": "DB-9361: remove duplicate indexes", "committedDate": "2020-04-22T22:48:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUzMTY1OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3463#discussion_r421531659", "bodyText": "re-add SpliceSpark.popScope()\n(this function does SpliceSpark.pushScope , but SpliceSpark.popScope(); was moved (unintentionally i guess) to line 204))", "author": "martinrupp", "createdAt": "2020-05-07T14:06:39Z", "path": "hbase_sql/src/main/java/com/splicemachine/derby/stream/spark/SparkTableChecker.java", "diffHunk": "@@ -148,30 +148,58 @@ public void setTableDataSet(DataSet tableDataSet) {\n      * @throws InterruptedException\n      * @throws ExecutionException\n      */\n-    private List<String> checkDuplicateIndexes(PairDataSet index) throws StandardException, InterruptedException, ExecutionException {\n-        List<String> messages = Lists.newLinkedList();\n-        SpliceSpark.pushScope(String.format(\"Check duplicates in index %s.%s\", schemaName, indexName));\n-        JavaPairRDD duplicateIndexRdd = ((SparkPairDataSet)index).rdd\n-                .combineByKey(new createCombiner(), new mergeValue(), new mergeCombiners())\n-                .filter(new DuplicateIndexFilter());\n+    private List<String> checkDuplicateIndexes(PairDataSet table, PairDataSet index) throws StandardException {\n+        try {\n+            SpliceSpark.pushScope(String.format(\"Check duplicates in index %s.%s\", schemaName, indexName));\n+            JavaPairRDD duplicateIndexRdd = ((SparkPairDataSet) index).rdd\n+                    .combineByKey(new CreateCombiner(), new MergeValue(), new MergeCombiners())\n+                    .filter(new DuplicateIndexFilter());\n \n-        long count = 0;\n-        JavaFutureAction<List> futureAction = duplicateIndexRdd.takeAsync(maxCheckTableError);\n-        List<Tuple2<String, List<byte[]>>> result = futureAction.get();\n-        for(Tuple2<String, List<byte[]>> tuple : result) {\n-            List<byte[]> keys = tuple._2;\n-            for (byte[] key : keys) {\n-                indexKeyDecoder.set(key, 0, key.length);\n-                indexKeyDecoder.decode(indexKeyTemplate);\n-                messages.add(indexKeyTemplate.getClone().toString() + \"=>\" + tuple._1);\n-                count++;\n+            JavaPairRDD joinedRdd = duplicateIndexRdd\n+                    .join(((SparkPairDataSet) table).rdd);\n+\n+            JavaRDD duplicateIndex = joinedRdd\n+                    .mapPartitions(new SparkFlatMapFunction<>(new DeleteDuplicateIndexFunction<>(conglomerate, txn, tentativeIndex, baseColumnMap, fix)));\n+\n+            Iterator it = duplicateIndex.toLocalIterator();\n+\n+            if (fix) {\n+                return fixDuplicateIndexes(it);\n+            } else {\n+                return reportDuplicateIndexes(it);\n             }\n+        }catch (Exception e) {\n+            throw StandardException.plainWrapException(e);\n         }\n-        if (count >= maxCheckTableError) {\n-            count = duplicateIndexRdd.count();\n-            messages.add(\"...\");\n+    }", "originalCommit": "d0cbc26fb625b5340e458eaa852e54d255643c68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUzMTg5Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3463#discussion_r421531896", "bodyText": "remove popScope", "author": "martinrupp", "createdAt": "2020-05-07T14:06:56Z", "path": "hbase_sql/src/main/java/com/splicemachine/derby/stream/spark/SparkTableChecker.java", "diffHunk": "@@ -148,30 +148,58 @@ public void setTableDataSet(DataSet tableDataSet) {\n      * @throws InterruptedException\n      * @throws ExecutionException\n      */\n-    private List<String> checkDuplicateIndexes(PairDataSet index) throws StandardException, InterruptedException, ExecutionException {\n-        List<String> messages = Lists.newLinkedList();\n-        SpliceSpark.pushScope(String.format(\"Check duplicates in index %s.%s\", schemaName, indexName));\n-        JavaPairRDD duplicateIndexRdd = ((SparkPairDataSet)index).rdd\n-                .combineByKey(new createCombiner(), new mergeValue(), new mergeCombiners())\n-                .filter(new DuplicateIndexFilter());\n+    private List<String> checkDuplicateIndexes(PairDataSet table, PairDataSet index) throws StandardException {\n+        try {\n+            SpliceSpark.pushScope(String.format(\"Check duplicates in index %s.%s\", schemaName, indexName));\n+            JavaPairRDD duplicateIndexRdd = ((SparkPairDataSet) index).rdd\n+                    .combineByKey(new CreateCombiner(), new MergeValue(), new MergeCombiners())\n+                    .filter(new DuplicateIndexFilter());\n \n-        long count = 0;\n-        JavaFutureAction<List> futureAction = duplicateIndexRdd.takeAsync(maxCheckTableError);\n-        List<Tuple2<String, List<byte[]>>> result = futureAction.get();\n-        for(Tuple2<String, List<byte[]>> tuple : result) {\n-            List<byte[]> keys = tuple._2;\n-            for (byte[] key : keys) {\n-                indexKeyDecoder.set(key, 0, key.length);\n-                indexKeyDecoder.decode(indexKeyTemplate);\n-                messages.add(indexKeyTemplate.getClone().toString() + \"=>\" + tuple._1);\n-                count++;\n+            JavaPairRDD joinedRdd = duplicateIndexRdd\n+                    .join(((SparkPairDataSet) table).rdd);\n+\n+            JavaRDD duplicateIndex = joinedRdd\n+                    .mapPartitions(new SparkFlatMapFunction<>(new DeleteDuplicateIndexFunction<>(conglomerate, txn, tentativeIndex, baseColumnMap, fix)));\n+\n+            Iterator it = duplicateIndex.toLocalIterator();\n+\n+            if (fix) {\n+                return fixDuplicateIndexes(it);\n+            } else {\n+                return reportDuplicateIndexes(it);\n             }\n+        }catch (Exception e) {\n+            throw StandardException.plainWrapException(e);\n         }\n-        if (count >= maxCheckTableError) {\n-            count = duplicateIndexRdd.count();\n-            messages.add(\"...\");\n+    }\n+\n+\n+    private List<String> fixDuplicateIndexes(Iterator it) {\n+        List<String> messages = Lists.newLinkedList();\n+\n+        long count = 0;\n+        while (it.hasNext()) {\n+            Tuple2<String, Tuple2<byte[], ExecRow>> t = (Tuple2<String, Tuple2<byte[], ExecRow>>)it.next();\n+            messages.add(t._2._2 + \"=>\" + t._1);\n+            count++;\n         }\n+        messages.add(0,String.format(\"Deleted the following %d duplicate indexes\", count));\n+        return messages;\n+    }\n+\n+    private List<String> reportDuplicateIndexes(Iterator it) throws StandardException, InterruptedException, ExecutionException {\n+        List<String> messages = Lists.newLinkedList();\n \n+        long count = 0;\n+        while (it.hasNext()) {\n+            Tuple2<String, Tuple2<byte[], ExecRow>> t = (Tuple2<String, Tuple2<byte[], ExecRow>>)it.next();\n+            messages.add(t._2._2 + \"=>\" + t._1);\n+            if (count >= maxCheckTableError) {\n+                messages.add(\"...\");\n+                break;\n+            }\n+            count++;\n+        }\n         messages.add(0, String.format(\"The following %d indexes are duplicates:\", count));\n         SpliceSpark.popScope();", "originalCommit": "d0cbc26fb625b5340e458eaa852e54d255643c68", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwNDA5NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3463#discussion_r423904095", "bodyText": "Good catch!", "author": "jyuanca", "createdAt": "2020-05-12T17:21:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUzMTg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUzNTA0Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3463#discussion_r421535046", "bodyText": "the only difference i see between these two functions is\nif(count >= maxCheckTableError) . I don't see how fixDuplicateIndexes fixes anything.\nIn general, we could do\nprivate List<String> reportDuplicateIndexes(Iterator it, int _maxCheckTableError)\nthen have\nif (_maxCheckTableError >= 0 || count >= _maxCheckTableError)\nand then do\nreturn reportDuplicateIndexes(it, fix ? -1 : maxCheckTableError);", "author": "martinrupp", "createdAt": "2020-05-07T14:11:07Z", "path": "hbase_sql/src/main/java/com/splicemachine/derby/stream/spark/SparkTableChecker.java", "diffHunk": "@@ -148,30 +148,58 @@ public void setTableDataSet(DataSet tableDataSet) {\n      * @throws InterruptedException\n      * @throws ExecutionException\n      */\n-    private List<String> checkDuplicateIndexes(PairDataSet index) throws StandardException, InterruptedException, ExecutionException {\n-        List<String> messages = Lists.newLinkedList();\n-        SpliceSpark.pushScope(String.format(\"Check duplicates in index %s.%s\", schemaName, indexName));\n-        JavaPairRDD duplicateIndexRdd = ((SparkPairDataSet)index).rdd\n-                .combineByKey(new createCombiner(), new mergeValue(), new mergeCombiners())\n-                .filter(new DuplicateIndexFilter());\n+    private List<String> checkDuplicateIndexes(PairDataSet table, PairDataSet index) throws StandardException {\n+        try {\n+            SpliceSpark.pushScope(String.format(\"Check duplicates in index %s.%s\", schemaName, indexName));\n+            JavaPairRDD duplicateIndexRdd = ((SparkPairDataSet) index).rdd\n+                    .combineByKey(new CreateCombiner(), new MergeValue(), new MergeCombiners())\n+                    .filter(new DuplicateIndexFilter());\n \n-        long count = 0;\n-        JavaFutureAction<List> futureAction = duplicateIndexRdd.takeAsync(maxCheckTableError);\n-        List<Tuple2<String, List<byte[]>>> result = futureAction.get();\n-        for(Tuple2<String, List<byte[]>> tuple : result) {\n-            List<byte[]> keys = tuple._2;\n-            for (byte[] key : keys) {\n-                indexKeyDecoder.set(key, 0, key.length);\n-                indexKeyDecoder.decode(indexKeyTemplate);\n-                messages.add(indexKeyTemplate.getClone().toString() + \"=>\" + tuple._1);\n-                count++;\n+            JavaPairRDD joinedRdd = duplicateIndexRdd\n+                    .join(((SparkPairDataSet) table).rdd);\n+\n+            JavaRDD duplicateIndex = joinedRdd\n+                    .mapPartitions(new SparkFlatMapFunction<>(new DeleteDuplicateIndexFunction<>(conglomerate, txn, tentativeIndex, baseColumnMap, fix)));\n+\n+            Iterator it = duplicateIndex.toLocalIterator();\n+\n+            if (fix) {\n+                return fixDuplicateIndexes(it);\n+            } else {\n+                return reportDuplicateIndexes(it);\n             }\n+        }catch (Exception e) {\n+            throw StandardException.plainWrapException(e);\n         }\n-        if (count >= maxCheckTableError) {\n-            count = duplicateIndexRdd.count();\n-            messages.add(\"...\");\n+    }\n+\n+\n+    private List<String> fixDuplicateIndexes(Iterator it) {\n+        List<String> messages = Lists.newLinkedList();\n+\n+        long count = 0;\n+        while (it.hasNext()) {\n+            Tuple2<String, Tuple2<byte[], ExecRow>> t = (Tuple2<String, Tuple2<byte[], ExecRow>>)it.next();\n+            messages.add(t._2._2 + \"=>\" + t._1);\n+            count++;\n         }\n+        messages.add(0,String.format(\"Deleted the following %d duplicate indexes\", count));\n+        return messages;\n+    }\n+\n+    private List<String> reportDuplicateIndexes(Iterator it) throws StandardException, InterruptedException, ExecutionException {\n+        List<String> messages = Lists.newLinkedList();\n \n+        long count = 0;\n+        while (it.hasNext()) {\n+            Tuple2<String, Tuple2<byte[], ExecRow>> t = (Tuple2<String, Tuple2<byte[], ExecRow>>)it.next();\n+            messages.add(t._2._2 + \"=>\" + t._1);\n+            if (count >= maxCheckTableError) {\n+                messages.add(\"...\");\n+                break;", "originalCommit": "d0cbc26fb625b5340e458eaa852e54d255643c68", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUzNzI5MA==", "url": "https://github.com/splicemachine/spliceengine/pull/3463#discussion_r421537290", "bodyText": "i think fixDuplicateIndexes is missing the lines https://github.com/splicemachine/spliceengine/pull/3463/files#diff-49eff1a8a3acfe993feb4e304ff615ceL161-L167 , no?", "author": "martinrupp", "createdAt": "2020-05-07T14:14:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUzNTA0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzkwNTEzNg==", "url": "https://github.com/splicemachine/spliceengine/pull/3463#discussion_r423905136", "bodyText": "Depending on whether fix is true\nJavaRDD duplicateIndex = joinedRdd\n.mapPartitions(new SparkFlatMapFunction<>(new DeleteDuplicateIndexFunction<>(conglomerate, txn, tentativeIndex, baseColumnMap, fix)));\nDeleteDuplicateIndexFunction deletes (or ignores)  extra indexes", "author": "jyuanca", "createdAt": "2020-05-12T17:22:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUzNTA0Ng=="}], "type": "inlineReview"}, {"oid": "67c91c383ccedb0ab21f5ea6550487c0ae670ec9", "url": "https://github.com/splicemachine/spliceengine/commit/67c91c383ccedb0ab21f5ea6550487c0ae670ec9", "message": "address review comments", "committedDate": "2020-05-12T17:44:39Z", "type": "forcePushed"}, {"oid": "86bd323035855ccd88ad80c0624ae69b283712d1", "url": "https://github.com/splicemachine/spliceengine/commit/86bd323035855ccd88ad80c0624ae69b283712d1", "message": "DB-9361: remove duplicate indexes", "committedDate": "2020-05-12T17:55:26Z", "type": "commit"}, {"oid": "38166536439f08fddfb6730303779d8ba941eca6", "url": "https://github.com/splicemachine/spliceengine/commit/38166536439f08fddfb6730303779d8ba941eca6", "message": "address review comments", "committedDate": "2020-05-12T17:56:00Z", "type": "commit"}, {"oid": "38166536439f08fddfb6730303779d8ba941eca6", "url": "https://github.com/splicemachine/spliceengine/commit/38166536439f08fddfb6730303779d8ba941eca6", "message": "address review comments", "committedDate": "2020-05-12T17:56:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0Mzc2MA==", "url": "https://github.com/splicemachine/spliceengine/pull/3463#discussion_r424143760", "bodyText": "By aborting here, we won't be able to know the actual number of duplicate indexes, is this intended? Before the change, we can get the the actual number of duplicate indexes.", "author": "yxia92", "createdAt": "2020-05-13T02:51:08Z", "path": "hbase_sql/src/main/java/com/splicemachine/derby/stream/spark/SparkTableChecker.java", "diffHunk": "@@ -148,32 +148,62 @@ public void setTableDataSet(DataSet tableDataSet) {\n      * @throws InterruptedException\n      * @throws ExecutionException\n      */\n-    private List<String> checkDuplicateIndexes(PairDataSet index) throws StandardException, InterruptedException, ExecutionException {\n-        List<String> messages = Lists.newLinkedList();\n-        SpliceSpark.pushScope(String.format(\"Check duplicates in index %s.%s\", schemaName, indexName));\n-        JavaPairRDD duplicateIndexRdd = ((SparkPairDataSet)index).rdd\n-                .combineByKey(new createCombiner(), new mergeValue(), new mergeCombiners())\n-                .filter(new DuplicateIndexFilter());\n+    private List<String> checkDuplicateIndexes(PairDataSet table, PairDataSet index) throws StandardException {\n+        try {\n+            SpliceSpark.pushScope(String.format(\"Check duplicates in index %s.%s\", schemaName, indexName));\n+            JavaPairRDD duplicateIndexRdd = ((SparkPairDataSet) index).rdd\n+                    .combineByKey(new CreateCombiner(), new MergeValue(), new MergeCombiners())\n+                    .filter(new DuplicateIndexFilter());\n \n-        long count = 0;\n-        JavaFutureAction<List> futureAction = duplicateIndexRdd.takeAsync(maxCheckTableError);\n-        List<Tuple2<String, List<byte[]>>> result = futureAction.get();\n-        for(Tuple2<String, List<byte[]>> tuple : result) {\n-            List<byte[]> keys = tuple._2;\n-            for (byte[] key : keys) {\n-                indexKeyDecoder.set(key, 0, key.length);\n-                indexKeyDecoder.decode(indexKeyTemplate);\n-                messages.add(indexKeyTemplate.getClone().toString() + \"=>\" + tuple._1);\n-                count++;\n+            JavaPairRDD joinedRdd = duplicateIndexRdd\n+                    .join(((SparkPairDataSet) table).rdd);\n+\n+            JavaRDD duplicateIndex = joinedRdd\n+                    .mapPartitions(new SparkFlatMapFunction<>(new DeleteDuplicateIndexFunction<>(conglomerate, txn, tentativeIndex, baseColumnMap, fix)));\n+\n+            Iterator it = duplicateIndex.toLocalIterator();\n+\n+            if (fix) {\n+                return fixDuplicateIndexes(it);\n+            } else {\n+                return reportDuplicateIndexes(it);\n             }\n+        }catch (Exception e) {\n+            throw StandardException.plainWrapException(e);\n+        }\n+        finally {\n+            SpliceSpark.popScope();\n         }\n-        if (count >= maxCheckTableError) {\n-            count = duplicateIndexRdd.count();\n-            messages.add(\"...\");\n+    }\n+\n+\n+    private List<String> fixDuplicateIndexes(Iterator it) {\n+        List<String> messages = Lists.newLinkedList();\n+\n+        long count = 0;\n+        while (it.hasNext()) {\n+            Tuple2<String, Tuple2<byte[], ExecRow>> t = (Tuple2<String, Tuple2<byte[], ExecRow>>)it.next();\n+            messages.add(t._2._2 + \"=>\" + t._1);\n+            count++;\n         }\n+        messages.add(0,String.format(\"Deleted the following %d duplicate indexes\", count));\n+        return messages;\n+    }\n+\n+    private List<String> reportDuplicateIndexes(Iterator it) throws StandardException, InterruptedException, ExecutionException {\n+        List<String> messages = Lists.newLinkedList();\n \n+        long count = 0;\n+        while (it.hasNext()) {\n+            Tuple2<String, Tuple2<byte[], ExecRow>> t = (Tuple2<String, Tuple2<byte[], ExecRow>>)it.next();\n+            messages.add(t._2._2 + \"=>\" + t._1);\n+            if (count >= maxCheckTableError) {\n+                messages.add(\"...\");\n+                break;", "originalCommit": "38166536439f08fddfb6730303779d8ba941eca6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyMzY3Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/3463#discussion_r424523672", "bodyText": "This was intentional to avoid counting exact number. However, my second thought is that it is rarely a very expensive operations, so I will revert back", "author": "jyuanca", "createdAt": "2020-05-13T15:21:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE0Mzc2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1MzA4NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3463#discussion_r424153085", "bodyText": "We seem to assume that if there are duplicate index rows, the extra ones must have different values than the base row. Is it possible that the extra index row also has the same values as the base row?", "author": "yxia92", "createdAt": "2020-05-13T03:31:56Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/stream/control/ControlTableChecker.java", "diffHunk": "@@ -134,41 +136,100 @@ private void populateData(PairDataSet table, PairDataSet index) {\n \n         indexData = ArrayListMultimap.create();\n         indexCount = 0;\n-        Iterator<Tuple2<String, byte[]>> indexSource = ((ControlPairDataSet)index).source;\n+        Iterator<Tuple2<String, Tuple2<byte[], ExecRow>>> indexSource = ((ControlPairDataSet)index).source;\n         while(indexSource.hasNext()) {\n             indexCount++;\n-            Tuple2<String, byte[]> t = indexSource.next();\n+            Tuple2<String, Tuple2<byte[], ExecRow>> t = indexSource.next();\n             String baseRowId = t._1;\n-            byte[] indexKey = t._2;\n-            indexData.put(baseRowId, indexKey);\n+            Tuple2<byte[], ExecRow> row = t._2;\n+            indexData.put(baseRowId, row);\n         }\n     }\n \n     private List<String> checkDuplicateIndexes() throws StandardException {\n-        List<String> messages = new LinkedList<>();\n-        ArrayListMultimap<String, byte[]> result = ArrayListMultimap.create();\n+        ArrayListMultimap<String, Tuple2<byte[], ExecRow>> result = ArrayListMultimap.create();\n         long duplicateIndexCount = 0;\n         for (String baseRowId : indexData.keySet()) {\n-            List<byte[]> rows = indexData.get(baseRowId);\n+            List<Tuple2<byte[], ExecRow>> rows = indexData.get(baseRowId);\n             if (rows.size() > 1) {\n-                duplicateIndexCount += rows.size();\n+                duplicateIndexCount += rows.size()-1;\n                 result.putAll(baseRowId, rows);\n             }\n         }\n-        int i = 0;\n         if (duplicateIndexCount > 0) {\n-            messages.add(String.format(\"The following %d indexes are duplicates:\", duplicateIndexCount));\n+            if (fix) {\n+                fixDuplicateIndexes(result);\n+            }\n+            return reportDuplicateIndexes(result, duplicateIndexCount);\n+        }\n+        return new LinkedList<>();\n+    }\n+\n+    private void fixDuplicateIndexes(ArrayListMultimap<String, Tuple2<byte[], ExecRow>> result) throws StandardException {\n+        try {\n+            WriteCoordinator writeCoordinator = PipelineDriver.driver().writeCoordinator();\n+            WriteConfiguration writeConfiguration = writeCoordinator.defaultWriteConfiguration();\n+            Partition indexPartition = SIDriver.driver().getTableFactory().getTable(Long.toString(conglomerate));\n+            RecordingCallBuffer<KVPair> writeBuffer = writeCoordinator.writeBuffer(indexPartition, txn, null, writeConfiguration);\n+\n+            List<Integer> indexToMain = tentativeIndex.getIndex().getIndexColsToMainColMapList();\n             for (String baseRowId : result.keySet()) {\n-                List<byte[]> indexKeys = result.get(baseRowId);\n-                for (byte[] indexKey : indexKeys) {\n-                    if (i >= maxCheckTableErrors) {\n+                ExecRow baseRow = tableData.get(baseRowId);\n+                List<Tuple2<byte[], ExecRow>> indexRows = result.get(baseRowId);\n+                for (Tuple2<byte[], ExecRow> indexRow : indexRows) {\n+                    boolean duplicate = false;\n+                    DataValueDescriptor[] dvds = indexRow._2.getRowArray();\n+                    for (int i = 0; i < dvds.length - 1; ++i) {\n+                        int col = baseColumnMap[indexToMain.get(i) - 1];\n+                        if (!dvds[i].equals(baseRow.getColumn(col + 1))) {\n+                            duplicate = true;\n+                            break;", "originalCommit": "38166536439f08fddfb6730303779d8ba941eca6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyMDMwOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3463#discussion_r424520309", "bodyText": "The index that has some column values as base row is the correct one and should be kept.", "author": "jyuanca", "createdAt": "2020-05-13T15:16:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE1MzA4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ0MjU3Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/3463#discussion_r424442577", "bodyText": "i still don't understand how this function is fixing any duplicate indices.\nit does pretty much the same as reportDuplicateIndexes when maxCheckTableError = infinity (well, except for the \"Deleted the following %d duplicate indexes\" / \"The following %d indexes are duplicates\" ).", "author": "martinrupp", "createdAt": "2020-05-13T13:36:04Z", "path": "hbase_sql/src/main/java/com/splicemachine/derby/stream/spark/SparkTableChecker.java", "diffHunk": "@@ -148,32 +148,62 @@ public void setTableDataSet(DataSet tableDataSet) {\n      * @throws InterruptedException\n      * @throws ExecutionException\n      */\n-    private List<String> checkDuplicateIndexes(PairDataSet index) throws StandardException, InterruptedException, ExecutionException {\n-        List<String> messages = Lists.newLinkedList();\n-        SpliceSpark.pushScope(String.format(\"Check duplicates in index %s.%s\", schemaName, indexName));\n-        JavaPairRDD duplicateIndexRdd = ((SparkPairDataSet)index).rdd\n-                .combineByKey(new createCombiner(), new mergeValue(), new mergeCombiners())\n-                .filter(new DuplicateIndexFilter());\n+    private List<String> checkDuplicateIndexes(PairDataSet table, PairDataSet index) throws StandardException {\n+        try {\n+            SpliceSpark.pushScope(String.format(\"Check duplicates in index %s.%s\", schemaName, indexName));\n+            JavaPairRDD duplicateIndexRdd = ((SparkPairDataSet) index).rdd\n+                    .combineByKey(new CreateCombiner(), new MergeValue(), new MergeCombiners())\n+                    .filter(new DuplicateIndexFilter());\n \n-        long count = 0;\n-        JavaFutureAction<List> futureAction = duplicateIndexRdd.takeAsync(maxCheckTableError);\n-        List<Tuple2<String, List<byte[]>>> result = futureAction.get();\n-        for(Tuple2<String, List<byte[]>> tuple : result) {\n-            List<byte[]> keys = tuple._2;\n-            for (byte[] key : keys) {\n-                indexKeyDecoder.set(key, 0, key.length);\n-                indexKeyDecoder.decode(indexKeyTemplate);\n-                messages.add(indexKeyTemplate.getClone().toString() + \"=>\" + tuple._1);\n-                count++;\n+            JavaPairRDD joinedRdd = duplicateIndexRdd\n+                    .join(((SparkPairDataSet) table).rdd);\n+\n+            JavaRDD duplicateIndex = joinedRdd\n+                    .mapPartitions(new SparkFlatMapFunction<>(new DeleteDuplicateIndexFunction<>(conglomerate, txn, tentativeIndex, baseColumnMap, fix)));\n+\n+            Iterator it = duplicateIndex.toLocalIterator();\n+\n+            if (fix) {\n+                return fixDuplicateIndexes(it);\n+            } else {\n+                return reportDuplicateIndexes(it);\n             }\n+        }catch (Exception e) {\n+            throw StandardException.plainWrapException(e);\n+        }\n+        finally {\n+            SpliceSpark.popScope();\n         }\n-        if (count >= maxCheckTableError) {\n-            count = duplicateIndexRdd.count();\n-            messages.add(\"...\");\n+    }\n+\n+\n+    private List<String> fixDuplicateIndexes(Iterator it) {\n+        List<String> messages = Lists.newLinkedList();\n+\n+        long count = 0;\n+        while (it.hasNext()) {\n+            Tuple2<String, Tuple2<byte[], ExecRow>> t = (Tuple2<String, Tuple2<byte[], ExecRow>>)it.next();\n+            messages.add(t._2._2 + \"=>\" + t._1);\n+            count++;\n         }\n+        messages.add(0,String.format(\"Deleted the following %d duplicate indexes\", count));", "originalCommit": "38166536439f08fddfb6730303779d8ba941eca6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUyNDg5NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3463#discussion_r424524895", "bodyText": "The index is fixed by DeleteDuplicateIndexFunction. This function reports fixed indexes.", "author": "jyuanca", "createdAt": "2020-05-13T15:23:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ0MjU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDU1NjI2NA==", "url": "https://github.com/splicemachine/spliceengine/pull/3463#discussion_r424556264", "bodyText": "Let me restructure the code around here so not to cause confusion", "author": "jyuanca", "createdAt": "2020-05-13T16:04:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ0MjU3Nw=="}], "type": "inlineReview"}, {"oid": "0f885d37fd0e4c552dd86485df0d4f9a13310b5a", "url": "https://github.com/splicemachine/spliceengine/commit/0f885d37fd0e4c552dd86485df0d4f9a13310b5a", "message": "address review comments", "committedDate": "2020-05-14T13:06:53Z", "type": "commit"}, {"oid": "0f885d37fd0e4c552dd86485df0d4f9a13310b5a", "url": "https://github.com/splicemachine/spliceengine/commit/0f885d37fd0e4c552dd86485df0d4f9a13310b5a", "message": "address review comments", "committedDate": "2020-05-14T13:06:53Z", "type": "forcePushed"}]}