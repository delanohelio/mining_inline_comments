{"pr_number": 4162, "pr_title": "DB-10236 Take expression-based indexes as covering indexes properly", "pr_createdAt": "2020-09-21T09:44:33Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4162", "timeline": [{"oid": "14fe546ec41d9966447fba8619955372f4d21cc1", "url": "https://github.com/splicemachine/spliceengine/commit/14fe546ec41d9966447fba8619955372f4d21cc1", "message": "DB-10236 Fix SpotBugs", "committedDate": "2020-09-23T16:23:03Z", "type": "forcePushed"}, {"oid": "5c7e264195c5cd1059332c52d5307791bf296e95", "url": "https://github.com/splicemachine/spliceengine/commit/5c7e264195c5cd1059332c52d5307791bf296e95", "message": "DB-10175 Expression-based index scan with relational operator preds", "committedDate": "2020-10-07T14:08:11Z", "type": "commit"}, {"oid": "e22d448f521f0b4e81a9edae44a00a40fbe90cfd", "url": "https://github.com/splicemachine/spliceengine/commit/e22d448f521f0b4e81a9edae44a00a40fbe90cfd", "message": "DB-10175 Expression-based index scan with in-list predicates", "committedDate": "2020-10-07T14:08:11Z", "type": "commit"}, {"oid": "57ce9e16fc3de1c64638575483938d57d6795e42", "url": "https://github.com/splicemachine/spliceengine/commit/57ce9e16fc3de1c64638575483938d57d6795e42", "message": "DB-10175 Fix SpotBugs", "committedDate": "2020-10-07T14:08:11Z", "type": "commit"}, {"oid": "44ec6f37735acf851ff4a82268c0d544693b4790", "url": "https://github.com/splicemachine/spliceengine/commit/44ec6f37735acf851ff4a82268c0d544693b4790", "message": "DB-10175 Address comments", "committedDate": "2020-10-07T14:08:11Z", "type": "commit"}, {"oid": "0ffbe56cc0c711fb7b5e75a12eb20159832f1d72", "url": "https://github.com/splicemachine/spliceengine/commit/0ffbe56cc0c711fb7b5e75a12eb20159832f1d72", "message": "DB-10236 Fix SpotBugs", "committedDate": "2020-10-07T14:13:33Z", "type": "forcePushed"}, {"oid": "9e3af248dd4661a171b634971791d42033e722d5", "url": "https://github.com/splicemachine/spliceengine/commit/9e3af248dd4661a171b634971791d42033e722d5", "message": "DB-10236 Fix SpotBugs", "committedDate": "2020-10-08T14:21:25Z", "type": "forcePushed"}, {"oid": "b965fdf6ac44f431b541813d79344aec6776bde4", "url": "https://github.com/splicemachine/spliceengine/commit/b965fdf6ac44f431b541813d79344aec6776bde4", "message": "Merge branch 'master' into DB-10175", "committedDate": "2020-10-15T11:22:30Z", "type": "commit"}, {"oid": "317898efdf1bf6ad03f6da2230cb4237c7acca9e", "url": "https://github.com/splicemachine/spliceengine/commit/317898efdf1bf6ad03f6da2230cb4237c7acca9e", "message": "DB-10236 Fix TernaryOperator handling in index expression rewriting", "committedDate": "2020-10-15T11:37:51Z", "type": "forcePushed"}, {"oid": "1516c436841f204c294d1ac4329eeea983ef3802", "url": "https://github.com/splicemachine/spliceengine/commit/1516c436841f204c294d1ac4329eeea983ef3802", "message": "Merge branch 'master' into DB-10175", "committedDate": "2020-10-22T09:06:54Z", "type": "commit"}, {"oid": "c5d12ed61478bccf565395f8029144a5314879b4", "url": "https://github.com/splicemachine/spliceengine/commit/c5d12ed61478bccf565395f8029144a5314879b4", "message": "Merge branch 'master' into DB-10175", "committedDate": "2020-10-23T12:46:54Z", "type": "commit"}, {"oid": "e3acbd50dffaed40a0feb9068ad4d8eb155fb4d5", "url": "https://github.com/splicemachine/spliceengine/commit/e3acbd50dffaed40a0feb9068ad4d8eb155fb4d5", "message": "DB-10236 Fix TernaryOperator handling in index expression rewriting", "committedDate": "2020-10-23T12:47:57Z", "type": "forcePushed"}, {"oid": "4c65948d27940e0e3567baa1adc0839afc56da45", "url": "https://github.com/splicemachine/spliceengine/commit/4c65948d27940e0e3567baa1adc0839afc56da45", "message": "Merge branch 'master' into DB-10175", "committedDate": "2020-10-26T08:16:31Z", "type": "commit"}, {"oid": "e06325c12c5c50abc3cc93e6c3b406ce657a5c77", "url": "https://github.com/splicemachine/spliceengine/commit/e06325c12c5c50abc3cc93e6c3b406ce657a5c77", "message": "DB-10236 Rewrite query for a covering expression-based index\n\nIn this change, rewriting happens in:\n\n- where clause\n- group by clause\n- order by clause\n- having clause, including aggregates\n- select list, including aggregates", "committedDate": "2020-10-26T08:17:27Z", "type": "commit"}, {"oid": "7c1e30772a08c639076530ca35d0220475f6190b", "url": "https://github.com/splicemachine/spliceengine/commit/7c1e30772a08c639076530ca35d0220475f6190b", "message": "DB-10236 Make joins work correctly for covering expr index", "committedDate": "2020-10-26T08:17:27Z", "type": "commit"}, {"oid": "7554fbf220cd6282423c68ce60e6ec3e5021056e", "url": "https://github.com/splicemachine/spliceengine/commit/7554fbf220cd6282423c68ce60e6ec3e5021056e", "message": "DB-10236 Fix SpotBugs", "committedDate": "2020-10-26T08:17:27Z", "type": "commit"}, {"oid": "c136be91f09b0a1fa2c9b9786fb30c61fced173d", "url": "https://github.com/splicemachine/spliceengine/commit/c136be91f09b0a1fa2c9b9786fb30c61fced173d", "message": "DB-10236 Fix TernaryOperator handling in index expression rewriting", "committedDate": "2020-10-26T08:17:27Z", "type": "commit"}, {"oid": "c136be91f09b0a1fa2c9b9786fb30c61fced173d", "url": "https://github.com/splicemachine/spliceengine/commit/c136be91f09b0a1fa2c9b9786fb30c61fced173d", "message": "DB-10236 Fix TernaryOperator handling in index expression rewriting", "committedDate": "2020-10-26T08:17:27Z", "type": "forcePushed"}, {"oid": "d9f90256bb404ab2ad137a4fee677c2b0dc3a3d5", "url": "https://github.com/splicemachine/spliceengine/commit/d9f90256bb404ab2ad137a4fee677c2b0dc3a3d5", "message": "Merge branch 'master' into DB-10175", "committedDate": "2020-10-27T15:47:00Z", "type": "commit"}, {"oid": "bf9602776fbe57fac0d07cbe0dff0c086932f8e4", "url": "https://github.com/splicemachine/spliceengine/commit/bf9602776fbe57fac0d07cbe0dff0c086932f8e4", "message": "DB-10175 Address comments", "committedDate": "2020-10-27T15:56:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk3MzQ5Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r512973493", "bodyText": "It would be a good idea to use a different method than equals in all of the locations where we compare index expressions, like a wrapper function.  For now, perhaps the wrapper function would call equals, but later, when we want a+1 to be matched equivalent with 1+a, we can simply add the new logic to that method and all the required locations will see the new logic.", "author": "msirek", "createdAt": "2020-10-27T19:33:42Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/ValueNode.java", "diffHunk": "@@ -1512,4 +1522,70 @@ public int getOuterJoinLevel() {\n     public void setOuterJoinLevel(int level) {\n         return;\n     }\n+\n+    public ValueNode replaceIndexExpression(ResultColumnList childRCL) throws StandardException {\n+        // by default, try replace this whole subtree\n+        if (childRCL != null) {\n+            for (ResultColumn childRC : childRCL) {\n+                if (this.equals(childRC.getIndexExpression())) {", "originalCommit": "c136be91f09b0a1fa2c9b9786fb30c61fced173d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5Mjc3Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r515292772", "bodyText": "Yes, this is done in the latest changes in DB-10175 PR (#4110). Then I merged branch DB-10175 into this one and adapt the code. A few places need to be tuned because JavaToSQLValueNode is special in a sense that its sub-tree structure changes during binding. For this reason, we have to bind index expressions (partially, at least), too. It causes a bit trouble and the fix is in these commits: e15d6ad and 93d5dd9.", "author": "ascend1", "createdAt": "2020-10-30T18:13:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk3MzQ5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAwNDk2OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r513004969", "bodyText": "This check is too simple to cover all combinations.  For example:\n\ncreate table t1 (a int, b int, primary key(a));\ncreate index t1_idx on t1(a+1, b);\nexplain select count(*) from t1 --splice-properties index=t1_idx\nwhere a+1 > 1 and b+b > 1;\n->  GroupBy(n=4,totalCost=38.017,outputRows=1,outputHeapSize=0 B,partitions=1)\n->  ProjectRestrict(n=3,totalCost=30.413,outputRows=4,outputHeapSize=7 B,partitions=1)\n->  ProjectRestrict(n=2,totalCost=30.413,outputRows=4,outputHeapSize=7 B,partitions=1,preds=[((B[1:2] + B[1:2]) > 1)])\n->  IndexLookup(n=1,totalCost=30.413,outputRows=7,outputHeapSize=7 B,partitions=1)\n->  IndexScan[T1_IDX(7249)](n=0,totalCost=4.013,scannedRows=7,outputRows=7,outputHeapSize=7 B,partitions=1,baseTable=T1(7232),preds=[((A[1:1] + 1) > 1)])\n\nEven though column B is in the index, an expensive IndexLookup operation is done in order to evaluate b+b > 1.  Without expression-based indexes, the reference to b+b does not cause an IndexLookup.\nI'm not sure how we should handle this, perhaps by not marking rc.isReferenced for column A in this case, or maybe detecting whether all column references of a given column only occur as matched index expressions.  But having to do IndexLookup is very expensive so we want to always avoid it if possible.\nWe may want to resolve this before merging.  If not, at least open a Jira for it.", "author": "msirek", "createdAt": "2020-10-27T20:21:03Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java", "diffHunk": "@@ -561,6 +566,48 @@ public boolean isCoveringIndex(ConglomerateDescriptor cd) throws StandardExcepti\n         return coveringIndex;\n     }\n \n+    private boolean areAllReferencingExprsCoveredByIndex(IndexDescriptor id) throws StandardException {\n+        if (referencingExpressions == null || referencingExpressions.isEmpty()) {\n+            return false;\n+        }\n+        return getRefExprIndexPositions(id).size() == referencingExpressions.size();", "originalCommit": "c136be91f09b0a1fa2c9b9786fb30c61fced173d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5ODU5MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r515298591", "bodyText": "I agree that the check is simple at the moment. However, doing something similar on expressions is probably more difficult than on column references. In general, we can avoid IndexLookup in the following case:\n\ncreate index t1_idx on t1(a+1);\nselect * from t1 where 2*a+2 > 3;  -- possible to utilize (a+1) column without IndexLookup\n\nI think I can take care of the case you mentioned in the example, in which an index expression contains only a column reference. But for more general cases, I haven't got clear ideas on that.", "author": "ascend1", "createdAt": "2020-10-30T18:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAwNDk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzExMTMyNA==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r517111324", "bodyText": "Can you open a Jira to take care of the general case?  I believe regular indexes can handle such expressions without doing an IndexLookup.", "author": "msirek", "createdAt": "2020-11-04T05:54:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAwNDk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ2NDc1OA==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r517464758", "bodyText": "Yes, I'll open a Jira ticket to track this issue.", "author": "ascend1", "createdAt": "2020-11-04T16:19:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAwNDk2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ3MTI0NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r517471244", "bodyText": "Here it is: https://splicemachine.atlassian.net/browse/DB-10653", "author": "ascend1", "createdAt": "2020-11-04T16:28:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAwNDk2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA3Njg1NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r513076855", "bodyText": "This will disqualify the following case as a covering index:\ncreate table t1 (a1 int, b1 int, c1 int);\nreate index idx_t1 on t1(a1+1);\n\nexplain select count(*) from t1 --splice-properties index=idx_t1\n;", "author": "yxia92", "createdAt": "2020-10-27T22:45:05Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java", "diffHunk": "@@ -561,6 +566,48 @@ public boolean isCoveringIndex(ConglomerateDescriptor cd) throws StandardExcepti\n         return coveringIndex;\n     }\n \n+    private boolean areAllReferencingExprsCoveredByIndex(IndexDescriptor id) throws StandardException {\n+        if (referencingExpressions == null || referencingExpressions.isEmpty()) {\n+            return false;", "originalCommit": "c136be91f09b0a1fa2c9b9786fb30c61fced173d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjUxNTU1Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r516515556", "bodyText": "Right, this is part of the buggy proceed problem discussed below. I thought when the expression collecting process ended early, we set referencingExpressions to null as an indicator. But this is just wrong and opposite to its natural meaning. If no expression references this table, then an index on expressions should be covering, too. I removed the proceed flag in the other place and fixed the check here.", "author": "ascend1", "createdAt": "2020-11-03T09:10:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA3Njg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NzE4OA==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r513087188", "bodyText": "I'm thinking if it is possible to call collectExpression() in a separate phase right before the costing phase. At this stage, the tree is still under rewrite, so the tree form is still changing. For example, derived tables(FromSubqueryNode) and outer joins (HalfOuterJoinNode) haven't been flattened. They are done a little late in fromList.flattenFromTables(). The flattening of derived table and outer joins could change the mapping between the tablenumber and the expression, and may make more cases disqualified as covering index case. For example:\ncreate table t1 (a1 int, b1 int, c1 int);\ncreate index idx_t1 on t1(a1+1);\nsplice> explain select a1+1 from (select a1 from t1 --splice-properties index=idx_t1\n> ) dt;\nPlan                                                                                                                                                                                                                                                            \n----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------\nCursor(n=4,rows=20,updateMode=READ_ONLY (1),engine=OLTP (default))                                                                                                                                                                                              \n  ->  ScrollInsensitive(n=4,totalCost=88.227,outputRows=20,outputHeapSize=20 B,partitions=1)                                                                                                                                                                    \n    ->  ProjectRestrict(n=3,totalCost=84.027,outputRows=20,outputHeapSize=20 B,partitions=1)                                                                                                                                                                    \n      ->  IndexLookup(n=1,totalCost=84.027,outputRows=20,outputHeapSize=20 B,partitions=1)                                                                                                                                                                      \n        ->  IndexScan[IDX_T1(1681)](n=0,totalCost=4.027,scannedRows=20,outputRows=20,outputHeapSize=20 B,partitions=1,baseTable=T1(1664))                                                                                                                       \n\n5 rows selected\nELAPSED TIME = 167844 milliseconds\n\nHere the derived table would be flattened to\nexplain select a1+1 from t1;\n\nSo, the index could be qualified as a covering index.\nalso, unsatisiable tree pruning, constant folding and transitive closure also happen later, which could either eliminate expressions(due to unsat tree pruning/constant folding) or introduce more expressions (due to Transitive closure not currently, but maybe in the future by deriving condition like a1+1=a2 and a2=3 => a1+1=3.", "author": "yxia92", "createdAt": "2020-10-27T23:15:35Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/SelectNode.java", "diffHunk": "@@ -889,7 +891,8 @@ public ResultSetNode preprocess(int numTables,GroupByList gbl,FromList fl) throw\n          * ProjectRestrictNode. If it is a FromBaseTable, then we will generate\n          * the ProjectRestrictNode above it.\n          */\n-        fromList.preprocess(numTables,groupByList,whereClause);\n+        fromList.preprocess(numTables,groupByList,whereClause,\n+                exprMap == null ? collectExpression() : exprMap);", "originalCommit": "c136be91f09b0a1fa2c9b9786fb30c61fced173d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2NjA0Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r513166042", "bodyText": "In the presence of derived tables, we are only collecting the top-level expressions, as a result, we cannot qualify the index for the following query as a covering index:\ncreate table t1 (a1 int, b1 int, c1 int, d1 int);\ncreate index idx_t1 on t1(a1+1, b1+1);\ncreate table t2(a2 int, b2 int, c2 int);\n\ninsert into t1 values (2,2,2,2), (3,3,3,3), (4,4,4,4);\ninsert into t2 values (1,1,1), (2,2,2), (3,3,3), (4,4,4), (5,5,5);\n\n/* this query does not use covering index, however if we run the derived table by itself, we can qualify covering index */\nselect X from (select a1+1 as X, b2 from t1 --splice-properties index=idx_t1\n, t2 where b1+1=b2) dt, t2\nwhere X=3;\nPlan\n----\nCursor(n=14,rows=324,updateMode=READ_ONLY (1),engine=OLTP (default))\n  ->  ScrollInsensitive(n=14,totalCost=2654.904,outputRows=324,outputHeapSize=1.016 KB,partitions=1)\n    ->  NestedLoopJoin(n=11,totalCost=2514.624,outputRows=324,outputHeapSize=1.016 KB,partitions=1)\n      ->  TableScan[T2(1776)](n=9,totalCost=4.04,scannedRows=20,outputRows=20,outputHeapSize=1.016 KB,partitions=1)\n      ->  ProjectRestrict(n=8,totalCost=176.316,outputRows=16,outputHeapSize=52 B,partitions=1,preds=[(X[7:1] = 3)])\n        ->  ProjectRestrict(n=7,totalCost=92.286,outputRows=16,outputHeapSize=52 B,partitions=1)\n          ->  ProjectRestrict(n=6,totalCost=92.286,outputRows=16,outputHeapSize=52 B,partitions=1)\n            ->  BroadcastJoin(n=5,totalCost=92.286,outputRows=16,outputHeapSize=52 B,partitions=1,preds=[(B1[5:3] = B2[5:4])])\n              ->  TableScan[T2(1776)](n=3,totalCost=4.04,scannedRows=20,outputRows=20,outputHeapSize=52 B,partitions=1)\n              ->  ProjectRestrict(n=2,totalCost=84.03,outputRows=20,outputHeapSize=40 B,partitions=1)\n                ->  IndexLookup(n=1,totalCost=84.03,outputRows=20,outputHeapSize=40 B,partitions=1)\n                  ->  IndexScan[IDX_T1(1761)](n=0,totalCost=4.03,scannedRows=20,outputRows=20,outputHeapSize=40 B,partitions=1,baseTable=T1(1744))\n\n12 rows selected\nELAPSED TIME = 94 milliseconds", "author": "yxia92", "createdAt": "2020-10-28T03:57:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NzE4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA1NzUzMg==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r516057532", "bodyText": "Fix of this problem is in commit edd0881. There, expressions are collected right before calling resultSet.optimize(...). Also, a few test cases on derived tables including the two examples above are added.", "author": "ascend1", "createdAt": "2020-11-02T15:37:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4NzE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4OTEwNg==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r513089106", "bodyText": "this variable does not seem to be useful.", "author": "yxia92", "createdAt": "2020-10-27T23:20:51Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/SelectNode.java", "diffHunk": "@@ -2853,4 +2911,62 @@ public JBitSet collectInnerTablesFromFlattenedOJ() {\n         }\n         return collected;\n     }\n+\n+    private Map<Integer, List<ValueNode>> collectExpression() {\n+        HashMap<Integer, List<ValueNode>> result = new HashMap<>();\n+        boolean proceed = true;", "originalCommit": "c136be91f09b0a1fa2c9b9786fb30c61fced173d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4NDA4Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r516084086", "bodyText": "You're right. I was thinking that in case we find an expression that references more than one table, we know immediately that index on expressions defined on these tables cannot be covering. So we can quite the process earlier by not setting the referencingExprssions to these base tables. But this logic is buggy (for example, the whole map is cleared if we found one such expression, wrong for multiple tables' case anyway) and error-prone. So I removed it and always collect all expressions.", "author": "ascend1", "createdAt": "2020-11-02T16:13:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA4OTEwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA5MDA5Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r513090097", "bodyText": "We also need to check window function nodes.", "author": "yxia92", "createdAt": "2020-10-27T23:23:54Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/SelectNode.java", "diffHunk": "@@ -2853,4 +2911,62 @@ public JBitSet collectInnerTablesFromFlattenedOJ() {\n         }\n         return collected;\n     }\n+\n+    private Map<Integer, List<ValueNode>> collectExpression() {\n+        HashMap<Integer, List<ValueNode>> result = new HashMap<>();\n+        boolean proceed = true;\n+\n+        if (groupByList != null) {\n+            for (int i = 0; i < groupByList.size(); i++) {\n+                proceed = proceed && groupByList.getGroupByColumn(i).getColumnExpression().collectSingleExpression(result);\n+            }\n+        }\n+\n+        if (orderByList != null) {\n+            for (int i = 0; i < orderByList.size(); i++) {\n+                proceed = proceed && orderByList.getOrderByColumn(i).getColumnExpression().collectSingleExpression(result);\n+            }\n+        }\n+\n+        if (whereClause != null) {\n+            whereClause.collectExpressions(result);\n+        }\n+\n+        if (havingClause != null) {\n+            havingClause.collectExpressions(result);\n+        }\n+\n+        if (selectAggregates != null) {\n+            for (AggregateNode selectAggregate : selectAggregates) {\n+                selectAggregate.collectExpressions(result);\n+            }\n+        }\n+\n+        if (havingAggregates != null) {\n+            for (AggregateNode havingAggregate : havingAggregates) {\n+                havingAggregate.collectExpressions(result);\n+            }\n+        }\n+        // no need to check whereAggregates, should be empty\n+", "originalCommit": "c136be91f09b0a1fa2c9b9786fb30c61fced173d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ2NDAzOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r517464039", "bodyText": "Done.", "author": "ascend1", "createdAt": "2020-11-04T16:18:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA5MDA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA5NDI5Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r513094293", "bodyText": "We need to do the mapping for window function node also.", "author": "yxia92", "createdAt": "2020-10-27T23:37:08Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/SelectNode.java", "diffHunk": "@@ -1253,6 +1270,28 @@ public ResultSetNode genProjectRestrict(int origFromListSize) throws StandardExc\n         ** block.\n         */\n         if(((selectAggregates!=null) && (!selectAggregates.isEmpty())) || (groupByList!=null)){\n+            if (childResultColumns.isFromExprIndex()) {\n+                if (groupByList != null) {\n+                    groupByList.replaceIndexExpressions(childResultColumns);\n+                }\n+                if (havingClause != null) {\n+                    for (ResultColumn childRC : childResultColumns) {\n+                        IndexExpressionReplacementVisitor ierv =\n+                                new IndexExpressionReplacementVisitor(childRC, null);\n+                        havingClause.accept(ierv);\n+                    }\n+                }\n+                if (havingAggregates != null) {\n+                    for (AggregateNode havingAggr : havingAggregates) {\n+                        havingAggr.replaceIndexExpression(childResultColumns);\n+                    }\n+                }\n+                if (selectAggregates != null) {\n+                    for (AggregateNode selectAggr : selectAggregates) {\n+                        selectAggr.replaceIndexExpression(childResultColumns);\n+                    }\n+                }\n+            }", "originalCommit": "c136be91f09b0a1fa2c9b9786fb30c61fced173d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzQ2NDEzNw==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r517464137", "bodyText": "Done.", "author": "ascend1", "createdAt": "2020-11-04T16:18:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA5NDI5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjY5MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r513112690", "bodyText": "There is no need to check receiver. It is either left operand or right operand and used at the code generation phase.", "author": "yxia92", "createdAt": "2020-10-28T00:39:05Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryComparisonOperatorNode.java", "diffHunk": "@@ -495,4 +494,36 @@ public ValueNode genSQLJavaSQLTree() throws StandardException\n \n \t\treturn this;\n \t}\n+\n+\t@Override\n+\tpublic ValueNode replaceIndexExpression(ResultColumnList childRCL) throws StandardException {\n+\t\tif (childRCL == null) {\n+\t\t\treturn this;\n+\t\t}\n+\t\tif (receiver != null) {", "originalCommit": "c136be91f09b0a1fa2c9b9786fb30c61fced173d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4NTQzMQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r516085431", "bodyText": "Done.", "author": "ascend1", "createdAt": "2020-11-02T16:15:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjgyMw==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r513112823", "bodyText": "Same here, no need to look at receiver.", "author": "yxia92", "createdAt": "2020-10-28T00:39:27Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryComparisonOperatorNode.java", "diffHunk": "@@ -495,4 +494,36 @@ public ValueNode genSQLJavaSQLTree() throws StandardException\n \n \t\treturn this;\n \t}\n+\n+\t@Override\n+\tpublic ValueNode replaceIndexExpression(ResultColumnList childRCL) throws StandardException {\n+\t\tif (childRCL == null) {\n+\t\t\treturn this;\n+\t\t}\n+\t\tif (receiver != null) {\n+\t\t\treceiver = receiver.replaceIndexExpression(childRCL);\n+\t\t}\n+\t\tif (leftOperand != null) {\n+\t\t\tleftOperand = leftOperand.replaceIndexExpression(childRCL);\n+\t\t}\n+\t\tif (rightOperand != null) {\n+\t\t\trightOperand = rightOperand.replaceIndexExpression(childRCL);\n+\t\t}\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic boolean collectExpressions(Map<Integer, List<ValueNode>> exprMap) {\n+\t\tboolean result = true;\n+\t\tif (receiver != null) {\n+\t\t\tresult = receiver.collectExpressions(exprMap);\n+\t\t}", "originalCommit": "c136be91f09b0a1fa2c9b9786fb30c61fced173d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4NjI1Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r516086252", "bodyText": "Done.", "author": "ascend1", "createdAt": "2020-11-02T16:17:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExMjgyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExNzkwOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r513117909", "bodyText": "We need to check the rightOperandList also, as it could also contain expressions:\nFor example:\ncreate table t1 (a1 int, b1 int, c1 int);\ncreate index idx_t1 on t1(a1+1);\ncreate table t2(a2 int, b2 int, c2 int);\n\nsplice> explain select a1+1 from t1\n> , t2 where a2 in (1, a1+1);\nERROR XJ001: DERBY SQL error: SQLCODE: -1, SQLSTATE: XJ001, SQLERRMC: java.lang.IllegalStateExceptionASSERT FAILED sourceResultSetNumber expected to be >= 0 for null.A1XJ001.U", "author": "yxia92", "createdAt": "2020-10-28T00:58:28Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryListOperatorNode.java", "diffHunk": "@@ -472,4 +473,24 @@ public int getOuterJoinLevel() {\n     public void setOuterJoinLevel(int level) {\n         outerJoinLevel = level;\n     }\n+\n+    public ValueNode replaceIndexExpression(ResultColumnList childRCL) throws StandardException {\n+        ValueNodeList newList = (ValueNodeList) getNodeFactory().getNode(\n+                C_NodeTypes.VALUE_NODE_LIST,\n+                getContextManager());\n+        for (Object leftItem : leftOperandList) {\n+            newList.addValueNode(((ValueNode) leftItem).replaceIndexExpression(childRCL));\n+        }\n+        leftOperandList = newList;\n+        return this;\n+    }\n+\n+    @Override\n+    public boolean collectExpressions(Map<Integer, List<ValueNode>> exprMap) {\n+        boolean result = true;\n+        for (Object leftItem : leftOperandList) {\n+            result = result && ((ValueNode) leftItem).collectExpressions(exprMap);\n+        }\n+        return result;", "originalCommit": "c136be91f09b0a1fa2c9b9786fb30c61fced173d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjExNTYxOA==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r516115618", "bodyText": "Done. The example is added as a test case.", "author": "ascend1", "createdAt": "2020-11-02T16:56:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExNzkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExODEzNQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r513118135", "bodyText": "We need to check the rightOperandList also.", "author": "yxia92", "createdAt": "2020-10-28T00:59:14Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryListOperatorNode.java", "diffHunk": "@@ -472,4 +473,24 @@ public int getOuterJoinLevel() {\n     public void setOuterJoinLevel(int level) {\n         outerJoinLevel = level;\n     }\n+\n+    public ValueNode replaceIndexExpression(ResultColumnList childRCL) throws StandardException {\n+        ValueNodeList newList = (ValueNodeList) getNodeFactory().getNode(\n+                C_NodeTypes.VALUE_NODE_LIST,\n+                getContextManager());\n+        for (Object leftItem : leftOperandList) {\n+            newList.addValueNode(((ValueNode) leftItem).replaceIndexExpression(childRCL));\n+        }\n+        leftOperandList = newList;\n+        return this;", "originalCommit": "c136be91f09b0a1fa2c9b9786fb30c61fced173d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA5NTc5NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r516095794", "bodyText": "Done.", "author": "ascend1", "createdAt": "2020-11-02T16:30:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExODEzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExODM1OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r513118359", "bodyText": "No need to check receiver.", "author": "yxia92", "createdAt": "2020-10-28T00:59:55Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryLogicalOperatorNode.java", "diffHunk": "@@ -228,4 +227,36 @@ DataTypeDescriptor resolveLogicalBinaryOperator(\n \t\treturn leftType.getNullabilityType(\n \t\t\t\t\tleftType.isNullable() || rightType.isNullable());\n \t}\n+\n+\t@Override\n+\tpublic ValueNode replaceIndexExpression(ResultColumnList childRCL) throws StandardException {\n+\t\tif (childRCL == null) {\n+\t\t\treturn this;\n+\t\t}\n+\t\tif (receiver != null) {\n+\t\t\treceiver = receiver.replaceIndexExpression(childRCL);\n+\t\t}\n+\t\tif (leftOperand != null) {", "originalCommit": "c136be91f09b0a1fa2c9b9786fb30c61fced173d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4Njg5Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r516086897", "bodyText": "Done.", "author": "ascend1", "createdAt": "2020-11-02T16:18:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExODM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExODU4NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r513118585", "bodyText": "No need to check receiver.", "author": "yxia92", "createdAt": "2020-10-28T01:00:45Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryLogicalOperatorNode.java", "diffHunk": "@@ -228,4 +227,36 @@ DataTypeDescriptor resolveLogicalBinaryOperator(\n \t\treturn leftType.getNullabilityType(\n \t\t\t\t\tleftType.isNullable() || rightType.isNullable());\n \t}\n+\n+\t@Override\n+\tpublic ValueNode replaceIndexExpression(ResultColumnList childRCL) throws StandardException {\n+\t\tif (childRCL == null) {\n+\t\t\treturn this;\n+\t\t}\n+\t\tif (receiver != null) {\n+\t\t\treceiver = receiver.replaceIndexExpression(childRCL);\n+\t\t}\n+\t\tif (leftOperand != null) {\n+\t\t\tleftOperand = leftOperand.replaceIndexExpression(childRCL);\n+\t\t}\n+\t\tif (rightOperand != null) {\n+\t\t\trightOperand = rightOperand.replaceIndexExpression(childRCL);\n+\t\t}\n+\t\treturn this;\n+\t}\n+\n+\t@Override\n+\tpublic boolean collectExpressions(Map<Integer, List<ValueNode>> exprMap) {\n+\t\tboolean result = true;\n+\t\tif (receiver != null) {\n+\t\t\tresult = receiver.collectExpressions(exprMap);\n+\t\t}", "originalCommit": "c136be91f09b0a1fa2c9b9786fb30c61fced173d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA4NzEzMA==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r516087130", "bodyText": "Done.", "author": "ascend1", "createdAt": "2020-11-02T16:18:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzExODU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE0NDUzOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r513144539", "bodyText": "Is there a reason to call binding logic here? I don't see that binding logic is applied to other nodes like GroupByList, is there something special about OrderByList?", "author": "yxia92", "createdAt": "2020-10-28T02:37:12Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/OrderByList.java", "diffHunk": "@@ -616,4 +616,13 @@ boolean requiresDescending(ColumnReference cRef,int numOptimizables) throws Stan\n          */\n         return false;\n     }\n+\n+    public void replaceIndexExpressions(ResultSetNode child) throws StandardException {\n+        ResultColumnList childRCL = child.getResultColumns();\n+        for (int i = 0; i < size(); i++) {\n+            OrderByColumn obc = (OrderByColumn) elementAt(i);\n+            obc.setColumnExpression(obc.getColumnExpression().replaceIndexExpression(childRCL));\n+        }\n+        bindOrderByColumns(child);", "originalCommit": "c136be91f09b0a1fa2c9b9786fb30c61fced173d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzkwMTcyNw==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r517901727", "bodyText": "Hmm, I couldn't remember what was the problem but I'm pretty sure I encountered some failure in composing order by tests, then came up with this solution.\nI just commented out the bind call and all tests pass now. I think it should be that expression replacement was buggy but I was on the wrong spot. Lots of fixes came later.\nI think you're right that OrderByList is not more special than OrderByList. I remove the bind call.", "author": "ascend1", "createdAt": "2020-11-05T09:20:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE0NDUzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1MTU2Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r513151567", "bodyText": "resultSet of a SubqueryNode could be a SelectNode, but when we get it, it is called from modifyAccessPath phase, so I guess SelectNode has already been replaced by a ProjectRestrictNode, so the assertion here is OK. Am I right? A comment may be helpful here.", "author": "yxia92", "createdAt": "2020-10-28T03:03:04Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/SubqueryNode.java", "diffHunk": "@@ -2702,4 +2699,11 @@ public int getCardinalityCheck() throws StandardException {\n             return OnceResultSet.DO_CARDINALITY_CHECK;\n         }\n     }\n+\n+    @Override\n+    public ValueNode replaceIndexExpression(ResultColumnList childRCL) throws StandardException {\n+        assert resultSet instanceof Optimizable;", "originalCommit": "c136be91f09b0a1fa2c9b9786fb30c61fced173d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk0MDUyMA==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r517940520", "bodyText": "I think that's right. When we enter this call, it should come from the replaceIndexExpression in genProjectRestrict. At that point, access paths of subqueries, including derived tables, have been modified. The other place index expressions got replaced is in FromBaseTable. But it should never ends up here.\nI add a comment as you suggested.", "author": "ascend1", "createdAt": "2020-11-05T10:20:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1MTU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2NzIwMg==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r513167202", "bodyText": "I have a concern with the replacement of the resultColumns here. As all the column references that are on top of this ProjectRestrictNode that reference the result columns in resultColumns will be broken. I'm trying to use s derived table as a case to demonstrate the problem, but currently in the presence of derived table, index are always qualified as a non-covering index, so this logic is not triggered. We need to check back here once the derived table issue is fixed.", "author": "yxia92", "createdAt": "2020-10-28T04:02:33Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/ProjectRestrictNode.java", "diffHunk": "@@ -809,6 +809,17 @@ else if(!(childResult instanceof FromBaseTable)){\n         }\n         accessPathModified=true;\n \n+        if (childResult.getResultColumns().isFromExprIndex()) {\n+            /* We get a shallow copy of the ResultColumnList and its\n+             * ResultColumns.  (Copy maintains ResultColumn.expression for now.)\n+             */\n+            resultColumns = childResult.getResultColumns().copyListAndObjects();", "originalCommit": "c136be91f09b0a1fa2c9b9786fb30c61fced173d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODkxODM2OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r518918369", "bodyText": "After two days debugging with cases including derived tables and outer joins, I believe that breaking column mapping is unfortunately inevitable. Main reason is that if childResult comes from an index on expressions, the number of RCs may change. Example could be here we have two result columns for A and B, but the index expression is A + B and the childResult has only one result column. Or we could have only column A here, but actually we have multiple index expressions defined on A and referenced like A + 1 and A * 3.\nOnce we enter this code path, parent nodes must have their resultColumns rebuilt, too. Good news is that this propagation stops at top-level select of current query block. There we don't have to make new RC instances, but just replace their expressions.\nThe outer join failure you discovered is a combined one. Fixing it requires 1) expression collection is fixed, 2) result column rebuilding is fixed, and 3) indexExpression of RCs must be set and propagated properly. The third item is a newly found issue.", "author": "ascend1", "createdAt": "2020-11-06T18:06:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2NzIwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTcwNzUwNw==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r519707507", "bodyText": "Based on our discussion yesterday, I made two changes to the code:\n\nnot propagating fromIndexExpr flag across query block boundary\nwhen rebuilding result columns of join node, it rebuilds only those from index expressions\n\nWith these two changes, all tests work with no need of UpdateColumnReferenceVisitor. Thus, I remove it and revert unnecessary changes in the latest commit.", "author": "ascend1", "createdAt": "2020-11-09T10:35:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE2NzIwMg=="}], "type": "inlineReview"}, {"oid": "4236cac5c473ac58a99061323b366d5edc70eda8", "url": "https://github.com/splicemachine/spliceengine/commit/4236cac5c473ac58a99061323b366d5edc70eda8", "message": "Merge branch 'master' into DB-10175\n\nConflicts:\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/Predicate.java", "committedDate": "2020-10-28T14:38:13Z", "type": "commit"}, {"oid": "2cf8db9f4c07e7ecbdf84a340c73c407a3ee70ca", "url": "https://github.com/splicemachine/spliceengine/commit/2cf8db9f4c07e7ecbdf84a340c73c407a3ee70ca", "message": "DB-10175 Address comments / add semanticallyEquals()\n\nDB-10312 Cache index expression ASTs is partially applied here so that\nthe code binding index expressions is not duplicated everywhere.", "committedDate": "2020-10-29T20:24:59Z", "type": "commit"}, {"oid": "83a20d4c2342308c196697fa55929e49e997c901", "url": "https://github.com/splicemachine/spliceengine/commit/83a20d4c2342308c196697fa55929e49e997c901", "message": "Merge branch 'master' into DB-10175", "committedDate": "2020-10-29T20:26:10Z", "type": "commit"}, {"oid": "35654b5f5111273d24a3a795f0ab4adcca2f8f70", "url": "https://github.com/splicemachine/spliceengine/commit/35654b5f5111273d24a3a795f0ab4adcca2f8f70", "message": "DB-10175 Address comments / fix potential concurrent issue\n\nIndex expression ASTs should not be cached in IndexDescriptor because\nit is in turns cached in data dictionary cache, which is global to all\nqueries. For now, always return a copy of ASTs.", "committedDate": "2020-10-30T10:09:08Z", "type": "commit"}, {"oid": "e84193961ad090ee1047773f57b3d810224cdde1", "url": "https://github.com/splicemachine/spliceengine/commit/e84193961ad090ee1047773f57b3d810224cdde1", "message": "Merge branch 'DB-10175' into DB-10236\n\nConflicts:\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/Predicate.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/PredicateList.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/TernaryOperatorNode.java\n\tsplice_machine/src/test/java/com/splicemachine/derby/impl/sql/actions/index/IndexIT.java", "committedDate": "2020-10-30T10:43:27Z", "type": "commit"}, {"oid": "e15d6ad1db16a17112f3cf80e4e2b87c46039d20", "url": "https://github.com/splicemachine/spliceengine/commit/e15d6ad1db16a17112f3cf80e4e2b87c46039d20", "message": "DB-10236 Adapt to the latest changes made in DB-10175\n\nNote: IndexIT.testCoveringExpressionBasedIndexSubquery fails in\ncurrent state because we cannot bind expressions after resultColumns\nare changed to index columns after changeAccessPath(). As a result,\nindex expressions containing JavaToSQLValueNode do not work.", "committedDate": "2020-10-30T14:49:11Z", "type": "commit"}, {"oid": "93d5dd9183c6871c1822362d45225f14e8734abf", "url": "https://github.com/splicemachine/spliceengine/commit/93d5dd9183c6871c1822362d45225f14e8734abf", "message": "DB-10236 Fix IndexIT.testCoveringExpressionBasedIndexSubquery\n\nThe fix is done by allowing binding base table columns even after\ntable's access path has been changed to index columns. This ability is\nlimited to index on expressions only.", "committedDate": "2020-10-30T17:50:59Z", "type": "commit"}, {"oid": "d1b3b65435c343fca40c91a1d99ae948a147461e", "url": "https://github.com/splicemachine/spliceengine/commit/d1b3b65435c343fca40c91a1d99ae948a147461e", "message": "DB-10312 Add hashCode() to ValueNode class hierarchy", "committedDate": "2020-11-02T08:52:12Z", "type": "commit"}, {"oid": "edd0881cf1a975079c18a51632f64ac0eb77a36b", "url": "https://github.com/splicemachine/spliceengine/commit/edd0881cf1a975079c18a51632f64ac0eb77a36b", "message": "DB-10236 Address comments / fix expr collecting and derived tables", "committedDate": "2020-11-02T15:29:40Z", "type": "commit"}, {"oid": "1f192d6f3a9ee4bf31a6f7120b5db18543bc380b", "url": "https://github.com/splicemachine/spliceengine/commit/1f192d6f3a9ee4bf31a6f7120b5db18543bc380b", "message": "DB-10236 Address comments / fix index expr in RHS of in-list", "committedDate": "2020-11-02T16:57:50Z", "type": "commit"}, {"oid": "dec647dfb3287c8ab6cc63e298cee3454ae3ba42", "url": "https://github.com/splicemachine/spliceengine/commit/dec647dfb3287c8ab6cc63e298cee3454ae3ba42", "message": "WIP: DB-10236 Address comments / fix count(*) and index expr in window", "committedDate": "2020-11-04T16:25:58Z", "type": "commit"}, {"oid": "6fbed9d56a55f3be3bd4f02f9b6af7eee168ff2e", "url": "https://github.com/splicemachine/spliceengine/commit/6fbed9d56a55f3be3bd4f02f9b6af7eee168ff2e", "message": "Merge branch 'master' into DB-10236\n\nConflicts:\n\tdb-engine/src/main/java/com/splicemachine/db/catalog/types/IndexDescriptorImpl.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/ArrayConstantNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryListOperatorNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/BinaryOperatorNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CastNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/ConditionalNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/FromBaseTable.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/GenerationClauseNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/JavaToSQLValueNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/JavaValueNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/MethodCallNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/Predicate.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/PredicateList.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/SQLToJavaValueNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/StaticClassFieldReferenceNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/TernaryOperatorNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/UnaryOperatorNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/ValueNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/ValueTupleNode.java\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/VirtualColumnNode.java\n\tsplice_machine/src/test/java/com/splicemachine/derby/impl/sql/actions/index/IndexIT.java", "committedDate": "2020-11-04T23:19:18Z", "type": "commit"}, {"oid": "87fbb50fa6439543ca5a01ab2b4851000aba3662", "url": "https://github.com/splicemachine/spliceengine/commit/87fbb50fa6439543ca5a01ab2b4851000aba3662", "message": "Resolved missed conflicts", "committedDate": "2020-11-04T23:45:54Z", "type": "commit"}, {"oid": "713a0d727e775503dd2374aaba512d3794026d10", "url": "https://github.com/splicemachine/spliceengine/commit/713a0d727e775503dd2374aaba512d3794026d10", "message": "DB-10236 Column mapping manipulation for index on expressions", "committedDate": "2020-11-07T03:02:29Z", "type": "commit"}, {"oid": "d908f867665b138a317911e3caafb2ac6be60073", "url": "https://github.com/splicemachine/spliceengine/commit/d908f867665b138a317911e3caafb2ac6be60073", "message": "Merge branch 'master' into DB-10236", "committedDate": "2020-11-07T03:04:11Z", "type": "commit"}, {"oid": "50554af111bb803018025226236573fc4b3e8976", "url": "https://github.com/splicemachine/spliceengine/commit/50554af111bb803018025226236573fc4b3e8976", "message": "Merge branch 'master' into DB-10236", "committedDate": "2020-11-09T08:28:12Z", "type": "commit"}, {"oid": "6b6aef41c1efc752ed870edc5016410a283c57e7", "url": "https://github.com/splicemachine/spliceengine/commit/6b6aef41c1efc752ed870edc5016410a283c57e7", "message": "DB-10236 Fix outer join without correcting column references", "committedDate": "2020-11-09T10:57:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxODA5OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r521018099", "bodyText": "It seems to me that the replacement of index expression in all places (window functions, order by list) should be done in one shot before the group by node is generated. As before the group by node is generated, these expressions should all be pointing to the join result; after the group by node is generated, they will automatically be pointing to the group by result node. If we delay the replacement of expression in window function and order by list, these expression will still be pointing to the join result instead of the group by result, which does not seem right.", "author": "yxia92", "createdAt": "2020-11-11T02:02:12Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/SelectNode.java", "diffHunk": "@@ -1283,6 +1322,9 @@ public ResultSetNode genProjectRestrict(int origFromListSize) throws StandardExc\n         if(hasWindows()){\n             // Now we add a window result set wrapped in a PRN on top of what we currently have.\n             for (WindowNode windowDefinition : windowDefinitionList) {\n+                if (childResultColumns.isFromExprIndex()) {\n+                    windowDefinition.replaceIndexExpression(childResultColumns);\n+                }", "originalCommit": "6b6aef41c1efc752ed870edc5016410a283c57e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTc4MTQ0Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r521781446", "bodyText": "Hmm, you're right, it seems windows and group by columns would refer to child of GBN, not the latest top result columns. Then I wonder why it has been working so far... I added two test cases explicitly test these cases, but they still work.\nI then investigated OrderByList a bit further. It turns out that in code generation, its expression is not used at all. What matters is columnPosition, based on which the generated code knows the indexes of sort keys. This field is assigned in binding phase.\nThen I suddenly remember why I bind OrderByColumns after replacing index expressions. It's because binding them would resolve the column reference in newly assigned expressions and update their columnPosition. GroupByColumn doesn't have this issue.\nThat also explains why replacing index expression late and having wrong column references also work. Because for OrderByColumns, what matters is column references' column position, not their source or chain. We could have a GBN in between and GBN can change the number of result columns, but order by can only refer to the output columns of GBN and that's checked in binding phase. So as long as the order of result columns doesn't change, column position would be correct, despite that the column mapping is not right.\nStill, I think it's good to make the column mapping right. So I replace OrderByList and WindowDefinitions together before constructing the GroupBy node. Also, I reverted the replaceIndexExpression() method for OrderByList to still bind it, and added a comment there.", "author": "ascend1", "createdAt": "2020-11-12T02:40:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTAxODA5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA3ODg5NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r521078895", "bodyText": "It seems that for non-flattened correlated subquery, we are not collecting all the expressions. Here is an example:\ncreate table t1 (a1 int, b1 int, c1 int, d1 int);\ncreate index idx_t1 on t1 (a1+1, b1+2);\ncreate table t2 (a2 int, b2 int, c2 int, d2 int);\n\nexplain select 1 from t1 --splice-properties index=idx_t1\nwhere a1+1 not in (select a2 from t2 where b1+2 =b2);\n\nIn this case, I don't see the expression a1+1 being collected. This condition is in the PR node underneath SubqueryNode but above the SELECT node, so we may examine that also.", "author": "yxia92", "createdAt": "2020-11-11T03:22:31Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/SelectNode.java", "diffHunk": "@@ -2876,4 +2937,60 @@ public JBitSet collectInnerTablesFromFlattenedOJ() {\n         }\n         return collected;\n     }\n+\n+    public Map<Integer, Set<ValueNode>> collectExpressions() {\n+        HashMap<Integer, Set<ValueNode>> result = new HashMap<>();\n+\n+        if (groupByList != null) {\n+            groupByList.collectExpressions(result);\n+        }\n+\n+        if (orderByList != null) {\n+            orderByList.collectExpressions(result);\n+        }\n+\n+        if (whereClause != null) {\n+            whereClause.collectExpressions(result);\n+        }\n+        if (wherePredicates != null) {\n+            wherePredicates.collectExpressions(result);\n+        }\n+\n+        if (havingClause != null) {\n+            havingClause.collectExpressions(result);\n+        }\n+\n+        if (selectAggregates != null) {\n+            for (AggregateNode selectAggregate : selectAggregates) {\n+                selectAggregate.collectExpressions(result);\n+            }\n+        }\n+\n+        if (havingAggregates != null) {\n+            for (AggregateNode havingAggregate : havingAggregates) {\n+                havingAggregate.collectExpressions(result);\n+            }\n+        }\n+        // no need to check whereAggregates, should be empty\n+\n+        if (windowDefinitionList != null) {\n+            for (WindowNode wn : windowDefinitionList) {\n+                wn.collectExpressions(result);\n+            }\n+        }\n+\n+        for (QueryTreeNode fromItem : fromList) {\n+            if (fromItem instanceof ResultSetNode) {  // this is probably always true?\n+                ((ResultSetNode) fromItem).collectExpressions(result);\n+            }\n+        }\n+\n+        for (ResultColumn rc : resultColumns) {\n+            rc.getExpression().collectSingleExpression(result);\n+        }\n+\n+        return result;", "originalCommit": "6b6aef41c1efc752ed870edc5016410a283c57e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgyNzgxOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r521827819", "bodyText": "Yes, I found this today when working on multi-column in-subquery, that leftOperand is not collected because it's never part of a SelectNode. It happens to all subqueries that have leftOperand and cannot be flattened, not necessarily correlated.\nWithout collecting it we may make wrong decisions about an index being a covering one, but actually have an expression that cannot be replaced. I enhanced this by collecting SubqueryNode, too. Then collect its leftOperand (if not null), and also restrictionList in the PRN directly under SubqueryNode. That PRN is generated on top of SelectNode to store the newly created predicate. I add a test for this case.", "author": "ascend1", "createdAt": "2020-11-12T04:10:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA3ODg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA4MTgxMw==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r521081813", "bodyText": "I don't see a problem with the logic here, but the below case returns a wrong plan, maybe we are missing the replacement for post join conditions?\ncreate table t1 (a1 int, b1 int, c1 int, d1 int);\ncreate index idx_t1 on t1 (a1+1, b1+2);\n\nexplain select a1+1 from t2 left join t1 --splice-properties index=idx_t1\non a1+1=a2 where a1+1 is null;\n\nPlan\n----\nCursor(n=8,rows=20,updateMode=READ_ONLY (1),engine=OLTP (default))\n  ->  ScrollInsensitive(n=8,totalCost=193.12,outputRows=20,outputHeapSize=160 B,partitions=1,parallelTasks=1)\n    ->  ProjectRestrict(n=7,totalCost=184.72,outputRows=20,outputHeapSize=160 B,partitions=1,parallelTasks=1)\n      ->  ProjectRestrict(n=6,totalCost=184.72,outputRows=20,outputHeapSize=160 B,partitions=1,parallelTasks=1,preds=[is null((A1[5:2] + 1))])\n        ->  MergeSortLeftOuterJoin(n=5,totalCost=184.72,outputRows=20,outputHeapSize=160 B,partitions=1,parallelTasks=1,preds=[(A1[5:3] = A2[5:1])])\n          ->  ProjectRestrict(n=4,totalCost=84.03,outputRows=20,outputHeapSize=160 B,partitions=1,parallelTasks=1)\n            ->  IndexLookup(n=3,totalCost=84.03,outputRows=20,outputHeapSize=160 B,partitions=1,parallelTasks=1)\n              ->  IndexScan[IDX_T1(1681)](n=2,totalCost=4.03,scannedRows=20,outputRows=20,outputHeapSize=160 B,partitions=1,parallelTasks=1,baseTable=T1(1664),preds=[(A1[5:3] = A2[5:1])])\n          ->  TableScan[T2(1696)](n=0,totalCost=4.04,scannedRows=20,outputRows=20,outputHeapSize=80 B,partitions=1,parallelTasks=1)\n\nthe condition a1=a2 is pushed to the the index scan step(n=2),", "author": "yxia92", "createdAt": "2020-11-11T03:27:01Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/JoinNode.java", "diffHunk": "@@ -378,6 +402,33 @@ public Optimizable modifyAccessPath(JBitSet outerTables) throws StandardExceptio\n \n         super.modifyAccessPath(outerTables);\n \n+        /* If any of the two children has chosen an index on expression, result\n+         * columns have to be rebuilt because the number may change. Column\n+         * mapping between parent node and this node is broken after reassigning\n+         * resultColumns. For this reason, resultColumns of (grand-)parent nodes\n+         * must be rebuilt until the top select node in the current query block.\n+         *\n+         * This logic handles nested JoinNode. If parent node is a PRN, its\n+         * result columns are rebuilt in its modifyAccessPath() method. If\n+         * parent is SelectNode, there is no need to rebuild its result columns\n+         * but only replace their expressions.\n+         */\n+        if (leftResultSet.getResultColumns().isFromExprIndex() || rightResultSet.getResultColumns().isFromExprIndex()) {\n+            ResultColumnList newResultColumns = (ResultColumnList) getNodeFactory()\n+                    .getNode(C_NodeTypes.RESULT_COLUMN_LIST, getContextManager());\n+            newResultColumns.copyOrderBySelect(resultColumns);\n+\n+            getNewResultColumns(resultColumns, newResultColumns, leftResultSet);\n+            getNewResultColumns(resultColumns, newResultColumns, rightResultSet);\n+            resultColumns = newResultColumns;\n+            assert resultColumns.size() == leftResultSet.getResultColumns().size() + rightResultSet.getResultColumns().size();\n+        }\n+\n+        // replace join predicates pushed down to right\n+        if (leftResultSet.getResultColumns().isFromExprIndex()) {\n+            rightResultSet.replaceIndexExpressions(leftResultSet.getResultColumns());\n+        }\n+", "originalCommit": "6b6aef41c1efc752ed870edc5016410a283c57e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg2MTQ1MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4162#discussion_r521861450", "bodyText": "Right, post join conditions are not replaced correctly. I fixed it in the latest commit.", "author": "ascend1", "createdAt": "2020-11-12T06:12:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTA4MTgxMw=="}], "type": "inlineReview"}, {"oid": "4dc00f89ca5d25c80a135036925b7298607d57ab", "url": "https://github.com/splicemachine/spliceengine/commit/4dc00f89ca5d25c80a135036925b7298607d57ab", "message": "DB-10236 Address comments / fix collecting expressions", "committedDate": "2020-11-12T04:10:57Z", "type": "commit"}, {"oid": "2208d1c4f7a8b2cb3b207e07d658704a5580eefd", "url": "https://github.com/splicemachine/spliceengine/commit/2208d1c4f7a8b2cb3b207e07d658704a5580eefd", "message": "DB-10236 Address comment / fix post join condition replacing", "committedDate": "2020-11-12T06:38:51Z", "type": "commit"}, {"oid": "9e6bbc2a956aae13ad97471165f8da1737d6b8b0", "url": "https://github.com/splicemachine/spliceengine/commit/9e6bbc2a956aae13ad97471165f8da1737d6b8b0", "message": "Merge branch 'master' into DB-10236\n\nConflicts:\n\tdb-engine/src/main/java/com/splicemachine/db/impl/sql/compile/ValueTupleNode.java", "committedDate": "2020-11-12T22:55:48Z", "type": "commit"}]}