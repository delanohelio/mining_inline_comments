{"pr_number": 4781, "pr_title": "DB-10817 Fix plan structure for non-flattenable nested joins", "pr_createdAt": "2020-12-04T14:47:09Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4781", "timeline": [{"oid": "8c2cd7aa2601ac68f7994cfc772437af84e71eb0", "url": "https://github.com/splicemachine/spliceengine/commit/8c2cd7aa2601ac68f7994cfc772437af84e71eb0", "message": "DB-10817 Fix column reference remapping", "committedDate": "2020-12-04T13:34:29Z", "type": "commit"}, {"oid": "c2afb04943476841e9f6baa42d993c580e35dff2", "url": "https://github.com/splicemachine/spliceengine/commit/c2afb04943476841e9f6baa42d993c580e35dff2", "message": "DB-10817 Fix hash key columns for non-flattenable nested joins", "committedDate": "2020-12-04T14:39:02Z", "type": "commit"}, {"oid": "f913266eca67f3a33682514ed0c3eb6b6f3ed40b", "url": "https://github.com/splicemachine/spliceengine/commit/f913266eca67f3a33682514ed0c3eb6b6f3ed40b", "message": "DB-10187 Add a comment explaining the fix", "committedDate": "2020-12-04T14:56:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ2NTYyOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4781#discussion_r536465629", "bodyText": "It might be a good idea to introduce a new flag, such as 'needsProjectRestrict' so we don't overload flattenableJoin.  Is my understanding correct?  We can still flatten these child JoinNodes, but we just need to mark them so a ProjectRestrict is built?", "author": "msirek", "createdAt": "2020-12-05T00:51:47Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/TableOperatorNode.java", "diffHunk": "@@ -529,6 +529,19 @@ protected FromTable getFromTableByName(String name,String schemaName,boolean exa\n      */\n     @Override\n     public ResultSetNode preprocess(int numTables, GroupByList gbl, FromList fromList) throws StandardException{\n+        /* DB-10817 note\n+         * For a non-flattenable join, set the non-flattenable flag to all nested joins.\n+         * This has nothing to do with flattening, but to build a PRN on top of each\n+         * nested joins. This is necessary because JoinConditionVisitor may add extra\n+         * hash key columns into children's result column lists. If any child is a\n+         * JoinNode, not PRN, then it breaks the equation that\n+         * resultColumns.size() = leftResultSet.resultColumns.size() + rightResultSet.resultColumns.size(),\n+         * which is the assumption in generated code.\n+         */\n+        if (!isFlattenableJoinNode()) {\n+            leftResultSet.notFlattenableJoin();\n+            rightResultSet.notFlattenableJoin();", "originalCommit": "f913266eca67f3a33682514ed0c3eb6b6f3ed40b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzM0MzQ5MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4781#discussion_r537343491", "bodyText": "Hmm, I'm not sure if we will flatten the child JoinNodes in this case. Here is my understanding from the source code:\nFromSubquery and JoinNodes flattening happens in SelectNode's preprocess(), when calling fromList.flattenFromTables(...). So at this time, join order is the one specified in query, no reordering yet.\nLooking into flattenFromTables, we see that it iterates over each FromTable in fromList. If a FromTable is a JoinNode that can be flattened, its children will be put into fromList and flattened is set to true. The outer while loop continues, meaning we will try to flatten the nested join.\nHowever, if the JoinNode is not flattenable, then flattened will not be set, and the outer loop terminates. That means all nested loops do not have a chance to be considered. Basically, that means if a JoinNode is not flattenable, the whole sub-tree is not flattenable. Another clue about this is the implementation of notFlattenableJoin. This method is actually recursive. Calling leftResultSet.notFlattenableJoin() sets all JoinNodes in the sub-tree to be non-flattenable.\nTo me, the question is why we need this flag. If a join cannot be flattened, then all nested joins in the sub-tree doesn't participate join ordering? But I see that we maintain dependencies between joins, too. If that's the case, shouldn't all joins participate join ordering and dependencies prevent some illegal order? Do you have a clue on this Mark?", "author": "ascend1", "createdAt": "2020-12-07T09:13:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ2NTYyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY2ODU3Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/4781#discussion_r538668576", "bodyText": "@ascend1 I'm not sure, unless a JoinNode can show up in multiple FromLists, or maybe the code author just wanted the nodes to all be consistent (indicate that nothing was flattened).  In any case, the code you added, I see the same code in JoinNode.java, so this is the current convention for marking the tree, so is consistent.  Also, I cannot find a test case where the recursive marking of notFlattenableJoin makes a difference.", "author": "msirek", "createdAt": "2020-12-08T18:00:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ2NTYyOQ=="}], "type": "inlineReview"}, {"oid": "22517d82bbf63d551c555370bbb475a55e94a97f", "url": "https://github.com/splicemachine/spliceengine/commit/22517d82bbf63d551c555370bbb475a55e94a97f", "message": "Merge branch 'master' into DB-10817", "committedDate": "2020-12-07T10:04:32Z", "type": "commit"}]}