{"pr_number": 3214, "pr_title": "DB-9140 Support tuples in predicates", "pr_createdAt": "2020-02-10T02:11:03Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/3214", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM2NTE4NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3214#discussion_r378365185", "bodyText": "You may use the expression case when 1=0 then 1 end to generate a null value.", "author": "yxia92", "createdAt": "2020-02-12T16:28:57Z", "path": "splice_machine/src/test/java/com/splicemachine/db/impl/sql/compile/PredicateTupleIT.java", "diffHunk": "@@ -0,0 +1,170 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ *\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.db.impl.sql.compile;\n+\n+\n+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;\n+import com.splicemachine.derby.test.framework.SpliceUnitTest;\n+import com.splicemachine.derby.test.framework.SpliceWatcher;\n+import com.splicemachine.homeless.TestUtils;\n+import org.junit.*;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.spark_project.guava.collect.Lists;\n+\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLSyntaxErrorException;\n+import java.sql.Types;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import static org.junit.Assert.*;\n+import static org.hamcrest.Matchers.containsString;\n+\n+/**\n+ * Test predicate with tuples\n+ */\n+@RunWith(Parameterized.class)\n+public class PredicateTupleIT extends SpliceUnitTest {\n+\n+    private Boolean useSpark;\n+\n+    @Parameterized.Parameters\n+    public static Collection<Object[]> data() {\n+        Collection<Object[]> params = Lists.newArrayListWithCapacity(2);\n+        params.add(new Object[]{true});\n+        params.add(new Object[]{false});\n+        return params;\n+    }\n+    private static final String SCHEMA = PredicateTupleIT.class.getSimpleName();\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher schemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    @ClassRule\n+    public static SpliceWatcher classWatcher = new SpliceWatcher(SCHEMA);\n+\n+    @Rule\n+    public SpliceWatcher methodWatcher = new SpliceWatcher(SCHEMA);\n+\n+    @BeforeClass\n+    public static void createSharedTables() throws Exception {\n+        TestUtils.executeSqlFile(classWatcher.getOrCreateConnection(), \"subquery/PredSimplTestTables.sql\", \"\");\n+    }\n+\n+    @AfterClass\n+    public static void dropUDF() throws Exception {\n+        try {\n+            TestUtils.executeSqlFile(classWatcher.getOrCreateConnection(), \"subquery/PredSimplTestCleanup.sql\", \"\");\n+        }\n+        catch (Exception e) {\n+            // Don't error out if the UDF we want to drop does not exist.\n+        }\n+    }\n+\n+    public PredicateTupleIT(Boolean useSpark) {\n+        this.useSpark = useSpark;\n+    }\n+\n+\n+    private void testQuery(String sqlText, String expected) throws Exception {\n+        ResultSet rs = null;\n+        try {\n+            rs = methodWatcher.executeQuery(sqlText);\n+            assertEquals(\"\\n\" + sqlText + \"\\n\", expected, TestUtils.FormattedResult.ResultFactory.toStringUnsorted(rs));\n+        }\n+        finally {\n+            if (rs != null)\n+                rs.close();\n+        }\n+    }\n+\n+    @Test\n+    public void testSimpleTuple() throws Exception {\n+        String query = format(\"select * from A --SPLICE-PROPERTIES useSpark=%s\\n\" +\n+                \"where (a1, a2) = (1,10)\", useSpark);\n+        String expected = \"A1 |A2 |A3  |\\n\" +\n+                \"-------------\\n\" +\n+                \" 1 |10 |100 |\";\n+\n+        testQuery(query, expected);\n+    }\n+\n+    @Ignore(\"Find a way to pass nulls inside a tuple\")\n+    @Test\n+    public void testTupleWithNulls() throws Exception {\n+        String query = format(\"select count(*) from D --splice-properties useSpark=%s\\n\" +\n+                \"where (d1,d2,d3) = (null,null,null)\", useSpark);", "originalCommit": "8324ac362ee98f567de21e49f5f74b9d3d92ebe7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODU3MjA3MA==", "url": "https://github.com/splicemachine/spliceengine/pull/3214#discussion_r378572070", "bodyText": "Removing this test as it does not make much sense to compare to null", "author": "arnaud-splice", "createdAt": "2020-02-12T23:27:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM2NTE4NQ=="}], "type": "inlineReview"}, {"oid": "817a62c944a3b625cafa34785c31d741891bbbe6", "url": "https://github.com/splicemachine/spliceengine/commit/817a62c944a3b625cafa34785c31d741891bbbe6", "message": "DB-9140 Support tuples in predicates", "committedDate": "2020-02-12T23:26:30Z", "type": "commit"}, {"oid": "817a62c944a3b625cafa34785c31d741891bbbe6", "url": "https://github.com/splicemachine/spliceengine/commit/817a62c944a3b625cafa34785c31d741891bbbe6", "message": "DB-9140 Support tuples in predicates", "committedDate": "2020-02-12T23:26:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI0NTk2Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3214#discussion_r381245966", "bodyText": "I don't like changing all these return types from ValueNode to QueryTreeNode, I feel like a tuple should also be a ValueNode, either by making a ValueNodeList extend a ValueNode or by introducing another node type for tuples.", "author": "dgomezferro", "createdAt": "2020-02-19T11:56:01Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/sqlgrammar.jj", "diffHunk": "@@ -6821,13 +6890,14 @@ multiplicativeOperator() throws StandardException :\n /*\n  * <A NAME=\"unaryExpression\">unaryExpression</A>\n  */\n-ValueNode", "originalCommit": "817a62c944a3b625cafa34785c31d741891bbbe6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTYwNTc2MA==", "url": "https://github.com/splicemachine/spliceengine/pull/3214#discussion_r381605760", "bodyText": "Introduced ValueTupleNode that derives ValueNode", "author": "arnaud-splice", "createdAt": "2020-02-19T23:24:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTI0NTk2Ng=="}], "type": "inlineReview"}, {"oid": "ac8f9d03b7afbe2e8cf951b92cdccb47f8b4dddb", "url": "https://github.com/splicemachine/spliceengine/commit/ac8f9d03b7afbe2e8cf951b92cdccb47f8b4dddb", "message": "DB-9140 Remove support for le/lt/gt/ge in tuple comparison until we support lexicographical comparison", "committedDate": "2020-02-19T14:21:38Z", "type": "commit"}, {"oid": "f88faddf2cfda2f73407da043dc8ab5436dc90ac", "url": "https://github.com/splicemachine/spliceengine/commit/f88faddf2cfda2f73407da043dc8ab5436dc90ac", "message": "DB-9140 Introduce ValueTupleNode", "committedDate": "2020-02-19T23:23:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE5MDQyOA==", "url": "https://github.com/splicemachine/spliceengine/pull/3214#discussion_r382190428", "bodyText": "@arnaud-splice Can you move the call of valueExpression() up. valueExpression() is part of the parser rule, although eventually it will be compiled into a function of the same name, I think it is better to keep it as a parser rule and put explicitly at the top as shown below, following the tradition of all other parser rules:\nValueTupleNode\nvalueTupleElement(ValueNode tupleOrFirstValue) throws StandardException:\n{\n    ValueTupleNode  valueTuple;\n    ValueNode       newValue;\n}\n{\n    newValue = valueExpression()\n    {\n        if (tupleOrFirstValue instanceof ValueTupleNode) {\n            valueTuple = (ValueTupleNode) tupleOrFirstValue;\n        } else {\n            valueTuple = (ValueTupleNode) nodeFactory.getNode(\n                                    C_NodeTypes.VALUE_TUPLE_NODE,\n                                    getContextManager());\n            valueTuple.addValueNode((ValueNode) tupleOrFirstValue);\n        }\n\n        if (newValue instanceof ValueTupleNode) {\n            throw StandardException.newException(SQLState.LANG_SYNTAX_ERROR,\n                \"Nested tuple not supported\");\n        }\n        valueTuple.addValueNode(newValue);\n        return valueTuple;\n    }\n}", "author": "yxia92", "createdAt": "2020-02-20T18:50:45Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/sqlgrammar.jj", "diffHunk": "@@ -8003,6 +8063,35 @@ valueExpressionPrimary() throws StandardException :\n     }\n }\n \n+/*\n+ * <A NAME=\"valueTupleElement\">tupleValueElement</A>\n+ */\n+ValueTupleNode\n+valueTupleElement(ValueNode tupleOrFirstValue) throws StandardException:\n+{\n+    ValueTupleNode  valueTuple;\n+    ValueNode       newValue;\n+}\n+{\n+    {\n+        if (tupleOrFirstValue instanceof ValueTupleNode) {\n+            valueTuple = (ValueTupleNode) tupleOrFirstValue;\n+        } else {\n+            valueTuple = (ValueTupleNode) nodeFactory.getNode(\n+                                    C_NodeTypes.VALUE_TUPLE_NODE,\n+                                    getContextManager());\n+            valueTuple.addValueNode((ValueNode) tupleOrFirstValue);\n+        }\n+        newValue = valueExpression();", "originalCommit": "f88faddf2cfda2f73407da043dc8ab5436dc90ac", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIwNTk0NA==", "url": "https://github.com/splicemachine/spliceengine/pull/3214#discussion_r382205944", "bodyText": "Sure, that's a good idea!", "author": "arnaud-splice", "createdAt": "2020-02-20T19:19:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjE5MDQyOA=="}], "type": "inlineReview"}, {"oid": "94d68c9ccc7f99743480457289165e91f1a8453e", "url": "https://github.com/splicemachine/spliceengine/commit/94d68c9ccc7f99743480457289165e91f1a8453e", "message": "DB-9140 Address comments", "committedDate": "2020-02-20T19:38:24Z", "type": "commit"}]}