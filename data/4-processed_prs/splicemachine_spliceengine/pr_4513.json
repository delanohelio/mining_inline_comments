{"pr_number": 4513, "pr_title": "DB-10638 DB-10643 DB-10671 Implement new foreign key checker.", "pr_createdAt": "2020-11-06T21:02:26Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4513", "timeline": [{"oid": "d48a45886ee287b2070b0da3bf70559d05b55cf5", "url": "https://github.com/splicemachine/spliceengine/commit/d48a45886ee287b2070b0da3bf70559d05b55cf5", "message": "DB-10638 add foreign key graph DSL for testing.", "committedDate": "2020-11-06T19:39:28Z", "type": "commit"}, {"oid": "30b648f3119f15efed502b8b5c6a4821afd6c6e5", "url": "https://github.com/splicemachine/spliceengine/commit/30b648f3119f15efed502b8b5c6a4821afd6c6e5", "message": "DB-10638 implement new foreign key checker.", "committedDate": "2020-11-06T19:43:14Z", "type": "commit"}, {"oid": "93507b1735a13c85fad763c48a224f61c6c10119", "url": "https://github.com/splicemachine/spliceengine/commit/93507b1735a13c85fad763c48a224f61c6c10119", "message": "DB-10638 allow foreign key checker to handle cycles.", "committedDate": "2020-11-06T19:47:35Z", "type": "commit"}, {"oid": "bc959e0f01b4fb40ac55f07756d9da4a7708ec92", "url": "https://github.com/splicemachine/spliceengine/commit/bc959e0f01b4fb40ac55f07756d9da4a7708ec92", "message": "DB-10638 fixes for create table.", "committedDate": "2020-11-06T20:07:39Z", "type": "commit"}, {"oid": "ed907f354c4d6584eb43ef9af096b57eb6699fd7", "url": "https://github.com/splicemachine/spliceengine/commit/ed907f354c4d6584eb43ef9af096b57eb6699fd7", "message": "DB-10643 build foreign key graph from cached constraints.", "committedDate": "2020-11-06T20:18:04Z", "type": "commit"}, {"oid": "58cd5b345f8527b32be119b8e087d9518cf1a3e7", "url": "https://github.com/splicemachine/spliceengine/commit/58cd5b345f8527b32be119b8e087d9518cf1a3e7", "message": "DB-10643 fixes for cache usage.", "committedDate": "2020-11-06T20:21:14Z", "type": "commit"}, {"oid": "fe8b508195ad14f6a274cca6004c1f71cb784963", "url": "https://github.com/splicemachine/spliceengine/commit/fe8b508195ad14f6a274cca6004c1f71cb784963", "message": "DB-10671 make foreign key checker configurable.", "committedDate": "2020-11-06T20:22:10Z", "type": "commit"}, {"oid": "98e44ebd126a7a0467dc0b9bb5f7789edb50ebed", "url": "https://github.com/splicemachine/spliceengine/commit/98e44ebd126a7a0467dc0b9bb5f7789edb50ebed", "message": "DB-10671 pass down the configuration down to execution.", "committedDate": "2020-11-06T20:27:05Z", "type": "commit"}, {"oid": "47f178b331126d18e6fe03cb01370c9b4764029c", "url": "https://github.com/splicemachine/spliceengine/commit/47f178b331126d18e6fe03cb01370c9b4764029c", "message": "DB-10638 DB-10671 fixes.", "committedDate": "2020-11-09T08:50:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY0MjI1Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r519642257", "bodyText": "I commented out this method because it doesn't seem very easy to read the FK checker configuration in this module. Maybe a more important question is: Is com.splicemachine.db.impl.sql.execute.CreateConstraintConstantAction#executeConstantAction reachable? if so, how? if not, I suggest we remove it.\nIt looks almost identical to com.splicemachine.derby.impl.sql.execute.actions.CreateConstraintConstantOperation#executeConstantAction", "author": "hatyo", "createdAt": "2020-11-09T08:52:49Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/execute/CreateConstraintConstantAction.java", "diffHunk": "@@ -302,7 +302,7 @@ public void\texecuteConstantAction( Activation activation )\n \t\t\tcase DataDictionary.FOREIGNKEY_CONSTRAINT:\n \t\t\t\tReferencedKeyConstraintDescriptor referencedConstraint = DDUtils.locateReferencedConstraint\n \t\t\t\t\t( dd, td, constraintName, columnNames, otherConstraintInfo );\n-\t\t\t\tDDUtils.validateReferentialActions(dd, td, constraintName, otherConstraintInfo,columnNames);\n+\t\t\t\t// DDUtils.validateReferentialActions(dd, td, constraintName, otherConstraintInfo,columnNames);", "originalCommit": "47f178b331126d18e6fe03cb01370c9b4764029c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY1NzM0OA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r519657348", "bodyText": "... to be removed, follow up in DB-10689.", "author": "hatyo", "createdAt": "2020-11-09T09:17:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY0MjI1Nw=="}], "type": "inlineReview"}, {"oid": "048e9b61fdc9dc17cd774780dec256e12f69ec13", "url": "https://github.com/splicemachine/spliceengine/commit/048e9b61fdc9dc17cd774780dec256e12f69ec13", "message": "Merge remote-tracking branch 'origin/master' into DB-10638", "committedDate": "2020-11-09T10:55:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzMjU4OA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520432588", "bodyText": "i would suggest to not  use abbrevations on a top level. i'm fine with variable names like int fkIndex etc.,\nbut i think classes and namespace names should be easily readable in an instant.\n\nit makes my head go hm what was that again when i see it used elsewhere\ne.g. DFS could also be a distributed filesystem.\nit's not even commented in the file what DFS or FK means\ngrep-ing for fk will also list stuff like kaFKa, grep-ing for dfs also lists hDFS\n\nfk = foreignkeys\nDfs = DepthFirstSearch", "author": "martinrupp", "createdAt": "2020-11-10T09:56:41Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/fk/Dfs.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*", "originalCommit": "048e9b61fdc9dc17cd774780dec256e12f69ec13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAxMTM4OA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522011388", "bodyText": "Good point, I refactored accordingly.", "author": "hatyo", "createdAt": "2020-11-12T10:47:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzMjU4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzMjg4MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520432880", "bodyText": "a small comment explaining why this class exists and what it is doing would be nice", "author": "martinrupp", "createdAt": "2020-11-10T09:57:04Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/fk/Dfs.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.db.iapi.sql.dictionary.fk;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.utils.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Stack;\n+", "originalCommit": "048e9b61fdc9dc17cd774780dec256e12f69ec13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzNjQ1Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520436453", "bodyText": "please add unit tests for this class", "author": "martinrupp", "createdAt": "2020-11-10T10:02:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzMjg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAxNDIzNw==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522014237", "bodyText": "a small comment explaining why this class exists and what it is doing would be nice\n\ndone.", "author": "hatyo", "createdAt": "2020-11-12T10:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzMjg4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAyNTIzOA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522025238", "bodyText": "please add unit tests for this class\n\nwill do in a separate JIRA ticket.", "author": "hatyo", "createdAt": "2020-11-12T11:09:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzMjg4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzNTIyMQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520435221", "bodyText": "add a comment what run is doing", "author": "martinrupp", "createdAt": "2020-11-10T10:00:22Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/fk/Dfs.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.db.iapi.sql.dictionary.fk;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.utils.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Stack;\n+\n+public class Dfs {\n+    private final Graph graph;\n+    private final String newConstraintName;\n+    int[] dfsParent;\n+    boolean[] processed;\n+    boolean[] discovered;\n+    private boolean trackParents;\n+\n+    enum EdgeClassification {TREE, BACK, FORWARD, CROSS};\n+    EdgeClassification[] edgeTypes;\n+    Stack<Integer> stack;\n+    int[] entryTime;\n+    int[] exitTime;\n+    int time;\n+    ArrayList[] parents;\n+    boolean finished;\n+\n+\n+    public Dfs(Graph g, String newConstraintName) {\n+        this.graph = g;\n+        dfsParent = new int[g.getVertexCount()];\n+        processed = new boolean[g.getVertexCount()];\n+        discovered = new boolean[g.getVertexCount()];\n+        edgeTypes = new EdgeClassification[g.getVertexCount()];\n+        entryTime = new int[g.getVertexCount()];\n+        exitTime = new int[g.getVertexCount()];\n+        init();\n+        stack = new Stack<Integer>();\n+        parents = new ArrayList[g.getVertexCount()];\n+        this.newConstraintName = newConstraintName;\n+        finished = false;\n+    }\n+\n+    void init() {\n+        Arrays.fill(dfsParent, -1);\n+        Arrays.fill(discovered, false);\n+        Arrays.fill(processed, false);\n+        Arrays.fill(edgeTypes, EdgeClassification.TREE);\n+        Arrays.fill(entryTime, 0);\n+        Arrays.fill(exitTime, 0);\n+    }\n+\n+    EdgeClassification edgeClassification(int x, int y) {\n+        if(dfsParent[y] == x) return EdgeClassification.TREE;\n+        if(discovered[y] && !processed[y]) return EdgeClassification.BACK;\n+        if(processed[y] && (entryTime[y] > entryTime[x])) return EdgeClassification.FORWARD;\n+        if(processed[y] && (entryTime[y] < entryTime[x])) return EdgeClassification.CROSS;\n+        throw new IllegalArgumentException(\"unknown edge class between \" + x + \" and \" + y);\n+    }\n+\n+    public void run(int v) throws StandardException {", "originalCommit": "048e9b61fdc9dc17cd774780dec256e12f69ec13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAyNjg1NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522026854", "bodyText": "done.", "author": "hatyo", "createdAt": "2020-11-12T11:12:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzNTIyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzNzAxMA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520437010", "bodyText": "please add unit tests for Graph", "author": "martinrupp", "createdAt": "2020-11-10T10:03:02Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/fk/Graph.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.db.iapi.sql.dictionary.fk;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.reference.SQLState;\n+\n+import java.util.*;\n+\n+public class Graph {", "originalCommit": "048e9b61fdc9dc17cd774780dec256e12f69ec13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAyNzAyOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522027029", "bodyText": "will do in a separate JIRA ticket.", "author": "hatyo", "createdAt": "2020-11-12T11:13:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzNzAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzODQ2NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520438465", "bodyText": "C, R, SN, NA?\nC -> CASCADE;\nNA -> NOACTION;\nR -> RESTRICT;\nSN -> SETNULL;\nare those other values even used? Maybe a\nbool cascade would be sufficient and somewhat more \"general\"", "author": "martinrupp", "createdAt": "2020-11-10T10:05:07Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/fk/EdgeNode.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.db.iapi.sql.dictionary.fk;\n+\n+public class EdgeNode {\n+    public EdgeNode(int y, Type type) {\n+        this.y = y;\n+        this.type = type;\n+        this.next = null;\n+    }\n+\n+    enum Type {C, R, SN, NA};", "originalCommit": "048e9b61fdc9dc17cd774780dec256e12f69ec13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAyNzc3NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522027774", "bodyText": "You're right, but I would rather keep the distinction as it helps stringifying error messages and potentially address other future use cases.", "author": "hatyo", "createdAt": "2020-11-12T11:14:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzODQ2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ0NDQ2OA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520444468", "bodyText": "edgeNode.next = null; // bye, GC.\nthis line is superflous. the thing you want to clean up is edgeNode, not edgeNode.next. edgeNode.next will survive in previous.next. at this point, no one should be pointing to edgeNode anymore, so no need for this line.", "author": "martinrupp", "createdAt": "2020-11-10T10:14:07Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/fk/Graph.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.db.iapi.sql.dictionary.fk;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.reference.SQLState;\n+\n+import java.util.*;\n+\n+public class Graph {\n+    List<EdgeNode> edgeNodes;\n+    Map<String, Integer> vertexIndex;\n+    int[][] parents;\n+\n+    Map<Integer, Integer> surrogates;\n+    int surrogateCounter;\n+    String newConstraintName;\n+\n+    public Graph(Set<String> vertices, String newConstraintName) {\n+        edgeNodes = new ArrayList<>(vertices.size());\n+        vertexIndex = new HashMap<>(vertices.size());\n+        int i = 0;\n+        for (String vertex : vertices) {\n+            edgeNodes.add(null);\n+            vertexIndex.put(vertex, i++);\n+        }\n+        parents = new int[vertices.size()][];\n+        surrogateCounter = 0;\n+        this.newConstraintName = newConstraintName;\n+        this.surrogates = new HashMap<>();\n+    }\n+\n+    void addEdge(String from, String to, EdgeNode.Type type) throws StandardException {\n+        addEdgeInternal(vertexIndex.get(from), vertexIndex.get(to), type);\n+    }\n+\n+    private void addSurrogate(int fromIdx, int toIdx, EdgeNode.Type type) {\n+        int surrogateIdx = vertexIndex.size();\n+        String name = getName(toIdx) + \"__SURROGATE__\" + surrogateCounter++;\n+        surrogates.put(surrogateIdx, toIdx);\n+        vertexIndex.put(name, surrogateIdx);\n+        EdgeNode edgeNode = new EdgeNode(surrogateIdx, type);\n+        edgeNode.next = edgeNodes.get(fromIdx);\n+        edgeNodes.set(fromIdx, edgeNode);\n+        edgeNodes.add(null); // for the surrogate\n+    }\n+\n+    void addEdgeInternal(int fromIdx, int toIdx, EdgeNode.Type type) throws StandardException {\n+        Dfs dfs = new Dfs(this, newConstraintName);\n+        dfs.run(toIdx);\n+        List<Integer> p = dfs.getPath(toIdx, fromIdx);\n+        if(p.size() >= 2 && p.get(0) == toIdx && p.get(p.size() - 1) == fromIdx) {\n+            breakCycle(p, type, fromIdx, toIdx);\n+        } else {\n+            EdgeNode edgeNode = new EdgeNode(toIdx, type);\n+            edgeNode.next = edgeNodes.get(fromIdx);\n+            edgeNodes.set(fromIdx, edgeNode);\n+        }\n+    }\n+\n+    private void breakCycle(List<Integer> p, EdgeNode.Type type, int fromIdx, int toIdx) throws StandardException {\n+        if(type != EdgeNode.Type.C) {\n+            addSurrogate(fromIdx, toIdx, type);\n+            return;\n+        } else {\n+            for(int i = 1; i < p.size(); i++) { // find first none-C in the cycle and break it up\n+                EdgeNode.Type edgeType = getEdgeType(p.get(i-1), p.get(i));\n+                if(edgeType != EdgeNode.Type.C) {\n+                    addSurrogate(p.get(i-1), p.get(i), edgeType);\n+                    // remove this edge\n+                    removeEdge(p.get(i-1), p.get(i));\n+                    // add the new edge again, but check again for cycles!\n+                    addEdgeInternal(fromIdx, toIdx, type);\n+                    return;\n+                }\n+            }\n+        }\n+        // cycle is unbreakable, bail out\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"adding the constraint between \").append(\n+                getName(p.get(0))).append(\" and \").append(getName(p.get(p.size()-1))).append(\" would cause the following illegal delete action cascade cycle\");\n+        for(int v : p) {\n+            sb.append(\" \").append(getName(v));\n+        }\n+        throw StandardException.newException(SQLState.LANG_DELETE_RULE_VIOLATION,\n+                                             newConstraintName,\n+                                             sb.toString());\n+    }\n+\n+    public String getName(int index) {\n+        for (Map.Entry<String, Integer> entry : vertexIndex.entrySet()) {\n+            if (entry.getValue() == index) {\n+                return entry.getKey();\n+            }\n+        }\n+        throw new IllegalArgumentException(\"could not find name for item at the index: \" + index);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"digraph {\").append(\"\\n\");\n+        int i = 0;\n+        for (EdgeNode edge : edgeNodes) {\n+            EdgeNode next = edge;\n+            while (next != null) {\n+                sb.append(\"\\t\").append(getName(i)).append(\" -> \").append(getName(next.y)).append(\"[label=\\\"\").append(next.type.toString()).append(\"\\\"];\").append(\"\\n\");\n+                next = next.next;\n+            }\n+            i++;\n+        }\n+        sb.append(\"}\").append(\"\\n\");\n+        return sb.toString();\n+    }\n+\n+    public EdgeNode getEdge(int v) {\n+        return edgeNodes.get(v);\n+    }\n+\n+    public int getVertexCount() {\n+        return vertexIndex.size();\n+\n+    }\n+\n+    public EdgeNode.Type getEdgeType(int from, int to) {\n+        EdgeNode edgeNode = getEdge(from);\n+        while(true) {\n+            if(edgeNode == null) {\n+                throw new IllegalArgumentException(\"no edge between \" + getName(from) + \" and \" + getName(to));\n+            }\n+            if(edgeNode.y == to) {\n+                return edgeNode.type;\n+            }\n+            edgeNode = edgeNode.next;\n+        }\n+    }\n+\n+    public void removeEdge(int from, int to) {\n+        EdgeNode edgeNode = getEdge(from);\n+        if(edgeNode == null) {\n+            throw new IllegalArgumentException(\"no edge between \" + getName(from) + \" and \" + getName(to));\n+        }\n+        if(edgeNode.y == to) {\n+            edgeNodes.set(from, null);\n+        } else {\n+            EdgeNode previous = edgeNode;\n+            edgeNode = edgeNode.next;\n+            while(true) {\n+                if(edgeNode == null) {\n+                    throw new IllegalArgumentException(\"no edge between \" + getName(from) + \" and \" + getName(to));\n+                }\n+                if(edgeNode.y == to) {\n+                    previous.next = edgeNode.next;\n+                    edgeNode.next = null; // bye, GC.", "originalCommit": "048e9b61fdc9dc17cd774780dec256e12f69ec13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAzMjk4MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522032980", "bodyText": "Good point, but it seems it could help generational GC as explained here and here.\nWhat do you think?", "author": "hatyo", "createdAt": "2020-11-12T11:23:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ0NDQ2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ1ODgxMA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522458810", "bodyText": "woah hm yeah i didn't think about that! a GC hack, interesting. \ud83d\udc4d", "author": "martinrupp", "createdAt": "2020-11-12T22:11:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ0NDQ2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ0NTM3Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520445373", "bodyText": "\u26a0\ufe0f \u26a0\ufe0f \u26a0\ufe0f if it's the first edge, but there are other edges, this code would delete all edges, but i guess it should only delete the first one ->\nedgeNodes.set(from, edgeNodes.next);", "author": "martinrupp", "createdAt": "2020-11-10T10:15:24Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/fk/Graph.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.db.iapi.sql.dictionary.fk;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.reference.SQLState;\n+\n+import java.util.*;\n+\n+public class Graph {\n+    List<EdgeNode> edgeNodes;\n+    Map<String, Integer> vertexIndex;\n+    int[][] parents;\n+\n+    Map<Integer, Integer> surrogates;\n+    int surrogateCounter;\n+    String newConstraintName;\n+\n+    public Graph(Set<String> vertices, String newConstraintName) {\n+        edgeNodes = new ArrayList<>(vertices.size());\n+        vertexIndex = new HashMap<>(vertices.size());\n+        int i = 0;\n+        for (String vertex : vertices) {\n+            edgeNodes.add(null);\n+            vertexIndex.put(vertex, i++);\n+        }\n+        parents = new int[vertices.size()][];\n+        surrogateCounter = 0;\n+        this.newConstraintName = newConstraintName;\n+        this.surrogates = new HashMap<>();\n+    }\n+\n+    void addEdge(String from, String to, EdgeNode.Type type) throws StandardException {\n+        addEdgeInternal(vertexIndex.get(from), vertexIndex.get(to), type);\n+    }\n+\n+    private void addSurrogate(int fromIdx, int toIdx, EdgeNode.Type type) {\n+        int surrogateIdx = vertexIndex.size();\n+        String name = getName(toIdx) + \"__SURROGATE__\" + surrogateCounter++;\n+        surrogates.put(surrogateIdx, toIdx);\n+        vertexIndex.put(name, surrogateIdx);\n+        EdgeNode edgeNode = new EdgeNode(surrogateIdx, type);\n+        edgeNode.next = edgeNodes.get(fromIdx);\n+        edgeNodes.set(fromIdx, edgeNode);\n+        edgeNodes.add(null); // for the surrogate\n+    }\n+\n+    void addEdgeInternal(int fromIdx, int toIdx, EdgeNode.Type type) throws StandardException {\n+        Dfs dfs = new Dfs(this, newConstraintName);\n+        dfs.run(toIdx);\n+        List<Integer> p = dfs.getPath(toIdx, fromIdx);\n+        if(p.size() >= 2 && p.get(0) == toIdx && p.get(p.size() - 1) == fromIdx) {\n+            breakCycle(p, type, fromIdx, toIdx);\n+        } else {\n+            EdgeNode edgeNode = new EdgeNode(toIdx, type);\n+            edgeNode.next = edgeNodes.get(fromIdx);\n+            edgeNodes.set(fromIdx, edgeNode);\n+        }\n+    }\n+\n+    private void breakCycle(List<Integer> p, EdgeNode.Type type, int fromIdx, int toIdx) throws StandardException {\n+        if(type != EdgeNode.Type.C) {\n+            addSurrogate(fromIdx, toIdx, type);\n+            return;\n+        } else {\n+            for(int i = 1; i < p.size(); i++) { // find first none-C in the cycle and break it up\n+                EdgeNode.Type edgeType = getEdgeType(p.get(i-1), p.get(i));\n+                if(edgeType != EdgeNode.Type.C) {\n+                    addSurrogate(p.get(i-1), p.get(i), edgeType);\n+                    // remove this edge\n+                    removeEdge(p.get(i-1), p.get(i));\n+                    // add the new edge again, but check again for cycles!\n+                    addEdgeInternal(fromIdx, toIdx, type);\n+                    return;\n+                }\n+            }\n+        }\n+        // cycle is unbreakable, bail out\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"adding the constraint between \").append(\n+                getName(p.get(0))).append(\" and \").append(getName(p.get(p.size()-1))).append(\" would cause the following illegal delete action cascade cycle\");\n+        for(int v : p) {\n+            sb.append(\" \").append(getName(v));\n+        }\n+        throw StandardException.newException(SQLState.LANG_DELETE_RULE_VIOLATION,\n+                                             newConstraintName,\n+                                             sb.toString());\n+    }\n+\n+    public String getName(int index) {\n+        for (Map.Entry<String, Integer> entry : vertexIndex.entrySet()) {\n+            if (entry.getValue() == index) {\n+                return entry.getKey();\n+            }\n+        }\n+        throw new IllegalArgumentException(\"could not find name for item at the index: \" + index);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"digraph {\").append(\"\\n\");\n+        int i = 0;\n+        for (EdgeNode edge : edgeNodes) {\n+            EdgeNode next = edge;\n+            while (next != null) {\n+                sb.append(\"\\t\").append(getName(i)).append(\" -> \").append(getName(next.y)).append(\"[label=\\\"\").append(next.type.toString()).append(\"\\\"];\").append(\"\\n\");\n+                next = next.next;\n+            }\n+            i++;\n+        }\n+        sb.append(\"}\").append(\"\\n\");\n+        return sb.toString();\n+    }\n+\n+    public EdgeNode getEdge(int v) {\n+        return edgeNodes.get(v);\n+    }\n+\n+    public int getVertexCount() {\n+        return vertexIndex.size();\n+\n+    }\n+\n+    public EdgeNode.Type getEdgeType(int from, int to) {\n+        EdgeNode edgeNode = getEdge(from);\n+        while(true) {\n+            if(edgeNode == null) {\n+                throw new IllegalArgumentException(\"no edge between \" + getName(from) + \" and \" + getName(to));\n+            }\n+            if(edgeNode.y == to) {\n+                return edgeNode.type;\n+            }\n+            edgeNode = edgeNode.next;\n+        }\n+    }\n+\n+    public void removeEdge(int from, int to) {\n+        EdgeNode edgeNode = getEdge(from);\n+        if(edgeNode == null) {\n+            throw new IllegalArgumentException(\"no edge between \" + getName(from) + \" and \" + getName(to));\n+        }\n+        if(edgeNode.y == to) {\n+            edgeNodes.set(from, null);", "originalCommit": "048e9b61fdc9dc17cd774780dec256e12f69ec13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjAzOTkyNA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522039924", "bodyText": "Great point, thanks for spotting this, fixed it.", "author": "hatyo", "createdAt": "2020-11-12T11:35:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ0NTM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ0Njc1NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520446754", "bodyText": "// adds am edge and checks for cycles", "author": "martinrupp", "createdAt": "2020-11-10T10:17:30Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/fk/Graph.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.db.iapi.sql.dictionary.fk;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.reference.SQLState;\n+\n+import java.util.*;\n+\n+public class Graph {\n+    List<EdgeNode> edgeNodes;\n+    Map<String, Integer> vertexIndex;\n+    int[][] parents;\n+\n+    Map<Integer, Integer> surrogates;\n+    int surrogateCounter;\n+    String newConstraintName;\n+\n+    public Graph(Set<String> vertices, String newConstraintName) {\n+        edgeNodes = new ArrayList<>(vertices.size());\n+        vertexIndex = new HashMap<>(vertices.size());\n+        int i = 0;\n+        for (String vertex : vertices) {\n+            edgeNodes.add(null);\n+            vertexIndex.put(vertex, i++);\n+        }\n+        parents = new int[vertices.size()][];\n+        surrogateCounter = 0;\n+        this.newConstraintName = newConstraintName;\n+        this.surrogates = new HashMap<>();\n+    }\n+\n+    void addEdge(String from, String to, EdgeNode.Type type) throws StandardException {\n+        addEdgeInternal(vertexIndex.get(from), vertexIndex.get(to), type);\n+    }\n+\n+    private void addSurrogate(int fromIdx, int toIdx, EdgeNode.Type type) {\n+        int surrogateIdx = vertexIndex.size();\n+        String name = getName(toIdx) + \"__SURROGATE__\" + surrogateCounter++;\n+        surrogates.put(surrogateIdx, toIdx);\n+        vertexIndex.put(name, surrogateIdx);\n+        EdgeNode edgeNode = new EdgeNode(surrogateIdx, type);\n+        edgeNode.next = edgeNodes.get(fromIdx);\n+        edgeNodes.set(fromIdx, edgeNode);\n+        edgeNodes.add(null); // for the surrogate\n+    }\n+\n+    void addEdgeInternal(int fromIdx, int toIdx, EdgeNode.Type type) throws StandardException {", "originalCommit": "048e9b61fdc9dc17cd774780dec256e12f69ec13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0MDAzNA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522040034", "bodyText": "done.", "author": "hatyo", "createdAt": "2020-11-12T11:35:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ0Njc1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ0Nzc4Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520447787", "bodyText": "i think normal + should be performant enough for this part of the code\nsb.append(\"adding the constraint between \" + getName(p.get(0)) + \" and \" + getName(p.get(p.size()-1)) + \" would cause the following illegal delete action cascade cycle\");", "author": "martinrupp", "createdAt": "2020-11-10T10:19:06Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/fk/Graph.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.db.iapi.sql.dictionary.fk;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.reference.SQLState;\n+\n+import java.util.*;\n+\n+public class Graph {\n+    List<EdgeNode> edgeNodes;\n+    Map<String, Integer> vertexIndex;\n+    int[][] parents;\n+\n+    Map<Integer, Integer> surrogates;\n+    int surrogateCounter;\n+    String newConstraintName;\n+\n+    public Graph(Set<String> vertices, String newConstraintName) {\n+        edgeNodes = new ArrayList<>(vertices.size());\n+        vertexIndex = new HashMap<>(vertices.size());\n+        int i = 0;\n+        for (String vertex : vertices) {\n+            edgeNodes.add(null);\n+            vertexIndex.put(vertex, i++);\n+        }\n+        parents = new int[vertices.size()][];\n+        surrogateCounter = 0;\n+        this.newConstraintName = newConstraintName;\n+        this.surrogates = new HashMap<>();\n+    }\n+\n+    void addEdge(String from, String to, EdgeNode.Type type) throws StandardException {\n+        addEdgeInternal(vertexIndex.get(from), vertexIndex.get(to), type);\n+    }\n+\n+    private void addSurrogate(int fromIdx, int toIdx, EdgeNode.Type type) {\n+        int surrogateIdx = vertexIndex.size();\n+        String name = getName(toIdx) + \"__SURROGATE__\" + surrogateCounter++;\n+        surrogates.put(surrogateIdx, toIdx);\n+        vertexIndex.put(name, surrogateIdx);\n+        EdgeNode edgeNode = new EdgeNode(surrogateIdx, type);\n+        edgeNode.next = edgeNodes.get(fromIdx);\n+        edgeNodes.set(fromIdx, edgeNode);\n+        edgeNodes.add(null); // for the surrogate\n+    }\n+\n+    void addEdgeInternal(int fromIdx, int toIdx, EdgeNode.Type type) throws StandardException {\n+        Dfs dfs = new Dfs(this, newConstraintName);\n+        dfs.run(toIdx);\n+        List<Integer> p = dfs.getPath(toIdx, fromIdx);\n+        if(p.size() >= 2 && p.get(0) == toIdx && p.get(p.size() - 1) == fromIdx) {\n+            breakCycle(p, type, fromIdx, toIdx);\n+        } else {\n+            EdgeNode edgeNode = new EdgeNode(toIdx, type);\n+            edgeNode.next = edgeNodes.get(fromIdx);\n+            edgeNodes.set(fromIdx, edgeNode);\n+        }\n+    }\n+\n+    private void breakCycle(List<Integer> p, EdgeNode.Type type, int fromIdx, int toIdx) throws StandardException {\n+        if(type != EdgeNode.Type.C) {\n+            addSurrogate(fromIdx, toIdx, type);\n+            return;\n+        } else {\n+            for(int i = 1; i < p.size(); i++) { // find first none-C in the cycle and break it up\n+                EdgeNode.Type edgeType = getEdgeType(p.get(i-1), p.get(i));\n+                if(edgeType != EdgeNode.Type.C) {\n+                    addSurrogate(p.get(i-1), p.get(i), edgeType);\n+                    // remove this edge\n+                    removeEdge(p.get(i-1), p.get(i));\n+                    // add the new edge again, but check again for cycles!\n+                    addEdgeInternal(fromIdx, toIdx, type);\n+                    return;\n+                }\n+            }\n+        }\n+        // cycle is unbreakable, bail out\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"adding the constraint between \").append(\n+                getName(p.get(0))).append(\" and \").append(getName(p.get(p.size()-1))).append(\" would cause the following illegal delete action cascade cycle\");", "originalCommit": "048e9b61fdc9dc17cd774780dec256e12f69ec13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0ODI0NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522048245", "bodyText": "I always try to avoid String concatenation and use a StringBuilder instead, I see your point, the code is ugly, I will make it more readable by restructuring it.\nIt is not only for performance, but it is kind of a habit I think :)\nLet me know what you think about the new version once I push it.", "author": "hatyo", "createdAt": "2020-11-12T11:50:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ0Nzc4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ1OTk3Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522459973", "bodyText": "\ud83d\udc4d", "author": "martinrupp", "createdAt": "2020-11-12T22:12:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ0Nzc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ0OTIyNw==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520449227", "bodyText": "this also looks easily unit-testable", "author": "martinrupp", "createdAt": "2020-11-10T10:21:16Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/fk/GraphAnnotator.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.db.iapi.sql.dictionary.fk;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.reference.SQLState;\n+import com.splicemachine.utils.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class GraphAnnotator {\n+    private final Graph graph;\n+    private final String newConstraintName;\n+\n+    class Path {\n+        public Path(List<Integer> vertices, EdgeNode.Type action) {\n+            this.vertices = vertices;\n+            this.action = action;\n+        }\n+\n+        public String toString(Graph g) {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"PATH action: \").append(action).append(\" \");\n+            for(int v : vertices) {\n+                sb.append(g.getName(v)).append(\" \");\n+            }\n+            return sb.toString();\n+        }\n+\n+        List<Integer> vertices;\n+        EdgeNode.Type action;\n+\n+        private List<Integer> removeSurrogates(List<Integer> in) {\n+            return in.stream().map((vertex) -> {\n+                if (graph.isSurrogate(vertex)) {\n+                    return graph.getOriginal(vertex);\n+                } else {\n+                    return vertex;\n+                }\n+            }).collect(Collectors.toList());\n+        }\n+\n+        public boolean intersects(Path needle) {\n+            List<Integer> originalPathVertices = removeSurrogates(vertices);\n+            List<Integer> originalNeedleVertices = removeSurrogates(needle.vertices);\n+\n+\n+            return originalPathVertices.stream()\n+                    .distinct()\n+                    .filter(originalNeedleVertices::contains)\n+                    .collect(Collectors.toSet()).size() > 0;\n+        }\n+    }\n+\n+    static class Annotation {\n+        List<Path> paths;\n+        public Annotation() {\n+            paths = new ArrayList<>();\n+        }\n+    }\n+\n+    Annotation[] annotations;\n+\n+    public GraphAnnotator(String newConstraintName, Graph graph) {", "originalCommit": "048e9b61fdc9dc17cd774780dec256e12f69ec13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA0NTg4Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522045882", "bodyText": "True, planning for extensive testing of the graph and its algorithms in this JIRA, that is actually why I did the separation of the graph checker from the rest of the data dictionary so I can unit test it.", "author": "hatyo", "createdAt": "2020-11-12T11:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ0OTIyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzMTI2Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520431262", "bodyText": "Would it be possible to only remove the dropped constraint instead of all descriptors?", "author": "dgomezferro", "createdAt": "2020-11-10T09:54:53Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/actions/DropConstraintConstantOperation.java", "diffHunk": "@@ -239,6 +239,8 @@ public void executeConstantAction(Activation activation ) throws StandardExcepti\n \t\t\tdm.invalidateFor(conDesc, DependencyManager.DROP_CONSTRAINT, lcc);\n \t\t\tdm.clearDependencies(lcc, conDesc);\n \t\t}\n+\n+\t\tdd.getDataDictionaryCache().clearConstraintDescriptorListCache(); // not sure if this is the correct place to do this.", "originalCommit": "048e9b61fdc9dc17cd774780dec256e12f69ec13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA1OTEwMw==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522059103", "bodyText": "We store in this cache the following map: Map(<constraint UUID>, <list of all foreign key constraint descriptors referencing that constraint>, I think we can be more intelligent in cleaning up this cache such that:\n\nIf we find the UUID of the  constraint we're about to drop in the cache we delete.\nwe iterate over the result of the entries, and for each entry-value, we iterate over all the foreign keys, if we find a foreign key descriptor with UUID matching the one we're about to drop, we remove the entire entry from the map.\n\nI think step(1) removes the children and step(2) removes the parents, both steps are necessary to remove all traces of this constraint from the cache, do you agree?", "author": "hatyo", "createdAt": "2020-11-12T12:09:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzMTI2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA2MzkwMA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522063900", "bodyText": "... I just checked the interface of the ManagedCache, I couldn't find a way to get all the present keys from the cache which is necessary for step 2.", "author": "hatyo", "createdAt": "2020-11-12T12:18:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzMTI2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3NTI0Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522075247", "bodyText": "@hatyo you could add an asMap method to the ManagedCache that delegates it to the guava cache. But this is not too important, and iterating over all elements might be more expensive than repopulating the cache when needed. Up to you.", "author": "dgomezferro", "createdAt": "2020-11-12T12:39:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzMTI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ0NDk3NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520444975", "bodyText": "A Deque is the preferred Java Stack type (Stack is based on Vector, which is synchronized by default and the API is not as consistent as Deque)", "author": "dgomezferro", "createdAt": "2020-11-10T10:14:52Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/fk/Dfs.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.db.iapi.sql.dictionary.fk;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.utils.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Stack;\n+\n+public class Dfs {\n+    private final Graph graph;\n+    private final String newConstraintName;\n+    int[] dfsParent;\n+    boolean[] processed;\n+    boolean[] discovered;\n+    private boolean trackParents;\n+\n+    enum EdgeClassification {TREE, BACK, FORWARD, CROSS};\n+    EdgeClassification[] edgeTypes;\n+    Stack<Integer> stack;\n+    int[] entryTime;\n+    int[] exitTime;\n+    int time;\n+    ArrayList[] parents;\n+    boolean finished;\n+\n+\n+    public Dfs(Graph g, String newConstraintName) {\n+        this.graph = g;\n+        dfsParent = new int[g.getVertexCount()];\n+        processed = new boolean[g.getVertexCount()];\n+        discovered = new boolean[g.getVertexCount()];\n+        edgeTypes = new EdgeClassification[g.getVertexCount()];\n+        entryTime = new int[g.getVertexCount()];\n+        exitTime = new int[g.getVertexCount()];\n+        init();\n+        stack = new Stack<Integer>();", "originalCommit": "048e9b61fdc9dc17cd774780dec256e12f69ec13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3MDI0MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522070241", "bodyText": "done.", "author": "hatyo", "createdAt": "2020-11-12T12:30:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ0NDk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ0NTk1Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520445952", "bodyText": "is Step a better name than Time?", "author": "dgomezferro", "createdAt": "2020-11-10T10:16:17Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/fk/Dfs.java", "diffHunk": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.db.iapi.sql.dictionary.fk;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.utils.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Stack;\n+\n+public class Dfs {\n+    private final Graph graph;\n+    private final String newConstraintName;\n+    int[] dfsParent;\n+    boolean[] processed;\n+    boolean[] discovered;\n+    private boolean trackParents;\n+\n+    enum EdgeClassification {TREE, BACK, FORWARD, CROSS};\n+    EdgeClassification[] edgeTypes;\n+    Stack<Integer> stack;\n+    int[] entryTime;\n+    int[] exitTime;\n+    int time;", "originalCommit": "048e9b61fdc9dc17cd774780dec256e12f69ec13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3MDI4Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522070283", "bodyText": "done.", "author": "hatyo", "createdAt": "2020-11-12T12:30:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ0NTk1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ0OTUzMg==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520449532", "bodyText": "Can you document this class?", "author": "arnaud-splice", "createdAt": "2020-11-10T10:21:45Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/fk/Dfs.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.db.iapi.sql.dictionary.fk;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.reference.SQLState;\n+import javafx.util.Pair;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Stack;\n+\n+public class Dfs {", "originalCommit": "30b648f3119f15efed502b8b5c6a4821afd6c6e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ1NDQ1MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520454450", "bodyText": "And add unit tests for it?", "author": "arnaud-splice", "createdAt": "2020-11-10T10:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ0OTUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3MDY3MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522070671", "bodyText": "Can you document this class?\n\ndone\n\nAnd add unit tests for it?\n\nwill do in a separate JIRA ticket.", "author": "hatyo", "createdAt": "2020-11-12T12:30:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ0OTUzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ2MjQ1Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520462453", "bodyText": "Please use explicit names", "author": "arnaud-splice", "createdAt": "2020-11-10T10:41:45Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/fk/EdgeNode.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.db.iapi.sql.dictionary.fk;\n+\n+public class EdgeNode {\n+    public EdgeNode(int y, Type type) {\n+        this.y = y;\n+        this.type = type;\n+        this.next = null;\n+    }\n+\n+    enum Type {C, R, SN, NA};", "originalCommit": "30b648f3119f15efed502b8b5c6a4821afd6c6e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3Mjc5Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522072797", "bodyText": "I will write comments about each one's meaning, they are just used internally and they make quite easy to quickly check a complex graphviz diagram.", "author": "hatyo", "createdAt": "2020-11-12T12:34:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ2MjQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ2MTA2OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522461069", "bodyText": "wait, you can create a graphviz diagram out of this? how?", "author": "martinrupp", "createdAt": "2020-11-12T22:14:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ2MjQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ2MjY2Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520462662", "bodyText": "What is y?", "author": "arnaud-splice", "createdAt": "2020-11-10T10:42:04Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/fk/EdgeNode.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.db.iapi.sql.dictionary.fk;\n+\n+public class EdgeNode {\n+    public EdgeNode(int y, Type type) {\n+        this.y = y;", "originalCommit": "30b648f3119f15efed502b8b5c6a4821afd6c6e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3MTM3Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522071373", "bodyText": "It is the \"y\" part of an edge between (x,y) in the graph.", "author": "hatyo", "createdAt": "2020-11-12T12:32:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ2MjY2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjEwMjYzNA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522102634", "bodyText": "I refactored it and renamed it to to.", "author": "hatyo", "createdAt": "2020-11-12T13:25:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ2MjY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ2NTg1NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520465855", "bodyText": "Did you mean to replace 10000 with the result of the commented function?", "author": "arnaud-splice", "createdAt": "2020-11-10T10:47:06Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/DataDictionaryCache.java", "diffHunk": "@@ -144,6 +145,8 @@ public DataDictionaryCache(Properties startParams,DataDictionary dd) throws Stan\n                 Property.LANG_PROPERTY_CACHE_SIZE_DEFAULT);\n         int catalogVersionCacheSize = getCacheSize(startParams, Property.LANG_PROPERTY_CACHE_SIZE,\n                 Property.LANG_PROPERTY_CACHE_SIZE_DEFAULT);\n+        int constraintDescriptorListCacheSize = 10000;//getCacheSize(startParams, Property.LANG_PROPERTY_CACHE_SIZE,", "originalCommit": "93507b1735a13c85fad763c48a224f61c6c10119", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3MzA2MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522073061", "bodyText": "Correct, this is done in a more recent commit.", "author": "hatyo", "createdAt": "2020-11-12T12:35:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ2NTg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ2NjI4MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520466280", "bodyText": "Should that code be restored?", "author": "arnaud-splice", "createdAt": "2020-11-10T10:47:48Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/DataDictionaryCache.java", "diffHunk": "@@ -728,6 +734,32 @@ public void conglomerateDescriptorCacheRemove(Long conglomId) throws StandardExc\n         conglomerateDescriptorCache.invalidate(conglomId);\n     }\n \n+    public void constraintDescriptorListCacheAdd(UUID id, ConstraintDescriptorList item) throws StandardException {\n+        if (LOG.isDebugEnabled())\n+            LOG.debug(\"constraintDescriptorListCacheAdd \" + id);\n+        constraintDescriptorListCache.put(id,item);\n+    }\n+\n+    public ConstraintDescriptorList constraintDescriptorListCacheFind(UUID id) throws StandardException {\n+        //if (!dd.canReadCache(null))", "originalCommit": "93507b1735a13c85fad763c48a224f61c6c10119", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3MzQxNA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522073414", "bodyText": "Correct, it is already restored in more recent commits.", "author": "hatyo", "createdAt": "2020-11-12T12:35:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ2NjI4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ2OTIwNQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520469205", "bodyText": "Don't you need something in SpliceDatabase.java (registerDDL.startChange) to invalidate that new cache on DROP_CONSTRAINT?", "author": "arnaud-splice", "createdAt": "2020-11-10T10:52:18Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/catalog/DataDictionaryCache.java", "diffHunk": "@@ -507,6 +512,7 @@ public void clearAll() {\n         aliasDescriptorCache.invalidateAll();\n         catalogVersionCache.invalidateAll();\n         txnAwareConglomerateCache.invalidateAll();\n+        constraintDescriptorListCache.invalidateAll();", "originalCommit": "048e9b61fdc9dc17cd774780dec256e12f69ec13", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ3MzQ5Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520473492", "bodyText": "This is not enough, as it will only clear the constraint cache on the local. You need to use what we have in DDL.proto to communicate with the other servers. Check DDLUtils.java as well to see other uses for tables, schemas, etc.", "author": "arnaud-splice", "createdAt": "2020-11-10T10:58:45Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/impl/sql/execute/actions/DropConstraintConstantOperation.java", "diffHunk": "@@ -239,6 +239,8 @@ public void executeConstantAction(Activation activation ) throws StandardExcepti\n \t\t\tdm.invalidateFor(conDesc, DependencyManager.DROP_CONSTRAINT, lcc);\n \t\t\tdm.clearDependencies(lcc, conDesc);\n \t\t}\n+\n+\t\tdd.getDataDictionaryCache().clearConstraintDescriptorListCache(); // not sure if this is the correct place to do this.", "originalCommit": "048e9b61fdc9dc17cd774780dec256e12f69ec13", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ4NzI2NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520487265", "bodyText": "+1 for this one.", "author": "ascend1", "createdAt": "2020-11-10T11:21:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ3MzQ5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ4MDcwOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520480709", "bodyText": "you can define     private static final Logger LOG = Logger.getLogger(DDUtils.class); at the top of the class.", "author": "arnaud-splice", "createdAt": "2020-11-10T11:10:20Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/DDUtils.java", "diffHunk": "@@ -261,7 +261,7 @@ public static void validateReferentialActions(DataDictionary dd,\n                                                               deleteConnectionsMap,\n                                                               newForeignKeyConstraintName);\n             }\n-        }\n+        } // would be nice to have a logger so we can log that we are not going to perform foreign key checks.", "originalCommit": "47f178b331126d18e6fe03cb01370c9b4764029c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyOTEyNQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520429125", "bodyText": "Just a minor comment, execute might be a better name here since they are DDLs and no result set is produced.", "author": "ascend1", "createdAt": "2020-11-10T09:51:45Z", "path": "splice_machine/src/test/java/com/splicemachine/foreignkeys/ForeignKeyGraphIT.java", "diffHunk": "@@ -0,0 +1,195 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.foreignkeys;\n+\n+import com.splicemachine.derby.test.framework.SpliceSchemaWatcher;\n+import com.splicemachine.derby.test.framework.SpliceWatcher;\n+import org.junit.*;\n+\n+import java.sql.SQLException;\n+import java.sql.Statement;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class ForeignKeyGraphIT {\n+\n+    private static final String SCHEMA = ForeignKeyGraphIT.class.getSimpleName().toUpperCase();\n+\n+    @ClassRule\n+    public static SpliceWatcher watcher = new SpliceWatcher(SCHEMA);\n+\n+    @ClassRule\n+    public static SpliceSchemaWatcher spliceSchemaWatcher = new SpliceSchemaWatcher(SCHEMA);\n+\n+    static int counter = 0;\n+    private static String generateName() {\n+        return \"T\" + counter++;\n+    }\n+\n+    enum Action { NO_ACTION, SET_NULL, CASCADE, RESTRICT };\n+\n+    static class DDLGenerator {\n+        List<String> tables = null;\n+        List<String> ddls = null;\n+        String constraintName = null;\n+\n+        public DDLGenerator(int count) {\n+            tables = new ArrayList<>(count);\n+            ddls = new ArrayList<>();\n+            for(int i=0; i<count; ++i) {\n+                String tableName = generateName();\n+                tables.add(tableName);\n+                ddls.add(String.format(\"CREATE TABLE %s(C1 int primary key, C2 int)\", tableName));\n+            }\n+        }\n+\n+        private static String toString(Action action) {\n+            switch(action) {\n+                case NO_ACTION:\n+                    return \"NO ACTION\";\n+                case SET_NULL:\n+                    return \"SET NULL\";\n+                case CASCADE:\n+                    return \"CASCADE\";\n+                case RESTRICT:\n+                    return \"RESTRICT\";\n+                default:\n+                    assert false; // should not happen.\n+            }\n+            return \"\"; // make compiler happy.\n+        }\n+\n+        private String generateConstraintDdl(int child, int parent, Action action) {\n+            assert child >= 0 && child < tables.size();\n+            assert parent >= 0 && parent < tables.size();\n+            constraintName = generateName();\n+            return String.format(\"ALTER TABLE %s ADD CONSTRAINT \\\"%s\\\" FOREIGN KEY (C2) REFERENCES %s(C1) ON DELETE %s\",\n+                                 tables.get(child), constraintName, tables.get(parent), toString(action));\n+        }\n+\n+        public DDLGenerator link(int child, int parent, Action action) {\n+            ddls.add(generateConstraintDdl(child, parent, action));\n+            return this;\n+        }\n+\n+        public DDLGenerator materialize() throws Exception {", "originalCommit": "d48a45886ee287b2070b0da3bf70559d05b55cf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3Njk2Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522076967", "bodyText": "done.", "author": "hatyo", "createdAt": "2020-11-12T12:42:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQyOTEyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzOTY0NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520439645", "bodyText": "I think we have a Pair implementation in com.splicemachine.utils.Pair. Not sure if it's better to point there.", "author": "ascend1", "createdAt": "2020-11-10T10:06:53Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/fk/Dfs.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.db.iapi.sql.dictionary.fk;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.reference.SQLState;\n+import javafx.util.Pair;", "originalCommit": "30b648f3119f15efed502b8b5c6a4821afd6c6e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3NzMyMQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522077321", "bodyText": "Correct, it has been already addressed in recent commits.", "author": "hatyo", "createdAt": "2020-11-12T12:42:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQzOTY0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ0NzI5Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520447296", "bodyText": "TableDescriptor has a getQualifiedName() method for this purpose.", "author": "ascend1", "createdAt": "2020-11-10T10:18:22Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/fk/DictionaryGraphBuilder.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.db.iapi.sql.dictionary.fk;\n+\n+import com.splicemachine.db.catalog.UUID;\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.reference.SQLState;\n+import com.splicemachine.db.iapi.sql.StatementType;\n+import com.splicemachine.db.iapi.sql.dictionary.*;\n+import com.splicemachine.utils.Pair;\n+\n+import java.util.*;\n+\n+public class DictionaryGraphBuilder implements GraphBuilder {\n+\n+    private final TableDescriptor referencingTableDescriptor;\n+    private final DataDictionary dd;\n+    private final ConsInfo newConstraintInfo;\n+\n+    static class Edge {\n+        final String from;\n+        final EdgeNode.Type type;\n+        final String to;\n+\n+        Edge(String from, EdgeNode.Type type, String to) {\n+            this.from = from;\n+            this.type = type;\n+            this.to = to;\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            Edge edge = (Edge) o;\n+            return Objects.equals(from, edge.from) &&\n+                    type == edge.type &&\n+                    Objects.equals(to, edge.to);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(from, type, to);\n+        }\n+    }\n+\n+    private EdgeNode.Type toEdgeNodeType(int action) {\n+        switch (action) {\n+            case StatementType.RA_CASCADE:\n+                return EdgeNode.Type.C;\n+            case StatementType.RA_NOACTION:\n+                return EdgeNode.Type.NA;\n+            case StatementType.RA_RESTRICT:\n+                return EdgeNode.Type.R;\n+            case StatementType.RA_SETNULL:\n+                return EdgeNode.Type.SN;\n+        }\n+        throw new IllegalArgumentException(\"unexpected action type: \" + action);\n+    }\n+\n+    public DictionaryGraphBuilder(DataDictionary dd,\n+                                  TableDescriptor referencingTableDescriptor,\n+                                  ConsInfo newConstraintInfo) {\n+        this.dd = dd;\n+        this.referencingTableDescriptor = referencingTableDescriptor;\n+        this.newConstraintInfo = newConstraintInfo;\n+    }\n+\n+    List<Pair<TableDescriptor, EdgeNode.Type>> getParents(TableDescriptor tableDescriptor) throws StandardException {\n+        List<Pair<TableDescriptor, EdgeNode.Type>> result = new ArrayList<>();\n+        ConstraintDescriptorList constraintDescriptorList = dd.getConstraintDescriptors(tableDescriptor);\n+        for (ConstraintDescriptor constraintDescriptor : constraintDescriptorList) {\n+            if (!(constraintDescriptor instanceof ForeignKeyConstraintDescriptor)) { //look for foreign keys only\n+                continue;\n+            }\n+            ForeignKeyConstraintDescriptor foreignKeyConstraintDescriptor = (ForeignKeyConstraintDescriptor) constraintDescriptor;\n+\n+            // take care of cases where the FK is self-referencing, for now ignore.\n+            if (foreignKeyConstraintDescriptor.isSelfReferencingFK()) {\n+                continue;\n+            }\n+\n+            ReferencedKeyConstraintDescriptor referencedConstraint = foreignKeyConstraintDescriptor.getReferencedConstraint();\n+            TableDescriptor referencedConstraintTableDescriptor = referencedConstraint.getTableDescriptor();\n+\n+            result.add(new Pair<>(referencedConstraintTableDescriptor, toEdgeNodeType(foreignKeyConstraintDescriptor.getRaDeleteRule())));\n+        }\n+        return result;\n+    }\n+\n+    List<Pair<TableDescriptor, EdgeNode.Type>> getChildren(TableDescriptor tableDescriptor) throws StandardException {\n+        List<Pair<TableDescriptor, EdgeNode.Type>> result = new ArrayList<>();\n+        ConstraintDescriptorList constraintDescriptorList = dd.getConstraintDescriptors(tableDescriptor);\n+        for (ConstraintDescriptor cd : constraintDescriptorList) {\n+            if ((cd instanceof ReferencedKeyConstraintDescriptor)) {\n+                ConstraintDescriptorList fkcdl = dd.getActiveConstraintDescriptors\n+                        (((ReferencedKeyConstraintDescriptor) cd).getForeignKeyConstraints(ConstraintDescriptor.ALL));\n+                int size = fkcdl.size();\n+                if (size == 0) {\n+                    continue;\n+                }\n+                for (int inner = 0; inner < size; inner++) {\n+                    ForeignKeyConstraintDescriptor fkcd = (ForeignKeyConstraintDescriptor) fkcdl.elementAt(inner);\n+                    TableDescriptor fktd = fkcd.getTableDescriptor();\n+                    // take care of cases where the FK is self-referencing, for now ignore.\n+                    if (fkcd.isSelfReferencingFK()) {\n+                        continue;\n+                    }\n+                    result.add(new Pair<>(fktd, toEdgeNodeType(fkcd.getRaDeleteRule())));\n+                }\n+            }\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Graph generateGraph() throws StandardException {\n+        Set<Edge> edges = new HashSet<>();\n+        Set<String> tableNames = new HashSet<>();\n+\n+        Queue<TableDescriptor> descriptors = new LinkedList();\n+        descriptors.add(referencingTableDescriptor);\n+\n+        TableDescriptor referencedTableDescriptor = newConstraintInfo.getReferencedTableDescriptor(dd);\n+        descriptors.add(referencedTableDescriptor);\n+\n+        Set<UUID> visited = new HashSet<>();\n+\n+        while(!descriptors.isEmpty()) {\n+            TableDescriptor descriptor = descriptors.remove();\n+            visited.add(descriptor.getUUID());\n+            String tableName = descriptor.getSchemaName() + \".\" + descriptor.getName();", "originalCommit": "30b648f3119f15efed502b8b5c6a4821afd6c6e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3ODM0MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522078340", "bodyText": "Thanks! fixed in multiple places.", "author": "hatyo", "createdAt": "2020-11-12T12:44:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ0NzI5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ1MDI1NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520450255", "bodyText": "Maybe make the enum item names more descriptive, like capitalized full word? It's more readable and doesn't hurt. Also for variable y. By looking at this file only, it's hard to get what y is for.", "author": "ascend1", "createdAt": "2020-11-10T10:22:53Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/fk/EdgeNode.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.db.iapi.sql.dictionary.fk;\n+\n+public class EdgeNode {\n+    public EdgeNode(int y, Type type) {\n+        this.y = y;\n+        this.type = type;\n+        this.next = null;\n+    }\n+\n+    enum Type {C, R, SN, NA};", "originalCommit": "30b648f3119f15efed502b8b5c6a4821afd6c6e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA3ODk3NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522078974", "bodyText": "OK, I give up :) (read the comment I wrote to Arnaud), two opinions beat one, I will fix accordingly! :)", "author": "hatyo", "createdAt": "2020-11-12T12:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ1MDI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ1NTc1Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520455753", "bodyText": "Also here about the Pair package.", "author": "ascend1", "createdAt": "2020-11-10T10:31:05Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/fk/GraphAnnotator.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright (c) 2012 - 2020 Splice Machine, Inc.\n+ * This file is part of Splice Machine.\n+ * Splice Machine is free software: you can redistribute it and/or modify it under the terms of the\n+ * GNU Affero General Public License as published by the Free Software Foundation, either\n+ * version 3, or (at your option) any later version.\n+ * Splice Machine is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n+ * See the GNU Affero General Public License for more details.\n+ * You should have received a copy of the GNU Affero General Public License along with Splice Machine.\n+ * If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package com.splicemachine.db.iapi.sql.dictionary.fk;\n+\n+import com.splicemachine.db.iapi.error.StandardException;\n+import com.splicemachine.db.iapi.reference.SQLState;\n+import javafx.util.Pair;", "originalCommit": "30b648f3119f15efed502b8b5c6a4821afd6c6e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA5MTc3Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522091777", "bodyText": "already fixed in more recent commits.", "author": "hatyo", "createdAt": "2020-11-12T13:07:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ1NTc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ3ODc1MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520478750", "bodyText": "Maybe add some comments describing the graph structure. Having an example with three nodes would be very helpful in understanding how it works. Currently, interface doesn't match call site (from <-> to reversed) and it's a bit confusing.", "author": "ascend1", "createdAt": "2020-11-10T11:07:02Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/fk/Graph.java", "diffHunk": "@@ -29,12 +36,66 @@ public Graph(Set<String> vertices) {\n             vertexIndex.put(vertex, i++);\n         }\n         parents = new int[vertices.size()][];\n+        surrogateCounter = 0;\n+        this.newConstraintName = newConstraintName;\n+        this.surrogates = new HashMap<>();\n+    }\n+\n+    void addEdge(String from, String to, EdgeNode.Type type) throws StandardException {", "originalCommit": "93507b1735a13c85fad763c48a224f61c6c10119", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA5Mzk5MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522093990", "bodyText": "totally agree, I fixed it, and added more documentation.", "author": "hatyo", "createdAt": "2020-11-12T13:10:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ3ODc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ4MzU1NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r520483555", "bodyText": "Is this an error that we expected? I mean, talking about just an abstract graph, if we want to delete an edge that doesn't exist, might just be a no-op and OK to be safely ignored. Or if we don't expect this ever happen, probably assert instead of throw.", "author": "ascend1", "createdAt": "2020-11-10T11:15:01Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/fk/Graph.java", "diffHunk": "@@ -71,4 +132,50 @@ public int getVertexCount() {\n         return vertexIndex.size();\n \n     }\n+\n+    public EdgeNode.Type getEdgeType(int from, int to) {\n+        EdgeNode edgeNode = getEdge(from);\n+        while(true) {\n+            if(edgeNode == null) {\n+                throw new IllegalArgumentException(\"no edge between \" + getName(from) + \" and \" + getName(to));\n+            }\n+            if(edgeNode.y == to) {\n+                return edgeNode.type;\n+            }\n+            edgeNode = edgeNode.next;\n+        }\n+    }\n+\n+    public void removeEdge(int from, int to) {\n+        EdgeNode edgeNode = getEdge(from);\n+        if(edgeNode == null) {\n+            throw new IllegalArgumentException(\"no edge between \" + getName(from) + \" and \" + getName(to));\n+        }", "originalCommit": "93507b1735a13c85fad763c48a224f61c6c10119", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA5MjI3OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522092279", "bodyText": "You're right, it should never happen, but still I would rather keep an exception to get more context if something goes wrong.", "author": "hatyo", "createdAt": "2020-11-12T13:08:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDQ4MzU1NQ=="}], "type": "inlineReview"}, {"oid": "7d1b66d982d9db853658772d05e0fd516bbd2070", "url": "https://github.com/splicemachine/spliceengine/commit/7d1b66d982d9db853658772d05e0fd516bbd2070", "message": "DB-10638 address comments.", "committedDate": "2020-11-12T13:55:55Z", "type": "commit"}, {"oid": "6892021fb5b41b96307141fe228bc70c23650c65", "url": "https://github.com/splicemachine/spliceengine/commit/6892021fb5b41b96307141fe228bc70c23650c65", "message": "DB-10638 improve cache consistency across multiple RS.\n\n- add test.", "committedDate": "2020-11-12T21:16:40Z", "type": "commit"}, {"oid": "38271f9719b203c98c1ce748cc3ad09f28da4953", "url": "https://github.com/splicemachine/spliceengine/commit/38271f9719b203c98c1ce748cc3ad09f28da4953", "message": "Merge remote-tracking branch 'origin/master' into DB-10638", "committedDate": "2020-11-12T21:18:36Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ2OTE2MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522469161", "bodyText": "Nitpick, name is a bit confusing since it's being used for both Add/Drop, preAlter.. might be better.", "author": "dgomezferro", "createdAt": "2020-11-12T22:22:46Z", "path": "splice_machine/src/main/java/com/splicemachine/derby/ddl/DDLUtils.java", "diffHunk": "@@ -309,6 +309,14 @@ public static BitSet getIndexedCols(int[] indexColsToMainColMap) {\n         }\n     }\n \n+    public static void preDropForeignKey(DDLMessage.DDLChange change, DataDictionary dd) throws StandardException {", "originalCommit": "6892021fb5b41b96307141fe228bc70c23650c65", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjgzODYxOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4513#discussion_r522838619", "bodyText": "Thanks Daniel, you're right, I will address it in another PR where I improve the FK checker.", "author": "hatyo", "createdAt": "2020-11-13T09:46:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ2OTE2MQ=="}], "type": "inlineReview"}]}