{"pr_number": 4789, "pr_title": "DB-10963 Add timeouts to connection.close() and call abort() on timeout", "pr_createdAt": "2020-12-04T18:15:28Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4789", "timeline": [{"oid": "46b17619a403213f79fd70a22f404270417c927c", "url": "https://github.com/splicemachine/spliceengine/commit/46b17619a403213f79fd70a22f404270417c927c", "message": "DB-10963 Add timeouts to connection.close() and call abort() on timeout", "committedDate": "2020-12-04T18:09:18Z", "type": "commit"}, {"oid": "cf96b9ee9ecfab3e890703e8f21a29662d1ce126", "url": "https://github.com/splicemachine/spliceengine/commit/cf96b9ee9ecfab3e890703e8f21a29662d1ce126", "message": "DB-10963 Fix spotbugs", "committedDate": "2020-12-04T18:57:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE5MjU3NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4789#discussion_r538192574", "bodyText": "The thread pool is shared right? according to the doc:\n\npublic static ExecutorService newFixedThreadPool(int nThreads)\n... At any point, at most nThreads threads will be active processing tasks. If additional tasks are submitted when all threads are active, they will wait in the queue until a thread is available.\n\nIf we run Test suites in parallel which use SpliceWatcher, could it lead to competition between different suites calling closeConnection on parallel and causing some of them to time out (as they are given 10 seconds to finish per line 198).", "author": "hatyo", "createdAt": "2020-12-08T09:51:49Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/test/framework/SpliceWatcher.java", "diffHunk": "@@ -160,21 +173,61 @@ public PreparedStatement prepareStatement(String sql) throws SQLException {\n         return ps;\n     }\n \n+    /**\n+     * Try closing connections gracefully from different threads, if that takes long it could be some queries are stuck,\n+     * so abort the connections forcefully instead\n+     */\n     private void closeConnections() {\n+        int numThreads = connections.size() + 2; // two extra for the .abort() call\n+        ExecutorService executor = Executors.newFixedThreadPool(numThreads,", "originalCommit": "cf96b9ee9ecfab3e890703e8f21a29662d1ce126", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA3NjU3NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4789#discussion_r540076575", "bodyText": "It wasn't shared, but I think it's better if it is. I made the Executor a cachedThreadPool without a thread limit, so resources should be enough for concurrent ITs.", "author": "dgomezferro", "createdAt": "2020-12-10T11:02:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE5MjU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE5MzgwNA==", "url": "https://github.com/splicemachine/spliceengine/pull/4789#discussion_r538193804", "bodyText": "Does it make sense to at least log this exception?", "author": "hatyo", "createdAt": "2020-12-08T09:53:29Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/test/framework/SpliceWatcher.java", "diffHunk": "@@ -160,21 +173,61 @@ public PreparedStatement prepareStatement(String sql) throws SQLException {\n         return ps;\n     }\n \n+    /**\n+     * Try closing connections gracefully from different threads, if that takes long it could be some queries are stuck,\n+     * so abort the connections forcefully instead\n+     */\n     private void closeConnections() {\n+        int numThreads = connections.size() + 2; // two extra for the .abort() call\n+        ExecutorService executor = Executors.newFixedThreadPool(numThreads,\n+                new ThreadFactoryBuilder().setDaemon(true).setNameFormat(\"connection-close-%d\").build());\n+        CompletionService<Void> completionService =\n+                new ExecutorCompletionService<>(executor);\n         try {\n-            for (Connection connection : connections) {\n-                if (connection != null && !connection.isClosed()) {\n-                    try {\n-                        connection.close();\n-                    } catch (SQLException e) {\n-                        connection.rollback();\n+            connections.stream().forEach(connection -> completionService.submit(() -> {\n+                try {\n+                    if (connection != null && !connection.isClosed())\n                         connection.close();\n+                } catch (SQLException e) {", "originalCommit": "cf96b9ee9ecfab3e890703e8f21a29662d1ce126", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA3NzAyNg==", "url": "https://github.com/splicemachine/spliceengine/pull/4789#discussion_r540077026", "bodyText": "Good point, made the change.", "author": "dgomezferro", "createdAt": "2020-12-10T11:03:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE5MzgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE5NTIzOA==", "url": "https://github.com/splicemachine/spliceengine/pull/4789#discussion_r538195238", "bodyText": "we were verifying previously that the result set contained at least one row, this is removed now, is this intentional?", "author": "hatyo", "createdAt": "2020-12-08T09:55:26Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/utils/SpliceAdmin_OperationsIT.java", "diffHunk": "@@ -239,11 +246,9 @@ public void testKillLongRunningQuery(boolean useSpark) throws Exception {\n         Thread thread = new Thread(new Runnable() {\n             @Override\n             public void run() {\n-                PreparedStatement ps = null;\n-                try (TestConnection connection = methodWatcher.createConnection()) {\n-                    ps = connection.prepareStatement(sql);\n-                    ResultSet rs = ps.executeQuery();\n-                    assertTrue(rs.next());\n+                try (TestConnection connection = methodWatcher.createConnection();\n+                     PreparedStatement ps = connection.prepareStatement(sql);\n+                     ResultSet rs = ps.executeQuery()) {", "originalCommit": "cf96b9ee9ecfab3e890703e8f21a29662d1ce126", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA4NjQzNg==", "url": "https://github.com/splicemachine/spliceengine/pull/4789#discussion_r540086436", "bodyText": "Yes, this query was never completing in the first place (it's a long running query on purpose) and it was running in a separate thread, so even if the assertion failed it wouldn't have failed the test.", "author": "dgomezferro", "createdAt": "2020-12-10T11:18:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE5NTIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI0NzQ3MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4789#discussion_r538247470", "bodyText": "(minor comment) this would wait 10 second not for each, but 10 second every time you call it, so the first one is for 10s, the second 20s, third 30s etc.. Maybe sth like\nFuture<Void> future = completionService.poll(futures  == 0 ? 10 : 1, TimeUnit.SECONDS);\nI'm not entirely sure you need a CompletionService here at all, maybe a simple\nExecutorService.invokeAll(Callable, timeout, TimeUnit) would work.", "author": "martinrupp", "createdAt": "2020-12-08T11:06:02Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/test/framework/SpliceWatcher.java", "diffHunk": "@@ -160,21 +173,61 @@ public PreparedStatement prepareStatement(String sql) throws SQLException {\n         return ps;\n     }\n \n+    /**\n+     * Try closing connections gracefully from different threads, if that takes long it could be some queries are stuck,\n+     * so abort the connections forcefully instead\n+     */\n     private void closeConnections() {\n+        int numThreads = connections.size() + 2; // two extra for the .abort() call\n+        ExecutorService executor = Executors.newFixedThreadPool(numThreads,\n+                new ThreadFactoryBuilder().setDaemon(true).setNameFormat(\"connection-close-%d\").build());\n+        CompletionService<Void> completionService =\n+                new ExecutorCompletionService<>(executor);\n         try {\n-            for (Connection connection : connections) {\n-                if (connection != null && !connection.isClosed()) {\n-                    try {\n-                        connection.close();\n-                    } catch (SQLException e) {\n-                        connection.rollback();\n+            connections.stream().forEach(connection -> completionService.submit(() -> {\n+                try {\n+                    if (connection != null && !connection.isClosed())\n                         connection.close();\n+                } catch (SQLException e) {\n+                }\n+                return null;\n+            }));\n+\n+            int futures = 0;\n+            while(futures++ < connections.size()) {\n+                Future<Void> future = completionService.poll(10, TimeUnit.SECONDS);", "originalCommit": "cf96b9ee9ecfab3e890703e8f21a29662d1ce126", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA4NjkyNQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4789#discussion_r540086925", "bodyText": "I like the invokeAll approach, we need to check the futures afterwards to see if they are done or not, but I think it's cleaner.", "author": "dgomezferro", "createdAt": "2020-12-10T11:19:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODI0NzQ3MA=="}], "type": "inlineReview"}, {"oid": "8b1d6b764af5a5eead983f685d6eb33b6f68d48e", "url": "https://github.com/splicemachine/spliceengine/commit/8b1d6b764af5a5eead983f685d6eb33b6f68d48e", "message": "DB-10963 Address reviews", "committedDate": "2020-12-10T11:43:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEwODM3OA==", "url": "https://github.com/splicemachine/spliceengine/pull/4789#discussion_r540108378", "bodyText": "wouldn't this cause problems when running tests in parallel?", "author": "martinrupp", "createdAt": "2020-12-10T11:54:41Z", "path": "splice_machine/src/test/java/com/splicemachine/derby/test/framework/SpliceWatcher.java", "diffHunk": "@@ -51,6 +54,8 @@\n public class SpliceWatcher extends TestWatcher implements AutoCloseable {\n \n     private static final Logger LOG = Logger.getLogger(SpliceWatcher.class);\n+    private static ExecutorService executor = Executors.newCachedThreadPool(\n+            new ThreadFactoryBuilder().setDaemon(true).setNameFormat(\"connection-close-%d\").build());", "originalCommit": "8b1d6b764af5a5eead983f685d6eb33b6f68d48e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDExMTc4MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4789#discussion_r540111780", "bodyText": "I don't think so, each task would get it's own thread and we are not limiting the amount of threads, so there should be no conflict.", "author": "dgomezferro", "createdAt": "2020-12-10T12:00:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEwODM3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDExMjM2OQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4789#discussion_r540112369", "bodyText": "right, ok!", "author": "martinrupp", "createdAt": "2020-12-10T12:01:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDEwODM3OA=="}], "type": "inlineReview"}]}