{"pr_number": 4063, "pr_title": "DB-10067 Support creating indexes on expressions", "pr_createdAt": "2020-08-31T16:59:21Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/4063", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczNDIxNw==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r482734217", "bodyText": "is that tab/spaces mixed?", "author": "martinrupp", "createdAt": "2020-09-03T06:31:51Z", "path": "db-engine/src/main/java/com/splicemachine/db/catalog/types/IndexDescriptorImpl.java", "diffHunk": "@@ -269,20 +322,35 @@ else if (isUniqueWithDuplicateNulls)\n \tpublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n         FormatableHashtable fh = (FormatableHashtable) in.readObject();\n         isUnique = fh.getBoolean(\"isUnique\");\n-        int bcpLength = fh.getInt(\"keyLength\");\n-        baseColumnPositions = new int[bcpLength];\n-        isAscending = new boolean[bcpLength];\n-        for (int i = 0; i < bcpLength; i++) {\n-            baseColumnPositions[i] = fh.getInt(\"bcp\" + i);\n-            isAscending[i] = fh.getBoolean(\"isAsc\" + i);\n-        }\n+        int keyLength = fh.getInt(\"keyLength\");\n+\t\tisAscending = new boolean[keyLength];", "originalCommit": "fcf5fe75e5b5377c720614030620aa6506601b74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMwOTkyNw==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r483309927", "bodyText": "Yes I also found my Intellij is confused about mixing tabs and spaces after pushing these commits. I try to fix them in the following commits.", "author": "ascend1", "createdAt": "2020-09-03T23:45:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczNDIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczNDYwNw==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r482734607", "bodyText": "we should maybe use sth like static final String numBaseColumnsKey = \"numBaseColumns\" for this (also other keys)", "author": "martinrupp", "createdAt": "2020-09-03T06:32:49Z", "path": "db-engine/src/main/java/com/splicemachine/db/catalog/types/IndexDescriptorImpl.java", "diffHunk": "@@ -269,20 +322,35 @@ else if (isUniqueWithDuplicateNulls)\n \tpublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n         FormatableHashtable fh = (FormatableHashtable) in.readObject();\n         isUnique = fh.getBoolean(\"isUnique\");\n-        int bcpLength = fh.getInt(\"keyLength\");\n-        baseColumnPositions = new int[bcpLength];\n-        isAscending = new boolean[bcpLength];\n-        for (int i = 0; i < bcpLength; i++) {\n-            baseColumnPositions[i] = fh.getInt(\"bcp\" + i);\n-            isAscending[i] = fh.getBoolean(\"isAsc\" + i);\n-        }\n+        int keyLength = fh.getInt(\"keyLength\");\n+\t\tisAscending = new boolean[keyLength];\n+\t\tfor (int i = 0; i < keyLength; i++) {\n+\t\t\tisAscending[i] = fh.getBoolean(\"isAsc\" + i);\n+\t\t}\n+\t\tint numBaseColumns = fh.containsKey(\"numBaseColumns\") ? fh.getInt(\"numBaseColumns\") : keyLength;", "originalCommit": "fcf5fe75e5b5377c720614030620aa6506601b74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYxOTUwMg==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r483619502", "bodyText": "Good point, would make it less error-prone. Done.", "author": "ascend1", "createdAt": "2020-09-04T13:35:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczNDYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczNjgzNw==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r482736837", "bodyText": "it's not immediately clear why you don't use id.baseColumnPositions(); in this else branch, can you maybe add a comment in the code?", "author": "martinrupp", "createdAt": "2020-09-03T06:38:17Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/IndexRowGenerator.java", "diffHunk": "@@ -150,17 +185,23 @@ public ExecIndexRow getNullIndexRow(ColumnDescriptorList columnList,\n     \t\tRowLocation rowLocation)\n     throws StandardException\n     {\n-\t\tint[] baseColumnPositions = id.baseColumnPositions();\n \t\tExecIndexRow indexRow = getIndexRowTemplate();\n-\n-\t\tfor (int i = 0; i < baseColumnPositions.length; i++)\n-\t\t{\n-\t\t\tDataTypeDescriptor dtd =\n-\t\t\t\tcolumnList.elementAt(baseColumnPositions[i] - 1).getType();\n-\t\t\tindexRow.setColumn(i + 1, dtd.getNull());\n+\t\tDataTypeDescriptor[] columnTypes = getIndexColumnTypes();\n+\n+\t\tif (columnTypes.length == 0) {\n+\t\t\tint[] baseColumnPositions = id.baseColumnPositions();\n+\t\t\tfor (int i = 0; i < baseColumnPositions.length; i++) {\n+\t\t\t\tDataTypeDescriptor dtd =\n+\t\t\t\t\t\tcolumnList.elementAt(baseColumnPositions[i] - 1).getType();\n+\t\t\t\tindexRow.setColumn(i + 1, dtd.getNull());\n+\t\t\t}\n+\t\t\tindexRow.setColumn(baseColumnPositions.length + 1, rowLocation);\n+\t\t} else {\n+\t\t\tfor (int i = 0; i < columnTypes.length; i++) {", "originalCommit": "fcf5fe75e5b5377c720614030620aa6506601b74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYyMDU2MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r483620560", "bodyText": "Done.", "author": "ascend1", "createdAt": "2020-09-04T13:37:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczNjgzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczNzI1Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r482737256", "bodyText": "maybe extract function getExpandedRow() ?", "author": "martinrupp", "createdAt": "2020-09-03T06:39:08Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/IndexRowGenerator.java", "diffHunk": "@@ -230,49 +271,69 @@ private void getIndexRowHelper(ExecRow baseRow,\n \t\t\t\t\t\t\tboolean alwaysIncludeLocation)\n \t\t\t\t\t\tthrows StandardException\n \t{\n-\t\t/*\n-\t\t** Set the columns in the index row that are based on columns in\n-\t\t** the base row.\n-\t\t*/\n-\t\tint[] baseColumnPositions = id.baseColumnPositions();\n-\t\tint colCount = baseColumnPositions.length;\n-\n-\t\tif (bitSet == null)\n-\t\t{\n-\t\t\t/*\n-\t\t\t** Set the columns in the index row that are based on columns in\n-\t\t\t** the base row.\n-\t\t\t*/\n-\t\t\tfor (int i = 0; i < colCount ; i++)\n-\t\t\t{\n-\t\t\t\tindexRow.setColumn(i + 1,\n-\t\t\t\t\t\tbaseRow.getColumn(baseColumnPositions[i]));\n+\t\tint colCount;\n+\t\tif (isOnExpression()) {\n+\t\t\tcolCount = isAscending().length;\n+\t\t\tExecRow expandedRow;\n+\n+\t\t\tif (bitSet == null) {", "originalCommit": "fcf5fe75e5b5377c720614030620aa6506601b74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczOTk0Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r482739947", "bodyText": "why is this code so different from the code in lines 326-336? it somehow has the feel it's doing the same, it should maybe look the same, or maybe use same code (e.g. extract a function which returns an array of pairs expandedRowIndex -> column, so that i could write e.g. code like\nexpandedRow = new ValueRow(maxNumCols);\nauto mapping = getRowColMapping();\nfor( auto pair : mapping )\n{\n  expandedRow.setColumn(pair.first, pair.second);\n}\n\nand the code below would be\nauto mapping = getRowColMapping();\nfor( auto pair : mapping )\n{\n  indexRow.setColumn(pair.first, pair.second);\n}", "author": "martinrupp", "createdAt": "2020-09-03T06:43:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczNzI1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYzOTI4NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r483639284", "bodyText": "The code in lines 326 - 336 (in latest commit 329 - 339) doesn't actually expand baseRow. Consider a partial baseRow that has the original columns 3, 5, 7. The row looks like this:\noriginal col pos    :  3   |   5   |   7\nrow column pos      :  1   |   2   |   3\n\nbitSet should have bits for 3, 5, and 7 set. Let's suppose the index column to base column mapping (i.e., baseColumnPositions) is 5, 3, 7. That is, the first index column is full base row column 5, the second index column is full base row column 3, and so on. Btw, column position is always 1-based.\nThe code tries to assign columns in indexRow directly from the partial row. To achieve that, it needs to get the position of the full base row column in this partial row. Take the first index column as an example:\nfullColumnNumber = baseColumnPositions[0], which is 5. Now we count the bitSet from 1 to 5 inclusive. 3 is set, 5 is set, so we get partialColumnNumber = 2. That is, the full base row column 5 is at position 2 in this partial row.\nThe new code doesn't do this. Instead, it creates a new row, trying to be wide enough to hold the columns at their full base row positions. Example of an expanded row:\noriginal column pos :  x | x | 3 | x | 5 | x | 7\nexpanded row pos    :  1 | 2 | 3 | 4 | 5 | 6 | 7\n\nThe full base row might have more than 7 columns. But since our index column mapping tells us we only use up to column 7, we expand to 7.\nWe need to expand the row as a way to normalize the input for generated code. During code generation, only full base row column positions are available, not with any mapping. So for generated code, it assumes the row passed in is a full base row.\nWe can unify the two code paths by always expanding the row. But then it would be unnecessary extra cost in case of normal index creation. That's one point I mentioned in the design discussion the other day.", "author": "ascend1", "createdAt": "2020-09-04T14:09:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczNzI1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzcyNTUxOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r487725519", "bodyText": "ah, ok", "author": "martinrupp", "createdAt": "2020-09-14T08:05:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczNzI1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MTMxMA==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r482741310", "bodyText": "tabs/spaces mix?", "author": "martinrupp", "createdAt": "2020-09-03T06:46:47Z", "path": "db-engine/src/main/java/com/splicemachine/db/iapi/sql/dictionary/IndexRowGenerator.java", "diffHunk": "@@ -489,4 +553,33 @@ public int getTypeFormatId()\n     public boolean isPrimaryKey() {\n         return indexType() != null && indexType().contains(\"PRIMARY\");\n     }\n+\n+\t/** @see IndexDescriptor#getCompiledExpressions */\n+\t@Override\n+\tpublic ByteArray[] getCompiledExpressions() { return id.getCompiledExpressions(); }\n+\n+\t/** @see IndexDescriptor#getCompiledExpressionClassNames */\n+\t@Override\n+\tpublic String[] getCompiledExpressionClassNames() { return id.getCompiledExpressionClassNames(); }\n+\n+\t/** @see IndexDescriptor#isOnExpression */\n+    @Override\n+\tpublic boolean isOnExpression() { return id.isOnExpression(); }\n+\n+\t/** @see IndexDescriptor#getExecutableIndexExpression */\n+\t@Override\n+\tpublic BaseExecutableIndexExpression getExecutableIndexExpression(int indexColumnPosition)\n+\t\t\tthrows StandardException\n+\t{\n+    \treturn id.getExecutableIndexExpression(indexColumnPosition);\n+\t}\n+\n+\tprivate int getMaxBaseColumnPosition() {\n+    \tint maxPosition = 1;  // base column positions are 1-based", "originalCommit": "fcf5fe75e5b5377c720614030620aa6506601b74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY0MDQ0Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r483640447", "bodyText": "Fixed in following commits.", "author": "ascend1", "createdAt": "2020-09-04T14:11:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MTMxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MTc2Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r482741767", "bodyText": "maybe align like other members? (also below)", "author": "martinrupp", "createdAt": "2020-09-03T06:47:52Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java", "diffHunk": "@@ -64,8 +68,9 @@\n \tString\t\t\t\tindexType;\n \tTableName\t\t\tindexName;\n \tTableName\t\t\ttableName;\n-\tVector\t\t\t\tcolumnNameList;\n-\tString[]\t\t\tcolumnNames = null;\n+\tVector<IndexExpression> expressionList;", "originalCommit": "fcf5fe75e5b5377c720614030620aa6506601b74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY0MDg2Mw==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r483640863", "bodyText": "Yes, fixed in the following commits.", "author": "ascend1", "createdAt": "2020-09-04T14:11:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MTc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MjI3Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r482742277", "bodyText": "extract into function", "author": "martinrupp", "createdAt": "2020-09-03T06:49:10Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java", "diffHunk": "@@ -264,6 +280,55 @@ public void bindStatement() throws StandardException\n //  \t\t\t\t\t\t\t\t\t\t\t\t sd.getSchemaName());\n //  \t\t}\n \n+\t\tif (onExpression) {", "originalCommit": "fcf5fe75e5b5377c720614030620aa6506601b74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY0MTAzMA==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r483641030", "bodyText": "Done.", "author": "ascend1", "createdAt": "2020-09-04T14:12:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MjI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MzQ4Mg==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r482743482", "bodyText": "remove. we have ie.isAscending now, no \"space at end\" logic anymore, right?", "author": "martinrupp", "createdAt": "2020-09-03T06:51:39Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java", "diffHunk": "@@ -371,32 +439,79 @@ public ConstantAction\tmakeConstantAction() throws StandardException\n \tprivate void verifyAndGetUniqueNames()\n \t\t\t\tthrows StandardException\n \t{\n-\t\tint size = columnNameList.size();\n-\t\tHashtable\tht = new Hashtable(size + 2, (float) .999);\n-\t\tcolumnNames = new String[size];\n+\t\tint size = expressionList.size();\n \t\tisAscending = new boolean[size];\n \n-\t\tfor (int index = 0; index < size; index++)\n-\t\t{\n-\t\t\t/* Verify that this column's name is unique within the list\n-\t\t\t * Having a space at the end meaning descending on the column\n-\t\t\t */\n-\t\t\tcolumnNames[index] = (String) columnNameList.get(index);\n-\t\t\tif (columnNames[index].endsWith(\" \"))\n-\t\t\t{\n-\t\t\t\tcolumnNames[index] = columnNames[index].substring(0, columnNames[index].length() - 1);\n-\t\t\t\tisAscending[index] = false;\n+\t\tif (onExpression) {\n+\t\t\tCollectNodesVisitor cnv = new CollectNodesVisitor(ColumnReference.class);\n+\t\t\tfor (int i = 0; i < size; i++) {\n+\t\t\t\tIndexExpression ie = expressionList.get(i);\n+\t\t\t\tie.expression.accept(cnv);\n+\t\t\t\tisAscending[i] = ie.isAscending;\n+\t\t\t}\n+\t\t\tVector<ColumnReference> columnReferenceList = cnv.getList();\n+\t\t\tif (columnReferenceList.isEmpty()) {\n+\t\t\t\t// TODO: correct exception\n+\t\t\t\tthrow StandardException.newException(SQLState.LANG_SYNTAX_ERROR, \"index expression must contain at least one column reference\");\n \t\t\t}\n-\t\t\telse\n-\t\t\t\tisAscending[index] = true;\n-\n-\t\t\tObject object = ht.put(columnNames[index], columnNames[index]);\n \n-\t\t\tif (object != null &&\n-\t\t\t\t((String) object).equals(columnNames[index]))\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException(SQLState.LANG_DUPLICATE_COLUMN_NAME_CREATE_INDEX, columnNames[index]);\n+\t\t\tHashSet<String> columnNameSet = new HashSet<>();\n+\t\t\tfor (ColumnReference cr : columnReferenceList) {\n+\t\t\t\tcolumnNameSet.add(cr.getColumnName());\n+\t\t\t}\n+\t\t\tinvolvedColumnNames = new String[columnNameSet.size()];\n+\t\t\tcolumnNameSet.toArray(involvedColumnNames);\n+\t\t}\n+\t\telse {\n+\t\t\tHashtable\tht = new Hashtable(size + 2, (float) .999);\n+\t\t\tinvolvedColumnNames = new String[size];\n+\n+\t\t\tfor (int index = 0; index < size; index++) {\n+\t\t\t\t/* Verify that this column's name is unique within the list\n+\t\t\t\t * Having a space at the end meaning descending on the column\n+\t\t\t\t */", "originalCommit": "fcf5fe75e5b5377c720614030620aa6506601b74", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzY0MTE5MQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r483641191", "bodyText": "Good catch! Removed.", "author": "ascend1", "createdAt": "2020-09-04T14:12:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MzQ4Mg=="}], "type": "inlineReview"}, {"oid": "caeebfcca3141eab9c51e93019bf57e9638156ce", "url": "https://github.com/splicemachine/spliceengine/commit/caeebfcca3141eab9c51e93019bf57e9638156ce", "message": "DB-10067 Add DDL metadata to support creating index on expressions", "committedDate": "2020-09-04T10:52:51Z", "type": "commit"}, {"oid": "12b2140b5d6e0bc1801d0f7da319b1dd26a60a07", "url": "https://github.com/splicemachine/spliceengine/commit/12b2140b5d6e0bc1801d0f7da319b1dd26a60a07", "message": "DB-10067 Apply index expressions on existing data when creating an index", "committedDate": "2020-09-04T10:52:51Z", "type": "commit"}, {"oid": "aeb73ed556a6596adfd6b6dc8330ceca805c37c3", "url": "https://github.com/splicemachine/spliceengine/commit/aeb73ed556a6596adfd6b6dc8330ceca805c37c3", "message": "DB-10067 Apply existing index expressions on new changes of data", "committedDate": "2020-09-04T10:52:51Z", "type": "commit"}, {"oid": "0a8ebc795acff4712f40638e59492775e1f990d6", "url": "https://github.com/splicemachine/spliceengine/commit/0a8ebc795acff4712f40638e59492775e1f990d6", "message": "DB-10067 Prevent from using indexes on expressions for now", "committedDate": "2020-09-04T10:52:51Z", "type": "commit"}, {"oid": "fd34e621958ff96865c4d4372df127df64955b3c", "url": "https://github.com/splicemachine/spliceengine/commit/fd34e621958ff96865c4d4372df127df64955b3c", "message": "DB-10067 Minor fixes and refactoring", "committedDate": "2020-09-04T10:52:51Z", "type": "commit"}, {"oid": "1c4ea2761b286bbdaa5346af80dc30e02cadb4e7", "url": "https://github.com/splicemachine/spliceengine/commit/1c4ea2761b286bbdaa5346af80dc30e02cadb4e7", "message": "DB-10067 Fix SpotBugs", "committedDate": "2020-09-04T10:52:51Z", "type": "commit"}, {"oid": "f545ef8487d6dc38a6fee0cbaec4cbdf6a462d52", "url": "https://github.com/splicemachine/spliceengine/commit/f545ef8487d6dc38a6fee0cbaec4cbdf6a462d52", "message": "DB-10067 Store index expression texts", "committedDate": "2020-09-04T10:52:51Z", "type": "commit"}, {"oid": "8b05f19f6791362e89e86d1c8373f716d0d59d44", "url": "https://github.com/splicemachine/spliceengine/commit/8b05f19f6791362e89e86d1c8373f716d0d59d44", "message": "DB-10067 Support all built-in functions and BULK_IMPORT_HFILE", "committedDate": "2020-09-04T10:52:51Z", "type": "commit"}, {"oid": "766b2dc62a3771537195e32bc97cfc14a3a07cf0", "url": "https://github.com/splicemachine/spliceengine/commit/766b2dc62a3771537195e32bc97cfc14a3a07cf0", "message": "DB-10067 Fix SpotBugs", "committedDate": "2020-09-04T10:52:51Z", "type": "forcePushed"}, {"oid": "ef3513a43700774b7a2506d37bca1000a2613c2e", "url": "https://github.com/splicemachine/spliceengine/commit/ef3513a43700774b7a2506d37bca1000a2613c2e", "message": "DB-10067 Improve binding checks with DB2 compatible SQL state", "committedDate": "2020-09-04T12:21:16Z", "type": "commit"}, {"oid": "b76da920f3e5fc677051ffbb84efd35dce857473", "url": "https://github.com/splicemachine/spliceengine/commit/b76da920f3e5fc677051ffbb84efd35dce857473", "message": "DB-10067 Fix SpotBugs", "committedDate": "2020-09-04T12:21:23Z", "type": "commit"}, {"oid": "b76da920f3e5fc677051ffbb84efd35dce857473", "url": "https://github.com/splicemachine/spliceengine/commit/b76da920f3e5fc677051ffbb84efd35dce857473", "message": "DB-10067 Fix SpotBugs", "committedDate": "2020-09-04T12:21:23Z", "type": "forcePushed"}, {"oid": "d4011a991b3ad899eaa5d5ae4c55826f8bf3991f", "url": "https://github.com/splicemachine/spliceengine/commit/d4011a991b3ad899eaa5d5ae4c55826f8bf3991f", "message": "DB-10067 Fix indentation and alignment", "committedDate": "2020-09-04T13:19:50Z", "type": "commit"}, {"oid": "ac0f02afddf030665aa69ca7e147c16f5746fcef", "url": "https://github.com/splicemachine/spliceengine/commit/ac0f02afddf030665aa69ca7e147c16f5746fcef", "message": "DB-10067 Address Martin's comments.", "committedDate": "2020-09-04T14:12:57Z", "type": "commit"}, {"oid": "77192d13a6c92b3fe580f711c564899fae65884a", "url": "https://github.com/splicemachine/spliceengine/commit/77192d13a6c92b3fe580f711c564899fae65884a", "message": "DB-10067 Fix row decoding for evaluating index expressions on NULLs", "committedDate": "2020-09-09T13:47:13Z", "type": "commit"}, {"oid": "70721239b16a26556af7c5c311a5f4f0a949f448", "url": "https://github.com/splicemachine/spliceengine/commit/70721239b16a26556af7c5c311a5f4f0a949f448", "message": "DB-10067 Fix index expression text extraction", "committedDate": "2020-09-09T18:06:35Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk3NzE3MA==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r485977170", "bodyText": "We can get the formatId directly from ddd.getTypeId().getTypeFormatId(). There is no need to generate a Null value.", "author": "yxia92", "createdAt": "2020-09-09T23:31:38Z", "path": "splice_machine/src/main/java/com/splicemachine/protobuf/ProtoUtil.java", "diffHunk": "@@ -300,6 +305,19 @@ public static Index createIndex(long conglomerate, IndexDescriptor indexDescript\n         for(int i=0;i<backingArray.length;i++){\n             builder = builder.addIndexColsToMainColMap(backingArray[i]);\n         }\n+\n+        ByteArray[] bytecodeArray = indexDescriptor.getExprBytecode();\n+        for (ByteArray bc : bytecodeArray) {\n+            builder = builder.addBytecodeExprs(ByteString.copyFrom(bc.getArray(), bc.getOffset(), bc.getLength()));\n+        }\n+        String[] classNames = indexDescriptor.getGeneratedClassNames();\n+        for (String cn : classNames) {\n+            builder = builder.addGeneratedClassNames(cn);\n+        }\n+        DataTypeDescriptor[] indexColumnTypes = indexDescriptor.getIndexColumnTypes();\n+        for (DataTypeDescriptor dtd : indexColumnTypes) {\n+            builder = builder.addIndexColumnFormatIds(dtd.getNull().getTypeFormatId());", "originalCommit": "70721239b16a26556af7c5c311a5f4f0a949f448", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY5Nzg2NQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r486697865", "bodyText": "Bingo! Now I see it's really a trap for people. I was doing dtd.getTypeId().getTypeFormatId() at the beginning and then spent about half an hour debugging what's wrong.\nProblem is that getTypeFormatId() call from TypeId class returns something like BOOLEAN_TYPE_ID, CHAR_TYPE_ID, etc., while getTypeFormatId() call from a concrete SQL type class, say SQLBoolean, returns SQL_BOOLEAN_ID. Since we need to encode/decode concrete SQL values later, we have to get the latter format IDs. Otherwise it would complain something about no suitable serializer.\nFor normal index, the DDL message contains a list of all base column format IDs in the table message. There we call getFormatIds from TableDescriptor, which does type.getNull().getTypeFormatId(), too.", "author": "ascend1", "createdAt": "2020-09-11T00:02:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk3NzE3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODM5NjkwOQ==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r488396909", "bodyText": "I see, thanks for the explanation!", "author": "yxia92", "createdAt": "2020-09-15T05:36:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk3NzE3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk5NjQ2NA==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r485996464", "bodyText": "It seems more appropriate to put  generateExecutableIndexExpression() in makeConstantAction() at code generation phase.", "author": "yxia92", "createdAt": "2020-09-10T00:40:18Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/CreateIndexNode.java", "diffHunk": "@@ -140,170 +150,262 @@ public void init(\n         this.dateFormat = dateFormat != null ? ((CharConstantNode)dateFormat).getString() : null;\n         this.timeFormat = timeFormat != null ? ((CharConstantNode)timeFormat).getString() : null;\n         this.hfilePath = hfilePath != null ? ((CharConstantNode)hfilePath).getString() : null;\n-\t}\n-\n-\t/**\n-\t * Convert this object to a String.  See comments in QueryTreeNode.java\n-\t * for how this should be done for tree printing.\n-\t *\n-\t * @return\tThis object as a String\n-\t */\n-\n-\tpublic String toString()\n-\t{\n-\t\tif (SanityManager.DEBUG)\n-\t\t{\n-\t\t\treturn super.toString() +\n-\t\t\t\t\"unique: \" + unique + \"\\n\" +\n-\t\t\t\t\"indexType: \" + indexType + \"\\n\" +\n-\t\t\t\t\"indexName: \" + indexName + \"\\n\" +\n-\t\t\t\t\"tableName: \" + tableName + \"\\n\" +\n-\t\t\t\t\"properties: \" + properties + \"\\n\";\n-\t\t}\n-\t\telse\n-\t\t{\n-\t\t\treturn \"\";\n-\t\t}\n-\t}\n-\n-\tpublic String statementToString()\n-\t{\n-\t\treturn \"CREATE INDEX\";\n-\t}\n-\n-\n-\tpublic\tboolean\t\t\t\tgetUniqueness() { return unique; }\n-\tpublic\tString\t\t\t\tgetIndexType() { return indexType; }\n-\tpublic\tTableName\t\t\tgetIndexName() { return indexName; }\n-\tpublic\tUUID\t\t\t\tgetBoundTableID() { return td.getUUID(); }\n-    public\tProperties\t\t\tgetProperties() { return properties; }\n-\tpublic  TableName\t\t\tgetIndexTableName() {return tableName; }\n-\tpublic  String[]\t\t\tgetColumnNames() { return columnNames; }\n-\n-\t// get 1-based column ids\n-\tpublic\tint[]\t\t\t\tgetKeyColumnIDs() { return boundColumnIDs; }\n-\tpublic\tboolean[]\t\t\tgetIsAscending() { return isAscending; }\n-\n-\t// We inherit the generate() method from DDLStatementNode.\n-\n-\t/**\n-\t * Bind this CreateIndexNode.  This means doing any static error\n-\t * checking that can be done before actually creating the table.\n-\t * For example, verifying that the column name list does not\n-\t * contain any duplicate column names.\n-\t *\n-\t * @exception StandardException\t\tThrown on error\n-\t */\n-\n-\tpublic void bindStatement() throws StandardException\n-\t{\n-\t\tCompilerContext\t\t\tcc = getCompilerContext();\n-\t\tSchemaDescriptor\t\tsd;\n-\t\tint\t\t\t\t\t\tcolumnCount;\n-\n-\t\tsd = getSchemaDescriptor();\n-\n-\t\ttd = getTableDescriptor(tableName);\n-\n-\t\t//If total number of indexes on the table so far is more than 32767, then we need to throw an exception\n-/*\t\tif (td.getTotalNumberOfIndexes() > Limits.DB2_MAX_INDEXES_ON_TABLE)\n-\t\t{\n-\t\t\tthrow StandardException.newException(SQLState.LANG_TOO_MANY_INDEXES_ON_TABLE,\n-\t\t\t\tString.valueOf(td.getTotalNumberOfIndexes()),\n-\t\t\t\ttableName,\n-\t\t\t\tString.valueOf(Limits.DB2_MAX_INDEXES_ON_TABLE));\n-\t\t}\n+\n+        this.onExpression = isIndexOnExpression();\n+        int exprSize = this.onExpression ? this.expressionList.size() : 0;\n+        this.exprTexts = new String[exprSize];\n+        this.exprBytecode = new ByteArray[exprSize];\n+        this.generatedClassNames = new String[exprSize];\n+        this.indexColumnTypes = new DataTypeDescriptor[exprSize];\n+    }\n+\n+    /**\n+     * Convert this object to a String.  See comments in QueryTreeNode.java\n+     * for how this should be done for tree printing.\n+     *\n+     * @return    This object as a String\n+     */\n+\n+    public String toString()\n+    {\n+        if (SanityManager.DEBUG)\n+        {\n+            return super.toString() +\n+                \"unique: \" + unique + \"\\n\" +\n+                \"indexType: \" + indexType + \"\\n\" +\n+                \"indexName: \" + indexName + \"\\n\" +\n+                \"tableName: \" + tableName + \"\\n\" +\n+                \"properties: \" + properties + \"\\n\";\n+        }\n+        else\n+        {\n+            return \"\";\n+        }\n+    }\n+\n+    public String statementToString()\n+    {\n+        return \"CREATE INDEX\";\n+    }\n+\n+\n+    public  boolean     getUniqueness()     { return unique; }\n+    public  String      getIndexType()      { return indexType; }\n+    public  TableName   getIndexName()      { return indexName; }\n+    public  UUID        getBoundTableID()   { return td.getUUID(); }\n+    public  Properties  getProperties()     { return properties; }\n+    public  TableName   getIndexTableName() { return tableName; }\n+    public  String[]    getColumnNames()    { return involvedColumnNames; }\n+\n+    // get 1-based column ids\n+    public  int[]       getKeyColumnIDs()   { return boundColumnIDs; }\n+    public  boolean[]   getIsAscending()    { return isAscending; }\n+\n+    // We inherit the generate() method from DDLStatementNode.\n+\n+    /**\n+     * Bind this CreateIndexNode.  This means doing any static error\n+     * checking that can be done before actually creating the table.\n+     * For example, verifying that the column name list does not\n+     * contain any duplicate column names.\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n+\n+    public void bindStatement() throws StandardException\n+    {\n+        int columnCount;\n+        td = getTableDescriptor(tableName);\n+\n+        //If total number of indexes on the table so far is more than 32767, then we need to throw an exception\n+/*        if (td.getTotalNumberOfIndexes() > Limits.DB2_MAX_INDEXES_ON_TABLE)\n+        {\n+            throw StandardException.newException(SQLState.LANG_TOO_MANY_INDEXES_ON_TABLE,\n+                String.valueOf(td.getTotalNumberOfIndexes()),\n+                tableName,\n+                String.valueOf(Limits.DB2_MAX_INDEXES_ON_TABLE));\n+        }\n */\n-\t\t/* Validate the column name list */\n-\t\tverifyAndGetUniqueNames();\n-\n-\t\tcolumnCount = columnNames.length;\n-\t\tboundColumnIDs = new int[ columnCount ];\n-\n-\t\t// Verify that the columns exist\n-\t\tfor (int i = 0; i < columnCount; i++)\n-\t\t{\n-\t\t\tColumnDescriptor\t\t\tcolumnDescriptor;\n-\n-\t\t\tcolumnDescriptor = td.getColumnDescriptor(columnNames[i]);\n-\t\t\tif (columnDescriptor == null)\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE,\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcolumnNames[i],\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ttableName);\n-\t\t\t}\n-\t\t\tboundColumnIDs[ i ] = columnDescriptor.getPosition();\n-\t\t\t\n-\t\t\t// set this only once -- if just one column does is missing \"not null\" constraint in schema\n-\t\t\tuniqueWithDuplicateNulls = (! uniqueWithDuplicateNulls && (unique && ! columnDescriptor.hasNonNullDefault()));\n-\n-\t\t\t// Don't allow a column to be created on a non-orderable type\n-\t\t\tif ( ! columnDescriptor.getType().getTypeId().\n-\t\t\t\t\t\t\t\t\t\t\t\torderable(getClassFactory()))\n-\t\t\t{\n-\t\t\t\tthrow StandardException.newException(SQLState.LANG_COLUMN_NOT_ORDERABLE_DURING_EXECUTION,\n-\t\t\t\t\tcolumnDescriptor.getType().getTypeId().getSQLTypeName());\n-\t\t\t}\n-\t\t}\n-\n-\t\t/* Check for number of key columns to be less than 16 to match DB2 */\n-/*\t\tif (columnCount > 16)\n-\t\t\tthrow StandardException.newException(SQLState.LANG_TOO_MANY_INDEX_KEY_COLS);\n+        /* Validate the column name list */\n+        verifyAndGetUniqueNames();\n+\n+        columnCount = involvedColumnNames.length;\n+        boundColumnIDs = new int[ columnCount ];\n+\n+        // Verify that the columns exist\n+        for (int i = 0; i < columnCount; i++)\n+        {\n+            ColumnDescriptor columnDescriptor;\n+\n+            columnDescriptor = td.getColumnDescriptor(involvedColumnNames[i]);\n+            if (columnDescriptor == null)\n+            {\n+                throw StandardException.newException(SQLState.LANG_COLUMN_NOT_FOUND_IN_TABLE,\n+                        involvedColumnNames[i], tableName);\n+            }\n+            boundColumnIDs[ i ] = columnDescriptor.getPosition();\n+            \n+            // set this only once -- if just one column does is missing \"not null\" constraint in schema\n+            uniqueWithDuplicateNulls = (! uniqueWithDuplicateNulls && (unique && ! columnDescriptor.hasNonNullDefault()));\n+\n+            // Don't allow a column to be created on a non-orderable type\n+            if ( ! columnDescriptor.getType().getTypeId().orderable(getClassFactory()))\n+            {\n+                // Note that this exception is not SQL state 429BX, same as DB2 but not compatible.\n+                throw StandardException.newException(SQLState.LANG_COLUMN_NOT_ORDERABLE_DURING_EXECUTION,\n+                        columnDescriptor.getType().getTypeId().getSQLTypeName());\n+            }\n+        }\n+\n+        /* Check for number of key columns to be less than 16 to match DB2 */\n+/*        if (columnCount > 16)\n+            throw StandardException.newException(SQLState.LANG_TOO_MANY_INDEX_KEY_COLS);\n */\n-\t\t/* See if the index already exists in this schema.\n-\t\t * NOTE: We still need to check at execution time\n-\t\t * since the index name is only unique to the schema,\n-\t\t * not the table.\n-\t\t */\n-//  \t\tif (dd.getConglomerateDescriptor(indexName.getTableName(), sd, false) != null)\n-//  \t\t{\n-//  \t\t\tthrow StandardException.newException(SQLState.LANG_OBJECT_ALREADY_EXISTS_IN_OBJECT,\n-//  \t\t\t\t\t\t\t\t\t\t\t\t \"Index\",\n-//  \t\t\t\t\t\t\t\t\t\t\t\t indexName.getTableName(),\n-//  \t\t\t\t\t\t\t\t\t\t\t\t \"schema\",\n-//  \t\t\t\t\t\t\t\t\t\t\t\t sd.getSchemaName());\n-//  \t\t}\n-\n-\t\t/* Statement is dependent on the TableDescriptor */\n-\t\tgetCompilerContext().createDependency(td);\n-\n-\t}\n-\n-\t/**\n-\t * Return true if the node references SESSION schema tables (temporary or permanent)\n-\t *\n-\t * @return\ttrue if references SESSION schema tables, else false\n-\t *\n-\t * @exception StandardException\t\tThrown on error\n-\t */\n-\tpublic boolean referencesSessionSchema()\n-\t\tthrows StandardException\n-\t{\n-\t\t//If create index is on a SESSION schema table, then return true.\n-\t\treturn isSessionSchema(td.getSchemaName());\n-\t}\n-\n-\t/**\n-\t * Create the Constant information that will drive the guts of Execution.\n-\t *\n-\t * @exception StandardException\t\tThrown on failure\n-\t */\n-\tpublic ConstantAction\tmakeConstantAction() throws StandardException\n-\t{\n-\t\tSchemaDescriptor\t\tsd = getSchemaDescriptor();\n-\n-\t\tint columnCount = columnNames.length;\n-\t\tint approxLength = 0;\n-\t\tboolean index_has_long_column = false;\n-\n-\n-\t\t// bump the page size for the index,\n-\t\t// if the approximate sizes of the columns in the key are\n-\t\t// greater than the bump threshold.\n-\t\t// Ideally, we would want to have atleast 2 or 3 keys fit in one page\n-\t\t// With fix for beetle 5728, indexes on long types is not allowed\n-\t\t// so we do not have to consider key columns of long types\n-        for (String columnName : columnNames) {\n+        /* See if the index already exists in this schema.\n+         * NOTE: We still need to check at execution time\n+         * since the index name is only unique to the schema,\n+         * not the table.\n+         */\n+//          if (dd.getConglomerateDescriptor(indexName.getTableName(), sd, false) != null)\n+//          {\n+//              throw StandardException.newException(SQLState.LANG_OBJECT_ALREADY_EXISTS_IN_OBJECT,\n+//                                                   \"Index\",\n+//                                                   indexName.getTableName(),\n+//                                                   \"schema\",\n+//                                                   sd.getSchemaName());\n+//          }\n+\n+        if (onExpression) {\n+            bindIndexExpressions();\n+            generateExecutableIndexExpression();", "originalCommit": "70721239b16a26556af7c5c311a5f4f0a949f448", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjY5MTQxOA==", "url": "https://github.com/splicemachine/spliceengine/pull/4063#discussion_r486691418", "bodyText": "Right, that makes more sense. Fixed in new commit.", "author": "ascend1", "createdAt": "2020-09-10T23:39:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTk5NjQ2NA=="}], "type": "inlineReview"}, {"oid": "7cb0de09da8ac203f6c7ba34e9444264bcb27f4f", "url": "https://github.com/splicemachine/spliceengine/commit/7cb0de09da8ac203f6c7ba34e9444264bcb27f4f", "message": "DB-10067 Address Yi's comment", "committedDate": "2020-09-10T23:38:51Z", "type": "commit"}, {"oid": "e01d082d81ebf0bb515d5ba970ac7e8f816a9b1b", "url": "https://github.com/splicemachine/spliceengine/commit/e01d082d81ebf0bb515d5ba970ac7e8f816a9b1b", "message": "Merge branch 'master' into DB-10067", "committedDate": "2020-09-15T09:55:28Z", "type": "commit"}, {"oid": "eb2e95de783842fb59ba60bced86d8dbeefe88d6", "url": "https://github.com/splicemachine/spliceengine/commit/eb2e95de783842fb59ba60bced86d8dbeefe88d6", "message": "Merge branch 'master' into DB-10067", "committedDate": "2020-09-16T20:49:35Z", "type": "commit"}]}