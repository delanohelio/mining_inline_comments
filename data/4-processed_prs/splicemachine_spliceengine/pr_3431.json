{"pr_number": 3431, "pr_title": "DB-9363 Support all parms in TernaryOperator.{get/set}HashableColumnRef", "pr_createdAt": "2020-04-15T21:28:20Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/3431", "timeline": [{"oid": "774f9d5e68d19afb63c2c8b63bde126951999577", "url": "https://github.com/splicemachine/spliceengine/commit/774f9d5e68d19afb63c2c8b63bde126951999577", "message": "DB-9363 Support all parms in TernaryOperator.{get/set}HashableColumnRef", "committedDate": "2020-04-15T21:22:30Z", "type": "commit"}, {"oid": "6773832e3fedcf4b019118190eb2c807ed7e75e9", "url": "https://github.com/splicemachine/spliceengine/commit/6773832e3fedcf4b019118190eb2c807ed7e75e9", "message": "DB-9363 Fix spotbugs", "committedDate": "2020-04-15T21:22:30Z", "type": "commit"}, {"oid": "552b63058350528c00724db88e17153bcbea100a", "url": "https://github.com/splicemachine/spliceengine/commit/552b63058350528c00724db88e17153bcbea100a", "message": "DB-9363 Fix issue in switch", "committedDate": "2020-04-16T09:17:36Z", "type": "commit"}, {"oid": "b504b177ccd6892459180ff3cc8f69d889a7a3c1", "url": "https://github.com/splicemachine/spliceengine/commit/b504b177ccd6892459180ff3cc8f69d889a7a3c1", "message": "Merge remote-tracking branch 'origin/master' into DB-9363", "committedDate": "2020-04-16T13:35:14Z", "type": "commit"}, {"oid": "567bda307ee6cc75108c96357463410bb794b6e8", "url": "https://github.com/splicemachine/spliceengine/commit/567bda307ee6cc75108c96357463410bb794b6e8", "message": "DB-9363 Fix AddColumnWithDefaultIT", "committedDate": "2020-04-16T14:49:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI0MTIxMQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3431#discussion_r414241211", "bodyText": "Should we throw UnsupportedOperationException(\"Not Implemented\") to be consistent with node like CurrentDatetimeOperatorNode?", "author": "yxia92", "createdAt": "2020-04-24T02:09:58Z", "path": "db-engine/src/main/java/com/splicemachine/db/impl/sql/compile/GetCurrentConnectionNode.java", "diffHunk": "@@ -58,151 +59,166 @@\n \n public final class GetCurrentConnectionNode extends JavaValueNode\n {\n-\t/**\n-\t * Constructor for a GetCurrentConnectionNode\n-\t *\n-\t */\n-\n-\tpublic GetCurrentConnectionNode()\n-\t{\n-\t\t/*\n-\t\t** The result type of getCurrentConnection is\n-\t\t** java.sql.Connection\n-\t\t*/\n-\n-\t\tsetJavaTypeName(\"java.sql.Connection\");\n-\t}\n-\n-\t/**\n-\t * Bind this operator\n-\t *\n-\t * @param fromList            The query's FROM list\n-\t * @param subqueryList        The subquery list being built as we find SubqueryNodes\n-\t * @param aggregateVector    The aggregate vector being built as we find AggregateNodes\n-\t *\n-\t * @exception StandardException\t\tThrown on error\n-\t */\n+    /**\n+     * Constructor for a GetCurrentConnectionNode\n+     *\n+     */\n+\n+    public GetCurrentConnectionNode()\n+    {\n+        /*\n+        ** The result type of getCurrentConnection is\n+        ** java.sql.Connection\n+        */\n+\n+        setJavaTypeName(\"java.sql.Connection\");\n+    }\n+\n+    /**\n+     * Bind this operator\n+     *\n+     * @param fromList            The query's FROM list\n+     * @param subqueryList        The subquery list being built as we find SubqueryNodes\n+     * @param aggregateVector    The aggregate vector being built as we find AggregateNodes\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n     @Override\n-\tpublic JavaValueNode bindExpression(FromList fromList,\n+    public JavaValueNode bindExpression(FromList fromList,\n                                         SubqueryList subqueryList,\n                                         List<AggregateNode> aggregateVector) throws StandardException {\n-\t\treturn this;\n-\t}\n-\n-\t/**\n-\t * Preprocess an expression tree.  We do a number of transformations\n-\t * here (including subqueries, IN lists, LIKE and BETWEEN) plus\n-\t * subquery flattening.\n-\t * NOTE: This is done before the outer ResultSetNode is preprocessed.\n-\t *\n-\t * @param\tnumTables\t\t\tNumber of tables in the DML Statement\n-\t * @param\touterFromList\t\tFromList from outer query block\n-\t * @param\touterSubqueryList\tSubqueryList from outer query block\n-\t * @param\touterPredicateList\tPredicateList from outer query block\n-\t *\n-\t * @exception StandardException\t\tThrown on error\n-\t */\n-\tpublic void preprocess(int numTables,\n-\t\t\t\t\t\t\t\tFromList outerFromList,\n-\t\t\t\t\t\t\t\tSubqueryList outerSubqueryList,\n-\t\t\t\t\t\t\t\tPredicateList outerPredicateList) \n-\t\t\t\t\tthrows StandardException\n-\t{\n-\t}\n-\n-\t/**\n-\t * Categorize this predicate.  Initially, this means\n-\t * building a bit map of the referenced tables for each predicate.\n-\t * If the source of this ColumnReference (at the next underlying level)\n-\t * is not a ColumnReference or a VirtualColumnNode then this predicate\n-\t * will not be pushed down.\n-\t *\n-\t * For example, in:\n-\t *\t\tselect * from (select 1 from s) a (x) where x = 1\n-\t * we will not push down x = 1.\n-\t * NOTE: It would be easy to handle the case of a constant, but if the\n-\t * inner SELECT returns an arbitrary expression, then we would have to copy\n-\t * that tree into the pushed predicate, and that tree could contain\n-\t * subqueries and method calls.\n-\t * RESOLVE - revisit this issue once we have views.\n-\t *\n-\t * @param referencedTabs\tJBitSet with bit map of referenced FromTables\n-\t * @param simplePredsOnly\tWhether or not to consider method\n-\t *\t\t\t\t\t\t\tcalls, field references and conditional nodes\n-\t *\t\t\t\t\t\t\twhen building bit map\n-\t *\n-\t * @return boolean\t\tWhether or not source.expression is a ColumnReference\n-\t *\t\t\t\t\t\tor a VirtualColumnNode.\n-\t */\n-\tpublic boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)\n-\t{\n-\t\treturn false;\n-\t}\n-\n-\t/**\n-\t * Remap all ColumnReferences in this tree to be clones of the\n-\t * underlying expression.\n-\t *\n-\t * @return JavaValueNode\t\t\tThe remapped expression tree.\n-\t *\n-\t */\n-\tpublic JavaValueNode remapColumnReferencesToExpressions()\n-\t{\n-\t\treturn this;\n-\t}\n-\n-\t/**\n-\t * Bind a ? parameter operand of the char_length function.\n-\t */\n-\n-\tvoid bindParameter()\n-\t{\n-\t}\n-\n-\t/**\n-\t * Return the variant type for the underlying expression.\n-\t * The variant type can be:\n-\t *\t\tVARIANT\t\t\t\t- variant within a scan\n-\t *\t\t\t\t\t\t\t  (method calls and non-static field access)\n-\t *\t\tSCAN_INVARIANT\t\t- invariant within a scan\n-\t *\t\t\t\t\t\t\t  (column references from outer tables)\n-\t *\t\tQUERY_INVARIANT\t\t- invariant within the life of a query\n-\t *\t\t\t\t\t\t\t  (constant expressions)\n-\t *\n-\t * @return\tThe variant type for the underlying expression.\n-\t */\n-\tprotected int getOrderableVariantType()\n-\t{\n-\t\treturn Qualifier.QUERY_INVARIANT;\n-\t}\n-\t/**\n-\t *\n-\t * @see ConstantNode#generateExpression\n-\t *\n-\t * @param acb\tThe ExpressionClassBuilder for the class being built\n-\t * @param mb\tThe method the code to place the code\n-\t *\n-\t * @exception StandardException\t\tThrown on error\n-\t */\n-\tpublic void generateExpression(ExpressionClassBuilder acb,\n-\t\t\t\t\t\t\t\t\t\t\tMethodBuilder mb)\n-\t\t\t\t\t\t\t\t\tthrows StandardException\n-\t{\n-\t\tmb.pushThis();\n-\t\tmb.callMethod(VMOpcode.INVOKEVIRTUAL, ClassName.BaseActivation, \"getCurrentConnection\", getJavaTypeName(), 0);\n-\t}\n-\n-\t/**\n-\t\tCheck the reliability type of this java value.\n-\n-\t    @exception StandardException\t\tThrown on error\n-\n-\t\t@see com.splicemachine.db.iapi.sql.compile.CompilerContext\n-\t*/\n-\tpublic void checkReliability(ValueNode sqlNode)\n-\t\tthrows StandardException {\n-\t\tsqlNode.checkReliability(\"getCurrentConnection()\",\n-\t\t\tCompilerContext.CURRENT_CONNECTION_ILLEGAL);\n-\t}\n+        return this;\n+    }\n+\n+    /**\n+     * Preprocess an expression tree.  We do a number of transformations\n+     * here (including subqueries, IN lists, LIKE and BETWEEN) plus\n+     * subquery flattening.\n+     * NOTE: This is done before the outer ResultSetNode is preprocessed.\n+     *\n+     * @param    numTables            Number of tables in the DML Statement\n+     * @param    outerFromList        FromList from outer query block\n+     * @param    outerSubqueryList    SubqueryList from outer query block\n+     * @param    outerPredicateList    PredicateList from outer query block\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n+    public void preprocess(int numTables,\n+                                FromList outerFromList,\n+                                SubqueryList outerSubqueryList,\n+                                PredicateList outerPredicateList)\n+                    throws StandardException\n+    {\n+    }\n+\n+    /**\n+     * Categorize this predicate.  Initially, this means\n+     * building a bit map of the referenced tables for each predicate.\n+     * If the source of this ColumnReference (at the next underlying level)\n+     * is not a ColumnReference or a VirtualColumnNode then this predicate\n+     * will not be pushed down.\n+     *\n+     * For example, in:\n+     *        select * from (select 1 from s) a (x) where x = 1\n+     * we will not push down x = 1.\n+     * NOTE: It would be easy to handle the case of a constant, but if the\n+     * inner SELECT returns an arbitrary expression, then we would have to copy\n+     * that tree into the pushed predicate, and that tree could contain\n+     * subqueries and method calls.\n+     * RESOLVE - revisit this issue once we have views.\n+     *\n+     * @param referencedTabs    JBitSet with bit map of referenced FromTables\n+     * @param simplePredsOnly    Whether or not to consider method\n+     *                            calls, field references and conditional nodes\n+     *                            when building bit map\n+     *\n+     * @return boolean        Whether or not source.expression is a ColumnReference\n+     *                        or a VirtualColumnNode.\n+     */\n+    public boolean categorize(JBitSet referencedTabs, boolean simplePredsOnly)\n+    {\n+        return false;\n+    }\n+\n+    /**\n+     * Remap all ColumnReferences in this tree to be clones of the\n+     * underlying expression.\n+     *\n+     * @return JavaValueNode            The remapped expression tree.\n+     *\n+     */\n+    public JavaValueNode remapColumnReferencesToExpressions()\n+    {\n+        return this;\n+    }\n+\n+    /**\n+     * Bind a ? parameter operand of the char_length function.\n+     */\n+\n+    void bindParameter()\n+    {\n+    }\n+\n+    /**\n+     * Return the variant type for the underlying expression.\n+     * The variant type can be:\n+     *        VARIANT                - variant within a scan\n+     *                              (method calls and non-static field access)\n+     *        SCAN_INVARIANT        - invariant within a scan\n+     *                              (column references from outer tables)\n+     *        QUERY_INVARIANT        - invariant within the life of a query\n+     *                              (constant expressions)\n+     *\n+     * @return    The variant type for the underlying expression.\n+     */\n+    protected int getOrderableVariantType()\n+    {\n+        return Qualifier.QUERY_INVARIANT;\n+    }\n+    /**\n+     *\n+     * @see ConstantNode#generateExpression\n+     *\n+     * @param acb    The ExpressionClassBuilder for the class being built\n+     * @param mb    The method the code to place the code\n+     *\n+     * @exception StandardException        Thrown on error\n+     */\n+    public void generateExpression(ExpressionClassBuilder acb,\n+                                            MethodBuilder mb)\n+                                    throws StandardException\n+    {\n+        mb.pushThis();\n+        mb.callMethod(VMOpcode.INVOKEVIRTUAL, ClassName.BaseActivation, \"getCurrentConnection\", getJavaTypeName(), 0);\n+    }\n+\n+    /**\n+        Check the reliability type of this java value.\n+\n+        @exception StandardException        Thrown on error\n+\n+        @see com.splicemachine.db.iapi.sql.compile.CompilerContext\n+    */\n+    public void checkReliability(ValueNode sqlNode)\n+        throws StandardException {\n+        sqlNode.checkReliability(\"getCurrentConnection()\",\n+            CompilerContext.CURRENT_CONNECTION_ILLEGAL);\n+    }\n \n+    @Override\n+    public List<? extends QueryTreeNode> getChildren() {\n+        return Collections.EMPTY_LIST;\n+    }\n+\n+    @Override\n+    public QueryTreeNode getChild(int index) {\n+        assert false;", "originalCommit": "567bda307ee6cc75108c96357463410bb794b6e8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzUxMjUyMA==", "url": "https://github.com/splicemachine/spliceengine/pull/3431#discussion_r417512520", "bodyText": "Done", "author": "arnaud-splice", "createdAt": "2020-04-29T18:09:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDI0MTIxMQ=="}], "type": "inlineReview"}, {"oid": "f016ed2dacb2ef42572e78753f1c3ab1d73c6251", "url": "https://github.com/splicemachine/spliceengine/commit/f016ed2dacb2ef42572e78753f1c3ab1d73c6251", "message": "DB-9363 Replace assert with throw unsupported", "committedDate": "2020-04-29T18:09:08Z", "type": "forcePushed"}, {"oid": "31c14cf6c41804d70407ea66fcfdf460da8264fd", "url": "https://github.com/splicemachine/spliceengine/commit/31c14cf6c41804d70407ea66fcfdf460da8264fd", "message": "Merge remote-tracking branch 'origin/master' into DB-9363", "committedDate": "2020-04-29T18:14:14Z", "type": "commit"}, {"oid": "bcae7a649a087ed71c82065e1509835f09a28db6", "url": "https://github.com/splicemachine/spliceengine/commit/bcae7a649a087ed71c82065e1509835f09a28db6", "message": "DB-9363 Replace assert with throw unsupported", "committedDate": "2020-04-29T18:14:33Z", "type": "commit"}, {"oid": "bcae7a649a087ed71c82065e1509835f09a28db6", "url": "https://github.com/splicemachine/spliceengine/commit/bcae7a649a087ed71c82065e1509835f09a28db6", "message": "DB-9363 Replace assert with throw unsupported", "committedDate": "2020-04-29T18:14:33Z", "type": "forcePushed"}]}