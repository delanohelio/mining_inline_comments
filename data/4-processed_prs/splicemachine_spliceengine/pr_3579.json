{"pr_number": 3579, "pr_title": "DB-9562 NSDS Update and Delete should handle Partial Rows and Empty Inputs", "pr_createdAt": "2020-05-16T19:30:23Z", "pr_url": "https://github.com/splicemachine/spliceengine/pull/3579", "timeline": [{"oid": "5bb04d980f4655e8b09171a73699d5323c7538cb", "url": "https://github.com/splicemachine/spliceengine/commit/5bb04d980f4655e8b09171a73699d5323c7538cb", "message": "DB-9562 NSDS update and delete handling partial rows and empty input.", "committedDate": "2020-05-16T19:02:39Z", "type": "commit"}, {"oid": "ddbaba3dbdf08968331698b3da204ba7f7a88ad5", "url": "https://github.com/splicemachine/spliceengine/commit/ddbaba3dbdf08968331698b3da204ba7f7a88ad5", "message": "DB-9562 Increased timeout in SparkStreamingIT.", "committedDate": "2020-05-16T19:03:47Z", "type": "commit"}, {"oid": "4fb6bba4383b516ac84cc260fae0565971d64dd8", "url": "https://github.com/splicemachine/spliceengine/commit/4fb6bba4383b516ac84cc260fae0565971d64dd8", "message": "Fix Spotbugs.", "committedDate": "2020-05-18T03:22:08Z", "type": "commit"}, {"oid": "12bad63aaa86c6286c8b5bee849482c4807d4904", "url": "https://github.com/splicemachine/spliceengine/commit/12bad63aaa86c6286c8b5bee849482c4807d4904", "message": "DB-9562 Fix Spotbugs.", "committedDate": "2020-05-18T04:14:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5ODIzOA==", "url": "https://github.com/splicemachine/spliceengine/pull/3579#discussion_r427598238", "bodyText": "What fields was it complaining about?", "author": "dgomezferro", "createdAt": "2020-05-19T21:02:51Z", "path": "splice_spark/src/main/spark2.1/com/splicemachine/spark/splicemachine/SplicemachineContext.scala", "diffHunk": "@@ -39,10 +39,16 @@ import org.apache.hadoop.hbase.util.Bytes\n import org.apache.log4j.Logger\n import org.apache.spark.api.java.JavaRDD\n import org.apache.spark.scheduler.{SparkListener, SparkListenerApplicationEnd}\n+import edu.umd.cs.findbugs.annotations.SuppressFBWarnings\n \n+@SerialVersionUID(20200513211L)\n object Holder extends Serializable {\n   @transient lazy val log = Logger.getLogger(getClass.getName)\n }\n+@SerialVersionUID(20200513212L)\n+@SuppressFBWarnings(value = Array(\"ST_WRITE_TO_STATIC_FROM_INSTANCE_METHOD\"), justification = \"Need to set SpliceClient.connectionString\")\n+@SuppressFBWarnings(value = Array(\"NP_ALWAYS_NULL\"), justification = \"These fields usually are not null\")", "originalCommit": "12bad63aaa86c6286c8b5bee849482c4807d4904", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczMDk5Nw==", "url": "https://github.com/splicemachine/spliceengine/pull/3579#discussion_r427730997", "bodyText": "Wrote https://splicemachine.atlassian.net/browse/DB-9580 and listed the issues in the jira.", "author": "jpanko1", "createdAt": "2020-05-20T04:13:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU5ODIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwMTk4Ng==", "url": "https://github.com/splicemachine/spliceengine/pull/3579#discussion_r427601986", "bodyText": "Does this work for quoted columns?\ncreate table a (\"notEQUAL\" int, \"NOTequal\" int);", "author": "dgomezferro", "createdAt": "2020-05-19T21:10:36Z", "path": "splice_spark2/src/main/spark2.2/com/splicemachine/spark2/splicemachine/SplicemachineContext.scala", "diffHunk": "@@ -595,11 +595,13 @@ class SplicemachineContext(options: Map[String, String]) extends Serializable {\n     )\n   \n   /** Schema string built from JDBC metadata. */\n-  def schemaString(schemaTableName: String): String =\n+  def schemaString(schemaTableName: String, schema: StructType = new StructType()): String =\n     SpliceJDBCUtil.retrieveColumnInfo(\n       new JDBCOptions(Map(\n         JDBCOptions.JDBC_URL -> url,\n         JDBCOptions.JDBC_TABLE_NAME -> schemaTableName))\n+    ).filter(\n+      col => schema.isEmpty || schema.exists( field => field.name.toUpperCase.equals( col(0).toUpperCase ) )", "originalCommit": "5bb04d980f4655e8b09171a73699d5323c7538cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYyNzEzNQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3579#discussion_r427627135", "bodyText": "Verified now that it works for unquoted columns but not quoted columns.  I\u2019ll file a jira.", "author": "jpanko1", "createdAt": "2020-05-19T22:04:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwMTk4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczMTIwMg==", "url": "https://github.com/splicemachine/spliceengine/pull/3579#discussion_r427731202", "bodyText": "Wrote https://splicemachine.atlassian.net/browse/DB-9581", "author": "jpanko1", "createdAt": "2020-05-20T04:14:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwMTk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwMjUxNQ==", "url": "https://github.com/splicemachine/spliceengine/pull/3579#discussion_r427602515", "bodyText": "This could force a computation of the RDD, ideally we'd want to make sure the RDD is only computed once.\nWhat's the error if the RDD is empty?", "author": "dgomezferro", "createdAt": "2020-05-19T21:11:30Z", "path": "splice_spark2/src/main/spark2.2/com/splicemachine/spark2/splicemachine/SplicemachineContext.scala", "diffHunk": "@@ -577,7 +577,7 @@ class SplicemachineContext(options: Map[String, String]) extends Serializable {\n    * @param schema\n    * @param schemaTableName table to delete from\n    */\n-  def delete(rdd: JavaRDD[Row], schema: StructType, schemaTableName: String): Unit = {\n+  def delete(rdd: JavaRDD[Row], schema: StructType, schemaTableName: String): Unit = if( !rdd.isEmpty ) {", "originalCommit": "5bb04d980f4655e8b09171a73699d5323c7538cb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY1MzMxNg==", "url": "https://github.com/splicemachine/spliceengine/pull/3579#discussion_r427653316", "bodyText": "The delete function (and it's the same for update) calls modifyOnKeys() which passes the rdd to sendData() which would put the data into Kafka, if there was data.  But in this case sendData() returns after having no data to pass, and then the sql is created and it hangs at\nstatement.executeUpdate(sql).  The code in the DB is probably polling Kafka when no data was put on the topic.  It looks like KafkaReadFunction would go into an infinite loop polling Kafka:\n                    ConsumerRecords<Integer, Externalizable> records = null;\n                    while (records == null || records.isEmpty()) {\n                        records = consumer.poll( java.time.Duration.ofMillis(1000) );\n                        if (TaskContext.get().isInterrupted()) {\n                            consumer.close();\n                            throw new TaskKilledException();\n                        }\n                    }", "author": "jpanko1", "createdAt": "2020-05-19T23:18:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzYwMjUxNQ=="}], "type": "inlineReview"}]}