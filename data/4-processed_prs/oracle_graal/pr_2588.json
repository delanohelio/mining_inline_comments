{"pr_number": 2588, "pr_title": "Add intrinsics for floating point Math.min/Math.max on AArch64", "pr_createdAt": "2020-06-19T13:16:03Z", "pr_url": "https://github.com/oracle/graal/pull/2588", "timeline": [{"oid": "d1267fbd41fcbee180c66cd5b2760659764046f3", "url": "https://github.com/oracle/graal/commit/d1267fbd41fcbee180c66cd5b2760659764046f3", "message": "Add intrinsics for floating point Math.min/Math.max on AArch64\n\nEmit \"fmin/fmax\" instructions when Math.min()/Math.max() function is\ncalled with single or double precision floating point values on AArch64.\nThe existing mechanism emits cmp+csel combination for the integer\nvariants of Math.min()/Math.max().\n\nChange-Id: Ic3b9de4aa096a8af699cfe5d0f0b8c83ca86b208", "committedDate": "2020-07-03T12:37:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1MjIwNA==", "url": "https://github.com/oracle/graal/pull/2588#discussion_r467152204", "bodyText": "Since Max/Min are associative, I believe also hooks for them must be added into BinaryArithmeticNode.reassociate", "author": "teshull", "createdAt": "2020-08-07T16:44:18Z", "path": "compiler/src/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/type/FloatStamp.java", "diffHunk": "@@ -910,6 +910,76 @@ public Stamp foldStamp(Stamp s) {\n \n                     null, null, null,\n \n+                    new BinaryOp.Max(true, true) {", "originalCommit": "d1267fbd41fcbee180c66cd5b2760659764046f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIxNTQwOQ==", "url": "https://github.com/oracle/graal/pull/2588#discussion_r477215409", "bodyText": "Done!", "author": "SwapnilGaikwad", "createdAt": "2020-08-26T11:01:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE1MjIwNA=="}], "type": "inlineReview"}, {"oid": "73342c8c948fde7d48fc4b77af4923d06bd055de", "url": "https://github.com/oracle/graal/commit/73342c8c948fde7d48fc4b77af4923d06bd055de", "message": "Add intrinsics for floating point Math.min/Math.max on AArch64\n\nEmit \"fmin/fmax\" instructions when Math.min()/Math.max() function is\ncalled with single or double precision floating point values on AArch64.\nThe existing mechanism emits cmp+csel combination for the integer\nvariants of Math.min()/Math.max().\n\nChange-Id: Ic3b9de4aa096a8af699cfe5d0f0b8c83ca86b208", "committedDate": "2020-08-26T10:57:12Z", "type": "forcePushed"}, {"oid": "0112744b46bad63e756876dfc1c469e72ee81bfe", "url": "https://github.com/oracle/graal/commit/0112744b46bad63e756876dfc1c469e72ee81bfe", "message": "Add intrinsics for floating point Math.min/Math.max on AArch64\n\nEmit \"fmin/fmax\" instructions when Math.min()/Math.max() function is\ncalled with single or double precision floating point values on AArch64.\nThe existing mechanism emits cmp+csel combination for the integer\nvariants of Math.min()/Math.max().\n\nChange-Id: Ic3b9de4aa096a8af699cfe5d0f0b8c83ca86b208", "committedDate": "2020-08-27T15:55:15Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMTI1NA==", "url": "https://github.com/oracle/graal/pull/2588#discussion_r490411254", "bodyText": "Can you tighten the bounds of the returned stamp? Since this is a max operation, we know the lower bound will be max(stamp1.lowerBound(), stamp2.lowerBound()) and the upper bound likewise will be the max of the two stamps' upper bounds.", "author": "teshull", "createdAt": "2020-09-17T16:49:07Z", "path": "compiler/src/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/type/FloatStamp.java", "diffHunk": "@@ -910,6 +910,76 @@ public Stamp foldStamp(Stamp s) {\n \n                     null, null, null,\n \n+                    new BinaryOp.Max(true, true) {\n+\n+                        @Override\n+                        public Constant foldConstant(Constant const1, Constant const2) {\n+                            PrimitiveConstant a = (PrimitiveConstant) const1;\n+                            PrimitiveConstant b = (PrimitiveConstant) const2;\n+                            assert a.getJavaKind() == b.getJavaKind();\n+                            switch (a.getJavaKind()) {\n+                                case Float:\n+                                    return JavaConstant.forFloat(Math.max(a.asFloat(), b.asFloat()));\n+                                case Double:\n+                                    return JavaConstant.forDouble(Math.max(a.asDouble(), b.asDouble()));\n+                                default:\n+                                    throw GraalError.shouldNotReachHere();\n+                            }\n+                        }\n+\n+                        @Override\n+                        public Stamp foldStamp(Stamp s1, Stamp s2) {\n+                            if (s1.isEmpty()) {\n+                                return s1;\n+                            }\n+                            if (s2.isEmpty()) {\n+                                return s2;\n+                            }\n+                            FloatStamp stamp1 = (FloatStamp) s1;\n+                            FloatStamp stamp2 = (FloatStamp) s2;\n+                            Stamp folded = maybeFoldConstant(this, stamp1, stamp2);\n+                            if (folded != null) {\n+                                return folded;\n+                            }\n+                            return stamp1.unrestricted();", "originalCommit": "0112744b46bad63e756876dfc1c469e72ee81bfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM0MTI3MQ==", "url": "https://github.com/oracle/graal/pull/2588#discussion_r497341271", "bodyText": "Done!", "author": "SwapnilGaikwad", "createdAt": "2020-09-30T08:41:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMTI1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMTc2OQ==", "url": "https://github.com/oracle/graal/pull/2588#discussion_r490411769", "bodyText": "Same thing as the comment above, except this time the upper/lower bounds would be the min of the two stamps' respective values", "author": "teshull", "createdAt": "2020-09-17T16:49:56Z", "path": "compiler/src/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/type/FloatStamp.java", "diffHunk": "@@ -910,6 +910,76 @@ public Stamp foldStamp(Stamp s) {\n \n                     null, null, null,\n \n+                    new BinaryOp.Max(true, true) {\n+\n+                        @Override\n+                        public Constant foldConstant(Constant const1, Constant const2) {\n+                            PrimitiveConstant a = (PrimitiveConstant) const1;\n+                            PrimitiveConstant b = (PrimitiveConstant) const2;\n+                            assert a.getJavaKind() == b.getJavaKind();\n+                            switch (a.getJavaKind()) {\n+                                case Float:\n+                                    return JavaConstant.forFloat(Math.max(a.asFloat(), b.asFloat()));\n+                                case Double:\n+                                    return JavaConstant.forDouble(Math.max(a.asDouble(), b.asDouble()));\n+                                default:\n+                                    throw GraalError.shouldNotReachHere();\n+                            }\n+                        }\n+\n+                        @Override\n+                        public Stamp foldStamp(Stamp s1, Stamp s2) {\n+                            if (s1.isEmpty()) {\n+                                return s1;\n+                            }\n+                            if (s2.isEmpty()) {\n+                                return s2;\n+                            }\n+                            FloatStamp stamp1 = (FloatStamp) s1;\n+                            FloatStamp stamp2 = (FloatStamp) s2;\n+                            Stamp folded = maybeFoldConstant(this, stamp1, stamp2);\n+                            if (folded != null) {\n+                                return folded;\n+                            }\n+                            return stamp1.unrestricted();\n+                        }\n+                    },\n+\n+                    new BinaryOp.Min(true, true) {\n+\n+                        @Override\n+                        public Constant foldConstant(Constant const1, Constant const2) {\n+                            PrimitiveConstant a = (PrimitiveConstant) const1;\n+                            PrimitiveConstant b = (PrimitiveConstant) const2;\n+                            assert a.getJavaKind() == b.getJavaKind();\n+                            switch (a.getJavaKind()) {\n+                                case Float:\n+                                    return JavaConstant.forFloat(Math.min(a.asFloat(), b.asFloat()));\n+                                case Double:\n+                                    return JavaConstant.forDouble(Math.min(a.asDouble(), b.asDouble()));\n+                                default:\n+                                    throw GraalError.shouldNotReachHere();\n+                            }\n+                        }\n+\n+                        @Override\n+                        public Stamp foldStamp(Stamp s1, Stamp s2) {\n+                            if (s1.isEmpty()) {\n+                                return s1;\n+                            }\n+                            if (s2.isEmpty()) {\n+                                return s2;\n+                            }\n+                            FloatStamp stamp1 = (FloatStamp) s1;\n+                            FloatStamp stamp2 = (FloatStamp) s2;\n+                            Stamp folded = maybeFoldConstant(this, stamp1, stamp2);\n+                            if (folded != null) {\n+                                return folded;\n+                            }\n+                            return stamp1.unrestricted();", "originalCommit": "0112744b46bad63e756876dfc1c469e72ee81bfe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMjQ5MQ==", "url": "https://github.com/oracle/graal/pull/2588#discussion_r490412491", "bodyText": "Can you create a shared abstract superclass for the Max and Min nodes, called MinMaxNode, and lift the common logic into this class?", "author": "teshull", "createdAt": "2020-09-17T16:51:09Z", "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/MaxNode.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.nodes.calc;\n+\n+import org.graalvm.compiler.core.common.type.ArithmeticOpTable;\n+import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp;\n+import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp.Max;\n+import org.graalvm.compiler.core.common.type.Stamp;\n+import org.graalvm.compiler.graph.NodeClass;\n+import org.graalvm.compiler.graph.spi.Canonicalizable.BinaryCommutative;\n+import org.graalvm.compiler.graph.spi.CanonicalizerTool;\n+import org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool;\n+import org.graalvm.compiler.nodeinfo.NodeInfo;\n+import org.graalvm.compiler.nodes.ConstantNode;\n+import org.graalvm.compiler.nodes.NodeView;\n+import org.graalvm.compiler.nodes.ValueNode;\n+import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;\n+\n+import jdk.vm.ci.meta.Value;\n+\n+@NodeInfo(shortName = \"MAX\")\n+public class MaxNode extends BinaryArithmeticNode<Max> implements NarrowableArithmeticNode, BinaryCommutative<ValueNode> {", "originalCommit": "0112744b46bad63e756876dfc1c469e72ee81bfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM0MjMzMw==", "url": "https://github.com/oracle/graal/pull/2588#discussion_r497342333", "bodyText": "Done, added MinMaxNode.java", "author": "SwapnilGaikwad", "createdAt": "2020-09-30T08:43:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMjQ5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMzM0NA==", "url": "https://github.com/oracle/graal/pull/2588#discussion_r490413344", "bodyText": "Can you add the assert assert stamp instanceof FloatStamp?", "author": "teshull", "createdAt": "2020-09-17T16:52:32Z", "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/MaxNode.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.nodes.calc;\n+\n+import org.graalvm.compiler.core.common.type.ArithmeticOpTable;\n+import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp;\n+import org.graalvm.compiler.core.common.type.ArithmeticOpTable.BinaryOp.Max;\n+import org.graalvm.compiler.core.common.type.Stamp;\n+import org.graalvm.compiler.graph.NodeClass;\n+import org.graalvm.compiler.graph.spi.Canonicalizable.BinaryCommutative;\n+import org.graalvm.compiler.graph.spi.CanonicalizerTool;\n+import org.graalvm.compiler.lir.gen.ArithmeticLIRGeneratorTool;\n+import org.graalvm.compiler.nodeinfo.NodeInfo;\n+import org.graalvm.compiler.nodes.ConstantNode;\n+import org.graalvm.compiler.nodes.NodeView;\n+import org.graalvm.compiler.nodes.ValueNode;\n+import org.graalvm.compiler.nodes.spi.NodeLIRBuilderTool;\n+\n+import jdk.vm.ci.meta.Value;\n+\n+@NodeInfo(shortName = \"MAX\")\n+public class MaxNode extends BinaryArithmeticNode<Max> implements NarrowableArithmeticNode, BinaryCommutative<ValueNode> {\n+\n+    public static final NodeClass<MaxNode> TYPE = NodeClass.create(MaxNode.class);\n+\n+    public MaxNode(ValueNode x, ValueNode y) {\n+        super(TYPE, getArithmeticOpTable(x).getMax(), x, y);\n+    }\n+\n+    @Override\n+    protected BinaryOp<Max> getOp(ArithmeticOpTable table) {\n+        return table.getMax();\n+    }\n+\n+    public static ValueNode create(ValueNode x, ValueNode y, NodeView view) {\n+        BinaryOp<Max> op = ArithmeticOpTable.forStamp(x.stamp(view)).getMax();\n+        Stamp stamp = op.foldStamp(x.stamp(view), y.stamp(view));", "originalCommit": "0112744b46bad63e756876dfc1c469e72ee81bfe", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzM0MjU4Ng==", "url": "https://github.com/oracle/graal/pull/2588#discussion_r497342586", "bodyText": "Done!", "author": "SwapnilGaikwad", "createdAt": "2020-09-30T08:43:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQxMzM0NA=="}], "type": "inlineReview"}, {"oid": "32f8ee8c7d3840861e269a278037c3a0849a5f7b", "url": "https://github.com/oracle/graal/commit/32f8ee8c7d3840861e269a278037c3a0849a5f7b", "message": "Add intrinsics for floating point Math.min/Math.max on AArch64\n\nEmit \"fmin/fmax\" instructions when Math.min()/Math.max() function is\ncalled with single or double precision floating point values on AArch64.\nThe existing mechanism emits cmp+csel combination for the integer\nvariants of Math.min()/Math.max().\n\nChange-Id: Ic3b9de4aa096a8af699cfe5d0f0b8c83ca86b208", "committedDate": "2020-09-30T08:37:27Z", "type": "forcePushed"}, {"oid": "ec3fb4041b4e2304b94b7bdfb7ab1eb0132777e5", "url": "https://github.com/oracle/graal/commit/ec3fb4041b4e2304b94b7bdfb7ab1eb0132777e5", "message": "Add intrinsics for floating point Math.min/Math.max on AArch64\n\nEmit \"fmin/fmax\" instructions when Math.min()/Math.max() function is\ncalled with single or double precision floating point values on AArch64.\nThe existing mechanism emits cmp+csel combination for the integer\nvariants of Math.min()/Math.max().\n\nChange-Id: Ic3b9de4aa096a8af699cfe5d0f0b8c83ca86b208", "committedDate": "2020-09-30T13:17:37Z", "type": "commit"}, {"oid": "ec3fb4041b4e2304b94b7bdfb7ab1eb0132777e5", "url": "https://github.com/oracle/graal/commit/ec3fb4041b4e2304b94b7bdfb7ab1eb0132777e5", "message": "Add intrinsics for floating point Math.min/Math.max on AArch64\n\nEmit \"fmin/fmax\" instructions when Math.min()/Math.max() function is\ncalled with single or double precision floating point values on AArch64.\nThe existing mechanism emits cmp+csel combination for the integer\nvariants of Math.min()/Math.max().\n\nChange-Id: Ic3b9de4aa096a8af699cfe5d0f0b8c83ca86b208", "committedDate": "2020-09-30T13:17:37Z", "type": "forcePushed"}]}