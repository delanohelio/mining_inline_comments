{"pr_number": 2343, "pr_title": "Initialize classes with simple side-effect-free class initializers before static analysis", "pr_createdAt": "2020-04-14T04:33:38Z", "pr_url": "https://github.com/oracle/graal/pull/2343", "timeline": [{"oid": "98ad5aab2aaed80bc57f927df34a75d0e294f288", "url": "https://github.com/oracle/graal/commit/98ad5aab2aaed80bc57f927df34a75d0e294f288", "message": "Initialize classes with simple side-effect-free class initializers before static analysis", "committedDate": "2020-04-14T05:26:52Z", "type": "commit"}, {"oid": "98ad5aab2aaed80bc57f927df34a75d0e294f288", "url": "https://github.com/oracle/graal/commit/98ad5aab2aaed80bc57f927df34a75d0e294f288", "message": "Initialize classes with simple side-effect-free class initializers before static analysis", "committedDate": "2020-04-14T05:26:52Z", "type": "forcePushed"}, {"oid": "cff644d59fe25fe32ac0afe4641efa2e6dbf3543", "url": "https://github.com/oracle/graal/commit/cff644d59fe25fe32ac0afe4641efa2e6dbf3543", "message": "Early constant folding of $assertionsDisabled fields", "committedDate": "2020-04-15T18:38:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg2Mzg0OA==", "url": "https://github.com/oracle/graal/pull/2343#discussion_r409863848", "bodyText": "Extra white space.", "author": "vjovanov", "createdAt": "2020-04-16T21:38:49Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/classinitialization/EarlyClassInitializerAnalysis.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package com.oracle.svm.hosted.classinitialization;\n+\n+import static org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin.InlineInfo.createStandardInlineInfo;\n+\n+import java.util.function.Supplier;\n+\n+import org.graalvm.compiler.api.replacements.SnippetReflectionProvider;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.DebugContext.Builder;\n+import org.graalvm.compiler.graph.Graph;\n+import org.graalvm.compiler.graph.Node;\n+import org.graalvm.compiler.java.BytecodeParser;\n+import org.graalvm.compiler.java.GraphBuilderPhase;\n+import org.graalvm.compiler.nodes.FrameState;\n+import org.graalvm.compiler.nodes.Invoke;\n+import org.graalvm.compiler.nodes.StructuredGraph;\n+import org.graalvm.compiler.nodes.StructuredGraph.GuardsStage;\n+import org.graalvm.compiler.nodes.ValueNode;\n+import org.graalvm.compiler.nodes.extended.UnsafeAccessNode;\n+import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration;\n+import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderConfiguration.Plugins;\n+import org.graalvm.compiler.nodes.graphbuilderconf.GraphBuilderContext;\n+import org.graalvm.compiler.nodes.graphbuilderconf.InlineInvokePlugin;\n+import org.graalvm.compiler.nodes.graphbuilderconf.InvocationPlugins;\n+import org.graalvm.compiler.nodes.java.AccessFieldNode;\n+import org.graalvm.compiler.options.OptionValues;\n+import org.graalvm.compiler.phases.OptimisticOptimizations;\n+import org.graalvm.compiler.phases.tiers.HighTierContext;\n+import org.graalvm.compiler.phases.util.Providers;\n+\n+import com.oracle.svm.core.option.HostedOptionValues;\n+import com.oracle.svm.core.util.VMError;\n+import com.oracle.svm.hosted.c.GraalAccess;\n+import com.oracle.svm.hosted.phases.EarlyConstantFoldLoadFieldPlugin;\n+import com.oracle.svm.hosted.phases.NoClassInitializationPlugin;\n+import com.oracle.svm.hosted.snippets.SubstrateGraphBuilderPlugins;\n+\n+import jdk.vm.ci.meta.ResolvedJavaField;\n+import jdk.vm.ci.meta.ResolvedJavaMethod;\n+import jdk.vm.ci.meta.ResolvedJavaType;\n+\n+/**\n+ * A simple intra-procedural analysis of class initializers to allow early class initialization\n+ * before static analysis for classes with simple class initializers.\n+ * \n+ * This analysis runs before the call tree is completely built, so the scope is limited to the class\n+ * initializer itself, and methods that can be inlined into the class initializer. Method inlining\n+ * is an easy way to increase the scope. Two simple tests are used to determine if a class\n+ * initializer is side-effect free:\n+ * \n+ * 1) No method calls remain after parsing. This automatically precludes any virtual calls (only\n+ * direct calls can be inlined during parsing) and any calls to native methods.\n+ * \n+ * 2) No reads and writes of static fields apart from static fields of the class that is going to be\n+ * initialized. This ensures that there are no side effects. Note that we do not need to check for\n+ * instance fields: since no static fields are read, it is guaranteed that only instance fields of\n+ * newly allocated objects are accessed.\n+ * \n+ * To avoid parsing a large class initializer graph just to find out that the class cannot be\n+ * initialized anyway, the parsing is aborted using a {@link ClassInitalizerHasSideEffectsException}\n+ * as soon as one of the tests fail.\n+ */\n+class EarlyClassInitializerAnalysis {\n+\n+    private final Providers originalProviders;\n+    private final GraphBuilderConfiguration graphBuilderConfig;\n+    private final HighTierContext context;\n+\n+    EarlyClassInitializerAnalysis() {\n+        originalProviders = GraalAccess.getOriginalProviders();\n+        SnippetReflectionProvider originalSnippetReflection = GraalAccess.getOriginalSnippetReflection();\n+\n+        InvocationPlugins invocationPlugins = new InvocationPlugins();\n+        SubstrateGraphBuilderPlugins.registerClassDesiredAssertionStatusPlugin(invocationPlugins, originalSnippetReflection);\n+\n+        Plugins plugins = new Plugins(invocationPlugins);\n+        plugins.appendInlineInvokePlugin(new AbortOnRecursiveInliningPlugin());\n+        plugins.setClassInitializationPlugin(new AbortOnUnitializedClassPlugin());\n+        plugins.appendNodePlugin(new EarlyConstantFoldLoadFieldPlugin(originalProviders.getMetaAccess()));\n+\n+        graphBuilderConfig = GraphBuilderConfiguration.getDefault(plugins).withEagerResolving(true);\n+        context = new HighTierContext(originalProviders, null, OptimisticOptimizations.NONE);\n+    }\n+\n+    @SuppressWarnings(\"try\")\n+    boolean canInitializeWithoutSideEffects(Class<?> clazz) {\n+        ResolvedJavaType type = originalProviders.getMetaAccess().lookupJavaType(clazz);\n+        assert type.getSuperclass() == null || type.getSuperclass().isInitialized() : \"This analysis assumes that the superclass was successfully analyzed and initialized beforehand: \" +\n+                        type.toJavaName(true);\n+\n+        ResolvedJavaMethod clinit = type.getClassInitializer();\n+        if (clinit == null) {\n+            /* No class initializer, so the class can trivially be initialized. */\n+            return true;\n+        } else if (clinit.getCode() == null) {\n+            /*\n+             * Happens e.g. when linking of the class failed. Note that we really need to check for\n+             * getCode(), because getCodeSize() still returns a value > 0 for such methods.\n+             */\n+            return false;\n+        }\n+\n+        OptionValues options = HostedOptionValues.singleton();\n+        DebugContext debug = new Builder(options).build();\n+        try (DebugContext.Scope s = debug.scope(\"EarlyClassInitializerAnalysis\", clinit)) {\n+            return canInitializeWithoutSideEffects(clinit, options, debug);\n+        } catch (Throwable ex) {\n+            throw debug.handle(ex);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"try\")\n+    private boolean canInitializeWithoutSideEffects(ResolvedJavaMethod clinit, OptionValues options, DebugContext debug) {\n+        StructuredGraph graph = new StructuredGraph.Builder(options, debug).method(clinit).build();\n+        graph.setGuardsStage(GuardsStage.FIXED_DEOPTS);\n+        GraphBuilderPhase.Instance builderPhase = new ClassInitializerGraphBuilderPhase(context, graphBuilderConfig, context.getOptimisticOptimizations());\n+\n+        try (Graph.NodeEventScope nes = graph.trackNodeEvents(new AbortOnDisallowedNode())) {\n+            builderPhase.apply(graph, context);\n+            /*\n+             * If parsing is not aborted by a ClassInitalizerHasSideEffectsException, it does not\n+             * have any side effect.\n+             */\n+            return true;\n+\n+        } catch (ClassInitalizerHasSideEffectsException ex) {\n+            return false;\n+        } catch (BytecodeParser.BytecodeParserError ex) {\n+            if (ex.getCause() instanceof ClassInitalizerHasSideEffectsException) {\n+                return false;\n+            }\n+            throw ex;\n+        }\n+    }\n+}\n+\n+class ClassInitalizerHasSideEffectsException extends RuntimeException {\n+    private static final long serialVersionUID = 1L;\n+\n+    ClassInitalizerHasSideEffectsException(String message) {\n+        super(message);\n+    }\n+}\n+\n+class AbortOnRecursiveInliningPlugin implements InlineInvokePlugin {\n+    @Override\n+    public InlineInfo shouldInlineInvoke(GraphBuilderContext b, ResolvedJavaMethod original, ValueNode[] arguments) {\n+        for (GraphBuilderContext parent = b.getParent(); parent != null; parent = parent.getParent()) {\n+            if (parent.getMethod().equals(original)) {\n+                return InlineInfo.DO_NOT_INLINE_WITH_EXCEPTION;\n+            }\n+        }\n+        if (original.getCode() == null) {\n+            return InlineInfo.DO_NOT_INLINE_WITH_EXCEPTION;\n+        }\n+\n+        /*\n+         * We do not restrict inlining based on method size or inlining depth. Since parsing is\n+         * aborted as soon as a forbidden node is added, we do not expect the graph size to grow out\n+         * of control.\n+         */\n+        return createStandardInlineInfo(original);\n+    }\n+}\n+\n+/**\n+ * Parsing is aborted if any non-initialized class is encountered (apart from the class that is\n+ * analyzed itself).\n+ */\n+class AbortOnUnitializedClassPlugin extends NoClassInitializationPlugin {\n+    @Override\n+    public boolean apply(GraphBuilderContext b, ResolvedJavaType type, Supplier<FrameState> frameState, ValueNode[] classInit) {\n+        ResolvedJavaMethod clinitMethod = b.getGraph().method();\n+        if (!type.isInitialized() && !type.isArray() && !type.equals(clinitMethod.getDeclaringClass())) {\n+            throw new ClassInitalizerHasSideEffectsException(\"Reference of class that is not initialized: \" + type.toJavaName(true));\n+        }\n+        return false;\n+    }\n+}\n+\n+class AbortOnDisallowedNode extends Graph.NodeEventListener {\n+    @Override\n+    public void nodeAdded(Node node) {\n+        if (node instanceof Invoke) {\n+            throw new ClassInitalizerHasSideEffectsException(\"Non-inlined invoke of method: \" + ((Invoke) node).getTargetMethod().format(\"%H.%n(%p)\"));\n+", "originalCommit": "cff644d59fe25fe32ac0afe4641efa2e6dbf3543", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTg4MDE1Mg==", "url": "https://github.com/oracle/graal/pull/2343#discussion_r409880152", "bodyText": "This is an intentional semantic change that cleans up the assertion status for JDK classes. Historically, some assertions in the JDK failed because not all parts of the JDK were supported yet in a native image. But by now every assertion failing in JDK code is actually a bug that we want to know about and fix.", "author": "christianwimmer", "createdAt": "2020-04-16T22:15:56Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/ameta/AnalysisConstantReflectionProvider.java", "diffHunk": "@@ -225,22 +225,14 @@ private JavaConstant replaceObject(JavaConstant value) {\n     /**\n      * Intercept assertion status: the value of the field during image generation does not matter at\n      * all (because it is the hosted assertion status), we instead return the appropriate runtime\n-     * assertion status.\n+     * assertion status. Field loads are also intrinsified early in\n+     * {@link com.oracle.svm.hosted.phases.EarlyConstantFoldLoadFieldPlugin}, but we could still see\n+     * such a field here if user code, e.g., accesses it via reflection.\n      */\n     private static JavaConstant interceptAssertionStatus(AnalysisField field, JavaConstant value) {\n-        if (Modifier.isStatic(field.getModifiers()) && field.isSynthetic() && field.getName().startsWith(\"$assertionsDisabled\")) {\n-            String unsubstitutedName = field.wrapped.getDeclaringClass().toJavaName();\n-            if (unsubstitutedName.startsWith(\"java.\") || unsubstitutedName.startsWith(\"javax.\") || unsubstitutedName.startsWith(\"sun.\")) {", "originalCommit": "cff644d59fe25fe32ac0afe4641efa2e6dbf3543", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}