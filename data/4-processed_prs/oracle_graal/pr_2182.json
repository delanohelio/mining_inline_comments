{"pr_number": 2182, "pr_title": "AArch64: Add match rules for bitfield move.", "pr_createdAt": "2020-02-24T07:56:29Z", "pr_url": "https://github.com/oracle/graal/pull/2182", "timeline": [{"oid": "5b1d4e28647734eca456226d5ed2c0fc4db8df68", "url": "https://github.com/oracle/graal/commit/5b1d4e28647734eca456226d5ed2c0fc4db8df68", "message": "AArch64: Add match rules for bitfield move.\n\nThis patch adds the following match rules to generate bitfield\nmove instruction on AArch64:\n* (RightShift (LeftShift value a) b)         -> SBFX/SBFIZ\n* (UnsignedRightShift (LeftShift value a) b) -> UBFX/UBFIZ\n* (LeftShift (SignExtend value) a)           -> SBFIZ\nEg:\n  lsl    w0, w1, #8\n  asr    w0, w0, #15\nis optimized to:\n  sbfx   w0, w1, #7, #17\n\nIt also adds the rules to integrate the ZeroExtend with unsigned\nbitfield move operation.\nEg:\n  ubfiz  w0, w1, #5, #12\n  and    x0, x0, #0xffffffff\nis optimized to:\n  ubfiz  x0, x1, #5, #12\n\nChange-Id: I2b635d4895db0d5f4c30630176f336e9a226ccaf", "committedDate": "2020-02-24T07:51:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1Mjc0Ng==", "url": "https://github.com/oracle/graal/pull/2182#discussion_r434452746", "bodyText": "I think this is missing the mask of the lower bits in the shift amount. Here is a test:\ndiff --git a/compiler/src/org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64BitFieldTest.java b/compiler/src/org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64BitFieldTest.java\nindex 7212af4f80f..13ad08c91f8 100644\n--- a/compiler/src/org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64BitFieldTest.java\n+++ b/compiler/src/org.graalvm.compiler.core.aarch64.test/src/org/graalvm/compiler/core/aarch64/test/AArch64BitFieldTest.java\n@@ -183,6 +183,16 @@ public class AArch64BitFieldTest extends AArch64MatchRuleTest {\n         testAndCheckLIR(\"signedB2LInsert\", 0xab3213efL);\n     }\n \n+    public long signedB2LInsertShAmtOverflow(long input) {\n+        byte b = (byte) input;\n+        return ((long) b) << 64;\n+    }\n+\n+    @Test\n+    public void testSignedB2LInsertShAmtOverflow() {\n+        testAndCheckLIR(\"signedB2LInsertShAmtOverflow\", 0xab3213efL);\n+    }\n+\n     // SBFIZ with S2L.\n     public long signedS2LInsert(long input) {\n         short s = (short) input;", "author": "sanzinger", "createdAt": "2020-06-03T10:00:57Z", "path": "compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64NodeMatchRules.java", "diffHunk": "@@ -233,38 +266,68 @@ public ComplexMatchResult extendedPointerAddShift(AArch64PointerAddNode addP) {\n         return null;\n     }\n \n-    @MatchRule(\"(And (UnsignedRightShift=shift a Constant=b) Constant=c)\")\n-    @MatchRule(\"(LeftShift=shift (And a Constant=c) Constant=b)\")\n-    public ComplexMatchResult unsignedBitField(BinaryNode shift, ValueNode a, ConstantNode b, ConstantNode c) {\n-        JavaKind srcKind = a.getStackKind();\n-        assert srcKind.isNumericInteger();\n-        AArch64BitFieldOp.BitFieldOpCode op = bitFieldOpMap.get(shift.getClass());\n-        assert op != null;\n-        int distance = b.asJavaConstant().asInt();\n-        long mask = c.asJavaConstant().asLong();\n+    @MatchRule(\"(And (UnsignedRightShift=shift value Constant=a) Constant=b)\")\n+    @MatchRule(\"(LeftShift=shift (And value Constant=b) Constant=a)\")\n+    public ComplexMatchResult unsignedBitField(BinaryNode shift, ValueNode value, ConstantNode a, ConstantNode b) {\n+        JavaKind kind = shift.getStackKind();\n+        return emitUnsignedBitField(kind, shift, value, a, b);\n+    }\n \n-        // The Java(R) Language Specification CHAPTER 15.19 Shift Operators says:\n-        // \"If the promoted type of the left-hand operand is int(long), then only the five(six)\n-        // lowest-order bits of the right-hand operand are used as the shift distance.\"\n-        distance = distance & (srcKind == JavaKind.Int ? 0x1f : 0x3f);\n+    @MatchRule(\"(LeftShift=shift (ZeroExtend=extend (And value Constant=b)) Constant=a)\")\n+    @MatchRule(\"(ZeroExtend=extend (And (UnsignedRightShift=shift value Constant=a) Constant=b))\")\n+    @MatchRule(\"(ZeroExtend=extend (LeftShift=shift (And value Constant=b) Constant=a))\")\n+    public ComplexMatchResult unsignedExtBitField(ZeroExtendNode extend, BinaryNode shift, ValueNode value, ConstantNode a, ConstantNode b) {\n+        JavaKind kind = extend.getStackKind();\n+        return emitUnsignedBitField(kind, shift, value, a, b);\n+    }\n \n-        // Constraint 1: Mask plus one should be a power-of-2 integer.\n-        if (!CodeUtil.isPowerOf2(mask + 1)) {\n-            return null;\n-        }\n-        int width = CodeUtil.log2(mask + 1);\n+    @MatchRule(\"(LeftShift=shift (SignExtend value) Constant)\")\n+    public ComplexMatchResult signedBitField(LeftShiftNode shift) {\n+        JavaKind kind = shift.getStackKind();\n+        assert kind.isNumericInteger();\n+\n+        SignExtendNode extend = (SignExtendNode) shift.getX();\n+        int srcBits = extend.getInputBits();\n+        int resultBits = extend.getResultBits();\n+        assert kind.getBitCount() == resultBits;\n+\n+        int lsb = shift.getY().asJavaConstant().asInt() & (resultBits - 1);", "originalCommit": "5b1d4e28647734eca456226d5ed2c0fc4db8df68", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3MDk2OA==", "url": "https://github.com/oracle/graal/pull/2182#discussion_r434470968", "bodyText": "Left shift by 64 equals to 0. So this case can use a signed extended instruction\nsxtb        x0, w2", "author": "XiaohongGong", "createdAt": "2020-06-03T10:34:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1Mjc0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ4MjkxNw==", "url": "https://github.com/oracle/graal/pull/2182#discussion_r434482917", "bodyText": "Ah. I see. I didn't pay too much attention to the output of the test. Yes this was false alarm. Everything looks good.", "author": "sanzinger", "createdAt": "2020-06-03T10:58:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1Mjc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1Mzk5Mg==", "url": "https://github.com/oracle/graal/pull/2182#discussion_r434453992", "bodyText": "This may be missing the masking of the lower bits as well. (Same as above in .signedBitField) Please doublecheck.", "author": "sanzinger", "createdAt": "2020-06-03T10:03:12Z", "path": "compiler/src/org.graalvm.compiler.core.aarch64/src/org/graalvm/compiler/core/aarch64/AArch64NodeMatchRules.java", "diffHunk": "@@ -233,38 +266,68 @@ public ComplexMatchResult extendedPointerAddShift(AArch64PointerAddNode addP) {\n         return null;\n     }\n \n-    @MatchRule(\"(And (UnsignedRightShift=shift a Constant=b) Constant=c)\")\n-    @MatchRule(\"(LeftShift=shift (And a Constant=c) Constant=b)\")\n-    public ComplexMatchResult unsignedBitField(BinaryNode shift, ValueNode a, ConstantNode b, ConstantNode c) {\n-        JavaKind srcKind = a.getStackKind();\n-        assert srcKind.isNumericInteger();\n-        AArch64BitFieldOp.BitFieldOpCode op = bitFieldOpMap.get(shift.getClass());\n-        assert op != null;\n-        int distance = b.asJavaConstant().asInt();\n-        long mask = c.asJavaConstant().asLong();\n+    @MatchRule(\"(And (UnsignedRightShift=shift value Constant=a) Constant=b)\")\n+    @MatchRule(\"(LeftShift=shift (And value Constant=b) Constant=a)\")\n+    public ComplexMatchResult unsignedBitField(BinaryNode shift, ValueNode value, ConstantNode a, ConstantNode b) {\n+        JavaKind kind = shift.getStackKind();\n+        return emitUnsignedBitField(kind, shift, value, a, b);\n+    }\n \n-        // The Java(R) Language Specification CHAPTER 15.19 Shift Operators says:\n-        // \"If the promoted type of the left-hand operand is int(long), then only the five(six)\n-        // lowest-order bits of the right-hand operand are used as the shift distance.\"\n-        distance = distance & (srcKind == JavaKind.Int ? 0x1f : 0x3f);\n+    @MatchRule(\"(LeftShift=shift (ZeroExtend=extend (And value Constant=b)) Constant=a)\")\n+    @MatchRule(\"(ZeroExtend=extend (And (UnsignedRightShift=shift value Constant=a) Constant=b))\")\n+    @MatchRule(\"(ZeroExtend=extend (LeftShift=shift (And value Constant=b) Constant=a))\")\n+    public ComplexMatchResult unsignedExtBitField(ZeroExtendNode extend, BinaryNode shift, ValueNode value, ConstantNode a, ConstantNode b) {\n+        JavaKind kind = extend.getStackKind();\n+        return emitUnsignedBitField(kind, shift, value, a, b);\n+    }\n \n-        // Constraint 1: Mask plus one should be a power-of-2 integer.\n-        if (!CodeUtil.isPowerOf2(mask + 1)) {\n-            return null;\n-        }\n-        int width = CodeUtil.log2(mask + 1);\n+    @MatchRule(\"(LeftShift=shift (SignExtend value) Constant)\")\n+    public ComplexMatchResult signedBitField(LeftShiftNode shift) {\n+        JavaKind kind = shift.getStackKind();\n+        assert kind.isNumericInteger();\n+\n+        SignExtendNode extend = (SignExtendNode) shift.getX();\n+        int srcBits = extend.getInputBits();\n+        int resultBits = extend.getResultBits();\n+        assert kind.getBitCount() == resultBits;\n+\n+        int lsb = shift.getY().asJavaConstant().asInt() & (resultBits - 1);\n+        // Get the min value of the srcBits and (resultBits - lsb) as the bitfield width.\n+        int width = Math.min(srcBits, resultBits - lsb);\n+        assert width >= 1 && width <= resultBits - lsb;\n+\n+        ValueNode value = extend.getValue();\n+        return emitBitField(kind, BitFieldOpCode.SBFIZ, value, lsb, width);\n+    }\n+\n+    @MatchRule(\"(RightShift=rshift (LeftShift=lshift value Constant) Constant)\")\n+    @MatchRule(\"(UnsignedRightShift=rshift (LeftShift=lshift value Constant) Constant)\")\n+    public ComplexMatchResult bitFieldMove(BinaryNode rshift, LeftShiftNode lshift) {\n+        JavaKind srcKind = rshift.getStackKind();\n+        assert srcKind.isNumericInteger();\n         int srcBits = srcKind.getBitCount();\n-        // Constraint 2: Bit field width is less than 31(63) for int(long) as any bit field move\n-        // operations can be done by a single shift instruction if the width is 31(63).\n-        if (width >= srcBits - 1) {\n+        int lshiftNum = lshift.getY().asJavaConstant().asInt() & (srcBits - 1);\n+        int rshiftNum = rshift.getY().asJavaConstant().asInt() & (srcBits - 1);", "originalCommit": "5b1d4e28647734eca456226d5ed2c0fc4db8df68", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3MjA0Ng==", "url": "https://github.com/oracle/graal/pull/2182#discussion_r434472046", "bodyText": "Actually I think  & (srcBits - 1) is not needed, since the compiler has handled it in the mid-end.", "author": "XiaohongGong", "createdAt": "2020-06-03T10:36:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1Mzk5Mg=="}], "type": "inlineReview"}]}