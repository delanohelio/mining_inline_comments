{"pr_number": 2088, "pr_title": "Debug info prototype", "pr_createdAt": "2020-01-22T10:51:13Z", "pr_url": "https://github.com/oracle/graal/pull/2088", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAyMTEwOA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r370021108", "bodyText": "Can you please convert all these C++ style comments to proper javadoc.", "author": "dougxc", "createdAt": "2020-01-23T09:52:32Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debuginfo;\n+\n+import java.util.List;\n+\n+// class defining interfaces used to allow a native image", "originalCommit": "7138edc94f05596cf2d70d158f317cad5abb5178", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDA3MzEyNw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r370073127", "bodyText": "Yes, of course -- I should have been on the ball from the start.\nI have converted almost all of these existing comments to javadoc, updated the content to be more informative and added a lot more missing javadoc comments.\nI have (deliberately) not javadoc commented all the final values that clearly identify DWARF constants -- there is the DWARF spec for that.\nI have also not (yet) javadoc commented some of the internal details of DwarfSectionImpl and its subclasses, most notably the various putXXX and writeXXX methods that insert simple data records to the ELF sections in a variety of different formats. The higher level methods which invoke them provide comments detailing the data layouts so this omission should not be not critical when it comes to understanding the code.", "author": "adinn", "createdAt": "2020-01-23T11:48:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAyMTEwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1MzY1Mw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372353653", "bodyText": "No point in assigning to an unused local. Just use newUserDefinedSection( ..... I know the names of these methods are stupid.", "author": "olpaw", "createdAt": "2020-01-29T12:27:34Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/ELFObjectFile.java", "diffHunk": "@@ -1155,4 +1157,46 @@ public SymbolTable getSymbolTable() {\n     protected int getMinimumFileSize() {\n         return 0;\n     }\n+\n+    @Override\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        DwarfSections dwarfSections = new DwarfSections(getMachine());\n+        // we need an implementation for each section\n+        DwarfSections.DwarfStrSectionImpl elfStrSectionImpl = dwarfSections.getStrSectionImpl();\n+        DwarfSections.DwarfAbbrevSectionImpl elfAbbrevSectionImpl = dwarfSections.getAbbrevSectionImpl();\n+        DwarfSections.DwarfFrameSectionImpl frameSectionImpl = dwarfSections.getFrameSectionImpl();\n+        DwarfSections.DwarfInfoSectionImpl elfInfoSectionImpl = dwarfSections.getInfoSectionImpl();\n+        DwarfSections.DwarfARangesSectionImpl elfARangesSectionImpl = dwarfSections.getARangesSectionImpl();\n+        DwarfSections.DwarfLineSectionImpl elfLineSectionImpl = dwarfSections.getLineSectionImpl();\n+        // now we can create the section elements with empty content\n+        @SuppressWarnings(\"unused\")\n+        ELFSection strSection = (ELFSection) newUserDefinedSection(elfStrSectionImpl.getSectionName(), elfStrSectionImpl);", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc4OTM0NA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375789344", "bodyText": "Yes, indeed. Removed.", "author": "adinn", "createdAt": "2020-02-06T11:47:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1MzY1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1ODA2MQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372358061", "bodyText": "I did not see the code where your elf.darf entities get transformed into their binary representations. Do I miss something or is this simply not ready yet?", "author": "olpaw", "createdAt": "2020-01-29T12:38:06Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/Range.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+/**\n+ * details of a specific address range in a compiled method\n+ * either a primary range identifying a whole method\n+ * or a sub-range identifying a sequence of\n+ * instructions that belong to an inlined method\n+ */\n+\n+public class Range {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NzE0NQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372387145", "bodyText": "Sorry for the noise. Found it in DwarfSections.java (github did not show me that file first because it too large ... and it really is ;-) )", "author": "olpaw", "createdAt": "2020-01-29T13:41:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1ODA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc4OTY4Mg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375789682", "bodyText": "Yes, I will split out the embedded classes so the code can be in separate files.", "author": "adinn", "createdAt": "2020-02-06T11:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1ODA2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1ODg5Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372358896", "bodyText": "We would want to have a hosted option. e.g GenerateDebugInfo that would ensure TrackNodeSourcePosition is enabled whenever GenerateDebugInfo > 0", "author": "olpaw", "createdAt": "2020-01-29T12:40:12Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java", "diffHunk": "@@ -458,6 +473,12 @@ public void build(DebugContext debug, ImageHeapLayouter layouter) {\n             cGlobals.writeData(rwDataBuffer, (offset, symbolName) -> defineDataSymbol(symbolName, rwDataSection, offset + RWDATA_CGLOBALS_PARTITION_OFFSET));\n             defineDataSymbol(CGlobalDataInfo.CGLOBALDATA_BASE_SYMBOL_NAME, rwDataSection, RWDATA_CGLOBALS_PARTITION_OFFSET);\n \n+            // if we have constructed any debug info then\n+            // give the object file a chance to install it\n+            if (GraalOptions.TrackNodeSourcePosition.getValue(HostedOptionValues.singleton())) {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMzMDI5Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r376330296", "bodyText": "Answered in another comment", "author": "adinn", "createdAt": "2020-02-07T10:52:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM1ODg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2NjM3Mg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372366372", "bodyText": "We have org.graalvm.compiler.debug.DebugContext for logging. See e.g. com.oracle.svm.hosted.ResourcesFeature#scanDirectory", "author": "olpaw", "createdAt": "2020-01-29T12:57:22Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2OTYyNQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372369625", "bodyText": "afaics you only ever add to this list without every using it afterwards", "author": "olpaw", "createdAt": "2020-01-29T13:04:32Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc5NTM5MQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375795391", "bodyText": "Yes, I was hedging on the idea that it might be necessary at some point to iterate over (outer) compiled methods in address order. At present all iteration is by methods within each owning class (using the list of ClassEntry) which is effectively the same. I have removed this list and updated the comments regarding iteration options.", "author": "adinn", "createdAt": "2020-02-06T12:02:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM2OTYyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3MDg5Nw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372370897", "bodyText": "Maybe Charset.forName(\"US-ASCII\").newEncoder().canEncode ?", "author": "olpaw", "createdAt": "2020-01-29T13:07:35Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putInt(int i, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putLong(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            // mark address so it is relocated relative to the start of the text segment\n+            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+            pos = putLong(0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int putULEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >>> 7;\n+                boolean done = (l == 0);\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putSLEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >> 7;\n+                boolean bIsSigned = (b & 0x40) != 0;\n+                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+            return putAsciiStringBytes(s, 0, buffer, pos);\n+        }\n+\n+        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+            int pos = p;\n+            for (int l = startChar; l < s.length(); l++) {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3MjI3OQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372372279", "bodyText": "CUDOs for documenting the binary representations. Please use\n/*\n * This style for code comments wherever possible.\n *\n */", "author": "olpaw", "createdAt": "2020-01-29T13:10:31Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putInt(int i, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putLong(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            // mark address so it is relocated relative to the start of the text segment\n+            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+            pos = putLong(0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int putULEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >>> 7;\n+                boolean done = (l == 0);\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putSLEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >> 7;\n+                boolean bIsSigned = (b & 0x40) != 0;\n+                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+            return putAsciiStringBytes(s, 0, buffer, pos);\n+        }\n+\n+        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+            int pos = p;\n+            for (int l = startChar; l < s.length(); l++) {\n+                char c = s.charAt(l);\n+                if (c > 127) {\n+                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n+                }\n+                buffer[pos++] = (byte) c;\n+            }\n+            buffer[pos++] = '\\0';\n+            return pos;\n+        }\n+\n+        // common write methods that check for a null buffer\n+\n+        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n+            if (buffer != null) {\n+                int length = pos - (lengthPos + 4);\n+                putInt(length, buffer, lengthPos);\n+            }\n+        }\n+\n+        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeTag(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeFlag(byte flag, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(flag, scratch, 0);\n+            } else {\n+                return putByte(flag, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + 8;\n+            } else {\n+                return putRelocatableCodeOffset(address, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData8(long value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putLong(value, scratch, 0);\n+            } else {\n+                return putLong(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData4(int value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putInt(value, scratch, 0);\n+            } else {\n+                return putInt(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(value, scratch, 0);\n+            } else {\n+                return putByte(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrNull(byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(0, scratch, 0);\n+            } else {\n+                return putSLEB(0, buffer, pos);\n+            }\n+        }\n+\n+        /**\n+         * identify the section after which this debug section\n+         * needs to be ordered when sizing and creating content.\n+         * @return the name of the preceding section\n+         */\n+        public abstract String targetSectionName();\n+\n+        /**\n+         * identify the layout properties of the target section\n+         * which need to have been decided before the contents\n+         * of this section can be created.\n+         * @return an array of the relevant decision kinds\n+         */\n+        public abstract LayoutDecision.Kind[] targetSectionKinds();\n+\n+        /**\n+         * identify this debug section by name.\n+         * @return the name of the debug section\n+         */\n+        public abstract String getSectionName();\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            // ensure content byte[] has been created before calling super method\n+            createContent();\n+\n+            // ensure content byte[] has been written before calling super method\n+            writeContent();\n+\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n+            Set<BuildDependency> deps = super.getDependencies(decisions);\n+            String targetName = targetSectionName();\n+            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n+            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n+            // make our content depend on the size and content of the target\n+            for (LayoutDecision.Kind targetKind : targetKinds) {\n+                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n+                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n+            }\n+            // make our size depend on our content\n+            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n+\n+            return deps;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_str section.\n+     */\n+    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n+        public DwarfStrSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_STR_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    stringEntry.setOffset(pos);\n+                    String string = stringEntry.getString();\n+                    pos += string.length() + 1;\n+                }\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    assert stringEntry.getOffset() == pos;\n+                    String string = stringEntry.getString();\n+                    pos = putAsciiStringBytes(string, buffer, pos);\n+                }\n+            }\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_abbrev section.\n+     */\n+    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfAbbrevSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ABBREV_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // an abbrev table contains abbrev entries for one or", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3MzI1NQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372373255", "bodyText": "This file would profit from getting partitioned into multiple source files.", "author": "olpaw", "createdAt": "2020-01-29T13:12:45Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTg2NzcyNA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375867724", "bodyText": "All the section implementation classes are now in separat efiles and they are no longer inner classes of class SwarfSections", "author": "adinn", "createdAt": "2020-02-06T14:33:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3MzI1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3NDA4NA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372374084", "bodyText": "Nah ... instead add HostedOption GenerateDebugInfo and whenever it is > 0 make sure TrackNodeSourcePosition gets set.", "author": "olpaw", "createdAt": "2020-01-29T13:14:38Z", "path": "substratevm/DEBUGINFO.md", "diffHunk": "@@ -0,0 +1,127 @@\n+Using the ptototype debug info feature\n+--------------------------------------\n+\n+To add debug info to a generated native image add flag\n+-H:+TrackNodeSourcePosition to the native image command line.\n+\n+  mx native-image -H:+TrackNodeSourcePosition Hello.java", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk5MTE4Mg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375991182", "bodyText": "Yes, I wanted to do something like that but I was not sure exactly how to implement it. Having looked around at the code I think I worked out how to do it and have pushed a further commit which I believe does it correctly.\nGenerateDebugInfo is now a HostedOption in SubstrateOptions. It uses an onValueUpdate override to test TrackNodeSourcePosition and force it to true if it is not set. Hope that is ok.", "author": "adinn", "createdAt": "2020-02-06T17:56:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3NDA4NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzAyMDAzNg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r377020036", "bodyText": "Looks good now. Thanks!", "author": "olpaw", "createdAt": "2020-02-10T11:58:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3NDA4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3NzU3NA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372377574", "bodyText": "Instead of having a bash script that will get very complicated over time as part of building debuginfo produce a sources folder next to the binary (subdir of Path HostedOption) where you collect all the source files that the generated debuginfo refers to. This way the debugger only needs to know about a single source dir. Also keep in mind that in the Java ecosystem jar-files often have their corresponding zip or jar file that contain the sources. In Java its easy to aggregate all these files from source bundles into a single common directory location.", "author": "olpaw", "createdAt": "2020-01-29T13:21:54Z", "path": "substratevm/DEBUGINFO.md", "diffHunk": "@@ -0,0 +1,127 @@\n+Using the ptototype debug info feature\n+--------------------------------------\n+\n+To add debug info to a generated native image add flag\n+-H:+TrackNodeSourcePosition to the native image command line.\n+\n+  mx native-image -H:+TrackNodeSourcePosition Hello.java\n+\n+The resulting image should contain code (method) debug symbols.\n+\n+What is currently implemented\n+-----------------------------\n+\n+The currently implemented features include:\n+\n+  - break points configured by file and line or by method name\n+  - single stepping by line including both into and over function calls\n+  - stack backtraces (not including frames detailing inlined code)\n+\n+Note that single stepping within a compiled method includes file and\n+line number info for inlined code, including inlined Graal methods.\n+So, gdb may switch files even though you are still in the same\n+compiled method.\n+\n+Identifying the location of source code\n+---------------------------------------\n+\n+In order for gdb to be able to locate the source files for your app\n+methods, Graal methods and JDK runtime methods you need to provide gdb\n+with a list of source root dirs a 'set directories' command:\n+\n+    (gdb) set directories /home/adinn/hello/src:/home/adinn/graal/sdk/src/org/graalvm.word/src:/home/adinn/graal/sdk/src/org.graalvm.options/src:...", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3ODcwOA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372378708", "bodyText": "... also for the Windows version you would need to provide a *.bat version of that script. Don't go down that path ...", "author": "olpaw", "createdAt": "2020-01-29T13:24:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3NzU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTk5MTU5Nw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375991597", "bodyText": "Yeah, I'll get onto that after I sort out using Path instead of String.", "author": "adinn", "createdAt": "2020-02-06T17:57:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3NzU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkwMjE0NA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r383902144", "bodyText": "I have just pushed a change to populate a sources tree in the working directory using source file lookups based on whatever sources  can be found in $JAVA_HOME/lib/src/zip for JDK classes ($JAVA_HOME/lib/src/zip for jdk11) or via the classpath for GraalVM & application classes. The cache manager triages classes based on package prefix and uses a lookup scheme appropriate to the identified target type: jdk, graalvm or application.\nJDK classes are looked up in src.zip, prepending a module name to the lookup path if necessary\nGraalVM classes are looked up relative to the classpath. If foo.jar is found on the class path then if foo.src.zip is found it is assumed to contain graalvm sources and added to the list of search roots. If a directory foo is found on the class path and foo/src or foo/src_gen exist then they are added to the list of search roots.\nApplication sources are looked up relative to the classpath. If foo.jar is found on the class path then if foo-sources.jar is found it is assumed to contain application sources and added to the list of search roots. If a directory foo/classes or foo/target/classes is found on the class path and foo/src exists it is added to the list of search roots. The current working directory is also added to the list of application search roots.\nFiles are cached in local dir sources under 3 distinct subdirectories jdk, graalvm and src (for JDK, GraalVM and application sources, respectively). So, in order to make this work with gdb that requires adding 3 entries to the source search path\n(gdb) set directories /path/to/pwd/sources/jdk:/path/to/pwd/sources/graalvm:/path/to/pwd/sources/src\n\nThe file names and paths used in the debug info are normally derived using the package name, substituted with the local file system separator, suffixed with the classfile source name. If the source name is missing then the unqualified class name is used. In the latter case for inner classes the name before the $ is used. Class names which start with $ (e.g. anon classes etc) are not mapped to files and so cannot have debug entries. Of course, paths for JDK classes are prefixed with the name of the module that the class belongs to.\nThere is one problem with this. Compiler classes which are referenced from NodeSourcePosition records are not present in jars on the classpath (well, not when running with jdk11). For example, class org.graalvm.compiler.replacements.amd64.AMD64StringLatin1Substitutions is referenced from a simple HelloWorld app but the corresponding source is not found. That's because these classes are made available via the platform classloader as jmod files. In consequence there is no way to locate a source for these classes.\nThere are actually sources for classes like this in src.zip. However, 1) they are almost always going to be out of date wrt the source used by the native image generator and 2) they are bundled into the src.zip with both under a path which includes not just their module name but also a secondary directory based on some initial segment of their package prefix.\nI am not really sure how to make these classes available. It appears that all the source files needed are available under compiler/mxbuild/dists/jdk11/ i.e. the directory that contains the bundled jmod files (they seem to be mostly in graal.src.zip). Is there any way for the native image generator to identify the location of this dir from the build config info and search it for extra roots to add to the GraalVM search path?", "author": "adinn", "createdAt": "2020-02-25T14:12:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3NzU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3MjM4Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r383972386", "bodyText": "@olpaw Forgot to tag this for your attention", "author": "adinn", "createdAt": "2020-02-25T15:58:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3NzU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3OTE3OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r383979178", "bodyText": "That sounds great!\nI should be able to take a closer look somewhere in the next two days or so.", "author": "olpaw", "createdAt": "2020-02-25T16:08:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3NzU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAxMDQwOA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384010408", "bodyText": "Thanks. I'm just updating the DEBUGINFO.md readme which will clarify the latest status quo.", "author": "adinn", "createdAt": "2020-02-25T17:13:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3NzU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM3OTEwOQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372379109", "bodyText": "dwarfdump is also nice for debugging/verification", "author": "olpaw", "createdAt": "2020-01-29T13:25:12Z", "path": "substratevm/DEBUGINFO.md", "diffHunk": "@@ -0,0 +1,127 @@\n+Using the ptototype debug info feature\n+--------------------------------------\n+\n+To add debug info to a generated native image add flag\n+-H:+TrackNodeSourcePosition to the native image command line.\n+\n+  mx native-image -H:+TrackNodeSourcePosition Hello.java\n+\n+The resulting image should contain code (method) debug symbols.\n+\n+What is currently implemented\n+-----------------------------\n+\n+The currently implemented features include:\n+\n+  - break points configured by file and line or by method name\n+  - single stepping by line including both into and over function calls\n+  - stack backtraces (not including frames detailing inlined code)\n+\n+Note that single stepping within a compiled method includes file and\n+line number info for inlined code, including inlined Graal methods.\n+So, gdb may switch files even though you are still in the same\n+compiled method.\n+\n+Identifying the location of source code\n+---------------------------------------\n+\n+In order for gdb to be able to locate the source files for your app\n+methods, Graal methods and JDK runtime methods you need to provide gdb\n+with a list of source root dirs a 'set directories' command:\n+\n+    (gdb) set directories /home/adinn/hello/src:/home/adinn/graal/sdk/src/org/graalvm.word/src:/home/adinn/graal/sdk/src/org.graalvm.options/src:...\n+\n+The argument is a comma separated list of source roots. It needs to\n+identify:\n+\n+  - sources for your app\n+  - sources under the Graal sdk, compiler, substratevm and truffle trees\n+  - sources in the JDK src.zip file\n+\n+Needless to say the list for Graal is long and complex. Also, the JDK\n+sources are in a zip file and gdb does not understand zip sources. So\n+you need to extract the JDK sources as a preparatory step,\n+\n+You can use shell script write_gdbsourcepath (added to Graal dir\n+substratevm) to auto-generate settings for the GRaal and JDK sources.\n+\n+    $ bash write_gdbsourcepath\n+\n+It creates a local file .gdbsourcepath which sets the relevant\n+directories. Before running it you can set two env vars to tell it\n+where to locate the source trees it needs to include:\n+\n+  - GRAAL_JAVA_SRC_ROOT should point to the dir into which you have\n+  unzipped the src.zip from your Graal JDK release\n+  - GRAAL_SRC_ROOT should point to the dir in which your Graal git\n+  tree checkout is located\n+\n+Note that the script ignores test source dirs and jdk dirs that do not\n+match the release level of the JDK (i.e. if you use jdk8 it will ony\n+include jdk8 src dirs). The script runs the java command available via\n+JAVA_HOME to idenitfy which JDK is in use).\n+\n+If you run the script from the substratevm dir of your Graal git repo\n+checkout the script will default GRAAL_SRC_ROOT to the parent dir.\n+\n+If JAVA_HOME is set the script will default GRAAL_JAVA_SRC_ROOT to\n+$JAVA_HOME/src\n+\n+Checking debug info\n+-------------------\n+\n+The objdump command can be used to display the dbeug info embedded\n+into a native image. The following commands (which all assume the\n+target binary is called hello) can be used to display all currentyl\n+generated content:\n+\n+    $ objdump --dwarf=info hello > info", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MDQ3Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372380476", "bodyText": "Why not use Path for path-like entities?", "author": "olpaw", "createdAt": "2020-01-29T13:28:02Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DirEntry.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+/**\n+ * track the directory associated with one or\n+ * more source files.\n+ */\n+public class DirEntry {\n+    private String path;", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3MjcwNg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r383972706", "bodyText": "Done", "author": "adinn", "createdAt": "2020-02-25T15:59:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MDQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MTcxMg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372381712", "bodyText": "Use Path here an you get Platform portability for free.", "author": "olpaw", "createdAt": "2020-01-29T13:30:35Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3MzAzMQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r377773031", "bodyText": "I have pushed some changes which address this problem. I modified the interface between the native image writer and the object file to pass a String for file name and Path for directory. The object file writer also employs Path internally to store both dir names and full (dir-qualfiied) file names. This avoids issues any need to handle path separators.\nI'm not sure yet that this is all done though. In particular, the info in the hosted class and source node positions does not contain any information about original source file locations. So, the native image writer is still populating Path instances with the component elements of the hosted class's package name or the inlined class's qualified name, respectively.", "author": "adinn", "createdAt": "2020-02-11T17:07:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MTcxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3NTMxMA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r383975310", "bodyText": "Thsi has been reworked. See other comments.", "author": "adinn", "createdAt": "2020-02-25T16:03:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MTcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MjkxMA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372382910", "bodyText": "Should be a static class. Others likely as well. Event better split out into several source files", "author": "olpaw", "createdAt": "2020-01-29T13:32:56Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMzMTM5Mg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r376331392", "bodyText": "Fixed as part of the move to separate files.", "author": "adinn", "createdAt": "2020-02-07T10:54:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4MjkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NDk2MQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372384961", "bodyText": "That is the right place to switch from Path to String objects.", "author": "olpaw", "createdAt": "2020-01-29T13:36:54Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putInt(int i, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (i & 0xff);\n+            buffer[pos++] = (byte) ((i >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((i >> 24) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putLong(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (l & 0xff);\n+            buffer[pos++] = (byte) ((l >> 8) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 16) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 24) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 32) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 40) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 48) & 0xff);\n+            buffer[pos++] = (byte) ((l >> 56) & 0xff);\n+            return pos;\n+        }\n+\n+        public int putRelocatableCodeOffset(long l, byte[] buffer, int p) {\n+            int pos = p;\n+            // mark address so it is relocated relative to the start of the text segment\n+            markRelocationSite(pos, 8, ObjectFile.RelocationKind.DIRECT, TEXT_SECTION_NAME, false, Long.valueOf(l));\n+            pos = putLong(0, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int putULEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >>> 7;\n+                boolean done = (l == 0);\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putSLEB(long val, byte[] buffer, int p) {\n+            long l = val;\n+            int pos = p;\n+            for (int i = 0; i < 9; i++) {\n+                byte b = (byte) (l & 0x7f);\n+                l = l >> 7;\n+                boolean bIsSigned = (b & 0x40) != 0;\n+                boolean done = ((bIsSigned && l == -1) || (!bIsSigned && l == 0));\n+                if (!done) {\n+                    b = (byte) (b | 0x80);\n+                }\n+                pos = putByte(b, buffer, pos);\n+                if (done) {\n+                    break;\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int putAsciiStringBytes(String s, byte[] buffer, int pos) {\n+            return putAsciiStringBytes(s, 0, buffer, pos);\n+        }\n+\n+        public int putAsciiStringBytes(String s, int startChar, byte[] buffer, int p) {\n+            int pos = p;\n+            for (int l = startChar; l < s.length(); l++) {\n+                char c = s.charAt(l);\n+                if (c > 127) {\n+                    throw new RuntimeException(\"oops : expected ASCII string! \" + s);\n+                }\n+                buffer[pos++] = (byte) c;\n+            }\n+            buffer[pos++] = '\\0';\n+            return pos;\n+        }\n+\n+        // common write methods that check for a null buffer\n+\n+        public void patchLength(int lengthPos, byte[] buffer, int pos) {\n+            if (buffer != null) {\n+                int length = pos - (lengthPos + 4);\n+                putInt(length, buffer, lengthPos);\n+            }\n+        }\n+\n+        public int writeAbbrevCode(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeTag(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeFlag(byte flag, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(flag, scratch, 0);\n+            } else {\n+                return putByte(flag, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrAddress(long address, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + 8;\n+            } else {\n+                return putRelocatableCodeOffset(address, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData8(long value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putLong(value, scratch, 0);\n+            } else {\n+                return putLong(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData4(int value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putInt(value, scratch, 0);\n+            } else {\n+                return putInt(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrData1(byte value, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putByte(value, scratch, 0);\n+            } else {\n+                return putByte(value, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrNull(byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(0, scratch, 0);\n+            } else {\n+                return putSLEB(0, buffer, pos);\n+            }\n+        }\n+\n+        /**\n+         * identify the section after which this debug section\n+         * needs to be ordered when sizing and creating content.\n+         * @return the name of the preceding section\n+         */\n+        public abstract String targetSectionName();\n+\n+        /**\n+         * identify the layout properties of the target section\n+         * which need to have been decided before the contents\n+         * of this section can be created.\n+         * @return an array of the relevant decision kinds\n+         */\n+        public abstract LayoutDecision.Kind[] targetSectionKinds();\n+\n+        /**\n+         * identify this debug section by name.\n+         * @return the name of the debug section\n+         */\n+        public abstract String getSectionName();\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            // ensure content byte[] has been created before calling super method\n+            createContent();\n+\n+            // ensure content byte[] has been written before calling super method\n+            writeContent();\n+\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public Set<BuildDependency> getDependencies(Map<Element, LayoutDecisionMap> decisions) {\n+            Set<BuildDependency> deps = super.getDependencies(decisions);\n+            String targetName = targetSectionName();\n+            ELFSection targetSection = (ELFSection) getElement().getOwner().elementForName(targetName);\n+            LayoutDecision ourContent = decisions.get(getElement()).getDecision(LayoutDecision.Kind.CONTENT);\n+            LayoutDecision ourSize = decisions.get(getElement()).getDecision(LayoutDecision.Kind.SIZE);\n+            LayoutDecision.Kind[] targetKinds = targetSectionKinds();\n+            // make our content depend on the size and content of the target\n+            for (LayoutDecision.Kind targetKind : targetKinds) {\n+                LayoutDecision targetDecision = decisions.get(targetSection).getDecision(targetKind);\n+                deps.add(BuildDependency.createOrGet(ourContent, targetDecision));\n+            }\n+            // make our size depend on our content\n+            deps.add(BuildDependency.createOrGet(ourSize, ourContent));\n+\n+            return deps;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_str section.\n+     */\n+    public class DwarfStrSectionImpl extends DwarfSectionImpl {\n+        public DwarfStrSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_STR_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    stringEntry.setOffset(pos);\n+                    String string = stringEntry.getString();\n+                    pos += string.length() + 1;\n+                }\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            for (StringEntry stringEntry : stringTable) {\n+                if (stringEntry.isAddToStrSection()) {\n+                    assert stringEntry.getOffset() == pos;\n+                    String string = stringEntry.getString();\n+                    pos = putAsciiStringBytes(string, buffer, pos);\n+                }\n+            }\n+            assert pos == size;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = TEXT_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        /**\n+         * debug_str section content depends on text section content and offset.\n+         */\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET,\n+                        LayoutDecision.Kind.VADDR, // add this so we can use the base address\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_abbrev section.\n+     */\n+    public class DwarfAbbrevSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfAbbrevSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ABBREV_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // an abbrev table contains abbrev entries for one or\n+            // more CUs. the table includes a sequence of abbrev\n+            // entries each of which defines a specific DIE layout\n+            // employed to describe some DIE in a CU. a table is\n+            // terminated by a null entry\n+            //\n+            // a null entry has consists of just a 0 abbrev code\n+            // LEB128 abbrev_code; ...... == 0\n+            //\n+            // non-null entries have the following format\n+            // LEB128 abbrev_code; ...... unique noncode for this layout != 0\n+            // LEB128 tag; .............. defines the type of the DIE (class, subprogram, var etc)\n+            // uint8 has_chldren; ....... is the DIE followed by child DIEs or a sibling DIE\n+            // <attribute_spec>* ........ zero or more attributes\n+            // <null_attribute_spec> .... terminator\n+            //\n+            // An attribute_spec consists of an attribute name and form\n+            // LEB128 attr_name; ........ 0 for the null attribute name\n+            // LEB128 attr_form; ........ 0 for the null attribute form\n+            //\n+            // For the moment we only use one abbrev table for all CUs.\n+            // It contains two DIEs, the first to describe the compilation\n+            // unit itself and the second to describe each method within\n+            // that compilation unit.\n+            //\n+            // The DIE layouts are as follows:\n+            //\n+            // abbrev_code == 1, tag == DW_TAG_compilation_unit, has_children\n+            // DW_AT_language : ... DW_FORM_data1\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_address\n+            // DW_AT_hi_pc : ...... DW_FORM_address\n+            // DW_AT_stmt_list : .. DW_FORM_data4\n+            //\n+            // abbrev_code == 2, tag == DW_TAG_subprogram, no_children\n+            // DW_AT_name : ....... DW_FORM_strp\n+            // DW_AT_low_pc : ..... DW_FORM_addr\n+            // DW_AT_hi_pc : ...... DW_FORM_addr\n+            // DW_AT_external : ... DW_FORM_flag\n+\n+            pos = writeAbbrev1(null, pos);\n+            pos = writeAbbrev2(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            pos = writeAbbrev1(buffer, pos);\n+            pos = writeAbbrev2(buffer, pos);\n+            assert pos == size;\n+        }\n+\n+        public int writeAttrType(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrForm(long code, byte[] buffer, int pos) {\n+            if (buffer == null) {\n+                return pos + putSLEB(code, scratch, 0);\n+            } else {\n+                return putSLEB(code, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAbbrev1(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 1 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            pos = writeTag(DW_TAG_compile_unit, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_yes, buffer, pos);\n+            pos = writeAttrType(DW_AT_language, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data1, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_stmt_list, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_data4, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        public int writeAbbrev2(byte[] buffer, int p) {\n+            int pos = p;\n+            // abbrev 2 compile unit\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            pos = writeTag(DW_TAG_subprogram, buffer, pos);\n+            pos = writeFlag(DW_CHILDREN_no, buffer, pos);\n+            pos = writeAttrType(DW_AT_name, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_strp, buffer, pos);\n+            pos = writeAttrType(DW_AT_low_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_hi_pc, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_addr, buffer, pos);\n+            pos = writeAttrType(DW_AT_external, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_flag, buffer, pos);\n+            // now terminate\n+            pos = writeAttrType(DW_AT_null, buffer, pos);\n+            pos = writeAttrForm(DW_FORM_null, buffer, pos);\n+            return pos;\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_abbrev section content depends on debug_frame section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_FRAME_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generic generator for debug_frame section.\n+     */\n+    public abstract class DwarfFrameSectionImpl extends DwarfSectionImpl {\n+\n+        public DwarfFrameSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_FRAME_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+\n+            // the frame section contains one CIE at offset 0\n+            // followed by an FIE for each method\n+            pos = writeCIE(null, pos);\n+            pos = writeMethodFrames(null, pos);\n+\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            // there are entries for the prologue region where the\n+            // stack is being built, the method body region(s) where\n+            // the code executes with a fixed size frame and the\n+            // epilogue region(s) where the stack is torn down\n+            pos = writeCIE(buffer, pos);\n+            pos = writeMethodFrames(buffer, pos);\n+\n+            if (pos != size) {\n+                System.out.format(\"pos = 0x%x  size = 0x%x\", pos, size);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCIE(byte[] buffer, int p) {\n+            // we only need a vanilla CIE with default fields\n+            // because we have to have at least one\n+            // the layout is\n+            //\n+            // uint32 : length ............... length of remaining fields in this CIE\n+            // uint32 : CIE_id ................ unique id for CIE == 0xffffff\n+            // uint8 : version ................ == 1\n+            // uint8[] : augmentation ......... == \"\" so always 1 byte\n+            // ULEB : code_alignment_factor ... == 1 (could use 4 for Aarch64)\n+            // ULEB : data_alignment_factor ... == -8\n+            // byte : ret_addr reg id ......... x86_64 => 16 AArch64 => 32\n+            // byte[] : initial_instructions .. includes pad to 8-byte boundary\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // don't care about length\n+                pos += putInt(DW_CFA_CIE_id, scratch, 0);\n+                pos += putByte(DW_CFA_CIE_version, scratch, 0);\n+                pos += putAsciiStringBytes(\"\", scratch, 0);\n+                pos += putULEB(1, scratch, 0);\n+                pos += putSLEB(-8, scratch, 0);\n+                pos += putByte((byte) getPCIdx(), scratch, 0);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                // no need to write length\n+                return pos;\n+            } else {\n+                int lengthPos = pos;\n+                pos = putInt(0, buffer, pos);\n+                pos = putInt(DW_CFA_CIE_id, buffer, pos);\n+                pos = putByte(DW_CFA_CIE_version, buffer, pos);\n+                pos = putAsciiStringBytes(\"\", buffer, pos);\n+                pos = putULEB(1, buffer, pos);\n+                pos = putSLEB(-8, buffer, pos);\n+                pos = putByte((byte) getPCIdx(), buffer, pos);\n+                // write insns to set up empty frame\n+                pos = writeInitialInstructions(buffer, pos);\n+                // pad to word alignment\n+                pos = writePaddingNops(8, buffer, pos);\n+                patchLength(lengthPos, buffer, pos);\n+                return pos;\n+            }\n+        }\n+\n+        public int writeMethodFrames(byte[] buffer, int p) {\n+            int pos = p;\n+            for (ClassEntry classEntry : primaryClasses) {\n+                for (PrimaryEntry primaryEntry : classEntry.getPrimaryEntries()) {\n+                    long lo = primaryEntry.getPrimary().getLo();\n+                    long hi = primaryEntry.getPrimary().getHi();\n+                    int frameSize = primaryEntry.getFrameSize();\n+                    int currentOffset = 0;\n+                    int lengthPos = pos;\n+                    pos = writeFDEHeader((int) lo, (int) hi, buffer, pos);\n+                    for (DebugFrameSizeChange debugFrameSizeInfo : primaryEntry.getFrameSizeInfos()) {\n+                        int advance = debugFrameSizeInfo.getOffset() - currentOffset;\n+                        currentOffset += advance;\n+                        pos = writeAdvanceLoc(advance, buffer, pos);\n+                        if (debugFrameSizeInfo.getType() == DebugFrameSizeChange.Type.EXTEND) {\n+                            // SP has been extended so rebase CFA using full frame\n+                            pos = writeDefCFAOffset(frameSize, buffer, pos);\n+                        } else {\n+                            // SP has been contracted so rebase CFA using empty frame\n+                            pos = writeDefCFAOffset(8, buffer, pos);\n+                        }\n+                    }\n+                    pos = writePaddingNops(8, buffer, pos);\n+                    patchLength(lengthPos, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeFDEHeader(int lo, int hi, byte[] buffer, int p) {\n+            // we only need a vanilla FDE header with default fields\n+            // the layout is\n+            //\n+            // uint32 : length ........... length of remaining fields in this FDE\n+            // uint32 : CIE_offset ........ always 0 i.e. identifies our only CIE header\n+            // uint64 : initial_location .. i.e. method lo address\n+            // uint64 : address_range ..... i.e. method hi - lo\n+            // byte[] : instructions ...... includes pad to 8-byte boundary\n+\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0); // dummy length\n+                pos += putInt(0, scratch, 0); // CIE_offset\n+                pos += putLong(lo, scratch, 0); // initial address\n+                return pos + putLong(hi - lo, scratch, 0); // address range\n+            } else {\n+                pos = putInt(0, buffer, pos); // dummy length\n+                pos = putInt(0, buffer, pos); // CIE_offset\n+                pos = putRelocatableCodeOffset(lo, buffer, pos); // initial address\n+                return putLong(hi - lo, buffer, pos); // address range\n+            }\n+        }\n+\n+        public int writePaddingNops(int alignment, byte[] buffer, int p) {\n+            int pos = p;\n+            assert (alignment & (alignment - 1)) == 0;\n+            while ((pos & (alignment - 1)) != 0) {\n+                if (buffer == null) {\n+                    pos++;\n+                } else {\n+                    pos = putByte(DW_CFA_nop, buffer, pos);\n+                }\n+            }\n+            return pos;\n+        }\n+\n+        public int writeDefCFA(int register, int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa, scratch, 0);\n+                pos += putSLEB(register, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa, buffer, pos);\n+                pos = putULEB(register, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeDefCFAOffset(int offset, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_def_cfa_offset, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_def_cfa_offset, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc(int offset, byte[] buffer, int pos) {\n+            if (offset <= 0x3f) {\n+                return writeAdvanceLoc0((byte) offset, buffer, pos);\n+            } else if (offset <= 0xff) {\n+                return writeAdvanceLoc1((byte) offset, buffer, pos);\n+            } else if (offset <= 0xffff) {\n+                return writeAdvanceLoc2((short) offset, buffer, pos);\n+            } else {\n+                return writeAdvanceLoc4(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc0(byte offset, byte[] buffer, int pos) {\n+            byte op = advanceLoc0Op(offset);\n+            if (buffer == null) {\n+                return pos + putByte(op, scratch, 0);\n+            } else {\n+                return putByte(op, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc1(byte offset, byte[] buffer, int p) {\n+            int pos = p;\n+            byte op = DW_CFA_advance_loc1;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putByte(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putByte(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc2(short offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc2;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putShort(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putShort(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAdvanceLoc4(int offset, byte[] buffer, int p) {\n+            byte op = DW_CFA_advance_loc4;\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putInt(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putInt(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeOffset(int register, int offset, byte[] buffer, int p) {\n+            byte op = offsetOp(register);\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(op, scratch, 0);\n+                return pos + putULEB(offset, scratch, 0);\n+            } else {\n+                pos = putByte(op, buffer, pos);\n+                return putULEB(offset, buffer, pos);\n+            }\n+        }\n+\n+        public int writeRegister(int savedReg, int savedToReg, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putByte(DW_CFA_register, scratch, 0);\n+                pos += putULEB(savedReg, scratch, 0);\n+                return pos + putULEB(savedToReg, scratch, 0);\n+            } else {\n+                pos = putByte(DW_CFA_register, buffer, pos);\n+                pos = putULEB(savedReg, buffer, pos);\n+                return putULEB(savedToReg, buffer, pos);\n+            }\n+        }\n+\n+        public abstract int getPCIdx();\n+\n+        public abstract int getSPIdx();\n+\n+        public abstract int writeInitialInstructions(byte[] buffer, int pos);\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            super.debug(format, args);\n+        }\n+\n+        /**\n+         * debug_frame section content depends on debug_line section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_LINE_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+\n+        private byte offsetOp(int register) {\n+            assert (register >> 6) == 0;\n+            return (byte) ((DW_CFA_offset << 6) | register);\n+        }\n+\n+        private byte advanceLoc0Op(int offset) {\n+            assert (offset >= 0 && offset <= 0x3f);\n+            return (byte) ((DW_CFA_advance_loc << 6) | offset);\n+        }\n+    }\n+\n+    /**\n+     * x86_64-specific generator for debug_frame section\n+     * that knows details of x86_64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplX86_64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_RSP_IDX = 7;\n+        public static final int DW_CFA_RIP_IDX = 16;\n+\n+        public DwarfFrameSectionImplX86_64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_RIP_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_RSP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp points at the word containing the saved rip\n+            // so the frame base (cfa) is at rsp + 8 (why not - ???)\n+            // def_cfa r7 (sp) offset 8\n+            pos = writeDefCFA(DW_CFA_RSP_IDX, 8, buffer, pos);\n+            // and rip is saved at offset 8 (coded as 1 which gets scaled by dataAlignment) from cfa\n+            // (why not -1 ???)\n+            // offset r16 (rip) cfa - 8\n+            pos = writeOffset(DW_CFA_RIP_IDX, 1, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * AArch64-specific generator for debug_frame section\n+     * that knows details of AArch64 registers and frame layout.\n+     */\n+    public class DwarfFrameSectionImplAArch64 extends DwarfFrameSectionImpl {\n+        public static final int DW_CFA_FP_IDX = 29;\n+        public static final int DW_CFA_LR_IDX = 30;\n+        public static final int DW_CFA_SP_IDX = 31;\n+        public static final int DW_CFA_PC_IDX = 32;\n+\n+        public DwarfFrameSectionImplAArch64() {\n+            super();\n+        }\n+\n+        @Override\n+        public int getPCIdx() {\n+            return DW_CFA_PC_IDX;\n+        }\n+\n+        @Override\n+        public int getSPIdx() {\n+            return DW_CFA_SP_IDX;\n+        }\n+\n+        @Override\n+        public int writeInitialInstructions(byte[] buffer, int p) {\n+            int pos = p;\n+            // rsp has not been updated\n+            // caller pc is in lr\n+            // register r32 (rpc), r30 (lr)\n+            pos = writeRegister(DW_CFA_PC_IDX, DW_CFA_LR_IDX, buffer, pos);\n+            return pos;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_info section.\n+     */\n+    public class DwarfInfoSectionImpl extends DwarfSectionImpl {\n+        /**\n+         * an info header section always contains a fixed number of bytes.\n+         */\n+        private static final int DW_DIE_HEADER_SIZE = 11;\n+\n+        public DwarfInfoSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_INFO_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            // we need a single level 0 DIE for each compilation unit (CU)\n+            // Each CU's Level 0 DIE is preceded by a fixed header:\n+            // and terminated by a null DIE\n+            // uint32 length ......... excluding this length field\n+            // uint16 dwarf_version .. always 2 ??\n+            // uint32 abbrev offset .. always 0 ??\n+            // uint8 address_size .... always 8\n+            // <DIE>* ................ sequence of top-level and nested child entries\n+            // <null_DIE> ............ == 0\n+            //\n+            // a DIE is a recursively defined structure\n+            // it starts with a code for the associated\n+            // abbrev entry followed by a series of attribute\n+            // values as determined by the entry terminated by\n+            // a null value and followed by zero or more child\n+            // DIEs (zero iff has_children == no_children)\n+            //\n+            // LEB128 abbrev_code != 0 .. non-zero value indexes tag + attr layout of DIE\n+            // <attribute_value>* ....... value sequence as determined by abbrev entry\n+            // <DIE>* ................... sequence of child DIEs (if appropriate)\n+            // <null_value> ............. == 0\n+            //\n+            // note that a null_DIE looks like\n+            // LEB128 abbrev_code ....... == 0\n+            // i.e. it also looks like a null_value\n+\n+            byte[] buffer = null;\n+            int pos = 0;\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // no need to backpatch length at lengthPos\n+            }\n+            buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_INFO\\n\", pos);\n+            debug(\"  [0x%08x] size = 0x%08x\\n\", pos, size);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                // save the offset of this file's CU so it can\n+                // be used when writing the aranges section\n+                classEntry.setCUIndex(pos);\n+                int lengthPos = pos;\n+                pos = writeCUHeader(buffer, pos);\n+                debug(\"  [0x%08x] Compilation Unit\\n\", pos, size);\n+                assert pos == lengthPos + DW_DIE_HEADER_SIZE;\n+                pos = writeCU(classEntry, buffer, pos);\n+                // backpatch length at lengthPos (excluding length field)\n+                patchLength(lengthPos, buffer, pos);\n+            }\n+            assert pos == size;\n+        }\n+\n+        public int writeCUHeader(byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                pos += putInt(0, scratch, 0);            // CU length\n+                pos += putShort(DW_VERSION_2, scratch, 0);  // dwarf version\n+                pos += putInt(0, scratch, 0);            // abbrev offset\n+                return pos + putByte((byte) 8, scratch, 0); // address size\n+            } else {\n+                pos = putInt(0, buffer, pos);                 // CU length\n+                pos = putShort(DW_VERSION_2, buffer, pos);       // dwarf version\n+                pos = putInt(0, buffer, pos);                 // abbrev offset\n+                return putByte((byte) 8, buffer, pos);           // address size\n+            }\n+        }\n+\n+        public int writeCU(ClassEntry classEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+            debug(\"  [0x%08x] <0> Abbrev Number %d\\n\", pos, DW_ABBREV_CODE_compile_unit);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_compile_unit, buffer, pos);\n+            debug(\"  [0x%08x]     language  %s\\n\", pos, \"DW_LANG_Java\");\n+            pos = writeAttrData1(DW_LANG_Java, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%x (%s)\\n\", pos, debugStringIndex(classEntry.getFileName()), classEntry.getFileName());\n+            pos = writeAttrStrp(classEntry.getFileName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, classPrimaryEntries.getFirst().getPrimary().getLo());\n+            pos = writeAttrAddress(classPrimaryEntries.getFirst().getPrimary().getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     hi_pc  0x%08x\\n\", pos, classPrimaryEntries.getLast().getPrimary().getHi());\n+            pos = writeAttrAddress(classPrimaryEntries.getLast().getPrimary().getHi(), buffer, pos);\n+            debug(\"  [0x%08x]     stmt_list  0x%08x\\n\", pos, classEntry.getLineIndex());\n+            pos = writeAttrData4(classEntry.getLineIndex(), buffer, pos);\n+            for (PrimaryEntry primaryEntry : classPrimaryEntries) {\n+                pos = writePrimary(primaryEntry, buffer, pos);\n+            }\n+            // write a terminating null attribute for the the level 2 primaries\n+            return writeAttrNull(buffer, pos);\n+\n+        }\n+\n+        public int writePrimary(PrimaryEntry primaryEntry, byte[] buffer, int p) {\n+            int pos = p;\n+            Range primary = primaryEntry.getPrimary();\n+            debug(\"  [0x%08x] <1> Abbrev Number  %d\\n\", pos, DW_ABBREV_CODE_subprogram);\n+            pos = writeAbbrevCode(DW_ABBREV_CODE_subprogram, buffer, pos);\n+            debug(\"  [0x%08x]     name  0x%X (%s)\\n\", pos, debugStringIndex(primary.getFullMethodName()), primary.getFullMethodName());\n+            pos = writeAttrStrp(primary.getFullMethodName(), buffer, pos);\n+            debug(\"  [0x%08x]     low_pc  0x%08x\\n\", pos, primary.getLo());\n+            pos = writeAttrAddress(primary.getLo(), buffer, pos);\n+            debug(\"  [0x%08x]     high_pc  0x%08x\\n\", pos, primary.getHi());\n+            pos = writeAttrAddress(primary.getHi(), buffer, pos);\n+            // need to pass true only if method is public\n+            debug(\"  [0x%08x]     external  true\\n\", pos);\n+            return writeFlag(DW_FLAG_true, buffer, pos);\n+        }\n+\n+        public int writeAttrStrp(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + putInt(0, scratch, 0);\n+            } else {\n+                int idx = debugStringIndex(value);\n+                return putInt(idx, buffer, pos);\n+            }\n+        }\n+\n+        public int writeAttrString(String value, byte[] buffer, int p) {\n+            int pos = p;\n+            if (buffer == null) {\n+                return pos + value.length() + 1;\n+            } else {\n+                return putAsciiStringBytes(value, buffer, pos);\n+            }\n+        }\n+\n+        @Override\n+        protected void debug(String format, Object... args) {\n+            if (((int) args[0] - debugBase) < 0x100000) {\n+                super.debug(format, args);\n+            } else if (format.startsWith(\"  [0x%08x] primary file\")) {\n+                super.debug(format, args);\n+            }\n+        }\n+\n+        /**\n+         * debug_info section content depends on abbrev section content and offset.\n+         */\n+        public static final String TARGET_SECTION_NAME = DW_ABBREV_SECTION_NAME;\n+\n+        @Override\n+        public String targetSectionName() {\n+            return TARGET_SECTION_NAME;\n+        }\n+\n+        public final LayoutDecision.Kind[] targetSectionKinds = {\n+                        LayoutDecision.Kind.CONTENT,\n+                        LayoutDecision.Kind.OFFSET\n+        };\n+\n+        @Override\n+        public LayoutDecision.Kind[] targetSectionKinds() {\n+            return targetSectionKinds;\n+        }\n+    }\n+\n+    /**\n+     * generator for debug_aranges section.\n+     */\n+    public class DwarfARangesSectionImpl extends DwarfSectionImpl {\n+        private static final int DW_AR_HEADER_SIZE = 12;\n+        private static final int DW_AR_HEADER_PAD_SIZE = 4; // align up to 2 * address size\n+\n+        public DwarfARangesSectionImpl() {\n+            super();\n+        }\n+\n+        @Override\n+        public String getSectionName() {\n+            return DW_ARANGES_SECTION_NAME;\n+        }\n+\n+        @Override\n+        public void createContent() {\n+            int pos = 0;\n+            // we need an entry for each compilation unit\n+            //\n+            // uint32 length ............ in bytes (not counting these 4 bytes)\n+            // uint16 dwarf_version ..... always 2\n+            // uint32 info_offset ....... offset of compilation unit on debug_info\n+            // uint8 address_size ....... always 8\n+            // uint8 segment_desc_size .. ???\n+            //\n+            // i.e. 12 bytes followed by padding\n+            // aligning up to 2 * address size\n+            //\n+            // uint8 pad[4]\n+            //\n+            // followed by N + 1 times\n+            //\n+            // uint64 lo ................ lo address of range\n+            // uint64 length ............ number of bytes in range\n+            //\n+            // where N is the number of ranges belonging to the compilation unit\n+            // and the last range contains two zeroes\n+\n+            for (ClassEntry classEntry : primaryClasses) {\n+                pos += DW_AR_HEADER_SIZE;\n+                // align to 2 * address size\n+                pos += DW_AR_HEADER_PAD_SIZE;\n+                pos += classEntry.getPrimaryEntries().size() * 2 * 8;\n+                pos += 2 * 8;\n+            }\n+            byte[] buffer = new byte[pos];\n+            super.setContent(buffer);\n+        }\n+\n+        @Override\n+        public byte[] getOrDecideContent(Map<Element, LayoutDecisionMap> alreadyDecided, byte[] contentHint) {\n+            Element textElement = getElement().getOwner().elementForName(\".text\");\n+            LayoutDecisionMap decisionMap = alreadyDecided.get(textElement);\n+            if (decisionMap != null) {\n+                Object valueObj = decisionMap.getDecidedValue(LayoutDecision.Kind.VADDR);\n+                if (valueObj != null && valueObj instanceof Number) {\n+                    // this may not be the final vaddr for the text segment\n+                    // but it will be close enough to make debug easier\n+                    // i.e. to within a 4k page or two\n+                    debugTextBase = ((Number) valueObj).longValue();\n+                }\n+            }\n+            return super.getOrDecideContent(alreadyDecided, contentHint);\n+        }\n+\n+        @Override\n+        public void writeContent() {\n+            byte[] buffer = getContent();\n+            int size = buffer.length;\n+            int pos = 0;\n+\n+            checkDebug(pos);\n+\n+            debug(\"  [0x%08x] DEBUG_ARANGES\\n\", pos);\n+            for (ClassEntry classEntry : primaryClasses) {\n+                int lastpos = pos;\n+                int length = DW_AR_HEADER_SIZE + DW_AR_HEADER_PAD_SIZE - 4;\n+                int cuIndex = classEntry.getCUIndex();\n+                LinkedList<PrimaryEntry> classPrimaryEntries = classEntry.getPrimaryEntries();\n+                // add room for each entry into length count\n+                length += classPrimaryEntries.size() * 2 * 8;\n+                length += 2 * 8;\n+                debug(\"  [0x%08x] %s CU %d length 0x%x\\n\", pos, classEntry.getFileName(), cuIndex, length);\n+             ", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NjQwNw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r377776407", "bodyText": "Yes, uses of file names and paths are now converted at the point of use.", "author": "adinn", "createdAt": "2020-02-11T17:12:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NDk2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NTYzMQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372385631", "bodyText": "Strings ...", "author": "olpaw", "createdAt": "2020-01-29T13:38:12Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/FileEntry.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+/**\n+ * track debug info associated with a Java source file.\n+ */\n+public class FileEntry {\n+    // the name of the associated file including path\n+    private String fileName;\n+    // the name of the associated file excluding path\n+    private String baseName;\n+    // the directory entry associated with this file entry\n+    DirEntry dirEntry;\n+\n+    public FileEntry(String fileName, String baseName, DirEntry dirEntry) {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NjU4NQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r377776585", "bodyText": "See the last commit.", "author": "adinn", "createdAt": "2020-02-11T17:13:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NTYzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3NTY1Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r383975656", "bodyText": "Yes, now using Path. See other comments", "author": "adinn", "createdAt": "2020-02-25T16:03:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NTYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NjIzMQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372386231", "bodyText": "Always start JavaDoc with capital letter.", "author": "olpaw", "createdAt": "2020-01-29T13:39:26Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/PrimaryEntry.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+/**\n+ * track debug info associated with a primary method.", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Nzc3NzM1MA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r377777350", "bodyText": "I have done a global update to all Javadoc and will endeavour to stick to this from now on. I will do a final pass once the other comments have been addressed.", "author": "adinn", "createdAt": "2020-02-11T17:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4NjIzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4ODQwOA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372388408", "bodyText": "afaics this is the only thing used atm, right?", "author": "olpaw", "createdAt": "2020-01-29T13:43:27Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java", "diffHunk": "@@ -952,4 +973,299 @@ protected NativeTextSectionImpl(RelocatableBuffer relocatableBuffer, ObjectFile\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n+\n+    /**\n+     * implementation of the DebugInfoProvider API interface\n+     * that allows type, code and heap data info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n+        private final NativeImageCodeCache codeCache;\n+        private final NativeImageHeap heap;\n+        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n+        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n+\n+        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n+            super();\n+            this.codeCache = codeCache;\n+            this.heap = heap;\n+            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n+            this.heapIterator = heap.objects.entrySet().iterator();\n+        }\n+\n+        @Override\n+        public DebugTypeInfoProvider typeInfoProvider() {\n+            return () -> new Iterator<DebugTypeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugTypeInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugCodeInfoProvider codeInfoProvider() {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTc5NzY1OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375797658", "bodyText": "Yes, at present. However, the plan is to also allow the debug writer to iterate over types and details of heap contents courtesy of a DebugTypeInfoProvider and DebugDataInfoProvider. The details of those interfaces still need to be fully worked out.", "author": "adinn", "createdAt": "2020-02-06T12:07:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM4ODQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372390309", "bodyText": "In Java 11 the module base-name is also part of the full file path with the src.zip. e.g.\nsrc.zip contains /java.base/java/util/Set.class", "author": "olpaw", "createdAt": "2020-01-29T13:47:11Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java", "diffHunk": "@@ -952,4 +973,299 @@ protected NativeTextSectionImpl(RelocatableBuffer relocatableBuffer, ObjectFile\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n+\n+    /**\n+     * implementation of the DebugInfoProvider API interface\n+     * that allows type, code and heap data info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n+        private final NativeImageCodeCache codeCache;\n+        private final NativeImageHeap heap;\n+        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n+        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n+\n+        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n+            super();\n+            this.codeCache = codeCache;\n+            this.heap = heap;\n+            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n+            this.heapIterator = heap.objects.entrySet().iterator();\n+        }\n+\n+        @Override\n+        public DebugTypeInfoProvider typeInfoProvider() {\n+            return () -> new Iterator<DebugTypeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugTypeInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugCodeInfoProvider codeInfoProvider() {\n+            return () -> new Iterator<DebugCodeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return codeCacheIterator.hasNext();\n+                }\n+\n+                @Override\n+                public DebugCodeInfo next() {\n+                    Map.Entry<HostedMethod, CompilationResult> entry = codeCacheIterator.next();\n+                    return new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue());\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugDataInfoProvider dataInfoProvider() {\n+            return () -> new Iterator<DebugDataInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugDataInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugCodeInfo API interface\n+     * that allows code info to be passed to an ObjectFile\n+     * when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n+        private final HostedMethod method;\n+        private final CompilationResult compilation;\n+\n+        NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n+            this.method = method;\n+            this.compilation = compilation;\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            HostedType declaringClass = method.getDeclaringClass();", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODI2MTAwOA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378261008", "bodyText": "Well, I finally managed to rebuild using jdk11 (I had to nuke all the mxbuild dirs to get it to stop using cached jdk8 code) and found out some interesting things about pathe that probably need to be discussed and decided upon.\nI tweaked the path generation to add the result of ModuleSupport.getModuleName(javaClass) to the head of the path expression. So, for jdk11 runtime classes that will add e.g. \"java.base\" to the list of Path elements whereas for jdk8 runtime classes it will add nothing since  the module name is returned as \"\". This means that unzipped jdk sources are now being located correctly on both jdk8 and jdk11 assuming the root dir for the unzipped src.zip is added to the source path.\nI prefixed the module name to the file path for all classes that belong to a module on the assumption that this action would only apply for JDK runtime code. However, this assumption is not strictly correct as some Graal classes reside in JDK runtime modules.\nI noticed that, for example, class AllocationSnippets in package org/graalvm/compiler/replacements turns out to belong to module jdk.internal.vm.compiler. The source for this class actually sits in the Graal tree under root compiler/src/org.graalvm.compiler.replacements/src. Another example is class PrefetchAllocateNode which also belongs to module jdk.internal.vm.compiler. The source for this class also sits in the Graal tree under root compiler/src/org.graalvm.compiler.nodes/src.\nI also noticed that various of the Graal class sources are bundled into the src.zip for the jdk11 release I am using (labsjdk-ce-11.0.6+9-jvmci-20.0-b02-linux-amd64) and indeed are bundled into stock jdk11u releases. The source for PrefetchAllocateNode is present under root jdk.internal.vm.compiler/org.graalvm.compiler.nodes/src. However, the source for AllocationSnippets is not present. It looks as if these are present by because they are present in the OpenJDK repo (which may explain why AllocationSnippets.java is missing).\nSo, in order to find the correct versions of these sources from the Graal tree rather than from the OpenJDK src.zip it appears I will need to special case classes that are in certain well-known org.graal and com.oracle packages and not prefix the module to the file path for those cases. For example, the file path for PrefetchAllocateNode will need to be org/graalvm/compiler/nodes rather than jdk.internal.vm.compiler/org/graalvm/compiler/nodes.\nIn order to minimize the number of source roots needed to locate Graal sources it might also be helpful to insert the required overarching src root into the file path. For example, PrefetchAllocateNode might be better associated with file path org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/. That would  mean that only  compiler/src, substratevm/src etc would need to be supplied as source root dirs.\nThe difficutly with this is that it is not always clear what the oevrarching top level directory needs to be. For example, class CodeInfo.java sits under dir com.oracle.svm.core/src but resides in subdir com/oracle/svm/core/code because its is in a subpackage com.oracle.svm.core.code. Given any Graal class the overarching root dir always comprises some initial segment of the package name but it is not always clear which elements to include. This is slightly complicated by the need to recognize that classes in package com.oracle.svm.core.code map to root dir com.oracle.svm.core/src but that classes in package com.oracle.svm.core.graal map to root dir com.oracle.svm.core.graal/src\nI did actually implement a variant of the filepath computation some while back which used a hard-wired list of known root packages. I could easily do that again. However, the problem is keeping the list of source roots up to date with any changes. Do you have any other suggestions as to how to do this? Input from other Graal community devs woudl be very welcome.", "author": "adinn", "createdAt": "2020-02-12T13:50:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMxNTAxNw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378315017", "bodyText": "This means that unzipped jdk sources are now being located correctly on both jdk8 and jdk11 assuming the root dir for the unzipped src.zip is added to the source path.\n\nUnzipping should happen transparently. Just use Zip File System Provider instead of requiring the user to unzip src.zip. See https://docs.oracle.com/javase/7/docs/technotes/guides/io/fsp/zipfilesystemprovider.html - For examples in our code base where we make use of Zip File System Provider see e.g. com.oracle.svm.driver.NativeImage#processClasspathNativeImageMetaInf(java.nio.file.Path, com.oracle.svm.driver.NativeImage.NativeImageMetaInfResourceProcessor)", "author": "olpaw", "createdAt": "2020-02-12T15:14:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMyNTgyMQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378325821", "bodyText": "Another example is class PrefetchAllocateNode which also belongs to module jdk.internal.vm.compiler. The source for this class also sits in the Graal tree under root compiler/src/org.graalvm.compiler.nodes/src.\n\nAs you noticed even vanilla JDK11 releases contain Graal. For debuginfo generation this version of Graal should be ignored (it exists so that vanilla JDK can provide Graal as tier-4 JIT compiler when using -XX:+UnlockExperimentalVMOptions -XX:+UseJVMCICompiler). When we build native images we always use the version of Graal that is shipped as part of a GraalVM release. Thus any Graal related source files that exist in src.zip are irrelevant for us.", "author": "olpaw", "createdAt": "2020-02-12T15:30:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODMzNDA5NQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378334095", "bodyText": "However, the problem is keeping the list of source roots up to date with any changes.\n\nSure you could diff each file do decide if you need to update a preexisting target file but it is probably easier to simply copy over based on timestamps (if src or zip file that contains src is newer -> update)", "author": "olpaw", "createdAt": "2020-02-12T15:42:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODM3MjY3Mw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378372673", "bodyText": "source roots needed to locate Graal sources\n\nA good heuristic for the roots is to inspect the jar files that are on the image classpath and check if you find a corresponding sibling file. E.g. for <graalvm>/lib/svm/builder/svm.jar you probe for <graalvm>/lib/svm/builder/svm.src.zip. If the classpath entry is a directory <dir> instead you probe for <dir>/src and <dir>/src_gen as roots. For each source file lookup you check against these roots for a match. (src.zip from jdk is a special case and should always be in the list of roots (obviously as last entry))", "author": "olpaw", "createdAt": "2020-02-12T16:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc3NDAzNg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378774036", "bodyText": "Unzipping should happen transparently. Just use Zip File System Provider instead of requiring the user to unzip src.zip. See https://docs.oracle.com/javase/7/docs/technotes/guides/io/fsp/zipfilesystemprovider.html - For examples in our code base where we make use of Zip File System Provider see e.g. com.oracle.svm.driver.NativeImage#processClasspathNativeImageMetaInf(java.nio.file.Path, com.oracle.svm.driver.NativeImage.NativeImageMetaInfResourceProcessor)\n\nI'm not clear what you are suggesting here. I understand how to use a zip file provider from Java. However, the problem I am looking at is how to allow gdb to locate a source file for a JDK class when it is running. gdb needs to be pointed at a root directory under which it can locate the sources. It is not going to unzip any files to do that.\nI believe the model you are proposing for resolving that requirement is that the native image generator should attempt to locate all the relevant JDK, Graal (and, perhaps, application) source files at image build time, bundling them into a jar/zip file provided as a secondary deliverable. If that jar/zip deliverable is correctly structured then it could be unzipped into a single root source directory from which all file paths and name nstalled into the debuginfo could be successfully resolved to the required source file at debug time. Is that a fair summary?\n\nA good heuristic for the roots is to inspect the jar files that are on the image classpath and check if you find a corresponding sibling file. E.g. for /lib/svm/builder/svm.jar you probe for /lib/svm/builder/svm.src.zip. If the classpath entry is a directory  instead you probe for /src and /src_gen as roots. For each source file lookup you check against these roots for a match. (src.zip from jdk is a special case and should always be in the list of roots (obviously as last entry))\n\nYes, I am sure I can implement a lookup model like that.\n\nAs you noticed even vanilla JDK11 releases contain Graal.  . . . Thus any Graal related source files that exist in src.zip are irrelevant for us.\n\nYes, I will ignore those files.", "author": "adinn", "createdAt": "2020-02-13T10:29:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODc5NjA3NA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378796074", "bodyText": "I'm not clear what you are suggesting here.\n\nI'm just saying the mechanism should be able to process zip-files, jar-files & directories alike as inputs (roots) and copy files referenced in debuginfo (--x-->) from those roots into one single output directory (preferably named sources) (the one that gdb will then use for file retrival):\n[... foo/prjx/src]\n[... foo/lib/gson.sources.jar]\n[...]                                           --x-->     [... foo/sources]\n[<graalvm>/lib/svm/builder/svm.src.zip]\n[<graalvm> ...]\n[<graalvm>/src.zip]\n\n(assuming an image gets built to ... foo (e.g. ... foo/myimage)\n\nbundling them into a jar/zip file\n\nJust building them into a sources sibling directory next to the image so that gdb can use it as is (also a directory is easier to keep up to date with changes from the roots side if you are rebuilding the image).", "author": "olpaw", "createdAt": "2020-02-13T11:10:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODgwMTAwMg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378801002", "bodyText": "Ok, that sounds fine. I'll work on adding that.", "author": "adinn", "createdAt": "2020-02-13T11:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODgyMDE4Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r378820186", "bodyText": "n.b. I just updated the issue to record this conversation with a more precise 'spec'", "author": "adinn", "createdAt": "2020-02-13T12:05:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3MzI5Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r383973296", "bodyText": "This has now been implemented -- see my other comment", "author": "adinn", "createdAt": "2020-02-25T16:00:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjM5MDMwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQwNjcwOA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372406708", "bodyText": "Sometimes the source file isn't actually a .java file.  Is there any way to get access to the source name that was specified in the original .class file?  Or is this code only used when there is no debug info available?", "author": "dmlloyd", "createdAt": "2020-01-29T14:17:29Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java", "diffHunk": "@@ -952,4 +973,299 @@ protected NativeTextSectionImpl(RelocatableBuffer relocatableBuffer, ObjectFile\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n+\n+    /**\n+     * implementation of the DebugInfoProvider API interface\n+     * that allows type, code and heap data info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n+        private final NativeImageCodeCache codeCache;\n+        private final NativeImageHeap heap;\n+        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n+        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n+\n+        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n+            super();\n+            this.codeCache = codeCache;\n+            this.heap = heap;\n+            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n+            this.heapIterator = heap.objects.entrySet().iterator();\n+        }\n+\n+        @Override\n+        public DebugTypeInfoProvider typeInfoProvider() {\n+            return () -> new Iterator<DebugTypeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugTypeInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugCodeInfoProvider codeInfoProvider() {\n+            return () -> new Iterator<DebugCodeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return codeCacheIterator.hasNext();\n+                }\n+\n+                @Override\n+                public DebugCodeInfo next() {\n+                    Map.Entry<HostedMethod, CompilationResult> entry = codeCacheIterator.next();\n+                    return new NativeImageDebugCodeInfo(entry.getKey(), entry.getValue());\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugDataInfoProvider dataInfoProvider() {\n+            return () -> new Iterator<DebugDataInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugDataInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugCodeInfo API interface\n+     * that allows code info to be passed to an ObjectFile\n+     * when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugCodeInfo implements DebugCodeInfo {\n+        private final HostedMethod method;\n+        private final CompilationResult compilation;\n+\n+        NativeImageDebugCodeInfo(HostedMethod method, CompilationResult compilation) {\n+            this.method = method;\n+            this.compilation = compilation;\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            HostedType declaringClass = method.getDeclaringClass();\n+            String name = declaringClass.getSourceFileName();\n+            if (name != null) {\n+                // the file name will not include any path\n+                // use the package to create a path prefix\n+                Package pkg = declaringClass.getJavaClass().getPackage();\n+                if (pkg != null) {\n+                    String prefix = pkg.getName();\n+                    prefix = prefix.replace('.', '/');\n+                    name = prefix + \"/\" + name;\n+                }\n+            } else {\n+                // build file name from the class name which includes the package\n+                name = className();\n+                // try to map inner classes back to their parent class's file\n+                int idx = name.indexOf('$');\n+                if (idx == 0) {\n+                    // name is $XXX so cannot associate with a file\n+                    return \"\";\n+                }\n+                if (idx > 0) {\n+                    // name is XXX$YYY so use outer class to derive file name\n+                    name = name.substring(0, idx);\n+                }\n+                name = name.replace('.', '/') + \".java\";\n+            }\n+            return name;\n+        }\n+\n+        @Override\n+        public String className() {\n+            return method.format(\"%H\");\n+        }\n+\n+        @Override\n+        public String methodName() {\n+            return method.format(\"%n\");\n+        }\n+\n+        @Override\n+        public String paramNames() {\n+            return method.format(\"%P\");\n+        }\n+\n+        @Override\n+        public String returnTypeName() {\n+            return method.format(\"%R\");\n+        }\n+\n+        @Override\n+        public int addressLo() {\n+            return method.getCodeAddressOffset();\n+        }\n+\n+        @Override\n+        public int addressHi() {\n+            return method.getCodeAddressOffset() + compilation.getTargetCodeSize();\n+        }\n+\n+        @Override\n+        public int line() {\n+            LineNumberTable lineNumberTable = method.getLineNumberTable();\n+            if (lineNumberTable != null) {\n+                return lineNumberTable.getLineNumber(0);\n+            }\n+            return -1;\n+        }\n+\n+        @Override\n+        public DebugInfoProvider.DebugLineInfoProvider lineInfoProvider() {\n+            if (fileName().length() == 0) {\n+                return () -> new Iterator<DebugLineInfo>() {\n+                    @Override\n+                    public boolean hasNext() {\n+                        return false;\n+                    }\n+\n+                    @Override\n+                    public DebugLineInfo next() {\n+                        return null;\n+                    }\n+                };\n+            }\n+            return () -> new Iterator<DebugLineInfo>() {\n+                final Iterator<SourceMapping> sourceIterator = compilation.getSourceMappings().iterator();\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return sourceIterator.hasNext();\n+                }\n+\n+                @Override\n+                public DebugLineInfo next() {\n+                    return new NativeImageDebugLineInfo(sourceIterator.next());\n+                }\n+            };\n+        }\n+\n+        public int getFrameSize() {\n+            return compilation.getTotalFrameSize();\n+        }\n+\n+        public List<DebugFrameSizeChange> getFrameSizeChanges() {\n+            List<DebugFrameSizeChange> frameSizeChanges = new LinkedList<>();\n+            for (Mark mark : compilation.getMarks()) {\n+                // we only need to observe stack increment or decrement points\n+                if (mark.id.equals(\"PROLOGUE_DECD_RSP\")) {\n+                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, EXTEND);\n+                    frameSizeChanges.add(sizeChange);\n+                    // } else if (mark.id.equals(\"PROLOGUE_END\")) {\n+                    // can ignore these\n+                    // } else if (mark.id.equals(\"EPILOGUE_START\")) {\n+                    // can ignore these\n+                } else if (mark.id.equals(\"EPILOGUE_INCD_RSP\")) {\n+                    NativeImageDebugFrameSizeChange sizeChange = new NativeImageDebugFrameSizeChange(mark.pcOffset, CONTRACT);\n+                    frameSizeChanges.add(sizeChange);\n+                    // } else if(mark.id.equals(\"EPILOGUE_END\")) {\n+                }\n+            }\n+            return frameSizeChanges;\n+        }\n+    }\n+\n+    /**\n+     * implementation of the DebugLineInfo API interface\n+     * that allows line number info to be passed to an\n+     * ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugLineInfo implements DebugLineInfo {\n+        private final int bci;\n+        private final ResolvedJavaMethod method;\n+        private final int lo;\n+        private final int hi;\n+\n+        NativeImageDebugLineInfo(SourceMapping sourceMapping) {\n+            NodeSourcePosition position = sourceMapping.getSourcePosition();\n+            int bci = position.getBCI();\n+            this.bci = (bci >= 0 ? bci : 0);\n+            this.method = position.getMethod();\n+            this.lo = sourceMapping.getStartOffset();\n+            this.hi = sourceMapping.getEndOffset();\n+        }\n+\n+        @Override\n+        public String fileName() {\n+            String name = className();\n+            int idx = name.indexOf('$');\n+            if (idx == 0) {\n+                // name is $XXX so cannot associate with a file\n+                return \"\";\n+            }\n+            if (idx > 0) {\n+                // name is XXX$YYY so use outer class to derive file name\n+                name = name.substring(0, idx);\n+            }\n+            return name.replace('.', '/') + \".java\";", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTg3OTc3Nw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375879777", "bodyText": "That's what is going on here. The call to declaringClass.getSourceFileName() actually reads the value from the class file -- well, strictly it finds the underlying Java class and reads the name out of the constant poll associated with the corresponding JVM InstanceKlass. So the code that constructs a name with extension java is just a fallback for when the bytecode contains no such entry.", "author": "adinn", "createdAt": "2020-02-06T14:53:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQwNjcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkxOTEyMw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375919123", "bodyText": "Ah, understood.  Thanks!", "author": "dmlloyd", "createdAt": "2020-02-06T15:53:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQwNjcwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3NDMwNA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r383974304", "bodyText": "This has been reworked but the new code is still using the classfile info where it exists and defaulting to append .java to the class name (or its initial segment up to $) otherwise.", "author": "adinn", "createdAt": "2020-02-25T16:01:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQwNjcwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyOTIwMQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372429201", "bodyText": "How about something more modern than Iterable. E.g. like:\n@Override\npublic Stream<DebugCodeInfo> codeInfoProvider() {\n    return compilations.entrySet().stream().map(NativeImageDebugCodeInfo::new);\n}", "author": "olpaw", "createdAt": "2020-01-29T14:54:03Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/NativeBootImage.java", "diffHunk": "@@ -952,4 +973,299 @@ protected NativeTextSectionImpl(RelocatableBuffer relocatableBuffer, ObjectFile\n         protected final ObjectFile objectFile;\n         protected final NativeImageCodeCache codeCache;\n     }\n+\n+    /**\n+     * implementation of the DebugInfoProvider API interface\n+     * that allows type, code and heap data info to be passed to\n+     * an ObjectFile when generation of debug info is enabled.\n+     */\n+    private class NativeImageDebugInfoProvider implements DebugInfoProvider {\n+        private final NativeImageCodeCache codeCache;\n+        private final NativeImageHeap heap;\n+        private final Iterator<Map.Entry<HostedMethod, CompilationResult>> codeCacheIterator;\n+        private final Iterator<Map.Entry<Object, ObjectInfo>> heapIterator;\n+\n+        NativeImageDebugInfoProvider(NativeImageCodeCache codeCache, NativeImageHeap heap) {\n+            super();\n+            this.codeCache = codeCache;\n+            this.heap = heap;\n+            this.codeCacheIterator = codeCache.compilations.entrySet().iterator();\n+            this.heapIterator = heap.objects.entrySet().iterator();\n+        }\n+\n+        @Override\n+        public DebugTypeInfoProvider typeInfoProvider() {\n+            return () -> new Iterator<DebugTypeInfo>() {\n+                @Override\n+                public boolean hasNext() {\n+                    return false;\n+                }\n+\n+                @Override\n+                public DebugTypeInfo next() {\n+                    return null;\n+                }\n+            };\n+        }\n+\n+        @Override\n+        public DebugCodeInfoProvider codeInfoProvider() {", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjMzMjAzMA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r376332030", "bodyText": "Yes, that would be neater.", "author": "adinn", "createdAt": "2020-02-07T10:56:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyOTIwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk3MTc0Mg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r383971742", "bodyText": "@olpaw I just pushed another fix where I modified the DebugInfo interfaces to use Stream and tweaked the producers and consumers accordingly.", "author": "adinn", "createdAt": "2020-02-25T15:57:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQyOTIwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzMjY2OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r372432668", "bodyText": "Does DWARF have a fixed endianness, or should it be using the ELFDATA value to determine this?", "author": "dmlloyd", "createdAt": "2020-01-29T14:59:28Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSections.java", "diffHunk": "@@ -0,0 +1,2344 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfo;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugCodeInfoProvider;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugDataInfoProvider;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugFrameSizeChange;\n+import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugLineInfo;\n+// import com.oracle.objectfile.debuginfo.DebugInfoProvider.DebugTypeInfoProvider;\n+import com.oracle.objectfile.ObjectFile.Element;\n+import com.oracle.objectfile.elf.ELFMachine;\n+import com.oracle.objectfile.elf.ELFObjectFile.ELFSection;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * an outer class that models the debug info in an\n+ * organization that facilitates generation of the\n+ * required DWARF sections. It groups common data and\n+ * behaviours for use by the various subclasses of\n+ * inner class DwarfSectionImpl that take responsibility\n+ * for generating content for a specific section type.\n+ */\n+public class DwarfSections {\n+    // names of the different ELF sections we create or reference\n+    // in reverse dependency order\n+    public static final String TEXT_SECTION_NAME = \".text\";\n+    public static final String DW_STR_SECTION_NAME = \".debug_str\";\n+    public static final String DW_LINE_SECTION_NAME = \".debug_line\";\n+    public static final String DW_FRAME_SECTION_NAME = \".debug_frame\";\n+    public static final String DW_ABBREV_SECTION_NAME = \".debug_abbrev\";\n+    public static final String DW_INFO_SECTION_NAME = \".debug_info\";\n+    public static final String DW_ARANGES_SECTION_NAME = \".debug_aranges\";\n+\n+    /**\n+     * currently generated debug info relies on DWARF spec vesion 2.\n+     */\n+    private static final short DW_VERSION_2 = 2;\n+\n+    // define all the abbrev section codes we need for our DIEs\n+    // private static final int DW_ABBREV_CODE_null = 0;\n+    private static final int DW_ABBREV_CODE_compile_unit = 1;\n+    private static final int DW_ABBREV_CODE_subprogram = 2;\n+\n+    // define all the Dwarf tags we need for our DIEs\n+    private static final int DW_TAG_compile_unit = 0x11;\n+    private static final int DW_TAG_subprogram = 0x2e;\n+    // define all the Dwarf attributes we need for our DIEs\n+    private static final int DW_AT_null = 0x0;\n+    private static final int DW_AT_name = 0x3;\n+    // private static final int DW_AT_comp_dir = 0x1b;\n+    private static final int DW_AT_stmt_list = 0x10;\n+    private static final int DW_AT_low_pc = 0x11;\n+    private static final int DW_AT_hi_pc = 0x12;\n+    private static final int DW_AT_language = 0x13;\n+    private static final int DW_AT_external = 0x3f;\n+    // private static final int DW_AT_return_addr = 0x2a;\n+    // private static final int DW_AT_frame_base = 0x40;\n+    // define all the Dwarf attribute forms we need for our DIEs\n+    private static final int DW_FORM_null = 0x0;\n+    // private static final int DW_FORM_string = 0x8;\n+    private static final int DW_FORM_strp = 0xe; // not currently used\n+    private static final int DW_FORM_addr = 0x1;\n+    private static final int DW_FORM_data1 = 0x0b; // use flag instead\n+    private static final int DW_FORM_data4 = 0x6;\n+    // private static final int DW_FORM_data8 = 0x7;\n+    // private static final int DW_FORM_block1 = 0x0a;\n+    private static final int DW_FORM_flag = 0xc;\n+\n+    // define specific attribute values for given attribute or form types\n+    // DIE header has_children attribute values\n+    private static final byte DW_CHILDREN_no = 0;\n+    private static final byte DW_CHILDREN_yes = 1;\n+    // DW_FORM_flag attribute values\n+    // private static final byte DW_FLAG_false = 0;\n+    private static final byte DW_FLAG_true = 1;\n+    // value for DW_AT_language attribute with form DATA1\n+    private static final byte DW_LANG_Java = 0xb;\n+    // access not needed until we make functions members\n+    // DW_AT_Accessibility attribute values\n+    // private static final byte DW_ACCESS_public = 1;\n+    // private static final byte DW_ACCESS_protected = 2;\n+    // private static final byte DW_ACCESS_private = 3;\n+\n+    // not yet needed\n+    // private static final int DW_AT_type = 0; // only present for non-void functions\n+    // private static final int DW_AT_accessibility = 0;\n+\n+    // CIE and FDE entries\n+\n+    private static final int DW_CFA_CIE_id = -1;\n+    // private static final int DW_CFA_FDE_id = 0;\n+\n+    private static final byte DW_CFA_CIE_version = 1;\n+\n+    // values for high 2 bits\n+    private static final byte DW_CFA_advance_loc = 0x1;\n+    private static final byte DW_CFA_offset = 0x2;\n+    // private static final byte DW_CFA_restore = 0x3;\n+\n+    // values for low 6 bits\n+    private static final byte DW_CFA_nop = 0x0;\n+    // private static final byte DW_CFA_set_loc1 = 0x1;\n+    private static final byte DW_CFA_advance_loc1 = 0x2;\n+    private static final byte DW_CFA_advance_loc2 = 0x3;\n+    private static final byte DW_CFA_advance_loc4 = 0x4;\n+    // private static final byte DW_CFA_offset_extended = 0x5;\n+    // private static final byte DW_CFA_restore_extended = 0x6;\n+    // private static final byte DW_CFA_undefined = 0x7;\n+    // private static final byte DW_CFA_same_value = 0x8;\n+    private static final byte DW_CFA_register = 0x9;\n+    private static final byte DW_CFA_def_cfa = 0xc;\n+    // private static final byte DW_CFA_def_cfa_register = 0xd;\n+    private static final byte DW_CFA_def_cfa_offset = 0xe;\n+\n+    private ELFMachine elfMachine;\n+    private DwarfStrSectionImpl dwarfStrSection;\n+    private DwarfAbbrevSectionImpl dwarfAbbrevSection;\n+    private DwarfInfoSectionImpl dwarfInfoSection;\n+    private DwarfARangesSectionImpl dwarfARangesSection;\n+    private DwarfLineSectionImpl dwarfLineSection;\n+    private DwarfFrameSectionImpl dwarfFameSection;\n+\n+    public DwarfSections(ELFMachine elfMachine) {\n+        this.elfMachine = elfMachine;\n+        dwarfStrSection = new DwarfStrSectionImpl();\n+        dwarfAbbrevSection = new DwarfAbbrevSectionImpl();\n+        dwarfInfoSection = new DwarfInfoSectionImpl();\n+        dwarfARangesSection = new DwarfARangesSectionImpl();\n+        dwarfLineSection = new DwarfLineSectionImpl();\n+        dwarfFameSection = (elfMachine == ELFMachine.AArch64\n+                        ? new DwarfFrameSectionImplAArch64()\n+                        : new DwarfFrameSectionImplX86_64());\n+    }\n+\n+    public DwarfStrSectionImpl getStrSectionImpl() {\n+        return dwarfStrSection;\n+    }\n+\n+    public DwarfAbbrevSectionImpl getAbbrevSectionImpl() {\n+        return dwarfAbbrevSection;\n+    }\n+\n+    public DwarfFrameSectionImpl getFrameSectionImpl() {\n+        return dwarfFameSection;\n+    }\n+\n+    public DwarfInfoSectionImpl getInfoSectionImpl() {\n+        return dwarfInfoSection;\n+    }\n+\n+    public DwarfARangesSectionImpl getARangesSectionImpl() {\n+        return dwarfARangesSection;\n+    }\n+\n+    public DwarfLineSectionImpl getLineSectionImpl() {\n+        return dwarfLineSection;\n+    }\n+\n+    public ELFMachine getElfMachine() {\n+        return elfMachine;\n+    }\n+\n+    /**\n+     * a scratch buffer used during computation of a section's size.\n+     */\n+    protected static final byte[] scratch = new byte[10];\n+\n+    /**\n+     * a table listing all known strings, some of\n+     * which may be marked for insertion into the\n+     * debug_str section.\n+     */\n+    private StringTable stringTable = new StringTable();\n+\n+    /**\n+     * list detailing all dirs in which files are found to reside\n+     * either as part of substrate/compiler or user code.\n+     */\n+    private LinkedList<DirEntry> dirs = new LinkedList<>();\n+    /**\n+     * index of already seen dirs.\n+     */\n+    private Map<String, DirEntry> dirsIndex = new HashMap<>();\n+\n+    // The obvious traversal structure for debug records is:\n+    //\n+    // 1) by top level compiled method (primary Range) ordered by ascending address\n+    // 2) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this ensures that all debug records are generated in increasing address order\n+\n+    /**\n+     * a list recording details of all primary ranges included in\n+     * this file sorted by ascending address range.\n+     */\n+    private LinkedList<PrimaryEntry> primaryEntries = new LinkedList<>();\n+\n+    // An alternative traversal option is\n+    // 1) by top level class (String id)\n+    // 2) by top level compiled method (primary Range) within a class ordered by ascending address\n+    // 3) by inlined method (sub range) within top level method ordered by ascending address\n+    //\n+    // this relies on the (current) fact that methods of a given class always appear\n+    // in a single continuous address range with no intervening code from other methods\n+    // or data values. this means we can treat each class as a compilation unit, allowing\n+    // data common to all methods of the class to be shared.\n+    //\n+    // Unfortunately, files cannot be treated as the compilation unit. A file F may contain\n+    // multiple classes, say C1 and C2. There is no guarantee that methods for some other\n+    // class C' in file F' will not be compiled into the address space interleaved between\n+    // methods of C1 and C2. That is a shame because generating debug info records one file at a\n+    // time would allow more sharing e.g. enabling all classes in a file to share a single copy\n+    // of the file and dir tables.\n+\n+    /**\n+     * list of class entries detailing class info for primary ranges.\n+     */\n+    private LinkedList<ClassEntry> primaryClasses = new LinkedList<>();\n+    /**\n+     *  index of already seen classes.\n+     */\n+    private Map<String, ClassEntry> primaryClassesIndex = new HashMap<>();\n+\n+    /**\n+     * list of files which contain primary ranges.\n+     */\n+    private LinkedList<FileEntry> primaryFiles = new LinkedList<>();\n+    /**\n+     * List of files which contain primary or secondary ranges.\n+     */\n+    private LinkedList<FileEntry> files = new LinkedList<>();\n+    /**\n+     * index of already seen files.\n+     */\n+    private Map<String, FileEntry> filesIndex = new HashMap<>();\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string to be inserted\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueString(String string) {\n+        return stringTable.uniqueString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table, ensuring\n+     * the table entry is marked for inclusion in the\n+     * debug_str section.\n+     * @param string the string to be inserted and\n+     * marked for inclusion in the debug_str section\n+     * @return a unique equivalent String\n+     */\n+    public String uniqueDebugString(String string) {\n+        return stringTable.uniqueDebugString(string);\n+    }\n+\n+    /**\n+     * indirects this call to the string table.\n+     * @param string the string whose index is required\n+     * @return the offset of the string in the .debug_str\n+     * section\n+     */\n+    private int debugStringIndex(String string) {\n+        return stringTable.debugStringIndex(string);\n+    }\n+\n+    /**\n+     * entry point allowing ELFObjectFile to pass on information\n+     * about types, code and heap data.\n+     * @param debugInfoProvider provider instance passed by\n+     * ObjectFile client\n+     */\n+    public void installDebugInfo(DebugInfoProvider debugInfoProvider) {\n+        // DebugTypeInfoProvider typeInfoProvider = debugInfoProvider.typeInfoProvider();\n+        // for (DebugTypeInfo debugTypeInfo : typeInfoProvider) {\n+        // install types\n+        // }\n+\n+        // ensure we have a null string in the string section\n+        uniqueDebugString(\"\");\n+\n+        DebugCodeInfoProvider codeInfoProvider = debugInfoProvider.codeInfoProvider();\n+        for (DebugCodeInfo debugCodeInfo : codeInfoProvider) {\n+            // primary file name and full method name need to be written to the debug_str section\n+            String fileName = debugCodeInfo.fileName();\n+            String className = debugCodeInfo.className();\n+            String methodName = debugCodeInfo.methodName();\n+            String paramNames = debugCodeInfo.paramNames();\n+            String returnTypeName = debugCodeInfo.returnTypeName();\n+            int lo = debugCodeInfo.addressLo();\n+            int hi = debugCodeInfo.addressHi();\n+            int primaryLine = debugCodeInfo.line();\n+            Range primaryRange = new Range(fileName, className, methodName, paramNames, returnTypeName, stringTable, lo, hi, primaryLine);\n+            // System.out.format(\"arange: [0x%08x,0x%08x) %s %s::%s(%s) %s\\n\", lo, hi,\n+            // returnTypeName, className, methodName, paramNames, fileName);\n+            // create an infoSection entry for the method\n+            addRange(primaryRange, debugCodeInfo.getFrameSizeChanges(), debugCodeInfo.getFrameSize());\n+            for (DebugLineInfo debugLineInfo : debugCodeInfo.lineInfoProvider()) {\n+                String fileNameAtLine = debugLineInfo.fileName();\n+                String classNameAtLine = debugLineInfo.className();\n+                String methodNameAtLine = debugLineInfo.methodName();\n+                int loAtLine = lo + debugLineInfo.addressLo();\n+                int hiAtLine = lo + debugLineInfo.addressHi();\n+                int line = debugLineInfo.line();\n+                // record all subranges even if they have no line or file so we at least get a\n+                // symbol for them\n+                Range subRange = new Range(fileNameAtLine, classNameAtLine, methodNameAtLine, \"\", \"\", stringTable, loAtLine, hiAtLine, line, primaryRange);\n+                addSubRange(primaryRange, subRange);\n+            }\n+        }\n+        // DebugDataInfoProvider dataInfoProvider = debugInfoProvider.dataInfoProvider();\n+        // for (DebugDataInfo debugDataInfo : dataInfoProvider) {\n+        // install details of heap elements\n+        // String name = debugDataInfo.toString();\n+        // }\n+    }\n+\n+    public ClassEntry ensureClassEntry(Range range) {\n+        String className = range.getClassName();\n+        // see if we already have an entry\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        if (classEntry == null) {\n+            // create and index the entry associating it with the right file\n+            FileEntry fileEntry = ensureFileEntry(range);\n+            classEntry = new ClassEntry(className, fileEntry);\n+            primaryClasses.add(classEntry);\n+            primaryClassesIndex.put(className, classEntry);\n+        }\n+        assert classEntry.getClassName().equals(className);\n+        return classEntry;\n+    }\n+\n+    public FileEntry ensureFileEntry(Range range) {\n+        String fileName = range.getFileName();\n+        // ensure we have an entry\n+        FileEntry fileEntry = filesIndex.get(fileName);\n+        if (fileEntry == null) {\n+            DirEntry dirEntry = ensureDirEntry(fileName);\n+            String baseName = (dirEntry == null ? fileName : fileName.substring(dirEntry.getPath().length() + 1));\n+            fileEntry = new FileEntry(stringTable.uniqueDebugString(fileName),\n+                            stringTable.uniqueString(baseName),\n+                            dirEntry);\n+            files.add(fileEntry);\n+            filesIndex.put(fileName, fileEntry);\n+            // if this is a primary entry then add it to the primary list\n+            if (range.isPrimary()) {\n+                primaryFiles.add(fileEntry);\n+            } else {\n+                Range primaryRange = range.getPrimary();\n+                FileEntry primaryEntry = filesIndex.get(primaryRange.getFileName());\n+                assert primaryEntry != null;\n+            }\n+        }\n+        return fileEntry;\n+    }\n+\n+    public void addRange(Range primaryRange, List<DebugFrameSizeChange> frameSizeInfos, int frameSize) {\n+        assert primaryRange.isPrimary();\n+        ClassEntry classEntry = ensureClassEntry(primaryRange);\n+        PrimaryEntry entry = classEntry.addPrimary(primaryRange, frameSizeInfos, frameSize);\n+        if (entry != null) {\n+            // track the entry for this range in address order\n+            primaryEntries.add(entry);\n+        }\n+    }\n+\n+    public void addSubRange(Range primaryRange, Range subrange) {\n+        assert primaryRange.isPrimary();\n+        assert !subrange.isPrimary();\n+        String className = primaryRange.getClassName();\n+        ClassEntry classEntry = primaryClassesIndex.get(className);\n+        FileEntry subrangeEntry = ensureFileEntry(subrange);\n+        // the primary range should already have been seen\n+        // and associated with a primary class entry\n+        assert classEntry.primaryIndexFor(primaryRange) != null;\n+        classEntry.addSubRange(subrange, subrangeEntry);\n+    }\n+\n+    private DirEntry ensureDirEntry(String file) {\n+        int pathLength = file.lastIndexOf('/');\n+        if (pathLength < 0) {\n+            // no path/package means use dir entry 0\n+            return null;\n+        }\n+        String filePath = file.substring(0, pathLength);\n+        DirEntry dirEntry = dirsIndex.get(filePath);\n+        if (dirEntry == null) {\n+            dirEntry = new DirEntry(stringTable.uniqueString(filePath));\n+            dirsIndex.put(filePath, dirEntry);\n+            dirs.add(dirEntry);\n+        }\n+        return dirEntry;\n+    }\n+\n+    /**\n+     * class from which all DWARF debug section\n+     * inherit providing common behaviours.\n+     */\n+    // shared implementation methods to manage content creation\n+    public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+        public boolean debug = false;\n+        public long debugTextBase = 0;\n+        public long debugAddress = 0;\n+        public int debugBase = 0;\n+\n+        public DwarfSectionImpl() {\n+        }\n+\n+        /**\n+         * creates the target byte[] array used to define the section\n+         * contents.\n+         *\n+         * the main task of this method is to precompute the\n+         * size of the debug section. given the complexity of the\n+         * data layouts that invariably requires performing a dummy\n+         * write of the contents, inserting bytes into a small,\n+         * scratch buffer only when absolutely necessary. subclasses\n+         * may also cache some information for use when writing the\n+         * contents.\n+         */\n+        public abstract void createContent();\n+\n+        /**\n+         * populates the byte[] array used to contain the section\n+         * contents.\n+         *\n+         * in most cases this task reruns the operations performed\n+         * under createContent but this time actually writing data\n+         * to the target byte[].\n+         */\n+        public abstract void writeContent();\n+\n+        @Override\n+        public boolean isLoadable() {\n+            // even though we're a progbits section impl we're not actually loadable\n+            return false;\n+        }\n+\n+        public void checkDebug(int pos) {\n+            // if the env var relevant to this element\n+            // type is set then switch on debugging\n+            String name = getSectionName();\n+            String envVarName = \"DWARF_\" + name.substring(1).toUpperCase();\n+            if (System.getenv(envVarName) != null) {\n+                debug = true;\n+                debugBase = pos;\n+                debugAddress = debugTextBase;\n+            }\n+        }\n+\n+        protected void debug(String format, Object... args) {\n+            if (debug) {\n+                System.out.format(format, args);\n+            }\n+        }\n+\n+        // base level put methods that assume a non-null buffer\n+\n+        public int putByte(byte b, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = b;\n+            return pos;\n+        }\n+\n+        public int putShort(short s, byte[] buffer, int p) {\n+            int pos = p;\n+            buffer[pos++] = (byte) (s & 0xff);\n+            buffer[pos++] = (byte) ((s >> 8) & 0xff);", "originalCommit": "b2c884f8fdf3885c5aef077d2af031f4b763b57f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkxNzc1NA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r375917754", "bodyText": "Hmm, the DWARF standard didn't really make that clear but I talked to one of our debug experts (Mark Wielaard) and he confirmed that most numeric values need to follow target arch endianness. The special cases are ULEB and SLEB encoded numerics. So, I will update the code accordingly.", "author": "adinn", "createdAt": "2020-02-06T15:51:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzMjY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Njk5NTI3NA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r376995274", "bodyText": "I have pushed a fix that addresses the byte order issue.", "author": "adinn", "createdAt": "2020-02-10T11:01:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQzMjY2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUwMTU5OQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384501599", "bodyText": "s/pplication/Application", "author": "olpaw", "createdAt": "2020-02-26T13:48:20Z", "path": "substratevm/DEBUGINFO.md", "diffHunk": "@@ -25,50 +36,119 @@ compiled method.\n Identifying the location of source code\n ---------------------------------------\n \n-In order for gdb to be able to locate the source files for your app\n-methods, Graal methods and JDK runtime methods you need to provide gdb\n-with a list of source root dirs a 'set directories' command:\n+One goal of the implementation is to make it simple to configure your\n+debugger so that it can identify the relevant source file when it\n+stops during program execution. The native image generator tries to\n+achieve this by accumulating the relevant sources in a suitably\n+structured file cache.\n+\n+The native image generator uses different strategies to locate source\n+files for JDK runtime classes, GraalVM classses and application source\n+classes for inclusion in the local sources cache. It identifies which\n+strategy to use based on the package name of the class. So, for\n+example, packages starting with java.* or jdk.* are JDK classes;\n+packages starting with org.graal.* or com.oracle.svm.* are GraalVM\n+classes; any other packages are regarded as application classes.\n+\n+Sources for JDK runtime classes are retrieved from the src.zip found\n+in the JDK release used to run the native image generation process.\n+Retrieved files are cached under subdirectory sources/jdk, using the\n+module name (for JDK11) and package name of the associated class to\n+define the directory hierarchy in which the source is located.\n+\n+So, for example, on Linux the source for class java.util.HashMap will\n+be cached in file sources/jdk/java.base/java/util/HashMap.java. Debug\n+info records for this class and its methods will identify this source\n+file using the relative directory path java.base/java/util and file\n+name HashMap.java. On Windows things will be the same modulo use of\n+'\\' rather than '/' as the file separator.\n+\n+Sources for GraalVM classes are retrieved from zip files or source\n+directories derived from entries in the classpath. Retrieved files are\n+cached under subdirectory sources/graal, using the package name of the\n+associated class to define the directory hierarchy in which the source\n+is located (e.g. class com.oracle.svm.core.VM has its source file\n+cached at sources/graal/com/oracle/svm/core/VM.java).\n+\n+The lookup scheme for cached GraalVM sources varies depending upon\n+what is found in each classpath entry. Given a jar file entry like\n+/path/to/foo.jar, the corresponding file /path/to/foo.src.zip is\n+considered as a candidate zip file system from which source files may\n+be extracted. When the entry specifies a dir like /path/to/bar then\n+directories /path/to/bar/src and /path/to/bar/src_gen are considered\n+as candidates. Candidates are skipped when i) the zip file or source\n+directory does not exist or ii) it does not contain at least one\n+subdirectory hierarchy that matches one of the the expected GraalVM\n+package hierarchies.\n+\n+Sources for application classes are retrieved from source jar files or\n+source directories derived from entries in the classpath. Retrieved\n+files are cached under subdirectory sources/src, using the package\n+name of the associated class to define the directory hierarchy in\n+which the source is located (e.g. class org.my.foo.Foo has its\n+source file cached as sources/src/org/my/foo/Foo.java).\n+\n+The lookup scheme for cached pplication sources varies depending upon", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NzQzNw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384557437", "bodyText": "Fixed", "author": "adinn", "createdAt": "2020-02-26T15:14:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUwMTU5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUwMjMzMw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384502333", "bodyText": "s/whcih/which", "author": "olpaw", "createdAt": "2020-02-26T13:49:32Z", "path": "substratevm/DEBUGINFO.md", "diffHunk": "@@ -25,50 +36,119 @@ compiled method.\n Identifying the location of source code\n ---------------------------------------\n \n-In order for gdb to be able to locate the source files for your app\n-methods, Graal methods and JDK runtime methods you need to provide gdb\n-with a list of source root dirs a 'set directories' command:\n+One goal of the implementation is to make it simple to configure your\n+debugger so that it can identify the relevant source file when it\n+stops during program execution. The native image generator tries to\n+achieve this by accumulating the relevant sources in a suitably\n+structured file cache.\n+\n+The native image generator uses different strategies to locate source\n+files for JDK runtime classes, GraalVM classses and application source\n+classes for inclusion in the local sources cache. It identifies which\n+strategy to use based on the package name of the class. So, for\n+example, packages starting with java.* or jdk.* are JDK classes;\n+packages starting with org.graal.* or com.oracle.svm.* are GraalVM\n+classes; any other packages are regarded as application classes.\n+\n+Sources for JDK runtime classes are retrieved from the src.zip found\n+in the JDK release used to run the native image generation process.\n+Retrieved files are cached under subdirectory sources/jdk, using the\n+module name (for JDK11) and package name of the associated class to\n+define the directory hierarchy in which the source is located.\n+\n+So, for example, on Linux the source for class java.util.HashMap will\n+be cached in file sources/jdk/java.base/java/util/HashMap.java. Debug\n+info records for this class and its methods will identify this source\n+file using the relative directory path java.base/java/util and file\n+name HashMap.java. On Windows things will be the same modulo use of\n+'\\' rather than '/' as the file separator.\n+\n+Sources for GraalVM classes are retrieved from zip files or source\n+directories derived from entries in the classpath. Retrieved files are\n+cached under subdirectory sources/graal, using the package name of the\n+associated class to define the directory hierarchy in which the source\n+is located (e.g. class com.oracle.svm.core.VM has its source file\n+cached at sources/graal/com/oracle/svm/core/VM.java).\n+\n+The lookup scheme for cached GraalVM sources varies depending upon\n+what is found in each classpath entry. Given a jar file entry like\n+/path/to/foo.jar, the corresponding file /path/to/foo.src.zip is\n+considered as a candidate zip file system from which source files may\n+be extracted. When the entry specifies a dir like /path/to/bar then\n+directories /path/to/bar/src and /path/to/bar/src_gen are considered\n+as candidates. Candidates are skipped when i) the zip file or source\n+directory does not exist or ii) it does not contain at least one\n+subdirectory hierarchy that matches one of the the expected GraalVM\n+package hierarchies.\n+\n+Sources for application classes are retrieved from source jar files or\n+source directories derived from entries in the classpath. Retrieved\n+files are cached under subdirectory sources/src, using the package\n+name of the associated class to define the directory hierarchy in\n+which the source is located (e.g. class org.my.foo.Foo has its\n+source file cached as sources/src/org/my/foo/Foo.java).\n+\n+The lookup scheme for cached pplication sources varies depending upon\n+what is found in each classpath entry. Given a jar file entry like\n+/path/to/foo.jar, the corresponding jar /path/to/foo-sources.jar is\n+considered as a candidate zip file system from which source files may\n+be extracted. When the entry specifies a dir like /path/to/bar/classes\n+or /path/to/bar/target/classes then directory /path/to/bar/src is\n+considered as a candidate. Finally, the current directory in whcih the", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUwNzY4Mg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384507682", "bodyText": "Finally, the current directory in which the native image program is being run is also considered as a candidate.\n\nThat is (and should be) only true if -cp (or one of its variants) is not used as native-image argument. Our classpath-handling mirrors that of the java command in this regard:\nhttps://docs.oracle.com/javase/8/docs/technotes/tools/unix/classpath.html#A1100592\n...The default class path is the current directory. Setting the CLASSPATH variable or using the -classpath command-line option overrides that default...", "author": "olpaw", "createdAt": "2020-02-26T13:58:49Z", "path": "substratevm/DEBUGINFO.md", "diffHunk": "@@ -25,50 +36,119 @@ compiled method.\n Identifying the location of source code\n ---------------------------------------\n \n-In order for gdb to be able to locate the source files for your app\n-methods, Graal methods and JDK runtime methods you need to provide gdb\n-with a list of source root dirs a 'set directories' command:\n+One goal of the implementation is to make it simple to configure your\n+debugger so that it can identify the relevant source file when it\n+stops during program execution. The native image generator tries to\n+achieve this by accumulating the relevant sources in a suitably\n+structured file cache.\n+\n+The native image generator uses different strategies to locate source\n+files for JDK runtime classes, GraalVM classses and application source\n+classes for inclusion in the local sources cache. It identifies which\n+strategy to use based on the package name of the class. So, for\n+example, packages starting with java.* or jdk.* are JDK classes;\n+packages starting with org.graal.* or com.oracle.svm.* are GraalVM\n+classes; any other packages are regarded as application classes.\n+\n+Sources for JDK runtime classes are retrieved from the src.zip found\n+in the JDK release used to run the native image generation process.\n+Retrieved files are cached under subdirectory sources/jdk, using the\n+module name (for JDK11) and package name of the associated class to\n+define the directory hierarchy in which the source is located.\n+\n+So, for example, on Linux the source for class java.util.HashMap will\n+be cached in file sources/jdk/java.base/java/util/HashMap.java. Debug\n+info records for this class and its methods will identify this source\n+file using the relative directory path java.base/java/util and file\n+name HashMap.java. On Windows things will be the same modulo use of\n+'\\' rather than '/' as the file separator.\n+\n+Sources for GraalVM classes are retrieved from zip files or source\n+directories derived from entries in the classpath. Retrieved files are\n+cached under subdirectory sources/graal, using the package name of the\n+associated class to define the directory hierarchy in which the source\n+is located (e.g. class com.oracle.svm.core.VM has its source file\n+cached at sources/graal/com/oracle/svm/core/VM.java).\n+\n+The lookup scheme for cached GraalVM sources varies depending upon\n+what is found in each classpath entry. Given a jar file entry like\n+/path/to/foo.jar, the corresponding file /path/to/foo.src.zip is\n+considered as a candidate zip file system from which source files may\n+be extracted. When the entry specifies a dir like /path/to/bar then\n+directories /path/to/bar/src and /path/to/bar/src_gen are considered\n+as candidates. Candidates are skipped when i) the zip file or source\n+directory does not exist or ii) it does not contain at least one\n+subdirectory hierarchy that matches one of the the expected GraalVM\n+package hierarchies.\n+\n+Sources for application classes are retrieved from source jar files or\n+source directories derived from entries in the classpath. Retrieved\n+files are cached under subdirectory sources/src, using the package\n+name of the associated class to define the directory hierarchy in\n+which the source is located (e.g. class org.my.foo.Foo has its\n+source file cached as sources/src/org/my/foo/Foo.java).\n+\n+The lookup scheme for cached pplication sources varies depending upon\n+what is found in each classpath entry. Given a jar file entry like\n+/path/to/foo.jar, the corresponding jar /path/to/foo-sources.jar is\n+considered as a candidate zip file system from which source files may\n+be extracted. When the entry specifies a dir like /path/to/bar/classes\n+or /path/to/bar/target/classes then directory /path/to/bar/src is\n+considered as a candidate. Finally, the current directory in whcih the\n+native image program is being run is also considered as a candidate.", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU2MjI2Mg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384562262", "bodyText": "I'm not sure how I can identify the original arguments to see if -cp has been added. Is the current BuildConfiguration accessible? Say as a singleton?\nAlso, I am scanning what I take to be the classpath based on the value of the System property named \"java.class.path\". However, that value does not include an entry for the current working directory in the case where I omit -cp (and its equivalents). Is that expected? If so I don't understand how the native image class loader still manages to load Hello.class from the current working directory?", "author": "adinn", "createdAt": "2020-02-26T15:21:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUwNzY4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU3Njc0Mg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384576742", "bodyText": "I guess you are looking for com.oracle.svm.hosted.ImageClassLoader#getClasspath()\nYou can easily get access to the ImageClassLoader via the org.graalvm.nativeimage.hosted.Feature API. See e.g. com.oracle.svm.truffle.tck.PermissionsFeature#afterAnalysis search for accessImpl.getImageClassLoader()", "author": "olpaw", "createdAt": "2020-02-26T15:41:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUwNzY4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE1OTY0OQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r385159649", "bodyText": "Oh, yes, I think I am ... ;-) I'm onto this next.", "author": "adinn", "createdAt": "2020-02-27T14:26:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUwNzY4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY4NDc5Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r385684796", "bodyText": "I have added an automatic feature class as a static inner class of SourceCache. It acquires the image classloader and uses it to derive the class path. This ensures that $CWD is included when no classpath is provided.", "author": "adinn", "createdAt": "2020-02-28T13:06:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUwNzY4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTY5NzMyMw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r385697323", "bodyText": "Perfect", "author": "olpaw", "createdAt": "2020-02-28T13:34:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUwNzY4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxOTY2OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384519668", "bodyText": "That's cumbersome. Since you already have the infrastructure to copy sources from zip-files or directories for your automatic lookup strategy adding a hosted option (e.g. DebugInfoSourceSearchPath) that allows user to add additional lookup roots would be the most natural way to allow users to supplement source lookup.", "author": "olpaw", "createdAt": "2020-02-26T14:18:26Z", "path": "substratevm/DEBUGINFO.md", "diffHunk": "@@ -25,50 +36,119 @@ compiled method.\n Identifying the location of source code\n ---------------------------------------\n \n-In order for gdb to be able to locate the source files for your app\n-methods, Graal methods and JDK runtime methods you need to provide gdb\n-with a list of source root dirs a 'set directories' command:\n+One goal of the implementation is to make it simple to configure your\n+debugger so that it can identify the relevant source file when it\n+stops during program execution. The native image generator tries to\n+achieve this by accumulating the relevant sources in a suitably\n+structured file cache.\n+\n+The native image generator uses different strategies to locate source\n+files for JDK runtime classes, GraalVM classses and application source\n+classes for inclusion in the local sources cache. It identifies which\n+strategy to use based on the package name of the class. So, for\n+example, packages starting with java.* or jdk.* are JDK classes;\n+packages starting with org.graal.* or com.oracle.svm.* are GraalVM\n+classes; any other packages are regarded as application classes.\n+\n+Sources for JDK runtime classes are retrieved from the src.zip found\n+in the JDK release used to run the native image generation process.\n+Retrieved files are cached under subdirectory sources/jdk, using the\n+module name (for JDK11) and package name of the associated class to\n+define the directory hierarchy in which the source is located.\n+\n+So, for example, on Linux the source for class java.util.HashMap will\n+be cached in file sources/jdk/java.base/java/util/HashMap.java. Debug\n+info records for this class and its methods will identify this source\n+file using the relative directory path java.base/java/util and file\n+name HashMap.java. On Windows things will be the same modulo use of\n+'\\' rather than '/' as the file separator.\n+\n+Sources for GraalVM classes are retrieved from zip files or source\n+directories derived from entries in the classpath. Retrieved files are\n+cached under subdirectory sources/graal, using the package name of the\n+associated class to define the directory hierarchy in which the source\n+is located (e.g. class com.oracle.svm.core.VM has its source file\n+cached at sources/graal/com/oracle/svm/core/VM.java).\n+\n+The lookup scheme for cached GraalVM sources varies depending upon\n+what is found in each classpath entry. Given a jar file entry like\n+/path/to/foo.jar, the corresponding file /path/to/foo.src.zip is\n+considered as a candidate zip file system from which source files may\n+be extracted. When the entry specifies a dir like /path/to/bar then\n+directories /path/to/bar/src and /path/to/bar/src_gen are considered\n+as candidates. Candidates are skipped when i) the zip file or source\n+directory does not exist or ii) it does not contain at least one\n+subdirectory hierarchy that matches one of the the expected GraalVM\n+package hierarchies.\n+\n+Sources for application classes are retrieved from source jar files or\n+source directories derived from entries in the classpath. Retrieved\n+files are cached under subdirectory sources/src, using the package\n+name of the associated class to define the directory hierarchy in\n+which the source is located (e.g. class org.my.foo.Foo has its\n+source file cached as sources/src/org/my/foo/Foo.java).\n+\n+The lookup scheme for cached pplication sources varies depending upon\n+what is found in each classpath entry. Given a jar file entry like\n+/path/to/foo.jar, the corresponding jar /path/to/foo-sources.jar is\n+considered as a candidate zip file system from which source files may\n+be extracted. When the entry specifies a dir like /path/to/bar/classes\n+or /path/to/bar/target/classes then directory /path/to/bar/src is\n+considered as a candidate. Finally, the current directory in whcih the\n+native image program is being run is also considered as a candidate.\n+\n+These lookup strategies are only provisional and may need extending in\n+future. Note however that it is possible to make missing sources\n+available by other means. One option is to unzip extra app source jars\n+or copying extra app source trees into the cache. Another is to\n+configure extra source search paths (see below).\n+\n+Configuring source paths in gdb\n+-------------------------------\n \n-    (gdb) set directories /home/adinn/hello/src:/home/adinn/graal/sdk/src/org/graalvm.word/src:/home/adinn/graal/sdk/src/org.graalvm.options/src:...\n-\n-The argument is a comma separated list of source roots. It needs to\n-identify:\n+In order for gdb to be able to locate the source files for your app\n+classes, Graal classes and JDK runtime classes you need to provide gdb\n+with a list of source root dirs using the 'set directories' command:\n \n-  - sources for your app\n-  - sources under the Graal sdk, compiler, substratevm and truffle trees\n-  - sources in the JDK src.zip file\n+    (gdb) set directories /path/to/sources/jdk:/path/to/sources/graal:/path/to/sources/src\n \n-Needless to say the list for Graal is long and complex. Also, the JDK\n-sources are in a zip file and gdb does not understand zip sources. So\n-you need to extract the JDK sources as a preparatory step,\n+Directory .../sources/jdk should contain source files for all JDK runtime\n+classes referenced from debug records.\n \n-You can use shell script write_gdbsourcepath (added to Graal dir\n-substratevm) to auto-generate settings for the GRaal and JDK sources.\n+Directory .../sources/graal should contain source files for all GraalVM\n+classes referenced from debug records. Note that the current\n+implementation does not yet find some sources for the GraalVM JIT\n+compiler in the org.graalvm.compiler* package subspace.\n \n-    $ bash write_gdbsourcepath\n+Directory .../sources/src should contain source files for all\n+application classes referenced from debug records, assuming they can\n+be located using the lookup strategy described above.\n \n-It creates a local file .gdbsourcepath which sets the relevant\n-directories. Before running it you can set two env vars to tell it\n-where to locate the source trees it needs to include:\n+You can supplement the files cached in sources/src by unzipping\n+application source jars or copying application source trees into the", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU3MDU5NA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384570594", "bodyText": "Sure I will I add something along the lines of CLibraryPath or LinkerRPath i.e. on the command line the user specifies a comma-separated list of dirs\n-X:DebugInfoSourceSearchPath=/path/to/dir1,/path/to/jar2.jar,/path/to/jar3.jar\n\nwhich gets installed as a HostedOptionKey<String[]>", "author": "adinn", "createdAt": "2020-02-26T15:32:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxOTY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTEyODk5NA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r385128994", "bodyText": "I have added this in the latest push. As per the other paths the argument can be a single dir/jar/zip or a comma separated list and the option can appear multiple times if desired. Users call Options.flatten to squeeze to the comma separators. I still nee dto document this in DEBUGINFO.md", "author": "adinn", "createdAt": "2020-02-27T13:36:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxOTY2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE1ODI1MQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r385158251", "bodyText": "Ok, DEBUGINFO.md now documents how to specify search paths.", "author": "adinn", "createdAt": "2020-02-27T14:24:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxOTY2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyNDEyMA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384524120", "bodyText": "typo: fomrat", "author": "olpaw", "createdAt": "2020-02-26T14:25:33Z", "path": "substratevm/DEBUGINFO.md", "diffHunk": "@@ -25,50 +36,119 @@ compiled method.\n Identifying the location of source code\n ---------------------------------------\n \n-In order for gdb to be able to locate the source files for your app\n-methods, Graal methods and JDK runtime methods you need to provide gdb\n-with a list of source root dirs a 'set directories' command:\n+One goal of the implementation is to make it simple to configure your\n+debugger so that it can identify the relevant source file when it\n+stops during program execution. The native image generator tries to\n+achieve this by accumulating the relevant sources in a suitably\n+structured file cache.\n+\n+The native image generator uses different strategies to locate source\n+files for JDK runtime classes, GraalVM classses and application source\n+classes for inclusion in the local sources cache. It identifies which\n+strategy to use based on the package name of the class. So, for\n+example, packages starting with java.* or jdk.* are JDK classes;\n+packages starting with org.graal.* or com.oracle.svm.* are GraalVM\n+classes; any other packages are regarded as application classes.\n+\n+Sources for JDK runtime classes are retrieved from the src.zip found\n+in the JDK release used to run the native image generation process.\n+Retrieved files are cached under subdirectory sources/jdk, using the\n+module name (for JDK11) and package name of the associated class to\n+define the directory hierarchy in which the source is located.\n+\n+So, for example, on Linux the source for class java.util.HashMap will\n+be cached in file sources/jdk/java.base/java/util/HashMap.java. Debug\n+info records for this class and its methods will identify this source\n+file using the relative directory path java.base/java/util and file\n+name HashMap.java. On Windows things will be the same modulo use of\n+'\\' rather than '/' as the file separator.\n+\n+Sources for GraalVM classes are retrieved from zip files or source\n+directories derived from entries in the classpath. Retrieved files are\n+cached under subdirectory sources/graal, using the package name of the\n+associated class to define the directory hierarchy in which the source\n+is located (e.g. class com.oracle.svm.core.VM has its source file\n+cached at sources/graal/com/oracle/svm/core/VM.java).\n+\n+The lookup scheme for cached GraalVM sources varies depending upon\n+what is found in each classpath entry. Given a jar file entry like\n+/path/to/foo.jar, the corresponding file /path/to/foo.src.zip is\n+considered as a candidate zip file system from which source files may\n+be extracted. When the entry specifies a dir like /path/to/bar then\n+directories /path/to/bar/src and /path/to/bar/src_gen are considered\n+as candidates. Candidates are skipped when i) the zip file or source\n+directory does not exist or ii) it does not contain at least one\n+subdirectory hierarchy that matches one of the the expected GraalVM\n+package hierarchies.\n+\n+Sources for application classes are retrieved from source jar files or\n+source directories derived from entries in the classpath. Retrieved\n+files are cached under subdirectory sources/src, using the package\n+name of the associated class to define the directory hierarchy in\n+which the source is located (e.g. class org.my.foo.Foo has its\n+source file cached as sources/src/org/my/foo/Foo.java).\n+\n+The lookup scheme for cached pplication sources varies depending upon\n+what is found in each classpath entry. Given a jar file entry like\n+/path/to/foo.jar, the corresponding jar /path/to/foo-sources.jar is\n+considered as a candidate zip file system from which source files may\n+be extracted. When the entry specifies a dir like /path/to/bar/classes\n+or /path/to/bar/target/classes then directory /path/to/bar/src is\n+considered as a candidate. Finally, the current directory in whcih the\n+native image program is being run is also considered as a candidate.\n+\n+These lookup strategies are only provisional and may need extending in\n+future. Note however that it is possible to make missing sources\n+available by other means. One option is to unzip extra app source jars\n+or copying extra app source trees into the cache. Another is to\n+configure extra source search paths (see below).\n+\n+Configuring source paths in gdb\n+-------------------------------\n \n-    (gdb) set directories /home/adinn/hello/src:/home/adinn/graal/sdk/src/org/graalvm.word/src:/home/adinn/graal/sdk/src/org.graalvm.options/src:...\n-\n-The argument is a comma separated list of source roots. It needs to\n-identify:\n+In order for gdb to be able to locate the source files for your app\n+classes, Graal classes and JDK runtime classes you need to provide gdb\n+with a list of source root dirs using the 'set directories' command:\n \n-  - sources for your app\n-  - sources under the Graal sdk, compiler, substratevm and truffle trees\n-  - sources in the JDK src.zip file\n+    (gdb) set directories /path/to/sources/jdk:/path/to/sources/graal:/path/to/sources/src\n \n-Needless to say the list for Graal is long and complex. Also, the JDK\n-sources are in a zip file and gdb does not understand zip sources. So\n-you need to extract the JDK sources as a preparatory step,\n+Directory .../sources/jdk should contain source files for all JDK runtime\n+classes referenced from debug records.\n \n-You can use shell script write_gdbsourcepath (added to Graal dir\n-substratevm) to auto-generate settings for the GRaal and JDK sources.\n+Directory .../sources/graal should contain source files for all GraalVM\n+classes referenced from debug records. Note that the current\n+implementation does not yet find some sources for the GraalVM JIT\n+compiler in the org.graalvm.compiler* package subspace.\n \n-    $ bash write_gdbsourcepath\n+Directory .../sources/src should contain source files for all\n+application classes referenced from debug records, assuming they can\n+be located using the lookup strategy described above.\n \n-It creates a local file .gdbsourcepath which sets the relevant\n-directories. Before running it you can set two env vars to tell it\n-where to locate the source trees it needs to include:\n+You can supplement the files cached in sources/src by unzipping\n+application source jars or copying application source trees into the\n+cache. You need to ensure that any new subdirectory you add to\n+sources/src corresponds to the top level package for the classes whose\n+sources are being included.\n \n-  - GRAAL_JAVA_SRC_ROOT should point to the dir into which you have\n-  unzipped the src.zip from your Graal JDK release\n-  - GRAAL_SRC_ROOT should point to the dir in which your Graal git\n-  tree checkout is located\n+You can also add extra directories to the search path. Note that gdb\n+does not understand zip fomrat file systems so any extra entries you", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1Nzc2Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384557766", "bodyText": "Fixed", "author": "adinn", "createdAt": "2020-02-26T15:15:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyNDEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyODg5Mw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384528893", "bodyText": "Typo", "author": "olpaw", "createdAt": "2020-02-26T14:32:49Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/StringTable.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+\n+/**\n+ * Allows incoming strings to be reduced to unique (up\n+ * to equals) instances and supports marking of strings\n+ * which need to be written to the debug_str section\n+ * and retrieval of the location offset after writing.\n+ */\n+public class StringTable implements Iterable<StringEntry> {\n+\n+    private final HashMap<String, StringEntry> table;\n+\n+    public StringTable() {\n+        this.table = new HashMap<>();\n+    }\n+\n+    /**\n+     * Wnsures a unique instance of a string exists in the", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU3MDY5OQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384570699", "bodyText": "Fixed", "author": "adinn", "createdAt": "2020-02-26T15:33:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyODg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyOTU3Nw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384529577", "bodyText": "I still see many of these comments starting with lowercase letters", "author": "olpaw", "createdAt": "2020-02-26T14:33:57Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/StringEntry.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020 Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+/**\n+ * Used to retain a unique (up to equals) copy of a\n+ * String. Also flag swhether the String needs to be\n+ * located in the debug_string section and, if so,\n+ * tracks the offset at which it gets written.\n+ */\n+public class StringEntry {\n+    private String string;\n+    private int offset;\n+    private boolean addToStrSection;\n+\n+    StringEntry(String string) {\n+        this.string = string;\n+        this.offset = -1;\n+    }\n+\n+    public String getString() {\n+        return string;\n+    }\n+\n+    public int getOffset() {\n+        /*\n+         * offset must be set before this can be fetched", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NjgwOQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384546809", "bodyText": "Yes. I cleaned up a lot of them before fixing the other issues but I have not yet done a second pass over them. I will do that as part of the next cleanup that handles all this feedback.", "author": "adinn", "createdAt": "2020-02-26T14:59:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyOTU3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUzMDg2Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384530866", "bodyText": "GenerateDebugInfo is HostedOptionKey<Integer> which does not support the -H:+GenerateDebugInfo syntax.", "author": "olpaw", "createdAt": "2020-02-26T14:35:54Z", "path": "substratevm/DEBUGINFO.md", "diffHunk": "@@ -0,0 +1,207 @@\n+Using the ptototype debug info feature\n+--------------------------------------\n+\n+To add debug info to a generated native image add flag\n+-H:+GenerateDebugInfo to the native image command line.\n+\n+    $ javac Hello.java\n+    $ mx native-image -H:+GenerateDebugInfo Hello", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0Nzg3Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384547876", "bodyText": "Yes, it's meant to be -H:GenerateDebugInfo=1", "author": "adinn", "createdAt": "2020-02-26T15:00:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUzMDg2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NzkzOA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384557938", "bodyText": "Fixed", "author": "adinn", "createdAt": "2020-02-26T15:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUzMDg2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUzNzMyMA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384537320", "bodyText": "Windows support is still under development.\n\nIt would be useful to also see the development of the Windows support happening in this same repo.", "author": "olpaw", "createdAt": "2020-02-26T14:45:43Z", "path": "substratevm/DEBUGINFO.md", "diffHunk": "@@ -0,0 +1,207 @@\n+Using the ptototype debug info feature\n+--------------------------------------\n+\n+To add debug info to a generated native image add flag\n+-H:+GenerateDebugInfo to the native image command line.\n+\n+    $ javac Hello.java\n+    $ mx native-image -H:+GenerateDebugInfo Hello\n+\n+The resulting image should contain code (method) debug records in a\n+format gdb understands (VS support is still under development).\n+\n+The flag also enables caching of sources for JDK runtime classes,\n+GraalVM classes and application classes which can be located during\n+native image generation. The cache is created under local subdirectory\n+sources and can be used to configure source file search path roots for\n+the debugger. Files in the cache are located in a directory hierarchy\n+that matches the file path information included in the native image\n+debug records\n+\n+\n+What is currently implemented\n+-----------------------------\n+\n+The currently implemented features include:\n+\n+  - break points configured by file and line or by method name\n+  - single stepping by line including both into and over function calls\n+  - stack backtraces (not including frames detailing inlined code)\n+\n+Note that single stepping within a compiled method includes file and\n+line number info for inlined code, including inlined Graal methods.\n+So, gdb may switch files even though you are still in the same\n+compiled method.\n+\n+Identifying the location of source code\n+---------------------------------------\n+\n+One goal of the implementation is to make it simple to configure your\n+debugger so that it can identify the relevant source file when it\n+stops during program execution. The native image generator tries to\n+achieve this by accumulating the relevant sources in a suitably\n+structured file cache.\n+\n+The native image generator uses different strategies to locate source\n+files for JDK runtime classes, GraalVM classses and application source\n+classes for inclusion in the local sources cache. It identifies which\n+strategy to use based on the package name of the class. So, for\n+example, packages starting with java.* or jdk.* are JDK classes;\n+packages starting with org.graal.* or com.oracle.svm.* are GraalVM\n+classes; any other packages are regarded as application classes.\n+\n+Sources for JDK runtime classes are retrieved from the src.zip found\n+in the JDK release used to run the native image generation process.\n+Retrieved files are cached under subdirectory sources/jdk, using the\n+module name (for JDK11) and package name of the associated class to\n+define the directory hierarchy in which the source is located.\n+\n+So, for example, on Linux the source for class java.util.HashMap will\n+be cached in file sources/jdk/java.base/java/util/HashMap.java. Debug\n+info records for this class and its methods will identify this source\n+file using the relative directory path java.base/java/util and file\n+name HashMap.java. On Windows things will be the same modulo use of\n+'\\' rather than '/' as the file separator.\n+\n+Sources for GraalVM classes are retrieved from zip files or source\n+directories derived from entries in the classpath. Retrieved files are\n+cached under subdirectory sources/graal, using the package name of the\n+associated class to define the directory hierarchy in which the source\n+is located (e.g. class com.oracle.svm.core.VM has its source file\n+cached at sources/graal/com/oracle/svm/core/VM.java).\n+\n+The lookup scheme for cached GraalVM sources varies depending upon\n+what is found in each classpath entry. Given a jar file entry like\n+/path/to/foo.jar, the corresponding file /path/to/foo.src.zip is\n+considered as a candidate zip file system from which source files may\n+be extracted. When the entry specifies a dir like /path/to/bar then\n+directories /path/to/bar/src and /path/to/bar/src_gen are considered\n+as candidates. Candidates are skipped when i) the zip file or source\n+directory does not exist or ii) it does not contain at least one\n+subdirectory hierarchy that matches one of the the expected GraalVM\n+package hierarchies.\n+\n+Sources for application classes are retrieved from source jar files or\n+source directories derived from entries in the classpath. Retrieved\n+files are cached under subdirectory sources/src, using the package\n+name of the associated class to define the directory hierarchy in\n+which the source is located (e.g. class org.my.foo.Foo has its\n+source file cached as sources/src/org/my/foo/Foo.java).\n+\n+The lookup scheme for cached pplication sources varies depending upon\n+what is found in each classpath entry. Given a jar file entry like\n+/path/to/foo.jar, the corresponding jar /path/to/foo-sources.jar is\n+considered as a candidate zip file system from which source files may\n+be extracted. When the entry specifies a dir like /path/to/bar/classes\n+or /path/to/bar/target/classes then directory /path/to/bar/src is\n+considered as a candidate. Finally, the current directory in whcih the\n+native image program is being run is also considered as a candidate.\n+\n+These lookup strategies are only provisional and may need extending in\n+future. Note however that it is possible to make missing sources\n+available by other means. One option is to unzip extra app source jars\n+or copying extra app source trees into the cache. Another is to\n+configure extra source search paths (see below).\n+\n+Configuring source paths in gdb\n+-------------------------------\n+\n+In order for gdb to be able to locate the source files for your app\n+classes, Graal classes and JDK runtime classes you need to provide gdb\n+with a list of source root dirs using the 'set directories' command:\n+\n+    (gdb) set directories /path/to/sources/jdk:/path/to/sources/graal:/path/to/sources/src\n+\n+Directory .../sources/jdk should contain source files for all JDK runtime\n+classes referenced from debug records.\n+\n+Directory .../sources/graal should contain source files for all GraalVM\n+classes referenced from debug records. Note that the current\n+implementation does not yet find some sources for the GraalVM JIT\n+compiler in the org.graalvm.compiler* package subspace.\n+\n+Directory .../sources/src should contain source files for all\n+application classes referenced from debug records, assuming they can\n+be located using the lookup strategy described above.\n+\n+You can supplement the files cached in sources/src by unzipping\n+application source jars or copying application source trees into the\n+cache. You need to ensure that any new subdirectory you add to\n+sources/src corresponds to the top level package for the classes whose\n+sources are being included.\n+\n+You can also add extra directories to the search path. Note that gdb\n+does not understand zip fomrat file systems so any extra entries you\n+add must identify a directory tree containing the relevant\n+sources. Once again. top leel entries in the directory added to the\n+search path must correspond to the top level package for the classes\n+whose sources are being included.\n+\n+Configuring source paths in VS\n+------------------------------\n+\n+TO BE ADDED\n+\n+Checking debug info on Linux\n+----------------------------\n+\n+n.b. this is only of interest to those who want to understand how the\n+debug info implemetation works or want to trouble shoot problems\n+encountered during debugging that might relate to the debug info\n+encoding.\n+\n+The objdump command can be used to display the dbeug info embedded\n+into a native image. The following commands (which all assume the\n+target binary is called hello) can be used to display all currentyl\n+generated content:\n+\n+    $ objdump --dwarf=info hello > info\n+    $ objdump --dwarf=abbrev hello > abbrev\n+    $ objdump --dwarf=ranges hello > ranges\n+    $ objdump --dwarf=decodedline hello > decodedline\n+    $ objdump --dwarf=rawline hello > rawline\n+    $ objdump --dwarf=str hello > str\n+    $ objdump --dwarf=frames hello > frames\n+\n+The *info* section includes details of all compiled Java methods.\n+\n+The *abbrev* sectio defines the layout of records in the info section\n+that describe Java files (compilation units) and methods.\n+\n+The *ranges* section details the start and end addresses of method\n+code segments\n+\n+The *decodedline* section maps subsegments of method code range\n+segments to files and line numbers. This mapping includes entries\n+for files and line numbers for inlined methods.\n+\n+The *rawline* segment provides deatails of how the line table is\n+generated using DWARF state machine instuctions that encode file,\n+line and address transitions.\n+\n+The *str* section provides a lookup table for strings referenced\n+from records in the info section\n+\n+The *frames* section lists transition points in compiled methods\n+where a (fixed size) stack frame is pushed or popped, allowing\n+the debugger to identify each frame's current and previous stack\n+pointers and it's return address.\n+\n+Note that some of the content embedded in the debug records is\n+generated by the C compiler and belongs to code that is either in\n+libraries or the C lib bootstrap code that is bundled in with the\n+Java method code.\n+\n+Currently supported targets\n+---------------------------\n+\n+The prototype is currently implemented only for gdb on Linux.\n+\n+  - Linux/x86_64 suppoort has been tested and should work\n+    correctly.\n+\n+  - Linux/AArch64 support is present but has not yet been fully\n+    verified (break points should work ok but stack backtraces\n+    may be incorrect).\n+\n+Windows support is still under development.", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1NDcyNA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384554724", "bodyText": "Yes, I was thinking the same myself just yestrday.\nI believe my colleague Simon Tooke has some basic things working but is is still working on getting a stable version that he is happy to publish. He was struggling with getting VS to use the right file paths but the sources cache may have simplified that. I'll try to push him to provide a version I can pull into this PR branch that will build and maybe implement some basic debugging (I am sure that can be made to happen very soon ;-).\nOf course, Simon's code is always lagging slightly behind my version because he keeps having to play catch up with the changes I have been adding (sources cache, Streams in native image <-> object API, other tweaks to API). So, this may take a day or two.", "author": "adinn", "createdAt": "2020-02-26T15:11:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUzNzMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU2NjM5Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384566396", "bodyText": "I'll try to push him to provide a version I can pull into this PR branch that will build and maybe implement some basic debugging\n\nThat would be great!", "author": "olpaw", "createdAt": "2020-02-26T15:27:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUzNzMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTEzMjM5NQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r385132395", "bodyText": "Simon suggested raising his own PR from a branch in his github repo derived from my branch. That will avoid his changes breaking my branch and vice versa. He can pull my changes in and then publish them once he has assimilated them. It will also allow us to merge either just my changes or (much preferred) both sets of changes at the same time once we get them through review. I don't want his stuff delayed but this means we are not stuck there are any blockers for his code (which is still a possibility given the difficulty of knowing what might turn up in VS). How does that sound?", "author": "adinn", "createdAt": "2020-02-27T13:42:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUzNzMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE2NTQ4Mw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r385165483", "bodyText": "Sounds ok to me. I'd like to get my eyes on those changes as well. Please let me know when there is a PR to look at.", "author": "olpaw", "createdAt": "2020-02-27T14:36:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUzNzMyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYzNDM0MA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r385634340", "bodyText": "Ok, will do.", "author": "adinn", "createdAt": "2020-02-28T11:01:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUzNzMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MDg5OQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384550899", "bodyText": "dead code", "author": "olpaw", "createdAt": "2020-02-26T15:05:11Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debuginfo;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+/**\n+ * interfaces used to allow a native image to communicate\n+ * details of types, code and data to the underlying\n+ * object file so that the latter can insert appropriate\n+ * debug info.\n+ */\n+public interface DebugInfoProvider {\n+    /**\n+     * access details of a specific type.\n+     */\n+    interface DebugTypeInfo {\n+    }\n+\n+    /**\n+     * access details of a specific compiled method.\n+     */\n+    interface DebugCodeInfo {\n+        /**\n+         * @return the name of the file containing a compiled\n+         * method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing a compiled\n+         * method derived from its package name or null if the method\n+         * is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * compiled method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the compiled method including\n+         * signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the starting line number for the method\n+         */\n+        int line();\n+        /**\n+         * @return a stream of records detailing line numbers\n+         * and addresses within the compiled method\n+         */\n+        Stream<DebugLineInfo> lineInfoProvider();\n+        /**\n+         * @return a string identifying the method parameters\n+         */\n+        String paramNames();\n+        /**\n+         * @return a string identifying the method return type\n+         */\n+        String returnTypeName();\n+        /**\n+         * @return the size of the method frame between prologue\n+         * and epilogue\n+         */\n+        int getFrameSize();\n+        /**\n+         * @return a list of positions at which the stack is extended\n+         * to a full frame or torn down to an empty frame\n+         */\n+        List<DebugFrameSizeChange> getFrameSizeChanges();\n+    }\n+\n+    /**\n+     * access details of a specific heap object.\n+     */\n+    interface DebugDataInfo {\n+    }\n+\n+    /**\n+     *  access details of code generated for a specific outer\n+     *  or inlined method at  a given line number.\n+     */\n+    interface DebugLineInfo {\n+        /**\n+         * @return the name of the file containing the outer\n+         * or inlined method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing the outer\n+         * or inlined method derived from its package name or null\n+         * if the method is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * outer or inlined method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the outer or inlined method including signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the line number for the outer or inlined segment\n+         */\n+        int line();\n+    }\n+\n+    interface DebugFrameSizeChange {\n+        enum Type {\n+            EXTEND,\n+            CONTRACT\n+        }\n+\n+        int getOffset();\n+\n+        DebugFrameSizeChange.Type getType();\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugTypeInfoProvider extends Iterable<DebugTypeInfo> {", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1ODA1NQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384558055", "bodyText": "Fixed", "author": "adinn", "createdAt": "2020-02-26T15:15:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MDg5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MDk3Nw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384550977", "bodyText": "dead code", "author": "olpaw", "createdAt": "2020-02-26T15:05:19Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debuginfo;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+/**\n+ * interfaces used to allow a native image to communicate\n+ * details of types, code and data to the underlying\n+ * object file so that the latter can insert appropriate\n+ * debug info.\n+ */\n+public interface DebugInfoProvider {\n+    /**\n+     * access details of a specific type.\n+     */\n+    interface DebugTypeInfo {\n+    }\n+\n+    /**\n+     * access details of a specific compiled method.\n+     */\n+    interface DebugCodeInfo {\n+        /**\n+         * @return the name of the file containing a compiled\n+         * method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing a compiled\n+         * method derived from its package name or null if the method\n+         * is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * compiled method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the compiled method including\n+         * signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the starting line number for the method\n+         */\n+        int line();\n+        /**\n+         * @return a stream of records detailing line numbers\n+         * and addresses within the compiled method\n+         */\n+        Stream<DebugLineInfo> lineInfoProvider();\n+        /**\n+         * @return a string identifying the method parameters\n+         */\n+        String paramNames();\n+        /**\n+         * @return a string identifying the method return type\n+         */\n+        String returnTypeName();\n+        /**\n+         * @return the size of the method frame between prologue\n+         * and epilogue\n+         */\n+        int getFrameSize();\n+        /**\n+         * @return a list of positions at which the stack is extended\n+         * to a full frame or torn down to an empty frame\n+         */\n+        List<DebugFrameSizeChange> getFrameSizeChanges();\n+    }\n+\n+    /**\n+     * access details of a specific heap object.\n+     */\n+    interface DebugDataInfo {\n+    }\n+\n+    /**\n+     *  access details of code generated for a specific outer\n+     *  or inlined method at  a given line number.\n+     */\n+    interface DebugLineInfo {\n+        /**\n+         * @return the name of the file containing the outer\n+         * or inlined method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing the outer\n+         * or inlined method derived from its package name or null\n+         * if the method is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * outer or inlined method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the outer or inlined method including signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the line number for the outer or inlined segment\n+         */\n+        int line();\n+    }\n+\n+    interface DebugFrameSizeChange {\n+        enum Type {\n+            EXTEND,\n+            CONTRACT\n+        }\n+\n+        int getOffset();\n+\n+        DebugFrameSizeChange.Type getType();\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugTypeInfoProvider extends Iterable<DebugTypeInfo> {\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugCodeInfoProvider extends Iterable<DebugCodeInfo> {", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1ODQxMg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384558412", "bodyText": "fixed", "author": "adinn", "createdAt": "2020-02-26T15:16:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MDk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MTA3Mg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384551072", "bodyText": "dead code", "author": "olpaw", "createdAt": "2020-02-26T15:05:27Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debuginfo/DebugInfoProvider.java", "diffHunk": "@@ -0,0 +1,199 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debuginfo;\n+\n+import java.nio.file.Path;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+/**\n+ * interfaces used to allow a native image to communicate\n+ * details of types, code and data to the underlying\n+ * object file so that the latter can insert appropriate\n+ * debug info.\n+ */\n+public interface DebugInfoProvider {\n+    /**\n+     * access details of a specific type.\n+     */\n+    interface DebugTypeInfo {\n+    }\n+\n+    /**\n+     * access details of a specific compiled method.\n+     */\n+    interface DebugCodeInfo {\n+        /**\n+         * @return the name of the file containing a compiled\n+         * method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing a compiled\n+         * method derived from its package name or null if the method\n+         * is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * compiled method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the compiled method including\n+         * signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * the method represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the starting line number for the method\n+         */\n+        int line();\n+        /**\n+         * @return a stream of records detailing line numbers\n+         * and addresses within the compiled method\n+         */\n+        Stream<DebugLineInfo> lineInfoProvider();\n+        /**\n+         * @return a string identifying the method parameters\n+         */\n+        String paramNames();\n+        /**\n+         * @return a string identifying the method return type\n+         */\n+        String returnTypeName();\n+        /**\n+         * @return the size of the method frame between prologue\n+         * and epilogue\n+         */\n+        int getFrameSize();\n+        /**\n+         * @return a list of positions at which the stack is extended\n+         * to a full frame or torn down to an empty frame\n+         */\n+        List<DebugFrameSizeChange> getFrameSizeChanges();\n+    }\n+\n+    /**\n+     * access details of a specific heap object.\n+     */\n+    interface DebugDataInfo {\n+    }\n+\n+    /**\n+     *  access details of code generated for a specific outer\n+     *  or inlined method at  a given line number.\n+     */\n+    interface DebugLineInfo {\n+        /**\n+         * @return the name of the file containing the outer\n+         * or inlined method excluding any path\n+         */\n+        String fileName();\n+        /**\n+         * @return a relative path to the file containing the outer\n+         * or inlined method derived from its package name or null\n+         * if the method is in the empty package\n+         */\n+        Path filePath();\n+        /**\n+         * @return the fully qualified name of the class owning the\n+         * outer or inlined method\n+         */\n+        String className();\n+        /**\n+         * @return the name of the outer or inlined method including signature\n+         */\n+        String methodName();\n+        /**\n+         * @return the lowest address containing code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressLo();\n+        /**\n+         * @return the first address above the code generated for\n+         * an outer or inlined code segment reported at this line\n+         * represented as an offset into the code segment\n+         */\n+        int addressHi();\n+        /**\n+         * @return the line number for the outer or inlined segment\n+         */\n+        int line();\n+    }\n+\n+    interface DebugFrameSizeChange {\n+        enum Type {\n+            EXTEND,\n+            CONTRACT\n+        }\n+\n+        int getOffset();\n+\n+        DebugFrameSizeChange.Type getType();\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugTypeInfoProvider extends Iterable<DebugTypeInfo> {\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugCodeInfoProvider extends Iterable<DebugCodeInfo> {\n+    }\n+\n+    /**\n+     * convenience interface defining iterator type.\n+     */\n+    interface DebugLineInfoProvider extends Iterable<DebugLineInfo> {", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1ODE4NA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384558184", "bodyText": "Fixed", "author": "adinn", "createdAt": "2020-02-26T15:15:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU1MTA3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU2MjQ1MA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384562450", "bodyText": "How about\npublic enum SourceCacheType {\n    JDK(\"jdk\"),\n    GRAALVM(\"graal\"),\n    APPLICATION(\"src\");\n\n    final Path subdir;\n\n    SourceCacheType(String subdir) {\n        this.subdir = Paths.get(subdir);\n    }\n}\ninstead of those protected static final fields ?", "author": "olpaw", "createdAt": "2020-02-26T15:21:52Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.svm.hosted.image.sources;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.FileTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+/**\n+ * An abstract cache manager for some subspace of the\n+ * JDK, GraalVM or application source file space. This class\n+ * implements core behaviours that manage a cache of source\n+ * files in a specific subdirectory of the local sources\n+ * directory. It allows source files to be located\n+ * when present in the local cache or cached when not\n+ * already present. Subclasses are responsible for providing\n+ * behaviours that identify an original source for addition\n+ * to the cache and for verifying that a cached file is not\n+ * out of date with respect to its original.\n+ */\n+\n+public abstract class SourceCache {\n+\n+    /*\n+     * properties needed to locate relevant JDK and app source roots\n+     */\n+    protected static final String JAVA_CLASSPATH_PROP = \"java.class.path\";\n+    protected static final String JAVA_HOME_PROP = \"java.home\";\n+    protected static final String JAVA_SPEC_VERSION_PROP = \"java.specification.version\";\n+    /**\n+     * A list of root directories which may contain source files\n+     * from which this cache can be populated\n+     */\n+    protected List<Path> srcRoots;\n+\n+    /**\n+     * Create a source cache with a specific base type.\n+     * @param key a String identifying the subdir under\n+     * which sources should be cached which should also\n+     * match the type of content being cached\n+     */\n+    protected SourceCache(String key) {\n+        basePath = Paths.get(SOURCE_CACHE_ROOT_DIR, key);\n+        srcRoots = new ArrayList<>();\n+\n+    }\n+\n+    /**\n+     * A local directory serving as the root for all\n+     * source trees maintained by the different\n+     * available source caches.\n+     */\n+    private static final String SOURCE_CACHE_ROOT_DIR = \"sources\";\n+    /**\n+     * The top level path relative to the root directory\n+     * under which files belonging to this specific cache\n+     * are located.\n+     */\n+    private Path basePath;\n+    /**\n+     * JDK runtime code sources are cached using this key as a\n+     * leading path prefix with a module name as a sub-path\n+     * prefix when we have a modular JDK.\n+     *\n+     * For example, the full file path to a file under the cache\n+     * root directory might be jdk/java/lang/Throwable.java on jdk8 or\n+     * jdk/java.base/java/lang/Throwable.java on jdk11\n+     */\n+    protected static final String JDK_CACHE_KEY = \"jdk\";", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4MjY4OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384582688", "bodyText": "Yes, that looks better.", "author": "adinn", "createdAt": "2020-02-26T15:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU2MjQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTEyNzM3Mg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r385127372", "bodyText": "I pushed this and used it to clean up the constructors for SourceCache and its subclasses", "author": "adinn", "createdAt": "2020-02-27T13:33:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU2MjQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4MDA4OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r384580088", "bodyText": "adding\nabstract SourceCacheType getType();\n\ncould probably be handy at some point.", "author": "olpaw", "createdAt": "2020-02-26T15:46:25Z", "path": "substratevm/src/com.oracle.svm.hosted/src/com/oracle/svm/hosted/image/sources/SourceCache.java", "diffHunk": "@@ -0,0 +1,299 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.svm.hosted.image.sources;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.nio.file.StandardCopyOption;\n+import java.nio.file.attribute.FileTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+/**\n+ * An abstract cache manager for some subspace of the\n+ * JDK, GraalVM or application source file space. This class\n+ * implements core behaviours that manage a cache of source\n+ * files in a specific subdirectory of the local sources\n+ * directory. It allows source files to be located\n+ * when present in the local cache or cached when not\n+ * already present. Subclasses are responsible for providing\n+ * behaviours that identify an original source for addition\n+ * to the cache and for verifying that a cached file is not\n+ * out of date with respect to its original.\n+ */\n+\n+public abstract class SourceCache {", "originalCommit": "93dbfe57b94099877ef6a333795780f1897e3de8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTEyNzYzOQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r385127639", "bodyText": "Yes, I now use this in the cache constructors.", "author": "adinn", "createdAt": "2020-02-27T13:33:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU4MDA4OA=="}], "type": "inlineReview"}, {"oid": "ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "url": "https://github.com/oracle/graal/commit/ade5ccb9776ce6bb3b539da3efafd0749e50f66d", "message": "more format changes and fix some small errors in graal cache", "committedDate": "2020-03-10T14:47:11Z", "type": "forcePushed"}, {"oid": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "url": "https://github.com/oracle/graal/commit/c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "message": "support tracing of DWARF debug info modelling and generation to file using a debugContext provided via either the DebugInfoProvider API or via the ObjectFile", "committedDate": "2020-03-17T15:13:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA3OTQ0OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395079448", "bodyText": "If the return value is not used anywhere use java.util.function.Consumer instead Function of to avoid pointless code such as\n    // doesn't actually matter what we return\n    return true;", "author": "olpaw", "createdAt": "2020-03-19T14:43:33Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/ObjectFile.java", "diffHunk": "@@ -1725,4 +1741,49 @@ public final SymbolTable getOrCreateSymbolTable() {\n             return createSymbolTable();\n         }\n     }\n+\n+    /**\n+     * Temporary storage for a debug context installed in a nested scope under a call.\n+     * to {@link #withDebugContext}\n+     */\n+    private DebugContext debugContext = null;\n+\n+    /**\n+     * Allows a function to be executed with a specific debug context in a named subscope bound to\n+     * the object file and accessible to code invoked during the lifetime of the function. Invoked\n+     * code may obtain access to the debug context using method {@link #debugContext}.\n+     * @param context a context to be bound toin the object file for the duration of the function\n+     *        execution.\n+     * @param scopeName a name to be used to define a subscope current while the function is being\n+     *        executed.\n+     * @param t a value to be injected into the function that performs the action.\n+     * @param function a function to be executed while the context is bound to the object file.\n+     */\n+    @SuppressWarnings(\"try\")\n+    public <T, R> R withDebugContext(DebugContext context,  String scopeName, T t, Function<T, R> function) {", "originalCommit": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5MTU3MA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395091570", "bodyText": "Actually you can even make that a Runnable. The passing of the channel like this is pointless ceremony.\nThen in com/oracle/svm/hosted/image/NativeBootImage.java you just have\ntry (FileChannel channel = FileChannel.open(outputFile, StandardOpenOption.WRITE, StandardOpenOption.READ, StandardOpenOption.TRUNCATE_EXISTING, StandardOpenOption.CREATE)) {\n    objectFile.withDebugContext(context, \"ObjectFile.write\", () -> {\n        objectFile.write(channel);\n    });\n}\n\nRemember this is not C++ ;-)", "author": "olpaw", "createdAt": "2020-03-19T14:59:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA3OTQ0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTE0MDAwNw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395140007", "bodyText": "Well, I did start with a Consumer and then changed to a Function just in case you might want a more future-proof API. I was thinking it might later be decided that some other step of the ObjectFile write might need tracing and we could employ this Function flavour of withDebugContext where the operation needs to return a result. I'll happily switch to Consumer/Runnable. We can always switch back to Function if the need arises.\nAnd don't worry I have as little urge to use C++ features as the next OpenJDK programmer (well, modulo a few project 'enthusiasts' whose love of obscure C++ truly baffles me). Now Lisp would be a different matter . . . ;-)", "author": "adinn", "createdAt": "2020-03-19T16:03:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA3OTQ0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5NzUxMw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395097513", "bodyText": "Since we will also have Windows debug info generation it might be better to use\nreturn \"debug.dwarf.\" + getSectionName();\n\nhere so that we can have\nreturn \"debug.pdb.\" + getSectionName();\n\nfor Windows.", "author": "olpaw", "createdAt": "2020-03-19T15:07:03Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java", "diffHunk": "@@ -0,0 +1,396 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.elf.ELFObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.nio.ByteOrder;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.elf.dwarf.DwarfSections.TEXT_SECTION_NAME;\n+\n+/**\n+ * class from which all DWARF debug sections inherit providing common behaviours.\n+ */\n+public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+    protected DwarfSections dwarfSections;\n+    public boolean debug = false;\n+    public long debugTextBase = 0;\n+    public long debugAddress = 0;\n+    public int debugBase = 0;\n+\n+    public DwarfSectionImpl(DwarfSections dwarfSections) {\n+        this.dwarfSections = dwarfSections;\n+    }\n+\n+    /**\n+     * creates the target byte[] array used to define the section contents.\n+     *\n+     * the main task of this method is to precompute the size of the debug section. given the\n+     * complexity of the data layouts that invariably requires performing a dummy write of the\n+     * contents, inserting bytes into a small, scratch buffer only when absolutely necessary.\n+     * subclasses may also cache some information for use when writing the contents.\n+     */\n+    public abstract void createContent();\n+\n+    /**\n+     * populates the byte[] array used to contain the section contents.\n+     *\n+     * in most cases this task reruns the operations performed under createContent but this time\n+     * actually writing data to the target byte[].\n+     */\n+    public abstract void writeContent(DebugContext debugContext);\n+\n+    @Override\n+    public boolean isLoadable() {\n+        /*\n+         * even though we're a progbits section impl we're not actually loadable\n+         */\n+        return false;\n+    }\n+\n+    public String debugSectionLogName() {", "originalCommit": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEzMTc4Nw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395131787", "bodyText": "Sure will correct that. I guess I should also leave the section name in lower case as well.", "author": "adinn", "createdAt": "2020-03-19T15:52:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5NzUxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEzNTUwMw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395135503", "bodyText": "I guess I should also leave the section name in lower case as well.\n\nYes. That would fit better to our existing use of scope names.", "author": "olpaw", "createdAt": "2020-03-19T15:57:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTA5NzUxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTExOTA0OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395119048", "bodyText": "Is this a write-only field?", "author": "olpaw", "createdAt": "2020-03-19T15:35:23Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/elf/dwarf/DwarfSectionImpl.java", "diffHunk": "@@ -0,0 +1,396 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Red Hat Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.elf.dwarf;\n+\n+import com.oracle.objectfile.BasicProgbitsSectionImpl;\n+import com.oracle.objectfile.BuildDependency;\n+import com.oracle.objectfile.LayoutDecision;\n+import com.oracle.objectfile.LayoutDecisionMap;\n+import com.oracle.objectfile.ObjectFile;\n+import com.oracle.objectfile.debugentry.ClassEntry;\n+import com.oracle.objectfile.elf.ELFObjectFile;\n+import org.graalvm.compiler.debug.DebugContext;\n+\n+import java.nio.ByteOrder;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.oracle.objectfile.elf.dwarf.DwarfSections.TEXT_SECTION_NAME;\n+\n+/**\n+ * class from which all DWARF debug sections inherit providing common behaviours.\n+ */\n+public abstract class DwarfSectionImpl extends BasicProgbitsSectionImpl {\n+    protected DwarfSections dwarfSections;\n+    public boolean debug = false;\n+    public long debugTextBase = 0;\n+    public long debugAddress = 0;\n+    public int debugBase = 0;", "originalCommit": "c48f0c122ee6b72f03f6d385d6d9fc3b6217725e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTEzMTA4Nw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r395131087", "bodyText": "These are used when trace logging is enabled. They are updated in method enableLog(). n.b. currently only 3 of the DwarfSectionImpl subclasses generate trace. However, I have added the trace log functionality at the superclass level so that all Impl classes use it if/when it turns out to be needed.", "author": "adinn", "createdAt": "2020-03-19T15:51:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTExOTA0OA=="}], "type": "inlineReview"}, {"oid": "648cb8c2c35d90ff136785d7f4e2ec5737fe3ef1", "url": "https://github.com/oracle/graal/commit/648cb8c2c35d90ff136785d7f4e2ec5737fe3ef1", "message": "Checkstyle adjustments for copyright header", "committedDate": "2020-03-20T12:00:30Z", "type": "forcePushed"}, {"oid": "536baf5fca1685afe4205fc2bca846568ab5043b", "url": "https://github.com/oracle/graal/commit/536baf5fca1685afe4205fc2bca846568ab5043b", "message": "avoid repeated dot in scope name", "committedDate": "2020-03-20T16:16:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDIzNTk3OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r400235978", "bodyText": "@adinn, I think I already mentioned it, it's rather unusual in our codebase to start comments with lowercase.", "author": "olpaw", "createdAt": "2020-03-30T14:28:07Z", "path": "substratevm/src/com.oracle.objectfile/src/com/oracle/objectfile/debugentry/Range.java", "diffHunk": "@@ -0,0 +1,158 @@\n+/*\n+ * Copyright (c) 2020, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, 2020, Red Hat, Inc. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+\n+package com.oracle.objectfile.debugentry;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+/**\n+ * Details of a specific address range in a compiled method either a primary range identifying a\n+ * whole method or a sub-range identifying a sequence of instructions that belong to an inlined\n+ * method.\n+ */\n+\n+public class Range {\n+    private String fileName;\n+    private Path filePath;\n+    private String className;\n+    private String methodName;\n+    private String paramNames;\n+    private String returnTypeName;\n+    private String fullMethodName;\n+    private int lo;\n+    private int hi;\n+    private int line;\n+    /*\n+     * this is null for a primary range", "originalCommit": "b17a12e2847085772f41ef3e9762d957865bcd05", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDM5NjU3MQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r400396571", "bodyText": "Hmm, yes. A-and also this specific case is very wrong ... this can never be null :-)\nI'll get my coat . . .\nSorry. I thought I had fixed all these but I clearly missed some. I have just done a full pass through all the new/changed files. I am fairly sure I now have all comments starting with a capital letter and ending with a full stop.", "author": "adinn", "createdAt": "2020-03-30T18:15:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDIzNTk3OA=="}], "type": "inlineReview"}, {"oid": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "url": "https://github.com/oracle/graal/commit/0a0b19984f6a90726dbff59cd65e05e260de6d81", "message": "Add test of debuginfo generation to gate tests", "committedDate": "2020-03-31T11:25:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg1MDUwMA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r400850500", "bodyText": "You should use '-H:GenerateDebugInfo=1' also for\n\njavac_image(...)\nFirst helloworld(...) build (non-shared library build of hello world image)\ncinterfacetutorial(...)\n\nOtherwise it's pointless to build those images in GraalTags.helloworld_debug", "author": "olpaw", "createdAt": "2020-03-31T11:51:31Z", "path": "substratevm/mx.substratevm/mx_substratevm.py", "diffHunk": "@@ -468,6 +468,19 @@ def svm_gate_body(args, tasks):\n                 cinterfacetutorial([])\n                 clinittest([])\n \n+        with Task('image demos debuginfo', tasks, tags=[GraalTags.helloworld_debug]) as t:\n+            if t:\n+                if svm_java8():", "originalCommit": "0a0b19984f6a90726dbff59cd65e05e260de6d81", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg3NjQ0NQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r400876445", "bodyText": "Ah ok. I had no idea what that script was doing. I hope I have got it right this time.", "author": "adinn", "createdAt": "2020-03-31T12:34:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg1MDUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg3NzAxOQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r400877019", "bodyText": "I also fixed the eclipse format problems.", "author": "adinn", "createdAt": "2020-03-31T12:35:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg1MDUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDkzNzU5Ng==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r400937596", "bodyText": "The gate seems to be blocked however and closing then re-opening the PR seems not to have restarted testing.", "author": "adinn", "createdAt": "2020-03-31T14:01:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg1MDUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk1MTQyNw==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r400951427", "bodyText": "That's annoying. Sorry to hear. You should be able to run your new gate task locally with\nmx gate --omit-clean --tags build,helloworld_debug", "author": "olpaw", "createdAt": "2020-03-31T14:19:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg1MDUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk1MzY1OA==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r400953658", "bodyText": "Btw, you forgot to also add helloworld_debug to \n  \n    \n      graal/substratevm/mx.substratevm/mx_substratevm.py\n    \n    \n         Line 361\n      in\n      51c8f8f\n    \n    \n    \n    \n\n        \n          \n           'helloworld',", "author": "olpaw", "createdAt": "2020-03-31T14:22:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg1MDUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk1NTYzOQ==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r400955639", "bodyText": "... and here: \n  \n    \n      graal/.travis.yml\n    \n    \n         Line 29\n      in\n      97876cd\n    \n    \n    \n    \n\n        \n          \n           - env: JDK=\"jdk8\" GATE=\"build,test,helloworld\" PRIMARY=\"substratevm\"", "author": "olpaw", "createdAt": "2020-03-31T14:24:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg1MDUwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk4MTUyMg==", "url": "https://github.com/oracle/graal/pull/2088#discussion_r400981522", "bodyText": "Ok, I added those changes (although I have no proper idea what they are meant to achieve :-) and the above mx gate command appears to be do its stuff without errors. Also, the Travis gate build seems to be running again after pushing those changes.", "author": "adinn", "createdAt": "2020-03-31T14:57:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDg1MDUwMA=="}], "type": "inlineReview"}, {"oid": "b4680c224c85730ac0221155bab5881b98ea5bc1", "url": "https://github.com/oracle/graal/commit/b4680c224c85730ac0221155bab5881b98ea5bc1", "message": "Code cleanups", "committedDate": "2020-03-31T13:30:27Z", "type": "forcePushed"}, {"oid": "51c8f8f55d012aa5f073a608de6b66931c419c00", "url": "https://github.com/oracle/graal/commit/51c8f8f55d012aa5f073a608de6b66931c419c00", "message": "Code cleanups", "committedDate": "2020-03-31T13:46:17Z", "type": "forcePushed"}, {"oid": "dc16efa8528c7fb20a3bee0671214eee15edecff", "url": "https://github.com/oracle/graal/commit/dc16efa8528c7fb20a3bee0671214eee15edecff", "message": "use unique name for debuginfo gate test", "committedDate": "2020-04-01T09:41:07Z", "type": "forcePushed"}, {"oid": "ab1cb427a768786f0e6a70ae58e907861d8969de", "url": "https://github.com/oracle/graal/commit/ab1cb427a768786f0e6a70ae58e907861d8969de", "message": "Implement basic debuginfo generation for ELF objects", "committedDate": "2020-04-03T10:55:26Z", "type": "commit"}, {"oid": "84516d367c30a9493ceab8b96043512a45442536", "url": "https://github.com/oracle/graal/commit/84516d367c30a9493ceab8b96043512a45442536", "message": "Add option GenerateDebugInfo=<level>", "committedDate": "2020-04-03T10:55:26Z", "type": "commit"}, {"oid": "25c7101fcc02d41865ef60545b6177ee7842dbef", "url": "https://github.com/oracle/graal/commit/25c7101fcc02d41865ef60545b6177ee7842dbef", "message": "Use Path expressions for directories and file names", "committedDate": "2020-04-03T10:55:26Z", "type": "commit"}, {"oid": "53278b9babb1b18ffe927b1adbfbc73c7b3dddf1", "url": "https://github.com/oracle/graal/commit/53278b9babb1b18ffe927b1adbfbc73c7b3dddf1", "message": "Implement source file cache", "committedDate": "2020-04-03T10:55:26Z", "type": "commit"}, {"oid": "4161ea3d06d8f9c91dded5625a23a7b6ba7bd945", "url": "https://github.com/oracle/graal/commit/4161ea3d06d8f9c91dded5625a23a7b6ba7bd945", "message": "Modify debug info API to use streams instead of iterators", "committedDate": "2020-04-03T10:55:26Z", "type": "commit"}, {"oid": "259171c5618e71769cbc7610e0ffc136d7d77562", "url": "https://github.com/oracle/graal/commit/259171c5618e71769cbc7610e0ffc136d7d77562", "message": "Added option DebugInfoSourceSearchPath=<path>\n\nTweak SourceCacheType enum\n\nClean up SourceCache initialization\n\nMemoize source cache checks", "committedDate": "2020-04-03T10:55:26Z", "type": "commit"}, {"oid": "4b0aec7af896b5b20a0cbee931cf963906187669", "url": "https://github.com/oracle/graal/commit/4b0aec7af896b5b20a0cbee931cf963906187669", "message": "Support hierarchical logging", "committedDate": "2020-04-03T10:55:26Z", "type": "commit"}, {"oid": "1ac2fb1f0821d96d002d9f46553b889bbb1c27c0", "url": "https://github.com/oracle/graal/commit/1ac2fb1f0821d96d002d9f46553b889bbb1c27c0", "message": "Add test of debuginfo generation to gate tests", "committedDate": "2020-04-03T10:55:26Z", "type": "forcePushed"}, {"oid": "e4c876066b1122091bcaf68d869f94961d751724", "url": "https://github.com/oracle/graal/commit/e4c876066b1122091bcaf68d869f94961d751724", "message": "Abstract generic code for modelling debug info from DwarfSections into DebugInfoBase\n\nRename subclass DwarfSections to DwarfDebugInfo", "committedDate": "2020-04-06T09:44:26Z", "type": "commit"}, {"oid": "261045f807bdc6649c56fdbe8f93cd54b52e96a5", "url": "https://github.com/oracle/graal/commit/261045f807bdc6649c56fdbe8f93cd54b52e96a5", "message": "Add test of debuginfo generation to gate tests", "committedDate": "2020-04-06T09:45:25Z", "type": "commit"}, {"oid": "261045f807bdc6649c56fdbe8f93cd54b52e96a5", "url": "https://github.com/oracle/graal/commit/261045f807bdc6649c56fdbe8f93cd54b52e96a5", "message": "Add test of debuginfo generation to gate tests", "committedDate": "2020-04-06T09:45:25Z", "type": "forcePushed"}]}