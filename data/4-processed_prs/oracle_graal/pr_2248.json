{"pr_number": 2248, "pr_title": "AArch64: Eliminate redundant constant load instructions.", "pr_createdAt": "2020-03-11T06:22:11Z", "pr_url": "https://github.com/oracle/graal/pull/2248", "timeline": [{"oid": "7adcdcc955c09479552bdd15e5be295c4c3f10d3", "url": "https://github.com/oracle/graal/commit/7adcdcc955c09479552bdd15e5be295c4c3f10d3", "message": "Eliminate redundant constant load instructions.\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not deleted even though it will\nnever be used. To fix it, this patch inserts a phase applied to\nLIRInstructions. It's used to eliminate the unused constant load ops\nbefore code generation. Although it is limited to constant load ops\ncurrently, it can also be extended to remove other kinds of unused\ninstructions if needed in future.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1", "committedDate": "2020-03-11T07:15:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk4MDI5Ng==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r390980296", "bodyText": "minor: remove this.", "author": "zapster", "createdAt": "2020-03-11T13:46:06Z", "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.collectUnusedInBlock(b);", "originalCommit": "7adcdcc955c09479552bdd15e5be295c4c3f10d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk4MDU2Mw==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r390980563", "bodyText": "minor: remove this.", "author": "zapster", "createdAt": "2020-03-11T13:46:28Z", "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.removeUnusedInBlock(b);", "originalCommit": "7adcdcc955c09479552bdd15e5be295c4c3f10d3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk4Mzk1Ng==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r390983956", "bodyText": "I might be wrong, but IIRC all LIR phases should be able to deal with nulls in the instruction list. Deleting them manually should not be necessary.", "author": "zapster", "createdAt": "2020-03-11T13:51:26Z", "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.removeUnusedInBlock(b);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Collect unused instructions for a {@code block}.\n+         */\n+        private void collectUnusedInBlock(AbstractBlockBase<?> block) {\n+            InstructionValueConsumer defConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value) && isEligibleOp(instruction)) {\n+                    DefEntry def = new DefEntry(block, instruction, value);\n+                    unUsedDefs.put(((Variable) value), def);\n+                }\n+            };\n+\n+            InstructionValueConsumer useConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value)) {\n+                    DefEntry def = unUsedDefs.get((Variable) value);\n+                    if (def != null) {\n+                        assert def.value.equals(value);\n+                        // Remove the instruction that defined this value from the unused map.\n+                        LIRInstruction inst = def.instruction;\n+                        unUsedDefs.filter(d -> (!d.instruction.equals(inst)));\n+                    }\n+                }\n+            };\n+\n+            int opId = 0;\n+            for (LIRInstruction inst : lir.getLIRforBlock(block)) {\n+                inst.setId(opId++);\n+                inst.visitEachOutput(defConsumer);\n+                inst.visitEachInput(useConsumer);\n+                inst.visitEachAlive(useConsumer);\n+                inst.visitEachTemp(useConsumer);\n+                inst.visitEachState(useConsumer);\n+            }\n+        }\n+\n+        /**\n+         * Currently we only find the unused constant load instructions that can be safely removed.\n+         * If there are any other kinds of eligible instructions, please extend the condition here.\n+         */\n+        private static boolean isEligibleOp(LIRInstruction inst) {\n+            return inst.isLoadConstantOp();\n+        }\n+\n+        /**\n+         * Remove unused instructions for a {@code block}.\n+         */\n+        private void removeUnusedInBlock(AbstractBlockBase<?> block) {\n+            boolean hasDead = false;\n+            ArrayList<LIRInstruction> instructions = lir.getLIRforBlock(block);\n+            for (LIRInstruction instruction : instructions) {\n+                if (instruction == null) {\n+                    hasDead = true;\n+                } else {\n+                    instruction.setId(-1);\n+                }\n+            }\n+\n+            // delete unused instructions\n+            if (hasDead) {\n+                instructions.removeAll(Collections.singleton(null));", "originalCommit": "7adcdcc955c09479552bdd15e5be295c4c3f10d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQyMjE5Nw==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r391422197", "bodyText": "I'm not quite sure about this, but I think this is not guaranteed. For example null value LIRInstruction will cause NullPointerException in MarkBasePointersPhase. So I think it's necessary to delete them here.", "author": "XiaohongGong", "createdAt": "2020-03-12T06:26:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk4Mzk1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQyNzE2OQ==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r391427169", "bodyText": "Right, only later phases (after RA) can deal with that.", "author": "zapster", "createdAt": "2020-03-12T06:44:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk4Mzk1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk5MDE5OQ==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r390990199", "bodyText": "At some point we tried to avoid allocating lambdas. I'd replace d -> (!d.instruction.equals(inst)) with a static method (e.g. RedundantInstructionElimination::filterDefEntry).", "author": "zapster", "createdAt": "2020-03-11T14:00:17Z", "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        this.removeUnusedInBlock(b);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Collect unused instructions for a {@code block}.\n+         */\n+        private void collectUnusedInBlock(AbstractBlockBase<?> block) {\n+            InstructionValueConsumer defConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value) && isEligibleOp(instruction)) {\n+                    DefEntry def = new DefEntry(block, instruction, value);\n+                    unUsedDefs.put(((Variable) value), def);\n+                }\n+            };\n+\n+            InstructionValueConsumer useConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value)) {\n+                    DefEntry def = unUsedDefs.get((Variable) value);\n+                    if (def != null) {\n+                        assert def.value.equals(value);\n+                        // Remove the instruction that defined this value from the unused map.\n+                        LIRInstruction inst = def.instruction;\n+                        unUsedDefs.filter(d -> (!d.instruction.equals(inst)));", "originalCommit": "7adcdcc955c09479552bdd15e5be295c4c3f10d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTQyOTUyNQ==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r391429525", "bodyText": "Thanks for your review! Yeah, it makes sense. However, since VariableMap has the public API public void filter(Predicate<T> predicate)  to specially handle the filtration. I think it's better not to create another one. Another problem to use a static method in RedundantInstructionElimination is that the members of VariableMap are private and they are not expected to be public. We need to add another API to expose them if we want to go through them outside of class VariableMap .  But if you insist your opinion, I will try to fix it. Thanks!", "author": "XiaohongGong", "createdAt": "2020-03-12T06:52:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk5MDE5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTU2MzQwOA==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r391563408", "bodyText": "Ah, I missed that you are binding the local variable inst. Forget what I said.", "author": "zapster", "createdAt": "2020-03-12T11:39:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDk5MDE5OQ=="}], "type": "inlineReview"}, {"oid": "62c299285e8874b620448f786eb538a431287e75", "url": "https://github.com/oracle/graal/commit/62c299285e8874b620448f786eb538a431287e75", "message": "Eliminate redundant constant load instructions.\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not deleted even though it will\nnever be used. To fix it, this patch inserts a phase applied to\nLIRInstructions. It's used to eliminate the unused constant load ops\nbefore code generation. Although it is limited to constant load ops\ncurrently, it can also be extended to remove other kinds of unused\ninstructions if needed in future.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1", "committedDate": "2020-03-12T09:08:20Z", "type": "forcePushed"}, {"oid": "f02e6639b83dacbc0c0658d008fee87f0d4cb19b", "url": "https://github.com/oracle/graal/commit/f02e6639b83dacbc0c0658d008fee87f0d4cb19b", "message": "AArch64: Eliminate redundant constant load instructions.\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not deleted even though it will\nnever be used. To fix it, this patch inserts a phase applied to\nLIRInstructions. It's used to eliminate the unused constant load ops\nbefore code generation. Although it is limited to constant load ops\ncurrently, it can also be extended to remove other kinds of unused\ninstructions if needed in future.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1", "committedDate": "2020-03-13T03:19:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5MjY2Mw==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432292663", "bodyText": "I'd rewrite this to\n        for (T e : content) {\n            if (e != null) {\n                return false;\n            }\n        }\n        return true;\nNot a blocker, though.", "author": "zapster", "createdAt": "2020-05-29T07:03:11Z", "path": "compiler/src/org.graalvm.compiler.lir/src/org/graalvm/compiler/lir/VariableMap.java", "diffHunk": "@@ -87,4 +85,38 @@ public void filter(Predicate<T> predicate) {\n         }\n     }\n \n+    public boolean isEmpty() {\n+        if (content.isEmpty()) {\n+            return true;\n+        }\n+\n+        boolean empty = true;\n+        for (T e : content) {\n+            if (e != null) {\n+                empty = false;\n+                break;\n+            }\n+        }\n+        return empty;", "originalCommit": "f02e6639b83dacbc0c0658d008fee87f0d4cb19b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMzNDQ5Mg==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432334492", "bodyText": "Good catch! Thanks!", "author": "XiaohongGong", "createdAt": "2020-05-29T08:29:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5MjY2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5NzQ1Mw==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432297453", "bodyText": "Since we are in SSA form, there can be only one instruction defining a variable. Thus, I think the code can be changed to unUsedDefs.remove((asVariable(value)).", "author": "zapster", "createdAt": "2020-05-29T07:14:44Z", "path": "compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir.aarch64;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.InstructionValueConsumer;\n+import org.graalvm.compiler.lir.LIR;\n+import org.graalvm.compiler.lir.LIRInstruction;\n+import org.graalvm.compiler.lir.Variable;\n+import org.graalvm.compiler.lir.VariableMap;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class AArch64RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"AArch64RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        removeUnusedInBlock(b);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Collect unused instructions for a {@code block}.\n+         */\n+        private void collectUnusedInBlock(AbstractBlockBase<?> block) {\n+            InstructionValueConsumer defConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value) && isEligibleOp(instruction)) {\n+                    DefEntry def = new DefEntry(block, instruction, value);\n+                    unUsedDefs.put(((Variable) value), def);\n+                }\n+            };\n+\n+            InstructionValueConsumer useConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value)) {\n+                    DefEntry def = unUsedDefs.get((Variable) value);\n+                    if (def != null) {\n+                        assert def.value.equals(value);\n+                        // Remove the instruction that defined this value from the unused map.\n+                        LIRInstruction inst = def.instruction;\n+                        unUsedDefs.filter(d -> (!d.instruction.equals(inst)));", "originalCommit": "f02e6639b83dacbc0c0658d008fee87f0d4cb19b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxNDQ0OQ==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432314449", "bodyText": "Actually, directly calling remove is all right for ConstantLoadOp. Thanks! My original concern is the Def with an array type like @Def({REG, STACK}) private Value[] incomingValues; of LabelOp. If an instruction has a definition with an array type. It actually has multiply definition values. And if any of the member is used, the instruction should not be removed. So I use the filter instead of \"remove\".  Anyway it seems this might not be possible for all the existed ConstantLoadOp.", "author": "XiaohongGong", "createdAt": "2020-05-29T07:50:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5NzQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMyMzQyMw==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432323423", "bodyText": "If an instruction has a definition with an array type. It actually has multiply definition values.\n\nThat is right. In that case, there is still no need to use filter (which can be expensive I think) but do something like this (more or less pseudocode):\nInstructionValueConsumer removeConsumer = (instruction, value, mode, flags) -> {\n    if (isVariable(value)) {\n        unUsedDefs.remove(asVariable(value));\n    }\n};\n...\ninst.visitEachOutput(removeConsumer);", "author": "zapster", "createdAt": "2020-05-29T08:08:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5NzQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMzMzA5Ng==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432333096", "bodyText": "OK, it seems reasonable! So as a conclusion, which do you think is better:  add these codes to handle the corner case, or just a directly unUsedDefs.remove(asVariable(value)) is enough? I think the latter is ok. Your opinion? Thanks!", "author": "XiaohongGong", "createdAt": "2020-05-29T08:27:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5NzQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMzNjM5MA==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432336390", "bodyText": "I agree, remove is fine. However, I'd add a comment why this is OK and an assertion that inst in no longer in any entry of the unUsedDefs map to catch error early if our assumption changes.", "author": "zapster", "createdAt": "2020-05-29T08:33:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5NzQ1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMzNzM4Mg==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432337382", "bodyText": "Good idea! I will update the patch soon! Thank you!", "author": "XiaohongGong", "createdAt": "2020-05-29T08:35:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5NzQ1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5ODM3OA==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432298378", "bodyText": "We usually use LIRValueUtil.asVariable(value) instead of a direct cast, often with a static import so the code would change to unUsedDefs.put(asVariable(value)), def);. But it is a question of style preference and not a blocker.", "author": "zapster", "createdAt": "2020-05-29T07:16:49Z", "path": "compiler/src/org.graalvm.compiler.lir.aarch64/src/org/graalvm/compiler/lir/aarch64/AArch64RedundantInstructionElimination.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited and affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.lir.aarch64;\n+\n+import static org.graalvm.compiler.lir.LIRValueUtil.isVariable;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+\n+import org.graalvm.compiler.core.common.cfg.AbstractBlockBase;\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.debug.Indent;\n+import org.graalvm.compiler.lir.InstructionValueConsumer;\n+import org.graalvm.compiler.lir.LIR;\n+import org.graalvm.compiler.lir.LIRInstruction;\n+import org.graalvm.compiler.lir.Variable;\n+import org.graalvm.compiler.lir.VariableMap;\n+import org.graalvm.compiler.lir.gen.LIRGenerationResult;\n+import org.graalvm.compiler.lir.phases.PreAllocationOptimizationPhase;\n+\n+import jdk.vm.ci.code.TargetDescription;\n+import jdk.vm.ci.meta.Value;\n+\n+/**\n+ * This optimization tries to remove unused instructions. Currently it only removes the constant\n+ * load instructions. The unused constant mov may exist after match rules.\n+ */\n+public final class AArch64RedundantInstructionElimination extends PreAllocationOptimizationPhase {\n+\n+    @Override\n+    protected void run(TargetDescription target, LIRGenerationResult lirGenRes, PreAllocationOptimizationContext context) {\n+        new Optimization(lirGenRes.getLIR()).apply();\n+    }\n+\n+    private static final class Optimization {\n+        private final LIR lir;\n+        private final VariableMap<DefEntry> unUsedDefs;\n+        private final DebugContext debug;\n+\n+        private Optimization(LIR lir) {\n+            this.lir = lir;\n+            this.debug = lir.getDebug();\n+            this.unUsedDefs = new VariableMap<>();\n+        }\n+\n+        @SuppressWarnings(\"try\")\n+        private void apply() {\n+            try (Indent indent = debug.logAndIndent(\"AArch64RedundantInstructionElimination\")) {\n+                try (DebugContext.Scope s = debug.scope(\"CollectUnusedInstructions\")) {\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        collectUnusedInBlock(b);\n+                    }\n+\n+                    if (!unUsedDefs.isEmpty()) {\n+                        debug.log(\"Redundant instructions that will be removed later: %s\", unUsedDefs);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+\n+                try (DebugContext.Scope s = debug.scope(\"DeleteUnusedInstructions\")) {\n+                    unUsedDefs.forEach(this::deleteInstruction);\n+                    // Remove unused instructions for each block.\n+                    for (AbstractBlockBase<?> b : lir.getControlFlowGraph().getBlocks()) {\n+                        removeUnusedInBlock(b);\n+                    }\n+                } catch (Throwable e) {\n+                    throw debug.handle(e);\n+                }\n+            }\n+        }\n+\n+        /**\n+         * Collect unused instructions for a {@code block}.\n+         */\n+        private void collectUnusedInBlock(AbstractBlockBase<?> block) {\n+            InstructionValueConsumer defConsumer = (instruction, value, mode, flags) -> {\n+                if (isVariable(value) && isEligibleOp(instruction)) {\n+                    DefEntry def = new DefEntry(block, instruction, value);\n+                    unUsedDefs.put(((Variable) value), def);", "originalCommit": "f02e6639b83dacbc0c0658d008fee87f0d4cb19b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMzNDM3Mg==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r432334372", "bodyText": "Godd catch! I will update it soon! Thank you!", "author": "XiaohongGong", "createdAt": "2020-05-29T08:29:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5ODM3OA=="}], "type": "inlineReview"}, {"oid": "0990ae5c05e253ded8ff837273fcab9012852215", "url": "https://github.com/oracle/graal/commit/0990ae5c05e253ded8ff837273fcab9012852215", "message": "AArch64: Eliminate redundant constant load instructions.\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not deleted even though it will\nnever be used. To fix it, this patch inserts a phase applied to\nLIRInstructions. It's used to eliminate the unused constant load ops\nbefore code generation. Although it is limited to constant load ops\ncurrently, it can also be extended to remove other kinds of unused\ninstructions if needed in future.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1", "committedDate": "2020-06-01T07:16:40Z", "type": "forcePushed"}, {"oid": "b5c1d01a298771b7484296ceff60a729aee2b6ab", "url": "https://github.com/oracle/graal/commit/b5c1d01a298771b7484296ceff60a729aee2b6ab", "message": "AArch64: Eliminate redundant constant load instructions.\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not deleted even though it will\nnever be used. To fix it, this patch inserts a phase applied to\nLIRInstructions. It's used to eliminate the unused constant load ops\nbefore code generation. Although it is limited to constant load ops\ncurrently, it can also be extended to remove other kinds of unused\ninstructions if needed in future.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1", "committedDate": "2020-06-01T07:32:44Z", "type": "forcePushed"}, {"oid": "5c5f7c7f5bcce49c1eab663b30b096cd6e3fe591", "url": "https://github.com/oracle/graal/commit/5c5f7c7f5bcce49c1eab663b30b096cd6e3fe591", "message": "AArch64: Eliminate redundant constant load instructions.\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not deleted even though it will\nnever be used. To fix it, this patch inserts a phase applied to\nLIRInstructions. It's used to eliminate the unused constant load ops\nbefore code generation. Although it is limited to constant load ops\ncurrently, it can also be extended to remove other kinds of unused\ninstructions if needed in future.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1", "committedDate": "2020-06-02T07:14:04Z", "type": "forcePushed"}, {"oid": "126f62c924d8b155b9549c13ae220542eeae20cd", "url": "https://github.com/oracle/graal/commit/126f62c924d8b155b9549c13ae220542eeae20cd", "message": "Make sharable nodes be consumable by matched rules\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not consumed by the matched rules\nsince ConstantNode is sharable.\n\nTo fix it, this patch adds the modifications to the matching codes:\n  1) Adds the \"consumable\" flag for matching. It is used to decide\nwhether a node can be consumed by a matched rule.\n  2) Adds the class \"SharedMatchValue\". It is used as the operand for\na sharable and consumable node, if the node is swallowed by the matched\nrules. It doesn't emit any codes.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1", "committedDate": "2020-06-05T06:57:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkzNTI3NQ==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r436935275", "bodyText": "Why is this necessary?  I don't think this is safe is the return operand is a virtual register.", "author": "tkrodriguez", "createdAt": "2020-06-08T19:10:23Z", "path": "compiler/src/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/NodeLIRBuilder.java", "diffHunk": "@@ -171,6 +174,10 @@ protected DebugInfoBuilder createDebugInfoBuilder(StructuredGraph graph, NodeVal\n     @Override\n     public Value operand(Node node) {\n         Value operand = getOperand(node);\n+        if (node instanceof ValueNode && operand instanceof SharedMatchValue) {", "originalCommit": "126f62c924d8b155b9549c13ae220542eeae20cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1NTc1OA==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r437155758", "bodyText": "This is to handle the case when ConstantNode is matched but not swallowed by the matched rule.  This is an example on aarch64:\n @MatchRule(\"(Add=op (UnsignedRightShift=x src Constant=shiftAmt1) (LeftShift src Constant=shiftAmt2))\")\n public ComplexMatchResult rotationConstant(ValueNode op, ValueNode x, ValueNode src, ConstantNode shiftAmt1, ConstantNode shiftAmt2) {\n    assert src.getStackKind().isNumericInteger();\n    assert shiftAmt1.getStackKind().getBitCount() == 32;\n    assert shiftAmt2.getStackKind().getBitCount() == 32;\n\n    int shift1 = shiftAmt1.asJavaConstant().asInt();\n    int shift2 = shiftAmt2.asJavaConstant().asInt();\n    if (op instanceof AddNode && (0 == shift1 || 0 == shift2)) {\n        return null;\n    }\n    if ((0 == shift1 + shift2) || (src.getStackKind().getBitCount() == shift1 + shift2)) {\n    return builder -> {\n                Value a = operand(src);\n                Value b = x instanceof LeftShiftNode ? operand(shiftAmt2) : operand(shiftAmt1);\n                return getArithmeticLIRGenerator().emitBinary(LIRKind.combine(a, b), AArch64ArithmeticOp.ROR, false, a, b);\n            };\n    }\n    return null;\n  }\n\nThe ConstantNode shiftAmt1 and shiftAmt2 are all matched to the rule. However, it's still used as an operand of the final ROR. See:\nValue b = x instanceof LeftShiftNode ? operand(shiftAmt2) : operand(shiftAmt1);\n\nThe compiler cannot know the real usages inside of the evaluate function of the ComplexMatchValue during matching.\nAnother way to fix is to make it wrong when operand() of a matched ConstantNode is called. For the above rule, it needs some more modification at aarch64 backend which I don't think is friendly if fixing it.", "author": "XiaohongGong", "createdAt": "2020-06-09T06:00:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkzNTI3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYyNTA5Mw==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r437625093", "bodyText": "I think if it wants them as a constant then it needs to construct them in that form instead of going through operand.  Why can't it call emitBinaryConst directly using the JavaConstant from the node?  You can't safely do potentially lazy evaluation using doRoot since it might be called in a non-dominating position.", "author": "tkrodriguez", "createdAt": "2020-06-09T18:13:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkzNTI3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzk2ODUxNQ==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r437968515", "bodyText": "Yes, I greatly agree with you. I was thinking that it needs more effort to fix the rules, since this case also exists on AMD64. It seems easier and simpler than what I thought before.  I will fix it later. Thanks!", "author": "XiaohongGong", "createdAt": "2020-06-10T08:55:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjkzNTI3NQ=="}], "type": "inlineReview"}, {"oid": "5875c7ff7fce960c2a364a276b4197dee132f1d3", "url": "https://github.com/oracle/graal/commit/5875c7ff7fce960c2a364a276b4197dee132f1d3", "message": "Make sharable nodes be consumable by matched rules\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not consumed by the matched rules\nsince ConstantNode is sharable.\n\nTo fix it, this patch adds the modifications to the matching codes:\n  1) Adds the \"consumable\" flag for matching. It is used to decide\nwhether a node can be consumed by a matched rule.\n  2) Adds the class \"SharedMatchValue\". It is used as the operand for\na sharable and consumable node, if the node is swallowed by the matched\nrules. It doesn't emit any codes.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1", "committedDate": "2020-06-10T09:33:00Z", "type": "commit"}, {"oid": "5875c7ff7fce960c2a364a276b4197dee132f1d3", "url": "https://github.com/oracle/graal/commit/5875c7ff7fce960c2a364a276b4197dee132f1d3", "message": "Make sharable nodes be consumable by matched rules\n\nThis patch fixes issue: https://github.com/oracle/graal/issues/2216\n\nUnused constant load won't be deleted after match rules. As a result,\nit might generate redundant \"mov/orr\" instructions if the constants\ncannot be inlined to codes.\n\nFor example, the original codes:\n\n  lsr    w0, w0, #6\n  orr    w1, wzr, #0xfffff\n  and    w0, w0, w1\n\nwill be optimized to the following pattern by adding match rules:\n\n  orr    w1, wzr, #0xfffff\n  ubfx   w0, w0, #6, #20\n\nHowever, the constant \"0xfffff\" is not consumed by the matched rules\nsince ConstantNode is sharable.\n\nTo fix it, this patch adds the modifications to the matching codes:\n  1) Adds the \"consumable\" flag for matching. It is used to decide\nwhether a node can be consumed by a matched rule.\n  2) Adds the class \"SharedMatchValue\". It is used as the operand for\na sharable and consumable node, if the node is swallowed by the matched\nrules. It doesn't emit any codes.\n\nChange-Id: Ibed66714c12e02f400ab494683dee8826ede01a1", "committedDate": "2020-06-10T09:33:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU1Mzk4Mw==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r438553983", "bodyText": "You know I don't really thing we need SharedMatchValue.  If we're going to maintain a side table we can just as easily store an Integer to track the count.  Then when it's equal to getUsageCount() we can store INTERIOR_MATCH into nodeOperands.  I could make that change if you're amenable to it.", "author": "tkrodriguez", "createdAt": "2020-06-11T05:41:47Z", "path": "compiler/src/org.graalvm.compiler.core/src/org/graalvm/compiler/core/gen/NodeLIRBuilder.java", "diffHunk": "@@ -226,6 +229,19 @@ public void setMatchResult(Node x, Value operand) {\n         nodeOperands.set(x, operand);\n     }\n \n+    public void setSharedMatchResult(Node node) {\n+        assert nodeOperands != null && nodeOperands.get(node) == null : \"operand cannot be set twice\";\n+        SharedMatchValue matchValue = sharedMatchValues.get(node);", "originalCommit": "5875c7ff7fce960c2a364a276b4197dee132f1d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU4MDU5Mg==", "url": "https://github.com/oracle/graal/pull/2248#discussion_r438580592", "bodyText": "Yeah, agree! Actually the additional SharedMatchValue is not needed, and I think it's ok to remove it. Thanks for your review! And it's great that you could help to make it better. Thanks so much!", "author": "XiaohongGong", "createdAt": "2020-06-11T06:58:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODU1Mzk4Mw=="}], "type": "inlineReview"}]}