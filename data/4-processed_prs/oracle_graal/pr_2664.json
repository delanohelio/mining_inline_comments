{"pr_number": 2664, "pr_title": "Add more re-associations for associative binary operations", "pr_createdAt": "2020-07-10T08:21:32Z", "pr_url": "https://github.com/oracle/graal/pull/2664", "timeline": [{"oid": "9804f7ebbd1be5ea5945d97d6ca8f5f3525c1c6f", "url": "https://github.com/oracle/graal/commit/9804f7ebbd1be5ea5945d97d6ca8f5f3525c1c6f", "message": "Add more re-associations for associative binary operations\n\nChange-Id: I1fa87e348b9e66eb958bd43e9f0ebceff8ad2fcc", "committedDate": "2020-07-13T02:52:44Z", "type": "forcePushed"}, {"oid": "bb7477d0fddaf512fc2dd76705828eb1a61619b1", "url": "https://github.com/oracle/graal/commit/bb7477d0fddaf512fc2dd76705828eb1a61619b1", "message": "Add more re-associations for associative binary operations\n\nChange-Id: I8de6040ee07a09cdb17d57b17bcddaa8ea5f8f68", "committedDate": "2020-07-14T03:54:47Z", "type": "forcePushed"}, {"oid": "b28531d2206f8198ca7bcf8ec63ba46d1de0f1b3", "url": "https://github.com/oracle/graal/commit/b28531d2206f8198ca7bcf8ec63ba46d1de0f1b3", "message": "Add more re-associations for associative binary operations\n\nChange-Id: If32b49a14dd08ac1ab903878da0f459f452da221", "committedDate": "2020-07-14T05:19:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM5MjAzOQ==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r457392039", "bodyText": "please use a constant seed for tests (e.g. a prime number)", "author": "davleopo", "createdAt": "2020-07-20T13:38:43Z", "path": "compiler/src/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/ReassociateAndCanonicalTest2.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.core.test;\n+\n+import org.graalvm.compiler.nodes.StructuredGraph;\n+import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;\n+import org.junit.Test;\n+\n+public class ReassociateAndCanonicalTest2 extends GraalCompilerTest {\n+\n+    private static int rnd1 = (int) (Math.random() * 100);", "originalCommit": "b28531d2206f8198ca7bcf8ec63ba46d1de0f1b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1NjI3Mw==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r457856273", "bodyText": "OK, thanks for the advice! I will update it soon!", "author": "XiaohongGong", "createdAt": "2020-07-21T06:03:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM5MjAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM5MjU3OA==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r457392578", "bodyText": "Could you also please provide test cases for loops? some we are sure we do not want to regress any more in the future", "author": "davleopo", "createdAt": "2020-07-20T13:39:16Z", "path": "compiler/src/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/ReassociateAndCanonicalTest2.java", "diffHunk": "@@ -0,0 +1,362 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.core.test;\n+\n+import org.graalvm.compiler.nodes.StructuredGraph;\n+import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;\n+import org.junit.Test;\n+\n+public class ReassociateAndCanonicalTest2 extends GraalCompilerTest {", "originalCommit": "b28531d2206f8198ca7bcf8ec63ba46d1de0f1b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM5MzQ4Mw==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r457393483", "bodyText": "I would prefer a regular loop here if possible", "author": "davleopo", "createdAt": "2020-07-20T13:40:16Z", "path": "compiler/src/org.graalvm.compiler.loop.phases/src/org/graalvm/compiler/loop/phases/ReassociateInvariantPhase.java", "diffHunk": "@@ -31,25 +31,36 @@\n import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;\n import org.graalvm.compiler.phases.Phase;\n \n+import java.util.function.Predicate;\n+\n /**\n  * Rearrange {@link BinaryArithmeticNode#isAssociative() associative binary operations} so that\n  * invariant parts of the expression can move outside of the loop.\n  */\n public class ReassociateInvariantPhase extends Phase {\n+    private static final Predicate<LoopEx> reassociateVariants = loop -> loop.reassociateVariants();\n+    private static final Predicate<LoopEx> reassociateInvariants = loop -> loop.reassociateInvariants();\n \n     @SuppressWarnings(\"try\")\n     @Override\n     protected void run(StructuredGraph graph) {\n-        int iterations = 0;\n         DebugContext debug = graph.getDebug();\n-        try (DebugContext.Scope s = debug.scope(\"ReassociateInvariants\")) {\n+        try (DebugContext.Scope s = debug.scope(\"ReassociateLoopInvariant\")) {\n+            doReassociate(graph, reassociateVariants, debug, \"ReassociateVariants\");\n+            doReassociate(graph, reassociateInvariants, debug, \"ReassociateInvariants\");\n+        } catch (Throwable e) {\n+            throw debug.handle(e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"try\")\n+    private static void doReassociate(StructuredGraph graph, Predicate<LoopEx> predicate, DebugContext debug, String scope) {\n+        int iterations = 0;\n+        try (DebugContext.Scope s = debug.scope(scope)) {\n             boolean changed = true;\n             while (changed) {\n-                changed = false;\n                 final LoopsData dataReassociate = new LoopsData(graph);\n-                for (LoopEx loop : dataReassociate.loops()) {\n-                    changed |= loop.reassociateInvariants();\n-                }\n+                changed = dataReassociate.loops().stream().anyMatch(predicate);", "originalCommit": "b28531d2206f8198ca7bcf8ec63ba46d1de0f1b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1Njc1Mw==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r457856753", "bodyText": "Yeah, a regular loop better. I will update it later. Thanks for the advice!", "author": "XiaohongGong", "createdAt": "2020-07-21T06:04:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM5MzQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM5NDc0Mw==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r457394743", "bodyText": "is the phi predicate class & allocation necessary here? I might miss something but it seems it does not escape and the logic of apply is very simple.", "author": "davleopo", "createdAt": "2020-07-20T13:41:36Z", "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/BinaryArithmeticNode.java", "diffHunk": "@@ -235,6 +235,165 @@ private static ReassociateMatch findReassociate(BinaryNode binary, NodePredicate\n         return null;\n     }\n \n+    private static ReassociateMatch findReassociativeOperand(BinaryArithmeticNode<?> binary, NodePredicate criterion) {\n+        NodePredicate binaryCriterion = new ReassociativePredicate(binary);\n+        ValueNode forX = binary.getX();\n+        ValueNode forY = binary.getY();\n+        if (binaryCriterion.apply(forX) && findReassociate((BinaryNode) forX, criterion) != null) {\n+            return ReassociateMatch.x;\n+        }\n+\n+        if (binaryCriterion.apply(forY) && findReassociate((BinaryNode) forY, criterion) != null) {\n+            return ReassociateMatch.y;\n+        }\n+        return null;\n+    }\n+\n+    private static class ReassociativePredicate implements NodePredicate {\n+        private final BinaryArithmeticNode<?> binary;\n+\n+        ReassociativePredicate(BinaryArithmeticNode<?> binary) {\n+            this.binary = binary;\n+        }\n+\n+        @Override\n+        public boolean apply(Node node) {\n+            if (binary instanceof AddNode || binary instanceof SubNode) {\n+                return node instanceof AddNode || node instanceof SubNode;\n+            }\n+            return node.getClass() == binary.getClass();\n+        }\n+    }\n+\n+    private static class LoopPhiPredicate implements NodePredicate {\n+        private final BinaryArithmeticNode<?> binary;\n+\n+        LoopPhiPredicate(BinaryArithmeticNode<?> binary) {\n+            this.binary = binary;\n+        }\n+\n+        @Override\n+        public boolean apply(Node node) {\n+            if (node instanceof ValuePhiNode) {\n+                ValuePhiNode iv = (ValuePhiNode) node;\n+                return iv.values().contains(binary);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Tries to expose values which satisfy the criterion as an operand. This could create more\n+     * opportunities for other optimizations like constant-fold and loop-invariant elimination. For\n+     * example with a constantness criterion: {@code (a * 2) * b => (a * b) * 2}\n+     *\n+     * This method accepts only {@linkplain BinaryOp#isAssociative() associative} operations such as\n+     * +, -, *, &, | and ^\n+     */\n+    public static ValueNode reassociateUnmatchedValues(BinaryArithmeticNode<?> node, NodePredicate criterion, NodeView view, boolean skipLoopPhiValues) {\n+        ValueNode forX = node.getX();\n+        ValueNode forY = node.getY();\n+        assert node.getOp(forX, forY).isAssociative();\n+\n+        // Skip re-associations for expressions like \"i = i + var\". This may influence the counted\n+        // loop detection. For example, if the loop counter is re-associated from \"i += (var + 1)\"\n+        // to \"i = (i + var) + 1\", the counted loop will not be detected as expected.\n+        if (skipLoopPhiValues) {\n+            LoopPhiPredicate phiCriterion = new LoopPhiPredicate(node);", "originalCommit": "b28531d2206f8198ca7bcf8ec63ba46d1de0f1b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Nzg1MTQ2Mg==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r457851462", "bodyText": "Good catch! We could use a static function to check instead of NodePredicate here. Thanks!", "author": "XiaohongGong", "createdAt": "2020-07-21T05:48:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM5NDc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM5NTYwMQ==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r457395601", "bodyText": "also I am not sure this is restrictive enough. Have you tried with derived induction variables as well and what happens for re-associations of mul nodes?", "author": "davleopo", "createdAt": "2020-07-20T13:42:34Z", "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/BinaryArithmeticNode.java", "diffHunk": "@@ -235,6 +235,165 @@ private static ReassociateMatch findReassociate(BinaryNode binary, NodePredicate\n         return null;\n     }\n \n+    private static ReassociateMatch findReassociativeOperand(BinaryArithmeticNode<?> binary, NodePredicate criterion) {\n+        NodePredicate binaryCriterion = new ReassociativePredicate(binary);\n+        ValueNode forX = binary.getX();\n+        ValueNode forY = binary.getY();\n+        if (binaryCriterion.apply(forX) && findReassociate((BinaryNode) forX, criterion) != null) {\n+            return ReassociateMatch.x;\n+        }\n+\n+        if (binaryCriterion.apply(forY) && findReassociate((BinaryNode) forY, criterion) != null) {\n+            return ReassociateMatch.y;\n+        }\n+        return null;\n+    }\n+\n+    private static class ReassociativePredicate implements NodePredicate {\n+        private final BinaryArithmeticNode<?> binary;\n+\n+        ReassociativePredicate(BinaryArithmeticNode<?> binary) {\n+            this.binary = binary;\n+        }\n+\n+        @Override\n+        public boolean apply(Node node) {\n+            if (binary instanceof AddNode || binary instanceof SubNode) {\n+                return node instanceof AddNode || node instanceof SubNode;\n+            }\n+            return node.getClass() == binary.getClass();\n+        }\n+    }\n+\n+    private static class LoopPhiPredicate implements NodePredicate {\n+        private final BinaryArithmeticNode<?> binary;\n+\n+        LoopPhiPredicate(BinaryArithmeticNode<?> binary) {\n+            this.binary = binary;\n+        }\n+\n+        @Override\n+        public boolean apply(Node node) {\n+            if (node instanceof ValuePhiNode) {\n+                ValuePhiNode iv = (ValuePhiNode) node;\n+                return iv.values().contains(binary);\n+            }\n+            return false;\n+        }\n+    }\n+\n+    /**\n+     * Tries to expose values which satisfy the criterion as an operand. This could create more\n+     * opportunities for other optimizations like constant-fold and loop-invariant elimination. For\n+     * example with a constantness criterion: {@code (a * 2) * b => (a * b) * 2}\n+     *\n+     * This method accepts only {@linkplain BinaryOp#isAssociative() associative} operations such as\n+     * +, -, *, &, | and ^\n+     */\n+    public static ValueNode reassociateUnmatchedValues(BinaryArithmeticNode<?> node, NodePredicate criterion, NodeView view, boolean skipLoopPhiValues) {\n+        ValueNode forX = node.getX();\n+        ValueNode forY = node.getY();\n+        assert node.getOp(forX, forY).isAssociative();\n+\n+        // Skip re-associations for expressions like \"i = i + var\". This may influence the counted\n+        // loop detection. For example, if the loop counter is re-associated from \"i += (var + 1)\"\n+        // to \"i = (i + var) + 1\", the counted loop will not be detected as expected.\n+        if (skipLoopPhiValues) {\n+            LoopPhiPredicate phiCriterion = new LoopPhiPredicate(node);\n+            if (phiCriterion.apply(forX) || phiCriterion.apply(forY)) {", "originalCommit": "b28531d2206f8198ca7bcf8ec63ba46d1de0f1b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzgyMTM1Mg==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r457821352", "bodyText": "Regarding to the counted loop detection, I think re-associations for mul  nodes might have no influence to it, since the loop trip node should be a base induction variable, isn't it?\nAnd except for the counted loop, do you mean it might have any other influence for re-associations like a = 5 * i * 6  -> a = 30 * i?", "author": "XiaohongGong", "createdAt": "2020-07-21T03:57:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM5NTYwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ4OTcyMw==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r458489723", "bodyText": "The main concern to check the derived induction variables is that we need to get the LoopsData and detect the counted loop each time when canonicalizaion which I think influences the compile time more. Do you have any better idea to address it? Thanks!", "author": "XiaohongGong", "createdAt": "2020-07-22T02:01:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM5NTYwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTM4NTU4Mg==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r459385582", "bodyText": "no, I think we can come back there if necessary later. I was thinking of a case where we have a none re-associated basic induction variable and then a derived one and if the derived one can be destroyed if it is subject to re-association, but maybe that cannot happen, I just wanted to think it through...", "author": "davleopo", "createdAt": "2020-07-23T11:36:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzM5NTYwMQ=="}], "type": "inlineReview"}, {"oid": "154eef3a845c3d8cbd72f3bd09197fdfd3b7daa7", "url": "https://github.com/oracle/graal/commit/154eef3a845c3d8cbd72f3bd09197fdfd3b7daa7", "message": "Add more re-associations for associative binary operations\n\nChange-Id: If32b49a14dd08ac1ab903878da0f459f452da221", "committedDate": "2020-07-23T03:17:58Z", "type": "forcePushed"}, {"oid": "2c32b5b3b31f58a241b934c468f1dce00a29d248", "url": "https://github.com/oracle/graal/commit/2c32b5b3b31f58a241b934c468f1dce00a29d248", "message": "Add more re-associations for associative binary operations\n\nChange-Id: If32b49a14dd08ac1ab903878da0f459f452da221", "committedDate": "2020-08-17T10:00:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzMTM2Nw==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482031367", "bodyText": "we had problems with while(true) loops in the past and thus impose a policy where every while true loop must have an upper bound of iterations that should be a sanity filter.\nWhile it is true that this loop should terminate, in favor of defensive programming please add a constant upper number of iterations (idk 32? or what was the highest number of iterations y have seen during testing?) and abort the loop if the upper bound is reached.", "author": "davleopo", "createdAt": "2020-09-02T12:32:43Z", "path": "compiler/src/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/ReassociationPhase.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.phases.common;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.graph.NodeBitMap;\n+import org.graalvm.compiler.loop.LoopEx;\n+import org.graalvm.compiler.loop.LoopsData;\n+import org.graalvm.compiler.nodes.NodeView;\n+import org.graalvm.compiler.nodes.StructuredGraph;\n+import org.graalvm.compiler.nodes.ValueNode;\n+import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;\n+import org.graalvm.compiler.nodes.util.GraphUtil;\n+import org.graalvm.compiler.phases.Phase;\n+\n+/**\n+ * Rearrange {@link BinaryArithmeticNode#isAssociative() associative binary operations} for loop\n+ * invariants and constants.\n+ */\n+public class ReassociationPhase extends Phase {\n+\n+    @SuppressWarnings(\"try\")\n+    @Override\n+    protected void run(StructuredGraph graph) {\n+        DebugContext debug = graph.getDebug();\n+        try (DebugContext.Scope s = debug.scope(\"ReassociationPhase\")) {\n+            reassociateInvariant(graph, debug);\n+            reassociateConstant(graph, debug);\n+        } catch (Throwable e) {\n+            throw debug.handle(e);\n+        }\n+        graph.setAfterReassociation();\n+    }\n+\n+    /**\n+     * Re-associate loop invariant so that invariant parts of the expression can move outside of the\n+     * loop.\n+     */\n+    @SuppressWarnings(\"try\")\n+    private static void reassociateInvariant(StructuredGraph graph, DebugContext debug) {\n+        LoopsData loopsData = new LoopsData(graph);\n+        int iterations = 0;\n+        try (DebugContext.Scope s = debug.scope(\"ReassociateInvariants\")) {", "originalCommit": "2c32b5b3b31f58a241b934c468f1dce00a29d248", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzMTc2Ng==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482031766", "bodyText": "pls make that a VERY_DETAILED level and add the string \"reassociation:\" to the message", "author": "davleopo", "createdAt": "2020-09-02T12:33:26Z", "path": "compiler/src/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/ReassociationPhase.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.phases.common;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.graph.NodeBitMap;\n+import org.graalvm.compiler.loop.LoopEx;\n+import org.graalvm.compiler.loop.LoopsData;\n+import org.graalvm.compiler.nodes.NodeView;\n+import org.graalvm.compiler.nodes.StructuredGraph;\n+import org.graalvm.compiler.nodes.ValueNode;\n+import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;\n+import org.graalvm.compiler.nodes.util.GraphUtil;\n+import org.graalvm.compiler.phases.Phase;\n+\n+/**\n+ * Rearrange {@link BinaryArithmeticNode#isAssociative() associative binary operations} for loop\n+ * invariants and constants.\n+ */\n+public class ReassociationPhase extends Phase {\n+\n+    @SuppressWarnings(\"try\")\n+    @Override\n+    protected void run(StructuredGraph graph) {\n+        DebugContext debug = graph.getDebug();\n+        try (DebugContext.Scope s = debug.scope(\"ReassociationPhase\")) {\n+            reassociateInvariant(graph, debug);\n+            reassociateConstant(graph, debug);\n+        } catch (Throwable e) {\n+            throw debug.handle(e);\n+        }\n+        graph.setAfterReassociation();\n+    }\n+\n+    /**\n+     * Re-associate loop invariant so that invariant parts of the expression can move outside of the\n+     * loop.\n+     */\n+    @SuppressWarnings(\"try\")\n+    private static void reassociateInvariant(StructuredGraph graph, DebugContext debug) {\n+        LoopsData loopsData = new LoopsData(graph);\n+        int iterations = 0;\n+        try (DebugContext.Scope s = debug.scope(\"ReassociateInvariants\")) {\n+            boolean changed = true;\n+            while (changed) {\n+                changed = false;\n+                for (LoopEx loop : loopsData.loops()) {\n+                    changed |= loop.reassociateInvariants();\n+                }\n+                loopsData.deleteUnusedNodes();\n+                iterations++;\n+                debug.dump(DebugContext.VERBOSE_LEVEL, graph, \"after iteration %d\", iterations);", "originalCommit": "2c32b5b3b31f58a241b934c468f1dce00a29d248", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzMjMxOA==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482032318", "bodyText": "maybe you could also add a simple java doc example here pls?", "author": "davleopo", "createdAt": "2020-09-02T12:34:22Z", "path": "compiler/src/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/ReassociationPhase.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.phases.common;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.graph.NodeBitMap;\n+import org.graalvm.compiler.loop.LoopEx;\n+import org.graalvm.compiler.loop.LoopsData;\n+import org.graalvm.compiler.nodes.NodeView;\n+import org.graalvm.compiler.nodes.StructuredGraph;\n+import org.graalvm.compiler.nodes.ValueNode;\n+import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;\n+import org.graalvm.compiler.nodes.util.GraphUtil;\n+import org.graalvm.compiler.phases.Phase;\n+\n+/**\n+ * Rearrange {@link BinaryArithmeticNode#isAssociative() associative binary operations} for loop\n+ * invariants and constants.\n+ */\n+public class ReassociationPhase extends Phase {\n+\n+    @SuppressWarnings(\"try\")\n+    @Override\n+    protected void run(StructuredGraph graph) {\n+        DebugContext debug = graph.getDebug();\n+        try (DebugContext.Scope s = debug.scope(\"ReassociationPhase\")) {\n+            reassociateInvariant(graph, debug);\n+            reassociateConstant(graph, debug);\n+        } catch (Throwable e) {\n+            throw debug.handle(e);\n+        }\n+        graph.setAfterReassociation();\n+    }\n+\n+    /**\n+     * Re-associate loop invariant so that invariant parts of the expression can move outside of the\n+     * loop.", "originalCommit": "2c32b5b3b31f58a241b934c468f1dce00a29d248", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzMjc0OA==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482032748", "bodyText": "every phase has its own scope why is this one necessary?", "author": "davleopo", "createdAt": "2020-09-02T12:35:08Z", "path": "compiler/src/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/ReassociationPhase.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.phases.common;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.graph.NodeBitMap;\n+import org.graalvm.compiler.loop.LoopEx;\n+import org.graalvm.compiler.loop.LoopsData;\n+import org.graalvm.compiler.nodes.NodeView;\n+import org.graalvm.compiler.nodes.StructuredGraph;\n+import org.graalvm.compiler.nodes.ValueNode;\n+import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;\n+import org.graalvm.compiler.nodes.util.GraphUtil;\n+import org.graalvm.compiler.phases.Phase;\n+\n+/**\n+ * Rearrange {@link BinaryArithmeticNode#isAssociative() associative binary operations} for loop\n+ * invariants and constants.\n+ */\n+public class ReassociationPhase extends Phase {\n+\n+    @SuppressWarnings(\"try\")\n+    @Override\n+    protected void run(StructuredGraph graph) {\n+        DebugContext debug = graph.getDebug();\n+        try (DebugContext.Scope s = debug.scope(\"ReassociationPhase\")) {", "originalCommit": "2c32b5b3b31f58a241b934c468f1dce00a29d248", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0NzMxOQ==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482747319", "bodyText": "Yes, it can be removed. Thanks for reminding! I will remove it in the new patch.", "author": "XiaohongGong", "createdAt": "2020-09-03T06:59:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzMjc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzMjg5OA==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482032898", "bodyText": "please add a simple code sample here that shows such an operation", "author": "davleopo", "createdAt": "2020-09-02T12:35:25Z", "path": "compiler/src/org.graalvm.compiler.phases.common/src/org/graalvm/compiler/phases/common/ReassociationPhase.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright (c) 2015, 2020, Oracle and/or its affiliates. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.phases.common;\n+\n+import org.graalvm.compiler.debug.DebugContext;\n+import org.graalvm.compiler.graph.NodeBitMap;\n+import org.graalvm.compiler.loop.LoopEx;\n+import org.graalvm.compiler.loop.LoopsData;\n+import org.graalvm.compiler.nodes.NodeView;\n+import org.graalvm.compiler.nodes.StructuredGraph;\n+import org.graalvm.compiler.nodes.ValueNode;\n+import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;\n+import org.graalvm.compiler.nodes.util.GraphUtil;\n+import org.graalvm.compiler.phases.Phase;\n+\n+/**\n+ * Rearrange {@link BinaryArithmeticNode#isAssociative() associative binary operations} for loop\n+ * invariants and constants.", "originalCommit": "2c32b5b3b31f58a241b934c468f1dce00a29d248", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4Mjk4NA==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482682984", "bodyText": "Since the code sample will be added for \"ReassociateInvatiant\" and \"reassociateConstant\" respectively, does it still need to add the code sample here? Thanks!", "author": "XiaohongGong", "createdAt": "2020-09-03T03:35:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzMjg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc4MjU1Mw==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482782553", "bodyText": "No, right, adding it in the other places should be sufficient.", "author": "davleopo", "createdAt": "2020-09-03T07:57:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzMjg5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc4MzcwNA==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482783704", "bodyText": "Got it! Thanks again!", "author": "XiaohongGong", "createdAt": "2020-09-03T07:59:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzMjg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzMzU0OQ==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482033549", "bodyText": "We try to always use factory methods of nodes so any immediate folding can occur during construction already", "author": "davleopo", "createdAt": "2020-09-02T12:36:34Z", "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/MulNode.java", "diffHunk": "@@ -92,27 +93,37 @@ public ValueNode canonical(CanonicalizerTool tool, ValueNode forX, ValueNode for\n         }\n         BinaryOp<Mul> op = getOp(forX, forY);\n         NodeView view = NodeView.from(tool);\n-        return canonical(this, op, stamp(view), forX, forY, view);\n+        return canonical(tool, this, op, stamp(view), forX, forY, view);\n     }\n \n-    private static ValueNode canonical(MulNode self, BinaryOp<Mul> op, Stamp stamp, ValueNode forX, ValueNode forY, NodeView view) {\n+    private static ValueNode canonical(CanonicalizerTool tool, MulNode self, BinaryOp<Mul> op, Stamp stamp, ValueNode forX, ValueNode forY, NodeView view) {\n         if (forY.isConstant()) {\n             Constant c = forY.asConstant();\n             if (op.isNeutral(c)) {\n                 return forX;\n             }\n \n-            if (c instanceof PrimitiveConstant && ((PrimitiveConstant) c).getJavaKind().isNumericInteger()) {\n-                long i = ((PrimitiveConstant) c).asLong();\n-                ValueNode result = canonical(stamp, forX, i, view);\n-                if (result != null) {\n-                    return result;\n+            if (op.isAssociative()) {\n+                // Canonicalize expressions like \"(a * 2) * 4\" => \"(a * 8)\"\n+                ValueNode reassociated = reassociate1(self != null ? self : (MulNode) new MulNode(forX, forY).maybeCommuteInputs(), ValueNode.isConstantPredicate(), forX, forY, view);", "originalCommit": "2c32b5b3b31f58a241b934c468f1dce00a29d248", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4NzM2NQ==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482687365", "bodyText": "Yes, it's better to use the create normally. However, it cannot be used here, since this is inside of the canonical which is called by create. Using create here will make it a dead loop which looks like create -> canonical -> create -> canonical -> ...\nAnd this is the log detail:\n        at jdk.internal.vm.compiler/org.graalvm.compiler.nodes.calc.MulNode.create(MulNode.java:70)\n        at jdk.internal.vm.compiler/org.graalvm.compiler.nodes.calc.MulNode.canonical(MulNode.java:108)\n        at jdk.internal.vm.compiler/org.graalvm.compiler.nodes.calc.MulNode.create(MulNode.java:70)\n        at jdk.internal.vm.compiler/org.graalvm.compiler.nodes.calc.MulNode.canonical(MulNode.java:108)\n        at jdk.internal.vm.compiler/org.graalvm.compiler.nodes.calc.MulNode.create(MulNode.java:70)\n        at jdk.internal.vm.compiler/org.graalvm.compiler.nodes.calc.MulNode.canonical(MulNode.java:108)\n        at jdk.internal.vm.compiler/org.graalvm.compiler.nodes.calc.MulNode.create(MulNode.java:70)", "author": "XiaohongGong", "createdAt": "2020-09-03T03:52:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzMzU0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc4MzA1Ng==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482783056", "bodyText": "ah, yes overlooked that ;-) never mind", "author": "davleopo", "createdAt": "2020-09-03T07:58:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzMzU0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzNDM5OA==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482034398", "bodyText": "please give this method and the reassociate2 a better descriptive name that makes clear what is done in each method", "author": "davleopo", "createdAt": "2020-09-02T12:38:05Z", "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/BinaryArithmeticNode.java", "diffHunk": "@@ -261,7 +393,7 @@ private static ReassociateMatch findReassociate(BinaryNode binary, NodePredicate\n      * @param forY\n      * @param forX\n      */\n-    public static ValueNode reassociate(BinaryArithmeticNode<?> node, NodePredicate criterion, ValueNode forX, ValueNode forY, NodeView view) {\n+    public static ValueNode reassociate1(BinaryArithmeticNode<?> node, NodePredicate criterion, ValueNode forX, ValueNode forY, NodeView view) {", "originalCommit": "2c32b5b3b31f58a241b934c468f1dce00a29d248", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzNTcyNQ==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482035725", "bodyText": "I think this name alone is not descriptive enough, maybe ReassociateLoopInvariants? Also, please add a small sentence in the help text above in the annotation", "author": "davleopo", "createdAt": "2020-09-02T12:40:21Z", "path": "compiler/src/org.graalvm.compiler.core.common/src/org/graalvm/compiler/core/common/GraalOptions.java", "diffHunk": "@@ -94,7 +94,7 @@\n     public static final OptionKey<Boolean> LoopPeeling = new OptionKey<>(true);\n \n     @Option(help = \"\", type = OptionType.Debug)\n-    public static final OptionKey<Boolean> ReassociateInvariants = new OptionKey<>(true);\n+    public static final OptionKey<Boolean> Reassociation = new OptionKey<>(true);", "originalCommit": "2c32b5b3b31f58a241b934c468f1dce00a29d248", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjY4ODA2Nw==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482688067", "bodyText": "Reassociation is not only used for loop invariants, but also the constant reassociation. So do you have any better idea for it? Thanks!", "author": "XiaohongGong", "createdAt": "2020-09-03T03:55:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzNTcyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc4NDIxOQ==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482784219", "bodyText": "not only used for loop invariants, but also the constant reassociation\n\nI know, but the important use case is loops, thus the suggestion. But you are right. I think the name of the phase is fine, though. Maybe sth like ReassociateExpressions?", "author": "davleopo", "createdAt": "2020-09-03T08:00:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzNTcyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc4NTk1MQ==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482785951", "bodyText": "Yeah, make sense! I will change the name in the new patch. Thanks!", "author": "XiaohongGong", "createdAt": "2020-09-03T08:03:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzNTcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzNjQ5MA==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482036490", "bodyText": "In the course of my suggestion for the mul node this can be removed in favor of the shift to mul transformation", "author": "davleopo", "createdAt": "2020-09-02T12:41:30Z", "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/StructuredGraph.java", "diffHunk": "@@ -978,6 +980,14 @@ public void setAfterExpandLogic() {\n         isAfterExpandLogic = true;\n     }\n \n+    public boolean isAfterReassociation() {\n+        return isAfterReassociation;\n+    }\n+\n+    public void setAfterReassociation() {", "originalCommit": "2c32b5b3b31f58a241b934c468f1dce00a29d248", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjAzNjkxMw==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482036913", "bodyText": "See my general review comments about the shift to mul rewrite.", "author": "davleopo", "createdAt": "2020-09-02T12:42:02Z", "path": "compiler/src/org.graalvm.compiler.nodes/src/org/graalvm/compiler/nodes/calc/MulNode.java", "diffHunk": "@@ -92,27 +93,37 @@ public ValueNode canonical(CanonicalizerTool tool, ValueNode forX, ValueNode for\n         }\n         BinaryOp<Mul> op = getOp(forX, forY);\n         NodeView view = NodeView.from(tool);\n-        return canonical(this, op, stamp(view), forX, forY, view);\n+        return canonical(tool, this, op, stamp(view), forX, forY, view);\n     }\n \n-    private static ValueNode canonical(MulNode self, BinaryOp<Mul> op, Stamp stamp, ValueNode forX, ValueNode forY, NodeView view) {\n+    private static ValueNode canonical(CanonicalizerTool tool, MulNode self, BinaryOp<Mul> op, Stamp stamp, ValueNode forX, ValueNode forY, NodeView view) {\n         if (forY.isConstant()) {\n             Constant c = forY.asConstant();\n             if (op.isNeutral(c)) {\n                 return forX;\n             }\n \n-            if (c instanceof PrimitiveConstant && ((PrimitiveConstant) c).getJavaKind().isNumericInteger()) {\n-                long i = ((PrimitiveConstant) c).asLong();\n-                ValueNode result = canonical(stamp, forX, i, view);\n-                if (result != null) {\n-                    return result;\n+            if (op.isAssociative()) {\n+                // Canonicalize expressions like \"(a * 2) * 4\" => \"(a * 8)\"\n+                ValueNode reassociated = reassociate1(self != null ? self : (MulNode) new MulNode(forX, forY).maybeCommuteInputs(), ValueNode.isConstantPredicate(), forX, forY, view);\n+                if (reassociated != self) {\n+                    return reassociated;\n                 }\n             }\n \n-            if (op.isAssociative()) {\n-                // canonicalize expressions like \"(a * 1) * 2\"\n-                return reassociate(self != null ? self : (MulNode) new MulNode(forX, forY).maybeCommuteInputs(), ValueNode.isConstantPredicate(), forX, forY, view);\n+            // Defer the lowering to make sure the constant values have been re-associated", "originalCommit": "2c32b5b3b31f58a241b934c468f1dce00a29d248", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgyNTc2Ng==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482825766", "bodyText": "that's something I overlooked. While this is a nice way of testing the pure functionality of the phase I think we also want to test the application of the phase embedded in the regular compilation pipeline.\nFor the test cases above can you please add assertions for the most important node counts, e.g. for the mul test ensure after a regular compilation the final low tier graph before backend contains one mul node with constant 15 and so on.\nWe want to especially test the mul stuff we are discussing about and for that we need to test the final graph result after all phases.", "author": "davleopo", "createdAt": "2020-09-03T09:08:00Z", "path": "compiler/src/org.graalvm.compiler.core.test/src/org/graalvm/compiler/core/test/ReassociationTest.java", "diffHunk": "@@ -0,0 +1,474 @@\n+/*\n+ * Copyright (c) 2020, Oracle and/or its affiliates. All rights reserved.\n+ * Copyright (c) 2020, Arm Limited. All rights reserved.\n+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.\n+ *\n+ * This code is free software; you can redistribute it and/or modify it\n+ * under the terms of the GNU General Public License version 2 only, as\n+ * published by the Free Software Foundation.  Oracle designates this\n+ * particular file as subject to the \"Classpath\" exception as provided\n+ * by Oracle in the LICENSE file that accompanied this code.\n+ *\n+ * This code is distributed in the hope that it will be useful, but WITHOUT\n+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+ * version 2 for more details (a copy is included in the LICENSE file that\n+ * accompanied this code).\n+ *\n+ * You should have received a copy of the GNU General Public License version\n+ * 2 along with this work; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.\n+ *\n+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA\n+ * or visit www.oracle.com if you need additional information or have any\n+ * questions.\n+ */\n+package org.graalvm.compiler.core.test;\n+\n+import org.graalvm.compiler.graph.Node;\n+import org.graalvm.compiler.graph.iterators.FilteredNodeIterable;\n+import org.graalvm.compiler.nodes.StructuredGraph;\n+import org.graalvm.compiler.nodes.StructuredGraph.AllowAssumptions;\n+import org.graalvm.compiler.nodes.calc.BinaryArithmeticNode;\n+import org.graalvm.compiler.phases.common.ReassociationPhase;\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.Random;\n+\n+public class ReassociationTest extends GraalCompilerTest {\n+\n+    private static final Random random = new Random(11);\n+    private static int rnd1 = random.nextInt();\n+    private static int rnd2 = random.nextInt();\n+    private static long rndL1 = random.nextLong();\n+    private static long rndL2 = random.nextLong();\n+\n+    // Re-association tests with int type.\n+    @Test\n+    public void testAddAdd() {\n+        testReassociateConstant(\"testAddAddSnippet\", \"refAddAddSnippet\");\n+    }\n+\n+    public static int testAddAddSnippet() {\n+        return rnd1 + (rnd2 + 2) + 3;\n+    }\n+\n+    public static int refAddAddSnippet() {\n+        return rnd1 + rnd2 + 5;\n+    }\n+\n+    @Test\n+    public void testAddSubX() {\n+        testReassociateConstant(\"testAddSubXSnippet\", \"refAddSubXSnippet\");\n+    }\n+\n+    public static int testAddSubXSnippet() {\n+        return rnd1 + (3 - rnd2) + 2;\n+    }\n+\n+    public static int refAddSubXSnippet() {\n+        return (rnd1 - rnd2) + 5;\n+    }\n+\n+    @Test\n+    public void testAddSubY() {\n+        testReassociateConstant(\"testAddSubYSnippet\", \"refAddSubYSnippet\");\n+    }\n+\n+    public static int testAddSubYSnippet() {\n+        return rnd1 + (rnd2 - 3) + 2;\n+    }\n+\n+    public static int refAddSubYSnippet() {\n+        return (rnd1 + rnd2) - 1;\n+    }\n+\n+    @Test\n+    public void testSubAddX() {\n+        testReassociateConstant(\"testSubAddXSnippet\", \"refSubAddXSnippet\");\n+    }\n+\n+    public static int testSubAddXSnippet() {\n+        return (3 + rnd1) - rnd2 + 1;\n+    }\n+\n+    public static int refSubAddXSnippet() {\n+        return 4 + (rnd1 - rnd2);\n+    }\n+\n+    @Test\n+    public void testSubAddY() {\n+        testReassociateConstant(\"testSubAddYSnippet\", \"refSubAddYSnippet\");\n+    }\n+\n+    public static int testSubAddYSnippet() {\n+        return rnd1 - (3 + rnd2) + 1;\n+    }\n+\n+    public static int refSubAddYSnippet() {\n+        return (rnd1 - rnd2) - 2;\n+    }\n+\n+    @Test\n+    public void testSubSubYX() {\n+        testReassociateConstant(\"testSubSubYXSnippet\", \"refSubSubYXSnippet\");\n+    }\n+\n+    public static int testSubSubYXSnippet() {\n+        return rnd1 - (3 - rnd2) + 1;\n+    }\n+\n+    public static int refSubSubYXSnippet() {\n+        return (rnd1 + rnd2) - 2;\n+    }\n+\n+    @Test\n+    public void testSubSubYY() {\n+        testReassociateConstant(\"testSubSubYYSnippet\", \"refSubSubYYSnippet\");\n+    }\n+\n+    public static int testSubSubYYSnippet() {\n+        return rnd1 - (rnd2 - 3) + 1;\n+    }\n+\n+    public static int refSubSubYYSnippet() {\n+        return (rnd1 - rnd2) + 4;\n+    }\n+\n+    @Test\n+    public void testSubSubXX() {\n+        testReassociateConstant(\"testSubSubXXSnippet\", \"refSubSubXXSnippet\");\n+    }\n+\n+    public static int testSubSubXXSnippet() {\n+        return (3 - rnd1) - rnd2 + 1;\n+    }\n+\n+    public static int refSubSubXXSnippet() {\n+        return 4 - (rnd1 + rnd2);\n+    }\n+\n+    @Test\n+    public void testSubSubXY() {\n+        testReassociateConstant(\"testSubSubXYSnippet\", \"refSubSubXYSnippet\");\n+    }\n+\n+    public static int testSubSubXYSnippet() {\n+        return (rnd1 - 3) - rnd2 + 1;\n+    }\n+\n+    public static int refSubSubXYSnippet() {\n+        return (rnd1 - rnd2) - 2;\n+    }\n+\n+    @Test\n+    public void testMul() {\n+        testReassociateConstant(\"testMulSnippet\", \"refMulSnippet\");\n+    }\n+\n+    public static int testMulSnippet() {\n+        return rnd1 * (-3 * rnd2) * -5;\n+    }\n+\n+    public static int refMulSnippet() {\n+        return (rnd1 * rnd2) * 15;\n+    }\n+\n+    @Test\n+    public void testAnd() {\n+        testReassociateConstant(\"testAndSnippet\", \"refAndSnippet\");\n+    }\n+\n+    public static int testAndSnippet() {\n+        return rnd1 & (3 & rnd2) & 2;\n+    }\n+\n+    public static int refAndSnippet() {\n+        return (rnd1 & rnd2) & 2;\n+    }\n+\n+    @Test\n+    public void testOr() {\n+        testReassociateConstant(\"testOrSnippet\", \"refOrSnippet\");\n+    }\n+\n+    public static int testOrSnippet() {\n+        return rnd1 | (3 | rnd2) | 4;\n+    }\n+\n+    public static int refOrSnippet() {\n+        return (rnd1 | rnd2) | 7;\n+    }\n+\n+    @Test\n+    public void testXor() {\n+        testReassociateConstant(\"testXorSnippet\", \"refXorSnippet\");\n+    }\n+\n+    public static int testXorSnippet() {\n+        return rnd1 ^ (3 ^ rnd2) ^ 1;\n+    }\n+\n+    public static int refXorSnippet() {\n+        return (rnd1 ^ rnd2) ^ 2;\n+    }\n+\n+    // Re-association tests with long type.\n+    @Test\n+    public void testAddAddLong() {\n+        testReassociateConstant(\"testAddAddLongSnippet\", \"refAddAddLongSnippet\");\n+    }\n+\n+    public static long testAddAddLongSnippet() {\n+        return rndL1 + (rndL2 + 2L) + 3L;\n+    }\n+\n+    public static long refAddAddLongSnippet() {\n+        return rndL1 + rndL2 + 5L;\n+    }\n+\n+    @Test\n+    public void testSubAddLong() {\n+        testReassociateConstant(\"testSubAddLongSnippet\", \"refSubAddLongSnippet\");\n+    }\n+\n+    public static long testSubAddLongSnippet() {\n+        return (3L + rndL1) - rndL2 + 1L;\n+    }\n+\n+    public static long refSubAddLongSnippet() {\n+        return 4L + (rndL1 - rndL2);\n+    }\n+\n+    @Test\n+    public void testMulLong() {\n+        testReassociateConstant(\"testMulLongSnippet\", \"refMulLongSnippet\");\n+    }\n+\n+    public static long testMulLongSnippet() {\n+        return rndL1 * (-3L * rndL2) * -5L;\n+    }\n+\n+    public static long refMulLongSnippet() {\n+        return (rndL1 * rndL2) * 15L;\n+    }\n+\n+    @Test\n+    public void testAndLong() {\n+        testReassociateConstant(\"testAndLongSnippet\", \"refAndLongSnippet\");\n+    }\n+\n+    public static long testAndLongSnippet() {\n+        return rndL1 & (3L & rndL2) & 2L;\n+    }\n+\n+    public static long refAndLongSnippet() {\n+        return (rndL1 & rndL2) & 2L;\n+    }\n+\n+    @Test\n+    public void testOrLong() {\n+        testReassociateConstant(\"testOrLongSnippet\", \"refOrLongSnippet\");\n+    }\n+\n+    public static long testOrLongSnippet() {\n+        return rndL1 | (3L | rndL2) | 4L;\n+    }\n+\n+    public static long refOrLongSnippet() {\n+        return (rndL1 | rndL2) | 7L;\n+    }\n+\n+    @Test\n+    public void testXorLong() {\n+        testReassociateConstant(\"testXorLongSnippet\", \"refXorLongSnippet\");\n+    }\n+\n+    public static long testXorLongSnippet() {\n+        return rndL1 ^ (3L ^ rndL2) ^ 1L;\n+    }\n+\n+    public static long refXorLongSnippet() {\n+        return (rndL1 ^ rndL2) ^ 2L;\n+    }\n+\n+    // Re-association overflow tests.\n+    @Test\n+    public void testOverflow1() {\n+        testReassociateConstant(\"testOverflow1Snippet\", \"refOverflow1Snippet\");\n+    }\n+\n+    public static int testOverflow1Snippet() {\n+        return rnd1 + (rnd2 + Integer.MAX_VALUE) + Integer.MIN_VALUE;\n+    }\n+\n+    public static int refOverflow1Snippet() {\n+        return (rnd1 + rnd2) - 1;\n+    }\n+\n+    @Test\n+    public void testOverflow2() {\n+        testReassociateConstant(\"testOverflow2Snippet\", \"refOverflow2Snippet\");\n+    }\n+\n+    public static long testOverflow2Snippet() {\n+        return rndL1 + (rndL2 + Long.MAX_VALUE) - Long.MIN_VALUE;\n+    }\n+\n+    public static long refOverflow2Snippet() {\n+        return (rndL1 + rndL2) + (-1L);\n+    }\n+\n+    @Test\n+    public void testOverflow3() {\n+        testReassociateConstant(\"testOverflow3Snippet\", \"refOverflow3Snippet\");\n+    }\n+\n+    public static int testOverflow3Snippet() {\n+        return rnd1 + (rnd2 - Integer.MIN_VALUE) - 5;\n+    }\n+\n+    public static int refOverflow3Snippet() {\n+        return (rnd1 + rnd2) - 0x80000005;\n+    }\n+\n+    @Test\n+    public void testOverflow4() {\n+        testReassociateConstant(\"testOverflow4Snippet\", \"refOverflow4Snippet\");\n+    }\n+\n+    public static long testOverflow4Snippet() {\n+        return rndL1 * (Long.MIN_VALUE * rndL2) * (-3L);\n+    }\n+\n+    public static long refOverflow4Snippet() {\n+        return (rndL1 * rndL2) * (Long.MIN_VALUE * (-3L));\n+    }\n+\n+    private void testReassociateConstant(String testMethod, String refMethod) {\n+        test(testMethod);", "originalCommit": "2c32b5b3b31f58a241b934c468f1dce00a29d248", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgzNDg0Mg==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r482834842", "bodyText": "Sure, I can add the assertion to the final graph. However, regarding to the node counts, do you think the assertion of the graph equaling between \"testMethod\" and \"refMethod\" is enough?  I think it can guarantee the equaling of the final node counts.", "author": "XiaohongGong", "createdAt": "2020-09-03T09:21:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgyNTc2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQ2NTk1Mg==", "url": "https://github.com/oracle/graal/pull/2664#discussion_r483465952", "bodyText": "I think the final graph y added should be sufficient, thx. Verifying the node counts by hand would just guarantee that if we start doing something categorically wrong both inside the test and the ref snippet we would still catch it but thats not necessary for now.", "author": "davleopo", "createdAt": "2020-09-04T08:22:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgyNTc2Ng=="}], "type": "inlineReview"}, {"oid": "0b0ecdddfd802e24b250653e1572c9ab93c1eb17", "url": "https://github.com/oracle/graal/commit/0b0ecdddfd802e24b250653e1572c9ab93c1eb17", "message": "Add more re-associations for associative binary operations\n\nChange-Id: If32b49a14dd08ac1ab903878da0f459f452da221", "committedDate": "2020-09-04T03:52:52Z", "type": "commit"}, {"oid": "0b0ecdddfd802e24b250653e1572c9ab93c1eb17", "url": "https://github.com/oracle/graal/commit/0b0ecdddfd802e24b250653e1572c9ab93c1eb17", "message": "Add more re-associations for associative binary operations\n\nChange-Id: If32b49a14dd08ac1ab903878da0f459f452da221", "committedDate": "2020-09-04T03:52:52Z", "type": "forcePushed"}]}