{"pr_number": 673, "pr_title": "JENA-1812: Switch to Murmur3 for blank node allocation", "pr_createdAt": "2020-01-17T19:50:35Z", "pr_url": "https://github.com/apache/jena/pull/673", "timeline": [{"oid": "2eea5f574fa7ff16451790d962bfefc08cf31347", "url": "https://github.com/apache/jena/commit/2eea5f574fa7ff16451790d962bfefc08cf31347", "message": "JENA-1812: Switch to Murmur3 for blank node allocation", "committedDate": "2020-01-17T19:34:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEyMzgyMw==", "url": "https://github.com/apache/jena/pull/673#discussion_r368123823", "bodyText": "The original commons-codec MurmurHash3.hash128 (like the Guava code) has a sign extension issue with the seed value.  Since the seed is 104729 (for some reason) the hashes will work correctly.  However a fair amount of work has gone into commons-codec recently and v 1.14 fixes the issue.  Because of the change several of the MurmurHash3.hash128(x) methods have been deprecated.  It is probably cleaner to call MurmurHash3.hash128x86( input, 0, input.length, MurmurHash3.DEFAULT_SEED) or  MurmurHash3.hash128x86( input, 0, input.length, 104729L)", "author": "Claudenw", "createdAt": "2020-01-17T20:31:07Z", "path": "jena-arq/src/main/java/org/apache/jena/riot/lang/BlankNodeAllocatorHash.java", "diffHunk": "@@ -113,20 +104,67 @@ public Node call() {\n     public Node create() {\n         counter++;\n         // Make illegal string bytes so can't clash with alloc(String).\n-        // It is different because it has zeros in it.\n+        // It is different because it has a zero (illegal in a Java string) in it.\n         counterBytes[0] = 0;\n         counterBytes[1] = 0;\n         Bytes.setLong(counter, counterBytes, 2);\n         return alloc(counterBytes);\n     }\n \n+    /** Given the per-run seed and label bytes, make a blank node. */\n     private Node alloc(byte[] labelBytes) {\n-        // UUID.nameUUIDFromBytes(seedBytes+labelBytes) uses MD5 but creates the digester\n-        // each time. It also stamps in the UUID version/variant bits.\n-        mDigest.update(seedBytes);\n-        mDigest.update(labelBytes);\n-        byte[] bytes = mDigest.digest(); // resets\n-        String hexString = Bytes.asHexLC(bytes);\n+        byte[] input = new byte[seedBytes.length+labelBytes.length];\n+        System.arraycopy(seedBytes, 0, input, 0, seedBytes.length);\n+        System.arraycopy(labelBytes, 0, input, seedBytes.length, labelBytes.length);\n+        \n+        // Apache Common Codec or Guava. \n+        // The 2 versions of the code below should produce the same hex strings.\n+        //\n+        // The main difference from our perspective is that the Guava version\n+        // returns a byte[]. Hashes are not \"large numbers\" - they are bit patterns --\n+        // but it does create and use internal Java objects.\n+        //\n+        // We need to be careful about byte order. The long[] returned by\n+        // MurmurHash3 (Apache Commons) needs to be stringified as \"low bytes first\"\n+        // which is the reverse of %d-formatting for a long which is \n+        // \"high byte first\" (in a left-to-right writing system).\n+        //\n+        // For byte output compatibility with byte[] from Guava,\n+        // need to reverse the bytes of the longs so that it prints \"low to high\"\n+        // Java works in big-endian -- high bytes first.\n+\n+        String hexString;\n+        if ( true ) {\n+            long[] x = MurmurHash3.hash128(input);", "originalCommit": "2eea5f574fa7ff16451790d962bfefc08cf31347", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODE2Mzg0MQ==", "url": "https://github.com/apache/jena/pull/673#discussion_r368163841", "bodyText": "Thanks for the heads-up. It is also good to see the Murmur3 no longer uses String.getBytes().\nChanged to jena dependency to codec 1.14 and now calling MurmurHash3.hash128x86(x)\nIn fact, v1.14 has made a change unintentionally: it does apply the mask. I'll take this to the CODEC ticket.", "author": "afs", "createdAt": "2020-01-17T22:33:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODEyMzgyMw=="}], "type": "inlineReview"}, {"oid": "ad49bf4e9a9688f3952c47698cfb19dd6bd16fb5", "url": "https://github.com/apache/jena/commit/ad49bf4e9a9688f3952c47698cfb19dd6bd16fb5", "message": "JENA-1812: Commons Codec 1.14", "committedDate": "2020-01-17T21:59:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQyOTk5NA==", "url": "https://github.com/apache/jena/pull/673#discussion_r368429994", "bodyText": "I assume this is needed because otherwise the version and variant segments of the UUID would always be the same leading to some predictability in the hashing?", "author": "rvesse", "createdAt": "2020-01-20T09:00:16Z", "path": "jena-arq/src/main/java/org/apache/jena/riot/lang/BlankNodeAllocatorHash.java", "diffHunk": "@@ -90,6 +80,12 @@ protected UUID freshSeed() {\n     @Override\n     public void reset() {\n         UUID seed = this.freshSeed();\n+        long mostSigBits = seed.getMostSignificantBits();\n+        long leastSigBits = seed.getLeastSignificantBits();\n+        // Stamp on version and variant. Makes it an illegal UUID (unless all the bits are zero!)", "originalCommit": "ad49bf4e9a9688f3952c47698cfb19dd6bd16fb5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODcyNjY2OA==", "url": "https://github.com/apache/jena/pull/673#discussion_r368726668", "bodyText": "TBH it is not needed, it's being a little tidy saying \"this is not being used as a UUID\". We are using a UUID but only as convenient way to get a quality random number so large it is unique for practical purposes. Version and variant are together 6 bits (fixed), leaving 122 bits of input. 122 bits is a very large number. IIRC (e.g. 3Store paper) a few bits more that 64 is enough. 58 bits more is a lot more.\n\nThe \u201cBirthday Paradox\u201d1 gives the probability of an accidental hash collision\noccurring anywhere in a knowledge base of 10^9 distinct nodes to be around\n1 : 10^\u221210 when using an effective 63 bit hash.\n\n(more details in the paper)\nThe requirements are uniqueness for any bnodes that are ever going to meet (assumed \"global\"), speed and not requiring keeping the seen labels over the life of a parser run. Prior to using the hash allocator, Jena kept labels it had seen and very occasionally a user would run out of heap due to the footprint.", "author": "afs", "createdAt": "2020-01-20T21:10:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQyOTk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODg4ODUzNQ==", "url": "https://github.com/apache/jena/pull/673#discussion_r368888535", "bodyText": "Sure I'm well aware of the birthday paradox and the parsing concerns and overheads involved, just wanted to clarify the intent of the code", "author": "rvesse", "createdAt": "2020-01-21T09:24:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODQyOTk5NA=="}], "type": "inlineReview"}]}