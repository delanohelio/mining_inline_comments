{"pr_number": 804, "pr_title": "JENA-1974: G, a library of functions for working with Graph.", "pr_createdAt": "2020-10-01T13:20:10Z", "pr_url": "https://github.com/apache/jena/pull/804", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3MzAxOA==", "url": "https://github.com/apache/jena/pull/804#discussion_r498273018", "bodyText": "Could be more efficient without counting all triples, e.g.\ntry (ExtendedIterator<Triple> it = g.find(s, p, null) {\n  if (!it.hasNext()) {\n     return false;\n  }\n  it.next();\n  return !it.hasNext();\n}", "author": "strangepleasures", "createdAt": "2020-10-01T14:08:30Z", "path": "jena-arq/src/main/java/org/apache/jena/riot/other/G.java", "diffHunk": "@@ -0,0 +1,593 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.jena.riot.other;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+import org.apache.jena.atlas.iterator.Iter;\n+import org.apache.jena.graph.Graph;\n+import org.apache.jena.graph.GraphUtil;\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.riot.out.NodeFmtLib;\n+//import org.apache.jena.shacl.lib.GN;\n+//import org.apache.jena.shacl.lib.RDFDataException;\n+//import org.apache.jena.shacl.lib.Transitive;\n+//import org.apache.jena.shacl.sys.C;\n+import org.apache.jena.sparql.core.Quad;\n+import org.apache.jena.sparql.graph.NodeConst;\n+import org.apache.jena.sparql.util.graph.GNode;\n+import org.apache.jena.sparql.util.graph.GraphList;\n+import org.apache.jena.util.iterator.ExtendedIterator;\n+\n+/** A library of functions for working with {@link Graph}. */\n+public class G {\n+    private G() {}\n+    private static Node rdfType = NodeConst.nodeRDFType;\n+\n+    /** Return the subject of a triple, or null if the triple is null. */\n+    public static Node subject(Triple triple) {\n+        return triple == null ? null : triple.getSubject();\n+    }\n+\n+    /** Return the predicate of a triple, or null if the triple is null. */\n+    public static Node predicate(Triple triple) {\n+        return triple == null ? null : triple.getPredicate();\n+    }\n+\n+    /** Return the object of a triple, or null if the triple is null. */\n+    public static Node object(Triple triple) {\n+        return triple == null ? null : triple.getObject();\n+    }\n+\n+    // ---- Node filter tests.\n+    public static boolean isURI(Node n)         { return n != null && n.isURI(); }\n+    public static boolean isBlank(Node n)       { return n != null && n.isBlank(); }\n+    public static boolean isLiteral(Node n)     { return n != null && n.isLiteral(); }\n+    public static boolean isResource(Node n)    { return n != null && (n.isURI()||n.isBlank()); }\n+\n+    /** Convert null to Node.ANY */\n+    public static Node nullAsAny(Node x) { return nullAsDft(x, Node.ANY) ; }\n+\n+    /** Convert null to some default Node */\n+    public static Node nullAsDft(Node x, Node dft) { return x==null ? dft : x ; }\n+\n+    /** Does the graph match the s/p/o pattern? */ \n+    public static boolean contains(Graph g, Node s, Node p, Node o) {\n+        return g.contains(s, p, o);\n+    }\n+    \n+    /** Does the graph use the node anywhere as a subject, predicate or object? */\n+    public static boolean containsNode(Graph graph, Node node) {\n+        return GraphUtil.containsNode(graph, node);\n+//        return\n+//            contains(graph, node, Node.ANY, Node.ANY) ||\n+//            contains(graph, Node.ANY, Node.ANY, node) ||\n+//            contains(graph, Node.ANY, node, Node.ANY) ;\n+    }\n+    \n+    /** Test whether the node has the type or is rdfs:subclassOf. */\n+    public static boolean isOfType(Graph graph, Node x, Node type) {\n+        Objects.requireNonNull(x, \"Subject\");\n+        Objects.requireNonNull(type, \"Type\");\n+        List<Node> allClasses = listSubClasses(graph, type);\n+        for ( Node c : allClasses ) {\n+            if ( hasType(graph, x, c) )\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    /** Does the node x have the given type (non-RDFS - no rdfs:subclassOf considered)? */ \n+    public static boolean hasType(Graph graph, Node x, Node type) {\n+        Objects.requireNonNull(x, \"Subject\");\n+        Objects.requireNonNull(type, \"Type\");\n+        return contains(graph, x, NodeConst.nodeRDFType, type);\n+    }\n+\n+    //---- get/list/iter\n+\n+    /** Does node {@code s} have property {@code p} in graph {@code g}? */\n+    public static boolean hasProperty(Graph g, Node s, Node p) {\n+        return g.contains(s, p, null);\n+    }\n+\n+    /** Contains exactly one. */\n+    public static boolean containsOne(Graph g, Node s, Node p, Node o) {\n+        return g.contains(s, p, o) && Iter.count(g.find(s,p,null)) == 1;", "originalCommit": "2e29a2e34a35bf63f1c574596abfdc658db3f529", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI5ODYzMQ==", "url": "https://github.com/apache/jena/pull/804#discussion_r498298631", "bodyText": "Agreed.", "author": "afs", "createdAt": "2020-10-01T14:41:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3MzAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxMTMwMA==", "url": "https://github.com/apache/jena/pull/804#discussion_r498311300", "bodyText": "Actually, try-with-resources wouldn't work here as ClosableIterator doesn't implement AutoCloseable. It would be quite convenient and shouldn't break anything. public interface ClosableIterator<T> extends Iterator<T>,  AutoCloseable", "author": "strangepleasures", "createdAt": "2020-10-01T14:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3MzAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMyNzE1Nw==", "url": "https://github.com/apache/jena/pull/804#discussion_r498327157", "bodyText": "See https://issues.apache.org/jira/browse/JENA-1601...", "author": "ajs6f", "createdAt": "2020-10-01T15:19:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3MzAxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ1OTIwMg==", "url": "https://github.com/apache/jena/pull/804#discussion_r498459202", "bodyText": "Ah great!", "author": "strangepleasures", "createdAt": "2020-10-01T19:10:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3MzAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3NTU5MA==", "url": "https://github.com/apache/jena/pull/804#discussion_r498275590", "bodyText": "How about isNodeTriple?", "author": "strangepleasures", "createdAt": "2020-10-01T14:11:56Z", "path": "jena-arq/src/main/java/org/apache/jena/riot/other/G.java", "diffHunk": "@@ -0,0 +1,593 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.jena.riot.other;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+import org.apache.jena.atlas.iterator.Iter;\n+import org.apache.jena.graph.Graph;\n+import org.apache.jena.graph.GraphUtil;\n+import org.apache.jena.graph.Node;\n+import org.apache.jena.graph.Triple;\n+import org.apache.jena.riot.out.NodeFmtLib;\n+//import org.apache.jena.shacl.lib.GN;\n+//import org.apache.jena.shacl.lib.RDFDataException;\n+//import org.apache.jena.shacl.lib.Transitive;\n+//import org.apache.jena.shacl.sys.C;\n+import org.apache.jena.sparql.core.Quad;\n+import org.apache.jena.sparql.graph.NodeConst;\n+import org.apache.jena.sparql.util.graph.GNode;\n+import org.apache.jena.sparql.util.graph.GraphList;\n+import org.apache.jena.util.iterator.ExtendedIterator;\n+\n+/** A library of functions for working with {@link Graph}. */\n+public class G {\n+    private G() {}\n+    private static Node rdfType = NodeConst.nodeRDFType;\n+\n+    /** Return the subject of a triple, or null if the triple is null. */\n+    public static Node subject(Triple triple) {\n+        return triple == null ? null : triple.getSubject();\n+    }\n+\n+    /** Return the predicate of a triple, or null if the triple is null. */\n+    public static Node predicate(Triple triple) {\n+        return triple == null ? null : triple.getPredicate();\n+    }\n+\n+    /** Return the object of a triple, or null if the triple is null. */\n+    public static Node object(Triple triple) {\n+        return triple == null ? null : triple.getObject();\n+    }\n+\n+    // ---- Node filter tests.\n+    public static boolean isURI(Node n)         { return n != null && n.isURI(); }\n+    public static boolean isBlank(Node n)       { return n != null && n.isBlank(); }\n+    public static boolean isLiteral(Node n)     { return n != null && n.isLiteral(); }\n+    public static boolean isResource(Node n)    { return n != null && (n.isURI()||n.isBlank()); }\n+", "originalCommit": "2e29a2e34a35bf63f1c574596abfdc658db3f529", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODM0NjIwMQ==", "url": "https://github.com/apache/jena/pull/804#discussion_r498346201", "bodyText": "Good point. You can see that the code is dated!\n(and isNodeGraph even if it isn't current used)", "author": "afs", "createdAt": "2020-10-01T15:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODI3NTU5MA=="}], "type": "inlineReview"}, {"oid": "5b2ee120c0776dac876f0b9cbcb781202c1a0d83", "url": "https://github.com/apache/jena/commit/5b2ee120c0776dac876f0b9cbcb781202c1a0d83", "message": "Function library for working with graphs", "committedDate": "2020-10-01T14:50:06Z", "type": "forcePushed"}, {"oid": "b13c4c797f870cca9005821e0eca4c05e9ec5e1f", "url": "https://github.com/apache/jena/commit/b13c4c797f870cca9005821e0eca4c05e9ec5e1f", "message": "Spelling correction.", "committedDate": "2020-10-04T14:20:52Z", "type": "commit"}, {"oid": "7e02e499317dd05626d2ef15eb9dd7675a59c4a1", "url": "https://github.com/apache/jena/commit/7e02e499317dd05626d2ef15eb9dd7675a59c4a1", "message": "Correct whitespace in compact syntax output of [...]", "committedDate": "2020-10-04T14:20:52Z", "type": "commit"}, {"oid": "b3ab06944c6281f58a8d19eaaa9a9eac2eb0f7fb", "url": "https://github.com/apache/jena/commit/b3ab06944c6281f58a8d19eaaa9a9eac2eb0f7fb", "message": "Mark iterator to stream as immutable", "committedDate": "2020-10-04T19:08:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTMxNzA5NA==", "url": "https://github.com/apache/jena/pull/804#discussion_r499317094", "bodyText": "s/tripel/triple", "author": "kinow", "createdAt": "2020-10-05T02:04:08Z", "path": "jena-shacl/src/main/java/org/apache/jena/shacl/engine/SparqlConstraints.java", "diffHunk": "@@ -91,6 +94,27 @@ public static Constraint parseSparqlConstraint(Graph shapesGraph, Node shape, No\n             throw new ShaclParseException(\"SPARQL parse error: \"+ex.getMessage()+\"\\n\"+qs);\n         }\n     }\n+    \n+    /**\n+     * Test for zero or one occurrences of a tripel pattern that is expected to be   ", "originalCommit": "b3ab06944c6281f58a8d19eaaa9a9eac2eb0f7fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTMxNzEyOA==", "url": "https://github.com/apache/jena/pull/804#discussion_r499317128", "bodyText": "s/then/than", "author": "kinow", "createdAt": "2020-10-05T02:04:22Z", "path": "jena-shacl/src/main/java/org/apache/jena/shacl/engine/SparqlConstraints.java", "diffHunk": "@@ -91,6 +94,27 @@ public static Constraint parseSparqlConstraint(Graph shapesGraph, Node shape, No\n             throw new ShaclParseException(\"SPARQL parse error: \"+ex.getMessage()+\"\\n\"+qs);\n         }\n     }\n+    \n+    /**\n+     * Test for zero or one occurrences of a tripel pattern that is expected to be   \n+     * Returns false for zero, true for one. \n+     * Throws an exception on two or more.\n+     */\n+    private static boolean absentOrOne(Graph g, Node s, Node p, Node o) {\n+        ExtendedIterator<Triple> iter = G.find(g, s, p, null);\n+        try {\n+            if ( ! iter.hasNext() )\n+                return false;\n+            iter.next();\n+            if ( ! iter.hasNext() )\n+                return true;\n+            long x = Iter.count(G.find(g, s, p, null));\n+            throw new ShaclParseException(\"More then one (\" + x + \") of \" + String.format(\"(%s %s %s)\", s, p, o));", "originalCommit": "b3ab06944c6281f58a8d19eaaa9a9eac2eb0f7fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU1MTUyMw==", "url": "https://github.com/apache/jena/pull/804#discussion_r499551523", "bodyText": "Done", "author": "afs", "createdAt": "2020-10-05T12:12:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTMxNzEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2MDkyNg==", "url": "https://github.com/apache/jena/pull/804#discussion_r499360926", "bodyText": "Do we have to close iter?", "author": "kinow", "createdAt": "2020-10-05T06:03:44Z", "path": "jena-arq/src/main/java/org/apache/jena/riot/other/G.java", "diffHunk": "@@ -0,0 +1,669 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.jena.riot.other;\n+\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+import org.apache.jena.atlas.iterator.Iter;\n+import org.apache.jena.graph.*;\n+import org.apache.jena.riot.out.NodeFmtLib;\n+import org.apache.jena.sparql.core.Quad;\n+import org.apache.jena.sparql.graph.NodeConst;\n+import org.apache.jena.sparql.util.graph.GNode;\n+import org.apache.jena.sparql.util.graph.GraphList;\n+import org.apache.jena.util.iterator.ExtendedIterator;\n+\n+/** A library of functions for working with {@link Graph}. */\n+public class G {\n+    private G() {}\n+\n+    private static Node rdfType = NodeConst.nodeRDFType;\n+\n+    /** Return the subject of a triple, or null if the triple is null. */\n+    public static Node subject(Triple triple) {\n+        return triple == null ? null : triple.getSubject();\n+    }\n+\n+    /** Return the predicate of a triple, or null if the triple is null. */\n+    public static Node predicate(Triple triple) {\n+        return triple == null ? null : triple.getPredicate();\n+    }\n+\n+    /** Return the object of a triple, or null if the triple is null. */\n+    public static Node object(Triple triple) {\n+        return triple == null ? null : triple.getObject();\n+    }\n+\n+    // ---- Node filter tests.\n+    public static boolean isURI(Node n)         { return n != null && n.isURI(); }\n+    public static boolean isBlank(Node n)       { return n != null && n.isBlank(); }\n+    public static boolean isLiteral(Node n)     { return n != null && n.isLiteral(); }\n+    public static boolean isResource(Node n)    { return n != null && (n.isURI()||n.isBlank()); }\n+    public static boolean isNodeTriple(Node n)  { return n != null && n.isNodeTriple(); }\n+    public static boolean isNodeGraph(Node n)   { return n != null && n.isNodeGraph(); }\n+\n+    /** Convert null to Node.ANY */\n+    public static Node nullAsAny(Node x) { return nullAsDft(x, Node.ANY) ; }\n+\n+    /** Convert null to some default Node */\n+    public static Node nullAsDft(Node x, Node dft) { return x==null ? dft : x ; }\n+\n+    /** Does the graph match the s/p/o pattern? */\n+    public static boolean contains(Graph graph, Node subject, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return graph.contains(subject, predicate, object);\n+    }\n+\n+    /** Does the graph use the node anywhere as a subject, predicate or object? */\n+    public static boolean containsNode(Graph graph, Node node) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        return GraphUtil.containsNode(graph, node);\n+//        return\n+//            contains(graph, node, Node.ANY, Node.ANY) ||\n+//            contains(graph, Node.ANY, Node.ANY, node) ||\n+//            contains(graph, Node.ANY, node, Node.ANY) ;\n+    }\n+\n+    /** Test whether the node has the type or is rdfs:subclassOf. */\n+    public static boolean isOfType(Graph graph, Node node, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        Objects.requireNonNull(type, \"type\");\n+        List<Node> allClasses = listSubClasses(graph, type);\n+        for ( Node c : allClasses ) {\n+            if ( hasType(graph, node, c) )\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+    /** Does the node x have the given type (non-RDFS - no rdfs:subclassOf considered)? */\n+    public static boolean hasType(Graph graph, Node node, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        Objects.requireNonNull(type, \"type\");\n+        return contains(graph, node, NodeConst.nodeRDFType, type);\n+    }\n+\n+    //---- get/list/iter\n+\n+    /** Does node {@code s} have property {@code p} in graph {@code g}? */\n+    public static boolean hasProperty(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return graph.contains(subject, predicate, null);\n+    }\n+\n+    /** Contains exactly one. */\n+    public static boolean containsOne(Graph graph, Node subject, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        ExtendedIterator<Triple> iter = graph.find(subject, predicate, object);\n+        try {\n+            if ( ! iter.hasNext() )\n+                return false;\n+            iter.next();\n+            return !iter.hasNext();\n+        } finally { iter.close(); }\n+    }\n+\n+    /**\n+     * Get object, given subject and predicate. Returns one (non-deterministically) or null.\n+     * See also {@link #getOneSP} and {@link #getZeroOrOneSP}.\n+     */\n+    public static Node getSP(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return object(first(find(graph, subject, predicate, Node.ANY)));\n+    }\n+\n+    // --- Graph walking.\n+\n+    /**\n+     * Get object for subject-predicate. Must be exactly one object; exception\n+     * {@linkplain RDFDataException} thrown when none or more than one.\n+     */\n+    public static Node getOneSP(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return object(findUnique(graph, subject, predicate, Node.ANY));\n+    }\n+\n+    /**\n+     * Get object for subject-predicate. Return null for none, object for one, and\n+     * exception {@linkplain RDFDataException} if more than one.\n+     */\n+    public static Node getZeroOrOneSP(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return object(findZeroOne(graph, subject, predicate, Node.ANY));\n+    }\n+\n+    /**\n+     *  Get the subject, given predicate and object. Returns one (non-deterministically) or null.\n+     *  See also {@link #getOnePO} and {@link #getZeroOrOnePO}.\n+     */\n+    public static Node getPO(Graph graph, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return object(first(find(graph, Node.ANY, predicate, object)));\n+    }\n+\n+    /**\n+     * Get the subject for predicate-object. Must be exactly one subject; exception\n+     * {@linkplain RDFDataException} thrown when none or more than one.\n+     */\n+    public static Node getOnePO(Graph graph, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return subject(findUnique(graph, Node.ANY, predicate, object));\n+    }\n+\n+    /**\n+     * Get the subject for predicate-object. Return null for none, subject for one, throw\n+     * exception {@linkplain RDFDataException} if more than one.\n+     */\n+    public static Node getZeroOrOnePO(Graph graph, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return subject(findZeroOne(graph, Node.ANY, predicate, object));\n+    }\n+\n+    /**\n+     * Get triple if there is exactly one to match the s/p/o, else throw\n+     * {@linkplain RDFDataException}.\n+     */\n+    public static Triple getOne(Graph graph, Node subject, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return findUnique(graph, subject, predicate, object);\n+    }\n+\n+    /**\n+     * Get triple if there is exactly one to match the s/p/o; return null if none;\n+     * throw {@linkplain RDFDataException} if more than one.\n+     */\n+    public static Triple getZeroOrOne(Graph graph, Node subject, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return findZeroOne(graph, subject, predicate, object);\n+    }\n+\n+    // ---- Multiple matches.\n+\n+    /**\n+     * {@link ExtendedIterator} of objects where the triple matches for subject and\n+     * predicate (which can be wildcards). The {@link ExtendedIterator} must be fully\n+     * used or explicitly closed. It is preferable use {@link #listSP} which handles\n+     * this condition.\n+     */\n+    public static ExtendedIterator<Node> iterSP(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return find(graph, subject, predicate, null).mapWith(Triple::getObject);\n+    }\n+\n+    /**\n+     * List of objects matching the subject-predicate (which can be wildcards).\n+     */\n+    public static List<Node> listSP(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return iterSP(graph, subject, predicate).toList();\n+    }\n+\n+    /** Count matches of subject-predicate (which can be wildcards). */\n+    public static long countSP(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return Iter.count(iterSP(graph, subject, predicate));\n+    }\n+\n+    /**\n+     * {@link ExtendedIterator} of subjects where the triple matches for predicate\n+     * and object (which can be wildcards). The {@link ExtendedIterator} must be\n+     * fully used or explicitly closed. It is preferable use {@link #listSP} which\n+     * handles this condition.\n+     */\n+    public static ExtendedIterator<Node> iterPO(Graph graph, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return find(graph, null, predicate, object).mapWith(Triple::getSubject);\n+    }\n+\n+    /**\n+     * List of subjects matching the predicate-object (which can be wildcards).\n+     */\n+    public static List<Node> listPO(Graph graph, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return iterPO(graph, predicate, object).toList();\n+    }\n+\n+    /** Count matches of predicate-object (which can be wildcards). */\n+    public static long countPO(Graph graph, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return Iter.count(iterPO(graph, predicate, object));\n+    }\n+\n+    // DISTINCT means these are space using.\n+\n+    /** List the subjects in a graph (no duplicates) */\n+    public static Iterator<Node> listSubjects(Graph graph) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        ExtendedIterator<Triple> iter = graph.find(Node.ANY, Node.ANY, Node.ANY);\n+        return Iter.iter(iter).map(Triple::getSubject).distinct();\n+    }\n+\n+    /** List the predicates in a graph (no duplicates) */\n+    public static Iterator<Node> listPredicates(Graph graph) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        ExtendedIterator<Triple> iter = graph.find(Node.ANY, Node.ANY, Node.ANY);\n+        return Iter.iter(iter).map(Triple::getPredicate).distinct();\n+    }\n+\n+    /** List the objects in a graph (no duplicates) */\n+    public static Iterator<Node> listObjects(Graph graph) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        ExtendedIterator<Triple> iter = graph.find(Node.ANY, Node.ANY, Node.ANY);\n+        return Iter.iter(iter).map(Triple::getObject).distinct();\n+    }\n+\n+    // ---- rdf:type, not RDFS\n+\n+    /**\n+     * List the subjects with exactly {@code type}.\n+     * See {@link #listNodesOfTypeRDFS(Graph, Node)}, which does include sub-classes.\n+     */\n+    public static List<Node> nodesOfTypeAsList(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        return find(graph, null, rdfType, type).mapWith(Triple::getSubject).toList();\n+    }\n+\n+    /**\n+     * List the types of a node/subject.\n+     * See {@link #listTypesOfNodeRDFS(Graph, Node)} , which does include super-classes.\n+     */\n+    public static List<Node> typesOfNodeAsList(Graph graph, Node node) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        return find(graph, node, rdfType, null).mapWith(Triple::getObject).toList();\n+    }\n+\n+    /**\n+     * Set of nodes with exactly {@code type}.\n+     * See {@link #allNodesOfTypeRDFS(Graph, Node)}, which does include sub-classes.\n+     */\n+    public static Set<Node> nodesOfTypeAsSet(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        return find(graph, null, rdfType, type).mapWith(Triple::getSubject).toSet();\n+    }\n+\n+    /**\n+     * Set of exact types of a node See {@link #allTypesOfNodeRDFS(Graph, Node)},\n+     * which does include super-classes.\n+     */\n+    public static Set<Node> typesOfNodeAsSet(Graph graph, Node node) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        return find(graph, node, rdfType, null).mapWith(Triple::getObject).toSet();\n+    }\n+\n+    // ---- RDF list.\n+\n+    /** Return a java list for an RDF list of data. */\n+    public static List<Node> rdfList(Graph graph, Node node) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        GNode gNode = GNode.create(graph, node);\n+        return GraphList.members(gNode);\n+    }\n+\n+    // Sub-class / super-class\n+\n+    /**\n+     * List the subclasses of a type, including itself.\n+     * This is <tt>?x rdfs:subClassOf* type</tt>.\n+     * The list does not contain duplicates.\n+     */\n+    public static List<Node> listSubClasses(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        List<Node> acc = new ArrayList<>();\n+        // Subclasses are follow rdfs:subClassOf in reverse - object to subject.\n+        // Transitive.transitive is \"visit once\".\n+        Transitive.transitiveInc(graph, false, type, NodeConst.rdfsSubclassOf, acc);\n+        return acc;\n+    }\n+\n+    /**\n+     * List the super-classes of a type, including itself.\n+     * This is <tt>type rdfs:subClassOf* ?x</tt>.\n+     * The list does not contain duplicates.\n+     */\n+    public static List<Node> listSuperClasses(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        List<Node> acc = new ArrayList<>();\n+        // Super classes are \"follow rdfs:subclassOf\" - subject to object.\n+        // Transitive.transitive is \"visit once\".\n+        Transitive.transitiveInc(graph, true, type, NodeConst.rdfsSubclassOf, acc);\n+        return acc;\n+    }\n+\n+    /**\n+     * Set of the subclasses of a type, including itself.\n+     * This is <tt>?x rdfs:subClassOf* type</tt>.\n+     */\n+    public static Set<Node> subClasses(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        Set<Node> acc = new HashSet<>();\n+        // Subclasses are follow rdfs:subclassOf in reverse - object to subject.\n+        Transitive.transitiveInc(graph, false, type, NodeConst.rdfsSubclassOf, acc);\n+        return acc;\n+    }\n+\n+    /**\n+     * Set of the subclasses of a type, including itself.\n+     * This is <tt>?x rdfs:subClassOf* type</tt>.\n+     */\n+    public static Set<Node> superClasses(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        Set<Node> acc = new HashSet<>();\n+        Transitive.transitiveInc(graph, true, type, NodeConst.rdfsSubclassOf, acc);\n+        return acc;\n+    }\n+\n+    // ---- RDFS\n+\n+    /**\n+     * List the types of a node, following rdfs:subClassOf for super classes.\n+     */\n+    public static List<Node> listTypesOfNodeRDFS(Graph graph, Node node) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        List<Node> types = typesOfNodeAsList(graph, node);\n+        List<Node> types2 = new ArrayList<>();\n+        types.forEach(t->{\n+            List<Node> subClasses = listSuperClasses(graph, t);\n+            types2.addAll(subClasses);\n+        });\n+        return types2;\n+    }\n+\n+    /**\n+     * List all the nodes of type, including node of sub-classes.\n+     */\n+    public static List<Node> listNodesOfTypeRDFS(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        List<Node> types = listSubClasses(graph, type);\n+        List<Node> nodes = new ArrayList<>();\n+        accNodesOfTypes(nodes, graph, types);\n+        return nodes;\n+    }\n+\n+    /**\n+     * List all the types of a node, including super-classes.\n+     */\n+    public static Set<Node> allTypesOfNodeRDFS(Graph graph, Node node) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(node, \"node\");\n+        Set<Node> types = typesOfNodeAsSet(graph, node);\n+        Set<Node> types2 = new HashSet<>();\n+        types.forEach(t->{\n+            List<Node> subClasses = listSuperClasses(graph, t);\n+            types2.addAll(subClasses);\n+        });\n+        return types2;\n+    }\n+\n+    /** List all the node of type, including considering rdfs:subClassOf */\n+    public static Set<Node> allNodesOfTypeRDFS(Graph graph, Node type) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(type, \"type\");\n+        Set<Node> types = subClasses(graph, type);\n+        Set<Node> nodes = new HashSet<>();\n+        accNodesOfTypes(nodes, graph, types);\n+        return nodes;\n+    }\n+\n+    /** For each type, find nodes of that type and accumulate */\n+    private static void accNodesOfTypes(Collection<Node> acc, Graph graph, Collection<Node> types) {\n+        types.forEach(t->\n+            find(graph, null, rdfType, t).mapWith(Triple::getSubject).forEach(acc::add)\n+            );\n+    }\n+\n+    /** Return a set of all objects for subject-predicate */\n+    public static Set<Node> allSP(Graph graph, Node subject, Node predicate) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return find(graph, subject, predicate, null).mapWith(Triple::getObject).toSet();\n+    }\n+\n+    /** Return a set of all subjects for predicate-object */\n+    public static Set<Node> allPO(Graph graph, Node predicate, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        return find(graph, null, predicate, object).mapWith(Triple::getSubject).toSet();\n+    }\n+\n+    // --- Graph walking.\n+\n+    /** Count the number of in-arc to an object */\n+    public static long objectConnectiveness(Graph graph, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(object, \"object\");\n+        return Iter.count(find(graph, null, null, object));\n+    }\n+\n+    /** Test whether an object has exactly one in-arc. */\n+    public static boolean oneConnected(Graph graph, Node object) {\n+        Objects.requireNonNull(graph, \"graph\");\n+        Objects.requireNonNull(object, \"object\");\n+        ExtendedIterator<Triple> iter = find(graph, null, null, object);\n+        if ( ! iter.hasNext() )\n+            // Zero.\n+            return false;\n+        iter.next();\n+        if ( iter.hasNext() )\n+            // more than one\n+            return false;\n+        return true;", "originalCommit": "b3ab06944c6281f58a8d19eaaa9a9eac2eb0f7fb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTU1MzU1NQ==", "url": "https://github.com/apache/jena/pull/804#discussion_r499553555", "bodyText": "Yes. (It is also most the same as findUnique)\nClosing unfinished extended iterators is contract even if many (most?) apps don't care or attend to the detail. In fact, plain in-memory, TDB1, TDB2 and TIM don't rely on this. But as a library it ought to get it right!", "author": "afs", "createdAt": "2020-10-05T12:15:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTM2MDkyNg=="}], "type": "inlineReview"}, {"oid": "b552757b224a43926b9ffeb5e86efca206c57ecc", "url": "https://github.com/apache/jena/commit/b552757b224a43926b9ffeb5e86efca206c57ecc", "message": "Mark iterator to stream as immutable", "committedDate": "2020-10-05T11:12:43Z", "type": "commit"}, {"oid": "2ce67087fc0decde38d3c79b6b85dde259c788ea", "url": "https://github.com/apache/jena/commit/2ce67087fc0decde38d3c79b6b85dde259c788ea", "message": "JENA-1974: Function library for working with graphs", "committedDate": "2020-10-05T11:13:47Z", "type": "commit"}, {"oid": "2ce67087fc0decde38d3c79b6b85dde259c788ea", "url": "https://github.com/apache/jena/commit/2ce67087fc0decde38d3c79b6b85dde259c788ea", "message": "JENA-1974: Function library for working with graphs", "committedDate": "2020-10-05T11:13:47Z", "type": "forcePushed"}]}