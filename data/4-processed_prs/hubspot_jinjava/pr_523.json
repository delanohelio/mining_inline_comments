{"pr_number": 523, "pr_title": "Python Booleans and Filter base with parsing", "pr_createdAt": "2020-10-30T14:01:10Z", "pr_url": "https://github.com/HubSpot/jinjava/pull/523", "timeline": [{"oid": "73c8d78b8976cc1295ec0d54d4c855631b7e5c76", "url": "https://github.com/HubSpot/jinjava/commit/73c8d78b8976cc1295ec0d54d4c855631b7e5c76", "message": "toyaml/fromyaml filters, almost the same as tojson/fromjson using jackson", "committedDate": "2020-10-30T11:30:52Z", "type": "commit"}, {"oid": "faf57d9b1575e08a0ca54c9a2ff0f419c6646ff8", "url": "https://github.com/HubSpot/jinjava/commit/faf57d9b1575e08a0ca54c9a2ff0f419c6646ff8", "message": "Py-style booleans support True|False", "committedDate": "2020-10-30T11:31:50Z", "type": "commit"}, {"oid": "859f87d28f95d66c55c7bf146336cda61e9c2cbe", "url": "https://github.com/HubSpot/jinjava/commit/859f87d28f95d66c55c7bf146336cda61e9c2cbe", "message": "AbstractFilter implementation that uses Jinjavadoc to create parameters with name and automatic parsing", "committedDate": "2020-10-30T13:51:46Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5Mjk1Mw==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515292953", "bodyText": "style nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                for(JinjavaParam jinjavaParam: getNamedArguments().values()) {\n          \n          \n            \n                for (JinjavaParam jinjavaParam : getNamedArguments().values()) {", "author": "boulter", "createdAt": "2020-10-30T18:14:14Z", "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+\n+  private Map<String, JinjavaParam> namedArguments;\n+  private boolean isNamedArgumentCheckDone;\n+\n+  abstract Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Map<String, Object> parsedArgs);\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Object[] args,\n+          Map<String, Object> kwargs) {\n+    Map<String, JinjavaParam> validNamedArgs = getNamedArguments();\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    validNamedArgs.forEach((k, v) -> {\n+      if (StringUtils.isNotEmpty(v.defaultValue())) {\n+        namedArgs.put(k, v.defaultValue());\n+      }\n+    });\n+    //Process named params\n+    for (String passedNamedArg : kwargs.keySet()) {\n+      int argPosition = getNamedArgumentPosition(passedNamedArg);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument named '%s' is invalid for filter %s\", passedNamedArg, getName())\n+        );\n+      }\n+      namedArgs.put(passedNamedArg, kwargs.get(passedNamedArg));\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach((k, v) -> parsedArgs.put(k, parseArg(interpreter, validNamedArgs.get(k), v)));\n+\n+    validateArgs(interpreter, parsedArgs);\n+\n+    return filter(var, interpreter, parsedArgs);\n+  }\n+\n+  public Object parseArg(JinjavaInterpreter interpreter, JinjavaParam jinjavaParamMetadata, Object value) {\n+    if (jinjavaParamMetadata.type() == null ||\n+        Arrays.asList(\"object\", \"dict\", \"sequence\").contains(jinjavaParamMetadata.type())) {\n+      return value;\n+    }\n+    String valueString = Objects.toString(value, null);\n+    switch (jinjavaParamMetadata.type().toLowerCase()) {\n+      case \"boolean\": {\n+        return BooleanUtils.toBoolean(valueString);\n+      }\n+      case \"int\": {\n+        return NumberUtils.toInt(valueString);\n+      }\n+      case \"long\": {\n+        return NumberUtils.toLong(valueString);\n+      }\n+      case \"float\": {\n+        return NumberUtils.toFloat(valueString);\n+      }\n+      case \"double\": {\n+        return NumberUtils.toDouble(valueString);\n+      }\n+      case \"number\": {\n+        return new BigDecimal(valueString);\n+      }\n+      case \"string\": {\n+        return valueString;\n+      }\n+    }\n+    throw new InvalidInputException(\n+            interpreter,\n+            \"INVALID_ARG_NAME\",\n+            String.format(\"Argument named '%s' with value '%s' cannot be parsed for filter %s\", jinjavaParamMetadata.value(), getName())\n+    );\n+  }\n+\n+  public void validateArgs(JinjavaInterpreter interpreter, Map<String, Object> parsedArgs) {\n+    for(JinjavaParam jinjavaParam: getNamedArguments().values()) {", "originalCommit": "859f87d28f95d66c55c7bf146336cda61e9c2cbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5MzA3Nw==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515293077", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  if(jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {\n          \n          \n            \n                  if (jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {", "author": "boulter", "createdAt": "2020-10-30T18:14:26Z", "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+\n+  private Map<String, JinjavaParam> namedArguments;\n+  private boolean isNamedArgumentCheckDone;\n+\n+  abstract Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Map<String, Object> parsedArgs);\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Object[] args,\n+          Map<String, Object> kwargs) {\n+    Map<String, JinjavaParam> validNamedArgs = getNamedArguments();\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    validNamedArgs.forEach((k, v) -> {\n+      if (StringUtils.isNotEmpty(v.defaultValue())) {\n+        namedArgs.put(k, v.defaultValue());\n+      }\n+    });\n+    //Process named params\n+    for (String passedNamedArg : kwargs.keySet()) {\n+      int argPosition = getNamedArgumentPosition(passedNamedArg);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument named '%s' is invalid for filter %s\", passedNamedArg, getName())\n+        );\n+      }\n+      namedArgs.put(passedNamedArg, kwargs.get(passedNamedArg));\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach((k, v) -> parsedArgs.put(k, parseArg(interpreter, validNamedArgs.get(k), v)));\n+\n+    validateArgs(interpreter, parsedArgs);\n+\n+    return filter(var, interpreter, parsedArgs);\n+  }\n+\n+  public Object parseArg(JinjavaInterpreter interpreter, JinjavaParam jinjavaParamMetadata, Object value) {\n+    if (jinjavaParamMetadata.type() == null ||\n+        Arrays.asList(\"object\", \"dict\", \"sequence\").contains(jinjavaParamMetadata.type())) {\n+      return value;\n+    }\n+    String valueString = Objects.toString(value, null);\n+    switch (jinjavaParamMetadata.type().toLowerCase()) {\n+      case \"boolean\": {\n+        return BooleanUtils.toBoolean(valueString);\n+      }\n+      case \"int\": {\n+        return NumberUtils.toInt(valueString);\n+      }\n+      case \"long\": {\n+        return NumberUtils.toLong(valueString);\n+      }\n+      case \"float\": {\n+        return NumberUtils.toFloat(valueString);\n+      }\n+      case \"double\": {\n+        return NumberUtils.toDouble(valueString);\n+      }\n+      case \"number\": {\n+        return new BigDecimal(valueString);\n+      }\n+      case \"string\": {\n+        return valueString;\n+      }\n+    }\n+    throw new InvalidInputException(\n+            interpreter,\n+            \"INVALID_ARG_NAME\",\n+            String.format(\"Argument named '%s' with value '%s' cannot be parsed for filter %s\", jinjavaParamMetadata.value(), getName())\n+    );\n+  }\n+\n+  public void validateArgs(JinjavaInterpreter interpreter, Map<String, Object> parsedArgs) {\n+    for(JinjavaParam jinjavaParam: getNamedArguments().values()) {\n+      if(jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {", "originalCommit": "859f87d28f95d66c55c7bf146336cda61e9c2cbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5MzIwNA==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515293204", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  for (JinjavaParam jinjavaParam: jinjavaDoc.params()) {\n          \n          \n            \n                  for (JinjavaParam jinjavaParam : jinjavaDoc.params()) {", "author": "boulter", "createdAt": "2020-10-30T18:14:42Z", "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+\n+  private Map<String, JinjavaParam> namedArguments;\n+  private boolean isNamedArgumentCheckDone;\n+\n+  abstract Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Map<String, Object> parsedArgs);\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Object[] args,\n+          Map<String, Object> kwargs) {\n+    Map<String, JinjavaParam> validNamedArgs = getNamedArguments();\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    validNamedArgs.forEach((k, v) -> {\n+      if (StringUtils.isNotEmpty(v.defaultValue())) {\n+        namedArgs.put(k, v.defaultValue());\n+      }\n+    });\n+    //Process named params\n+    for (String passedNamedArg : kwargs.keySet()) {\n+      int argPosition = getNamedArgumentPosition(passedNamedArg);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument named '%s' is invalid for filter %s\", passedNamedArg, getName())\n+        );\n+      }\n+      namedArgs.put(passedNamedArg, kwargs.get(passedNamedArg));\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach((k, v) -> parsedArgs.put(k, parseArg(interpreter, validNamedArgs.get(k), v)));\n+\n+    validateArgs(interpreter, parsedArgs);\n+\n+    return filter(var, interpreter, parsedArgs);\n+  }\n+\n+  public Object parseArg(JinjavaInterpreter interpreter, JinjavaParam jinjavaParamMetadata, Object value) {\n+    if (jinjavaParamMetadata.type() == null ||\n+        Arrays.asList(\"object\", \"dict\", \"sequence\").contains(jinjavaParamMetadata.type())) {\n+      return value;\n+    }\n+    String valueString = Objects.toString(value, null);\n+    switch (jinjavaParamMetadata.type().toLowerCase()) {\n+      case \"boolean\": {\n+        return BooleanUtils.toBoolean(valueString);\n+      }\n+      case \"int\": {\n+        return NumberUtils.toInt(valueString);\n+      }\n+      case \"long\": {\n+        return NumberUtils.toLong(valueString);\n+      }\n+      case \"float\": {\n+        return NumberUtils.toFloat(valueString);\n+      }\n+      case \"double\": {\n+        return NumberUtils.toDouble(valueString);\n+      }\n+      case \"number\": {\n+        return new BigDecimal(valueString);\n+      }\n+      case \"string\": {\n+        return valueString;\n+      }\n+    }\n+    throw new InvalidInputException(\n+            interpreter,\n+            \"INVALID_ARG_NAME\",\n+            String.format(\"Argument named '%s' with value '%s' cannot be parsed for filter %s\", jinjavaParamMetadata.value(), getName())\n+    );\n+  }\n+\n+  public void validateArgs(JinjavaInterpreter interpreter, Map<String, Object> parsedArgs) {\n+    for(JinjavaParam jinjavaParam: getNamedArguments().values()) {\n+      if(jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"MISSING_REQUIRED_ARG\",\n+                String.format(\"Argument named '%s' is required but missing for filter %s\", jinjavaParam.value(), getName())\n+        );\n+      }\n+    }\n+  }\n+\n+  public Map<String, JinjavaParam> getNamedArguments() {\n+    if (isNamedArgumentCheckDone) {\n+      return namedArguments;\n+    }\n+    JinjavaDoc jinjavaDoc = this.getClass().getAnnotation(JinjavaDoc.class);\n+    if (jinjavaDoc != null) {\n+      namedArguments = new LinkedHashMap<>();\n+      for (JinjavaParam jinjavaParam: jinjavaDoc.params()) {", "originalCommit": "859f87d28f95d66c55c7bf146336cda61e9c2cbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5NDEzMQ==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515294131", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                int width = ((Number)parsedArgs.get(\"width\")).intValue();\n          \n          \n            \n                int width = ((Number) parsedArgs.get(\"width\")).intValue();", "author": "boulter", "createdAt": "2020-10-30T18:16:23Z", "path": "src/main/java/com/hubspot/jinjava/lib/filter/IndentFilter.java", "diffHunk": "@@ -40,24 +41,20 @@\n     )\n   }\n )\n-public class IndentFilter implements Filter {\n+public class IndentFilter extends AbstractFilter {\n \n   @Override\n   public String getName() {\n     return \"indent\";\n   }\n \n   @Override\n-  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n-    int width = 4;\n-    if (args.length > 0) {\n-      width = NumberUtils.toInt(args[0], 4);\n-    }\n+  public Object filter(Object var,\n+                       JinjavaInterpreter interpreter,\n+                       Map<String, Object> parsedArgs) {\n+    int width = ((Number)parsedArgs.get(\"width\")).intValue();", "originalCommit": "859f87d28f95d66c55c7bf146336cda61e9c2cbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5NDE4Ng==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515294186", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                boolean indentFirst = (boolean)parsedArgs.get(\"indentfirst\");\n          \n          \n            \n                boolean indentFirst = (boolean) parsedArgs.get(\"indentfirst\");", "author": "boulter", "createdAt": "2020-10-30T18:16:31Z", "path": "src/main/java/com/hubspot/jinjava/lib/filter/IndentFilter.java", "diffHunk": "@@ -40,24 +41,20 @@\n     )\n   }\n )\n-public class IndentFilter implements Filter {\n+public class IndentFilter extends AbstractFilter {\n \n   @Override\n   public String getName() {\n     return \"indent\";\n   }\n \n   @Override\n-  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n-    int width = 4;\n-    if (args.length > 0) {\n-      width = NumberUtils.toInt(args[0], 4);\n-    }\n+  public Object filter(Object var,\n+                       JinjavaInterpreter interpreter,\n+                       Map<String, Object> parsedArgs) {\n+    int width = ((Number)parsedArgs.get(\"width\")).intValue();\n \n-    boolean indentFirst = false;\n-    if (args.length > 1) {\n-      indentFirst = BooleanUtils.toBoolean(args[1]);\n-    }\n+    boolean indentFirst = (boolean)parsedArgs.get(\"indentfirst\");", "originalCommit": "859f87d28f95d66c55c7bf146336cda61e9c2cbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5NjkzMw==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515296933", "bodyText": "You could rewrite this in funcional style with something like\nreturn Optional.ofNullable(getNamedArguments()).map(a -> a.keySet()).filter(argNames -> a.contains(argName)).map(a -> a.indexOf(argName)).orElse(-1);", "author": "boulter", "createdAt": "2020-10-30T18:22:01Z", "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+\n+  private Map<String, JinjavaParam> namedArguments;\n+  private boolean isNamedArgumentCheckDone;\n+\n+  abstract Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Map<String, Object> parsedArgs);\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Object[] args,\n+          Map<String, Object> kwargs) {\n+    Map<String, JinjavaParam> validNamedArgs = getNamedArguments();\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    validNamedArgs.forEach((k, v) -> {\n+      if (StringUtils.isNotEmpty(v.defaultValue())) {\n+        namedArgs.put(k, v.defaultValue());\n+      }\n+    });\n+    //Process named params\n+    for (String passedNamedArg : kwargs.keySet()) {\n+      int argPosition = getNamedArgumentPosition(passedNamedArg);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument named '%s' is invalid for filter %s\", passedNamedArg, getName())\n+        );\n+      }\n+      namedArgs.put(passedNamedArg, kwargs.get(passedNamedArg));\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach((k, v) -> parsedArgs.put(k, parseArg(interpreter, validNamedArgs.get(k), v)));\n+\n+    validateArgs(interpreter, parsedArgs);\n+\n+    return filter(var, interpreter, parsedArgs);\n+  }\n+\n+  public Object parseArg(JinjavaInterpreter interpreter, JinjavaParam jinjavaParamMetadata, Object value) {\n+    if (jinjavaParamMetadata.type() == null ||\n+        Arrays.asList(\"object\", \"dict\", \"sequence\").contains(jinjavaParamMetadata.type())) {\n+      return value;\n+    }\n+    String valueString = Objects.toString(value, null);\n+    switch (jinjavaParamMetadata.type().toLowerCase()) {\n+      case \"boolean\": {\n+        return BooleanUtils.toBoolean(valueString);\n+      }\n+      case \"int\": {\n+        return NumberUtils.toInt(valueString);\n+      }\n+      case \"long\": {\n+        return NumberUtils.toLong(valueString);\n+      }\n+      case \"float\": {\n+        return NumberUtils.toFloat(valueString);\n+      }\n+      case \"double\": {\n+        return NumberUtils.toDouble(valueString);\n+      }\n+      case \"number\": {\n+        return new BigDecimal(valueString);\n+      }\n+      case \"string\": {\n+        return valueString;\n+      }\n+    }\n+    throw new InvalidInputException(\n+            interpreter,\n+            \"INVALID_ARG_NAME\",\n+            String.format(\"Argument named '%s' with value '%s' cannot be parsed for filter %s\", jinjavaParamMetadata.value(), getName())\n+    );\n+  }\n+\n+  public void validateArgs(JinjavaInterpreter interpreter, Map<String, Object> parsedArgs) {\n+    for(JinjavaParam jinjavaParam: getNamedArguments().values()) {\n+      if(jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"MISSING_REQUIRED_ARG\",\n+                String.format(\"Argument named '%s' is required but missing for filter %s\", jinjavaParam.value(), getName())\n+        );\n+      }\n+    }\n+  }\n+\n+  public Map<String, JinjavaParam> getNamedArguments() {\n+    if (isNamedArgumentCheckDone) {\n+      return namedArguments;\n+    }\n+    JinjavaDoc jinjavaDoc = this.getClass().getAnnotation(JinjavaDoc.class);\n+    if (jinjavaDoc != null) {\n+      namedArguments = new LinkedHashMap<>();\n+      for (JinjavaParam jinjavaParam: jinjavaDoc.params()) {\n+        namedArguments.put(jinjavaParam.value(), jinjavaParam);\n+      }\n+      namedArguments = Collections.unmodifiableMap(namedArguments);\n+    }\n+    isNamedArgumentCheckDone = true;\n+    return namedArguments;\n+  }\n+\n+  public int getNamedArgumentPosition(String argName) {\n+    getNamedArguments();", "originalCommit": "859f87d28f95d66c55c7bf146336cda61e9c2cbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5NzI3MA==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515297270", "bodyText": "same comment as above.", "author": "boulter", "createdAt": "2020-10-30T18:22:43Z", "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+\n+  private Map<String, JinjavaParam> namedArguments;\n+  private boolean isNamedArgumentCheckDone;\n+\n+  abstract Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Map<String, Object> parsedArgs);\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+          Object var,\n+          JinjavaInterpreter interpreter,\n+          Object[] args,\n+          Map<String, Object> kwargs) {\n+    Map<String, JinjavaParam> validNamedArgs = getNamedArguments();\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    validNamedArgs.forEach((k, v) -> {\n+      if (StringUtils.isNotEmpty(v.defaultValue())) {\n+        namedArgs.put(k, v.defaultValue());\n+      }\n+    });\n+    //Process named params\n+    for (String passedNamedArg : kwargs.keySet()) {\n+      int argPosition = getNamedArgumentPosition(passedNamedArg);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument named '%s' is invalid for filter %s\", passedNamedArg, getName())\n+        );\n+      }\n+      namedArgs.put(passedNamedArg, kwargs.get(passedNamedArg));\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"INVALID_ARG_NAME\",\n+                String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach((k, v) -> parsedArgs.put(k, parseArg(interpreter, validNamedArgs.get(k), v)));\n+\n+    validateArgs(interpreter, parsedArgs);\n+\n+    return filter(var, interpreter, parsedArgs);\n+  }\n+\n+  public Object parseArg(JinjavaInterpreter interpreter, JinjavaParam jinjavaParamMetadata, Object value) {\n+    if (jinjavaParamMetadata.type() == null ||\n+        Arrays.asList(\"object\", \"dict\", \"sequence\").contains(jinjavaParamMetadata.type())) {\n+      return value;\n+    }\n+    String valueString = Objects.toString(value, null);\n+    switch (jinjavaParamMetadata.type().toLowerCase()) {\n+      case \"boolean\": {\n+        return BooleanUtils.toBoolean(valueString);\n+      }\n+      case \"int\": {\n+        return NumberUtils.toInt(valueString);\n+      }\n+      case \"long\": {\n+        return NumberUtils.toLong(valueString);\n+      }\n+      case \"float\": {\n+        return NumberUtils.toFloat(valueString);\n+      }\n+      case \"double\": {\n+        return NumberUtils.toDouble(valueString);\n+      }\n+      case \"number\": {\n+        return new BigDecimal(valueString);\n+      }\n+      case \"string\": {\n+        return valueString;\n+      }\n+    }\n+    throw new InvalidInputException(\n+            interpreter,\n+            \"INVALID_ARG_NAME\",\n+            String.format(\"Argument named '%s' with value '%s' cannot be parsed for filter %s\", jinjavaParamMetadata.value(), getName())\n+    );\n+  }\n+\n+  public void validateArgs(JinjavaInterpreter interpreter, Map<String, Object> parsedArgs) {\n+    for(JinjavaParam jinjavaParam: getNamedArguments().values()) {\n+      if(jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {\n+        throw new InvalidInputException(\n+                interpreter,\n+                \"MISSING_REQUIRED_ARG\",\n+                String.format(\"Argument named '%s' is required but missing for filter %s\", jinjavaParam.value(), getName())\n+        );\n+      }\n+    }\n+  }\n+\n+  public Map<String, JinjavaParam> getNamedArguments() {\n+    if (isNamedArgumentCheckDone) {\n+      return namedArguments;\n+    }\n+    JinjavaDoc jinjavaDoc = this.getClass().getAnnotation(JinjavaDoc.class);\n+    if (jinjavaDoc != null) {\n+      namedArguments = new LinkedHashMap<>();\n+      for (JinjavaParam jinjavaParam: jinjavaDoc.params()) {\n+        namedArguments.put(jinjavaParam.value(), jinjavaParam);\n+      }\n+      namedArguments = Collections.unmodifiableMap(namedArguments);\n+    }\n+    isNamedArgumentCheckDone = true;\n+    return namedArguments;\n+  }\n+\n+  public int getNamedArgumentPosition(String argName) {\n+    getNamedArguments();\n+    if (namedArguments != null) {\n+      List<String> argNames = new ArrayList<>(namedArguments.keySet());\n+      return argNames.contains(argName) ? argNames.indexOf(argName) : -1;\n+    }\n+    return -1;\n+  }\n+\n+  public String getIndexedArgumentName(int position) {\n+    getNamedArguments();", "originalCommit": "859f87d28f95d66c55c7bf146336cda61e9c2cbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTI5NzY1OQ==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r515297659", "bodyText": "Can you add some more test coverage for this class?", "author": "boulter", "createdAt": "2020-10-30T18:23:29Z", "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,189 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {", "originalCommit": "859f87d28f95d66c55c7bf146336cda61e9c2cbe", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a375e70c387dfbcc24ae1720da6c3e5275f17fdc", "url": "https://github.com/HubSpot/jinjava/commit/a375e70c387dfbcc24ae1720da6c3e5275f17fdc", "message": "style, checkstyle, findbugs fixes per comments. coverage tests for AbstractFilter", "committedDate": "2020-10-31T07:54:00Z", "type": "commit"}, {"oid": "3cf9f579bffe782c2366d18dc9a5b446b47b4b66", "url": "https://github.com/HubSpot/jinjava/commit/3cf9f579bffe782c2366d18dc9a5b446b47b4b66", "message": "removed yaml filters", "committedDate": "2020-10-31T07:59:12Z", "type": "commit"}, {"oid": "653a0eb3796781854acea4ebab2cf5e2b5b9370d", "url": "https://github.com/HubSpot/jinjava/commit/653a0eb3796781854acea4ebab2cf5e2b5b9370d", "message": "automatic java prettifier", "committedDate": "2020-10-31T12:51:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyMTkzNQ==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516021935", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private final Map<String, JinjavaParam> NAMED_ARGUMENTS;\n          \n          \n            \n              private final Map<String, JinjavaParam> namedArguments;\n          \n      \n    \n    \n  \n\nbecause it's not static", "author": "boulter", "createdAt": "2020-11-02T14:48:07Z", "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+  private final Map<String, JinjavaParam> NAMED_ARGUMENTS;", "originalCommit": "653a0eb3796781854acea4ebab2cf5e2b5b9370d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzOTMyNA==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516639324", "bodyText": "Done", "author": "michaelpro1", "createdAt": "2020-11-03T12:45:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyMTkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyMzIxMw==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516023213", "bodyText": "Might as well do this in the initializer with a stream() and collect().", "author": "boulter", "createdAt": "2020-11-02T14:49:55Z", "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+  private final Map<String, JinjavaParam> NAMED_ARGUMENTS;\n+\n+  public AbstractFilter() {\n+    NAMED_ARGUMENTS = initNamedArguments();\n+  }\n+\n+  abstract Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  );\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Object[] args,\n+    Map<String, Object> kwargs\n+  ) {\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    NAMED_ARGUMENTS.forEach(\n+      (k, v) -> {\n+        if (StringUtils.isNotEmpty(v.defaultValue())) {\n+          namedArgs.put(k, v.defaultValue());\n+        }\n+      }\n+    );", "originalCommit": "653a0eb3796781854acea4ebab2cf5e2b5b9370d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzOTM4Mg==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516639382", "bodyText": "Done", "author": "michaelpro1", "createdAt": "2020-11-03T12:45:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyMzIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyNDI0NA==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516024244", "bodyText": "Similar comment as above.", "author": "boulter", "createdAt": "2020-11-02T14:51:21Z", "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+  private final Map<String, JinjavaParam> NAMED_ARGUMENTS;\n+\n+  public AbstractFilter() {\n+    NAMED_ARGUMENTS = initNamedArguments();\n+  }\n+\n+  abstract Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  );\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Object[] args,\n+    Map<String, Object> kwargs\n+  ) {\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    NAMED_ARGUMENTS.forEach(\n+      (k, v) -> {\n+        if (StringUtils.isNotEmpty(v.defaultValue())) {\n+          namedArgs.put(k, v.defaultValue());\n+        }\n+      }\n+    );\n+    //Process named params\n+    for (Map.Entry<String, Object> passedNamedArgEntry : kwargs.entrySet()) {\n+      String argName = passedNamedArgEntry.getKey();\n+      Object argValue = passedNamedArgEntry.getValue();\n+      int argPosition = getNamedArgumentPosition(argName);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\n+            \"Argument named '%s' is invalid for filter %s\",\n+            argName,\n+            getName()\n+          )\n+        );\n+      }\n+      namedArgs.put(argName, argValue);\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach(\n+      (k, v) -> parsedArgs.put(k, parseArg(interpreter, NAMED_ARGUMENTS.get(k), v))\n+    );", "originalCommit": "653a0eb3796781854acea4ebab2cf5e2b5b9370d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzOTcwNQ==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516639705", "bodyText": "These are runtime arguments so can't be initialized at init", "author": "michaelpro1", "createdAt": "2020-11-03T12:45:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyNDI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyNzkyMA==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516027920", "bodyText": "could you create a static constant for \"indentfirst\" and \"width\"?", "author": "boulter", "createdAt": "2020-11-02T14:56:11Z", "path": "src/main/java/com/hubspot/jinjava/lib/filter/IndentFilter.java", "diffHunk": "@@ -40,24 +39,22 @@\n     )\n   }\n )\n-public class IndentFilter implements Filter {\n+public class IndentFilter extends AbstractFilter {\n \n   @Override\n   public String getName() {\n     return \"indent\";\n   }\n \n   @Override\n-  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n-    int width = 4;\n-    if (args.length > 0) {\n-      width = NumberUtils.toInt(args[0], 4);\n-    }\n+  public Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  ) {\n+    int width = ((Number) parsedArgs.get(\"width\")).intValue();\n \n-    boolean indentFirst = false;\n-    if (args.length > 1) {\n-      indentFirst = BooleanUtils.toBoolean(args[1]);\n-    }\n+    boolean indentFirst = (boolean) parsedArgs.get(\"indentfirst\");", "originalCommit": "653a0eb3796781854acea4ebab2cf5e2b5b9370d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjYzOTk0Nw==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516639947", "bodyText": "Done", "author": "michaelpro1", "createdAt": "2020-11-03T12:46:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyNzkyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyODQyOQ==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516028429", "bodyText": "nice tests, thank you.", "author": "boulter", "createdAt": "2020-11-02T14:56:53Z", "path": "src/test/java/com/hubspot/jinjava/lib/filter/AbstractFilterTest.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package com.hubspot.jinjava.lib.filter;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.hubspot.jinjava.BaseInterpretingTest;\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.Test;\n+\n+public class AbstractFilterTest extends BaseInterpretingTest {", "originalCommit": "653a0eb3796781854acea4ebab2cf5e2b5b9370d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyOTA0Mw==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516029043", "bodyText": "You could use ImmutableMap here for a more fluent interface and less repetition.", "author": "boulter", "createdAt": "2020-11-02T14:57:48Z", "path": "src/test/java/com/hubspot/jinjava/lib/filter/AbstractFilterTest.java", "diffHunk": "@@ -0,0 +1,163 @@\n+package com.hubspot.jinjava.lib.filter;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.hubspot.jinjava.BaseInterpretingTest;\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import org.junit.Test;\n+\n+public class AbstractFilterTest extends BaseInterpretingTest {\n+  private ArgCapturingFilter filter;\n+\n+  public static class NoJinjavaDocFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itErrorsWhenNoJinjavaDoc() {\n+    assertThatThrownBy(() -> new NoJinjavaDocFilter())\n+      .hasMessageContaining(\"@JinjavaDoc must be configured\");\n+  }\n+\n+  @JinjavaDoc\n+  public static class NoJinjavaParamsFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itDoesNotRequireParams() {\n+    filter = new NoJinjavaParamsFilter();\n+  }\n+\n+  @JinjavaDoc(\n+    params = {\n+      @JinjavaParam(value = \"1st\", desc = \"1st\"),\n+      @JinjavaParam(value = \"2nd\", desc = \"2nd\"),\n+      @JinjavaParam(value = \"3rd\", desc = \"3rd\")\n+    }\n+  )\n+  public static class TwoParamTypesFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itSupportsMixingOfPositionalAndNamedArgs() {\n+    filter = new TwoParamTypesFilter();\n+\n+    filter.filter(null, interpreter, new Object[] { \"1\" }, ImmutableMap.of(\"3rd\", \"3\"));\n+\n+    assertThat(filter.parsedArgs).isEqualTo(ImmutableMap.of(\"1st\", \"1\", \"3rd\", \"3\"));\n+  }\n+\n+  @JinjavaDoc(\n+    params = {\n+      @JinjavaParam(\n+        value = \"boolean\",\n+        type = \"boolean\",\n+        desc = \"boolean\",\n+        required = true\n+      ),\n+      @JinjavaParam(value = \"int\", type = \"int\", desc = \"int\"),\n+      @JinjavaParam(value = \"long\", type = \"long\", desc = \"long\"),\n+      @JinjavaParam(value = \"float\", type = \"float\", desc = \"float\"),\n+      @JinjavaParam(value = \"double\", type = \"double\", desc = \"double\"),\n+      @JinjavaParam(value = \"number\", type = \"number\", desc = \"number\"),\n+      @JinjavaParam(value = \"object\", type = \"object\", desc = \"object\"),\n+      @JinjavaParam(value = \"dict\", type = \"dict\", desc = \"dict\")\n+    }\n+  )\n+  public static class AllParamTypesFilter extends ArgCapturingFilter {}\n+\n+  @Test\n+  public void itParsesNumericAndBooleanInput() {\n+    filter = new AllParamTypesFilter();\n+\n+    Map<String, Object> kwArgs = new HashMap<>();", "originalCommit": "653a0eb3796781854acea4ebab2cf5e2b5b9370d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY0MDMzMw==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r516640333", "bodyText": "Unfortunately ImmutableMap.of has a limit of 5 keys so forced to use this", "author": "michaelpro1", "createdAt": "2020-11-03T12:47:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyOTA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE0Njc2NQ==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r518146765", "bodyText": "You could use ImmutableMap.builder().", "author": "boulter", "createdAt": "2020-11-05T15:37:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyOTA0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU3ODg1Mw==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r518578853", "bodyText": "Done", "author": "michaelpro1", "createdAt": "2020-11-06T07:58:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAyOTA0Mw=="}], "type": "inlineReview"}, {"oid": "9bfd056c84fcb7499e73bf8fad12fb674b73e887", "url": "https://github.com/HubSpot/jinjava/commit/9bfd056c84fcb7499e73bf8fad12fb674b73e887", "message": "review comments", "committedDate": "2020-11-03T12:39:13Z", "type": "commit"}, {"oid": "aaca4d49973d300baf593819ab4dc32b3fab80de", "url": "https://github.com/HubSpot/jinjava/commit/aaca4d49973d300baf593819ab4dc32b3fab80de", "message": "cache for namedArguments and defaultValues", "committedDate": "2020-11-03T12:44:04Z", "type": "commit"}, {"oid": "615e3b1b480e6badb98346cfa6337bab4a0f40a1", "url": "https://github.com/HubSpot/jinjava/commit/615e3b1b480e6badb98346cfa6337bab4a0f40a1", "message": "forgot the static classifier for cache", "committedDate": "2020-11-03T13:02:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE1MjIyMQ==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r518152221", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             Copyright (c) 2014 HubSpot Inc.\n          \n          \n            \n             Copyright (c) 2020 HubSpot Inc.", "author": "boulter", "createdAt": "2020-11-05T15:44:20Z", "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.", "originalCommit": "615e3b1b480e6badb98346cfa6337bab4a0f40a1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE1NzAwMQ==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r518157001", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  Map<String, JinjavaParam> namedArgs = new LinkedHashMap<>();\n          \n          \n            \n                  for (JinjavaParam jinjavaParam : jinjavaDoc.params()) {\n          \n          \n            \n                    namedArgs.put(jinjavaParam.value(), jinjavaParam);\n          \n          \n            \n                  }\n          \n          \n            \n                  return Collections.unmodifiableMap(namedArgs);\n          \n          \n            \n            return jinjavaDoc.params().stream().collect(ImmutableMap.toImmutableMap(p -> p.value(), p -> p));", "author": "boulter", "createdAt": "2020-11-05T15:50:25Z", "path": "src/main/java/com/hubspot/jinjava/lib/filter/AbstractFilter.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/**********************************************************************\n+ Copyright (c) 2014 HubSpot Inc.\n+\n+ Licensed under the Apache License, Version 2.0 (the \"License\");\n+ you may not use this file except in compliance with the License.\n+ You may obtain a copy of the License at\n+\n+ http://www.apache.org/licenses/LICENSE-2.0\n+\n+ Unless required by applicable law or agreed to in writing, software\n+ distributed under the License is distributed on an \"AS IS\" BASIS,\n+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ See the License for the specific language governing permissions and\n+ limitations under the License.\n+ **********************************************************************/\n+package com.hubspot.jinjava.lib.filter;\n+\n+import com.hubspot.jinjava.doc.annotations.JinjavaDoc;\n+import com.hubspot.jinjava.doc.annotations.JinjavaParam;\n+import com.hubspot.jinjava.interpret.InvalidInputException;\n+import com.hubspot.jinjava.interpret.JinjavaInterpreter;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.NotImplementedException;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.math.NumberUtils;\n+\n+/***\n+ * Filter base that uses Filter Jinjavadoc to construct named argument parameters.\n+ * Only filters that specify name, type and defaults correctly should use this as a base\n+ *\n+ * @see JinjavaDoc\n+ * @see JinjavaParam\n+ */\n+public abstract class AbstractFilter implements Filter {\n+  private static final Map<Class, Map<String, JinjavaParam>> NAMED_ARGUMENTS_CACHE = new ConcurrentHashMap<>();\n+  private static final Map<Class, Map<String, Object>> DEFAULT_VALUES_CACHE = new ConcurrentHashMap<>();\n+\n+  private final Map<String, JinjavaParam> namedArguments;\n+  private final Map<String, Object> defaultValues;\n+\n+  public AbstractFilter() {\n+    namedArguments =\n+      NAMED_ARGUMENTS_CACHE.computeIfAbsent(getClass(), cls -> initNamedArguments());\n+    defaultValues =\n+      DEFAULT_VALUES_CACHE.computeIfAbsent(getClass(), cls -> initDefaultValues());\n+  }\n+\n+  abstract Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  );\n+\n+  public Object filter(Object var, JinjavaInterpreter interpreter, String... args) {\n+    throw new NotImplementedException(\"Not implemented\");\n+  }\n+\n+  public Object filter(\n+    Object var,\n+    JinjavaInterpreter interpreter,\n+    Object[] args,\n+    Map<String, Object> kwargs\n+  ) {\n+    Map<String, Object> namedArgs = new HashMap<>();\n+    //Set defaults\n+    namedArgs.putAll(defaultValues);\n+\n+    //Process named params\n+    for (Map.Entry<String, Object> passedNamedArgEntry : kwargs.entrySet()) {\n+      String argName = passedNamedArgEntry.getKey();\n+      Object argValue = passedNamedArgEntry.getValue();\n+      int argPosition = getNamedArgumentPosition(argName);\n+      if (argPosition == -1) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\n+            \"Argument named '%s' is invalid for filter %s\",\n+            argName,\n+            getName()\n+          )\n+        );\n+      }\n+      namedArgs.put(argName, argValue);\n+    }\n+\n+    //Process indexed params, as declared\n+    for (int i = 0; i < args.length; i++) {\n+      Object arg = args[i];\n+      String argName = getIndexedArgumentName(i);\n+      if (argName == null) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\"Argument at index '%s' is invalid for filter %s\", i, getName())\n+        );\n+      }\n+      namedArgs.put(argName, arg);\n+    }\n+\n+    //Parse args based on their declared types\n+    Map<String, Object> parsedArgs = new HashMap<>();\n+    namedArgs.forEach(\n+      (k, v) -> parsedArgs.put(k, parseArg(interpreter, namedArguments.get(k), v))\n+    );\n+\n+    validateArgs(interpreter, parsedArgs);\n+\n+    return filter(var, interpreter, parsedArgs);\n+  }\n+\n+  protected Object parseArg(\n+    JinjavaInterpreter interpreter,\n+    JinjavaParam jinjavaParamMetadata,\n+    Object value\n+  ) {\n+    if (\n+      jinjavaParamMetadata.type() == null ||\n+      value == null ||\n+      Arrays.asList(\"object\", \"dict\", \"sequence\").contains(jinjavaParamMetadata.type())\n+    ) {\n+      return value;\n+    }\n+    String valueString = Objects.toString(value, null);\n+    switch (jinjavaParamMetadata.type().toLowerCase()) {\n+      case \"boolean\":\n+        return value instanceof Boolean\n+          ? (Boolean) value\n+          : BooleanUtils.toBooleanObject(valueString);\n+      case \"int\":\n+        return value instanceof Integer\n+          ? (Integer) value\n+          : NumberUtils.toInt(valueString);\n+      case \"long\":\n+        return value instanceof Long ? (Long) value : NumberUtils.toLong(valueString);\n+      case \"float\":\n+        return value instanceof Float ? (Float) value : NumberUtils.toFloat(valueString);\n+      case \"double\":\n+        return value instanceof Double\n+          ? (Double) value\n+          : NumberUtils.toDouble(valueString);\n+      case \"number\":\n+        return value instanceof Number ? (Number) value : new BigDecimal(valueString);\n+      case \"string\":\n+        return valueString;\n+      default:\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"INVALID_ARG_NAME\",\n+          String.format(\n+            \"Argument named '%s' with value '%s' cannot be parsed for filter %s\",\n+            jinjavaParamMetadata.value(),\n+            value,\n+            getName()\n+          )\n+        );\n+    }\n+  }\n+\n+  public void validateArgs(\n+    JinjavaInterpreter interpreter,\n+    Map<String, Object> parsedArgs\n+  ) {\n+    for (JinjavaParam jinjavaParam : namedArguments.values()) {\n+      if (jinjavaParam.required() && !parsedArgs.containsKey(jinjavaParam.value())) {\n+        throw new InvalidInputException(\n+          interpreter,\n+          \"MISSING_REQUIRED_ARG\",\n+          String.format(\n+            \"Argument named '%s' is required but missing for filter %s\",\n+            jinjavaParam.value(),\n+            getName()\n+          )\n+        );\n+      }\n+    }\n+  }\n+\n+  public int getNamedArgumentPosition(String argName) {\n+    return Optional\n+      .ofNullable(namedArguments)\n+      .map(Map::keySet)\n+      .map(ArrayList::new)\n+      .flatMap(argNames -> Optional.of(argNames.indexOf(argName)))\n+      .orElse(-1);\n+  }\n+\n+  public String getIndexedArgumentName(int position) {\n+    return Optional\n+      .ofNullable(namedArguments)\n+      .map(Map::keySet)\n+      .map(ArrayList::new)\n+      .flatMap(\n+        argNames ->\n+          Optional.ofNullable(argNames.size() > position ? argNames.get(position) : null)\n+      )\n+      .orElse(null);\n+  }\n+\n+  public Map<String, JinjavaParam> initNamedArguments() {\n+    JinjavaDoc jinjavaDoc = this.getClass().getAnnotation(JinjavaDoc.class);\n+    if (jinjavaDoc != null) {\n+      Map<String, JinjavaParam> namedArgs = new LinkedHashMap<>();\n+      for (JinjavaParam jinjavaParam : jinjavaDoc.params()) {\n+        namedArgs.put(jinjavaParam.value(), jinjavaParam);\n+      }\n+      return Collections.unmodifiableMap(namedArgs);", "originalCommit": "615e3b1b480e6badb98346cfa6337bab4a0f40a1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE1OTEzOA==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r518159138", "bodyText": "Note that this won't preserve the order though. If you do need that, you could collect to a LinkedHashMap and then wrap the whole thing in Collections.unmodifiableMap", "author": "boulter", "createdAt": "2020-11-05T15:53:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE1NzAwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODU4MjI0NA==", "url": "https://github.com/HubSpot/jinjava/pull/523#discussion_r518582244", "bodyText": "The order is important, just to be sure I used forEachOrdered with Builder. Default behaviour of ImmutableMap appears to be order of insertion\nBy default, a Builder will generate maps that iterate over entries in the order they were inserted into the builder, equivalently to LinkedHashMap.\n[https://guava.dev/releases/23.0/api/docs/com/google/common/collect/ImmutableMap.Builder.html]", "author": "michaelpro1", "createdAt": "2020-11-06T08:05:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE1NzAwMQ=="}], "type": "inlineReview"}, {"oid": "469907f7a9a1bee72849fb370beb63148b2dee7d", "url": "https://github.com/HubSpot/jinjava/commit/469907f7a9a1bee72849fb370beb63148b2dee7d", "message": "further review comments re: immutablemap. implement the AbstractFilter.filter(varargs) for backward compatibility", "committedDate": "2020-11-06T07:57:54Z", "type": "commit"}, {"oid": "ad437f9caaface26f214dfd708ccfe6c3144a3a5", "url": "https://github.com/HubSpot/jinjava/commit/ad437f9caaface26f214dfd708ccfe6c3144a3a5", "message": "missed the toImmutableMap comment", "committedDate": "2020-11-06T08:04:39Z", "type": "commit"}, {"oid": "ab42f2263e1070ac7847ae9970f5685b3136ec28", "url": "https://github.com/HubSpot/jinjava/commit/ab42f2263e1070ac7847ae9970f5685b3136ec28", "message": "remove newline", "committedDate": "2020-11-09T15:25:23Z", "type": "commit"}]}