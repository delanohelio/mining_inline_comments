{"pr_number": 9315, "pr_title": "fix!: Store in-memory filtering and sorting in component", "pr_createdAt": "2020-11-04T13:32:49Z", "pr_url": "https://github.com/vaadin/flow/pull/9315", "timeline": [{"oid": "ade1aca326ebbf0c8dece55d1aae4963e4840096", "url": "https://github.com/vaadin/flow/commit/ade1aca326ebbf0c8dece55d1aae4963e4840096", "message": "fix: Store in-memory filtering and sorting in component\n\nIn-memory filtering and sorting are now stored directly in component, which gives an opportunity to change it through the data view API for a certain component separately from other components bound to the same data provider.\n\nFixes: https://github.com/vaadin/flow/issues/8655", "committedDate": "2020-11-04T13:31:18Z", "type": "commit"}, {"oid": "a8bd42f843dad7fe20f90b83fd1cf1d51d5b1de2", "url": "https://github.com/vaadin/flow/commit/a8bd42f843dad7fe20f90b83fd1cf1d51d5b1de2", "message": "Remove filtering and sorting in DC, add unit tests", "committedDate": "2020-11-04T19:33:32Z", "type": "commit"}, {"oid": "2ec6ef42790fce5a250f3bc59256cce58589a90c", "url": "https://github.com/vaadin/flow/commit/2ec6ef42790fce5a250f3bc59256cce58589a90c", "message": "Fix data communicator tests", "committedDate": "2020-11-05T07:39:33Z", "type": "commit"}, {"oid": "cc14a01dc8da06d4a662ba71676297a2826aaeb4", "url": "https://github.com/vaadin/flow/commit/cc14a01dc8da06d4a662ba71676297a2826aaeb4", "message": "Remove erroneous component presence assertion and revert changes in tests", "committedDate": "2020-11-05T08:31:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY0Mjc3MA==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r519642770", "bodyText": "From glance I don't get what does filteringOnly mean and seems off.\nAfter reading the code, I would think that withSorting or includeSorting or similar would be better in this case, as \"filtering only\" is like double negation when it only applies to sorting.", "author": "pleku", "createdAt": "2020-11-09T08:53:44Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -380,4 +411,34 @@ private void addItemCollectionOnTarget(Collection<T> items, T target,\n         itemList.addAll(indexToInsertItems, items);\n         dataProvider.refreshAll();\n     }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    private Query getQuery(boolean filteringOnly) {", "originalCommit": "cc14a01dc8da06d4a662ba71676297a2826aaeb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTcyMzMyMw==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r519723323", "bodyText": "Yes, withSorting  is much more clear.", "author": "mshabarov", "createdAt": "2020-11-09T11:01:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY0Mjc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY1MDM1Mg==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r519650352", "bodyText": "Why is this class needed ? For storing the filter with certain key to component data ?\nIs it necessary that it is public ?", "author": "pleku", "createdAt": "2020-11-09T09:06:18Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/ComponentInMemoryFilter.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.vaadin.flow.data.provider;\n+\n+import java.io.Serializable;\n+\n+import com.vaadin.flow.function.SerializablePredicate;\n+\n+/**\n+ * Stores the component's specific in-memory filter.\n+ * \n+ * @param <T>\n+ *            component's items type\n+ */\n+public class ComponentInMemoryFilter<T> implements Serializable {", "originalCommit": "cc14a01dc8da06d4a662ba71676297a2826aaeb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTc4MDIzNw==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r519780237", "bodyText": "Yes, this is for storing the filter object in the component. I was considering to use a string key like this\nComponentUtil.setData(component, ListDataView.IN_MEMORY_FILTER_KEY,  filter);\nbut adding a public string to ListDataView seems even worse maybe, because it is still public and it modifies the public interface. This key should be visible in both AbstractListDataView and in the Component (Component needs to restore this object internally in some places), so I am not able to find out the better approach than to make it just public.", "author": "mshabarov", "createdAt": "2020-11-09T12:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY1MDM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTc4NDIzOQ==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r519784239", "bodyText": "If it were hidden to a protected method for the abstract data view, then it would be possible to access it in a component that creates the data view. If it was package protected, then the data communicator could access it. So package-protected static method in the AbstractListDataView ? I would not expose two new public classes just as mostly internal markers for storing data.", "author": "pleku", "createdAt": "2020-11-09T12:53:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY1MDM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgxNTI1Nw==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r519815257", "bodyText": "Yeah, good idea! So I will add protected static final String ...KEY = \"...key\"; to AbstractListDataView and then override it in component-specific data views, for instance, in ComboBoxListDataView, with a public modifier, and then just use in in ComboBox - ComboBoxListDataView.KEY and in data communicator - AbstractListDataView.KEY.\nSound good!", "author": "mshabarov", "createdAt": "2020-11-09T13:30:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY1MDM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgxNzUxNg==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r519817516", "bodyText": "Yeah, good idea! So I will add protected static final String ...KEY = \"...key\"; to AbstractListDataView and then override it in component-specific data views, for instance, in ComboBoxListDataView, with a public modifier, and then just use in in ComboBox - ComboBoxListDataView.KEY and in data communicator - AbstractListDataView.KEY.\nSound good!\n\nSorry, I'm not sure I understand this. Why do you need to expose or override keys ? If you just create package protected static getter & setter method in  AbstractListDataView that takes in component and optionally the filter OR sorting. Why would a component specific key be needed ????", "author": "pleku", "createdAt": "2020-11-09T13:34:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY1MDM1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgyODk1Nw==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r519828957", "bodyText": "Right, the component and data communicator will just use those static setter and getter. And the string key will be hidden in the AbstractListDataView. Sorry for confusing.", "author": "mshabarov", "createdAt": "2020-11-09T13:52:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY1MDM1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY1MDcyNQ==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r519650725", "bodyText": "Why is this class needed ? For storing the comparator in component data ?\nIs it necessary that it is public ?", "author": "pleku", "createdAt": "2020-11-09T09:06:54Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/ComponentSorting.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.vaadin.flow.data.provider;\n+\n+import java.io.Serializable;\n+\n+import com.vaadin.flow.function.SerializableComparator;\n+\n+/**\n+ * Stores the component's specific sorting.\n+ * \n+ * @param <T>\n+ *            component's items type\n+ */\n+public class ComponentSorting<T> implements Serializable {", "originalCommit": "cc14a01dc8da06d4a662ba71676297a2826aaeb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTc4MDg5OA==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r519780898", "bodyText": "The same comment as for filter.", "author": "mshabarov", "createdAt": "2020-11-09T12:47:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY1MDcyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY2NjU3OQ==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r519666579", "bodyText": "Should there be a test that checks case that setting a list data provider filter is applied correctly (doesn't discard data view filter) and that it is combined with the data view one ? Probably for sorting too ?", "author": "pleku", "createdAt": "2020-11-09T09:32:08Z", "path": "flow-data/src/test/java/com/vaadin/flow/data/provider/AbstractListDataViewTest.java", "diffHunk": "@@ -948,6 +952,174 @@ public void createListDataProviderFromArrayOfItems_removingOneItem_itemCountShou\n         Assert.assertEquals(itemCount - 1, listDataView.getItemCount());\n     }\n \n+    @Test\n+    public void setFilter_twoComponentsHasSameDataProvider_onlyTargetComponentImpacted() {\n+        TestComponent component1 = new TestComponent();\n+        TestComponent component2 = new TestComponent();\n+\n+        ListDataViewImpl listDataView1 = new ListDataViewImpl(\n+                () -> dataProvider, component1);\n+\n+        ListDataViewImpl listDataView2 = new ListDataViewImpl(\n+                () -> dataProvider, component2);\n+\n+        Assert.assertEquals(\"Unexpected initial items count for component #1\",\n+                3, listDataView1.getItemCount());\n+\n+        Assert.assertEquals(\"Unexpected initial items count for component #2\",\n+                3, listDataView2.getItemCount());\n+\n+        listDataView1.setFilter(\n+                item -> \"middle\".equals(item) || \"last\".equals(item));\n+\n+        Assert.assertEquals(\n+                \"Unexpected component #1 items count after filter apply\", 2,\n+                listDataView1.getItemCount());\n+\n+        Assert.assertEquals(\n+                \"Unexpected component #2 items count after filter apply to component #1\",\n+                3, listDataView2.getItemCount());\n+\n+        Assert.assertArrayEquals(\"Unexpected items after filter apply\",\n+                new String[] { \"middle\", \"last\" },\n+                listDataView1.getItems().toArray());\n+\n+        Assert.assertArrayEquals(\"Unexpected items after filter apply\",\n+                new String[] { \"first\", \"middle\", \"last\" },\n+                listDataView2.getItems().toArray());\n+\n+        listDataView1.addFilter(\"middle\"::equals);\n+\n+        Assert.assertEquals(\n+                \"Unexpected component #1 items count after filter apply\", 1,\n+                listDataView1.getItemCount());\n+\n+        Assert.assertEquals(\n+                \"Unexpected component #2 items count after filter apply to component #1\",\n+                3, listDataView2.getItemCount());\n+\n+        Assert.assertArrayEquals(\"Unexpected items after filter apply\",\n+                new String[] { \"middle\" }, listDataView1.getItems().toArray());\n+\n+        Assert.assertArrayEquals(\"Unexpected items after filter apply\",\n+                new String[] { \"first\", \"middle\", \"last\" },\n+                listDataView2.getItems().toArray());\n+\n+        listDataView1.removeFilters();\n+\n+        Assert.assertEquals(\n+                \"Unexpected component #1 items count after filter remove\", 3,\n+                listDataView1.getItemCount());\n+\n+        Assert.assertEquals(\n+                \"Unexpected component #2 items count after filter remove in component #1\",\n+                3, listDataView2.getItemCount());\n+\n+        Assert.assertArrayEquals(\"Unexpected items after filter remove\",\n+                new String[] { \"first\", \"middle\", \"last\" },\n+                listDataView1.getItems().toArray());\n+\n+        Assert.assertArrayEquals(\"Unexpected items after filter remove\",\n+                new String[] { \"first\", \"middle\", \"last\" },\n+                listDataView2.getItems().toArray());\n+    }\n+\n+    @Test\n+    public void setSortComparator_twoComponentsHasSameDataProvider_onlyTargetComponentImpacted() {\n+        TestComponent component1 = new TestComponent();\n+        TestComponent component2 = new TestComponent();\n+\n+        ListDataProvider<Item> dataProvider = DataProvider.ofItems(\n+                new Item(1L, \"baz\"), new Item(2L, \"foo\"), new Item(1L, \"bar\"));\n+\n+        ItemListDataView listDataView1 = new ItemListDataView(\n+                () -> dataProvider, component1);\n+\n+        ItemListDataView listDataView2 = new ItemListDataView(\n+                () -> dataProvider, component2);\n+\n+        listDataView1.setSortComparator(\n+                (item1, item2) -> Long.compare(item1.getId(), item2.getId()));\n+\n+        Assert.assertArrayEquals(\"Unexpected items sorting for component #1\",\n+                new Long[] { 1L, 1L, 2L },\n+                listDataView1.getItems().map(Item::getId).toArray());\n+\n+        Assert.assertArrayEquals(\"Unexpected items sorting for component #2\",\n+                new Long[] { 1L, 2L, 1L },\n+                listDataView2.getItems().map(Item::getId).toArray());\n+\n+        listDataView1.addSortComparator((item1, item2) -> item1.getValue()\n+                .compareToIgnoreCase(item2.getValue()));\n+\n+        Assert.assertArrayEquals(\"Unexpected items sorting for component #1\",\n+                new String[] { \"bar\", \"baz\", \"foo\" },\n+                listDataView1.getItems().map(Item::getValue).toArray());\n+\n+        Assert.assertArrayEquals(\"Unexpected items sorting for component #2\",\n+                new String[] { \"baz\", \"foo\", \"bar\" },\n+                listDataView2.getItems().map(Item::getValue).toArray());\n+\n+        listDataView1.removeSorting();\n+\n+        Assert.assertArrayEquals(\"Unexpected items sorting for component #1\",\n+                new Item[] { new Item(1L, \"baz\"), new Item(2L, \"foo\"),\n+                        new Item(1L, \"bar\") },\n+                listDataView1.getItems().toArray());\n+\n+        Assert.assertArrayEquals(\"Unexpected items sorting for component #2\",\n+                new Item[] { new Item(1L, \"baz\"), new Item(2L, \"foo\"),\n+                        new Item(1L, \"bar\") },\n+                listDataView2.getItems().toArray());\n+    }\n+\n+    @Test\n+    public void setSortOrder_twoComponentsHasSameDataProvider_onlyTargetComponentImpacted() {\n+        TestComponent component1 = new TestComponent();\n+        TestComponent component2 = new TestComponent();\n+\n+        ListDataProvider<Item> dataProvider = DataProvider.ofItems(\n+                new Item(1L, \"baz\"), new Item(2L, \"foo\"), new Item(1L, \"bar\"));\n+\n+        ItemListDataView listDataView1 = new ItemListDataView(\n+                () -> dataProvider, component1);\n+\n+        ItemListDataView listDataView2 = new ItemListDataView(\n+                () -> dataProvider, component2);\n+\n+        listDataView1.setSortOrder(Item::getId, SortDirection.ASCENDING);\n+\n+        Assert.assertArrayEquals(\"Unexpected items sorting for component #1\",\n+                new Long[] { 1L, 1L, 2L },\n+                listDataView1.getItems().map(Item::getId).toArray());\n+\n+        Assert.assertArrayEquals(\"Unexpected items sorting for component #2\",\n+                new Long[] { 1L, 2L, 1L },\n+                listDataView2.getItems().map(Item::getId).toArray());\n+\n+        listDataView1.addSortOrder(Item::getValue, SortDirection.ASCENDING);\n+\n+        Assert.assertArrayEquals(\"Unexpected items sorting for component #1\",\n+                new String[] { \"bar\", \"baz\", \"foo\" },\n+                listDataView1.getItems().map(Item::getValue).toArray());\n+\n+        Assert.assertArrayEquals(\"Unexpected items sorting for component #2\",\n+                new String[] { \"baz\", \"foo\", \"bar\" },\n+                listDataView2.getItems().map(Item::getValue).toArray());\n+\n+        listDataView1.removeSorting();\n+\n+        Assert.assertArrayEquals(\"Unexpected items sorting for component #1\",\n+                new Item[] { new Item(1L, \"baz\"), new Item(2L, \"foo\"),\n+                        new Item(1L, \"bar\") },\n+                listDataView1.getItems().toArray());\n+\n+        Assert.assertArrayEquals(\"Unexpected items sorting for component #2\",\n+                new Item[] { new Item(1L, \"baz\"), new Item(2L, \"foo\"),\n+                        new Item(1L, \"bar\") },\n+                listDataView2.getItems().toArray());\n+    }\n+", "originalCommit": "cc14a01dc8da06d4a662ba71676297a2826aaeb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTc4MTQzMg==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r519781432", "bodyText": "Yeah, good point! I will add such a test!", "author": "mshabarov", "createdAt": "2020-11-09T12:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY2NjU3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY2NzU4Mw==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r519667583", "bodyText": "So how is this working when none of the components react to this event ? Why not fire the DataChangeEvent instead ?", "author": "pleku", "createdAt": "2020-11-09T09:33:53Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -380,4 +411,34 @@ private void addItemCollectionOnTarget(Collection<T> items, T target,\n         itemList.addAll(indexToInsertItems, items);\n         dataProvider.refreshAll();\n     }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    private Query getQuery(boolean filteringOnly) {\n+        final Optional<ComponentInMemoryFilter<T>> filter = getComponentInMemoryFilter();\n+\n+        final Optional<ComponentSorting<T>> sorting = filteringOnly\n+                ? Optional.empty()\n+                : getComponentSorting();\n+\n+        return new Query(0, Integer.MAX_VALUE, null,\n+                sorting.map(ComponentSorting::getSortComparator).orElse(null),\n+                filter.map(ComponentInMemoryFilter::getFilter).orElse(null));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Optional<ComponentSorting<T>> getComponentSorting() {\n+        return Optional.ofNullable(\n+                ComponentUtil.getData(component, ComponentSorting.class));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Optional<ComponentInMemoryFilter<T>> getComponentInMemoryFilter() {\n+        return Optional.ofNullable(ComponentUtil.getData(component,\n+                ComponentInMemoryFilter.class));\n+    }\n+\n+    private void fireDataChangeEvent() {\n+        ComponentUtil.fireEvent(component,\n+                new ComponentDataChangeEvent<>(component));", "originalCommit": "cc14a01dc8da06d4a662ba71676297a2826aaeb4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTc5OTExMg==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r519799112", "bodyText": "So how is this working when none of the components react to this event ?\n\nI assumed that the components have to add a listener by themselves and to restore the filter/sorting by themselves. I avoided using a callback for notifying the components because it would be a breaking change for list data view abstract class.\n\nWhy not fire the DataChangeEvent instead ?\n\nThere are tow obstacles to do that:\n\nDataChangeEvent  does not have a 'component' field, nor any other information to distinguish the target component. Adding such a filed means the breaking change in this class.\nIf we fire this event via data provider listener handler, then it would require the certain component mention in the public method -> breaking change. We're also not able to fire it via ComponentUtil.fireEvent because this event class does not extend ComponentEvent.", "author": "mshabarov", "createdAt": "2020-11-09T13:10:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY2NzU4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgxNDUxNA==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r519814514", "bodyText": "Adding such a filed means the breaking change in this class.\n\nI see, this doesn't matter, but I don't see how it is necessarily a breaking change with another constructor and exposing a new getter which might return null. There is new API added here anyway which makes it impossible to backport anyway. I don't know if it is really worth it to introduce dubious new API just for avoiding breaking something that we introduced in version 4.0 and can now change for 5.0.\nBut as to an alternative, I don't know either how the data provider could even distinguish the correct component to fire the data change event on. But it feels somehow bad API design to me as a component developer that if I have to know and remember to do something extra when using AbstractListDataView instead of being required to do it implicitly in the constructor. Basically I could easily miss adding the listener to this event ^ and then my component would not work when filters & sorting changes.\nSo either\n\nmake the data provider fire the event for all components with the optional meta data of Component getDataChangeComponent() (better name would be nice) and then our components & data communicator (?) can ignore the events where the component is something different than itself.\nforce components using abstractlistdataview to always pass a callback for reacting to filter/sorting change\nsomething else, ?", "author": "pleku", "createdAt": "2020-11-09T13:29:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY2NzU4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgzNTk3Mg==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r519835972", "bodyText": "But it feels somehow bad API design to me as a component developer that if I have to know and remember to do something extra when using AbstractListDataView instead of being required to do it implicitly in the constructor.\n\nAgree! I would go with option 2 then, because it guarantee that the custom component won't forget to handle these filtering/sorting events.", "author": "mshabarov", "createdAt": "2020-11-09T14:02:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY2NzU4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTgzOTA5NA==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r519839094", "bodyText": "it guarantee that the custom component won't forget to handle these filtering/sorting events.\n\nI don't think it guarantees it per se, as existing components often can forget to add those listener into their data providers.. but is maybe a better pattern. I wonder now why we didn't just expose an API in the HasItems or HasDataProvider  that would have been called by the data provider and even optionally the users to just tell the component to refresh the data for itself... I don't know what sense it made to require acquiring the data provider to refresh things. Probably just wrong design principles with too much emphasis on the data providers.", "author": "pleku", "createdAt": "2020-11-09T14:07:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxOTY2NzU4Mw=="}], "type": "inlineReview"}, {"oid": "3ac6f5cfb6122d37dc6e3e11209ec4d36807b81b", "url": "https://github.com/vaadin/flow/commit/3ac6f5cfb6122d37dc6e3e11209ec4d36807b81b", "message": "Remove redundant classes, add data change callback", "committedDate": "2020-11-09T20:17:29Z", "type": "commit"}, {"oid": "600581253bf56ec9740076c139f3372b2fd1fe5b", "url": "https://github.com/vaadin/flow/commit/600581253bf56ec9740076c139f3372b2fd1fe5b", "message": "Update list data view javadoc regards filtering and sorting", "committedDate": "2020-11-10T13:37:03Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMzODQ0NQ==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r521338445", "bodyText": "Nit: this method name should be something different but not blocking", "author": "pleku", "createdAt": "2020-11-11T12:55:00Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/AbstractListDataView.java", "diffHunk": "@@ -380,4 +488,22 @@ private void addItemCollectionOnTarget(Collection<T> items, T target,\n         itemList.addAll(indexToInsertItems, items);\n         dataProvider.refreshAll();\n     }\n+\n+    @SuppressWarnings({ \"unchecked\", \"rawtypes\" })\n+    private Query getQuery(boolean withSorting) {\n+        final Optional<SerializablePredicate<T>> filter = getComponentFilter(\n+                component);\n+\n+        final Optional<SerializableComparator<T>> sorting = withSorting\n+                ? getComponentSortComparator(component)\n+                : Optional.empty();\n+\n+        return new Query(0, Integer.MAX_VALUE, null,\n+                sorting.orElse(null), filter.orElse(null));\n+    }\n+\n+    private void fireDataChangeEvent(SerializablePredicate<T> filter,", "originalCommit": "600581253bf56ec9740076c139f3372b2fd1fe5b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg5MDAyMg==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r521890022", "bodyText": "Done", "author": "mshabarov", "createdAt": "2020-11-12T07:33:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTMzODQ0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0NzA3OQ==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r521347079", "bodyText": "A filter bound to the component.\n\nThis is a bit odd way of continuing the javadocs at this point... maybe\n\nThis filter is bound to the component.\n\nwould make it more natural.", "author": "pleku", "createdAt": "2020-11-11T13:10:38Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/ListDataView.java", "diffHunk": "@@ -266,11 +266,10 @@\n      * that has been set or added previously. {@code null} will clear all\n      * filters.\n      * <p>\n-     * A filter bound to data set, not to the component. That means this filter\n-     * won't be retained when a new data or {@link DataProvider} is set to the\n-     * component. Any other component using the same {@link DataProvider} object\n-     * would be affected by setting a filter through data view of another\n-     * component.\n+     * A filter bound to the component. Any other component using the same", "originalCommit": "600581253bf56ec9740076c139f3372b2fd1fe5b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg5MDExMA==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r521890110", "bodyText": "Done", "author": "mshabarov", "createdAt": "2020-11-12T07:33:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0NzA3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0NzIwMA==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r521347200", "bodyText": "The same as above", "author": "pleku", "createdAt": "2020-11-11T13:10:53Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/ListDataView.java", "diffHunk": "@@ -286,11 +285,10 @@\n      * Adds a filter to be applied to all queries. The filter will be used in\n      * addition to any filter that has been set or added previously.\n      * <p>\n-     * A filter bound to data set, not to the component. That means this filter\n-     * and previously added filters won't be retained when a new data or\n-     * {@link DataProvider} is set to the component. Any other component using\n-     * the same {@link DataProvider} object would be affected by adding a filter\n-     * through data view of another component.\n+     * A filter bound to the component. Any other component using the same", "originalCommit": "600581253bf56ec9740076c139f3372b2fd1fe5b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg5MDE0Mw==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r521890143", "bodyText": "Done", "author": "mshabarov", "createdAt": "2020-11-12T07:33:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0NzIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0NzQ5Ng==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r521347496", "bodyText": "The same as above, seem off. Maybe\n\nThis comparator is bound to the component. Thus any other...\n\nwould be better", "author": "pleku", "createdAt": "2020-11-11T13:11:22Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/ListDataView.java", "diffHunk": "@@ -315,11 +313,11 @@\n      * Sets the comparator to use as the default sorting. This overrides the\n      * sorting set by any other method that manipulates the default sorting.\n      * <p>\n-     * A comparator bound to data set, not to the component. That means the\n-     * default sorting won't be retained when a new data or {@link DataProvider}\n-     * is set to the component. Any other component using the same\n-     * {@link DataProvider} object would be affected by setting a sort\n-     * comparator through data view of another component.\n+     * A comparator bound to the component. Any other component using the same", "originalCommit": "600581253bf56ec9740076c139f3372b2fd1fe5b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg5MDE3Nw==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r521890177", "bodyText": "Done", "author": "mshabarov", "createdAt": "2020-11-12T07:33:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0NzQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0NzY5Nw==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r521347697", "bodyText": "Same as above", "author": "pleku", "createdAt": "2020-11-11T13:11:45Z", "path": "flow-data/src/main/java/com/vaadin/flow/data/provider/ListDataView.java", "diffHunk": "@@ -337,11 +335,11 @@\n      * comparator will be used to determine the ordering of items that are\n      * considered equal by the previously defined default sorting.\n      * <p>\n-     * A comparator added to data set, not to the component. That means the\n-     * default sorting won't be retained when a new data or {@link DataProvider}\n-     * is set to the component. Any other component using the same\n-     * {@link DataProvider} object would be affected by adding a sort comparator\n-     * through data view of another component.\n+     * A comparator bound to the component. Any other component using the same", "originalCommit": "600581253bf56ec9740076c139f3372b2fd1fe5b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg5MDIwNQ==", "url": "https://github.com/vaadin/flow/pull/9315#discussion_r521890205", "bodyText": "Done", "author": "mshabarov", "createdAt": "2020-11-12T07:33:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTM0NzY5Nw=="}], "type": "inlineReview"}, {"oid": "3fac591ef499bfd7e2c71db0206e764873a71c7b", "url": "https://github.com/vaadin/flow/commit/3fac591ef499bfd7e2c71db0206e764873a71c7b", "message": "Address the comments regards javadoc and method name", "committedDate": "2020-11-11T13:46:07Z", "type": "commit"}]}