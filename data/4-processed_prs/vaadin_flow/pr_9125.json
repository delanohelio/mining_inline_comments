{"pr_number": 9125, "pr_title": "Re-implement the EventHandlerRpcHandler", "pr_createdAt": "2020-10-06T19:18:34Z", "pr_url": "https://github.com/vaadin/flow/pull/9125", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU4MTUwOQ==", "url": "https://github.com/vaadin/flow/pull/9125#discussion_r500581509", "bodyText": "Remove this use of \"PolymerServerEventHandlers\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-10-06T20:39:13Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -58,28 +68,341 @@ public String getRpcType() {\n     @Override\n     public Optional<Runnable> handleNode(StateNode node,\n             JsonObject invocationJson) {\n+        assert invocationJson\n+                .hasKey(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        String methodName = invocationJson\n+                .getString(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\n+                    \"Event handler method name may not be null\");\n+        }\n+        JsonValue args = invocationJson\n+                .get(JsonConstants.RPC_TEMPLATE_EVENT_ARGS);\n+        if (args == null) {\n+            args = Json.createArray();\n+        }\n+        if (args.getType() != JsonType.ARRAY) {\n+            throw new IllegalArgumentException(\n+                    \"Incorrect type for method arguments: \" + args.getClass());\n+        }\n+        int promiseId;\n+        if (invocationJson.hasKey(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE)) {\n+            promiseId = (int) invocationJson\n+                    .getNumber(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE);\n+        } else {\n+            promiseId = -1;\n+        }\n+        assert node.hasFeature(ComponentMapping.class);\n+        Optional<Component> component = ComponentMapping.getComponent(node);\n+        if (!component.isPresent()) {\n+            throw new IllegalStateException(\n+                    \"Unable to handle RPC template event JSON message: \"\n+                            + \"there is no component available for the target node\");\n+        }\n+\n+        boolean execute = node.isEnabled();\n+\n+        if (!execute) {\n+            ClientCallableHandlers clientDelegate = node\n+                    .getFeature(ClientCallableHandlers.class);\n+            PolymerServerEventHandlers eventHandlers = node", "originalCommit": "a45bafb4dae67640175bcffdffd882dd252595aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU4MTUxNw==", "url": "https://github.com/vaadin/flow/pull/9125#discussion_r500581517", "bodyText": "Remove this use of \"PolymerServerEventHandlers\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-10-06T20:39:14Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -58,28 +68,341 @@ public String getRpcType() {\n     @Override\n     public Optional<Runnable> handleNode(StateNode node,\n             JsonObject invocationJson) {\n+        assert invocationJson\n+                .hasKey(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        String methodName = invocationJson\n+                .getString(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\n+                    \"Event handler method name may not be null\");\n+        }\n+        JsonValue args = invocationJson\n+                .get(JsonConstants.RPC_TEMPLATE_EVENT_ARGS);\n+        if (args == null) {\n+            args = Json.createArray();\n+        }\n+        if (args.getType() != JsonType.ARRAY) {\n+            throw new IllegalArgumentException(\n+                    \"Incorrect type for method arguments: \" + args.getClass());\n+        }\n+        int promiseId;\n+        if (invocationJson.hasKey(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE)) {\n+            promiseId = (int) invocationJson\n+                    .getNumber(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE);\n+        } else {\n+            promiseId = -1;\n+        }\n+        assert node.hasFeature(ComponentMapping.class);\n+        Optional<Component> component = ComponentMapping.getComponent(node);\n+        if (!component.isPresent()) {\n+            throw new IllegalStateException(\n+                    \"Unable to handle RPC template event JSON message: \"\n+                            + \"there is no component available for the target node\");\n+        }\n+\n+        boolean execute = node.isEnabled();\n+\n+        if (!execute) {\n+            ClientCallableHandlers clientDelegate = node\n+                    .getFeature(ClientCallableHandlers.class);\n+            PolymerServerEventHandlers eventHandlers = node\n+                    .getFeature(PolymerServerEventHandlers.class);", "originalCommit": "a45bafb4dae67640175bcffdffd882dd252595aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU4MTU3Mg==", "url": "https://github.com/vaadin/flow/pull/9125#discussion_r500581572", "bodyText": "Replace this lambda with a method reference.", "author": "vaadin-bot", "createdAt": "2020-10-06T20:39:18Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -58,28 +68,341 @@ public String getRpcType() {\n     @Override\n     public Optional<Runnable> handleNode(StateNode node,\n             JsonObject invocationJson) {\n+        assert invocationJson\n+                .hasKey(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        String methodName = invocationJson\n+                .getString(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\n+                    \"Event handler method name may not be null\");\n+        }\n+        JsonValue args = invocationJson\n+                .get(JsonConstants.RPC_TEMPLATE_EVENT_ARGS);\n+        if (args == null) {\n+            args = Json.createArray();\n+        }\n+        if (args.getType() != JsonType.ARRAY) {\n+            throw new IllegalArgumentException(\n+                    \"Incorrect type for method arguments: \" + args.getClass());\n+        }\n+        int promiseId;\n+        if (invocationJson.hasKey(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE)) {\n+            promiseId = (int) invocationJson\n+                    .getNumber(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE);\n+        } else {\n+            promiseId = -1;\n+        }\n+        assert node.hasFeature(ComponentMapping.class);\n+        Optional<Component> component = ComponentMapping.getComponent(node);\n+        if (!component.isPresent()) {\n+            throw new IllegalStateException(\n+                    \"Unable to handle RPC template event JSON message: \"\n+                            + \"there is no component available for the target node\");\n+        }\n+\n+        boolean execute = node.isEnabled();\n+\n+        if (!execute) {\n+            ClientCallableHandlers clientDelegate = node\n+                    .getFeature(ClientCallableHandlers.class);\n+            PolymerServerEventHandlers eventHandlers = node\n+                    .getFeature(PolymerServerEventHandlers.class);\n+            if (clientDelegate.hasHandler(methodName)) {\n+                execute = DisabledUpdateMode.ALWAYS.equals(clientDelegate\n+                        .getDisabledUpdateMode(methodName));\n+            }\n+            if (eventHandlers.hasHandler(methodName)) {\n+                execute = execute || DisabledUpdateMode.ALWAYS\n+                        .equals(eventHandlers\n+                                .getDisabledUpdateMode(methodName));\n+            }\n+        }\n+\n+        if (execute) {\n+            invokeMethod(component.get(), component.get().getClass(),\n+                    methodName, (JsonArray) args, promiseId);\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    static void invokeMethod(Component instance, Class<?> clazz,\n+            String methodName, JsonArray args, int promiseId) {\n+        assert instance != null;\n+        Optional<Method> method = findMethod(instance, clazz, methodName);\n+        if (method.isPresent()) {\n+            invokeMethod(instance, method.get(), args, promiseId);\n+        } else if (instance instanceof Composite) {\n+            Component compositeContent = ((Composite<?>) instance).getContent();\n+            invokeMethod(compositeContent, compositeContent.getClass(),\n+                    methodName, args, promiseId);\n+        } else {\n+            String msg = String.format(\"Neither class '%s' \"\n+                            + \"nor its super classes declare event handler method '%s'\",\n+                    instance.getClass().getName(), methodName);\n+            throw new IllegalStateException(msg);\n+        }\n+    }\n+\n+    private static Optional<Method> findMethod(Component instance,\n+            Class<?> clazz, String methodName) {\n+        List<Method> methods = Stream.of(clazz.getDeclaredMethods())\n+                .filter(method -> methodName.equals(method.getName()))\n+                .filter(method -> hasMethodAnnotation(method))", "originalCommit": "a45bafb4dae67640175bcffdffd882dd252595aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU4MTYwMg==", "url": "https://github.com/vaadin/flow/pull/9125#discussion_r500581602", "bodyText": "Remove this use of \"PolymerTemplate\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-10-06T20:39:23Z", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PublishedEventRpcHandlerUtil.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Type;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.component.polymertemplate.PolymerTemplate;\n+import com.vaadin.flow.internal.StateNode;\n+import com.vaadin.flow.templatemodel.ModelType;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Polymer utilitiy class for handling polymer rpc events for @EventHandler.\n+ *\n+ * @since\n+ */\n+public class PublishedEventRpcHandlerUtil implements Serializable {\n+\n+    /**\n+     * Validate that the given Component instance is a PolymerTemplate and that\n+     * the value can be converted.\n+     *\n+     * @param instance\n+     *         Component to be validated\n+     * @param argValue\n+     *         received value\n+     * @param convertedType\n+     *         taget type that value sould be converted to\n+     * @return true if valid template model value\n+     */\n+    public static boolean isTemplateModelValue(Component instance,\n+            JsonValue argValue, Class<?> convertedType) {\n+        return instance instanceof PolymerTemplate", "originalCommit": "a45bafb4dae67640175bcffdffd882dd252595aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDU4MTYwNA==", "url": "https://github.com/vaadin/flow/pull/9125#discussion_r500581604", "bodyText": "Remove this use of \"PolymerTemplate\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-10-06T20:39:23Z", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PublishedEventRpcHandlerUtil.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Type;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.component.polymertemplate.PolymerTemplate;\n+import com.vaadin.flow.internal.StateNode;\n+import com.vaadin.flow.templatemodel.ModelType;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Polymer utilitiy class for handling polymer rpc events for @EventHandler.\n+ *\n+ * @since\n+ */\n+public class PublishedEventRpcHandlerUtil implements Serializable {\n+\n+    /**\n+     * Validate that the given Component instance is a PolymerTemplate and that\n+     * the value can be converted.\n+     *\n+     * @param instance\n+     *         Component to be validated\n+     * @param argValue\n+     *         received value\n+     * @param convertedType\n+     *         taget type that value sould be converted to\n+     * @return true if valid template model value\n+     */\n+    public static boolean isTemplateModelValue(Component instance,\n+            JsonValue argValue, Class<?> convertedType) {\n+        return instance instanceof PolymerTemplate\n+                && argValue instanceof JsonObject\n+                && ((PolymerTemplate<?>) instance)", "originalCommit": "a45bafb4dae67640175bcffdffd882dd252595aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a302d5eae94b7ee87c5703194fa363d1b3c0ce4c", "url": "https://github.com/vaadin/flow/commit/a302d5eae94b7ee87c5703194fa363d1b3c0ce4c", "message": "Re-implement the EventHandlerRpcHandler\n\nEventHandlerRpcHandler handles the ClientCallable\nserver method and is thus not purely for polymer.\nThe hanlder was returned and tests were parted\nbetween polymer (EventHandler) and server (ClientCallable)\n\nFixed tests to be more robust and also to work on Windows.\n\nCloses #9116", "committedDate": "2020-10-07T03:49:43Z", "type": "commit"}, {"oid": "a302d5eae94b7ee87c5703194fa363d1b3c0ce4c", "url": "https://github.com/vaadin/flow/commit/a302d5eae94b7ee87c5703194fa363d1b3c0ce4c", "message": "Re-implement the EventHandlerRpcHandler\n\nEventHandlerRpcHandler handles the ClientCallable\nserver method and is thus not purely for polymer.\nThe hanlder was returned and tests were parted\nbetween polymer (EventHandler) and server (ClientCallable)\n\nFixed tests to be more robust and also to work on Windows.\n\nCloses #9116", "committedDate": "2020-10-07T03:49:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc0NTA4MA==", "url": "https://github.com/vaadin/flow/pull/9125#discussion_r500745080", "bodyText": "This impl assumes that template is attached.\nThis should be explicitly checked via assertion e.g.", "author": "denis-anisimov", "createdAt": "2020-10-07T05:26:13Z", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PublishedEventRpcHandlerUtil.java", "diffHunk": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Type;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.component.polymertemplate.PolymerTemplate;\n+import com.vaadin.flow.internal.StateNode;\n+import com.vaadin.flow.templatemodel.ModelType;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Polymer utilitiy class for handling polymer rpc events for @EventHandler.\n+ *\n+ * @since\n+ */\n+public class PublishedEventRpcHandlerUtil implements Serializable {\n+\n+    /**\n+     * Validate that the given Component instance is a PolymerTemplate and that\n+     * the value can be converted.\n+     *\n+     * @param instance\n+     *         Component to be validated\n+     * @param argValue\n+     *         received value\n+     * @param convertedType\n+     *         taget type that value sould be converted to\n+     * @return true if valid template model value\n+     */\n+    public static boolean isTemplateModelValue(Component instance,\n+            JsonValue argValue, Class<?> convertedType) {\n+        return instance instanceof PolymerTemplate\n+                && argValue instanceof JsonObject\n+                && ((PolymerTemplate<?>) instance)\n+                .isSupportedClass(convertedType) && ((JsonObject) argValue)\n+                .hasKey(\"nodeId\");\n+    }\n+\n+    /**\n+     * Get the template model object and type.\n+     *\n+     * @param template\n+     *         polymer template to get model from\n+     * @param argValue\n+     *         argument value\n+     * @param convertedType\n+     *         value type\n+     * @return the provided model value\n+     */\n+    public static Object getTemplateItem(Component template,\n+            JsonObject argValue, Type convertedType) {\n+        StateNode node = template.getUI().get().getInternals().getStateTree()", "originalCommit": "a302d5eae94b7ee87c5703194fa363d1b3c0ce4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1OTAxOA==", "url": "https://github.com/vaadin/flow/pull/9125#discussion_r500759018", "bodyText": "Done. I'll have it throw as it is an exception state if the component is not attached as we shouldn't take in data from the client in that state.", "author": "caalador", "createdAt": "2020-10-07T06:10:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc0NTA4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc0NTkwMg==", "url": "https://github.com/vaadin/flow/pull/9125#discussion_r500745902", "bodyText": "There is a method hasAnnotation , no need to use getAnnotation.", "author": "denis-anisimov", "createdAt": "2020-10-07T05:29:24Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -58,28 +68,307 @@ public String getRpcType() {\n     @Override\n     public Optional<Runnable> handleNode(StateNode node,\n             JsonObject invocationJson) {\n+        assert invocationJson\n+                .hasKey(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        String methodName = invocationJson\n+                .getString(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\n+                    \"Event handler method name may not be null\");\n+        }\n+        JsonValue args = invocationJson\n+                .get(JsonConstants.RPC_TEMPLATE_EVENT_ARGS);\n+        if (args == null) {\n+            args = Json.createArray();\n+        }\n+        if (args.getType() != JsonType.ARRAY) {\n+            throw new IllegalArgumentException(\n+                    \"Incorrect type for method arguments: \" + args.getClass());\n+        }\n+        int promiseId;\n+        if (invocationJson.hasKey(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE)) {\n+            promiseId = (int) invocationJson\n+                    .getNumber(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE);\n+        } else {\n+            promiseId = -1;\n+        }\n+        assert node.hasFeature(ComponentMapping.class);\n+        Optional<Component> component = ComponentMapping.getComponent(node);\n+        if (!component.isPresent()) {\n+            throw new IllegalStateException(\n+                    \"Unable to handle RPC template event JSON message: \"\n+                            + \"there is no component available for the target node\");\n+        }\n+\n+        boolean execute = node.isEnabled();\n+\n+        if (!execute) {\n+            ClientCallableHandlers clientDelegate = node\n+                    .getFeature(ClientCallableHandlers.class);\n+            PolymerServerEventHandlers eventHandlers = node\n+                    .getFeature(PolymerServerEventHandlers.class);\n+            if (clientDelegate.hasHandler(methodName)) {\n+                execute = DisabledUpdateMode.ALWAYS.equals(clientDelegate\n+                        .getDisabledUpdateMode(methodName));\n+            }\n+            if (eventHandlers.hasHandler(methodName)) {\n+                execute = execute || DisabledUpdateMode.ALWAYS\n+                        .equals(eventHandlers\n+                                .getDisabledUpdateMode(methodName));\n+            }\n+        }\n+\n+        if (execute) {\n+            invokeMethod(component.get(), component.get().getClass(),\n+                    methodName, (JsonArray) args, promiseId);\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    static void invokeMethod(Component instance, Class<?> clazz,\n+            String methodName, JsonArray args, int promiseId) {\n+        assert instance != null;\n+        Optional<Method> method = findMethod(instance, clazz, methodName);\n+        if (method.isPresent()) {\n+            invokeMethod(instance, method.get(), args, promiseId);\n+        } else if (instance instanceof Composite) {\n+            Component compositeContent = ((Composite<?>) instance).getContent();\n+            invokeMethod(compositeContent, compositeContent.getClass(),\n+                    methodName, args, promiseId);\n+        } else {\n+            String msg = String.format(\"Neither class '%s' \"\n+                            + \"nor its super classes declare event handler method '%s'\",\n+                    instance.getClass().getName(), methodName);\n+            throw new IllegalStateException(msg);\n+        }\n+    }\n+\n+    private static Optional<Method> findMethod(Component instance,\n+            Class<?> clazz, String methodName) {\n+        List<Method> methods = Stream.of(clazz.getDeclaredMethods())\n+                .filter(method -> methodName.equals(method.getName()))\n+                .filter(method -> hasMethodAnnotation(method))\n+                .collect(Collectors.toList());\n+        if (methods.size() > 1) {\n+            String msg = String.format(\"Class '%s' contains \"\n+                            + \"several event handler method with the same name '%s'\",\n+                    instance.getClass().getName(), methodName);\n+            throw new IllegalStateException(msg);\n+        } else if (methods.size() == 1) {\n+            return Optional.of(methods.get(0));\n+        } else if (!Component.class.equals(clazz)) {\n+            return findMethod(instance, clazz.getSuperclass(), methodName);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private static boolean hasMethodAnnotation(Method method) {\n+        // Check for polymer event handler annotation.\n+        final Optional<Annotation> eventHandler = ReflectTools\n+                .getAnnotation(method,", "originalCommit": "a302d5eae94b7ee87c5703194fa363d1b3c0ce4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc1OTY1MA==", "url": "https://github.com/vaadin/flow/pull/9125#discussion_r500759650", "bodyText": "Thanks. I didn't notice that one.", "author": "caalador", "createdAt": "2020-10-07T06:12:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc0NTkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc0NzAwMA==", "url": "https://github.com/vaadin/flow/pull/9125#discussion_r500747000", "bodyText": "ClassNotFoundException  means there is no Polymer template in the classpath\nNoSuchMethodException  means there is a mistake in the impl since polymer IS in the classpath but the method name used here doesn't match any method name in the module. It means that the method is either renamed or removed and this code has to be rewritten.\nThe catch should distinguish this two cases and ignore one case silently (log is enough) and do something more serious in the second case. May be just throw ISE since this is a mistake in the impl.", "author": "denis-anisimov", "createdAt": "2020-10-07T05:33:32Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -58,28 +68,307 @@ public String getRpcType() {\n     @Override\n     public Optional<Runnable> handleNode(StateNode node,\n             JsonObject invocationJson) {\n+        assert invocationJson\n+                .hasKey(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        String methodName = invocationJson\n+                .getString(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\n+                    \"Event handler method name may not be null\");\n+        }\n+        JsonValue args = invocationJson\n+                .get(JsonConstants.RPC_TEMPLATE_EVENT_ARGS);\n+        if (args == null) {\n+            args = Json.createArray();\n+        }\n+        if (args.getType() != JsonType.ARRAY) {\n+            throw new IllegalArgumentException(\n+                    \"Incorrect type for method arguments: \" + args.getClass());\n+        }\n+        int promiseId;\n+        if (invocationJson.hasKey(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE)) {\n+            promiseId = (int) invocationJson\n+                    .getNumber(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE);\n+        } else {\n+            promiseId = -1;\n+        }\n+        assert node.hasFeature(ComponentMapping.class);\n+        Optional<Component> component = ComponentMapping.getComponent(node);\n+        if (!component.isPresent()) {\n+            throw new IllegalStateException(\n+                    \"Unable to handle RPC template event JSON message: \"\n+                            + \"there is no component available for the target node\");\n+        }\n+\n+        boolean execute = node.isEnabled();\n+\n+        if (!execute) {\n+            ClientCallableHandlers clientDelegate = node\n+                    .getFeature(ClientCallableHandlers.class);\n+            PolymerServerEventHandlers eventHandlers = node\n+                    .getFeature(PolymerServerEventHandlers.class);\n+            if (clientDelegate.hasHandler(methodName)) {\n+                execute = DisabledUpdateMode.ALWAYS.equals(clientDelegate\n+                        .getDisabledUpdateMode(methodName));\n+            }\n+            if (eventHandlers.hasHandler(methodName)) {\n+                execute = execute || DisabledUpdateMode.ALWAYS\n+                        .equals(eventHandlers\n+                                .getDisabledUpdateMode(methodName));\n+            }\n+        }\n+\n+        if (execute) {\n+            invokeMethod(component.get(), component.get().getClass(),\n+                    methodName, (JsonArray) args, promiseId);\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    static void invokeMethod(Component instance, Class<?> clazz,\n+            String methodName, JsonArray args, int promiseId) {\n+        assert instance != null;\n+        Optional<Method> method = findMethod(instance, clazz, methodName);\n+        if (method.isPresent()) {\n+            invokeMethod(instance, method.get(), args, promiseId);\n+        } else if (instance instanceof Composite) {\n+            Component compositeContent = ((Composite<?>) instance).getContent();\n+            invokeMethod(compositeContent, compositeContent.getClass(),\n+                    methodName, args, promiseId);\n+        } else {\n+            String msg = String.format(\"Neither class '%s' \"\n+                            + \"nor its super classes declare event handler method '%s'\",\n+                    instance.getClass().getName(), methodName);\n+            throw new IllegalStateException(msg);\n+        }\n+    }\n+\n+    private static Optional<Method> findMethod(Component instance,\n+            Class<?> clazz, String methodName) {\n+        List<Method> methods = Stream.of(clazz.getDeclaredMethods())\n+                .filter(method -> methodName.equals(method.getName()))\n+                .filter(method -> hasMethodAnnotation(method))\n+                .collect(Collectors.toList());\n+        if (methods.size() > 1) {\n+            String msg = String.format(\"Class '%s' contains \"\n+                            + \"several event handler method with the same name '%s'\",\n+                    instance.getClass().getName(), methodName);\n+            throw new IllegalStateException(msg);\n+        } else if (methods.size() == 1) {\n+            return Optional.of(methods.get(0));\n+        } else if (!Component.class.equals(clazz)) {\n+            return findMethod(instance, clazz.getSuperclass(), methodName);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private static boolean hasMethodAnnotation(Method method) {\n+        // Check for polymer event handler annotation.\n+        final Optional<Annotation> eventHandler = ReflectTools\n+                .getAnnotation(method,\n+                        \"com.vaadin.flow.component.polymertemplate.EventHandler\");\n+        return eventHandler.isPresent() || method\n+                .isAnnotationPresent(ClientCallable.class);\n+    }\n+\n+    private static void invokeMethod(Component instance, Method method,\n+            JsonArray args, int promiseId) {\n+        if (promiseId == -1) {\n+            invokeMethod(instance, method, args);\n+        } else {\n+            try {\n+                Serializable returnValue = (Serializable) invokeMethod(instance,\n+                        method, args);\n+\n+                instance.getElement().executeJs(\"this.$server['\"\n+                                + JsonConstants.RPC_PROMISE_CALLBACK_NAME\n+                                + \"']($0, true, $1)\", Integer.valueOf(promiseId),\n+                        returnValue);\n+            } catch (RuntimeException e) {\n+                instance.getElement().executeJs(\"this.$server['\"\n+                        + JsonConstants.RPC_PROMISE_CALLBACK_NAME\n+                        + \"']($0, false)\", Integer.valueOf(promiseId));\n+\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private static Object invokeMethod(Component instance, Method method,\n+            JsonArray args) {\n         try {\n-            Class<?> clazz = Class\n-                    .forName(\"com.vaadin.flow.component.polymertemplate.rpc.\"\n-                            + PublishedServerEventHandlerRpcHandler.class\n-                                    .getSimpleName());\n-            Method handleMethod = Stream.of(clazz.getDeclaredMethods())\n-                    .filter(method -> Modifier.isStatic(method.getModifiers())\n-                            && Modifier.isPublic(method.getModifiers()))\n-                    .findFirst().get();\n-            handleMethod.invoke(null, node, invocationJson);\n-        } catch (ClassNotFoundException e) {\n-            LoggerFactory.getLogger(PublishedServerEventHandlerRpcHandler.class)\n-                    .debug(\"Polymer handler is called even though the polymer module is not in the classpath\");\n-            // Just ignore: the functionality is not available\n+            method.setAccessible(true);\n+            return method.invoke(instance, decodeArgs(instance, method, args));\n         } catch (IllegalAccessException e) {\n-            LoggerFactory.getLogger(PublishedServerEventHandlerRpcHandler.class)\n-                    .warn(\"Implemenation error occured\", e);\n+            throw new RuntimeException(e);\n         } catch (InvocationTargetException e) {\n-            throw new IllegalStateException(e);\n+            LoggerFactory.getLogger(\n+                    PublishedServerEventHandlerRpcHandler.class.getName())\n+                    .debug(null, e);\n+            throw new RuntimeException(e.getCause());\n         }\n+    }\n \n-        return Optional.empty();\n+    private static Object[] decodeArgs(Component instance, Method method,\n+            JsonArray argsFromClient) {\n+        int methodArgs = method.getParameterCount();\n+        int clientValuesCount = argsFromClient.length();\n+        JsonArray argValues;\n+        if (method.isVarArgs()) {\n+            if (clientValuesCount >= methodArgs - 1) {\n+                argValues = unwrapVarArgs(argsFromClient, method);\n+            } else {\n+                String msg = String\n+                        .format(\"The number of received values (%d) is not enough \"\n+                                        + \"to call the method '%s' declared in '%s' which \"\n+                                        + \"has vararg parameter and the number of arguments %d\",\n+                                argsFromClient.length(), method.getName(),\n+                                method.getDeclaringClass().getName(),\n+                                method.getParameterCount());\n+                throw new IllegalArgumentException(msg);\n+            }\n+        } else {\n+            if (methodArgs == clientValuesCount) {\n+                argValues = argsFromClient;\n+            } else {\n+                String msg = String\n+                        .format(\"The number of received values (%d) is not equal \"\n+                                        + \"to the number of arguments (%d) in the method '%s' \"\n+                                        + \"declared in '%s'\", argsFromClient.length(),\n+                                method.getParameterCount(), method.getName(),\n+                                method.getDeclaringClass().getName());\n+                throw new IllegalArgumentException(msg);\n+            }\n+        }\n+        List<Object> decoded = new ArrayList<>(method.getParameterCount());\n+        Class<?>[] methodParameterTypes = method.getParameterTypes();\n+        for (int i = 0; i < argValues.length(); i++) {\n+            Class<?> type = methodParameterTypes[i];\n+            decoded.add(decodeArg(instance, method, type, i, argValues.get(i)));\n+        }\n+        return decoded.toArray(new Object[method.getParameterCount()]);\n+    }\n+\n+    private static JsonArray unwrapVarArgs(JsonArray argsFromClient,\n+            Method method) {\n+        int paramCount = method.getParameterCount();\n+        if (argsFromClient.length() == paramCount) {\n+            if (argsFromClient.get(paramCount - 1).getType()\n+                    .equals(JsonType.ARRAY)) {\n+                return argsFromClient;\n+            }\n+        }\n+        JsonArray result = Json.createArray();\n+        JsonArray rest = Json.createArray();\n+        int newIndex = 0;\n+        for (int i = 0; i < argsFromClient.length(); i++) {\n+            JsonValue value = argsFromClient.get(i);\n+            if (i < paramCount - 1) {\n+                result.set(i, value);\n+            } else {\n+                rest.set(newIndex, value);\n+                newIndex++;\n+            }\n+        }\n+        result.set(paramCount - 1, rest);\n+        return result;\n     }\n \n+    private static Object decodeArg(Component instance, Method method,\n+            Class<?> type, int index, JsonValue argValue) {\n+        // come up with method to know that it's an id and should be gotten from\n+        // the model\n+        assert argValue != null;\n+        if (type.isPrimitive() && argValue.getType() == JsonType.NULL) {\n+            String msg = String\n+                    .format(\"Null values are not allowed for primitive types but \"\n+                                    + \"a 'null' value was received for parameter %d \"\n+                                    + \"which refers to primitive type '%s' \"\n+                                    + \"in the method '%s' defined in the class '%s'\",\n+                            index, type.getName(), method.getName(),\n+                            method.getDeclaringClass().getName());\n+            throw new IllegalArgumentException(msg);\n+        } else if (type.isArray()) {\n+            return decodeArray(method, type, index, argValue);\n+        } else {\n+            Class<?> convertedType = ReflectTools.convertPrimitiveType(type);\n+\n+            try {\n+                final Class<?> polymerUtil = PublishedServerEventHandlerRpcHandler.class\n+                        .getClassLoader().loadClass(\n+                                \"com.vaadin.flow.component.polymertemplate.rpc.PublishedEventRpcHandlerUtil\");\n+                if ((Boolean) polymerUtil\n+                        .getMethod(\"isTemplateModelValue\", Component.class,\n+                                JsonValue.class, Class.class)\n+                        .invoke(polymerUtil, instance, argValue,\n+                                convertedType)) {\n+                    return polymerUtil\n+                            .getMethod(\"getTemplateItem\", Component.class,\n+                                    JsonObject.class, Type.class)\n+                            .invoke(polymerUtil, instance, argValue,\n+                                    method.getGenericParameterTypes()[index]);\n+                }\n+            } catch (ClassNotFoundException | NoSuchMethodException e) {", "originalCommit": "a302d5eae94b7ee87c5703194fa363d1b3c0ce4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc2MTczNQ==", "url": "https://github.com/vaadin/flow/pull/9125#discussion_r500761735", "bodyText": "This is a good point. Added.", "author": "caalador", "createdAt": "2020-10-07T06:18:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc0NzAwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc0NzU4MA==", "url": "https://github.com/vaadin/flow/pull/9125#discussion_r500747580", "bodyText": "IllegalAccessException : can't happen. If it happens then this is an impl mistake and it should throw probably.\nInvocationTargetException  means there was some exception in calling the method (which is wrapped to this one because of reflection call).\nThis exception may not be silently ignored (or just logged). It should be thrown somehow.", "author": "denis-anisimov", "createdAt": "2020-10-07T05:35:33Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -58,28 +68,307 @@ public String getRpcType() {\n     @Override\n     public Optional<Runnable> handleNode(StateNode node,\n             JsonObject invocationJson) {\n+        assert invocationJson\n+                .hasKey(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        String methodName = invocationJson\n+                .getString(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\n+                    \"Event handler method name may not be null\");\n+        }\n+        JsonValue args = invocationJson\n+                .get(JsonConstants.RPC_TEMPLATE_EVENT_ARGS);\n+        if (args == null) {\n+            args = Json.createArray();\n+        }\n+        if (args.getType() != JsonType.ARRAY) {\n+            throw new IllegalArgumentException(\n+                    \"Incorrect type for method arguments: \" + args.getClass());\n+        }\n+        int promiseId;\n+        if (invocationJson.hasKey(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE)) {\n+            promiseId = (int) invocationJson\n+                    .getNumber(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE);\n+        } else {\n+            promiseId = -1;\n+        }\n+        assert node.hasFeature(ComponentMapping.class);\n+        Optional<Component> component = ComponentMapping.getComponent(node);\n+        if (!component.isPresent()) {\n+            throw new IllegalStateException(\n+                    \"Unable to handle RPC template event JSON message: \"\n+                            + \"there is no component available for the target node\");\n+        }\n+\n+        boolean execute = node.isEnabled();\n+\n+        if (!execute) {\n+            ClientCallableHandlers clientDelegate = node\n+                    .getFeature(ClientCallableHandlers.class);\n+            PolymerServerEventHandlers eventHandlers = node\n+                    .getFeature(PolymerServerEventHandlers.class);\n+            if (clientDelegate.hasHandler(methodName)) {\n+                execute = DisabledUpdateMode.ALWAYS.equals(clientDelegate\n+                        .getDisabledUpdateMode(methodName));\n+            }\n+            if (eventHandlers.hasHandler(methodName)) {\n+                execute = execute || DisabledUpdateMode.ALWAYS\n+                        .equals(eventHandlers\n+                                .getDisabledUpdateMode(methodName));\n+            }\n+        }\n+\n+        if (execute) {\n+            invokeMethod(component.get(), component.get().getClass(),\n+                    methodName, (JsonArray) args, promiseId);\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    static void invokeMethod(Component instance, Class<?> clazz,\n+            String methodName, JsonArray args, int promiseId) {\n+        assert instance != null;\n+        Optional<Method> method = findMethod(instance, clazz, methodName);\n+        if (method.isPresent()) {\n+            invokeMethod(instance, method.get(), args, promiseId);\n+        } else if (instance instanceof Composite) {\n+            Component compositeContent = ((Composite<?>) instance).getContent();\n+            invokeMethod(compositeContent, compositeContent.getClass(),\n+                    methodName, args, promiseId);\n+        } else {\n+            String msg = String.format(\"Neither class '%s' \"\n+                            + \"nor its super classes declare event handler method '%s'\",\n+                    instance.getClass().getName(), methodName);\n+            throw new IllegalStateException(msg);\n+        }\n+    }\n+\n+    private static Optional<Method> findMethod(Component instance,\n+            Class<?> clazz, String methodName) {\n+        List<Method> methods = Stream.of(clazz.getDeclaredMethods())\n+                .filter(method -> methodName.equals(method.getName()))\n+                .filter(method -> hasMethodAnnotation(method))\n+                .collect(Collectors.toList());\n+        if (methods.size() > 1) {\n+            String msg = String.format(\"Class '%s' contains \"\n+                            + \"several event handler method with the same name '%s'\",\n+                    instance.getClass().getName(), methodName);\n+            throw new IllegalStateException(msg);\n+        } else if (methods.size() == 1) {\n+            return Optional.of(methods.get(0));\n+        } else if (!Component.class.equals(clazz)) {\n+            return findMethod(instance, clazz.getSuperclass(), methodName);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private static boolean hasMethodAnnotation(Method method) {\n+        // Check for polymer event handler annotation.\n+        final Optional<Annotation> eventHandler = ReflectTools\n+                .getAnnotation(method,\n+                        \"com.vaadin.flow.component.polymertemplate.EventHandler\");\n+        return eventHandler.isPresent() || method\n+                .isAnnotationPresent(ClientCallable.class);\n+    }\n+\n+    private static void invokeMethod(Component instance, Method method,\n+            JsonArray args, int promiseId) {\n+        if (promiseId == -1) {\n+            invokeMethod(instance, method, args);\n+        } else {\n+            try {\n+                Serializable returnValue = (Serializable) invokeMethod(instance,\n+                        method, args);\n+\n+                instance.getElement().executeJs(\"this.$server['\"\n+                                + JsonConstants.RPC_PROMISE_CALLBACK_NAME\n+                                + \"']($0, true, $1)\", Integer.valueOf(promiseId),\n+                        returnValue);\n+            } catch (RuntimeException e) {\n+                instance.getElement().executeJs(\"this.$server['\"\n+                        + JsonConstants.RPC_PROMISE_CALLBACK_NAME\n+                        + \"']($0, false)\", Integer.valueOf(promiseId));\n+\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private static Object invokeMethod(Component instance, Method method,\n+            JsonArray args) {\n         try {\n-            Class<?> clazz = Class\n-                    .forName(\"com.vaadin.flow.component.polymertemplate.rpc.\"\n-                            + PublishedServerEventHandlerRpcHandler.class\n-                                    .getSimpleName());\n-            Method handleMethod = Stream.of(clazz.getDeclaredMethods())\n-                    .filter(method -> Modifier.isStatic(method.getModifiers())\n-                            && Modifier.isPublic(method.getModifiers()))\n-                    .findFirst().get();\n-            handleMethod.invoke(null, node, invocationJson);\n-        } catch (ClassNotFoundException e) {\n-            LoggerFactory.getLogger(PublishedServerEventHandlerRpcHandler.class)\n-                    .debug(\"Polymer handler is called even though the polymer module is not in the classpath\");\n-            // Just ignore: the functionality is not available\n+            method.setAccessible(true);\n+            return method.invoke(instance, decodeArgs(instance, method, args));\n         } catch (IllegalAccessException e) {\n-            LoggerFactory.getLogger(PublishedServerEventHandlerRpcHandler.class)\n-                    .warn(\"Implemenation error occured\", e);\n+            throw new RuntimeException(e);\n         } catch (InvocationTargetException e) {\n-            throw new IllegalStateException(e);\n+            LoggerFactory.getLogger(\n+                    PublishedServerEventHandlerRpcHandler.class.getName())\n+                    .debug(null, e);\n+            throw new RuntimeException(e.getCause());\n         }\n+    }\n \n-        return Optional.empty();\n+    private static Object[] decodeArgs(Component instance, Method method,\n+            JsonArray argsFromClient) {\n+        int methodArgs = method.getParameterCount();\n+        int clientValuesCount = argsFromClient.length();\n+        JsonArray argValues;\n+        if (method.isVarArgs()) {\n+            if (clientValuesCount >= methodArgs - 1) {\n+                argValues = unwrapVarArgs(argsFromClient, method);\n+            } else {\n+                String msg = String\n+                        .format(\"The number of received values (%d) is not enough \"\n+                                        + \"to call the method '%s' declared in '%s' which \"\n+                                        + \"has vararg parameter and the number of arguments %d\",\n+                                argsFromClient.length(), method.getName(),\n+                                method.getDeclaringClass().getName(),\n+                                method.getParameterCount());\n+                throw new IllegalArgumentException(msg);\n+            }\n+        } else {\n+            if (methodArgs == clientValuesCount) {\n+                argValues = argsFromClient;\n+            } else {\n+                String msg = String\n+                        .format(\"The number of received values (%d) is not equal \"\n+                                        + \"to the number of arguments (%d) in the method '%s' \"\n+                                        + \"declared in '%s'\", argsFromClient.length(),\n+                                method.getParameterCount(), method.getName(),\n+                                method.getDeclaringClass().getName());\n+                throw new IllegalArgumentException(msg);\n+            }\n+        }\n+        List<Object> decoded = new ArrayList<>(method.getParameterCount());\n+        Class<?>[] methodParameterTypes = method.getParameterTypes();\n+        for (int i = 0; i < argValues.length(); i++) {\n+            Class<?> type = methodParameterTypes[i];\n+            decoded.add(decodeArg(instance, method, type, i, argValues.get(i)));\n+        }\n+        return decoded.toArray(new Object[method.getParameterCount()]);\n+    }\n+\n+    private static JsonArray unwrapVarArgs(JsonArray argsFromClient,\n+            Method method) {\n+        int paramCount = method.getParameterCount();\n+        if (argsFromClient.length() == paramCount) {\n+            if (argsFromClient.get(paramCount - 1).getType()\n+                    .equals(JsonType.ARRAY)) {\n+                return argsFromClient;\n+            }\n+        }\n+        JsonArray result = Json.createArray();\n+        JsonArray rest = Json.createArray();\n+        int newIndex = 0;\n+        for (int i = 0; i < argsFromClient.length(); i++) {\n+            JsonValue value = argsFromClient.get(i);\n+            if (i < paramCount - 1) {\n+                result.set(i, value);\n+            } else {\n+                rest.set(newIndex, value);\n+                newIndex++;\n+            }\n+        }\n+        result.set(paramCount - 1, rest);\n+        return result;\n     }\n \n+    private static Object decodeArg(Component instance, Method method,\n+            Class<?> type, int index, JsonValue argValue) {\n+        // come up with method to know that it's an id and should be gotten from\n+        // the model\n+        assert argValue != null;\n+        if (type.isPrimitive() && argValue.getType() == JsonType.NULL) {\n+            String msg = String\n+                    .format(\"Null values are not allowed for primitive types but \"\n+                                    + \"a 'null' value was received for parameter %d \"\n+                                    + \"which refers to primitive type '%s' \"\n+                                    + \"in the method '%s' defined in the class '%s'\",\n+                            index, type.getName(), method.getName(),\n+                            method.getDeclaringClass().getName());\n+            throw new IllegalArgumentException(msg);\n+        } else if (type.isArray()) {\n+            return decodeArray(method, type, index, argValue);\n+        } else {\n+            Class<?> convertedType = ReflectTools.convertPrimitiveType(type);\n+\n+            try {\n+                final Class<?> polymerUtil = PublishedServerEventHandlerRpcHandler.class\n+                        .getClassLoader().loadClass(\n+                                \"com.vaadin.flow.component.polymertemplate.rpc.PublishedEventRpcHandlerUtil\");\n+                if ((Boolean) polymerUtil\n+                        .getMethod(\"isTemplateModelValue\", Component.class,\n+                                JsonValue.class, Class.class)\n+                        .invoke(polymerUtil, instance, argValue,\n+                                convertedType)) {\n+                    return polymerUtil\n+                            .getMethod(\"getTemplateItem\", Component.class,\n+                                    JsonObject.class, Type.class)\n+                            .invoke(polymerUtil, instance, argValue,\n+                                    method.getGenericParameterTypes()[index]);\n+                }\n+            } catch (ClassNotFoundException | NoSuchMethodException e) {\n+                // NO-OP we just try to check if the polymer library is added\n+                LoggerFactory\n+                        .getLogger(PublishedServerEventHandlerRpcHandler.class)\n+                        .trace(\"Tried finding polymer dependency classes.\", e);\n+            } catch (IllegalAccessException | InvocationTargetException e) {", "originalCommit": "a302d5eae94b7ee87c5703194fa363d1b3c0ce4c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc2MTg5OQ==", "url": "https://github.com/vaadin/flow/pull/9125#discussion_r500761899", "bodyText": "Throwing for each exception.", "author": "caalador", "createdAt": "2020-10-07T06:18:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDc0NzU4MA=="}], "type": "inlineReview"}, {"oid": "44dedcb84805755a70b151e8f3eae597c9e8389b", "url": "https://github.com/vaadin/flow/commit/44dedcb84805755a70b151e8f3eae597c9e8389b", "message": "Undo test changes and move them to another branch", "committedDate": "2020-10-07T06:03:43Z", "type": "commit"}, {"oid": "6745aee58141617b9f40f2dea0ec7a534aa1b614", "url": "https://github.com/vaadin/flow/commit/6745aee58141617b9f40f2dea0ec7a534aa1b614", "message": "Fix throws clauses and add util tests", "committedDate": "2020-10-07T08:09:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDgyMTE2NQ==", "url": "https://github.com/vaadin/flow/pull/9125#discussion_r500821165", "bodyText": "It might be that IllegalArgumentException is better here.\nBut I think it doesn't really matter.", "author": "denis-anisimov", "createdAt": "2020-10-07T08:13:55Z", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PublishedEventRpcHandlerUtil.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Type;\n+import java.util.Optional;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.component.UI;\n+import com.vaadin.flow.component.polymertemplate.PolymerTemplate;\n+import com.vaadin.flow.internal.StateNode;\n+import com.vaadin.flow.templatemodel.ModelType;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Polymer utilitiy class for handling polymer rpc events for @EventHandler.\n+ *\n+ * @since\n+ */\n+public class PublishedEventRpcHandlerUtil implements Serializable {\n+\n+    /**\n+     * Validate that the given Component instance is a PolymerTemplate and that\n+     * the value can be converted.\n+     *\n+     * @param instance\n+     *         Component to be validated\n+     * @param argValue\n+     *         received value\n+     * @param convertedType\n+     *         target type that value should be converted to\n+     * @return true if valid template model value\n+     */\n+    public static boolean isTemplateModelValue(Component instance,\n+            JsonValue argValue, Class<?> convertedType) {\n+        return instance instanceof PolymerTemplate\n+                && argValue instanceof JsonObject\n+                && ((PolymerTemplate<?>) instance)\n+                .isSupportedClass(convertedType) && ((JsonObject) argValue)\n+                .hasKey(\"nodeId\");\n+    }\n+\n+    /**\n+     * Get the template model object and type.\n+     *\n+     * @param template\n+     *         polymer template to get model from\n+     * @param argValue\n+     *         argument value\n+     * @param convertedType\n+     *         value type\n+     * @return the provided model value\n+     * @throws IllegalStateException\n+     *         if the component is not attached to the UI\n+         */\n+        public static Object getTemplateItem(Component template,\n+                JsonObject argValue, Type convertedType) {\n+            final Optional<UI> ui = template.getUI();\n+            if (ui.isPresent()) {\n+                StateNode node = ui.get().getInternals().getStateTree()\n+                        .getNodeById((int) argValue.getNumber(\"nodeId\"));\n+\n+                ModelType propertyType = ((PolymerTemplate<?>) template)\n+                        .getModelType(convertedType);\n+\n+                return propertyType.modelToApplication(node);\n+            }\n+            throw new IllegalStateException(", "originalCommit": "6745aee58141617b9f40f2dea0ec7a534aa1b614", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDgzNTA4Ng==", "url": "https://github.com/vaadin/flow/pull/9125#discussion_r500835086", "bodyText": "changed", "author": "caalador", "createdAt": "2020-10-07T08:35:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDgyMTE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDgyMzQyNw==", "url": "https://github.com/vaadin/flow/pull/9125#discussion_r500823427", "bodyText": "What should happen to fail the test ?", "author": "denis-anisimov", "createdAt": "2020-10-07T08:17:37Z", "path": "flow-polymer-template/src/test/java/com/vaadin/flow/component/polymertemplate/rpc/PublishedEventRpcHandlerUtilTest.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import net.jcip.annotations.NotThreadSafe;\n+import org.jsoup.Jsoup;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.component.Tag;\n+import com.vaadin.flow.component.UI;\n+import com.vaadin.flow.component.dependency.JsModule;\n+import com.vaadin.flow.component.internal.PendingJavaScriptInvocation;\n+import com.vaadin.flow.component.polymertemplate.PolymerTemplate;\n+import com.vaadin.flow.component.polymertemplate.TemplateParser;\n+import com.vaadin.flow.function.DeploymentConfiguration;\n+import com.vaadin.flow.internal.StateNode;\n+import com.vaadin.flow.server.VaadinRequest;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinSession;\n+import com.vaadin.flow.templatemodel.ModelType;\n+import com.vaadin.flow.templatemodel.TemplateModel;\n+\n+import elemental.json.Json;\n+import elemental.json.JsonObject;\n+\n+@NotThreadSafe\n+public class PublishedEventRpcHandlerUtilTest {\n+\n+    private VaadinService service;\n+\n+    @Before\n+    public void setup() {\n+        service = Mockito.mock(VaadinService.class);\n+        VaadinService.setCurrent(service);\n+        DeploymentConfiguration configuration = Mockito\n+                .mock(DeploymentConfiguration.class);\n+\n+        Mockito.when(service.getDeploymentConfiguration())\n+                .thenReturn(configuration);\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        VaadinService.setCurrent(null);\n+    }\n+\n+    @Tag(\"likeable-element\")\n+    @JsModule(\"./frontend/likeable-element-view.js\")\n+    public class TestModule extends PolymerTemplate<ModelClass> {\n+\n+        public TestModule() {\n+            super((clazz, tag, service) -> new TemplateParser.TemplateData(\"\",\n+                    Jsoup.parse(\"<dom-module id='div'></dom-module>\")));\n+        }\n+    }\n+\n+    public interface ModelClass extends TemplateModel {\n+        void setMessage(String message);\n+    }\n+\n+    @Tag(\"my-component\")\n+    public class TestComponent extends Component {\n+    }\n+\n+    @Test\n+    public void templateWithModel_payloadAsExpected_returnsTrue() {\n+        TestModule instance = new TestModule();\n+\n+        JsonObject json = Json.createObject();\n+        json.put(\"nodeId\", 0);\n+        json.put(\"message\", \"bar\");\n+\n+        boolean isModelValue = PublishedEventRpcHandlerUtil\n+                .isTemplateModelValue(instance, json, String.class);\n+\n+        Assert.assertTrue(isModelValue);\n+    }\n+\n+    @Test\n+    public void templateWithModel_payloadMissingNodeId_returnsFalse() {\n+        TestModule instance = new TestModule();\n+\n+        JsonObject json = Json.createObject();\n+        json.put(\"message\", \"bar\");\n+\n+        boolean isModelValue = PublishedEventRpcHandlerUtil\n+                .isTemplateModelValue(instance, json, String.class);\n+\n+        Assert.assertFalse(isModelValue);\n+    }\n+\n+    @Test\n+    public void templateWithModel_unsupportedType_returnsFalse() {\n+        TestModule instance = new TestModule();\n+\n+        JsonObject json = Json.createObject();\n+        json.put(\"message\", \"bar\");\n+\n+        boolean isModelValue = PublishedEventRpcHandlerUtil\n+                .isTemplateModelValue(instance, json, Boolean.class);\n+\n+        Assert.assertFalse(isModelValue);\n+    }\n+\n+    @Test\n+    public void templateWithModel_faultyPayloadAsNoJsonObject_returnsFalse() {\n+        TestModule instance = new TestModule();\n+\n+        boolean isModelValue = PublishedEventRpcHandlerUtil\n+                .isTemplateModelValue(instance, Json.createArray(),\n+                        String.class);\n+\n+        Assert.assertFalse(isModelValue);\n+    }\n+\n+    @Test\n+    public void normalComponent_returnsFalse() {\n+        TestComponent instance = new TestComponent();\n+\n+        JsonObject json = Json.createObject();\n+        json.put(\"nodeId\", 0);\n+        json.put(\"message\", \"bar\");\n+\n+        boolean isModelValue = PublishedEventRpcHandlerUtil\n+                .isTemplateModelValue(instance, json, String.class);\n+\n+        Assert.assertFalse(isModelValue);\n+    }\n+\n+    public static Object getTemplateItem(Component template,\n+            JsonObject argValue, Type convertedType) {\n+        final Optional<UI> ui = template.getUI();\n+        if (ui.isPresent()) {\n+            StateNode node = ui.get().getInternals().getStateTree()\n+                    .getNodeById((int) argValue.getNumber(\"nodeId\"));\n+\n+            ModelType propertyType = ((PolymerTemplate<?>) template)\n+                    .getModelType(convertedType);\n+\n+            return propertyType.modelToApplication(node);\n+        }\n+        throw new IllegalStateException(\n+                \"Event sent for a non attached template component\");\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void templateNotConnectedToUI_throws() throws NoSuchMethodException {\n+        TestModule instance = new TestModule();\n+\n+        JsonObject json = Json.createObject();\n+        json.put(\"nodeId\", 0);\n+        json.put(\"message\", \"bar\");\n+        final Type messageType = ModelClass.class\n+                .getMethod(\"setMessage\", String.class)\n+                .getGenericParameterTypes()[0];\n+\n+        PublishedEventRpcHandlerUtil\n+                .getTemplateItem(instance, json, messageType);\n+    }\n+\n+    @Test\n+    public void correctItemReturnedFromTemplate() throws NoSuchMethodException {\n+        TestModule instance = new TestModule();\n+\n+        MockUI ui = new MockUI();\n+        ui.add(instance);\n+        ui.dumpPendingJsInvocations();\n+\n+        JsonObject json = Json.createObject();\n+        json.put(\"nodeId\", 0);\n+        json.put(\"message\", \"bar\");\n+        final Type messageType = ModelClass.class\n+                .getMethod(\"setMessage\", String.class)\n+                .getGenericParameterTypes()[0];\n+\n+        final Object templateItem = PublishedEventRpcHandlerUtil\n+                .getTemplateItem(instance, json, messageType);\n+\n+        // We test against the null node as it is impractical to get the\n+        // full model setup in junit test.\n+        Assert.assertNull(\"Null node should get a null template item\", templateItem);", "originalCommit": "6745aee58141617b9f40f2dea0ec7a534aa1b614", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDgzNTAzOA==", "url": "https://github.com/vaadin/flow/pull/9125#discussion_r500835038", "bodyText": "Removed the test as it makes no sense and I doen't see how it should work as a junit test", "author": "caalador", "createdAt": "2020-10-07T08:35:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDgyMzQyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDgyMzU2Mg==", "url": "https://github.com/vaadin/flow/pull/9125#discussion_r500823562", "bodyText": "new line", "author": "denis-anisimov", "createdAt": "2020-10-07T08:17:47Z", "path": "flow-polymer-template/src/test/java/com/vaadin/flow/component/polymertemplate/rpc/PublishedEventRpcHandlerUtilTest.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import net.jcip.annotations.NotThreadSafe;\n+import org.jsoup.Jsoup;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.Mockito;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.component.Tag;\n+import com.vaadin.flow.component.UI;\n+import com.vaadin.flow.component.dependency.JsModule;\n+import com.vaadin.flow.component.internal.PendingJavaScriptInvocation;\n+import com.vaadin.flow.component.polymertemplate.PolymerTemplate;\n+import com.vaadin.flow.component.polymertemplate.TemplateParser;\n+import com.vaadin.flow.function.DeploymentConfiguration;\n+import com.vaadin.flow.internal.StateNode;\n+import com.vaadin.flow.server.VaadinRequest;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinSession;\n+import com.vaadin.flow.templatemodel.ModelType;\n+import com.vaadin.flow.templatemodel.TemplateModel;\n+\n+import elemental.json.Json;\n+import elemental.json.JsonObject;\n+\n+@NotThreadSafe\n+public class PublishedEventRpcHandlerUtilTest {\n+\n+    private VaadinService service;\n+\n+    @Before\n+    public void setup() {\n+        service = Mockito.mock(VaadinService.class);\n+        VaadinService.setCurrent(service);\n+        DeploymentConfiguration configuration = Mockito\n+                .mock(DeploymentConfiguration.class);\n+\n+        Mockito.when(service.getDeploymentConfiguration())\n+                .thenReturn(configuration);\n+    }\n+\n+    @After\n+    public void tearDown() {\n+        VaadinService.setCurrent(null);\n+    }\n+\n+    @Tag(\"likeable-element\")\n+    @JsModule(\"./frontend/likeable-element-view.js\")\n+    public class TestModule extends PolymerTemplate<ModelClass> {\n+\n+        public TestModule() {\n+            super((clazz, tag, service) -> new TemplateParser.TemplateData(\"\",\n+                    Jsoup.parse(\"<dom-module id='div'></dom-module>\")));\n+        }\n+    }\n+\n+    public interface ModelClass extends TemplateModel {\n+        void setMessage(String message);\n+    }\n+\n+    @Tag(\"my-component\")\n+    public class TestComponent extends Component {\n+    }\n+\n+    @Test\n+    public void templateWithModel_payloadAsExpected_returnsTrue() {\n+        TestModule instance = new TestModule();\n+\n+        JsonObject json = Json.createObject();\n+        json.put(\"nodeId\", 0);\n+        json.put(\"message\", \"bar\");\n+\n+        boolean isModelValue = PublishedEventRpcHandlerUtil\n+                .isTemplateModelValue(instance, json, String.class);\n+\n+        Assert.assertTrue(isModelValue);\n+    }\n+\n+    @Test\n+    public void templateWithModel_payloadMissingNodeId_returnsFalse() {\n+        TestModule instance = new TestModule();\n+\n+        JsonObject json = Json.createObject();\n+        json.put(\"message\", \"bar\");\n+\n+        boolean isModelValue = PublishedEventRpcHandlerUtil\n+                .isTemplateModelValue(instance, json, String.class);\n+\n+        Assert.assertFalse(isModelValue);\n+    }\n+\n+    @Test\n+    public void templateWithModel_unsupportedType_returnsFalse() {\n+        TestModule instance = new TestModule();\n+\n+        JsonObject json = Json.createObject();\n+        json.put(\"message\", \"bar\");\n+\n+        boolean isModelValue = PublishedEventRpcHandlerUtil\n+                .isTemplateModelValue(instance, json, Boolean.class);\n+\n+        Assert.assertFalse(isModelValue);\n+    }\n+\n+    @Test\n+    public void templateWithModel_faultyPayloadAsNoJsonObject_returnsFalse() {\n+        TestModule instance = new TestModule();\n+\n+        boolean isModelValue = PublishedEventRpcHandlerUtil\n+                .isTemplateModelValue(instance, Json.createArray(),\n+                        String.class);\n+\n+        Assert.assertFalse(isModelValue);\n+    }\n+\n+    @Test\n+    public void normalComponent_returnsFalse() {\n+        TestComponent instance = new TestComponent();\n+\n+        JsonObject json = Json.createObject();\n+        json.put(\"nodeId\", 0);\n+        json.put(\"message\", \"bar\");\n+\n+        boolean isModelValue = PublishedEventRpcHandlerUtil\n+                .isTemplateModelValue(instance, json, String.class);\n+\n+        Assert.assertFalse(isModelValue);\n+    }\n+\n+    public static Object getTemplateItem(Component template,\n+            JsonObject argValue, Type convertedType) {\n+        final Optional<UI> ui = template.getUI();\n+        if (ui.isPresent()) {\n+            StateNode node = ui.get().getInternals().getStateTree()\n+                    .getNodeById((int) argValue.getNumber(\"nodeId\"));\n+\n+            ModelType propertyType = ((PolymerTemplate<?>) template)\n+                    .getModelType(convertedType);\n+\n+            return propertyType.modelToApplication(node);\n+        }\n+        throw new IllegalStateException(\n+                \"Event sent for a non attached template component\");\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void templateNotConnectedToUI_throws() throws NoSuchMethodException {\n+        TestModule instance = new TestModule();\n+\n+        JsonObject json = Json.createObject();\n+        json.put(\"nodeId\", 0);\n+        json.put(\"message\", \"bar\");\n+        final Type messageType = ModelClass.class\n+                .getMethod(\"setMessage\", String.class)\n+                .getGenericParameterTypes()[0];\n+\n+        PublishedEventRpcHandlerUtil\n+                .getTemplateItem(instance, json, messageType);\n+    }\n+\n+    @Test\n+    public void correctItemReturnedFromTemplate() throws NoSuchMethodException {\n+        TestModule instance = new TestModule();\n+\n+        MockUI ui = new MockUI();\n+        ui.add(instance);\n+        ui.dumpPendingJsInvocations();\n+\n+        JsonObject json = Json.createObject();\n+        json.put(\"nodeId\", 0);\n+        json.put(\"message\", \"bar\");\n+        final Type messageType = ModelClass.class\n+                .getMethod(\"setMessage\", String.class)\n+                .getGenericParameterTypes()[0];\n+\n+        final Object templateItem = PublishedEventRpcHandlerUtil\n+                .getTemplateItem(instance, json, messageType);\n+\n+        // We test against the null node as it is impractical to get the\n+        // full model setup in junit test.\n+        Assert.assertNull(\"Null node should get a null template item\", templateItem);\n+    }\n+\n+    public class MockUI extends UI {\n+\n+        public MockUI() {\n+            getInternals().setSession(Mockito.mock(VaadinSession.class));\n+            setCurrent(this);\n+        }\n+\n+        public List<PendingJavaScriptInvocation> dumpPendingJsInvocations() {\n+            // Ensure element invocations are also flushed\n+            getInternals().getStateTree().runExecutionsBeforeClientResponse();\n+\n+            return getInternals().dumpPendingJavaScriptInvocations();\n+        }\n+    }\n+\n+}", "originalCommit": "6745aee58141617b9f40f2dea0ec7a534aa1b614", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4da8311e566f950b99ad427b11ab3ce21904c65f", "url": "https://github.com/vaadin/flow/commit/4da8311e566f950b99ad427b11ab3ce21904c65f", "message": "Chang exception, remove test\n\nRemove test that has no sensble functionality", "committedDate": "2020-10-07T08:32:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg1MDkzMA==", "url": "https://github.com/vaadin/flow/pull/9125#discussion_r500850930", "bodyText": "Refactor this method to reduce its Cognitive Complexity from 19 to the 15 allowed.", "author": "vaadin-bot", "createdAt": "2020-10-07T09:00:00Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -58,28 +67,313 @@ public String getRpcType() {\n     @Override\n     public Optional<Runnable> handleNode(StateNode node,\n             JsonObject invocationJson) {\n+        assert invocationJson\n+                .hasKey(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        String methodName = invocationJson\n+                .getString(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\n+                    \"Event handler method name may not be null\");\n+        }\n+        JsonValue args = invocationJson\n+                .get(JsonConstants.RPC_TEMPLATE_EVENT_ARGS);\n+        if (args == null) {\n+            args = Json.createArray();\n+        }\n+        if (args.getType() != JsonType.ARRAY) {\n+            throw new IllegalArgumentException(\n+                    \"Incorrect type for method arguments: \" + args.getClass());\n+        }\n+        int promiseId;\n+        if (invocationJson.hasKey(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE)) {\n+            promiseId = (int) invocationJson\n+                    .getNumber(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE);\n+        } else {\n+            promiseId = -1;\n+        }\n+        assert node.hasFeature(ComponentMapping.class);\n+        Optional<Component> component = ComponentMapping.getComponent(node);\n+        if (!component.isPresent()) {\n+            throw new IllegalStateException(\n+                    \"Unable to handle RPC template event JSON message: \"\n+                            + \"there is no component available for the target node\");\n+        }\n+\n+        boolean execute = node.isEnabled();\n+\n+        if (!execute) {\n+            ClientCallableHandlers clientDelegate = node\n+                    .getFeature(ClientCallableHandlers.class);\n+            PolymerServerEventHandlers eventHandlers = node\n+                    .getFeature(PolymerServerEventHandlers.class);\n+            if (clientDelegate.hasHandler(methodName)) {\n+                execute = DisabledUpdateMode.ALWAYS.equals(clientDelegate\n+                        .getDisabledUpdateMode(methodName));\n+            }\n+            if (eventHandlers.hasHandler(methodName)) {\n+                execute = execute || DisabledUpdateMode.ALWAYS\n+                        .equals(eventHandlers\n+                                .getDisabledUpdateMode(methodName));\n+            }\n+        }\n+\n+        if (execute) {\n+            invokeMethod(component.get(), component.get().getClass(),\n+                    methodName, (JsonArray) args, promiseId);\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    static void invokeMethod(Component instance, Class<?> clazz,\n+            String methodName, JsonArray args, int promiseId) {\n+        assert instance != null;\n+        Optional<Method> method = findMethod(instance, clazz, methodName);\n+        if (method.isPresent()) {\n+            invokeMethod(instance, method.get(), args, promiseId);\n+        } else if (instance instanceof Composite) {\n+            Component compositeContent = ((Composite<?>) instance).getContent();\n+            invokeMethod(compositeContent, compositeContent.getClass(),\n+                    methodName, args, promiseId);\n+        } else {\n+            String msg = String.format(\"Neither class '%s' \"\n+                            + \"nor its super classes declare event handler method '%s'\",\n+                    instance.getClass().getName(), methodName);\n+            throw new IllegalStateException(msg);\n+        }\n+    }\n+\n+    private static Optional<Method> findMethod(Component instance,\n+            Class<?> clazz, String methodName) {\n+        List<Method> methods = Stream.of(clazz.getDeclaredMethods())\n+                .filter(method -> methodName.equals(method.getName()))\n+                .filter(method -> hasMethodAnnotation(method))\n+                .collect(Collectors.toList());\n+        if (methods.size() > 1) {\n+            String msg = String.format(\"Class '%s' contains \"\n+                            + \"several event handler method with the same name '%s'\",\n+                    instance.getClass().getName(), methodName);\n+            throw new IllegalStateException(msg);\n+        } else if (methods.size() == 1) {\n+            return Optional.of(methods.get(0));\n+        } else if (!Component.class.equals(clazz)) {\n+            return findMethod(instance, clazz.getSuperclass(), methodName);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private static boolean hasMethodAnnotation(Method method) {\n+        // Check for polymer event handler annotation.\n+        final boolean hasEventHandler = ReflectTools.hasAnnotation(method,\n+                \"com.vaadin.flow.component.polymertemplate.EventHandler\");\n+        return hasEventHandler || method\n+                .isAnnotationPresent(ClientCallable.class);\n+    }\n+\n+    private static void invokeMethod(Component instance, Method method,\n+            JsonArray args, int promiseId) {\n+        if (promiseId == -1) {\n+            invokeMethod(instance, method, args);\n+        } else {\n+            try {\n+                Serializable returnValue = (Serializable) invokeMethod(instance,\n+                        method, args);\n+\n+                instance.getElement().executeJs(\"this.$server['\"\n+                                + JsonConstants.RPC_PROMISE_CALLBACK_NAME\n+                                + \"']($0, true, $1)\", Integer.valueOf(promiseId),\n+                        returnValue);\n+            } catch (RuntimeException e) {\n+                instance.getElement().executeJs(\"this.$server['\"\n+                        + JsonConstants.RPC_PROMISE_CALLBACK_NAME\n+                        + \"']($0, false)\", Integer.valueOf(promiseId));\n+\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private static Object invokeMethod(Component instance, Method method,\n+            JsonArray args) {\n         try {\n-            Class<?> clazz = Class\n-                    .forName(\"com.vaadin.flow.component.polymertemplate.rpc.\"\n-                            + PublishedServerEventHandlerRpcHandler.class\n-                                    .getSimpleName());\n-            Method handleMethod = Stream.of(clazz.getDeclaredMethods())\n-                    .filter(method -> Modifier.isStatic(method.getModifiers())\n-                            && Modifier.isPublic(method.getModifiers()))\n-                    .findFirst().get();\n-            handleMethod.invoke(null, node, invocationJson);\n-        } catch (ClassNotFoundException e) {\n-            LoggerFactory.getLogger(PublishedServerEventHandlerRpcHandler.class)\n-                    .debug(\"Polymer handler is called even though the polymer module is not in the classpath\");\n-            // Just ignore: the functionality is not available\n+            method.setAccessible(true);\n+            return method.invoke(instance, decodeArgs(instance, method, args));\n         } catch (IllegalAccessException e) {\n-            LoggerFactory.getLogger(PublishedServerEventHandlerRpcHandler.class)\n-                    .warn(\"Implemenation error occured\", e);\n+            throw new RuntimeException(e);\n         } catch (InvocationTargetException e) {\n-            throw new IllegalStateException(e);\n+            LoggerFactory.getLogger(\n+                    PublishedServerEventHandlerRpcHandler.class.getName())\n+                    .debug(null, e);\n+            throw new RuntimeException(e.getCause());\n         }\n+    }\n \n-        return Optional.empty();\n+    private static Object[] decodeArgs(Component instance, Method method,\n+            JsonArray argsFromClient) {\n+        int methodArgs = method.getParameterCount();\n+        int clientValuesCount = argsFromClient.length();\n+        JsonArray argValues;\n+        if (method.isVarArgs()) {\n+            if (clientValuesCount >= methodArgs - 1) {\n+                argValues = unwrapVarArgs(argsFromClient, method);\n+            } else {\n+                String msg = String\n+                        .format(\"The number of received values (%d) is not enough \"\n+                                        + \"to call the method '%s' declared in '%s' which \"\n+                                        + \"has vararg parameter and the number of arguments %d\",\n+                                argsFromClient.length(), method.getName(),\n+                                method.getDeclaringClass().getName(),\n+                                method.getParameterCount());\n+                throw new IllegalArgumentException(msg);\n+            }\n+        } else {\n+            if (methodArgs == clientValuesCount) {\n+                argValues = argsFromClient;\n+            } else {\n+                String msg = String\n+                        .format(\"The number of received values (%d) is not equal \"\n+                                        + \"to the number of arguments (%d) in the method '%s' \"\n+                                        + \"declared in '%s'\", argsFromClient.length(),\n+                                method.getParameterCount(), method.getName(),\n+                                method.getDeclaringClass().getName());\n+                throw new IllegalArgumentException(msg);\n+            }\n+        }\n+        List<Object> decoded = new ArrayList<>(method.getParameterCount());\n+        Class<?>[] methodParameterTypes = method.getParameterTypes();\n+        for (int i = 0; i < argValues.length(); i++) {\n+            Class<?> type = methodParameterTypes[i];\n+            decoded.add(decodeArg(instance, method, type, i, argValues.get(i)));\n+        }\n+        return decoded.toArray(new Object[method.getParameterCount()]);\n+    }\n+\n+    private static JsonArray unwrapVarArgs(JsonArray argsFromClient,\n+            Method method) {\n+        int paramCount = method.getParameterCount();\n+        if (argsFromClient.length() == paramCount) {\n+            if (argsFromClient.get(paramCount - 1).getType()\n+                    .equals(JsonType.ARRAY)) {\n+                return argsFromClient;\n+            }\n+        }\n+        JsonArray result = Json.createArray();\n+        JsonArray rest = Json.createArray();\n+        int newIndex = 0;\n+        for (int i = 0; i < argsFromClient.length(); i++) {\n+            JsonValue value = argsFromClient.get(i);\n+            if (i < paramCount - 1) {\n+                result.set(i, value);\n+            } else {\n+                rest.set(newIndex, value);\n+                newIndex++;\n+            }\n+        }\n+        result.set(paramCount - 1, rest);\n+        return result;\n     }\n \n+    private static Object decodeArg(Component instance, Method method,", "originalCommit": "4da8311e566f950b99ad427b11ab3ce21904c65f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDg1MDk0NA==", "url": "https://github.com/vaadin/flow/pull/9125#discussion_r500850944", "bodyText": "Remove this use of \"ModelType\"; it is deprecated. \n Remove this use of \"PolymerTemplate\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-10-07T09:00:02Z", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PublishedEventRpcHandlerUtil.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Type;\n+import java.util.Optional;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.component.UI;\n+import com.vaadin.flow.component.polymertemplate.PolymerTemplate;\n+import com.vaadin.flow.internal.StateNode;\n+import com.vaadin.flow.templatemodel.ModelType;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Polymer utilitiy class for handling polymer rpc events for @EventHandler.\n+ *\n+ * @since\n+ */\n+public class PublishedEventRpcHandlerUtil implements Serializable {\n+\n+    /**\n+     * Validate that the given Component instance is a PolymerTemplate and that\n+     * the value can be converted.\n+     *\n+     * @param instance\n+     *         Component to be validated\n+     * @param argValue\n+     *         received value\n+     * @param convertedType\n+     *         target type that value should be converted to\n+     * @return true if valid template model value\n+     */\n+    public static boolean isTemplateModelValue(Component instance,\n+            JsonValue argValue, Class<?> convertedType) {\n+        return instance instanceof PolymerTemplate\n+                && argValue instanceof JsonObject\n+                && ((PolymerTemplate<?>) instance)\n+                .isSupportedClass(convertedType) && ((JsonObject) argValue)\n+                .hasKey(\"nodeId\");\n+    }\n+\n+    /**\n+     * Get the template model object and type.\n+     *\n+     * @param template\n+     *         polymer template to get model from\n+     * @param argValue\n+     *         argument value\n+     * @param convertedType\n+     *         value type\n+     * @return the provided model value\n+     * @throws IllegalStateException\n+     *         if the component is not attached to the UI\n+         */\n+        public static Object getTemplateItem(Component template,\n+                JsonObject argValue, Type convertedType) {\n+            final Optional<UI> ui = template.getUI();\n+            if (ui.isPresent()) {\n+                StateNode node = ui.get().getInternals().getStateTree()\n+                        .getNodeById((int) argValue.getNumber(\"nodeId\"));\n+\n+                ModelType propertyType = ((PolymerTemplate<?>) template)", "originalCommit": "4da8311e566f950b99ad427b11ab3ce21904c65f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3c56fae9364e8efb0715b773a717153f9d4ad5f3", "url": "https://github.com/vaadin/flow/commit/3c56fae9364e8efb0715b773a717153f9d4ad5f3", "message": "Fix test expectation", "committedDate": "2020-10-07T09:58:09Z", "type": "commit"}]}