{"pr_number": 9454, "pr_title": "Merge master to offline", "pr_createdAt": "2020-11-20T11:17:28Z", "pr_url": "https://github.com/vaadin/flow/pull/9454", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTM1NQ==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709355", "bodyText": "Remove this use of \"DeprecatedPolymerPublishedEventHandler\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:25Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -280,50 +284,36 @@ private static Object decodeArg(Component instance, Method method,\n         // the model\n         assert argValue != null;\n         if (type.isPrimitive() && argValue.getType() == JsonType.NULL) {\n-            String msg = String\n-                    .format(\"Null values are not allowed for primitive types but \"\n-                                    + \"a 'null' value was received for parameter %d \"\n-                                    + \"which refers to primitive type '%s' \"\n-                                    + \"in the method '%s' defined in the class '%s'\",\n-                            index, type.getName(), method.getName(),\n-                            method.getDeclaringClass().getName());\n+            String msg = String.format(\n+                    \"Null values are not allowed for primitive types but \"\n+                            + \"a 'null' value was received for parameter %d \"\n+                            + \"which refers to primitive type '%s' \"\n+                            + \"in the method '%s' defined in the class '%s'\",\n+                    index, type.getName(), method.getName(),\n+                    method.getDeclaringClass().getName());\n             throw new IllegalArgumentException(msg);\n         } else if (type.isArray()) {\n             return decodeArray(method, type, index, argValue);\n         } else {\n             Class<?> convertedType = ReflectTools.convertPrimitiveType(type);\n \n-            try {\n-                final Class<?> polymerUtil = PublishedServerEventHandlerRpcHandler.class\n-                        .getClassLoader().loadClass(\n-                                \"com.vaadin.flow.component.polymertemplate.rpc.PublishedEventRpcHandlerUtil\");\n-                if ((Boolean) polymerUtil\n-                        .getMethod(\"isTemplateModelValue\", Component.class,\n-                                JsonValue.class, Class.class)\n-                        .invoke(polymerUtil, instance, argValue,\n-                                convertedType)) {\n-                    return polymerUtil\n-                            .getMethod(\"getTemplateItem\", Component.class,\n-                                    JsonObject.class, Type.class)\n-                            .invoke(polymerUtil, instance, argValue,\n-                                    method.getGenericParameterTypes()[index]);\n+            if (instance != null) {\n+                Optional<UI> ui = instance.getUI();\n+                if (!ui.isPresent()) {\n+                    throw new IllegalStateException(\n+                            \"Rpc handler may not be called for a detached component\");\n+                }\n+                VaadinContext context = ui.get().getSession().getService()\n+                        .getContext();\n+                DeprecatedPolymerPublishedEventHandler handler = context\n+                        .getAttribute(Lookup.class)\n+                        .lookup(DeprecatedPolymerPublishedEventHandler.class);", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTM2MQ==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709361", "bodyText": "A \"NullPointerException\" could be thrown; \"instance\" is nullable here.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:26Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -180,14 +182,16 @@ private static void invokeMethod(Component instance, Method method,\n                 Serializable returnValue = (Serializable) invokeMethod(instance,\n                         method, args);\n \n-                instance.getElement().executeJs(\"this.$server['\"\n+                instance.getElement()", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTM2Ng==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709366", "bodyText": "Remove this use of \"PolymerServerEventHandlers\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:27Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -107,13 +110,12 @@ public String getRpcType() {\n             PolymerServerEventHandlers eventHandlers = node", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTM3NQ==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709375", "bodyText": "A \"NullPointerException\" could be thrown; \"instance\" is nullable here.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:27Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -180,14 +182,16 @@ private static void invokeMethod(Component instance, Method method,\n                 Serializable returnValue = (Serializable) invokeMethod(instance,\n                         method, args);\n \n-                instance.getElement().executeJs(\"this.$server['\"\n+                instance.getElement()\n+                        .executeJs(\"this.$server['\"\n                                 + JsonConstants.RPC_PROMISE_CALLBACK_NAME\n-                                + \"']($0, true, $1)\", Integer.valueOf(promiseId),\n-                        returnValue);\n+                                + \"']($0, true, $1)\",\n+                                Integer.valueOf(promiseId), returnValue);\n             } catch (RuntimeException e) {\n-                instance.getElement().executeJs(\"this.$server['\"\n-                        + JsonConstants.RPC_PROMISE_CALLBACK_NAME\n-                        + \"']($0, false)\", Integer.valueOf(promiseId));\n+                instance.getElement()", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTM4NQ==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709385", "bodyText": "Remove this use of \"PolymerServerEventHandlers\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:28Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -107,13 +110,12 @@ public String getRpcType() {\n             PolymerServerEventHandlers eventHandlers = node\n                     .getFeature(PolymerServerEventHandlers.class);", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f1fcf4f51ff3e70f6056a02d042fa67345a2d9de", "url": "https://github.com/vaadin/flow/commit/f1fcf4f51ff3e70f6056a02d042fa67345a2d9de", "message": "test: remove Theme annotation from demo helpers module (#9395)", "committedDate": "2020-11-13T08:58:21Z", "type": "commit"}, {"oid": "abd92e71d462b2a37e2866cab0b6105243cfbcab", "url": "https://github.com/vaadin/flow/commit/abd92e71d462b2a37e2866cab0b6105243cfbcab", "message": "feat: Do not allow themeClass and themeName in same annotation (#9389)\n\nTheme Class and Theme Name is not supported in\r\nthe same Theme annotation as theme name builds\r\non the Lumo theme.\r\n\r\ntest-themes is now for testing the Application theme only.\r\nOld theme test was moved into test-misc.\r\n\r\nFixes #9370", "committedDate": "2020-11-16T10:23:31Z", "type": "commit"}, {"oid": "3bc2e60af3600735fc5b188ebb31b48059a13349", "url": "https://github.com/vaadin/flow/commit/3bc2e60af3600735fc5b188ebb31b48059a13349", "message": "fix!: Use data view filter and sorting only to that component (#9315)\n\nIn-memory filtering and sorting are now stored directly in component, which gives an opportunity to change it through the data view API for a certain component separately from other components bound to the same data provider.\r\n\r\nFixes: #8655", "committedDate": "2020-11-16T12:35:45Z", "type": "commit"}, {"oid": "f8d95df1196793cbd202c9e776aaa82e34d231c4", "url": "https://github.com/vaadin/flow/commit/f8d95df1196793cbd202c9e776aaa82e34d231c4", "message": "feat: Only use one theme and fail for duplicates (#9406)\n\nNow we only handle the theme with the name inside the Theme annotation.\r\n\r\nFixes #9383", "committedDate": "2020-11-17T13:31:32Z", "type": "commit"}, {"oid": "a8f1087b0ed606ff4738e3292859e58b4cf4781a", "url": "https://github.com/vaadin/flow/commit/a8f1087b0ed606ff4738e3292859e58b4cf4781a", "message": "Read stats.json content as a bundle resource in OSGi\nRead token file as a bundle resource in OSGi\n\nFixes #9146\nFix NPE\nRevert logic back to the previous state\n# Conflicts:\n#\tflow-server/src/main/java/com/vaadin/flow/server/DeploymentConfigurationFactory.java\n#\tflow-server/src/main/java/com/vaadin/flow/server/frontend/FrontendUtils.java\n#\tflow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "f17fa6aa2a2ee9c6150aefba86a83c91fc8991ce", "url": "https://github.com/vaadin/flow/commit/f17fa6aa2a2ee9c6150aefba86a83c91fc8991ce", "message": "Refactor Instantiator and resources access\n\nFixes #9185\nExclude non-serializable classes\nDrop dependency to flow-push from flow-server\n# Conflicts:\n#\tflow-server/src/main/java/com/vaadin/flow/server/BootstrapHandler.java\n#\tflow-server/src/main/java/com/vaadin/flow/server/DeploymentConfigurationFactory.java\n#\tflow-server/src/main/resources/META-INF/services/javax.servlet.ServletContainerInitializer\n#\tflow-server/src/test/java/com/vaadin/flow/server/connect/generator/endpoints/model/OSGiInstantiatorFactory.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/connect/generator/endpoints/model/OSGiResourceProvider.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/connect/typeconversion/StringConversionTest.java", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "9313114c602c5e3577a430244bee9f7a342267e9", "url": "https://github.com/vaadin/flow/commit/9313114c602c5e3577a430244bee9f7a342267e9", "message": "Remove flow-osgi dep from flow-push, increase osgi cmpn version\n# Conflicts:\n#\tflow-push/pom.xml\n#\tflow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "f372558d37fd1723e1e840702832a1a6a307bf56", "url": "https://github.com/vaadin/flow/commit/f372558d37fd1723e1e840702832a1a6a307bf56", "message": "Correct unit tests after refactoring: make them compiling\nMock VaadinServlet in MockVaadinServletService\nAdapt unit tests for refactored code\nAdapt more unti tests and add one more new SPI method\nFix serializable test, proceed with unit tests adaption\nAdapt unit tests for classes in com.vaadin.flow.server\nAdapt unit tests in the com.vaadin.flow.server.communication package\n* Adapt more unit tests\n\n* Make sure that ServletContextInitializers are executed after\nLookupInitializer\nFix OSGi presence check to be able to run unit test\nAdapt servlet deployer unit tests\nExclude OSGi related classes from test\nExclude all OSGi impl classes from serializable test\n# Conflicts:\n#\tflow-polymer-template/src/test/java/com/vaadin/flow/component/polymertemplate/NpmTemplateParserTest.java\n#\tflow-server/src/main/java/com/vaadin/flow/server/DeploymentConfigurationFactory.java\n#\tflow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java\n#\tflow-server/src/main/resources/META-INF/services/javax.servlet.ServletContainerInitializer\n#\tflow-server/src/test/java/com/vaadin/flow/component/InvalidUrlTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/component/UITest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/BootstrapHandlerDependenciesTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/BootstrapHandlerTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/DeploymentConfigurationFactoryTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/I18NProviderTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/MockServletServiceSessionSetup.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/MockVaadinServletService.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/VaadinServiceTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/VaadinServletConfigurationTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/VaadinServletServiceTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/VaadinSessionTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/communication/PushHandlerTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/communication/WebComponentBootstrapHandlerTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/frontend/FrontendUtilsTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/startup/DevModeInitializerTestBase.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/startup/EnableOSGiRunner.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/startup/ServletDeployerTest.java", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "d5b1480a62c938bf258ff7aae420ed6f8f7d7366", "url": "https://github.com/vaadin/flow/commit/d5b1480a62c938bf258ff7aae420ed6f8f7d7366", "message": "Fix OSGi Lookup related issues\nFix OSGi related unit test one more time\n\n# Conflicts:\n#\tflow-osgi/src/main/java/com/vaadin/flow/osgi/support/OSGiResourceProvider.java\n#\tflow-server/src/main/java/com/vaadin/flow/server/VaadinServlet.java\n#\tflow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java\n#\tflow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java\n#\tflow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/startup/EnableOSGiRunner.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/startup/OSGiInitApplicationRouteRegistryTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/webcomponent/OSGiWebComponentConfigurationRegistryTest.java\n#\tflow-tests/test-root-context/src/main/java/com/vaadin/flow/osgi/Activator.java", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "778b7dff3cbdf184b29ffe1e1c67f0769b0a8ce9", "url": "https://github.com/vaadin/flow/commit/778b7dff3cbdf184b29ffe1e1c67f0769b0a8ce9", "message": "Correct the resource access for VaadinService", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "028fae73f08924ca85991efa153ab757c59f4a4b", "url": "https://github.com/vaadin/flow/commit/028fae73f08924ca85991efa153ab757c59f4a4b", "message": "Extend SPI, provide javadocs some unit tests fixes\nMinor code corrections, javadocs\nCorrect unit test\n# Conflicts:\n#\tflow-polymer-template/src/test/java/com/vaadin/flow/component/polymertemplate/NpmTemplateParserTest.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/communication/WebComponentBootstrapHandlerTest.java", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "205659c9727a2f301cbba745cf1563d6b3dc5b00", "url": "https://github.com/vaadin/flow/commit/205659c9727a2f301cbba745cf1563d6b3dc5b00", "message": "test: add unit tests\n\n# Conflicts:\n#\tflow-tests/test-root-context/src/main/java/com/vaadin/flow/osgi/Activator.java", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "f8aaadb7f68428553e532d1d629c81ee8941b1e8", "url": "https://github.com/vaadin/flow/commit/f8aaadb7f68428553e532d1d629c81ee8941b1e8", "message": "test: make it possible to run felix-jetty in npm mode\n# Conflicts:\n#\tflow-tests/servlet-containers/felix-jetty/pom.xml\n#\tflow-tests/test-root-context/pom-npm.xml", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "d58ac32df6f6a0489965dadff58205dc6f9b05b9", "url": "https://github.com/vaadin/flow/commit/d58ac32df6f6a0489965dadff58205dc6f9b05b9", "message": "Make httpclient dependency optional for now. (#9262)", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "5f3df01f6b5101f95f041a33be57929d2fb46c1d", "url": "https://github.com/vaadin/flow/commit/5f3df01f6b5101f95f041a33be57929d2fb46c1d", "message": "refactoring: move OSGi resource provider impl to flow-server (#9268)\n\nOSGi ResourceProvider impl should be available as a service at the moment when Vaadin WAB register a servlet.\r\nIt's not possible without extra unclear config to make sure that the service is registered if it's in the flow-osgi : the bundle may be activated at any moment regardless of servlet registration.\r\nThe issue doesn't appear if the service is registered at the flow-bundle start phase.", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "79c1bb6bfb9c2ed45f941f0ee7f4adce8e874811", "url": "https://github.com/vaadin/flow/commit/79c1bb6bfb9c2ed45f941f0ee7f4adce8e874811", "message": "refactor: review fixes for OSGi (#9289)\n\n* refactoring: review fixes\n\n* chore: add a comment about Jar packaging in test-root-context module\n\n* fix: ensureServletContext should be always called\n\n* fix: fix review comments\n# Conflicts:\n#\tflow-tests/test-root-context/pom-npm.xml", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "355a290b0780bc009e95b80dd086d62384423569", "url": "https://github.com/vaadin/flow/commit/355a290b0780bc009e95b80dd086d62384423569", "message": "refactor: get rid of cmpn osgi dependency (#9307)\n\nNot needed for flow-server.", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "21920102e9566939fdd4f997bd9d4a8d25e1c863", "url": "https://github.com/vaadin/flow/commit/21920102e9566939fdd4f997bd9d4a8d25e1c863", "message": "refactoring: App classpath resources should be access via\nResourceProvider (#9278)\n\nFixes #9269\n# Conflicts:\n#\tflow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/NpmTemplateParser.java\n#\tflow-server/src/main/java/com/vaadin/flow/server/BootstrapUtils.java", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "2e923d4dfd99b15ce6c05c7b3dc21b959598a468", "url": "https://github.com/vaadin/flow/commit/2e923d4dfd99b15ce6c05c7b3dc21b959598a468", "message": "test: update unit tests", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "1ddb9d6dc9da0e3ccb42c8f1698c11dd733daed3", "url": "https://github.com/vaadin/flow/commit/1ddb9d6dc9da0e3ccb42c8f1698c11dd733daed3", "message": "refactor: fix various OSGi related issues\n\n* add back lost classes during cherry-picks\n* fix unit tests\n* rewrite polymer template RPC", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "07323e92da3c62f2cf0b1f4afe6669baa3b61482", "url": "https://github.com/vaadin/flow/commit/07323e92da3c62f2cf0b1f4afe6669baa3b61482", "message": "fix: fix javadocs after merge conflicts", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "a23b10a31477a0256534a9eb21fccc044361890d", "url": "https://github.com/vaadin/flow/commit/a23b10a31477a0256534a9eb21fccc044361890d", "message": "fix: fix mocks in unit tests", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "3a3791ef62c5399a12729f376bdb937c32deb9d2", "url": "https://github.com/vaadin/flow/commit/3a3791ef62c5399a12729f376bdb937c32deb9d2", "message": "test: Correct activator", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "435beaa0498327e4bab0d51f91ed9f856b6ffbd8", "url": "https://github.com/vaadin/flow/commit/435beaa0498327e4bab0d51f91ed9f856b6ffbd8", "message": "refactor: correct lookup initializer filtering code", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "063de04e69a16a68a24d03a3ac685e8bfc78f3bf", "url": "https://github.com/vaadin/flow/commit/063de04e69a16a68a24d03a3ac685e8bfc78f3bf", "message": "fix: fix javadocs (SQ)", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "c4e8bd36cc2eca79637cdc8b832d94af7c422b81", "url": "https://github.com/vaadin/flow/commit/c4e8bd36cc2eca79637cdc8b832d94af7c422b81", "message": "refactor: Remove OSGi related ITs and osgi module from the repo", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "ce407f7681cf320e64864788668520b111a11756", "url": "https://github.com/vaadin/flow/commit/ce407f7681cf320e64864788668520b111a11756", "message": "fix: fix some review comments", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "389c99beccc0561ec943be4b852724f64ac8f14b", "url": "https://github.com/vaadin/flow/commit/389c99beccc0561ec943be4b852724f64ac8f14b", "message": "fix: test unstable test", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "c15aa5e951655fc3dc75a18433cfebe897530ee2", "url": "https://github.com/vaadin/flow/commit/c15aa5e951655fc3dc75a18433cfebe897530ee2", "message": "refactor: get rid of OSGiClientStaticResource (#9277)", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "28f0a2a818e64525919fc806a1723979411ad4ac", "url": "https://github.com/vaadin/flow/commit/28f0a2a818e64525919fc806a1723979411ad4ac", "message": "fix: use content parameter in the activate method", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "a720caf3191377090221fa0fb6bd38b381e185f3", "url": "https://github.com/vaadin/flow/commit/a720caf3191377090221fa0fb6bd38b381e185f3", "message": "fix: Make OSGi incompatible vaadin-connect dependencies optional", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "f06dfaa38fc0b9873fc0a5f022669267ad81039f", "url": "https://github.com/vaadin/flow/commit/f06dfaa38fc0b9873fc0a5f022669267ad81039f", "message": "fix: make Spring deps optional", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "be3813e42c74386e1509271d808fdcc1685709c5", "url": "https://github.com/vaadin/flow/commit/be3813e42c74386e1509271d808fdcc1685709c5", "message": "fix: make a workaround for broken Route registry API", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "6a0caffe1646883dc4a68a2b500c95af0d9e7057", "url": "https://github.com/vaadin/flow/commit/6a0caffe1646883dc4a68a2b500c95af0d9e7057", "message": "fix: avoid not-breaking exception ojn loading class from another bundle", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "ddefe2586b45ccb68e8bb9077040989cb0f1082d", "url": "https://github.com/vaadin/flow/commit/ddefe2586b45ccb68e8bb9077040989cb0f1082d", "message": "fix: workaround for possible bug in route registry (like #9360).", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "b564b63fc75ebd5cc5d23d13427579857f06a96a", "url": "https://github.com/vaadin/flow/commit/b564b63fc75ebd5cc5d23d13427579857f06a96a", "message": "[OSGi] - Cleanup BudleActivator and Service registration, Update bnd and osgi deps (#9361)\n\nrefactor: OSGi improvements \r\n\r\n* update bnd-version\r\n\r\nSigned-off-by: Stefan Bischof <stbischof@bipolis.org>\r\n\r\n* update osgi dependency and version\r\n\r\nSigned-off-by: Stefan Bischof <stbischof@bipolis.org>\r\n\r\n* fix mocking osgi-classes\r\n\r\nSigned-off-by: Stefan Bischof <stbischof@bipolis.org>\r\n\r\n* OSGiResourceProvider uses @Component to declare the service\r\n\r\nSigned-off-by: Stefan Bischof <stbischof@bipolis.org>\r\n\r\n* VaadinBundleTracker uses @Component to declare the service\r\n\r\nSigned-off-by: Stefan Bischof <stbischof@bipolis.org>\r\n\r\n* Remove `empty` BundleActivator\r\n\r\nSigned-off-by: Stefan Bischof <stbischof@bipolis.org>\r\n\r\n* use constants for osgi.http.whiteboard.servlet.pattern\r\n\r\nSigned-off-by: Stefan Bischof <stbischof@bipolis.org>\r\n\r\n* fix unregister Service PolymerPublishedEventRpcHandler\r\n\r\nSigned-off-by: Stefan Bischof <stbischof@bipolis.org>\r\n\r\n* registers PolymerPublishedEventRpcHandler as a declarative service\r\n\r\nSigned-off-by: Stefan Bischof <stbischof@bipolis.org>", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "477759b9e7a4f2ff70007415496242d198b7ea34", "url": "https://github.com/vaadin/flow/commit/477759b9e7a4f2ff70007415496242d198b7ea34", "message": "fix: add explanation why OSGi Component annotation is safe to use", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "df6f0e530fb7b05df85c68ba6b9e0299dc19311c", "url": "https://github.com/vaadin/flow/commit/df6f0e530fb7b05df85c68ba6b9e0299dc19311c", "message": "fix: code review fixes", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "784b75c120da0c9bf60f9dd1d4cfcd1431c490fc", "url": "https://github.com/vaadin/flow/commit/784b75c120da0c9bf60f9dd1d4cfcd1431c490fc", "message": "fix: return back accidentially removed method and call init for service", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "f77557678d9b7c907a16fda6105b44ac9c215061", "url": "https://github.com/vaadin/flow/commit/f77557678d9b7c907a16fda6105b44ac9c215061", "message": "fix: remove non-existent class pattern from test", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "2224129ffaf3777433b3c733f62651f02111d6d8", "url": "https://github.com/vaadin/flow/commit/2224129ffaf3777433b3c733f62651f02111d6d8", "message": "fix: fix import order", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "8a24e0aa100e2c5ef6748a84b1b0b2971307fd26", "url": "https://github.com/vaadin/flow/commit/8a24e0aa100e2c5ef6748a84b1b0b2971307fd26", "message": "fix: extract code to a separate method", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "08ab60ff10100a2b08b43d2a7e1bb15d591a330b", "url": "https://github.com/vaadin/flow/commit/08ab60ff10100a2b08b43d2a7e1bb15d591a330b", "message": "fix: correct unit test", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "fb5848c503e0376f5d7a5ef5ea542ec728102ec3", "url": "https://github.com/vaadin/flow/commit/fb5848c503e0376f5d7a5ef5ea542ec728102ec3", "message": "fix: fix unit test", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "81ab299cc3b232ee700af6865571de81db8d3f51", "url": "https://github.com/vaadin/flow/commit/81ab299cc3b232ee700af6865571de81db8d3f51", "message": "refactor: simplify list merging", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "2bc2338b9a226338b1167835560be1606e21f7d7", "url": "https://github.com/vaadin/flow/commit/2bc2338b9a226338b1167835560be1606e21f7d7", "message": "fix: return back lost code after review", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "5a73d1bafde440370dd367fc61f0e3ebee4c2c79", "url": "https://github.com/vaadin/flow/commit/5a73d1bafde440370dd367fc61f0e3ebee4c2c79", "message": "fix: imports order", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "7a1be9ceec6f478cc05cf87fcde93cf910d44f74", "url": "https://github.com/vaadin/flow/commit/7a1be9ceec6f478cc05cf87fcde93cf910d44f74", "message": "fix: revert bnd version", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "5a6a6d660e8a0be55d8ee8052a51403c11c0a77b", "url": "https://github.com/vaadin/flow/commit/5a6a6d660e8a0be55d8ee8052a51403c11c0a77b", "message": "fix: imports order, review comments", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "66fc0c42d8abb0bb40487251ee211664850fcfe1", "url": "https://github.com/vaadin/flow/commit/66fc0c42d8abb0bb40487251ee211664850fcfe1", "message": "fix: restore lost test method", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "d7b05cb4121df00003202cc4a08f79dfcebd634c", "url": "https://github.com/vaadin/flow/commit/d7b05cb4121df00003202cc4a08f79dfcebd634c", "message": "fix: import orders", "committedDate": "2020-11-18T05:41:06Z", "type": "commit"}, {"oid": "0e158459dd924b9d8a1dab3eb3f5d5b0793e63f5", "url": "https://github.com/vaadin/flow/commit/0e158459dd924b9d8a1dab3eb3f5d5b0793e63f5", "message": "fix: revert not working deployment of test-root-context ui classifier", "committedDate": "2020-11-18T10:36:04Z", "type": "commit"}, {"oid": "19fe3864f9d1567c5ac7a211189986ac093e781f", "url": "https://github.com/vaadin/flow/commit/19fe3864f9d1567c5ac7a211189986ac093e781f", "message": "fix: check if Url contains directory change in Dev Mode (#9392)\n\nChecks whether the Url contains a directory change and a double encoding in Dev Mode. Returns 403 Forbidden immediately and skip the request handling, if does.", "committedDate": "2020-11-18T10:59:39Z", "type": "commit"}, {"oid": "f3be09a172b2b63a5e1875ae5a939b708cc1692c", "url": "https://github.com/vaadin/flow/commit/f3be09a172b2b63a5e1875ae5a939b708cc1692c", "message": "fix: preserve filter to not lose it between page requests (#9421)\n\nData communicator's filter removal, which has been introduced for components with internal filtering (like a ComboBox), may lead to filter loss during the items scrolling. This fix reverts the filter removal and the components should implement this feature on their side, if necessary.\r\n\r\nRelated-to: vaadin/vaadin-flow-components#388", "committedDate": "2020-11-18T16:54:25Z", "type": "commit"}, {"oid": "cab19f1048faa617d885271a32399136dd3dbafb", "url": "https://github.com/vaadin/flow/commit/cab19f1048faa617d885271a32399136dd3dbafb", "message": "chore: Update issue template with discord link (#9426)", "committedDate": "2020-11-19T09:21:34Z", "type": "commit"}, {"oid": "a1719b4c47c4b0311b2548ae7480b849d0620c0c", "url": "https://github.com/vaadin/flow/commit/a1719b4c47c4b0311b2548ae7480b849d0620c0c", "message": "chore: update chrome expectation to 87 (#9445)", "committedDate": "2020-11-20T06:50:02Z", "type": "commit"}, {"oid": "96317da5a26e7bfe568a7382c8d3b8540f50bb51", "url": "https://github.com/vaadin/flow/commit/96317da5a26e7bfe568a7382c8d3b8540f50bb51", "message": "fix: revert changes which broke route registration (#9432)\n\nNeed to active the tracker from an servlet context initializer because @activate doesn't work on CTOR with parameter", "committedDate": "2020-11-20T10:49:51Z", "type": "commit"}, {"oid": "10a3fcd4d41ef4d47224e9ac88b6fa54d341455a", "url": "https://github.com/vaadin/flow/commit/10a3fcd4d41ef4d47224e9ac88b6fa54d341455a", "message": "Merge branch 'master' into joheriks/merge-master-to-offline\n\n# Conflicts:\n#\tflow-server/src/main/java/com/vaadin/flow/server/StaticFileServer.java\n#\tflow-server/src/main/java/com/vaadin/flow/server/frontend/FrontendUtils.java\n#\tflow-server/src/test/java/com/vaadin/flow/server/frontend/FrontendUtilsTest.java", "committedDate": "2020-11-20T11:16:40Z", "type": "commit"}, {"oid": "4f38cc41a814492ef24242a509a144dc2a3fcf37", "url": "https://github.com/vaadin/flow/commit/4f38cc41a814492ef24242a509a144dc2a3fcf37", "message": "chore: mock VaadinServletService.getClassoader in OSGiVaadinServletTest", "committedDate": "2020-11-20T12:59:39Z", "type": "commit"}, {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "url": "https://github.com/vaadin/flow/commit/bbac127625d7ff9be7e18a5911d9258d5d4ac268", "message": "chore: updated resourceBases directory", "committedDate": "2020-11-20T13:00:05Z", "type": "commit"}, {"oid": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "url": "https://github.com/vaadin/flow/commit/bbac127625d7ff9be7e18a5911d9258d5d4ac268", "message": "chore: updated resourceBases directory", "committedDate": "2020-11-20T13:00:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwODk3OA==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527708978", "bodyText": "Refactor this code to not nest more than 3 if/for/while/switch/try statements.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:00:49Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/scanner/FrontendDependencies.java", "diffHunk": "@@ -326,15 +326,24 @@ private void computeApplicationTheme() throws ClassNotFoundException,\n             // we have a proper theme or no-theme for the app\n             ThemeData themeData = themes.iterator().next();\n             if (!themeData.isNotheme()) {\n-                variant = themeData.getVariant();\n                 String themeClass = themeData.getThemeClass();\n-                if (themeClass == null) {\n-                    themeClass = LUMO;\n+                if (!themeData.getThemeName().isEmpty() && themeClass != null) {\n+                    throw new IllegalStateException(\n+                        \"Theme name and theme class can not both be specified. \"\n+                            + \"Theme name uses Lumo and can not be used in combination with custom theme class.\");\n+                }\n+                variant = themeData.getVariant();\n+                if (themeClass != null) {\n+                    theme = getFinder().loadClass(themeClass);\n+                } else {\n+                    theme = getDefaultTheme();\n+                    if (theme == null) {", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwODk5MA==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527708990", "bodyText": "This call to \"add()\" may be a performance hot spot if the collection is large.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:00:50Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/DeferredServletContextInitializers.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.server.VaadinContext;\n+\n+/**\n+ * Internal collection of initializers which may not be executed immediately but\n+ * requires a {@link Lookup} instance which will be set in the\n+ * {@link VaadinContext} ({@link ServletContext}) only when\n+ * {@link LookupInitializer} completed.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+class DeferredServletContextInitializers {\n+\n+    /**\n+     * A callback which will be called to run\n+     * {@link ServletContainerInitializer} logic once a {@link ServletContext}\n+     * is initialized with {@link Lookup}.\n+     * \n+     * @author Vaadin Ltd\n+     * @since\n+     *\n+     */\n+    interface Initializer {\n+        /**\n+         * Runs {@link ServletContainerInitializer} logic with the provided\n+         * {@code context}.\n+         * \n+         * @param context\n+         *            a ServletContext for the initializer\n+         * @throws ServletException\n+         *             thrown if the initializer throws an exception\n+         */\n+        void init(ServletContext context) throws ServletException;\n+    }\n+\n+    private final List<Initializer> initializers = new CopyOnWriteArrayList<>();\n+\n+    /**\n+     * Adds deferred initializer.\n+     * \n+     * @param initializer\n+     *            an initializer\n+     */\n+    void addInitializer(Initializer initializer) {\n+        initializers.add(initializer);", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTAwNQ==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709005", "bodyText": "Remove this use of \"DeprecatedPolymerPublishedEventHandler\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:00:51Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })\n+public class LookupInitializer\n+        implements ClassLoaderAwareServletContainerInitializer {\n+\n+    private static final String SPI = \" SPI: \";\n+\n+    private static final String ONE_IMPL_REQUIRED = \". Only one implementation should be registered. \"\n+            + \"Use lookupAll to get all instances of the given type.\";\n+\n+    private static final String SEVERAL_IMPLS = \"Found several implementations in the classpath for \";\n+\n+    /**\n+     * This class is private because it's an implementation detail/one of the\n+     * possible implementation and is explicitly made non-overridable because it\n+     * provides the way to override everything.\n+     */\n+    private static class LookupImpl implements Lookup {\n+\n+        private final Map<Class<?>, Collection<Object>> serviceMap;\n+\n+        private LookupImpl(Map<Class<?>, Collection<Object>> initialServices) {\n+            serviceMap = Collections\n+                    .unmodifiableMap(new HashMap<>(initialServices));\n+        }\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+            if (registered == null || registered.isEmpty()) {\n+                ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+                List<T> services = new ArrayList<>();\n+                for (Iterator<T> iterator = loader.iterator(); iterator\n+                        .hasNext();) {\n+                    services.add(iterator.next());\n+                }\n+                if (services.size() > 1) {\n+                    throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                            + SPI + services + ONE_IMPL_REQUIRED);\n+                } else if (services.size() == 1) {\n+                    return services.get(0);\n+                }\n+                return null;\n+            } else if (registered.size() > 1) {\n+                throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                        + SPI + registered + ONE_IMPL_REQUIRED);\n+            } else {\n+                return serviceClass.cast(registered.iterator().next());\n+            }\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            List<T> result = new ArrayList<>();\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+\n+            Set<?> registeredClasses = registered == null\n+                    ? Collections.emptySet()\n+                    : registered.stream().map(Object::getClass)\n+                            .collect(Collectors.toSet());\n+            if (registered != null) {\n+                registered.forEach(\n+                        service -> result.add(serviceClass.cast(service)));\n+            }\n+            ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+            for (Iterator<T> iterator = loader.iterator(); iterator\n+                    .hasNext();) {\n+                T next = iterator.next();\n+                if (!registeredClasses.contains(next.getClass())) {\n+                    result.add(next);\n+                }\n+            }\n+            return result;\n+        }\n+    }\n+\n+    private static class CachedStreamData {\n+\n+        private final byte[] data;\n+        private final IOException exception;\n+\n+        private CachedStreamData(byte[] data, IOException exception) {\n+            this.data = data;\n+            this.exception = exception;\n+        }\n+    }\n+\n+    /**\n+     * This class is private because it's an implementation detail/one of the\n+     * possible implementation and should not be available as public because\n+     * {@link LookupInitializer} will find it in the classpath and it will be\n+     * always used instead custom {@link ResourceProvider} implementation.\n+     */\n+    private static class ResourceProviderImpl implements ResourceProvider {\n+\n+        private Map<String, CachedStreamData> cache = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public URL getApplicationResource(Class<?> clazz, String path) {\n+            return Objects.requireNonNull(clazz).getClassLoader()\n+                    .getResource(path);\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Object context, String path)\n+                throws IOException {\n+            if (context instanceof VaadinService) {\n+                return Collections.list(((VaadinService) context)\n+                        .getClassLoader().getResources(path));\n+            }\n+            return Collections.list(\n+                    context.getClass().getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Class<?> clazz, String path)\n+                throws IOException {\n+            return Collections.list(Objects.requireNonNull(clazz)\n+                    .getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public URL getApplicationResource(Object context, String path) {\n+            Objects.requireNonNull(context);\n+            if (context instanceof VaadinService) {\n+                return ((VaadinService) context).getClassLoader()\n+                        .getResource(path);\n+            }\n+            return getApplicationResource(context.getClass(), path);\n+        }\n+\n+        @Override\n+        public URL getClientResource(String path) {\n+            return getApplicationResource(ResourceProviderImpl.class, path);\n+        }\n+\n+        @Override\n+        public InputStream getClientResourceAsStream(String path)\n+                throws IOException {\n+            // the client resource should be available in the classpath, so\n+            // its content is cached once. If an exception is thrown then\n+            // something is broken and it's also cached and will be rethrown on\n+            // every subsequent access\n+            CachedStreamData cached = cache.computeIfAbsent(path, key -> {\n+                URL url = getClientResource(key);\n+                try (InputStream stream = url.openStream()) {\n+                    ByteArrayOutputStream tempBuffer = new ByteArrayOutputStream();\n+                    IOUtils.copy(stream, tempBuffer);\n+                    return new CachedStreamData(tempBuffer.toByteArray(), null);\n+                } catch (IOException e) {\n+                    return new CachedStreamData(null, e);\n+                }\n+            });\n+\n+            IOException exception = cached.exception;\n+            if (exception == null) {\n+                return new ByteArrayInputStream(cached.data);\n+            }\n+            throw exception;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void process(Set<Class<?>> classSet, ServletContext servletContext)\n+            throws ServletException {\n+        OSGiAccess osgiAccess = OSGiAccess.getInstance();\n+        VaadinServletContext vaadinContext = new VaadinServletContext(\n+                servletContext);\n+        // OSGi case is out of the scope: the Lookup instance is set in the fake\n+        // context when it's created\n+        if (osgiAccess.getOsgiServletContext() == null) {\n+            initStandardLookup(classSet, servletContext);\n+        }\n+\n+        DeferredServletContextInitializers initializers;\n+        synchronized (servletContext) {\n+            initializers = vaadinContext\n+                    .getAttribute(DeferredServletContextInitializers.class);\n+            vaadinContext\n+                    .removeAttribute(DeferredServletContextInitializers.class);\n+        }\n+\n+        if (initializers != null) {\n+            initializers.runInitializers(servletContext);\n+        }\n+    }\n+\n+    @Override\n+    public boolean requiresLookup() {\n+        return false;\n+    }\n+\n+    private void initStandardLookup(Set<Class<?>> classSet,\n+            ServletContext servletContext) {\n+        VaadinServletContext vaadinContext = new VaadinServletContext(\n+                servletContext);\n+\n+        Map<Class<?>, Collection<Object>> services = new HashMap<>();\n+\n+        collectResourceProviders(classSet, services);\n+        collectSubclasses(InstantiatorFactory.class, classSet, services);\n+        collectSubclasses(DeprecatedPolymerPublishedEventHandler.class,", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTAxNQ==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709015", "bodyText": "Reduce the number of conditional operators (5) used in the expression (maximum allowed 3).", "author": "vaadin-bot", "createdAt": "2020-11-20T14:00:52Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })\n+public class LookupInitializer\n+        implements ClassLoaderAwareServletContainerInitializer {\n+\n+    private static final String SPI = \" SPI: \";\n+\n+    private static final String ONE_IMPL_REQUIRED = \". Only one implementation should be registered. \"\n+            + \"Use lookupAll to get all instances of the given type.\";\n+\n+    private static final String SEVERAL_IMPLS = \"Found several implementations in the classpath for \";\n+\n+    /**\n+     * This class is private because it's an implementation detail/one of the\n+     * possible implementation and is explicitly made non-overridable because it\n+     * provides the way to override everything.\n+     */\n+    private static class LookupImpl implements Lookup {\n+\n+        private final Map<Class<?>, Collection<Object>> serviceMap;\n+\n+        private LookupImpl(Map<Class<?>, Collection<Object>> initialServices) {\n+            serviceMap = Collections\n+                    .unmodifiableMap(new HashMap<>(initialServices));\n+        }\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+            if (registered == null || registered.isEmpty()) {\n+                ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+                List<T> services = new ArrayList<>();\n+                for (Iterator<T> iterator = loader.iterator(); iterator\n+                        .hasNext();) {\n+                    services.add(iterator.next());\n+                }\n+                if (services.size() > 1) {\n+                    throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                            + SPI + services + ONE_IMPL_REQUIRED);\n+                } else if (services.size() == 1) {\n+                    return services.get(0);\n+                }\n+                return null;\n+            } else if (registered.size() > 1) {\n+                throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                        + SPI + registered + ONE_IMPL_REQUIRED);\n+            } else {\n+                return serviceClass.cast(registered.iterator().next());\n+            }\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            List<T> result = new ArrayList<>();\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+\n+            Set<?> registeredClasses = registered == null\n+                    ? Collections.emptySet()\n+                    : registered.stream().map(Object::getClass)\n+                            .collect(Collectors.toSet());\n+            if (registered != null) {\n+                registered.forEach(\n+                        service -> result.add(serviceClass.cast(service)));\n+            }\n+            ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+            for (Iterator<T> iterator = loader.iterator(); iterator\n+                    .hasNext();) {\n+                T next = iterator.next();\n+                if (!registeredClasses.contains(next.getClass())) {\n+                    result.add(next);\n+                }\n+            }\n+            return result;\n+        }\n+    }\n+\n+    private static class CachedStreamData {\n+\n+        private final byte[] data;\n+        private final IOException exception;\n+\n+        private CachedStreamData(byte[] data, IOException exception) {\n+            this.data = data;\n+            this.exception = exception;\n+        }\n+    }\n+\n+    /**\n+     * This class is private because it's an implementation detail/one of the\n+     * possible implementation and should not be available as public because\n+     * {@link LookupInitializer} will find it in the classpath and it will be\n+     * always used instead custom {@link ResourceProvider} implementation.\n+     */\n+    private static class ResourceProviderImpl implements ResourceProvider {\n+\n+        private Map<String, CachedStreamData> cache = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public URL getApplicationResource(Class<?> clazz, String path) {\n+            return Objects.requireNonNull(clazz).getClassLoader()\n+                    .getResource(path);\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Object context, String path)\n+                throws IOException {\n+            if (context instanceof VaadinService) {\n+                return Collections.list(((VaadinService) context)\n+                        .getClassLoader().getResources(path));\n+            }\n+            return Collections.list(\n+                    context.getClass().getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Class<?> clazz, String path)\n+                throws IOException {\n+            return Collections.list(Objects.requireNonNull(clazz)\n+                    .getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public URL getApplicationResource(Object context, String path) {\n+            Objects.requireNonNull(context);\n+            if (context instanceof VaadinService) {\n+                return ((VaadinService) context).getClassLoader()\n+                        .getResource(path);\n+            }\n+            return getApplicationResource(context.getClass(), path);\n+        }\n+\n+        @Override\n+        public URL getClientResource(String path) {\n+            return getApplicationResource(ResourceProviderImpl.class, path);\n+        }\n+\n+        @Override\n+        public InputStream getClientResourceAsStream(String path)\n+                throws IOException {\n+            // the client resource should be available in the classpath, so\n+            // its content is cached once. If an exception is thrown then\n+            // something is broken and it's also cached and will be rethrown on\n+            // every subsequent access\n+            CachedStreamData cached = cache.computeIfAbsent(path, key -> {\n+                URL url = getClientResource(key);\n+                try (InputStream stream = url.openStream()) {\n+                    ByteArrayOutputStream tempBuffer = new ByteArrayOutputStream();\n+                    IOUtils.copy(stream, tempBuffer);\n+                    return new CachedStreamData(tempBuffer.toByteArray(), null);\n+                } catch (IOException e) {\n+                    return new CachedStreamData(null, e);\n+                }\n+            });\n+\n+            IOException exception = cached.exception;\n+            if (exception == null) {\n+                return new ByteArrayInputStream(cached.data);\n+            }\n+            throw exception;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void process(Set<Class<?>> classSet, ServletContext servletContext)\n+            throws ServletException {\n+        OSGiAccess osgiAccess = OSGiAccess.getInstance();\n+        VaadinServletContext vaadinContext = new VaadinServletContext(\n+                servletContext);\n+        // OSGi case is out of the scope: the Lookup instance is set in the fake\n+        // context when it's created\n+        if (osgiAccess.getOsgiServletContext() == null) {\n+            initStandardLookup(classSet, servletContext);\n+        }\n+\n+        DeferredServletContextInitializers initializers;\n+        synchronized (servletContext) {\n+            initializers = vaadinContext\n+                    .getAttribute(DeferredServletContextInitializers.class);\n+            vaadinContext\n+                    .removeAttribute(DeferredServletContextInitializers.class);\n+        }\n+\n+        if (initializers != null) {\n+            initializers.runInitializers(servletContext);\n+        }\n+    }\n+\n+    @Override\n+    public boolean requiresLookup() {\n+        return false;\n+    }\n+\n+    private void initStandardLookup(Set<Class<?>> classSet,\n+            ServletContext servletContext) {\n+        VaadinServletContext vaadinContext = new VaadinServletContext(\n+                servletContext);\n+\n+        Map<Class<?>, Collection<Object>> services = new HashMap<>();\n+\n+        collectResourceProviders(classSet, services);\n+        collectSubclasses(InstantiatorFactory.class, classSet, services);\n+        collectSubclasses(DeprecatedPolymerPublishedEventHandler.class,\n+                classSet, services);\n+\n+        LookupImpl lookup = new LookupImpl(services);\n+        vaadinContext.setAttribute(Lookup.class, lookup);\n+    }\n+\n+    private void collectSubclasses(Class<?> clazz, Set<Class<?>> classSet,\n+            Map<Class<?>, Collection<Object>> services) {\n+        services.put(clazz,\n+                filterSubClasses(clazz, classSet).stream()\n+                        .map(ReflectTools::createInstance)\n+                        .collect(Collectors.toList()));\n+    }\n+\n+    private void collectResourceProviders(Set<Class<?>> classSet,\n+            Map<Class<?>, Collection<Object>> services) {\n+        Set<Class<?>> providers = filterResourceProviders(classSet);\n+        if (providers.isEmpty()) {\n+            services.put(ResourceProvider.class,\n+                    Collections.singletonList(new ResourceProviderImpl()));\n+        } else if (providers.size() > 1) {\n+            throw new IllegalStateException(\n+                    SEVERAL_IMPLS + ResourceProvider.class.getSimpleName() + SPI\n+                            + classSet + ONE_IMPL_REQUIRED);\n+        } else {\n+            Class<?> clazz = providers.iterator().next();\n+            services.put(ResourceProvider.class, Collections\n+                    .singletonList(ReflectTools.createInstance(clazz)));\n+        }\n+    }\n+\n+    private Set<Class<?>> filterResourceProviders(Set<Class<?>> classes) {\n+        return classes == null ? Collections.emptySet()", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTAyOQ==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709029", "bodyText": "\"servletContext\" is a method parameter, and should not be used for synchronization.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:00:53Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })\n+public class LookupInitializer\n+        implements ClassLoaderAwareServletContainerInitializer {\n+\n+    private static final String SPI = \" SPI: \";\n+\n+    private static final String ONE_IMPL_REQUIRED = \". Only one implementation should be registered. \"\n+            + \"Use lookupAll to get all instances of the given type.\";\n+\n+    private static final String SEVERAL_IMPLS = \"Found several implementations in the classpath for \";\n+\n+    /**\n+     * This class is private because it's an implementation detail/one of the\n+     * possible implementation and is explicitly made non-overridable because it\n+     * provides the way to override everything.\n+     */\n+    private static class LookupImpl implements Lookup {\n+\n+        private final Map<Class<?>, Collection<Object>> serviceMap;\n+\n+        private LookupImpl(Map<Class<?>, Collection<Object>> initialServices) {\n+            serviceMap = Collections\n+                    .unmodifiableMap(new HashMap<>(initialServices));\n+        }\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+            if (registered == null || registered.isEmpty()) {\n+                ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+                List<T> services = new ArrayList<>();\n+                for (Iterator<T> iterator = loader.iterator(); iterator\n+                        .hasNext();) {\n+                    services.add(iterator.next());\n+                }\n+                if (services.size() > 1) {\n+                    throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                            + SPI + services + ONE_IMPL_REQUIRED);\n+                } else if (services.size() == 1) {\n+                    return services.get(0);\n+                }\n+                return null;\n+            } else if (registered.size() > 1) {\n+                throw new IllegalStateException(SEVERAL_IMPLS + serviceClass\n+                        + SPI + registered + ONE_IMPL_REQUIRED);\n+            } else {\n+                return serviceClass.cast(registered.iterator().next());\n+            }\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            List<T> result = new ArrayList<>();\n+            Collection<Object> registered = serviceMap.get(serviceClass);\n+\n+            Set<?> registeredClasses = registered == null\n+                    ? Collections.emptySet()\n+                    : registered.stream().map(Object::getClass)\n+                            .collect(Collectors.toSet());\n+            if (registered != null) {\n+                registered.forEach(\n+                        service -> result.add(serviceClass.cast(service)));\n+            }\n+            ServiceLoader<T> loader = ServiceLoader.load(serviceClass);\n+            for (Iterator<T> iterator = loader.iterator(); iterator\n+                    .hasNext();) {\n+                T next = iterator.next();\n+                if (!registeredClasses.contains(next.getClass())) {\n+                    result.add(next);\n+                }\n+            }\n+            return result;\n+        }\n+    }\n+\n+    private static class CachedStreamData {\n+\n+        private final byte[] data;\n+        private final IOException exception;\n+\n+        private CachedStreamData(byte[] data, IOException exception) {\n+            this.data = data;\n+            this.exception = exception;\n+        }\n+    }\n+\n+    /**\n+     * This class is private because it's an implementation detail/one of the\n+     * possible implementation and should not be available as public because\n+     * {@link LookupInitializer} will find it in the classpath and it will be\n+     * always used instead custom {@link ResourceProvider} implementation.\n+     */\n+    private static class ResourceProviderImpl implements ResourceProvider {\n+\n+        private Map<String, CachedStreamData> cache = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public URL getApplicationResource(Class<?> clazz, String path) {\n+            return Objects.requireNonNull(clazz).getClassLoader()\n+                    .getResource(path);\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Object context, String path)\n+                throws IOException {\n+            if (context instanceof VaadinService) {\n+                return Collections.list(((VaadinService) context)\n+                        .getClassLoader().getResources(path));\n+            }\n+            return Collections.list(\n+                    context.getClass().getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public List<URL> getApplicationResources(Class<?> clazz, String path)\n+                throws IOException {\n+            return Collections.list(Objects.requireNonNull(clazz)\n+                    .getClassLoader().getResources(path));\n+        }\n+\n+        @Override\n+        public URL getApplicationResource(Object context, String path) {\n+            Objects.requireNonNull(context);\n+            if (context instanceof VaadinService) {\n+                return ((VaadinService) context).getClassLoader()\n+                        .getResource(path);\n+            }\n+            return getApplicationResource(context.getClass(), path);\n+        }\n+\n+        @Override\n+        public URL getClientResource(String path) {\n+            return getApplicationResource(ResourceProviderImpl.class, path);\n+        }\n+\n+        @Override\n+        public InputStream getClientResourceAsStream(String path)\n+                throws IOException {\n+            // the client resource should be available in the classpath, so\n+            // its content is cached once. If an exception is thrown then\n+            // something is broken and it's also cached and will be rethrown on\n+            // every subsequent access\n+            CachedStreamData cached = cache.computeIfAbsent(path, key -> {\n+                URL url = getClientResource(key);\n+                try (InputStream stream = url.openStream()) {\n+                    ByteArrayOutputStream tempBuffer = new ByteArrayOutputStream();\n+                    IOUtils.copy(stream, tempBuffer);\n+                    return new CachedStreamData(tempBuffer.toByteArray(), null);\n+                } catch (IOException e) {\n+                    return new CachedStreamData(null, e);\n+                }\n+            });\n+\n+            IOException exception = cached.exception;\n+            if (exception == null) {\n+                return new ByteArrayInputStream(cached.data);\n+            }\n+            throw exception;\n+        }\n+\n+    }\n+\n+    @Override\n+    public void process(Set<Class<?>> classSet, ServletContext servletContext)\n+            throws ServletException {\n+        OSGiAccess osgiAccess = OSGiAccess.getInstance();\n+        VaadinServletContext vaadinContext = new VaadinServletContext(\n+                servletContext);\n+        // OSGi case is out of the scope: the Lookup instance is set in the fake\n+        // context when it's created\n+        if (osgiAccess.getOsgiServletContext() == null) {\n+            initStandardLookup(classSet, servletContext);\n+        }\n+\n+        DeferredServletContextInitializers initializers;\n+        synchronized (servletContext) {", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTAzNA==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709034", "bodyText": "Remove this use of \"DeprecatedPolymerPublishedEventHandler\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:00:53Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/LookupInitializer.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.startup;\n+\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.ServiceLoader;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.InstantiatorFactory;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.di.ResourceProvider;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.server.VaadinService;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.osgi.OSGiResourceProvider;\n+\n+/**\n+ * Standard servlet initializer for collecting all SPI implementations.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ */\n+@HandlesTypes({ ResourceProvider.class, InstantiatorFactory.class,\n+        DeprecatedPolymerPublishedEventHandler.class })", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTA0NA==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709044", "bodyText": "Replace the synchronized class \"Hashtable\" by an unsynchronized one such as \"HashMap\".", "author": "vaadin-bot", "createdAt": "2020-11-20T14:00:54Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ * \n+ * OSGi ServiceComponentRuntime creates the Service immediate while activating\n+ * the bundle.\n+ * \n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            URL resource = bundle.getResource(resourceDirPath + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            try (InputStream stream = resource.openStream()) {\n+                IOUtils.copy(stream, resp.getOutputStream());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of a bundle tracker. OSGi ServiceComponentRuntime\n+     * injects the BundleContext because of the @Activate\n+     * \n+     * @param context\n+     *            the {@code BundleContext} against which the tracking is done\n+     */\n+    @Activate\n+    public VaadinBundleTracker(BundleContext context) {\n+        super(context, Bundle.ACTIVE | Bundle.RESOLVED, null);\n+        flowServerBundle = context.getBundle();\n+    }\n+\n+    @Override\n+    public Bundle addingBundle(Bundle bundle, BundleEvent event) {\n+        if ((bundle.getState() & Bundle.ACTIVE) != 0) {\n+            // Don't scan every individual bundle until flow-server is active\n+            if (flowServerBundle.equals(bundle)) {\n+                // First: scan for servlet context initializers in flow-server\n+                // bundle to reuse the same logic\n+                executor.execute(this::scanContextInitializers);\n+                // Now scan all active bundles for all classes instead of\n+                // scanning every inidividual activated bundle/\n+                executor.execute(this::scanActiveBundles);\n+            } else if (isPushModule(bundle)) {\n+                registerPushResources(bundle);\n+            } else if (isClientModule(bundle)) {\n+                registerClientResources(bundle);\n+            } else if ((flowServerBundle.getState() & Bundle.ACTIVE) != 0) {\n+                // If flow-server bundle is already active then scan bundle for\n+                // classes\n+                executor.execute(() -> scanActivatedBundle(bundle));\n+            }\n+        } else if (event != null\n+                && ((event.getType() & BundleEvent.STOPPED) > 0)) {\n+            if (isPushModule(bundle)) {\n+                unregisterPushResource(bundle);\n+            } else if (isClientModule(bundle)) {\n+                unregisterClientResource(bundle);\n+            } else if (isVaadinExtender(bundle)) {\n+                // Remove all bundle classes once the bundle becomes stopped\n+                OSGiAccess.getInstance()\n+                        .removeScannedClasses(bundle.getBundleId());\n+            }\n+        }\n+        return bundle;\n+    }\n+\n+    private void registerPushResources(Bundle pushBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();\n+        properties.put(HttpWhiteboardConstants.HTTP_WHITEBOARD_SERVLET_PATTERN,\n+                \"/VAADIN/static/push/*\");\n+        servletPushRegistration.compareAndSet(null,\n+                pushBundle.getBundleContext().registerService(Servlet.class,\n+                        new ResourceServlet(pushBundle,\n+                                \"/META-INF/resources/VAADIN/static/push\"),\n+                        properties));\n+    }\n+\n+    private void unregisterPushResource(Bundle pushBundle) {\n+        ServiceRegistration<Servlet> registration = servletPushRegistration\n+                .get();\n+        if (registration != null && registration.getReference().getBundle()\n+                .getBundleId() == pushBundle.getBundleId()) {\n+            registration.unregister();\n+            servletPushRegistration.compareAndSet(registration, null);\n+        }\n+    }\n+\n+    private void registerClientResources(Bundle clientBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTA1MA==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709050", "bodyText": "Add a \"try/catch\" block for \"openStream\".", "author": "vaadin-bot", "createdAt": "2020-11-20T14:00:55Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ * \n+ * OSGi ServiceComponentRuntime creates the Service immediate while activating\n+ * the bundle.\n+ * \n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            URL resource = bundle.getResource(resourceDirPath + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            try (InputStream stream = resource.openStream()) {", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTA1Ng==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709056", "bodyText": "Add a \"try/catch\" block for \"copy\". \n Add a \"try/catch\" block for \"getOutputStream\".", "author": "vaadin-bot", "createdAt": "2020-11-20T14:00:56Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ * \n+ * OSGi ServiceComponentRuntime creates the Service immediate while activating\n+ * the bundle.\n+ * \n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            URL resource = bundle.getResource(resourceDirPath + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            try (InputStream stream = resource.openStream()) {\n+                IOUtils.copy(stream, resp.getOutputStream());", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTA2MQ==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709061", "bodyText": "Reduce the total number of break and continue statements in this loop to use at most one.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:00:57Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ * \n+ * OSGi ServiceComponentRuntime creates the Service immediate while activating\n+ * the bundle.\n+ * \n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            URL resource = bundle.getResource(resourceDirPath + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            try (InputStream stream = resource.openStream()) {\n+                IOUtils.copy(stream, resp.getOutputStream());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of a bundle tracker. OSGi ServiceComponentRuntime\n+     * injects the BundleContext because of the @Activate\n+     * \n+     * @param context\n+     *            the {@code BundleContext} against which the tracking is done\n+     */\n+    @Activate\n+    public VaadinBundleTracker(BundleContext context) {\n+        super(context, Bundle.ACTIVE | Bundle.RESOLVED, null);\n+        flowServerBundle = context.getBundle();\n+    }\n+\n+    @Override\n+    public Bundle addingBundle(Bundle bundle, BundleEvent event) {\n+        if ((bundle.getState() & Bundle.ACTIVE) != 0) {\n+            // Don't scan every individual bundle until flow-server is active\n+            if (flowServerBundle.equals(bundle)) {\n+                // First: scan for servlet context initializers in flow-server\n+                // bundle to reuse the same logic\n+                executor.execute(this::scanContextInitializers);\n+                // Now scan all active bundles for all classes instead of\n+                // scanning every inidividual activated bundle/\n+                executor.execute(this::scanActiveBundles);\n+            } else if (isPushModule(bundle)) {\n+                registerPushResources(bundle);\n+            } else if (isClientModule(bundle)) {\n+                registerClientResources(bundle);\n+            } else if ((flowServerBundle.getState() & Bundle.ACTIVE) != 0) {\n+                // If flow-server bundle is already active then scan bundle for\n+                // classes\n+                executor.execute(() -> scanActivatedBundle(bundle));\n+            }\n+        } else if (event != null\n+                && ((event.getType() & BundleEvent.STOPPED) > 0)) {\n+            if (isPushModule(bundle)) {\n+                unregisterPushResource(bundle);\n+            } else if (isClientModule(bundle)) {\n+                unregisterClientResource(bundle);\n+            } else if (isVaadinExtender(bundle)) {\n+                // Remove all bundle classes once the bundle becomes stopped\n+                OSGiAccess.getInstance()\n+                        .removeScannedClasses(bundle.getBundleId());\n+            }\n+        }\n+        return bundle;\n+    }\n+\n+    private void registerPushResources(Bundle pushBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();\n+        properties.put(HttpWhiteboardConstants.HTTP_WHITEBOARD_SERVLET_PATTERN,\n+                \"/VAADIN/static/push/*\");\n+        servletPushRegistration.compareAndSet(null,\n+                pushBundle.getBundleContext().registerService(Servlet.class,\n+                        new ResourceServlet(pushBundle,\n+                                \"/META-INF/resources/VAADIN/static/push\"),\n+                        properties));\n+    }\n+\n+    private void unregisterPushResource(Bundle pushBundle) {\n+        ServiceRegistration<Servlet> registration = servletPushRegistration\n+                .get();\n+        if (registration != null && registration.getReference().getBundle()\n+                .getBundleId() == pushBundle.getBundleId()) {\n+            registration.unregister();\n+            servletPushRegistration.compareAndSet(registration, null);\n+        }\n+    }\n+\n+    private void registerClientResources(Bundle clientBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();\n+        properties.put(\"osgi.http.whiteboard.servlet.pattern\",\n+                \"/VAADIN/static/client/*\");\n+        servletClientRegistration.compareAndSet(null,\n+                clientBundle.getBundleContext().registerService(Servlet.class,\n+                        new ResourceServlet(clientBundle,\n+                                \"/META-INF/resources/VAADIN/static/client\"),\n+                        properties));\n+    }\n+\n+    private void unregisterClientResource(Bundle clientBundle) {\n+        ServiceRegistration<Servlet> registration = servletClientRegistration\n+                .get();\n+        if (registration != null && registration.getReference().getBundle()\n+                .getBundleId() == clientBundle.getBundleId()) {\n+            registration.unregister();\n+            servletClientRegistration.compareAndSet(registration, null);\n+        }\n+    }\n+\n+    private boolean isPushModule(Bundle bundle) {\n+        return \"com.vaadin.flow.push\".equals(bundle.getSymbolicName());\n+    }\n+\n+    private boolean isClientModule(Bundle bundle) {\n+        return \"com.vaadin.flow.client\".equals(bundle.getSymbolicName());\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private void scanContextInitializers() {\n+        Map<Long, Collection<Class<?>>> map = new HashMap<>();\n+        scanClasses(flowServerBundle, map, this::handleFlowServerClassError);\n+        Collection<Class<?>> classes = map.get(flowServerBundle.getBundleId());\n+\n+        Predicate<Class<?>> isInterface = Class::isInterface;\n+\n+        Collection<Class<? extends ServletContainerInitializer>> initializers = classes\n+                .stream()\n+                .filter(ServletContainerInitializer.class::isAssignableFrom)\n+                .filter(isInterface.negate())\n+                .map(clazz -> (Class<? extends ServletContainerInitializer>) clazz)\n+                .collect(Collectors.toList());\n+        OSGiAccess.getInstance().setServletContainerInitializers(initializers);\n+    }\n+\n+    private void scanActivatedBundle(Bundle bundle) {\n+        if (!isActive(bundle) || !isVaadinExtender(bundle)) {\n+            return;\n+        }\n+        if (OSGiAccess.getInstance().hasInitializers()) {\n+            Map<Long, Collection<Class<?>>> map = new HashMap<>();\n+            scanClasses(bundle, map, this::handleBundleClassError);\n+            OSGiAccess.getInstance().addScannedClasses(map);\n+        } else {\n+            executor.execute(() -> scanActivatedBundle(bundle));\n+        }\n+    }\n+\n+    private void scanActiveBundles() {\n+        Map<Long, Collection<Class<?>>> map = new HashMap<>();\n+        Stream.of(flowServerBundle.getBundleContext().getBundles())\n+                .filter(this::isActive).filter(this::isVaadinExtender)\n+                .forEach(activeBundle -> scanClasses(activeBundle, map,\n+                        this::handleBundleClassError));\n+        OSGiAccess.getInstance().addScannedClasses(map);\n+    }\n+\n+    private boolean isActive(Bundle bundle) {\n+        return (bundle.getState() & Bundle.ACTIVE) > 0;\n+    }\n+\n+    private boolean isVaadinExtender(Bundle bundle) {\n+        return !flowServerBundle.equals(bundle) && Boolean.TRUE.toString()\n+                .equals(bundle.getHeaders().get(\"Vaadin-OSGi-Extender\"));\n+    }\n+\n+    private void handleFlowServerClassError(String className,\n+            Throwable throwable) {\n+        LoggerFactory.getLogger(VaadinBundleTracker.class)\n+                .trace(\"Couldn't load class '{}'\", className, throwable);\n+    }\n+\n+    private void handleBundleClassError(String className, Throwable throwable) {\n+        LoggerFactory.getLogger(VaadinBundleTracker.class)\n+                .warn(\"Couldn't load class '{}'\", className, throwable);\n+    }\n+\n+    private void scanClasses(Bundle bundle, Map<Long, Collection<Class<?>>> map,\n+            BiConsumer<String, Throwable> throwableHandler) {\n+        BundleWiring wiring = bundle.adapt(BundleWiring.class);\n+\n+        // get all .class resources of this bundle\n+        Collection<String> classes = wiring.listResources(\"/\", \"*.class\",\n+                /*\n+                 * Two options: recursive to visit all resources including\n+                 * sub-directories, and limit resources only to the current\n+                 * wiring (bundle) avoiding possibly returned classes from\n+                 * dependencies\n+                 */\n+                BundleWiring.LISTRESOURCES_RECURSE\n+                        | BundleWiring.LISTRESOURCES_LOCAL);\n+\n+        Collection<Class<?>> bundleClasses = new ArrayList<>();\n+\n+        for (String clazz : classes) {", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTA3OA==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709078", "bodyText": "Replace the synchronized class \"Hashtable\" by an unsynchronized one such as \"HashMap\".", "author": "vaadin-bot", "createdAt": "2020-11-20T14:00:58Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/VaadinBundleTracker.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import javax.servlet.Servlet;\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServlet;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.HttpURLConnection;\n+import java.net.URL;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Hashtable;\n+import java.util.Map;\n+import java.util.concurrent.Executor;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.BiConsumer;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.BundleContext;\n+import org.osgi.framework.BundleEvent;\n+import org.osgi.framework.ServiceRegistration;\n+import org.osgi.framework.wiring.BundleWiring;\n+import org.osgi.service.component.annotations.Activate;\n+import org.osgi.service.http.whiteboard.HttpWhiteboardConstants;\n+import org.osgi.util.tracker.BundleTracker;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Bundle tracker to discover all classes in active bundles.\n+ * <p>\n+ * The tracker scans for all classes in active bundles which have\n+ * <b>Vaadin-OSGi-Extender</b> header and report them to the {@link OSGiAccess}\n+ * instance.\n+ * \n+ * OSGi ServiceComponentRuntime creates the Service immediate while activating\n+ * the bundle.\n+ * \n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ */\n+public class VaadinBundleTracker extends BundleTracker<Bundle> {\n+\n+    private final Bundle flowServerBundle;\n+\n+    private Executor executor = Executors.newSingleThreadExecutor();\n+\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletPushRegistration = new AtomicReference<>();\n+    private final AtomicReference<ServiceRegistration<Servlet>> servletClientRegistration = new AtomicReference<>();\n+\n+    /**\n+     * Dedicated servlet for serving resources in Flow bundles.\n+     */\n+    private static class ResourceServlet extends HttpServlet {\n+\n+        private final Bundle bundle;\n+        private final String resourceDirPath;\n+\n+        public ResourceServlet(Bundle bundle, String resourceDirPath) {\n+            this.bundle = bundle;\n+            this.resourceDirPath = resourceDirPath;\n+        }\n+\n+        @Override\n+        protected void doGet(HttpServletRequest req, HttpServletResponse resp)\n+                throws ServletException, IOException {\n+            String pathInfo = req.getPathInfo();\n+            if (pathInfo == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            URL resource = bundle.getResource(resourceDirPath + pathInfo);\n+            if (resource == null) {\n+                resp.setStatus(HttpURLConnection.HTTP_NOT_FOUND);\n+                return;\n+            }\n+            try (InputStream stream = resource.openStream()) {\n+                IOUtils.copy(stream, resp.getOutputStream());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a new instance of a bundle tracker. OSGi ServiceComponentRuntime\n+     * injects the BundleContext because of the @Activate\n+     * \n+     * @param context\n+     *            the {@code BundleContext} against which the tracking is done\n+     */\n+    @Activate\n+    public VaadinBundleTracker(BundleContext context) {\n+        super(context, Bundle.ACTIVE | Bundle.RESOLVED, null);\n+        flowServerBundle = context.getBundle();\n+    }\n+\n+    @Override\n+    public Bundle addingBundle(Bundle bundle, BundleEvent event) {\n+        if ((bundle.getState() & Bundle.ACTIVE) != 0) {\n+            // Don't scan every individual bundle until flow-server is active\n+            if (flowServerBundle.equals(bundle)) {\n+                // First: scan for servlet context initializers in flow-server\n+                // bundle to reuse the same logic\n+                executor.execute(this::scanContextInitializers);\n+                // Now scan all active bundles for all classes instead of\n+                // scanning every inidividual activated bundle/\n+                executor.execute(this::scanActiveBundles);\n+            } else if (isPushModule(bundle)) {\n+                registerPushResources(bundle);\n+            } else if (isClientModule(bundle)) {\n+                registerClientResources(bundle);\n+            } else if ((flowServerBundle.getState() & Bundle.ACTIVE) != 0) {\n+                // If flow-server bundle is already active then scan bundle for\n+                // classes\n+                executor.execute(() -> scanActivatedBundle(bundle));\n+            }\n+        } else if (event != null\n+                && ((event.getType() & BundleEvent.STOPPED) > 0)) {\n+            if (isPushModule(bundle)) {\n+                unregisterPushResource(bundle);\n+            } else if (isClientModule(bundle)) {\n+                unregisterClientResource(bundle);\n+            } else if (isVaadinExtender(bundle)) {\n+                // Remove all bundle classes once the bundle becomes stopped\n+                OSGiAccess.getInstance()\n+                        .removeScannedClasses(bundle.getBundleId());\n+            }\n+        }\n+        return bundle;\n+    }\n+\n+    private void registerPushResources(Bundle pushBundle) {\n+        Hashtable<String, Object> properties = new Hashtable<>();", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTA4Nw==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709087", "bodyText": "Do not forget to remove this deprecated code someday.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:00:59Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/frontend/FrontendUtils.java", "diffHunk": "@@ -151,13 +155,13 @@\n     /**\n      * Default folder for copying front-end resources present in the classpath\n      * jars.\n-     * @deprecated This is deprecated due to a typo.\n-     *             Use DEFAULT_FLOW_RESOURCES_FOLDER instead.\n+     * \n+     * @deprecated This is deprecated due to a typo. Use\n+     *             DEFAULT_FLOW_RESOURCES_FOLDER instead.\n      * @see #DEFAULT_FLOW_RESOURCES_FOLDER\n      */\n     @Deprecated\n-    public static final String DEAULT_FLOW_RESOURCES_FOLDER =\n-            DEFAULT_FLOW_RESOURCES_FOLDER;\n+    public static final String DEAULT_FLOW_RESOURCES_FOLDER = DEFAULT_FLOW_RESOURCES_FOLDER;", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTA5Nw==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709097", "bodyText": "Remove this use of \"getUrl\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:00Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +65,157 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(\n+                    event -> update(() -> applyChange(event))));\n+        }\n+\n+        private void applyChange(RoutesChangedEvent event) {\n+            final RouteConfiguration routeConfiguration = RouteConfiguration\n+                    .forRegistry(this);\n+            Exception caught = null;\n+            for (RouteBaseData<?> data : event.getRemovedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration\n+                        .removeRoute(data.getUrl(), data.getNavigationTarget()),\n+                        caught != null);\n+            }\n+            for (RouteBaseData<?> data : event.getAddedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration.setRoute(\n+                        data.getUrl(), data.getNavigationTarget(),\n+                        data.getParentLayouts()), caught != null);\n+            }\n+            handleCaughtException(caught);\n+        }\n+\n+        private void setRoutes(List<RouteData> routes) {\n+            Exception caught = null;\n+            for (RouteData data : routes) {\n+                caught = modifyRoute(() -> setRoute(data.getUrl(),\n+                        data.getNavigationTarget(), data.getParentLayouts()),\n+                        caught != null);\n+                for (RouteAliasData alias : data.getRouteAliases()) {\n+                    caught = modifyRoute(() -> setRoute(alias.getUrl(),", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTEwNw==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709107", "bodyText": "Remove this use of \"getUrl\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:01Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +65,157 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(\n+                    event -> update(() -> applyChange(event))));\n+        }\n+\n+        private void applyChange(RoutesChangedEvent event) {\n+            final RouteConfiguration routeConfiguration = RouteConfiguration\n+                    .forRegistry(this);\n+            Exception caught = null;\n+            for (RouteBaseData<?> data : event.getRemovedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration\n+                        .removeRoute(data.getUrl(), data.getNavigationTarget()),\n+                        caught != null);\n+            }\n+            for (RouteBaseData<?> data : event.getAddedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration.setRoute(\n+                        data.getUrl(), data.getNavigationTarget(),", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTExNw==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709117", "bodyText": "This call to \"add()\" may be a performance hot spot if the collection is large.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:01Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +65,157 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTEyNw==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709127", "bodyText": "Remove this use of \"getUrl\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:03Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +65,157 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(\n+                    event -> update(() -> applyChange(event))));\n+        }\n+\n+        private void applyChange(RoutesChangedEvent event) {\n+            final RouteConfiguration routeConfiguration = RouteConfiguration\n+                    .forRegistry(this);\n+            Exception caught = null;\n+            for (RouteBaseData<?> data : event.getRemovedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration\n+                        .removeRoute(data.getUrl(), data.getNavigationTarget()),\n+                        caught != null);\n+            }\n+            for (RouteBaseData<?> data : event.getAddedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration.setRoute(\n+                        data.getUrl(), data.getNavigationTarget(),\n+                        data.getParentLayouts()), caught != null);\n+            }\n+            handleCaughtException(caught);\n+        }\n+\n+        private void setRoutes(List<RouteData> routes) {\n+            Exception caught = null;\n+            for (RouteData data : routes) {\n+                caught = modifyRoute(() -> setRoute(data.getUrl(),", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTE0Mw==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709143", "bodyText": "Remove this use of \"getUrl\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:04Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ApplicationRouteRegistry.java", "diffHunk": "@@ -52,6 +65,157 @@\n  */\n public class ApplicationRouteRegistry extends AbstractRouteRegistry {\n \n+    private static class OSGiRouteRegistry extends ApplicationRouteRegistry {\n+        private List<Registration> subscribingRegistrations = new CopyOnWriteArrayList<>();\n+\n+        @Override\n+        public Class<?> getPwaConfigurationClass() {\n+            initPwa();\n+            return super.getPwaConfigurationClass();\n+        }\n+\n+        @Override\n+        public Optional<ErrorTargetEntry> getErrorNavigationTarget(\n+                Exception exception) {\n+            initErrorTargets();\n+            return super.getErrorNavigationTarget(exception);\n+        }\n+\n+        private void initErrorTargets() {\n+            if (!getConfiguration().getExceptionHandlers().isEmpty()) {\n+                return;\n+            }\n+\n+            ServletContext osgiServletContext = OSGiAccess.getInstance()\n+                    .getOsgiServletContext();\n+            if (osgiServletContext == null\n+                    || !OSGiAccess.getInstance().hasInitializers()) {\n+                return;\n+            }\n+            OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                    new VaadinServletContext(osgiServletContext));\n+            if (registry.errorNavigationTargets.get() != null) {\n+                setErrorNavigationTargets(\n+                        registry.errorNavigationTargets.get());\n+            }\n+        }\n+\n+        private void initPwa() {\n+            if (getConfiguration().getRoutes().isEmpty()) {\n+                return;\n+            }\n+            if (OSGiAccess.getInstance().hasInitializers()) {\n+                OSGiDataCollector registry = (OSGiDataCollector) getInstance(\n+                        new VaadinServletContext(OSGiAccess.getInstance()\n+                                .getOsgiServletContext()));\n+                setPwaConfigurationClass(registry.getPwaConfigurationClass());\n+            }\n+        }\n+\n+        private void subscribeToChanges(RouteRegistry routeRegistry) {\n+            subscribingRegistrations.add(routeRegistry.addRoutesChangeListener(\n+                    event -> update(() -> applyChange(event))));\n+        }\n+\n+        private void applyChange(RoutesChangedEvent event) {\n+            final RouteConfiguration routeConfiguration = RouteConfiguration\n+                    .forRegistry(this);\n+            Exception caught = null;\n+            for (RouteBaseData<?> data : event.getRemovedRoutes()) {\n+                caught = modifyRoute(() -> routeConfiguration\n+                        .removeRoute(data.getUrl(), data.getNavigationTarget()),", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTE1OQ==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709159", "bodyText": "Rename \"instantiator\" which hides the field declared at line 191.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:05Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "diffHunk": "@@ -407,11 +413,33 @@ protected Instantiator createInstantiator() throws ServiceException {\n      */\n     protected Optional<Instantiator> loadInstantiators()\n             throws ServiceException {\n-        List<Instantiator> instantiators = StreamSupport\n+        Lookup lookup = getContext().getAttribute(Lookup.class);\n+        List<Instantiator> instantiators = null;\n+        if (lookup != null) {\n+            // lookup may be null in tests\n+            Collection<InstantiatorFactory> factories = lookup\n+                    .lookupAll(InstantiatorFactory.class);\n+            instantiators = new ArrayList<>(factories.size());\n+            for (InstantiatorFactory factory : factories) {\n+                Instantiator instantiator = factory.createInstantitor(this);", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTE2OA==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709168", "bodyText": "Remove this use of \"init\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:06Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "diffHunk": "@@ -407,11 +413,33 @@ protected Instantiator createInstantiator() throws ServiceException {\n      */\n     protected Optional<Instantiator> loadInstantiators()\n             throws ServiceException {\n-        List<Instantiator> instantiators = StreamSupport\n+        Lookup lookup = getContext().getAttribute(Lookup.class);\n+        List<Instantiator> instantiators = null;\n+        if (lookup != null) {\n+            // lookup may be null in tests\n+            Collection<InstantiatorFactory> factories = lookup\n+                    .lookupAll(InstantiatorFactory.class);\n+            instantiators = new ArrayList<>(factories.size());\n+            for (InstantiatorFactory factory : factories) {\n+                Instantiator instantiator = factory.createInstantitor(this);\n+                // if the existing instantiator is converted to new API then\n+                // let's respect its deprecated method\n+                if (instantiator != null && instantiator.init(this)) {\n+                    instantiators.add(instantiator);\n+                }\n+            }\n+        }\n+\n+        if (instantiators == null) {\n+            instantiators = new ArrayList<>();\n+        }\n+\n+        // the code to support previous way of loading instantiators\n+        StreamSupport\n                 .stream(ServiceLoader.load(Instantiator.class, getClassLoader())\n                         .spliterator(), false)\n                 .filter(iterator -> iterator.init(this))", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTE3OA==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709178", "bodyText": "Remove this use of \"init\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:07Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/VaadinService.java", "diffHunk": "@@ -407,11 +413,33 @@ protected Instantiator createInstantiator() throws ServiceException {\n      */\n     protected Optional<Instantiator> loadInstantiators()\n             throws ServiceException {\n-        List<Instantiator> instantiators = StreamSupport\n+        Lookup lookup = getContext().getAttribute(Lookup.class);\n+        List<Instantiator> instantiators = null;\n+        if (lookup != null) {\n+            // lookup may be null in tests\n+            Collection<InstantiatorFactory> factories = lookup\n+                    .lookupAll(InstantiatorFactory.class);\n+            instantiators = new ArrayList<>(factories.size());\n+            for (InstantiatorFactory factory : factories) {\n+                Instantiator instantiator = factory.createInstantitor(this);\n+                // if the existing instantiator is converted to new API then\n+                // let's respect its deprecated method\n+                if (instantiator != null && instantiator.init(this)) {", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTE4Ng==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709186", "bodyText": "Reduce this lambda expression number of lines from 37 to at most 20.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:08Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "diffHunk": "@@ -43,61 +46,90 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    default void onStartup(Set<Class<?>> set, ServletContext ctx)\n+    default void onStartup(Set<Class<?>> set, ServletContext context)\n             throws ServletException {\n-        ClassLoader webClassLoader = ctx.getClassLoader();\n-        ClassLoader classLoader = getClass().getClassLoader();\n+        // see DeferredServletContextIntializers\n+        DeferredServletContextInitializers.Initializer deferredInitializer = ctx -> {", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTE5MA==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709190", "bodyText": "This block of commented-out lines of code should be removed.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:09Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "diffHunk": "@@ -43,61 +46,90 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    default void onStartup(Set<Class<?>> set, ServletContext ctx)\n+    default void onStartup(Set<Class<?>> set, ServletContext context)\n             throws ServletException {\n-        ClassLoader webClassLoader = ctx.getClassLoader();\n-        ClassLoader classLoader = getClass().getClassLoader();\n+        // see DeferredServletContextIntializers\n+        DeferredServletContextInitializers.Initializer deferredInitializer = ctx -> {\n+            ClassLoader webClassLoader = ctx.getClassLoader();\n+            ClassLoader classLoader = getClass().getClassLoader();\n \n-        /*\n-         * Hack is needed to make a workaround for weird behavior of WildFly\n-         * with skinnywar See https://github.com/vaadin/flow/issues/7805\n-         */\n-        boolean noHack = false;\n-        while (classLoader != null) {\n-            if (classLoader.equals(webClassLoader)) {\n-                noHack = true;\n-                break;\n-            } else {\n-                /*\n-                 * The classloader which has loaded this class ({@code\n-                 * classLoader}) should be either the {@code webClassLoader} or\n-                 * its child: in this case it knows how to handle the classes\n-                 * loaded by the {@code webClassLoader} : it either is able to\n-                 * load them itself or delegate to its parent (which is the\n-                 * {@code webClassLoader}): in this case hack is not needed and\n-                 * the {@link #process(Set, ServletContext)} method can be\n-                 * called directly.\n-                 */\n-                classLoader = classLoader.getParent();\n+            /*\n+             * Hack is needed to make a workaround for weird behavior of WildFly\n+             * with skinnywar See https://github.com/vaadin/flow/issues/7805\n+             */\n+            boolean noHack = false;\n+            while (classLoader != null) {\n+                if (classLoader.equals(webClassLoader)) {\n+                    noHack = true;\n+                    break;\n+                } else {\n+                    /*\n+                     * The classloader which has loaded this class ({@code\n+                     * classLoader}) should be either the {@code webClassLoader}", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTIxMA==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709210", "bodyText": "Replace this lambda with a method reference.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:10Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "diffHunk": "@@ -43,61 +46,90 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    default void onStartup(Set<Class<?>> set, ServletContext ctx)\n+    default void onStartup(Set<Class<?>> set, ServletContext context)\n             throws ServletException {\n-        ClassLoader webClassLoader = ctx.getClassLoader();\n-        ClassLoader classLoader = getClass().getClassLoader();\n+        // see DeferredServletContextIntializers\n+        DeferredServletContextInitializers.Initializer deferredInitializer = ctx -> {\n+            ClassLoader webClassLoader = ctx.getClassLoader();\n+            ClassLoader classLoader = getClass().getClassLoader();\n \n-        /*\n-         * Hack is needed to make a workaround for weird behavior of WildFly\n-         * with skinnywar See https://github.com/vaadin/flow/issues/7805\n-         */\n-        boolean noHack = false;\n-        while (classLoader != null) {\n-            if (classLoader.equals(webClassLoader)) {\n-                noHack = true;\n-                break;\n-            } else {\n-                /*\n-                 * The classloader which has loaded this class ({@code\n-                 * classLoader}) should be either the {@code webClassLoader} or\n-                 * its child: in this case it knows how to handle the classes\n-                 * loaded by the {@code webClassLoader} : it either is able to\n-                 * load them itself or delegate to its parent (which is the\n-                 * {@code webClassLoader}): in this case hack is not needed and\n-                 * the {@link #process(Set, ServletContext)} method can be\n-                 * called directly.\n-                 */\n-                classLoader = classLoader.getParent();\n+            /*\n+             * Hack is needed to make a workaround for weird behavior of WildFly\n+             * with skinnywar See https://github.com/vaadin/flow/issues/7805\n+             */\n+            boolean noHack = false;\n+            while (classLoader != null) {\n+                if (classLoader.equals(webClassLoader)) {\n+                    noHack = true;\n+                    break;\n+                } else {\n+                    /*\n+                     * The classloader which has loaded this class ({@code\n+                     * classLoader}) should be either the {@code webClassLoader}\n+                     * or its child: in this case it knows how to handle the\n+                     * classes loaded by the {@code webClassLoader} : it either\n+                     * is able to load them itself or delegate to its parent\n+                     * (which is the {@code webClassLoader}): in this case hack\n+                     * is not needed and the {@link #process(Set,\n+                     * ServletContext)} method can be called directly.\n+                     */\n+                    classLoader = classLoader.getParent();\n+                }\n             }\n-        }\n \n-        if (noHack) {\n-            process(set, ctx);\n-            return;\n-        }\n+            if (noHack) {\n+                process(set, ctx);\n+                return;\n+            }\n+\n+            try {\n+                Class<?> initializer = ctx.getClassLoader()\n+                        .loadClass(getClass().getName());\n \n-        try {\n-            Class<?> initializer = ctx.getClassLoader()\n-                    .loadClass(getClass().getName());\n+                String processMethodName = Stream\n+                        .of(ClassLoaderAwareServletContainerInitializer.class\n+                                .getDeclaredMethods())\n+                        .filter(method -> !method.isDefault()\n+                                && !method.isSynthetic())\n+                        .findFirst().get().getName();\n+                Method operation = Stream.of(initializer.getDeclaredMethods())\n+                        .filter(method -> method.getName()\n+                                .equals(processMethodName))\n+                        .findFirst().get();\n+                operation.invoke(initializer.newInstance(),\n+                        new Object[] { set, ctx });\n+            } catch (ClassNotFoundException | IllegalAccessException\n+                    | IllegalArgumentException | InvocationTargetException\n+                    | InstantiationException e) {\n+                throw new ServletException(e);\n+            }\n+        };\n \n-            String processMethodName = Stream\n-                    .of(ClassLoaderAwareServletContainerInitializer.class\n-                            .getDeclaredMethods())\n-                    .filter(method -> !method.isDefault()\n-                            && !method.isSynthetic())\n-                    .findFirst().get().getName();\n-            Method operation = Stream.of(initializer.getDeclaredMethods())\n-                    .filter(method -> method.getName()\n-                            .equals(processMethodName))\n-                    .findFirst().get();\n-            operation.invoke(initializer.newInstance(),\n-                    new Object[] { set, ctx });\n-        } catch (ClassNotFoundException | IllegalAccessException\n-                | IllegalArgumentException | InvocationTargetException\n-                | InstantiationException e) {\n-            throw new ServletException(e);\n+        if (requiresLookup()) {\n+            VaadinServletContext vaadinContext = new VaadinServletContext(\n+                    context);\n+            synchronized (context) {\n+                if (vaadinContext.getAttribute(Lookup.class) == null) {\n+                    DeferredServletContextInitializers initializers = vaadinContext\n+                            .getAttribute(\n+                                    DeferredServletContextInitializers.class,\n+                                    () -> new DeferredServletContextInitializers());", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTIxNg==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709216", "bodyText": "Replace this lambda with a method reference.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:11Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "diffHunk": "@@ -43,61 +46,90 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    default void onStartup(Set<Class<?>> set, ServletContext ctx)\n+    default void onStartup(Set<Class<?>> set, ServletContext context)\n             throws ServletException {\n-        ClassLoader webClassLoader = ctx.getClassLoader();\n-        ClassLoader classLoader = getClass().getClassLoader();\n+        // see DeferredServletContextIntializers\n+        DeferredServletContextInitializers.Initializer deferredInitializer = ctx -> {\n+            ClassLoader webClassLoader = ctx.getClassLoader();\n+            ClassLoader classLoader = getClass().getClassLoader();\n \n-        /*\n-         * Hack is needed to make a workaround for weird behavior of WildFly\n-         * with skinnywar See https://github.com/vaadin/flow/issues/7805\n-         */\n-        boolean noHack = false;\n-        while (classLoader != null) {\n-            if (classLoader.equals(webClassLoader)) {\n-                noHack = true;\n-                break;\n-            } else {\n-                /*\n-                 * The classloader which has loaded this class ({@code\n-                 * classLoader}) should be either the {@code webClassLoader} or\n-                 * its child: in this case it knows how to handle the classes\n-                 * loaded by the {@code webClassLoader} : it either is able to\n-                 * load them itself or delegate to its parent (which is the\n-                 * {@code webClassLoader}): in this case hack is not needed and\n-                 * the {@link #process(Set, ServletContext)} method can be\n-                 * called directly.\n-                 */\n-                classLoader = classLoader.getParent();\n+            /*\n+             * Hack is needed to make a workaround for weird behavior of WildFly\n+             * with skinnywar See https://github.com/vaadin/flow/issues/7805\n+             */\n+            boolean noHack = false;\n+            while (classLoader != null) {\n+                if (classLoader.equals(webClassLoader)) {\n+                    noHack = true;\n+                    break;\n+                } else {\n+                    /*\n+                     * The classloader which has loaded this class ({@code\n+                     * classLoader}) should be either the {@code webClassLoader}\n+                     * or its child: in this case it knows how to handle the\n+                     * classes loaded by the {@code webClassLoader} : it either\n+                     * is able to load them itself or delegate to its parent\n+                     * (which is the {@code webClassLoader}): in this case hack\n+                     * is not needed and the {@link #process(Set,\n+                     * ServletContext)} method can be called directly.\n+                     */\n+                    classLoader = classLoader.getParent();\n+                }\n             }\n-        }\n \n-        if (noHack) {\n-            process(set, ctx);\n-            return;\n-        }\n+            if (noHack) {\n+                process(set, ctx);\n+                return;\n+            }\n+\n+            try {\n+                Class<?> initializer = ctx.getClassLoader()\n+                        .loadClass(getClass().getName());\n \n-        try {\n-            Class<?> initializer = ctx.getClassLoader()\n-                    .loadClass(getClass().getName());\n+                String processMethodName = Stream\n+                        .of(ClassLoaderAwareServletContainerInitializer.class\n+                                .getDeclaredMethods())\n+                        .filter(method -> !method.isDefault()\n+                                && !method.isSynthetic())\n+                        .findFirst().get().getName();\n+                Method operation = Stream.of(initializer.getDeclaredMethods())\n+                        .filter(method -> method.getName()\n+                                .equals(processMethodName))\n+                        .findFirst().get();\n+                operation.invoke(initializer.newInstance(),\n+                        new Object[] { set, ctx });\n+            } catch (ClassNotFoundException | IllegalAccessException\n+                    | IllegalArgumentException | InvocationTargetException\n+                    | InstantiationException e) {\n+                throw new ServletException(e);\n+            }\n+        };\n \n-            String processMethodName = Stream\n-                    .of(ClassLoaderAwareServletContainerInitializer.class\n-                            .getDeclaredMethods())\n-                    .filter(method -> !method.isDefault()\n-                            && !method.isSynthetic())\n-                    .findFirst().get().getName();\n-            Method operation = Stream.of(initializer.getDeclaredMethods())\n-                    .filter(method -> method.getName()\n-                            .equals(processMethodName))\n-                    .findFirst().get();\n-            operation.invoke(initializer.newInstance(),\n-                    new Object[] { set, ctx });\n-        } catch (ClassNotFoundException | IllegalAccessException\n-                | IllegalArgumentException | InvocationTargetException\n-                | InstantiationException e) {\n-            throw new ServletException(e);\n+        if (requiresLookup()) {\n+            VaadinServletContext vaadinContext = new VaadinServletContext(\n+                    context);\n+            synchronized (context) {\n+                if (vaadinContext.getAttribute(Lookup.class) == null) {\n+                    DeferredServletContextInitializers initializers = vaadinContext\n+                            .getAttribute(\n+                                    DeferredServletContextInitializers.class,\n+                                    () -> new DeferredServletContextInitializers());\n+                    initializers.addInitializer(\n+                            ctx -> deferredInitializer.init(ctx));", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTIyNw==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709227", "bodyText": "\"context\" is a method parameter, and should not be used for synchronization.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:11Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/startup/ClassLoaderAwareServletContainerInitializer.java", "diffHunk": "@@ -43,61 +46,90 @@\n      * {@inheritDoc}\n      */\n     @Override\n-    default void onStartup(Set<Class<?>> set, ServletContext ctx)\n+    default void onStartup(Set<Class<?>> set, ServletContext context)\n             throws ServletException {\n-        ClassLoader webClassLoader = ctx.getClassLoader();\n-        ClassLoader classLoader = getClass().getClassLoader();\n+        // see DeferredServletContextIntializers\n+        DeferredServletContextInitializers.Initializer deferredInitializer = ctx -> {\n+            ClassLoader webClassLoader = ctx.getClassLoader();\n+            ClassLoader classLoader = getClass().getClassLoader();\n \n-        /*\n-         * Hack is needed to make a workaround for weird behavior of WildFly\n-         * with skinnywar See https://github.com/vaadin/flow/issues/7805\n-         */\n-        boolean noHack = false;\n-        while (classLoader != null) {\n-            if (classLoader.equals(webClassLoader)) {\n-                noHack = true;\n-                break;\n-            } else {\n-                /*\n-                 * The classloader which has loaded this class ({@code\n-                 * classLoader}) should be either the {@code webClassLoader} or\n-                 * its child: in this case it knows how to handle the classes\n-                 * loaded by the {@code webClassLoader} : it either is able to\n-                 * load them itself or delegate to its parent (which is the\n-                 * {@code webClassLoader}): in this case hack is not needed and\n-                 * the {@link #process(Set, ServletContext)} method can be\n-                 * called directly.\n-                 */\n-                classLoader = classLoader.getParent();\n+            /*\n+             * Hack is needed to make a workaround for weird behavior of WildFly\n+             * with skinnywar See https://github.com/vaadin/flow/issues/7805\n+             */\n+            boolean noHack = false;\n+            while (classLoader != null) {\n+                if (classLoader.equals(webClassLoader)) {\n+                    noHack = true;\n+                    break;\n+                } else {\n+                    /*\n+                     * The classloader which has loaded this class ({@code\n+                     * classLoader}) should be either the {@code webClassLoader}\n+                     * or its child: in this case it knows how to handle the\n+                     * classes loaded by the {@code webClassLoader} : it either\n+                     * is able to load them itself or delegate to its parent\n+                     * (which is the {@code webClassLoader}): in this case hack\n+                     * is not needed and the {@link #process(Set,\n+                     * ServletContext)} method can be called directly.\n+                     */\n+                    classLoader = classLoader.getParent();\n+                }\n             }\n-        }\n \n-        if (noHack) {\n-            process(set, ctx);\n-            return;\n-        }\n+            if (noHack) {\n+                process(set, ctx);\n+                return;\n+            }\n+\n+            try {\n+                Class<?> initializer = ctx.getClassLoader()\n+                        .loadClass(getClass().getName());\n \n-        try {\n-            Class<?> initializer = ctx.getClassLoader()\n-                    .loadClass(getClass().getName());\n+                String processMethodName = Stream\n+                        .of(ClassLoaderAwareServletContainerInitializer.class\n+                                .getDeclaredMethods())\n+                        .filter(method -> !method.isDefault()\n+                                && !method.isSynthetic())\n+                        .findFirst().get().getName();\n+                Method operation = Stream.of(initializer.getDeclaredMethods())\n+                        .filter(method -> method.getName()\n+                                .equals(processMethodName))\n+                        .findFirst().get();\n+                operation.invoke(initializer.newInstance(),\n+                        new Object[] { set, ctx });\n+            } catch (ClassNotFoundException | IllegalAccessException\n+                    | IllegalArgumentException | InvocationTargetException\n+                    | InstantiationException e) {\n+                throw new ServletException(e);\n+            }\n+        };\n \n-            String processMethodName = Stream\n-                    .of(ClassLoaderAwareServletContainerInitializer.class\n-                            .getDeclaredMethods())\n-                    .filter(method -> !method.isDefault()\n-                            && !method.isSynthetic())\n-                    .findFirst().get().getName();\n-            Method operation = Stream.of(initializer.getDeclaredMethods())\n-                    .filter(method -> method.getName()\n-                            .equals(processMethodName))\n-                    .findFirst().get();\n-            operation.invoke(initializer.newInstance(),\n-                    new Object[] { set, ctx });\n-        } catch (ClassNotFoundException | IllegalAccessException\n-                | IllegalArgumentException | InvocationTargetException\n-                | InstantiationException e) {\n-            throw new ServletException(e);\n+        if (requiresLookup()) {\n+            VaadinServletContext vaadinContext = new VaadinServletContext(\n+                    context);\n+            synchronized (context) {", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTI0Mw==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709243", "bodyText": "Either log or rethrow this exception. \n Catch Exception instead of Throwable.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:12Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.InvalidSyntaxException;\n+import org.osgi.framework.ServiceReference;\n+import org.slf4j.LoggerFactory;\n+\n+import com.googlecode.gentyref.GenericTypeReflector;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.internal.AnnotationReader;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.internal.UsageStatistics;\n+import com.vaadin.flow.router.HasErrorParameter;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.startup.ClassLoaderAwareServletContainerInitializer;\n+import com.vaadin.flow.server.startup.DevModeInitializer;\n+import com.vaadin.flow.server.startup.LookupInitializer;\n+\n+import net.bytebuddy.ByteBuddy;\n+import net.bytebuddy.dynamic.DynamicType.Builder;\n+import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;\n+\n+/**\n+ * Manages scanned classes inside OSGi container.\n+ * <p>\n+ * It doesn't do anything outside of OSGi.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ *\n+ * @see #getInstance()\n+ */\n+public final class OSGiAccess {\n+    private static final OSGiAccess INSTANCE = new OSGiAccess();\n+\n+    private final ServletContext context = LazyOSGiDetector.IS_IN_OSGI\n+            ? createOSGiServletContext()\n+            : null;\n+\n+    private final AtomicReference<Collection<Class<? extends ServletContainerInitializer>>> initializerClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new AtomicReference<>()\n+            : null;\n+\n+    private final Map<Long, Collection<Class<?>>> cachedClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new ConcurrentHashMap<>()\n+            : null;\n+\n+    private OSGiAccess() {\n+        // The class is a singleton. Avoid instantiation outside of the class.\n+    }\n+\n+    private static class OsgiLookupImpl implements Lookup {\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            ServiceReference<T> reference = bundle.getBundleContext()\n+                    .getServiceReference(serviceClass);\n+            if (reference == null) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .debug(\"No service found for '{}' SPI\", serviceClass);\n+                return null;\n+            }\n+            return bundle.getBundleContext().getService(reference);\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            try {\n+                Collection<ServiceReference<T>> references = bundle\n+                        .getBundleContext()\n+                        .getServiceReferences(serviceClass, null);\n+                List<T> services = new ArrayList<>(references.size());\n+                for (ServiceReference<T> reference : references) {\n+                    T service = bundle.getBundleContext().getService(reference);\n+                    if (service != null) {\n+                        services.add(service);\n+                    }\n+                }\n+                return services;\n+            } catch (InvalidSyntaxException e) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .error(\"Unexpected invalid filter expression\", e);\n+                assert false : \"Implementation error: Unexpected invalid filter exception is \"\n+                        + \"thrown even though the service filter is null. Check the exception and update the impl\";\n+            }\n+\n+            return Collections.emptyList();\n+        }\n+\n+    }\n+\n+    /**\n+     * This is internal class and is not intended to be used.\n+     * <p>\n+     * It's public only because it needs to be proxied.\n+     * <p>\n+     * This class represents a singleton servlet context instance which is not a\n+     * real servlet context.\n+     */\n+    public abstract static class OSGiServletContext implements ServletContext {\n+\n+        private final Map<String, Object> attributes = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public void setAttribute(String name, Object object) {\n+            attributes.put(name, object);\n+        }\n+\n+        @Override\n+        public Object getAttribute(String name) {\n+            return attributes.get(name);\n+        }\n+\n+        @Override\n+        public void removeAttribute(String name) {\n+            attributes.remove(name);\n+        }\n+\n+        @Override\n+        public Enumeration<String> getAttributeNames() {\n+            return Collections.enumeration(attributes.keySet());\n+        }\n+\n+        @Override\n+        public void log(String msg) {\n+            // This method is used by Atmosphere initiailizer\n+            LoggerFactory.getLogger(OSGiAccess.class).warn(msg);\n+        }\n+\n+        @Override\n+        public String getInitParameter(String name) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Enumeration<String> getInitParameterNames() {\n+            return Collections.emptyEnumeration();\n+        }\n+\n+        @Override\n+        public Map<String, ? extends ServletRegistration> getServletRegistrations() {\n+            return Collections.emptyMap();\n+        }\n+\n+    }\n+\n+    /**\n+     * Gets the singleton instance.\n+     *\n+     * @return the singleton instance\n+     */\n+    public static OSGiAccess getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    /**\n+     * Gets a servlet context instance which is used to track registries which\n+     * are storage of scanned classes.\n+     * <p>\n+     * This is not a real servlet context. It's just a proxied unique instance\n+     * which is used to be able to access registries in a generic way via some\n+     * {@code getInstance(ServletContext)} method.\n+     *\n+     * @return an OSGi temporary servlet context\n+     */\n+    public ServletContext getOsgiServletContext() {\n+        return context;\n+    }\n+\n+    /**\n+     * Sets the discovered servlet context initializer classes.\n+     * <p>\n+     * The OSGi bundle tracker is used to scan all classes in bundles and it\n+     * also scans <b>flow-server</b> module for servlet initializer classes.\n+     * They are set using this method once they are collected.\n+     *\n+     * @param contextInitializers\n+     *            servlet context initializer classes\n+     */\n+    public void setServletContainerInitializers(\n+            Collection<Class<? extends ServletContainerInitializer>> contextInitializers) {\n+        assert contextInitializers != null;\n+        initializerClasses.set(new ArrayList<>(contextInitializers));\n+    }\n+\n+    /**\n+     * Checks whether the servlet initializers are discovered.\n+     *\n+     * @return {@code true} if servlet initializers are set, {@code false}\n+     *         otherwise\n+     */\n+    public boolean hasInitializers() {\n+        return initializerClasses.get() != null;\n+    }\n+\n+    /**\n+     * Adds scanned classes in active bundles.\n+     * <p>\n+     * The map contains a bundle id as a key and classes discovered in the\n+     * bundle as a value.\n+     *\n+     * @param extenderClasses\n+     *            a map with discovered classes in active bundles\n+     */\n+    public void addScannedClasses(\n+            Map<Long, Collection<Class<?>>> extenderClasses) {\n+        cachedClasses.putAll(extenderClasses);\n+        resetContextInitializers();\n+    }\n+\n+    /**\n+     * Removes classes from the bundle identified by the {@code bundleId}.\n+     * <p>\n+     * When a bundle becomes inactive its classes should not be used anymore.\n+     * This method removes the classes from the bundle from the collection of\n+     * discovered classes.\n+     *\n+     * @param bundleId\n+     *            the bundle identifier\n+     */\n+    public void removeScannedClasses(Long bundleId) {\n+        cachedClasses.remove(bundleId);\n+        resetContextInitializers();\n+    }\n+\n+    private void resetContextInitializers() {\n+        /*\n+         * exclude dev mode initializer (at least for now) because it doesn't\n+         * work in its current state anyway (so it's no-op) but its initial\n+         * calls breaks assumptions about Servlet registration in OSGi.\n+         * \n+         * Lookup is set immediately in the context, so no need to initialize it\n+         */\n+        initializerClasses.get().stream()\n+                .filter(clazz -> !clazz.equals(DevModeInitializer.class)\n+                        && !clazz.equals(LookupInitializer.class))\n+                .map(ReflectTools::createInstance).forEach(this::handleTypes);\n+    }\n+\n+    private void handleTypes(ServletContainerInitializer initializer) {\n+        Optional<HandlesTypes> handleTypes = AnnotationReader\n+                .getAnnotationFor(initializer.getClass(), HandlesTypes.class);\n+        /*\n+         * Every initializer should be an instance of\n+         * ClassLoaderAwareServletContainerInitializer : there is a test which\n+         * forces this. So assert should be enough here.\n+         */\n+        assert initializer instanceof ClassLoaderAwareServletContainerInitializer;\n+        try {\n+            // don't use onStartup method because a fake servlet context is\n+            // passed here: no need to detect classloaders in OSGi case\n+            ((ClassLoaderAwareServletContainerInitializer) initializer).process(\n+                    filterClasses(handleTypes.orElse(null)),\n+                    getOsgiServletContext());\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\n+                    \"Couldn't run servlet context initializer \"\n+                            + initializer.getClass(),\n+                    e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Set<Class<?>> filterClasses(HandlesTypes typesAnnotation) {\n+        Set<Class<?>> result = new HashSet<>();\n+        if (typesAnnotation == null) {\n+            cachedClasses.forEach((bundle, classes) -> result.addAll(classes));\n+        } else {\n+            Class<?>[] requestedTypes = typesAnnotation.value();\n+\n+            Predicate<Class<?>> isAnnotation = Class::isAnnotation;\n+\n+            List<Class<? extends Annotation>> annotations = Stream\n+                    .of(requestedTypes).filter(isAnnotation)\n+                    .map(clazz -> (Class<? extends Annotation>) clazz)\n+                    .collect(Collectors.toList());\n+\n+            List<Class<?>> superTypes = Stream.of(requestedTypes)\n+                    .filter(isAnnotation.negate()).collect(Collectors.toList());\n+\n+            Predicate<Class<?>> hasType = clazz -> annotations.stream()\n+                    .anyMatch(annotation -> AnnotationReader\n+                            .getAnnotationFor(clazz, annotation).isPresent())\n+                    || superTypes.stream()\n+                            .anyMatch(superType -> GenericTypeReflector\n+                                    .isSuperType(HasErrorParameter.class,\n+                                            clazz));\n+\n+            cachedClasses.forEach((bundle, classes) -> result.addAll(classes\n+                    .stream().filter(hasType).collect(Collectors.toList())));\n+\n+        }\n+        return result;\n+    }\n+\n+    private ServletContext createOSGiServletContext() {\n+        Builder<OSGiServletContext> builder = new ByteBuddy()\n+                .subclass(OSGiServletContext.class);\n+\n+        Class<? extends OSGiServletContext> osgiServletContextClass = builder\n+                .make().load(OSGiServletContext.class.getClassLoader(),\n+                        ClassLoadingStrategy.Default.WRAPPER)\n+                .getLoaded();\n+\n+        OSGiServletContext osgiContext = ReflectTools.createProxyInstance(\n+                osgiServletContextClass, ServletContext.class);\n+\n+        new VaadinServletContext(osgiContext).setAttribute(Lookup.class,\n+                new OsgiLookupImpl());\n+\n+        return osgiContext;\n+    }\n+\n+    private static final class LazyOSGiDetector {\n+        private static final boolean IS_IN_OSGI = isInOSGi();\n+\n+        private static boolean isInOSGi() {\n+            try {\n+                Class<?> clazz = Class\n+                        .forName(\"org.osgi.framework.FrameworkUtil\");\n+\n+                Method method = clazz.getDeclaredMethod(\"getBundle\",\n+                        Class.class);\n+\n+                // even though the FrameworkUtil class is in the classpath it\n+                // may be there not because of OSGi container but plain WAR with\n+                // jar which contains the class\n+                if (method.invoke(null, OSGiAccess.class) == null) {\n+                    return false;\n+                }\n+                UsageStatistics.markAsUsed(\"flow/osgi\", getOSGiVersion());\n+\n+                return true;\n+            } catch (ClassNotFoundException | NoSuchMethodException\n+                    | SecurityException | IllegalAccessException\n+                    | IllegalArgumentException\n+                    | InvocationTargetException exception) {\n+                if (LoggerFactory.getLogger(OSGiAccess.class)\n+                        .isTraceEnabled()) {\n+                    LoggerFactory.getLogger(OSGiAccess.class)\n+                            .trace(\"Exception in OSGi container check \"\n+                                    + \"(which most likely means that this is not OSGi container)\",\n+                                    exception);\n+                }\n+                return false;\n+            }\n+        }\n+\n+        /**\n+         * Tries to detect the version of the OSGi framework used.\n+         *\n+         * @return the used OSGi version or {@code null} if not able to detect\n+         *         it\n+         */\n+        private static String getOSGiVersion() {\n+            try {\n+                Bundle osgiBundle = org.osgi.framework.FrameworkUtil\n+                        .getBundle(Bundle.class);\n+                return osgiBundle.getVersion().toString();\n+            } catch (Throwable throwable) {", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTI0Nw==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709247", "bodyText": "Add a private constructor to hide the implicit public one.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:13Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.InvalidSyntaxException;\n+import org.osgi.framework.ServiceReference;\n+import org.slf4j.LoggerFactory;\n+\n+import com.googlecode.gentyref.GenericTypeReflector;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.internal.AnnotationReader;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.internal.UsageStatistics;\n+import com.vaadin.flow.router.HasErrorParameter;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.startup.ClassLoaderAwareServletContainerInitializer;\n+import com.vaadin.flow.server.startup.DevModeInitializer;\n+import com.vaadin.flow.server.startup.LookupInitializer;\n+\n+import net.bytebuddy.ByteBuddy;\n+import net.bytebuddy.dynamic.DynamicType.Builder;\n+import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;\n+\n+/**\n+ * Manages scanned classes inside OSGi container.\n+ * <p>\n+ * It doesn't do anything outside of OSGi.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ *\n+ * @see #getInstance()\n+ */\n+public final class OSGiAccess {\n+    private static final OSGiAccess INSTANCE = new OSGiAccess();\n+\n+    private final ServletContext context = LazyOSGiDetector.IS_IN_OSGI\n+            ? createOSGiServletContext()\n+            : null;\n+\n+    private final AtomicReference<Collection<Class<? extends ServletContainerInitializer>>> initializerClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new AtomicReference<>()\n+            : null;\n+\n+    private final Map<Long, Collection<Class<?>>> cachedClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new ConcurrentHashMap<>()\n+            : null;\n+\n+    private OSGiAccess() {\n+        // The class is a singleton. Avoid instantiation outside of the class.\n+    }\n+\n+    private static class OsgiLookupImpl implements Lookup {\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            ServiceReference<T> reference = bundle.getBundleContext()\n+                    .getServiceReference(serviceClass);\n+            if (reference == null) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .debug(\"No service found for '{}' SPI\", serviceClass);\n+                return null;\n+            }\n+            return bundle.getBundleContext().getService(reference);\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            try {\n+                Collection<ServiceReference<T>> references = bundle\n+                        .getBundleContext()\n+                        .getServiceReferences(serviceClass, null);\n+                List<T> services = new ArrayList<>(references.size());\n+                for (ServiceReference<T> reference : references) {\n+                    T service = bundle.getBundleContext().getService(reference);\n+                    if (service != null) {\n+                        services.add(service);\n+                    }\n+                }\n+                return services;\n+            } catch (InvalidSyntaxException e) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .error(\"Unexpected invalid filter expression\", e);\n+                assert false : \"Implementation error: Unexpected invalid filter exception is \"\n+                        + \"thrown even though the service filter is null. Check the exception and update the impl\";\n+            }\n+\n+            return Collections.emptyList();\n+        }\n+\n+    }\n+\n+    /**\n+     * This is internal class and is not intended to be used.\n+     * <p>\n+     * It's public only because it needs to be proxied.\n+     * <p>\n+     * This class represents a singleton servlet context instance which is not a\n+     * real servlet context.\n+     */\n+    public abstract static class OSGiServletContext implements ServletContext {\n+\n+        private final Map<String, Object> attributes = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public void setAttribute(String name, Object object) {\n+            attributes.put(name, object);\n+        }\n+\n+        @Override\n+        public Object getAttribute(String name) {\n+            return attributes.get(name);\n+        }\n+\n+        @Override\n+        public void removeAttribute(String name) {\n+            attributes.remove(name);\n+        }\n+\n+        @Override\n+        public Enumeration<String> getAttributeNames() {\n+            return Collections.enumeration(attributes.keySet());\n+        }\n+\n+        @Override\n+        public void log(String msg) {\n+            // This method is used by Atmosphere initiailizer\n+            LoggerFactory.getLogger(OSGiAccess.class).warn(msg);\n+        }\n+\n+        @Override\n+        public String getInitParameter(String name) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Enumeration<String> getInitParameterNames() {\n+            return Collections.emptyEnumeration();\n+        }\n+\n+        @Override\n+        public Map<String, ? extends ServletRegistration> getServletRegistrations() {\n+            return Collections.emptyMap();\n+        }\n+\n+    }\n+\n+    /**\n+     * Gets the singleton instance.\n+     *\n+     * @return the singleton instance\n+     */\n+    public static OSGiAccess getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    /**\n+     * Gets a servlet context instance which is used to track registries which\n+     * are storage of scanned classes.\n+     * <p>\n+     * This is not a real servlet context. It's just a proxied unique instance\n+     * which is used to be able to access registries in a generic way via some\n+     * {@code getInstance(ServletContext)} method.\n+     *\n+     * @return an OSGi temporary servlet context\n+     */\n+    public ServletContext getOsgiServletContext() {\n+        return context;\n+    }\n+\n+    /**\n+     * Sets the discovered servlet context initializer classes.\n+     * <p>\n+     * The OSGi bundle tracker is used to scan all classes in bundles and it\n+     * also scans <b>flow-server</b> module for servlet initializer classes.\n+     * They are set using this method once they are collected.\n+     *\n+     * @param contextInitializers\n+     *            servlet context initializer classes\n+     */\n+    public void setServletContainerInitializers(\n+            Collection<Class<? extends ServletContainerInitializer>> contextInitializers) {\n+        assert contextInitializers != null;\n+        initializerClasses.set(new ArrayList<>(contextInitializers));\n+    }\n+\n+    /**\n+     * Checks whether the servlet initializers are discovered.\n+     *\n+     * @return {@code true} if servlet initializers are set, {@code false}\n+     *         otherwise\n+     */\n+    public boolean hasInitializers() {\n+        return initializerClasses.get() != null;\n+    }\n+\n+    /**\n+     * Adds scanned classes in active bundles.\n+     * <p>\n+     * The map contains a bundle id as a key and classes discovered in the\n+     * bundle as a value.\n+     *\n+     * @param extenderClasses\n+     *            a map with discovered classes in active bundles\n+     */\n+    public void addScannedClasses(\n+            Map<Long, Collection<Class<?>>> extenderClasses) {\n+        cachedClasses.putAll(extenderClasses);\n+        resetContextInitializers();\n+    }\n+\n+    /**\n+     * Removes classes from the bundle identified by the {@code bundleId}.\n+     * <p>\n+     * When a bundle becomes inactive its classes should not be used anymore.\n+     * This method removes the classes from the bundle from the collection of\n+     * discovered classes.\n+     *\n+     * @param bundleId\n+     *            the bundle identifier\n+     */\n+    public void removeScannedClasses(Long bundleId) {\n+        cachedClasses.remove(bundleId);\n+        resetContextInitializers();\n+    }\n+\n+    private void resetContextInitializers() {\n+        /*\n+         * exclude dev mode initializer (at least for now) because it doesn't\n+         * work in its current state anyway (so it's no-op) but its initial\n+         * calls breaks assumptions about Servlet registration in OSGi.\n+         * \n+         * Lookup is set immediately in the context, so no need to initialize it\n+         */\n+        initializerClasses.get().stream()\n+                .filter(clazz -> !clazz.equals(DevModeInitializer.class)\n+                        && !clazz.equals(LookupInitializer.class))\n+                .map(ReflectTools::createInstance).forEach(this::handleTypes);\n+    }\n+\n+    private void handleTypes(ServletContainerInitializer initializer) {\n+        Optional<HandlesTypes> handleTypes = AnnotationReader\n+                .getAnnotationFor(initializer.getClass(), HandlesTypes.class);\n+        /*\n+         * Every initializer should be an instance of\n+         * ClassLoaderAwareServletContainerInitializer : there is a test which\n+         * forces this. So assert should be enough here.\n+         */\n+        assert initializer instanceof ClassLoaderAwareServletContainerInitializer;\n+        try {\n+            // don't use onStartup method because a fake servlet context is\n+            // passed here: no need to detect classloaders in OSGi case\n+            ((ClassLoaderAwareServletContainerInitializer) initializer).process(\n+                    filterClasses(handleTypes.orElse(null)),\n+                    getOsgiServletContext());\n+        } catch (ServletException e) {\n+            throw new RuntimeException(\n+                    \"Couldn't run servlet context initializer \"\n+                            + initializer.getClass(),\n+                    e);\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Set<Class<?>> filterClasses(HandlesTypes typesAnnotation) {\n+        Set<Class<?>> result = new HashSet<>();\n+        if (typesAnnotation == null) {\n+            cachedClasses.forEach((bundle, classes) -> result.addAll(classes));\n+        } else {\n+            Class<?>[] requestedTypes = typesAnnotation.value();\n+\n+            Predicate<Class<?>> isAnnotation = Class::isAnnotation;\n+\n+            List<Class<? extends Annotation>> annotations = Stream\n+                    .of(requestedTypes).filter(isAnnotation)\n+                    .map(clazz -> (Class<? extends Annotation>) clazz)\n+                    .collect(Collectors.toList());\n+\n+            List<Class<?>> superTypes = Stream.of(requestedTypes)\n+                    .filter(isAnnotation.negate()).collect(Collectors.toList());\n+\n+            Predicate<Class<?>> hasType = clazz -> annotations.stream()\n+                    .anyMatch(annotation -> AnnotationReader\n+                            .getAnnotationFor(clazz, annotation).isPresent())\n+                    || superTypes.stream()\n+                            .anyMatch(superType -> GenericTypeReflector\n+                                    .isSuperType(HasErrorParameter.class,\n+                                            clazz));\n+\n+            cachedClasses.forEach((bundle, classes) -> result.addAll(classes\n+                    .stream().filter(hasType).collect(Collectors.toList())));\n+\n+        }\n+        return result;\n+    }\n+\n+    private ServletContext createOSGiServletContext() {\n+        Builder<OSGiServletContext> builder = new ByteBuddy()\n+                .subclass(OSGiServletContext.class);\n+\n+        Class<? extends OSGiServletContext> osgiServletContextClass = builder\n+                .make().load(OSGiServletContext.class.getClassLoader(),\n+                        ClassLoadingStrategy.Default.WRAPPER)\n+                .getLoaded();\n+\n+        OSGiServletContext osgiContext = ReflectTools.createProxyInstance(\n+                osgiServletContextClass, ServletContext.class);\n+\n+        new VaadinServletContext(osgiContext).setAttribute(Lookup.class,\n+                new OsgiLookupImpl());\n+\n+        return osgiContext;\n+    }\n+\n+    private static final class LazyOSGiDetector {", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTI1Mg==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709252", "bodyText": "Define and throw a dedicated exception instead of using a generic one.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:14Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/osgi/OSGiAccess.java", "diffHunk": "@@ -0,0 +1,413 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.server.osgi;\n+\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import javax.servlet.ServletContainerInitializer;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRegistration;\n+import javax.servlet.annotation.HandlesTypes;\n+\n+import org.osgi.framework.Bundle;\n+import org.osgi.framework.FrameworkUtil;\n+import org.osgi.framework.InvalidSyntaxException;\n+import org.osgi.framework.ServiceReference;\n+import org.slf4j.LoggerFactory;\n+\n+import com.googlecode.gentyref.GenericTypeReflector;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.internal.AnnotationReader;\n+import com.vaadin.flow.internal.ReflectTools;\n+import com.vaadin.flow.internal.UsageStatistics;\n+import com.vaadin.flow.router.HasErrorParameter;\n+import com.vaadin.flow.server.VaadinServletContext;\n+import com.vaadin.flow.server.startup.ClassLoaderAwareServletContainerInitializer;\n+import com.vaadin.flow.server.startup.DevModeInitializer;\n+import com.vaadin.flow.server.startup.LookupInitializer;\n+\n+import net.bytebuddy.ByteBuddy;\n+import net.bytebuddy.dynamic.DynamicType.Builder;\n+import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;\n+\n+/**\n+ * Manages scanned classes inside OSGi container.\n+ * <p>\n+ * It doesn't do anything outside of OSGi.\n+ *\n+ * @author Vaadin Ltd\n+ * @since 1.2\n+ *\n+ * @see #getInstance()\n+ */\n+public final class OSGiAccess {\n+    private static final OSGiAccess INSTANCE = new OSGiAccess();\n+\n+    private final ServletContext context = LazyOSGiDetector.IS_IN_OSGI\n+            ? createOSGiServletContext()\n+            : null;\n+\n+    private final AtomicReference<Collection<Class<? extends ServletContainerInitializer>>> initializerClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new AtomicReference<>()\n+            : null;\n+\n+    private final Map<Long, Collection<Class<?>>> cachedClasses = LazyOSGiDetector.IS_IN_OSGI\n+            ? new ConcurrentHashMap<>()\n+            : null;\n+\n+    private OSGiAccess() {\n+        // The class is a singleton. Avoid instantiation outside of the class.\n+    }\n+\n+    private static class OsgiLookupImpl implements Lookup {\n+\n+        @Override\n+        public <T> T lookup(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            ServiceReference<T> reference = bundle.getBundleContext()\n+                    .getServiceReference(serviceClass);\n+            if (reference == null) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .debug(\"No service found for '{}' SPI\", serviceClass);\n+                return null;\n+            }\n+            return bundle.getBundleContext().getService(reference);\n+        }\n+\n+        @Override\n+        public <T> Collection<T> lookupAll(Class<T> serviceClass) {\n+            Bundle bundle = FrameworkUtil.getBundle(OSGiAccess.class);\n+            try {\n+                Collection<ServiceReference<T>> references = bundle\n+                        .getBundleContext()\n+                        .getServiceReferences(serviceClass, null);\n+                List<T> services = new ArrayList<>(references.size());\n+                for (ServiceReference<T> reference : references) {\n+                    T service = bundle.getBundleContext().getService(reference);\n+                    if (service != null) {\n+                        services.add(service);\n+                    }\n+                }\n+                return services;\n+            } catch (InvalidSyntaxException e) {\n+                LoggerFactory.getLogger(OsgiLookupImpl.class)\n+                        .error(\"Unexpected invalid filter expression\", e);\n+                assert false : \"Implementation error: Unexpected invalid filter exception is \"\n+                        + \"thrown even though the service filter is null. Check the exception and update the impl\";\n+            }\n+\n+            return Collections.emptyList();\n+        }\n+\n+    }\n+\n+    /**\n+     * This is internal class and is not intended to be used.\n+     * <p>\n+     * It's public only because it needs to be proxied.\n+     * <p>\n+     * This class represents a singleton servlet context instance which is not a\n+     * real servlet context.\n+     */\n+    public abstract static class OSGiServletContext implements ServletContext {\n+\n+        private final Map<String, Object> attributes = new ConcurrentHashMap<>();\n+\n+        @Override\n+        public void setAttribute(String name, Object object) {\n+            attributes.put(name, object);\n+        }\n+\n+        @Override\n+        public Object getAttribute(String name) {\n+            return attributes.get(name);\n+        }\n+\n+        @Override\n+        public void removeAttribute(String name) {\n+            attributes.remove(name);\n+        }\n+\n+        @Override\n+        public Enumeration<String> getAttributeNames() {\n+            return Collections.enumeration(attributes.keySet());\n+        }\n+\n+        @Override\n+        public void log(String msg) {\n+            // This method is used by Atmosphere initiailizer\n+            LoggerFactory.getLogger(OSGiAccess.class).warn(msg);\n+        }\n+\n+        @Override\n+        public String getInitParameter(String name) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Enumeration<String> getInitParameterNames() {\n+            return Collections.emptyEnumeration();\n+        }\n+\n+        @Override\n+        public Map<String, ? extends ServletRegistration> getServletRegistrations() {\n+            return Collections.emptyMap();\n+        }\n+\n+    }\n+\n+    /**\n+     * Gets the singleton instance.\n+     *\n+     * @return the singleton instance\n+     */\n+    public static OSGiAccess getInstance() {\n+        return INSTANCE;\n+    }\n+\n+    /**\n+     * Gets a servlet context instance which is used to track registries which\n+     * are storage of scanned classes.\n+     * <p>\n+     * This is not a real servlet context. It's just a proxied unique instance\n+     * which is used to be able to access registries in a generic way via some\n+     * {@code getInstance(ServletContext)} method.\n+     *\n+     * @return an OSGi temporary servlet context\n+     */\n+    public ServletContext getOsgiServletContext() {\n+        return context;\n+    }\n+\n+    /**\n+     * Sets the discovered servlet context initializer classes.\n+     * <p>\n+     * The OSGi bundle tracker is used to scan all classes in bundles and it\n+     * also scans <b>flow-server</b> module for servlet initializer classes.\n+     * They are set using this method once they are collected.\n+     *\n+     * @param contextInitializers\n+     *            servlet context initializer classes\n+     */\n+    public void setServletContainerInitializers(\n+            Collection<Class<? extends ServletContainerInitializer>> contextInitializers) {\n+        assert contextInitializers != null;\n+        initializerClasses.set(new ArrayList<>(contextInitializers));\n+    }\n+\n+    /**\n+     * Checks whether the servlet initializers are discovered.\n+     *\n+     * @return {@code true} if servlet initializers are set, {@code false}\n+     *         otherwise\n+     */\n+    public boolean hasInitializers() {\n+        return initializerClasses.get() != null;\n+    }\n+\n+    /**\n+     * Adds scanned classes in active bundles.\n+     * <p>\n+     * The map contains a bundle id as a key and classes discovered in the\n+     * bundle as a value.\n+     *\n+     * @param extenderClasses\n+     *            a map with discovered classes in active bundles\n+     */\n+    public void addScannedClasses(\n+            Map<Long, Collection<Class<?>>> extenderClasses) {\n+        cachedClasses.putAll(extenderClasses);\n+        resetContextInitializers();\n+    }\n+\n+    /**\n+     * Removes classes from the bundle identified by the {@code bundleId}.\n+     * <p>\n+     * When a bundle becomes inactive its classes should not be used anymore.\n+     * This method removes the classes from the bundle from the collection of\n+     * discovered classes.\n+     *\n+     * @param bundleId\n+     *            the bundle identifier\n+     */\n+    public void removeScannedClasses(Long bundleId) {\n+        cachedClasses.remove(bundleId);\n+        resetContextInitializers();\n+    }\n+\n+    private void resetContextInitializers() {\n+        /*\n+         * exclude dev mode initializer (at least for now) because it doesn't\n+         * work in its current state anyway (so it's no-op) but its initial\n+         * calls breaks assumptions about Servlet registration in OSGi.\n+         * \n+         * Lookup is set immediately in the context, so no need to initialize it\n+         */\n+        initializerClasses.get().stream()\n+                .filter(clazz -> !clazz.equals(DevModeInitializer.class)\n+                        && !clazz.equals(LookupInitializer.class))\n+                .map(ReflectTools::createInstance).forEach(this::handleTypes);\n+    }\n+\n+    private void handleTypes(ServletContainerInitializer initializer) {\n+        Optional<HandlesTypes> handleTypes = AnnotationReader\n+                .getAnnotationFor(initializer.getClass(), HandlesTypes.class);\n+        /*\n+         * Every initializer should be an instance of\n+         * ClassLoaderAwareServletContainerInitializer : there is a test which\n+         * forces this. So assert should be enough here.\n+         */\n+        assert initializer instanceof ClassLoaderAwareServletContainerInitializer;\n+        try {\n+            // don't use onStartup method because a fake servlet context is\n+            // passed here: no need to detect classloaders in OSGi case\n+            ((ClassLoaderAwareServletContainerInitializer) initializer).process(\n+                    filterClasses(handleTypes.orElse(null)),\n+                    getOsgiServletContext());\n+        } catch (ServletException e) {\n+            throw new RuntimeException(", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTI2MQ==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709261", "bodyText": "Do not forget to remove this deprecated code someday.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:15Z", "path": "flow-server/src/main/java/com/vaadin/flow/di/Instantiator.java", "diffHunk": "@@ -63,7 +63,12 @@\n      * @return <code>true</code> if this instance should be considered as a\n      *         candidate for usage for the provided service; <code>false</code>\n      *         to opt-out from the selection process\n+     * @deprecated The {@link Instantiator} instance should be created by an\n+     *             {@link InstantiatorFactory} which should just return\n+     *             {@code null} if the provided {@code service} can't be handled\n+     *             by it\n      */\n+    @Deprecated\n     boolean init(VaadinService service);", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTI3MA==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709270", "bodyText": "Remove this use of \"Thread.sleep()\".", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:16Z", "path": "flow-server/src/test/java/com/vaadin/flow/server/webcomponent/OSGiWebComponentConfigurationRegistryTest.java", "diffHunk": "@@ -0,0 +1,148 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+\n+package com.vaadin.flow.server.webcomponent;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Random;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import com.vaadin.flow.server.osgi.OSGiAccess;\n+import com.vaadin.flow.server.startup.EnableOSGiRunner;\n+\n+import net.jcip.annotations.NotThreadSafe;\n+\n+@NotThreadSafe\n+@RunWith(EnableOSGiRunner.class)\n+public class OSGiWebComponentConfigurationRegistryTest\n+        extends WebComponentConfigurationRegistryTest {\n+\n+    @Override\n+    protected WebComponentConfigurationRegistry createRegistry() {\n+        return new OSGiWebComponentConfigurationRegistry();\n+    }\n+\n+    @Test\n+    @Override\n+    public void assertRegistryIsSingleton() {\n+        Assert.assertSame(\n+                \"OSGiWebComponentConfigurationRegistry instance should be singleton\",\n+                registry,\n+                OSGiWebComponentConfigurationRegistry.getInstance(context));\n+    }\n+\n+    @After\n+    public void cleanUpOSGi() {\n+        OSGiAccess.getInstance().getOsgiServletContext().removeAttribute(\n+                WebComponentConfigurationRegistry.class.getName());\n+    }\n+\n+    @Override\n+    @Test\n+    public void assertWebComponentRegistry() {\n+        Assert.assertEquals(\n+                OSGiWebComponentConfigurationRegistry.class.getName(),\n+                registry.getClass().getName());\n+    }\n+\n+    @Override\n+    public void setConfigurationsTwice_onlyFirstSetIsAccepted() {\n+        // OSGi accepts setting the web components multiple times.\n+        // NO-OP\n+    }\n+\n+    @Override\n+    public void setConfigurations_getConfigurationsCallDoesNotChangeSetProtection() {\n+        // OSGi accepts setting the web components multiple times.\n+        // NO-OP\n+    }\n+\n+    @Test\n+    public void setBuildersTwice_allSetsAcceptedLastSetValid() {\n+        Assert.assertFalse(\"Registry should have no configurations\",\n+                registry.hasConfigurations());\n+\n+        Assert.assertTrue(\n+                \"Registry should have accepted the \" + \"WebComponentExporters\",\n+                registry.setConfigurations(\n+                        createConfigurations(MyComponentExporter.class)));\n+\n+        Assert.assertTrue(\n+                \"OSGi registry should have accept the second set of \"\n+                        + \"WebComponentExporters.\",\n+                registry.setConfigurations(\n+                        createConfigurations(UserBoxExporter.class)));\n+\n+        Assert.assertEquals(\"Registry should contain only one builder\", 1,\n+                registry.getConfigurations().size());\n+\n+        Assert.assertEquals(\"Builder should be linked to UserBox.class\",\n+                UserBox.class, registry.getConfiguration(\"user-box\").get()\n+                        .getComponentClass());\n+\n+        Assert.assertTrue(\"Registry should have configurations\",\n+                registry.hasConfigurations());\n+    }\n+\n+    @Override\n+    public void setSameRouteValueFromDifferentThreads_ConcurrencyTest()\n+            throws InterruptedException, ExecutionException {\n+        final int THREADS = 10;\n+\n+        ExecutorService executorService = Executors.newFixedThreadPool(THREADS);\n+\n+        List<Callable<AtomicBoolean>> callables = IntStream.range(0, THREADS)\n+                .mapToObj(i -> {\n+                    Callable<AtomicBoolean> callable = () -> {\n+                        // Add random sleep for better possibility to run at\n+                        // same time\n+                        Thread.sleep(new Random().nextInt(200));", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTI3OQ==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709279", "bodyText": "Immediately return this expression instead of assigning it to the temporary variable \"resourceProvider\".", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:17Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/BootstrapHandler.java", "diffHunk": "@@ -832,20 +827,52 @@ private String getClientEngineUrl(BootstrapContext context) {\n             final boolean productionMode = context.getSession()\n                     .getConfiguration().isProductionMode();\n \n-            boolean resolveNow = !productionMode || getClientEngine() == null;\n+            ResourceProvider resourceProvider = getResourceProvider(context);\n+            String clientEngine = getClientEngine(resourceProvider);\n+            boolean resolveNow = !productionMode || clientEngine == null;\n             if (resolveNow\n-                    && ClientResourcesUtils.getResource(\"/META-INF/resources/\"\n+                    && resourceProvider.getClientResource(\"/META-INF/resources/\"\n                             + CLIENT_ENGINE_NOCACHE_FILE) != null) {\n                 return context.getUriResolver().resolveVaadinUri(\n                         \"context://\" + CLIENT_ENGINE_NOCACHE_FILE);\n             }\n \n-            if (getClientEngine() == null) {\n+            if (clientEngine == null) {\n                 throw new BootstrapException(\n                         \"Client engine file name has not been resolved during initialization\");\n             }\n             return context.getUriResolver()\n-                    .resolveVaadinUri(\"context://\" + getClientEngine());\n+                    .resolveVaadinUri(\"context://\" + clientEngine);\n+        }\n+\n+        private ResourceProvider getResourceProvider(BootstrapContext context) {\n+            ResourceProvider resourceProvider = context.getSession()", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTI4OA==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709288", "bodyText": "Do not forget to remove this deprecated code someday.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:18Z", "path": "flow-server/src/main/java/com/vaadin/flow/component/template/internal/DeprecatedPolymerPublishedEventHandler.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.template.internal;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Type;\n+\n+import com.vaadin.flow.component.Component;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Service for injecting the polymer event handler when the module is available.\n+ * \n+ * @author Vaadin Ltd\n+ * @since\n+ *\n+ * @deprecated Polymer template support is deprecated - we recommend you to use\n+ *             {@code LitTemplate} instead. Read more details from <a href=\n+ *             \"https://vaadin.com/blog/future-of-html-templates-in-vaadin\">the\n+ *             Vaadin blog.</a>\n+ */\n+@Deprecated\n+public interface DeprecatedPolymerPublishedEventHandler extends Serializable {", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTI5Nw==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709297", "bodyText": "Remove this use of \"PolymerTemplate\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:19Z", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import java.lang.reflect.Type;\n+import java.util.Optional;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.component.UI;\n+import com.vaadin.flow.component.polymertemplate.PolymerTemplate;\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.internal.StateNode;\n+import com.vaadin.flow.templatemodel.ModelType;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Polymer utilitiy class for handling polymer rpc events for @EventHandler.\n+ *\n+ * Registers {@link PolymerPublishedEventRpcHandler} as a service to make it\n+ * available in {@link Lookup} in an OSGi container. *\n+ * \n+ * @since\n+ */\n+// This is OSGi specific annotation for the class which may be used without\n+// OSGi. But RetentionPolicy.CLASS used for the annotation makes it safe to use\n+// in runtime because JVM doesn't see it.\n+@org.osgi.service.component.annotations.Component(immediate = true)\n+public class PolymerPublishedEventRpcHandler\n+        implements DeprecatedPolymerPublishedEventHandler {\n+\n+    /**\n+     * Validate that the given Component instance is a PolymerTemplate and that\n+     * the value can be converted.\n+     *\n+     * @param instance\n+     *            Component to be validated\n+     * @param argValue\n+     *            received value\n+     * @param convertedType\n+     *            target type that value should be converted to\n+     * @return true if valid template model value\n+     */\n+    @Override\n+    public boolean isTemplateModelValue(Component instance, JsonValue argValue,\n+            Class<?> convertedType) {\n+        return instance instanceof PolymerTemplate\n+                && argValue instanceof JsonObject\n+                && ((PolymerTemplate<?>) instance)", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTMwNg==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709306", "bodyText": "Remove this use of \"ModelType\"; it is deprecated. \n Remove this use of \"PolymerTemplate\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:20Z", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import java.lang.reflect.Type;\n+import java.util.Optional;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.component.UI;\n+import com.vaadin.flow.component.polymertemplate.PolymerTemplate;\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.internal.StateNode;\n+import com.vaadin.flow.templatemodel.ModelType;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Polymer utilitiy class for handling polymer rpc events for @EventHandler.\n+ *\n+ * Registers {@link PolymerPublishedEventRpcHandler} as a service to make it\n+ * available in {@link Lookup} in an OSGi container. *\n+ * \n+ * @since\n+ */\n+// This is OSGi specific annotation for the class which may be used without\n+// OSGi. But RetentionPolicy.CLASS used for the annotation makes it safe to use\n+// in runtime because JVM doesn't see it.\n+@org.osgi.service.component.annotations.Component(immediate = true)\n+public class PolymerPublishedEventRpcHandler\n+        implements DeprecatedPolymerPublishedEventHandler {\n+\n+    /**\n+     * Validate that the given Component instance is a PolymerTemplate and that\n+     * the value can be converted.\n+     *\n+     * @param instance\n+     *            Component to be validated\n+     * @param argValue\n+     *            received value\n+     * @param convertedType\n+     *            target type that value should be converted to\n+     * @return true if valid template model value\n+     */\n+    @Override\n+    public boolean isTemplateModelValue(Component instance, JsonValue argValue,\n+            Class<?> convertedType) {\n+        return instance instanceof PolymerTemplate\n+                && argValue instanceof JsonObject\n+                && ((PolymerTemplate<?>) instance)\n+                        .isSupportedClass(convertedType)\n+                && ((JsonObject) argValue).hasKey(\"nodeId\");\n+    }\n+\n+    /**\n+     * Get the template model object and type.\n+     *\n+     * @param template\n+     *            polymer template to get model from\n+     * @param argValue\n+     *            argument value\n+     * @param convertedType\n+     *            value type\n+     * @return the provided model value\n+     * @throws IllegalStateException\n+     *             if the component is not attached to the UI\n+     */\n+    @Override\n+    public Object getTemplateItem(Component template, JsonObject argValue,\n+            Type convertedType) {\n+        final Optional<UI> ui = template.getUI();\n+        if (ui.isPresent()) {\n+            StateNode node = ui.get().getInternals().getStateTree()\n+                    .getNodeById((int) argValue.getNumber(\"nodeId\"));\n+\n+            ModelType propertyType = ((PolymerTemplate<?>) template)", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTMxNw==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709317", "bodyText": "Remove this use of \"DeprecatedPolymerPublishedEventHandler\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:21Z", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import java.lang.reflect.Type;\n+import java.util.Optional;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.component.UI;\n+import com.vaadin.flow.component.polymertemplate.PolymerTemplate;\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.internal.StateNode;\n+import com.vaadin.flow.templatemodel.ModelType;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Polymer utilitiy class for handling polymer rpc events for @EventHandler.\n+ *\n+ * Registers {@link PolymerPublishedEventRpcHandler} as a service to make it\n+ * available in {@link Lookup} in an OSGi container. *\n+ * \n+ * @since\n+ */\n+// This is OSGi specific annotation for the class which may be used without\n+// OSGi. But RetentionPolicy.CLASS used for the annotation makes it safe to use\n+// in runtime because JVM doesn't see it.\n+@org.osgi.service.component.annotations.Component(immediate = true)\n+public class PolymerPublishedEventRpcHandler\n+        implements DeprecatedPolymerPublishedEventHandler {", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTMzMA==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709330", "bodyText": "Remove this use of \"PolymerTemplate\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:22Z", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PolymerPublishedEventRpcHandler.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import java.lang.reflect.Type;\n+import java.util.Optional;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.component.UI;\n+import com.vaadin.flow.component.polymertemplate.PolymerTemplate;\n+import com.vaadin.flow.component.template.internal.DeprecatedPolymerPublishedEventHandler;\n+import com.vaadin.flow.di.Lookup;\n+import com.vaadin.flow.internal.StateNode;\n+import com.vaadin.flow.templatemodel.ModelType;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Polymer utilitiy class for handling polymer rpc events for @EventHandler.\n+ *\n+ * Registers {@link PolymerPublishedEventRpcHandler} as a service to make it\n+ * available in {@link Lookup} in an OSGi container. *\n+ * \n+ * @since\n+ */\n+// This is OSGi specific annotation for the class which may be used without\n+// OSGi. But RetentionPolicy.CLASS used for the annotation makes it safe to use\n+// in runtime because JVM doesn't see it.\n+@org.osgi.service.component.annotations.Component(immediate = true)\n+public class PolymerPublishedEventRpcHandler\n+        implements DeprecatedPolymerPublishedEventHandler {\n+\n+    /**\n+     * Validate that the given Component instance is a PolymerTemplate and that\n+     * the value can be converted.\n+     *\n+     * @param instance\n+     *            Component to be validated\n+     * @param argValue\n+     *            received value\n+     * @param convertedType\n+     *            target type that value should be converted to\n+     * @return true if valid template model value\n+     */\n+    @Override\n+    public boolean isTemplateModelValue(Component instance, JsonValue argValue,\n+            Class<?> convertedType) {\n+        return instance instanceof PolymerTemplate", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTMzOQ==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709339", "bodyText": "Define and throw a dedicated exception instead of using a generic one.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:23Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/HandlerHelper.java", "diffHunk": "@@ -176,4 +189,26 @@ public static String getCancelingRelativePath(String pathToCancel) {\n         return sb.toString();\n     }\n \n+    /**\n+     * Checks if the given URL path contains the directory change instruction\n+     * (dot-dot), taking into account possible double encoding in hexadecimal\n+     * format, which can be injected maliciously.\n+     *\n+     * @param path\n+     *            the URL path to be verified.\n+     * @return {@code true}, if the given path has a directory change\n+     *         instruction, {@code false} otherwise.\n+     */\n+    public static boolean isPathUnsafe(String path) {\n+        // Check that the path does not have '/../', '\\..\\', %5C..%5C,\n+        // %2F..%2F, nor '/..', '\\..', %5C.., %2F..\n+        try {\n+            path = URLDecoder.decode(path, StandardCharsets.UTF_8.name());\n+        } catch (UnsupportedEncodingException e) {\n+            throw new RuntimeException(\"An error occurred during decoding URL.\",", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzcwOTM0Nw==", "url": "https://github.com/vaadin/flow/pull/9454#discussion_r527709347", "bodyText": "Remove this use of \"DeprecatedPolymerPublishedEventHandler\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-11-20T14:01:24Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -280,50 +284,36 @@ private static Object decodeArg(Component instance, Method method,\n         // the model\n         assert argValue != null;\n         if (type.isPrimitive() && argValue.getType() == JsonType.NULL) {\n-            String msg = String\n-                    .format(\"Null values are not allowed for primitive types but \"\n-                                    + \"a 'null' value was received for parameter %d \"\n-                                    + \"which refers to primitive type '%s' \"\n-                                    + \"in the method '%s' defined in the class '%s'\",\n-                            index, type.getName(), method.getName(),\n-                            method.getDeclaringClass().getName());\n+            String msg = String.format(\n+                    \"Null values are not allowed for primitive types but \"\n+                            + \"a 'null' value was received for parameter %d \"\n+                            + \"which refers to primitive type '%s' \"\n+                            + \"in the method '%s' defined in the class '%s'\",\n+                    index, type.getName(), method.getName(),\n+                    method.getDeclaringClass().getName());\n             throw new IllegalArgumentException(msg);\n         } else if (type.isArray()) {\n             return decodeArray(method, type, index, argValue);\n         } else {\n             Class<?> convertedType = ReflectTools.convertPrimitiveType(type);\n \n-            try {\n-                final Class<?> polymerUtil = PublishedServerEventHandlerRpcHandler.class\n-                        .getClassLoader().loadClass(\n-                                \"com.vaadin.flow.component.polymertemplate.rpc.PublishedEventRpcHandlerUtil\");\n-                if ((Boolean) polymerUtil\n-                        .getMethod(\"isTemplateModelValue\", Component.class,\n-                                JsonValue.class, Class.class)\n-                        .invoke(polymerUtil, instance, argValue,\n-                                convertedType)) {\n-                    return polymerUtil\n-                            .getMethod(\"getTemplateItem\", Component.class,\n-                                    JsonObject.class, Type.class)\n-                            .invoke(polymerUtil, instance, argValue,\n-                                    method.getGenericParameterTypes()[index]);\n+            if (instance != null) {\n+                Optional<UI> ui = instance.getUI();\n+                if (!ui.isPresent()) {\n+                    throw new IllegalStateException(\n+                            \"Rpc handler may not be called for a detached component\");\n+                }\n+                VaadinContext context = ui.get().getSession().getService()\n+                        .getContext();\n+                DeprecatedPolymerPublishedEventHandler handler = context", "originalCommit": "bbac127625d7ff9be7e18a5911d9258d5d4ac268", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}