{"pr_number": 9155, "pr_title": "4.0 cherry pick", "pr_createdAt": "2020-10-09T18:55:17Z", "pr_url": "https://github.com/vaadin/flow/pull/9155", "timeline": [{"oid": "923c38e0ca6f13cc1859bf632e9a6598716f3024", "url": "https://github.com/vaadin/flow/commit/923c38e0ca6f13cc1859bf632e9a6598716f3024", "message": "fix: store app shell title into UI instead of AppShellRegistry (#9133)\n\n* fix: store app shell title into UI instead of AppShellRegistry\n\n* fix compile errors after merge\n\n* apply code review suggestions\n\n* add IT tests, apply code review suggestions\n\n* verify document.title was updated on the client-side\n\n* fix typo", "committedDate": "2020-10-09T18:53:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY1MDY3OA==", "url": "https://github.com/vaadin/flow/pull/9155#discussion_r502650678", "bodyText": "Do not forget to remove this deprecated code someday.", "author": "vaadin-bot", "createdAt": "2020-10-09T20:13:42Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/AppShellRegistry.java", "diffHunk": "@@ -163,12 +161,16 @@ public boolean isShell(Class<?> clz) {\n     }\n \n     /**\n-     * Return the text content of the title tag in the application shell.\n-     *\n-     * @return title;\n+     * @return {code null};\n+     * \n+     * @deprecated this method does not work, to get the application shell title, \n+     * use {code UI.getCurrent().getInternals().getAppShellTitle()} instead.\n      */\n+    @Deprecated\n     public String getTitle() {", "originalCommit": "923c38e0ca6f13cc1859bf632e9a6598716f3024", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f6e112950a6a4929cfbaa957bbdd1375a9e1dc5f", "url": "https://github.com/vaadin/flow/commit/f6e112950a6a4929cfbaa957bbdd1375a9e1dc5f", "message": "chore: bump junit from 4.12 to 4.13.1 (#9162)\n\nBumps [junit](https://github.com/junit-team/junit4) from 4.12 to 4.13.1.\r\n- [Release notes](https://github.com/junit-team/junit4/releases)\r\n- [Changelog](https://github.com/junit-team/junit4/blob/main/doc/ReleaseNotes4.12.md)\r\n- [Commits](https://github.com/junit-team/junit4/compare/r4.12...r4.13.1)\r\n\r\nSigned-off-by: dependabot[bot] <support@github.com>\r\n\r\nCo-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>", "committedDate": "2020-10-16T07:42:18Z", "type": "commit"}, {"oid": "f6f7c3fef198f3481c0762b1eaf1b24024e16e0c", "url": "https://github.com/vaadin/flow/commit/f6f7c3fef198f3481c0762b1eaf1b24024e16e0c", "message": "chore: bump httpclient to 4.5.13 (#9176)\n\nFixes #9173", "committedDate": "2020-10-16T07:42:29Z", "type": "commit"}, {"oid": "1d4b47923dcb22f7dbbe052dd47f789d48bb575e", "url": "https://github.com/vaadin/flow/commit/1d4b47923dcb22f7dbbe052dd47f789d48bb575e", "message": "fix: update development plugins (#9190)\n\n* fix: update copy-webpack-plugin\r\n\r\nUpdate the copy-webpack-plugin due to a found\r\nvulnerability in the old version.\r\n\r\nFixes #9189\r\n\r\n* Update dev server to fix yargs-parser security vulnerability", "committedDate": "2020-10-16T07:43:00Z", "type": "commit"}, {"oid": "5759e24e49b2dcfaba01869a3d95407baf71e7f2", "url": "https://github.com/vaadin/flow/commit/5759e24e49b2dcfaba01869a3d95407baf71e7f2", "message": "fix: only register endpoint request handler when endpoint presents (#9172)\n\nFor a non-boot Spring application or a Spring Boot application with auto-configuration disabled (e.g. when using `@EnableWebMvc`), Vaadin registers a request handler with mapping `/{endpoint}/{method}`. Note the connect prefix is not added in this case, since it relies on Spring Boot auto-configuraiton.\r\n\r\nSo it's better for users who are using endpoints, we don't register the endpoint request handler.\r\n\r\nTest is in https://github.com/vaadin/spring/pull/672", "committedDate": "2020-10-16T16:46:15Z", "type": "commit"}, {"oid": "60be63eec2353710e72479585174544682c35e74", "url": "https://github.com/vaadin/flow/commit/60be63eec2353710e72479585174544682c35e74", "message": "Revert \"fix: only register endpoint request handler when endpoint presents (#9172)\" (#9201)\n\nThis reverts commit 474e760d9fe3aa391ee405dec869ac6b6989cd37.", "committedDate": "2020-10-21T08:51:17Z", "type": "commit"}, {"oid": "9f0aee674bfa07f2b6ac6cfad256931002211bb2", "url": "https://github.com/vaadin/flow/commit/9f0aee674bfa07f2b6ac6cfad256931002211bb2", "message": "fix: register endpoint controller only when there are endpoints (#9208)", "committedDate": "2020-10-21T08:52:09Z", "type": "commit"}, {"oid": "d2c1311284fdfdd4d3d267a6285f3689bc75aefc", "url": "https://github.com/vaadin/flow/commit/d2c1311284fdfdd4d3d267a6285f3689bc75aefc", "message": "feat: add support for Range header to StaticFileServer (#9154)\n\nA Range header can specify either a single byte range, e.g. Range: bytes=0-99, or multiple ranges,\r\ne.g. Range: bytes=0-99, 200-299. The ranges do not need to be sequential and can have overlap;\r\ne.g. Range: bytes=200-299, 0-219 is valid; such requests will open a new stream reading from the\r\nbeginning of the file for each out-of-order range. The motivation for this feature is to support video\r\nplayback on Safari.\r\n\r\nFixes #9083", "committedDate": "2020-10-21T09:14:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE3MDA4Nw==", "url": "https://github.com/vaadin/flow/pull/9155#discussion_r509170087", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL)", "author": "vaadin-bot", "createdAt": "2020-10-21T10:33:36Z", "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -122,31 +132,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n             }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());\n+                long start = rangePair.getFirst();\n+                long end = rangePair.getSecond();\n+                if (mimeType != null) {\n+                    outputStream.write(\n+                            String.format(\"Content-Type: %s\\r\\n\", mimeType)\n+                                    .getBytes());\n+                }\n+                outputStream.write(String\n+                        .format(\"Content-Range: %s\\r\\n\\r\\n\",\n+                                createContentRangeHeader(start, end,\n+                                        connection.getContentLengthLong()))\n+                        .getBytes());\n+\n+                if (position > start) {\n+                    // out-of-sequence range -> open new stream to the file\n+                    // alternative: use single stream with mark / reset\n+                    closeStream(connection.getInputStream());\n+                    connection = resourceURL.openConnection();\n+                    dataStream = connection.getInputStream();\n+                    position = 0L;\n+                }\n+                long skipped = dataStream.skip(start - position);\n+                assert(skipped == start - position);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+                position = end + 1;\n+            }\n+        } finally {\n+            closeStream(dataStream);\n+        }\n+        outputStream.write(String.format(\"\\r\\n--%s\", partBoundary).getBytes());", "originalCommit": "d2c1311284fdfdd4d3d267a6285f3689bc75aefc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE3MDA5NA==", "url": "https://github.com/vaadin/flow/pull/9155#discussion_r509170094", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL) \n Found reliance on default encoding in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL): String.getBytes()", "author": "vaadin-bot", "createdAt": "2020-10-21T10:33:37Z", "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -122,31 +132,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n             }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());", "originalCommit": "d2c1311284fdfdd4d3d267a6285f3689bc75aefc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE3MDEwNg==", "url": "https://github.com/vaadin/flow/pull/9155#discussion_r509170106", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL)", "author": "vaadin-bot", "createdAt": "2020-10-21T10:33:38Z", "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -122,31 +132,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n             }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());\n+                long start = rangePair.getFirst();\n+                long end = rangePair.getSecond();\n+                if (mimeType != null) {\n+                    outputStream.write(\n+                            String.format(\"Content-Type: %s\\r\\n\", mimeType)", "originalCommit": "d2c1311284fdfdd4d3d267a6285f3689bc75aefc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTE3MDExNg==", "url": "https://github.com/vaadin/flow/pull/9155#discussion_r509170116", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL)", "author": "vaadin-bot", "createdAt": "2020-10-21T10:33:39Z", "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -122,31 +132,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n             }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());\n+                long start = rangePair.getFirst();\n+                long end = rangePair.getSecond();\n+                if (mimeType != null) {\n+                    outputStream.write(\n+                            String.format(\"Content-Type: %s\\r\\n\", mimeType)\n+                                    .getBytes());\n+                }\n+                outputStream.write(String\n+                        .format(\"Content-Range: %s\\r\\n\\r\\n\",", "originalCommit": "d2c1311284fdfdd4d3d267a6285f3689bc75aefc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}