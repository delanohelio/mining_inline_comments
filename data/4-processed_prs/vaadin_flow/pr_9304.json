{"pr_number": 9304, "pr_title": "deferred call submission status API refactor", "pr_createdAt": "2020-11-03T14:04:12Z", "pr_url": "https://github.com/vaadin/flow/pull/9304", "timeline": [{"oid": "3727b48a9352bd7965914ffc6a66a21f939c896c", "url": "https://github.com/vaadin/flow/commit/3727b48a9352bd7965914ffc6a66a21f939c896c", "message": "a dummy test to check if bender works", "committedDate": "2020-10-26T11:27:20Z", "type": "commit"}, {"oid": "3fc92155af2eec32a79e05a569df0482f961364e", "url": "https://github.com/vaadin/flow/commit/3fc92155af2eec32a79e05a569df0482f961364e", "message": "more change to trigger snapshot build", "committedDate": "2020-10-26T11:29:25Z", "type": "commit"}, {"oid": "74ec75925361a5834752f7fcf3b6d6870ebc19df", "url": "https://github.com/vaadin/flow/commit/74ec75925361a5834752f7fcf3b6d6870ebc19df", "message": "use an interface instead of a callback function for handling deferred calls.", "committedDate": "2020-10-26T14:08:45Z", "type": "commit"}, {"oid": "280200774467585edea8fcce127c63acb012d05d", "url": "https://github.com/vaadin/flow/commit/280200774467585edea8fcce127c63acb012d05d", "message": "feat: use command", "committedDate": "2020-10-27T09:25:49Z", "type": "commit"}, {"oid": "2b923726688a65826740911a8296a04055f1478d", "url": "https://github.com/vaadin/flow/commit/2b923726688a65826740911a8296a04055f1478d", "message": "use a DeferedCall class", "committedDate": "2020-10-27T10:37:00Z", "type": "commit"}, {"oid": "d7387c3c48f6e0cbbf3d075c7a9575c4c6804a91", "url": "https://github.com/vaadin/flow/commit/d7387c3c48f6e0cbbf3d075c7a9575c4c6804a91", "message": "Merge branch 'feature/offline' into deferred-call-refactor", "committedDate": "2020-10-29T12:14:35Z", "type": "commit"}, {"oid": "62de8097b5fcc615e063e2f2b251efe4098d64fe", "url": "https://github.com/vaadin/flow/commit/62de8097b5fcc615e063e2f2b251efe4098d64fe", "message": "split offline related to a separate file", "committedDate": "2020-10-30T20:17:55Z", "type": "commit"}, {"oid": "1f98b5f478a9735275e754ab81d80361d1a96813", "url": "https://github.com/vaadin/flow/commit/1f98b5f478a9735275e754ab81d80361d1a96813", "message": "add more tests", "committedDate": "2020-11-02T21:41:44Z", "type": "commit"}, {"oid": "d20bad7128fcdabc2dd7081a79ce3b8059174159", "url": "https://github.com/vaadin/flow/commit/d20bad7128fcdabc2dd7081a79ce3b8059174159", "message": "refactor", "committedDate": "2020-11-03T09:47:47Z", "type": "commit"}, {"oid": "03a3d6631f71e5b237b5a6dccfb25dc0cb6ea436", "url": "https://github.com/vaadin/flow/commit/03a3d6631f71e5b237b5a6dccfb25dc0cb6ea436", "message": "export Offline", "committedDate": "2020-11-03T09:48:38Z", "type": "commit"}, {"oid": "776daba238494b2ae485cfa2d3aa26f3a1feeeee", "url": "https://github.com/vaadin/flow/commit/776daba238494b2ae485cfa2d3aa26f3a1feeeee", "message": "renaming", "committedDate": "2020-11-03T10:00:18Z", "type": "commit"}, {"oid": "8a97a37d6c5e62905f5cf10e4395dbb539ef580c", "url": "https://github.com/vaadin/flow/commit/8a97a37d6c5e62905f5cf10e4395dbb539ef580c", "message": "rename", "committedDate": "2020-11-03T10:35:50Z", "type": "commit"}, {"oid": "3ba57e7eead3c475db04b104f27ae0ed591a46ef", "url": "https://github.com/vaadin/flow/commit/3ba57e7eead3c475db04b104f27ae0ed591a46ef", "message": "more renaming", "committedDate": "2020-11-03T11:04:35Z", "type": "commit"}, {"oid": "bc4ec3029fc0a35c78803f638d7e84ee71d74aac", "url": "https://github.com/vaadin/flow/commit/bc4ec3029fc0a35c78803f638d7e84ee71d74aac", "message": "Merge remote-tracking branch 'origin/feature/offline' into deferred-call-refactor", "committedDate": "2020-11-03T13:51:29Z", "type": "commit"}, {"oid": "c88146ad8ffc137d73cf70b99e21262a26f3bc15", "url": "https://github.com/vaadin/flow/commit/c88146ad8ffc137d73cf70b99e21262a26f3bc15", "message": "code format", "committedDate": "2020-11-03T14:07:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIxNjE5NA==", "url": "https://github.com/vaadin/flow/pull/9304#discussion_r517216194", "bodyText": "Typo (deferrecCall), should be deferrableCall or omitted", "author": "joheriks", "createdAt": "2020-11-04T09:45:10Z", "path": "flow-client/src/test/frontend/OfflineTests.ts", "diffHunk": "@@ -0,0 +1,532 @@\n+/* tslint:disable: no-unused-expression */\n+const { describe, it, beforeEach, afterEach, after } = intern.getPlugin('interface.bdd');\n+const { expect } = intern.getPlugin('chai');\n+const { fetchMock } = intern.getPlugin('fetchMock');\n+const { sinon } = intern.getPlugin('sinon');\n+\n+import {\n+  ConnectClient,\n+} from \"../../main/resources/META-INF/resources/frontend/Connect\";\n+\n+import { openDB } from \"idb\";\n+import { DeferredCallSubmitter, OfflineHelper } from \"../../main/resources/META-INF/resources/frontend/Offline\";\n+\n+const VAADIN_DEFERRED_CALL_QUEUE_DB_NAME = 'vaadin-deferred-call-queue';\n+const VAADIN_DEFERRED_CALL_STORE_NAME = 'deferredCalls';\n+\n+// `connectClient.call` adds the host and context to the endpoint request.\n+// we need to add this origin when configuring fetch-mock\n+const base = window.location.origin;\n+const offline = new OfflineHelper();\n+describe(\"Offline\", () => {\n+  beforeEach(() => localStorage.clear());\n+\n+  after(() => {\n+    // @ts-ignore\n+    delete window.Vaadin;\n+  });\n+\n+  describe(\"Defer Request\", () => {\n+    let client: ConnectClient;\n+\n+    beforeEach(() => {\n+      client = new ConnectClient();\n+    });\n+\n+    afterEach(() => {\n+      sinon.restore();\n+      fetchMock.restore();\n+    });\n+\n+    it(\"Should return a DeferrableResult that retains request meta when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\").callsFake((deferredCall: any) => {\n+        if (!deferredCall.id) {\n+          deferredCall.id = 100;\n+        }\n+        return { isDeferred: true, deferredCall };\n+      });\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(result.isDeferred).to.be.true;\n+      expect(result.deferredCall?.endpoint).to.equal('FooEndpoint');\n+      expect(result.deferredCall?.method).to.equal('fooMethod');\n+      expect(result.deferredCall?.params?.fooData).to.equal('foo');\n+    })\n+\n+    it(\"Should cache the endpoint call when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      const db = await openDB(VAADIN_DEFERRED_CALL_QUEUE_DB_NAME);\n+      const cachedRequest = await db.get(VAADIN_DEFERRED_CALL_STORE_NAME, result.deferredCall?.id as number);\n+\n+      expect(cachedRequest.endpoint).to.equal('FooEndpoint');\n+      expect(cachedRequest.method).to.equal('fooMethod');\n+      expect(cachedRequest.params?.fooData).to.equal('foo');\n+\n+      await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+      db.close();\n+    })\n+\n+    it(\"Should not invoke the client.call method when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const callMethod = sinon.stub(client, \"call\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(callMethod.called).to.be.false;\n+    })\n+\n+    it(\"Should invoke the client.call method when invoking deferRequest online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      const callMethod = sinon.stub(client, \"call\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(callMethod.called).to.be.true;\n+    })\n+\n+    it(\"Should not invoke the client.storeDeferredCall method when invoking deferRequest online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      const storeDeferredCallMock = sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(storeDeferredCallMock.called).to.be.false;\n+    })\n+\n+    it(\"should return false when checking the isDefered prooperty of the return value of invoking deferRequest method online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(result.isDeferred).to.be.false;\n+    })\n+\n+    it(\"should return undefined when checking the endpointRequest prooperty of the return value of invoking deferRequest method offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const returnValue = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(returnValue.deferredCall).to.be.undefined;\n+    })\n+\n+    it(\"should defer endpoint call when server is not reachable even though browser is online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      const storeDeferredCall = sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+      fetchMock.post(\n+        base + '/connect/FooEndpoint/fooMethod',\n+        Promise.reject(new TypeError('Failed to fetch'))\n+      )\n+  \n+      await client.deferrableCall('FooEndpoint', 'fooMethod');\n+  \n+      expect(storeDeferredCall.called).to.be.true;\n+    })\n+  \n+    it(\"should NOT defer endpoint call when server return error\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+      const body = 'Unexpected error';\n+      const errorResponse = new Response(\n+        body,\n+        {\n+          status: 500,\n+          statusText: 'Internal Server Error'\n+        }\n+      );\n+      fetchMock.post(base + '/connect/FooEndpoint/fooMethod', errorResponse);\n+  \n+      try {\n+        await client.deferrableCall('FooEndpoint', 'fooMethod');\n+      } catch (error) {\n+        expect(error).to.be.instanceOf(Error)\n+          .and.have.property('message').that.has.string('Unexpected error');\n+      }\n+    })\n+  });\n+\n+  describe(\"submit deferred calls\", () => {\n+    let client: ConnectClient;\n+    let requestCallStub: any;\n+\n+    function fakeRequestCallFails() {\n+      requestCallStub.callsFake(() => {\n+        throw new Error();\n+      });\n+    }\n+\n+    async function insertARequest(numberOfRequests = 1) {\n+      const db = await (offline as any).openOrCreateDB();\n+      for (let i = 0; i < numberOfRequests; i++) {\n+        await db.put(VAADIN_DEFERRED_CALL_STORE_NAME, { endpoint: 'FooEndpoint', method: 'fooMethod', params: { fooData: 'foo' } });\n+      }\n+      expect(await db.count(VAADIN_DEFERRED_CALL_STORE_NAME)).to.equal(numberOfRequests);\n+      db.close();\n+    }\n+\n+    async function verifyNumberOfRequsetsInTheQueue(numberOfRequests = 1) {\n+      const db = await (offline as any).openOrCreateDB();\n+      expect(await db.count(VAADIN_DEFERRED_CALL_STORE_NAME)).to.equal(numberOfRequests);\n+      db.close();\n+    }\n+\n+    beforeEach(async () => {\n+      client = new ConnectClient();\n+      requestCallStub = sinon.stub(client, 'requestCall').callsFake(async () => {\n+        await new Promise(resolve => setTimeout(resolve, 10))\n+      });\n+    });\n+\n+    afterEach(async () => {\n+      const db = await (offline as any).openOrCreateDB();\n+      await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+      db.close();\n+      fetchMock.restore();\n+    });\n+\n+    it(\"should check and submit the cached requests when receiving online event\", () => {\n+      const submitMethod = sinon.stub(ConnectClient.prototype, \"submitDeferredCalls\");\n+      client = new ConnectClient();\n+      self.dispatchEvent(new Event('online'));\n+      expect(submitMethod.called).to.be.true;\n+      submitMethod.restore();\n+    })\n+\n+    it(\"should submit the cached request when receiving online event\", async () => {\n+      await insertARequest(3);\n+\n+      await client.submitDeferredCalls();\n+\n+      await verifyNumberOfRequsetsInTheQueue(0);\n+    })\n+\n+    it(\"should keep the request if submission fails\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+      }\n+    });\n+\n+    it('should reject if submission fails', async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      let errors: Error[] | undefined;\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+        errors = e;\n+      }\n+\n+      expect(errors?.length).to.equal(1);\n+    });\n+\n+    it(\"should be able to resubmit cached request that was failed to submit\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+\n+        requestCallStub.restore();\n+        sinon.stub(client, \"requestCall\");\n+\n+        await client.submitDeferredCalls();\n+\n+        await verifyNumberOfRequsetsInTheQueue(0);\n+      }\n+    });\n+\n+    it(\"should only submit once when receiving multiple online events\", async () => {\n+      await insertARequest();\n+\n+      await Promise.all([\n+        client.submitDeferredCalls(),\n+        client.submitDeferredCalls(),\n+        client.submitDeferredCalls()\n+      ])\n+\n+      expect(requestCallStub.calledOnce).to.be.true;\n+    })\n+\n+    it(\"should only submit once when receiving multiple online events after a failed submission\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+\n+        requestCallStub.restore();\n+        sinon.stub(client, \"requestCall\");\n+\n+        await Promise.all([\n+          client.submitDeferredCalls(),\n+          client.submitDeferredCalls(),\n+          client.submitDeferredCalls()\n+        ])\n+\n+        expect(requestCallStub.calledOnce).to.be.true;\n+      }\n+    });\n+\n+    it('should invoke middleware with isDeferred context', async () => {\n+      fetchMock.post(base + '/connect/FooEndpoint/fooMethod', { fooData: 'foo' });\n+\n+      requestCallStub.restore();\n+\n+      const spyMiddleware = sinon.spy(async (context: any, next?: any) => {\n+        expect(context.endpoint).to.equal('FooEndpoint');\n+        expect(context.method).to.equal('fooMethod');\n+        expect(context.params).to.deep.equal({ fooData: 'foo' });\n+        expect(context.request).to.be.instanceOf(Request);\n+        expect(context.isDeferred).to.be.true;\n+        return next(context);\n+      });\n+      client.middlewares = [spyMiddleware];\n+\n+      try {\n+        await insertARequest();\n+\n+        expect(spyMiddleware.called).to.be.false;\n+\n+        await client.submitDeferredCalls();\n+\n+        expect(spyMiddleware.called).to.be.true;\n+      } finally {\n+        fetchMock.restore();\n+      }\n+    });\n+\n+    it('should invoke deferredCallHandler', async () => {\n+      await insertARequest();\n+\n+      const onDeferredCallStub = sinon.stub().resolves();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };\n+\n+      await client.submitDeferredCalls();\n+\n+      expect(onDeferredCallStub.callCount).to.equal(1);\n+      const [call] = onDeferredCallStub.getCall(0).args;\n+      expect(call.deferredCall.endpoint).to.equal('FooEndpoint');\n+      expect(call.deferredCall.method).to.equal('fooMethod');\n+      expect(call.deferredCall.params).to.deep.equal({ fooData: 'foo' });\n+\n+      await verifyNumberOfRequsetsInTheQueue(0);\n+    });\n+\n+    it('should reject if onDeferredCall callback rejects', async () => {\n+      const onDeferredCallStub = sinon.stub().rejects();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };\n+\n+      let errors: Error[] | undefined;\n+\n+      try {\n+        await insertARequest();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+        errors = e;\n+      } finally {\n+        expect(errors?.length).to.equal(1);\n+      }\n+    });\n+\n+    it('should keep request in the queue when onDeferredCall callback rejects', async () => {\n+      const onDeferredCallStub = sinon.stub().rejects();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };;\n+  \n+      try {\n+        await insertARequest();\n+        await client.submitDeferredCalls();\n+      } catch(_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+      }\n+    });\n+\n+    it('should set submitting status to false for all the request in the queue', async () => {\n+      try {\n+        await insertARequest(2);\n+        fakeRequestCallFails();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+      } finally {\n+        verifyNumberOfRequsetsInTheQueue(2)\n+        const db = await openDB(VAADIN_DEFERRED_CALL_QUEUE_DB_NAME);\n+        let cursor = await db.transaction(VAADIN_DEFERRED_CALL_STORE_NAME).store.openCursor();\n+        while (cursor) {\n+          expect(cursor.value.submitting).to.be.false;\n+          cursor = await cursor.continue();\n+        }\n+        await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+        db.close;\n+      }\n+    });\n+\n+    it('should submit all the endpoint calls in the queue even errors are encountered when submitting some calls', async () => {\n+      try {\n+        await insertARequest(3);\n+        fakeRequestCallFails();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+      } finally {\n+        expect(requestCallStub.callCount).to.equal(3);\n+        verifyNumberOfRequsetsInTheQueue(3)\n+      }\n+    });\n+\n+    describe('deferred call handler', () => {\n+      it('should be able to show a notification when a deferred call submission succeeds', async () => {\n+        const notifyOnSucess = sinon.stub();\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+            notifyOnSucess();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          await client.submitDeferredCalls();\n+        } finally {\n+          expect(notifyOnSucess.calledOnce).to.be.true;\n+        }\n+      });\n+\n+      it('should be able to show a notification when deferred call submission fails', async () => {\n+        const notifyOnFailure = sinon.stub();\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            try {\n+              await deferrableCall.submit();\n+            } catch (error) {\n+              notifyOnFailure();\n+            }\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          fakeRequestCallFails()\n+          await client.submitDeferredCalls();\n+        } finally {\n+          expect(notifyOnFailure.calledOnce).to.be.true;\n+        }\n+      });\n+\n+      it('should remove a succeeded endpoint call from the queue by default', async () => {\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          await client.submitDeferredCalls();\n+        } finally {\n+          await verifyNumberOfRequsetsInTheQueue(0);\n+        }\n+      });\n+\n+      it('should keep a failed endpoint in the queue by default', async () => {\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          fakeRequestCallFails();\n+          await client.submitDeferredCalls();\n+        } catch (_) {\n+          // expected\n+        } finally {\n+          await verifyNumberOfRequsetsInTheQueue(1);\n+        }\n+      });\n+\n+      it('should remove a failed endpoint call from the queue when user catches the error without calling deferrecCall.keepInTheQueue()', async () => {", "originalCommit": "c88146ad8ffc137d73cf70b99e21262a26f3bc15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI2MTAxMQ==", "url": "https://github.com/vaadin/flow/pull/9304#discussion_r517261011", "bodyText": "done", "author": "haijian-vaadin", "createdAt": "2020-11-04T10:57:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIxNjE5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIxNjI2Nw==", "url": "https://github.com/vaadin/flow/pull/9304#discussion_r517216267", "bodyText": "Typo (deferrecCall), should be deferrableCall or omitted.", "author": "joheriks", "createdAt": "2020-11-04T09:45:17Z", "path": "flow-client/src/test/frontend/OfflineTests.ts", "diffHunk": "@@ -0,0 +1,532 @@\n+/* tslint:disable: no-unused-expression */\n+const { describe, it, beforeEach, afterEach, after } = intern.getPlugin('interface.bdd');\n+const { expect } = intern.getPlugin('chai');\n+const { fetchMock } = intern.getPlugin('fetchMock');\n+const { sinon } = intern.getPlugin('sinon');\n+\n+import {\n+  ConnectClient,\n+} from \"../../main/resources/META-INF/resources/frontend/Connect\";\n+\n+import { openDB } from \"idb\";\n+import { DeferredCallSubmitter, OfflineHelper } from \"../../main/resources/META-INF/resources/frontend/Offline\";\n+\n+const VAADIN_DEFERRED_CALL_QUEUE_DB_NAME = 'vaadin-deferred-call-queue';\n+const VAADIN_DEFERRED_CALL_STORE_NAME = 'deferredCalls';\n+\n+// `connectClient.call` adds the host and context to the endpoint request.\n+// we need to add this origin when configuring fetch-mock\n+const base = window.location.origin;\n+const offline = new OfflineHelper();\n+describe(\"Offline\", () => {\n+  beforeEach(() => localStorage.clear());\n+\n+  after(() => {\n+    // @ts-ignore\n+    delete window.Vaadin;\n+  });\n+\n+  describe(\"Defer Request\", () => {\n+    let client: ConnectClient;\n+\n+    beforeEach(() => {\n+      client = new ConnectClient();\n+    });\n+\n+    afterEach(() => {\n+      sinon.restore();\n+      fetchMock.restore();\n+    });\n+\n+    it(\"Should return a DeferrableResult that retains request meta when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\").callsFake((deferredCall: any) => {\n+        if (!deferredCall.id) {\n+          deferredCall.id = 100;\n+        }\n+        return { isDeferred: true, deferredCall };\n+      });\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(result.isDeferred).to.be.true;\n+      expect(result.deferredCall?.endpoint).to.equal('FooEndpoint');\n+      expect(result.deferredCall?.method).to.equal('fooMethod');\n+      expect(result.deferredCall?.params?.fooData).to.equal('foo');\n+    })\n+\n+    it(\"Should cache the endpoint call when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      const db = await openDB(VAADIN_DEFERRED_CALL_QUEUE_DB_NAME);\n+      const cachedRequest = await db.get(VAADIN_DEFERRED_CALL_STORE_NAME, result.deferredCall?.id as number);\n+\n+      expect(cachedRequest.endpoint).to.equal('FooEndpoint');\n+      expect(cachedRequest.method).to.equal('fooMethod');\n+      expect(cachedRequest.params?.fooData).to.equal('foo');\n+\n+      await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+      db.close();\n+    })\n+\n+    it(\"Should not invoke the client.call method when invoking deferRequest offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => false);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const callMethod = sinon.stub(client, \"call\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(callMethod.called).to.be.false;\n+    })\n+\n+    it(\"Should invoke the client.call method when invoking deferRequest online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      const callMethod = sinon.stub(client, \"call\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(callMethod.called).to.be.true;\n+    })\n+\n+    it(\"Should not invoke the client.storeDeferredCall method when invoking deferRequest online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      const storeDeferredCallMock = sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(storeDeferredCallMock.called).to.be.false;\n+    })\n+\n+    it(\"should return false when checking the isDefered prooperty of the return value of invoking deferRequest method online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const result = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(result.isDeferred).to.be.false;\n+    })\n+\n+    it(\"should return undefined when checking the endpointRequest prooperty of the return value of invoking deferRequest method offline\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(client, \"call\");\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+\n+      const returnValue = await client.deferrableCall('FooEndpoint', 'fooMethod', { fooData: 'foo' });\n+\n+      expect(returnValue.deferredCall).to.be.undefined;\n+    })\n+\n+    it(\"should defer endpoint call when server is not reachable even though browser is online\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      const storeDeferredCall = sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+      fetchMock.post(\n+        base + '/connect/FooEndpoint/fooMethod',\n+        Promise.reject(new TypeError('Failed to fetch'))\n+      )\n+  \n+      await client.deferrableCall('FooEndpoint', 'fooMethod');\n+  \n+      expect(storeDeferredCall.called).to.be.true;\n+    })\n+  \n+    it(\"should NOT defer endpoint call when server return error\", async () => {\n+      sinon.stub(OfflineHelper.prototype, \"checkOnline\").callsFake(() => true);\n+      sinon.stub(OfflineHelper.prototype, \"storeDeferredCall\");\n+      const body = 'Unexpected error';\n+      const errorResponse = new Response(\n+        body,\n+        {\n+          status: 500,\n+          statusText: 'Internal Server Error'\n+        }\n+      );\n+      fetchMock.post(base + '/connect/FooEndpoint/fooMethod', errorResponse);\n+  \n+      try {\n+        await client.deferrableCall('FooEndpoint', 'fooMethod');\n+      } catch (error) {\n+        expect(error).to.be.instanceOf(Error)\n+          .and.have.property('message').that.has.string('Unexpected error');\n+      }\n+    })\n+  });\n+\n+  describe(\"submit deferred calls\", () => {\n+    let client: ConnectClient;\n+    let requestCallStub: any;\n+\n+    function fakeRequestCallFails() {\n+      requestCallStub.callsFake(() => {\n+        throw new Error();\n+      });\n+    }\n+\n+    async function insertARequest(numberOfRequests = 1) {\n+      const db = await (offline as any).openOrCreateDB();\n+      for (let i = 0; i < numberOfRequests; i++) {\n+        await db.put(VAADIN_DEFERRED_CALL_STORE_NAME, { endpoint: 'FooEndpoint', method: 'fooMethod', params: { fooData: 'foo' } });\n+      }\n+      expect(await db.count(VAADIN_DEFERRED_CALL_STORE_NAME)).to.equal(numberOfRequests);\n+      db.close();\n+    }\n+\n+    async function verifyNumberOfRequsetsInTheQueue(numberOfRequests = 1) {\n+      const db = await (offline as any).openOrCreateDB();\n+      expect(await db.count(VAADIN_DEFERRED_CALL_STORE_NAME)).to.equal(numberOfRequests);\n+      db.close();\n+    }\n+\n+    beforeEach(async () => {\n+      client = new ConnectClient();\n+      requestCallStub = sinon.stub(client, 'requestCall').callsFake(async () => {\n+        await new Promise(resolve => setTimeout(resolve, 10))\n+      });\n+    });\n+\n+    afterEach(async () => {\n+      const db = await (offline as any).openOrCreateDB();\n+      await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+      db.close();\n+      fetchMock.restore();\n+    });\n+\n+    it(\"should check and submit the cached requests when receiving online event\", () => {\n+      const submitMethod = sinon.stub(ConnectClient.prototype, \"submitDeferredCalls\");\n+      client = new ConnectClient();\n+      self.dispatchEvent(new Event('online'));\n+      expect(submitMethod.called).to.be.true;\n+      submitMethod.restore();\n+    })\n+\n+    it(\"should submit the cached request when receiving online event\", async () => {\n+      await insertARequest(3);\n+\n+      await client.submitDeferredCalls();\n+\n+      await verifyNumberOfRequsetsInTheQueue(0);\n+    })\n+\n+    it(\"should keep the request if submission fails\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+      }\n+    });\n+\n+    it('should reject if submission fails', async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      let errors: Error[] | undefined;\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+        errors = e;\n+      }\n+\n+      expect(errors?.length).to.equal(1);\n+    });\n+\n+    it(\"should be able to resubmit cached request that was failed to submit\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+\n+        requestCallStub.restore();\n+        sinon.stub(client, \"requestCall\");\n+\n+        await client.submitDeferredCalls();\n+\n+        await verifyNumberOfRequsetsInTheQueue(0);\n+      }\n+    });\n+\n+    it(\"should only submit once when receiving multiple online events\", async () => {\n+      await insertARequest();\n+\n+      await Promise.all([\n+        client.submitDeferredCalls(),\n+        client.submitDeferredCalls(),\n+        client.submitDeferredCalls()\n+      ])\n+\n+      expect(requestCallStub.calledOnce).to.be.true;\n+    })\n+\n+    it(\"should only submit once when receiving multiple online events after a failed submission\", async () => {\n+      await insertARequest();\n+\n+      fakeRequestCallFails();\n+\n+      try {\n+        await client.submitDeferredCalls();\n+      } catch (_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+\n+        requestCallStub.restore();\n+        sinon.stub(client, \"requestCall\");\n+\n+        await Promise.all([\n+          client.submitDeferredCalls(),\n+          client.submitDeferredCalls(),\n+          client.submitDeferredCalls()\n+        ])\n+\n+        expect(requestCallStub.calledOnce).to.be.true;\n+      }\n+    });\n+\n+    it('should invoke middleware with isDeferred context', async () => {\n+      fetchMock.post(base + '/connect/FooEndpoint/fooMethod', { fooData: 'foo' });\n+\n+      requestCallStub.restore();\n+\n+      const spyMiddleware = sinon.spy(async (context: any, next?: any) => {\n+        expect(context.endpoint).to.equal('FooEndpoint');\n+        expect(context.method).to.equal('fooMethod');\n+        expect(context.params).to.deep.equal({ fooData: 'foo' });\n+        expect(context.request).to.be.instanceOf(Request);\n+        expect(context.isDeferred).to.be.true;\n+        return next(context);\n+      });\n+      client.middlewares = [spyMiddleware];\n+\n+      try {\n+        await insertARequest();\n+\n+        expect(spyMiddleware.called).to.be.false;\n+\n+        await client.submitDeferredCalls();\n+\n+        expect(spyMiddleware.called).to.be.true;\n+      } finally {\n+        fetchMock.restore();\n+      }\n+    });\n+\n+    it('should invoke deferredCallHandler', async () => {\n+      await insertARequest();\n+\n+      const onDeferredCallStub = sinon.stub().resolves();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };\n+\n+      await client.submitDeferredCalls();\n+\n+      expect(onDeferredCallStub.callCount).to.equal(1);\n+      const [call] = onDeferredCallStub.getCall(0).args;\n+      expect(call.deferredCall.endpoint).to.equal('FooEndpoint');\n+      expect(call.deferredCall.method).to.equal('fooMethod');\n+      expect(call.deferredCall.params).to.deep.equal({ fooData: 'foo' });\n+\n+      await verifyNumberOfRequsetsInTheQueue(0);\n+    });\n+\n+    it('should reject if onDeferredCall callback rejects', async () => {\n+      const onDeferredCallStub = sinon.stub().rejects();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };\n+\n+      let errors: Error[] | undefined;\n+\n+      try {\n+        await insertARequest();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+        errors = e;\n+      } finally {\n+        expect(errors?.length).to.equal(1);\n+      }\n+    });\n+\n+    it('should keep request in the queue when onDeferredCall callback rejects', async () => {\n+      const onDeferredCallStub = sinon.stub().rejects();\n+      client.deferredCallSubmissionHandler = {\n+        handleDeferredCallSubmission: onDeferredCallStub\n+      };;\n+  \n+      try {\n+        await insertARequest();\n+        await client.submitDeferredCalls();\n+      } catch(_) {\n+        // expected\n+      } finally {\n+        await verifyNumberOfRequsetsInTheQueue(1);\n+      }\n+    });\n+\n+    it('should set submitting status to false for all the request in the queue', async () => {\n+      try {\n+        await insertARequest(2);\n+        fakeRequestCallFails();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+      } finally {\n+        verifyNumberOfRequsetsInTheQueue(2)\n+        const db = await openDB(VAADIN_DEFERRED_CALL_QUEUE_DB_NAME);\n+        let cursor = await db.transaction(VAADIN_DEFERRED_CALL_STORE_NAME).store.openCursor();\n+        while (cursor) {\n+          expect(cursor.value.submitting).to.be.false;\n+          cursor = await cursor.continue();\n+        }\n+        await db.clear(VAADIN_DEFERRED_CALL_STORE_NAME);\n+        db.close;\n+      }\n+    });\n+\n+    it('should submit all the endpoint calls in the queue even errors are encountered when submitting some calls', async () => {\n+      try {\n+        await insertARequest(3);\n+        fakeRequestCallFails();\n+        await client.submitDeferredCalls();\n+      } catch (e) {\n+        // expected\n+      } finally {\n+        expect(requestCallStub.callCount).to.equal(3);\n+        verifyNumberOfRequsetsInTheQueue(3)\n+      }\n+    });\n+\n+    describe('deferred call handler', () => {\n+      it('should be able to show a notification when a deferred call submission succeeds', async () => {\n+        const notifyOnSucess = sinon.stub();\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+            notifyOnSucess();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          await client.submitDeferredCalls();\n+        } finally {\n+          expect(notifyOnSucess.calledOnce).to.be.true;\n+        }\n+      });\n+\n+      it('should be able to show a notification when deferred call submission fails', async () => {\n+        const notifyOnFailure = sinon.stub();\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            try {\n+              await deferrableCall.submit();\n+            } catch (error) {\n+              notifyOnFailure();\n+            }\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          fakeRequestCallFails()\n+          await client.submitDeferredCalls();\n+        } finally {\n+          expect(notifyOnFailure.calledOnce).to.be.true;\n+        }\n+      });\n+\n+      it('should remove a succeeded endpoint call from the queue by default', async () => {\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          await client.submitDeferredCalls();\n+        } finally {\n+          await verifyNumberOfRequsetsInTheQueue(0);\n+        }\n+      });\n+\n+      it('should keep a failed endpoint in the queue by default', async () => {\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            await deferrableCall.submit();\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          fakeRequestCallFails();\n+          await client.submitDeferredCalls();\n+        } catch (_) {\n+          // expected\n+        } finally {\n+          await verifyNumberOfRequsetsInTheQueue(1);\n+        }\n+      });\n+\n+      it('should remove a failed endpoint call from the queue when user catches the error without calling deferrecCall.keepInTheQueue()', async () => {\n+        client.deferredCallSubmissionHandler = {\n+          async handleDeferredCallSubmission(deferrableCall: DeferredCallSubmitter) {\n+            try {\n+              await deferrableCall.submit();\n+            } catch (error) {\n+              // swallow the error\n+            }\n+          }\n+        };\n+\n+        try {\n+          await insertARequest();\n+          fakeRequestCallFails();\n+          await client.submitDeferredCalls();\n+        } finally {\n+          await verifyNumberOfRequsetsInTheQueue(0);\n+        }\n+      });\n+\n+      it('should keep a failed endpoint call in the queue when user catches the error and calls deferrecCall.keepInTheQueue()', async () => {", "originalCommit": "c88146ad8ffc137d73cf70b99e21262a26f3bc15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI2MTA3MA==", "url": "https://github.com/vaadin/flow/pull/9304#discussion_r517261070", "bodyText": "done", "author": "haijian-vaadin", "createdAt": "2020-11-04T10:57:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIxNjI2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI0MDM4Ng==", "url": "https://github.com/vaadin/flow/pull/9304#discussion_r517240386", "bodyText": "Extreanous The at end of docstring.", "author": "joheriks", "createdAt": "2020-11-04T10:23:43Z", "path": "flow-client/src/main/resources/META-INF/resources/frontend/Connect.ts", "diffHunk": "@@ -182,16 +174,12 @@ export interface ConnectClientOptions {\n   middlewares?: Middleware[];\n \n   /**\n-   * The `onDeferredCall` property value\n+   * The `deferredCallSubmissionHandler` property valueThe", "originalCommit": "c88146ad8ffc137d73cf70b99e21262a26f3bc15", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI1MTYyMg==", "url": "https://github.com/vaadin/flow/pull/9304#discussion_r517251622", "bodyText": "The name seems longish, how about deferredCallHandler?", "author": "joheriks", "createdAt": "2020-11-04T10:41:54Z", "path": "flow-client/src/main/resources/META-INF/resources/frontend/Connect.ts", "diffHunk": "@@ -182,16 +174,12 @@ export interface ConnectClientOptions {\n   middlewares?: Middleware[];\n \n   /**\n-   * The `onDeferredCall` property value\n+   * The `deferredCallSubmissionHandler` property valueThe\n    */\n-  onDeferredCall?: OnDeferredCallCallback\n+  deferredCallSubmissionHandler?: DeferredCallSubmissionHandler;", "originalCommit": "c88146ad8ffc137d73cf70b99e21262a26f3bc15", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI2MTI0OA==", "url": "https://github.com/vaadin/flow/pull/9304#discussion_r517261248", "bodyText": "renamed", "author": "haijian-vaadin", "createdAt": "2020-11-04T10:58:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzI1MTYyMg=="}], "type": "inlineReview"}, {"oid": "3ab44974d54a0efc99a17cf359569626c27965ee", "url": "https://github.com/vaadin/flow/commit/3ab44974d54a0efc99a17cf359569626c27965ee", "message": "renaming and typo fixes", "committedDate": "2020-11-04T10:57:11Z", "type": "commit"}, {"oid": "a62bdb21bf526312f701be60c636c6cb5306b419", "url": "https://github.com/vaadin/flow/commit/a62bdb21bf526312f701be60c636c6cb5306b419", "message": "Merge branch 'feature/offline' into deferred-call-refactor", "committedDate": "2020-11-04T10:58:18Z", "type": "commit"}]}