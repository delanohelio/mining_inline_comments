{"pr_number": 9177, "pr_title": "Merge master to offline", "pr_createdAt": "2020-10-14T09:06:43Z", "pr_url": "https://github.com/vaadin/flow/pull/9177", "timeline": [{"oid": "460eec0db056c957abc65ee1c0f36c7394cde8ed", "url": "https://github.com/vaadin/flow/commit/460eec0db056c957abc65ee1c0f36c7394cde8ed", "message": "fix: Rewrite fix for clearing Current instances (#9088)\n\nFixes #8548", "committedDate": "2020-10-01T09:42:10Z", "type": "commit"}, {"oid": "f82a36776a99622108ef8f1f0277ba6f7c9d495f", "url": "https://github.com/vaadin/flow/commit/f82a36776a99622108ef8f1f0277ba6f7c9d495f", "message": "fix: Add content type to dev-mode-not-ready response (#9095)\n\nIf you enable Spring Security, the missing charset causes the page to either be downloaded or shown as plain text depending on the browser.", "committedDate": "2020-10-01T18:26:32Z", "type": "commit"}, {"oid": "ce0799726a1ce86273481c707367bd444de6f351", "url": "https://github.com/vaadin/flow/commit/ce0799726a1ce86273481c707367bd444de6f351", "message": "fix: Use a default page size for DataCommunicator (#9081)\n\nFixes #9051", "committedDate": "2020-10-02T07:34:43Z", "type": "commit"}, {"oid": "12d82d549ddebd8a74669c9c735e0fd1c1727a00", "url": "https://github.com/vaadin/flow/commit/12d82d549ddebd8a74669c9c735e0fd1c1727a00", "message": "refactor: rename method name to avoid double negation (#9091)\n\n`DataCommunicator::fetchDisabled()` renamed to `DataCommunicator::fetchEnabled()` to avoid double negation according to a conventions.", "committedDate": "2020-10-02T11:00:30Z", "type": "commit"}, {"oid": "bae7bce45ce8708b6a00867f7b52ea854c45eb07", "url": "https://github.com/vaadin/flow/commit/bae7bce45ce8708b6a00867f7b52ea854c45eb07", "message": "fix: Fix JavaScriptBootstrapUI::getChildren\n\nIt should return all components added to the UI, like Dialog and Notification.\nRelated to #7799\n\nFixes #9069", "committedDate": "2020-10-02T15:42:02Z", "type": "commit"}, {"oid": "c009afc5c24d8a3d6abc14f6f5cd3faea80c1932", "url": "https://github.com/vaadin/flow/commit/c009afc5c24d8a3d6abc14f6f5cd3faea80c1932", "message": "Do more accurate check for error messages in IT (#9086)\n\nFixes #9068", "committedDate": "2020-10-05T07:05:45Z", "type": "commit"}, {"oid": "85a880f0a243db8b3033e4be28fe03135e89d9e1", "url": "https://github.com/vaadin/flow/commit/85a880f0a243db8b3033e4be28fe03135e89d9e1", "message": "fix: documentation for KeyboardEvent.getCode (#9100)", "committedDate": "2020-10-07T05:42:42Z", "type": "commit"}, {"oid": "28115e1392131866eb53323959677d96c53055bb", "url": "https://github.com/vaadin/flow/commit/28115e1392131866eb53323959677d96c53055bb", "message": "fix: Set disabled status for component mapped to an Element (#9122)\n\nfix: Set disabled status for component mapped to an Element\r\n\r\nFixes #8973", "committedDate": "2020-10-07T06:06:00Z", "type": "commit"}, {"oid": "262d897310f7827cdf125e341bdaac3fd3abc86d", "url": "https://github.com/vaadin/flow/commit/262d897310f7827cdf125e341bdaac3fd3abc86d", "message": "refactor: allow components to fire a count change event (#9124)", "committedDate": "2020-10-07T10:20:08Z", "type": "commit"}, {"oid": "e46e7949d9b547bc87af12bd1405e33c23255858", "url": "https://github.com/vaadin/flow/commit/e46e7949d9b547bc87af12bd1405e33c23255858", "message": "Re-implement the EventHandlerRpcHandler (#9125)\n\nRe-implement the EventHandlerRpcHandler\r\n\r\nEventHandlerRpcHandler handles the ClientCallable\r\nserver method and is thus not purely for polymer.\r\nThe hanlder was returned and tests were parted\r\nbetween polymer (EventHandler) and server (ClientCallable)\r\n\r\nCloses #9116", "committedDate": "2020-10-07T11:10:43Z", "type": "commit"}, {"oid": "fe45340af7dadc3ca0c4899faaefe1136da8f451", "url": "https://github.com/vaadin/flow/commit/fe45340af7dadc3ca0c4899faaefe1136da8f451", "message": "Make handleFileUploadValidationAndData and sendUploadResponse protected (#8468)\n\nThis allows external code extending this class to reduce copy/pasting these and other private methods.", "committedDate": "2020-10-07T11:26:36Z", "type": "commit"}, {"oid": "21413c50975496647027609c70d62a45f9e7a264", "url": "https://github.com/vaadin/flow/commit/21413c50975496647027609c70d62a45f9e7a264", "message": "feat: upgrade to TypeScript 4 (#9138)", "committedDate": "2020-10-08T08:02:56Z", "type": "commit"}, {"oid": "b250bce9dbc5da986ca2281345c4c506eca1f5b2", "url": "https://github.com/vaadin/flow/commit/b250bce9dbc5da986ca2281345c4c506eca1f5b2", "message": "refactor: revert 'allow components to fire a count change event' (#9139)\n\nPart of https://github.com/vaadin/vaadin-combo-box/issues/914", "committedDate": "2020-10-08T10:46:21Z", "type": "commit"}, {"oid": "13384f93709b2f9b19e995d2b536cd45537bd4f5", "url": "https://github.com/vaadin/flow/commit/13384f93709b2f9b19e995d2b536cd45537bd4f5", "message": "Revert \"fix: Set disabled status for component mapped to an Element (#9122)\" (#9141)\n\nThis reverts commit 28115e1392131866eb53323959677d96c53055bb.\r\n\r\nDecided to fix this by reverting the implementation for mapping disabled\r\nattribute for mapped components, as it is so little added user value for so\r\nbig risk of regressions (like this one), confusion and bad code introduced\r\ninto the framework, increasing maintenance costs. Will change docs too.\r\nFurther details in #9140\r\n\r\nFixes #9136", "committedDate": "2020-10-08T11:16:18Z", "type": "commit"}, {"oid": "e737ed4b8ba5f1882797546e9f0ea3fee6f462bc", "url": "https://github.com/vaadin/flow/commit/e737ed4b8ba5f1882797546e9f0ea3fee6f462bc", "message": "test: Navigation test between modes (#9149)\n\ntest: Navigation test between modes\r\n\r\nTest navigating from clinet view to server-side\r\nview and server to client.\r\n\r\nCloses #9134", "committedDate": "2020-10-09T09:54:40Z", "type": "commit"}, {"oid": "2fa75ddc88cdb719daaceb8ef21478b9acb43c37", "url": "https://github.com/vaadin/flow/commit/2fa75ddc88cdb719daaceb8ef21478b9acb43c37", "message": "chore: Fix tests for windows execution (#9129)\n\nFix tests so they work also on windows.\r\nRemove Polymer dependency form the test root and only have it in packages actually utilizing Polymer.", "committedDate": "2020-10-09T10:11:04Z", "type": "commit"}, {"oid": "f617010cdff589bf8b8d714081d1a2d1488ca156", "url": "https://github.com/vaadin/flow/commit/f617010cdff589bf8b8d714081d1a2d1488ca156", "message": "fix: store app shell title into UI instead of AppShellRegistry (#9133)\n\n* fix: store app shell title into UI instead of AppShellRegistry\r\n\r\n* fix compile errors after merge\r\n\r\n* apply code review suggestions\r\n\r\n* add IT tests, apply code review suggestions\r\n\r\n* verify document.title was updated on the client-side\r\n\r\n* fix typo", "committedDate": "2020-10-09T15:32:22Z", "type": "commit"}, {"oid": "601a69cf1f694aa23457fd3c4fcdd5720269d634", "url": "https://github.com/vaadin/flow/commit/601a69cf1f694aa23457fd3c4fcdd5720269d634", "message": "feat!: remove deprecated AppShellRegistry.getTitle() (#9156)", "committedDate": "2020-10-12T06:29:51Z", "type": "commit"}, {"oid": "09c6aa687f4793cc143834f90c7869c50041f068", "url": "https://github.com/vaadin/flow/commit/09c6aa687f4793cc143834f90c7869c50041f068", "message": "Fix docs typo (#9066)", "committedDate": "2020-10-12T06:54:57Z", "type": "commit"}, {"oid": "d372d3337d57546c271a93dd76b4d74a2c505ba1", "url": "https://github.com/vaadin/flow/commit/d372d3337d57546c271a93dd76b4d74a2c505ba1", "message": "feat: add support for Range header to StaticFileServer (#9154)\n\nA Range header can specify either a single byte range, e.g. Range: bytes=0-99, or multiple ranges,\r\ne.g. Range: bytes=0-99, 200-299. The ranges do not need to be sequential and can have overlap;\r\ne.g. Range: bytes=200-299, 0-219 is valid; such requests will open a new stream reading from the\r\nbeginning of the file for each out-of-order range. The motivation for this feature is to support video\r\nplayback on Safari.\r\n\r\nFixes #9083", "committedDate": "2020-10-12T13:58:45Z", "type": "commit"}, {"oid": "a8c709e434c7dfb2090e5094e28c425238f8be5b", "url": "https://github.com/vaadin/flow/commit/a8c709e434c7dfb2090e5094e28c425238f8be5b", "message": "refactor: move client-side authentication helpers to a separate file (#9157)\n\n* Split authentication-related helpers to a separate file.\r\n* Change the main entry point of @vaadin/flow-frontend to index, the index exports Flow, Connect, and Authentication, so that a user could just import @vaadin/flow-frontend without having to specify the suffix.", "committedDate": "2020-10-12T18:36:25Z", "type": "commit"}, {"oid": "e6e3977be5948de309fd586dcbf6188553c74685", "url": "https://github.com/vaadin/flow/commit/e6e3977be5948de309fd586dcbf6188553c74685", "message": "chore: bump junit from 4.12 to 4.13.1 (#9162)\n\nBumps [junit](https://github.com/junit-team/junit4) from 4.12 to 4.13.1.\r\n- [Release notes](https://github.com/junit-team/junit4/releases)\r\n- [Changelog](https://github.com/junit-team/junit4/blob/main/doc/ReleaseNotes4.12.md)\r\n- [Commits](https://github.com/junit-team/junit4/compare/r4.12...r4.13.1)\r\n\r\nSigned-off-by: dependabot[bot] <support@github.com>\r\n\r\nCo-authored-by: dependabot[bot] <49699333+dependabot[bot]@users.noreply.github.com>", "committedDate": "2020-10-14T08:30:23Z", "type": "commit"}, {"oid": "d292c8de532e639ae82ada71cad245cfb657b71f", "url": "https://github.com/vaadin/flow/commit/d292c8de532e639ae82ada71cad245cfb657b71f", "message": "Merge branch 'master' into merge-master-to-offline", "committedDate": "2020-10-14T09:05:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1NzI5Mg==", "url": "https://github.com/vaadin/flow/pull/9177#discussion_r504557292", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL)", "author": "vaadin-bot", "createdAt": "2020-10-14T10:05:23Z", "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -122,31 +132,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n             }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());\n+                long start = rangePair.getFirst();\n+                long end = rangePair.getSecond();\n+                if (mimeType != null) {\n+                    outputStream.write(\n+                            String.format(\"Content-Type: %s\\r\\n\", mimeType)\n+                                    .getBytes());\n+                }\n+                outputStream.write(String\n+                        .format(\"Content-Range: %s\\r\\n\\r\\n\",\n+                                createContentRangeHeader(start, end,\n+                                        connection.getContentLengthLong()))\n+                        .getBytes());\n+\n+                if (position > start) {\n+                    // out-of-sequence range -> open new stream to the file\n+                    // alternative: use single stream with mark / reset\n+                    closeStream(connection.getInputStream());\n+                    connection = resourceURL.openConnection();\n+                    dataStream = connection.getInputStream();\n+                    position = 0L;\n+                }\n+                long skipped = dataStream.skip(start - position);\n+                assert(skipped == start - position);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+                position = end + 1;\n+            }\n+        } finally {\n+            closeStream(dataStream);\n+        }\n+        outputStream.write(String.format(\"\\r\\n--%s\", partBoundary).getBytes());", "originalCommit": "d292c8de532e639ae82ada71cad245cfb657b71f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1NzMwMw==", "url": "https://github.com/vaadin/flow/pull/9177#discussion_r504557303", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL) \n Found reliance on default encoding in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL): String.getBytes()", "author": "vaadin-bot", "createdAt": "2020-10-14T10:05:24Z", "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -122,31 +132,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n             }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());", "originalCommit": "d292c8de532e639ae82ada71cad245cfb657b71f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1NzMxNw==", "url": "https://github.com/vaadin/flow/pull/9177#discussion_r504557317", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL)", "author": "vaadin-bot", "createdAt": "2020-10-14T10:05:25Z", "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -122,31 +132,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n             }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());\n+                long start = rangePair.getFirst();\n+                long end = rangePair.getSecond();\n+                if (mimeType != null) {\n+                    outputStream.write(\n+                            String.format(\"Content-Type: %s\\r\\n\", mimeType)", "originalCommit": "d292c8de532e639ae82ada71cad245cfb657b71f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1NzMyNg==", "url": "https://github.com/vaadin/flow/pull/9177#discussion_r504557326", "bodyText": "Format string should use %n rather than \\n in com.vaadin.flow.internal.ResponseWriter.writeMultipartRangeContents(List, URLConnection, HttpServletResponse, URL)", "author": "vaadin-bot", "createdAt": "2020-10-14T10:05:26Z", "path": "flow-server/src/main/java/com/vaadin/flow/internal/ResponseWriter.java", "diffHunk": "@@ -122,31 +132,177 @@ public void writeResponseContents(String filenameWithPath, URL resourceUrl,\n \n         if (dataStream == null) {\n             // compressed resource not available, get non compressed\n+            url = resourceUrl;\n             connection = resourceUrl.openConnection();\n             dataStream = connection.getInputStream();\n         } else {\n             response.setHeader(\"Vary\", \"Accept-Encoding\");\n         }\n \n         try {\n-            long length = connection.getContentLengthLong();\n-            if (length >= 0L) {\n-                response.setContentLengthLong(length);\n+            String range = request.getHeader(\"Range\");\n+            if (range != null) {\n+                closeStream(dataStream);\n+                dataStream = null;\n+                writeRangeContents(range, response, url);\n+            } else {\n+                final long contentLength = connection.getContentLengthLong();\n+                if (0 <= contentLength) {\n+                    setContentLength(response, contentLength);\n+                }\n+                writeStream(response.getOutputStream(), dataStream,\n+                        Long.MAX_VALUE);\n+            }\n+        } catch (IOException e) {\n+            getLogger().debug(\"Error writing static file to user\", e);\n+        } finally {\n+            if (dataStream !=null ) {\n+                closeStream(dataStream);\n             }\n-        } catch (Exception e) {\n-            getLogger().debug(\"Error setting the content length\", e);\n         }\n+    }\n \n+    private void closeStream(Closeable stream) {\n         try {\n-            writeStream(response.getOutputStream(), dataStream);\n+            stream.close();\n         } catch (IOException e) {\n-            getLogger().debug(\"Error writing static file to user\", e);\n-        } finally {\n+            getLogger().debug(\"Error closing input stream for resource\", e);\n+        }\n+    }\n+\n+    /**\n+     * Handle a \"Header:\" request. The handling logic is splits on single or\n+     * multiple ranges: for a single range, send a regular response with\n+     * Content-Length; for multiple ranges, send a \"Content-Type:\n+     * multipart/byteranges\" response. If the byte ranges are satisfiable, the\n+     * response code is 206, otherwise it is 416. See e.g.\n+     * https://developer.mozilla.org/en-US/docs/Web/HTTP/Range_requests for\n+     * protocol details.\n+     */\n+    private void writeRangeContents(String range, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        response.setHeader(\"Accept-Ranges\", \"bytes\");\n+\n+        URLConnection connection = resourceURL.openConnection();\n+\n+        Matcher headerMatcher = RANGE_HEADER_PATTERN.matcher(range);\n+        if (!headerMatcher.matches()) {\n+            response.setContentLengthLong(0L);\n+            response.setStatus(416); // Range Not Satisfiable\n+            return;\n+        }\n+        String byteRanges = headerMatcher.group(1);\n+\n+        long resourceLength = connection.getContentLengthLong();\n+        Matcher rangeMatcher = BYTE_RANGE_PATTERN.matcher(byteRanges);\n+\n+        List<Pair<Long, Long>> ranges = new ArrayList<>();\n+        while (rangeMatcher.find()) {\n+            final long start = Long.parseLong(rangeMatcher.group(1));\n+            final long end = Long.parseLong(rangeMatcher.group(2));\n+            if (end < start\n+                    || (resourceLength >= 0 && start >= resourceLength)) {\n+                // illegal range -> 416\n+                response.setContentLengthLong(0L);\n+                response.setStatus(416);\n+                return;\n+            }\n+            ranges.add(new Pair<>(start, end));\n+        }\n+\n+        response.setStatus(206);\n+\n+        if (ranges.size() == 1) {\n+            ServletOutputStream outputStream = response.getOutputStream();\n+\n+            // single range: calculate Content-Length\n+            long start = ranges.get(0).getFirst();\n+            long end = ranges.get(0).getSecond();\n+            if (resourceLength >= 0) {\n+                end = Math.min(end, resourceLength - 1);\n+            }\n+            setContentLength(response, end - start + 1);\n+            response.setHeader(\"Content-Range\",\n+                    createContentRangeHeader(start, end, resourceLength));\n+\n+            final InputStream dataStream = connection.getInputStream();\n             try {\n-                dataStream.close();\n-            } catch (IOException e) {\n-                getLogger().debug(\"Error closing input stream for resource\", e);\n+                long skipped = dataStream.skip(start);\n+                assert(skipped == start);\n+                writeStream(outputStream, dataStream, end - start + 1);\n+            } finally {\n+                closeStream(dataStream);\n             }\n+        } else {\n+            writeMultipartRangeContents(ranges, connection, response,\n+                    resourceURL);\n+        }\n+    }\n+\n+    /**\n+     * Write a multi-part request with MIME type \"multipart/byteranges\",\n+     * separated by boundaries and use \"Transfer-Encoding: chunked\" mode to\n+     * avoid computing \"Content-Length\".\n+     */\n+    private void writeMultipartRangeContents(List<Pair<Long, Long>> ranges,\n+            URLConnection connection, HttpServletResponse response,\n+            URL resourceURL) throws IOException {\n+        String partBoundary = UUID.randomUUID().toString();\n+        response.setContentType(String\n+                .format(\"multipart/byteranges; boundary=%s\", partBoundary));\n+        response.setHeader(\"Transfer-Encoding\", \"chunked\");\n+\n+        long position = 0L;\n+        String mimeType = response.getContentType();\n+        InputStream dataStream = connection.getInputStream();\n+        ServletOutputStream outputStream = response.getOutputStream();\n+        try {\n+            for (Pair<Long, Long> rangePair : ranges) {\n+                outputStream.write(\n+                        String.format(\"\\r\\n--%s\\r\\n\", partBoundary).getBytes());\n+                long start = rangePair.getFirst();\n+                long end = rangePair.getSecond();\n+                if (mimeType != null) {\n+                    outputStream.write(\n+                            String.format(\"Content-Type: %s\\r\\n\", mimeType)\n+                                    .getBytes());\n+                }\n+                outputStream.write(String\n+                        .format(\"Content-Range: %s\\r\\n\\r\\n\",", "originalCommit": "d292c8de532e639ae82ada71cad245cfb657b71f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1NzMzOA==", "url": "https://github.com/vaadin/flow/pull/9177#discussion_r504557338", "bodyText": "Refactor this method to reduce its Cognitive Complexity from 19 to the 15 allowed.", "author": "vaadin-bot", "createdAt": "2020-10-14T10:05:27Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -58,28 +67,313 @@ public String getRpcType() {\n     @Override\n     public Optional<Runnable> handleNode(StateNode node,\n             JsonObject invocationJson) {\n+        assert invocationJson\n+                .hasKey(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        String methodName = invocationJson\n+                .getString(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\n+                    \"Event handler method name may not be null\");\n+        }\n+        JsonValue args = invocationJson\n+                .get(JsonConstants.RPC_TEMPLATE_EVENT_ARGS);\n+        if (args == null) {\n+            args = Json.createArray();\n+        }\n+        if (args.getType() != JsonType.ARRAY) {\n+            throw new IllegalArgumentException(\n+                    \"Incorrect type for method arguments: \" + args.getClass());\n+        }\n+        int promiseId;\n+        if (invocationJson.hasKey(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE)) {\n+            promiseId = (int) invocationJson\n+                    .getNumber(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE);\n+        } else {\n+            promiseId = -1;\n+        }\n+        assert node.hasFeature(ComponentMapping.class);\n+        Optional<Component> component = ComponentMapping.getComponent(node);\n+        if (!component.isPresent()) {\n+            throw new IllegalStateException(\n+                    \"Unable to handle RPC template event JSON message: \"\n+                            + \"there is no component available for the target node\");\n+        }\n+\n+        boolean execute = node.isEnabled();\n+\n+        if (!execute) {\n+            ClientCallableHandlers clientDelegate = node\n+                    .getFeature(ClientCallableHandlers.class);\n+            PolymerServerEventHandlers eventHandlers = node\n+                    .getFeature(PolymerServerEventHandlers.class);\n+            if (clientDelegate.hasHandler(methodName)) {\n+                execute = DisabledUpdateMode.ALWAYS.equals(clientDelegate\n+                        .getDisabledUpdateMode(methodName));\n+            }\n+            if (eventHandlers.hasHandler(methodName)) {\n+                execute = execute || DisabledUpdateMode.ALWAYS\n+                        .equals(eventHandlers\n+                                .getDisabledUpdateMode(methodName));\n+            }\n+        }\n+\n+        if (execute) {\n+            invokeMethod(component.get(), component.get().getClass(),\n+                    methodName, (JsonArray) args, promiseId);\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    static void invokeMethod(Component instance, Class<?> clazz,\n+            String methodName, JsonArray args, int promiseId) {\n+        assert instance != null;\n+        Optional<Method> method = findMethod(instance, clazz, methodName);\n+        if (method.isPresent()) {\n+            invokeMethod(instance, method.get(), args, promiseId);\n+        } else if (instance instanceof Composite) {\n+            Component compositeContent = ((Composite<?>) instance).getContent();\n+            invokeMethod(compositeContent, compositeContent.getClass(),\n+                    methodName, args, promiseId);\n+        } else {\n+            String msg = String.format(\"Neither class '%s' \"\n+                            + \"nor its super classes declare event handler method '%s'\",\n+                    instance.getClass().getName(), methodName);\n+            throw new IllegalStateException(msg);\n+        }\n+    }\n+\n+    private static Optional<Method> findMethod(Component instance,\n+            Class<?> clazz, String methodName) {\n+        List<Method> methods = Stream.of(clazz.getDeclaredMethods())\n+                .filter(method -> methodName.equals(method.getName()))\n+                .filter(method -> hasMethodAnnotation(method))\n+                .collect(Collectors.toList());\n+        if (methods.size() > 1) {\n+            String msg = String.format(\"Class '%s' contains \"\n+                            + \"several event handler method with the same name '%s'\",\n+                    instance.getClass().getName(), methodName);\n+            throw new IllegalStateException(msg);\n+        } else if (methods.size() == 1) {\n+            return Optional.of(methods.get(0));\n+        } else if (!Component.class.equals(clazz)) {\n+            return findMethod(instance, clazz.getSuperclass(), methodName);\n+        } else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private static boolean hasMethodAnnotation(Method method) {\n+        // Check for polymer event handler annotation.\n+        final boolean hasEventHandler = ReflectTools.hasAnnotation(method,\n+                \"com.vaadin.flow.component.polymertemplate.EventHandler\");\n+        return hasEventHandler || method\n+                .isAnnotationPresent(ClientCallable.class);\n+    }\n+\n+    private static void invokeMethod(Component instance, Method method,\n+            JsonArray args, int promiseId) {\n+        if (promiseId == -1) {\n+            invokeMethod(instance, method, args);\n+        } else {\n+            try {\n+                Serializable returnValue = (Serializable) invokeMethod(instance,\n+                        method, args);\n+\n+                instance.getElement().executeJs(\"this.$server['\"\n+                                + JsonConstants.RPC_PROMISE_CALLBACK_NAME\n+                                + \"']($0, true, $1)\", Integer.valueOf(promiseId),\n+                        returnValue);\n+            } catch (RuntimeException e) {\n+                instance.getElement().executeJs(\"this.$server['\"\n+                        + JsonConstants.RPC_PROMISE_CALLBACK_NAME\n+                        + \"']($0, false)\", Integer.valueOf(promiseId));\n+\n+                throw e;\n+            }\n+        }\n+    }\n+\n+    private static Object invokeMethod(Component instance, Method method,\n+            JsonArray args) {\n         try {\n-            Class<?> clazz = Class\n-                    .forName(\"com.vaadin.flow.component.polymertemplate.rpc.\"\n-                            + PublishedServerEventHandlerRpcHandler.class\n-                                    .getSimpleName());\n-            Method handleMethod = Stream.of(clazz.getDeclaredMethods())\n-                    .filter(method -> Modifier.isStatic(method.getModifiers())\n-                            && Modifier.isPublic(method.getModifiers()))\n-                    .findFirst().get();\n-            handleMethod.invoke(null, node, invocationJson);\n-        } catch (ClassNotFoundException e) {\n-            LoggerFactory.getLogger(PublishedServerEventHandlerRpcHandler.class)\n-                    .debug(\"Polymer handler is called even though the polymer module is not in the classpath\");\n-            // Just ignore: the functionality is not available\n+            method.setAccessible(true);\n+            return method.invoke(instance, decodeArgs(instance, method, args));\n         } catch (IllegalAccessException e) {\n-            LoggerFactory.getLogger(PublishedServerEventHandlerRpcHandler.class)\n-                    .warn(\"Implemenation error occured\", e);\n+            throw new RuntimeException(e);\n         } catch (InvocationTargetException e) {\n-            throw new IllegalStateException(e);\n+            LoggerFactory.getLogger(\n+                    PublishedServerEventHandlerRpcHandler.class.getName())\n+                    .debug(null, e);\n+            throw new RuntimeException(e.getCause());\n         }\n+    }\n \n-        return Optional.empty();\n+    private static Object[] decodeArgs(Component instance, Method method,\n+            JsonArray argsFromClient) {\n+        int methodArgs = method.getParameterCount();\n+        int clientValuesCount = argsFromClient.length();\n+        JsonArray argValues;\n+        if (method.isVarArgs()) {\n+            if (clientValuesCount >= methodArgs - 1) {\n+                argValues = unwrapVarArgs(argsFromClient, method);\n+            } else {\n+                String msg = String\n+                        .format(\"The number of received values (%d) is not enough \"\n+                                        + \"to call the method '%s' declared in '%s' which \"\n+                                        + \"has vararg parameter and the number of arguments %d\",\n+                                argsFromClient.length(), method.getName(),\n+                                method.getDeclaringClass().getName(),\n+                                method.getParameterCount());\n+                throw new IllegalArgumentException(msg);\n+            }\n+        } else {\n+            if (methodArgs == clientValuesCount) {\n+                argValues = argsFromClient;\n+            } else {\n+                String msg = String\n+                        .format(\"The number of received values (%d) is not equal \"\n+                                        + \"to the number of arguments (%d) in the method '%s' \"\n+                                        + \"declared in '%s'\", argsFromClient.length(),\n+                                method.getParameterCount(), method.getName(),\n+                                method.getDeclaringClass().getName());\n+                throw new IllegalArgumentException(msg);\n+            }\n+        }\n+        List<Object> decoded = new ArrayList<>(method.getParameterCount());\n+        Class<?>[] methodParameterTypes = method.getParameterTypes();\n+        for (int i = 0; i < argValues.length(); i++) {\n+            Class<?> type = methodParameterTypes[i];\n+            decoded.add(decodeArg(instance, method, type, i, argValues.get(i)));\n+        }\n+        return decoded.toArray(new Object[method.getParameterCount()]);\n+    }\n+\n+    private static JsonArray unwrapVarArgs(JsonArray argsFromClient,\n+            Method method) {\n+        int paramCount = method.getParameterCount();\n+        if (argsFromClient.length() == paramCount) {\n+            if (argsFromClient.get(paramCount - 1).getType()\n+                    .equals(JsonType.ARRAY)) {\n+                return argsFromClient;\n+            }\n+        }\n+        JsonArray result = Json.createArray();\n+        JsonArray rest = Json.createArray();\n+        int newIndex = 0;\n+        for (int i = 0; i < argsFromClient.length(); i++) {\n+            JsonValue value = argsFromClient.get(i);\n+            if (i < paramCount - 1) {\n+                result.set(i, value);\n+            } else {\n+                rest.set(newIndex, value);\n+                newIndex++;\n+            }\n+        }\n+        result.set(paramCount - 1, rest);\n+        return result;\n     }\n \n+    private static Object decodeArg(Component instance, Method method,", "originalCommit": "d292c8de532e639ae82ada71cad245cfb657b71f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1NzM1NA==", "url": "https://github.com/vaadin/flow/pull/9177#discussion_r504557354", "bodyText": "Replace this lambda with a method reference.", "author": "vaadin-bot", "createdAt": "2020-10-14T10:05:28Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -58,28 +67,313 @@ public String getRpcType() {\n     @Override\n     public Optional<Runnable> handleNode(StateNode node,\n             JsonObject invocationJson) {\n+        assert invocationJson\n+                .hasKey(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        String methodName = invocationJson\n+                .getString(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\n+                    \"Event handler method name may not be null\");\n+        }\n+        JsonValue args = invocationJson\n+                .get(JsonConstants.RPC_TEMPLATE_EVENT_ARGS);\n+        if (args == null) {\n+            args = Json.createArray();\n+        }\n+        if (args.getType() != JsonType.ARRAY) {\n+            throw new IllegalArgumentException(\n+                    \"Incorrect type for method arguments: \" + args.getClass());\n+        }\n+        int promiseId;\n+        if (invocationJson.hasKey(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE)) {\n+            promiseId = (int) invocationJson\n+                    .getNumber(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE);\n+        } else {\n+            promiseId = -1;\n+        }\n+        assert node.hasFeature(ComponentMapping.class);\n+        Optional<Component> component = ComponentMapping.getComponent(node);\n+        if (!component.isPresent()) {\n+            throw new IllegalStateException(\n+                    \"Unable to handle RPC template event JSON message: \"\n+                            + \"there is no component available for the target node\");\n+        }\n+\n+        boolean execute = node.isEnabled();\n+\n+        if (!execute) {\n+            ClientCallableHandlers clientDelegate = node\n+                    .getFeature(ClientCallableHandlers.class);\n+            PolymerServerEventHandlers eventHandlers = node\n+                    .getFeature(PolymerServerEventHandlers.class);\n+            if (clientDelegate.hasHandler(methodName)) {\n+                execute = DisabledUpdateMode.ALWAYS.equals(clientDelegate\n+                        .getDisabledUpdateMode(methodName));\n+            }\n+            if (eventHandlers.hasHandler(methodName)) {\n+                execute = execute || DisabledUpdateMode.ALWAYS\n+                        .equals(eventHandlers\n+                                .getDisabledUpdateMode(methodName));\n+            }\n+        }\n+\n+        if (execute) {\n+            invokeMethod(component.get(), component.get().getClass(),\n+                    methodName, (JsonArray) args, promiseId);\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    static void invokeMethod(Component instance, Class<?> clazz,\n+            String methodName, JsonArray args, int promiseId) {\n+        assert instance != null;\n+        Optional<Method> method = findMethod(instance, clazz, methodName);\n+        if (method.isPresent()) {\n+            invokeMethod(instance, method.get(), args, promiseId);\n+        } else if (instance instanceof Composite) {\n+            Component compositeContent = ((Composite<?>) instance).getContent();\n+            invokeMethod(compositeContent, compositeContent.getClass(),\n+                    methodName, args, promiseId);\n+        } else {\n+            String msg = String.format(\"Neither class '%s' \"\n+                            + \"nor its super classes declare event handler method '%s'\",\n+                    instance.getClass().getName(), methodName);\n+            throw new IllegalStateException(msg);\n+        }\n+    }\n+\n+    private static Optional<Method> findMethod(Component instance,\n+            Class<?> clazz, String methodName) {\n+        List<Method> methods = Stream.of(clazz.getDeclaredMethods())\n+                .filter(method -> methodName.equals(method.getName()))\n+                .filter(method -> hasMethodAnnotation(method))", "originalCommit": "d292c8de532e639ae82ada71cad245cfb657b71f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1NzM2OQ==", "url": "https://github.com/vaadin/flow/pull/9177#discussion_r504557369", "bodyText": "Remove this use of \"PolymerServerEventHandlers\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-10-14T10:05:28Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -58,28 +67,313 @@ public String getRpcType() {\n     @Override\n     public Optional<Runnable> handleNode(StateNode node,\n             JsonObject invocationJson) {\n+        assert invocationJson\n+                .hasKey(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        String methodName = invocationJson\n+                .getString(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\n+                    \"Event handler method name may not be null\");\n+        }\n+        JsonValue args = invocationJson\n+                .get(JsonConstants.RPC_TEMPLATE_EVENT_ARGS);\n+        if (args == null) {\n+            args = Json.createArray();\n+        }\n+        if (args.getType() != JsonType.ARRAY) {\n+            throw new IllegalArgumentException(\n+                    \"Incorrect type for method arguments: \" + args.getClass());\n+        }\n+        int promiseId;\n+        if (invocationJson.hasKey(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE)) {\n+            promiseId = (int) invocationJson\n+                    .getNumber(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE);\n+        } else {\n+            promiseId = -1;\n+        }\n+        assert node.hasFeature(ComponentMapping.class);\n+        Optional<Component> component = ComponentMapping.getComponent(node);\n+        if (!component.isPresent()) {\n+            throw new IllegalStateException(\n+                    \"Unable to handle RPC template event JSON message: \"\n+                            + \"there is no component available for the target node\");\n+        }\n+\n+        boolean execute = node.isEnabled();\n+\n+        if (!execute) {\n+            ClientCallableHandlers clientDelegate = node\n+                    .getFeature(ClientCallableHandlers.class);\n+            PolymerServerEventHandlers eventHandlers = node", "originalCommit": "d292c8de532e639ae82ada71cad245cfb657b71f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1NzM3OQ==", "url": "https://github.com/vaadin/flow/pull/9177#discussion_r504557379", "bodyText": "Remove this use of \"PolymerServerEventHandlers\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-10-14T10:05:29Z", "path": "flow-server/src/main/java/com/vaadin/flow/server/communication/rpc/PublishedServerEventHandlerRpcHandler.java", "diffHunk": "@@ -58,28 +67,313 @@ public String getRpcType() {\n     @Override\n     public Optional<Runnable> handleNode(StateNode node,\n             JsonObject invocationJson) {\n+        assert invocationJson\n+                .hasKey(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        String methodName = invocationJson\n+                .getString(JsonConstants.RPC_TEMPLATE_EVENT_METHOD_NAME);\n+        if (methodName == null) {\n+            throw new IllegalArgumentException(\n+                    \"Event handler method name may not be null\");\n+        }\n+        JsonValue args = invocationJson\n+                .get(JsonConstants.RPC_TEMPLATE_EVENT_ARGS);\n+        if (args == null) {\n+            args = Json.createArray();\n+        }\n+        if (args.getType() != JsonType.ARRAY) {\n+            throw new IllegalArgumentException(\n+                    \"Incorrect type for method arguments: \" + args.getClass());\n+        }\n+        int promiseId;\n+        if (invocationJson.hasKey(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE)) {\n+            promiseId = (int) invocationJson\n+                    .getNumber(JsonConstants.RPC_TEMPLATE_EVENT_PROMISE);\n+        } else {\n+            promiseId = -1;\n+        }\n+        assert node.hasFeature(ComponentMapping.class);\n+        Optional<Component> component = ComponentMapping.getComponent(node);\n+        if (!component.isPresent()) {\n+            throw new IllegalStateException(\n+                    \"Unable to handle RPC template event JSON message: \"\n+                            + \"there is no component available for the target node\");\n+        }\n+\n+        boolean execute = node.isEnabled();\n+\n+        if (!execute) {\n+            ClientCallableHandlers clientDelegate = node\n+                    .getFeature(ClientCallableHandlers.class);\n+            PolymerServerEventHandlers eventHandlers = node\n+                    .getFeature(PolymerServerEventHandlers.class);", "originalCommit": "d292c8de532e639ae82ada71cad245cfb657b71f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1NzM4OQ==", "url": "https://github.com/vaadin/flow/pull/9177#discussion_r504557389", "bodyText": "Remove this use of \"PolymerTemplate\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-10-14T10:05:30Z", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PublishedEventRpcHandlerUtil.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Type;\n+import java.util.Optional;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.component.UI;\n+import com.vaadin.flow.component.polymertemplate.PolymerTemplate;\n+import com.vaadin.flow.internal.StateNode;\n+import com.vaadin.flow.templatemodel.ModelType;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Polymer utilitiy class for handling polymer rpc events for @EventHandler.\n+ *\n+ * @since\n+ */\n+public class PublishedEventRpcHandlerUtil implements Serializable {\n+\n+    /**\n+     * Validate that the given Component instance is a PolymerTemplate and that\n+     * the value can be converted.\n+     *\n+     * @param instance\n+     *         Component to be validated\n+     * @param argValue\n+     *         received value\n+     * @param convertedType\n+     *         target type that value should be converted to\n+     * @return true if valid template model value\n+     */\n+    public static boolean isTemplateModelValue(Component instance,\n+            JsonValue argValue, Class<?> convertedType) {\n+        return instance instanceof PolymerTemplate", "originalCommit": "d292c8de532e639ae82ada71cad245cfb657b71f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1NzQwNA==", "url": "https://github.com/vaadin/flow/pull/9177#discussion_r504557404", "bodyText": "Remove this use of \"PolymerTemplate\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-10-14T10:05:31Z", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PublishedEventRpcHandlerUtil.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Type;\n+import java.util.Optional;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.component.UI;\n+import com.vaadin.flow.component.polymertemplate.PolymerTemplate;\n+import com.vaadin.flow.internal.StateNode;\n+import com.vaadin.flow.templatemodel.ModelType;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Polymer utilitiy class for handling polymer rpc events for @EventHandler.\n+ *\n+ * @since\n+ */\n+public class PublishedEventRpcHandlerUtil implements Serializable {\n+\n+    /**\n+     * Validate that the given Component instance is a PolymerTemplate and that\n+     * the value can be converted.\n+     *\n+     * @param instance\n+     *         Component to be validated\n+     * @param argValue\n+     *         received value\n+     * @param convertedType\n+     *         target type that value should be converted to\n+     * @return true if valid template model value\n+     */\n+    public static boolean isTemplateModelValue(Component instance,\n+            JsonValue argValue, Class<?> convertedType) {\n+        return instance instanceof PolymerTemplate\n+                && argValue instanceof JsonObject\n+                && ((PolymerTemplate<?>) instance)", "originalCommit": "d292c8de532e639ae82ada71cad245cfb657b71f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDU1NzQxMQ==", "url": "https://github.com/vaadin/flow/pull/9177#discussion_r504557411", "bodyText": "Remove this use of \"ModelType\"; it is deprecated. \n Remove this use of \"PolymerTemplate\"; it is deprecated.", "author": "vaadin-bot", "createdAt": "2020-10-14T10:05:32Z", "path": "flow-polymer-template/src/main/java/com/vaadin/flow/component/polymertemplate/rpc/PublishedEventRpcHandlerUtil.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2000-2020 Vaadin Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not\n+ * use this file except in compliance with the License. You may obtain a copy of\n+ * the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package com.vaadin.flow.component.polymertemplate.rpc;\n+\n+import java.io.Serializable;\n+import java.lang.reflect.Type;\n+import java.util.Optional;\n+\n+import com.vaadin.flow.component.Component;\n+import com.vaadin.flow.component.UI;\n+import com.vaadin.flow.component.polymertemplate.PolymerTemplate;\n+import com.vaadin.flow.internal.StateNode;\n+import com.vaadin.flow.templatemodel.ModelType;\n+\n+import elemental.json.JsonObject;\n+import elemental.json.JsonValue;\n+\n+/**\n+ * Polymer utilitiy class for handling polymer rpc events for @EventHandler.\n+ *\n+ * @since\n+ */\n+public class PublishedEventRpcHandlerUtil implements Serializable {\n+\n+    /**\n+     * Validate that the given Component instance is a PolymerTemplate and that\n+     * the value can be converted.\n+     *\n+     * @param instance\n+     *         Component to be validated\n+     * @param argValue\n+     *         received value\n+     * @param convertedType\n+     *         target type that value should be converted to\n+     * @return true if valid template model value\n+     */\n+    public static boolean isTemplateModelValue(Component instance,\n+            JsonValue argValue, Class<?> convertedType) {\n+        return instance instanceof PolymerTemplate\n+                && argValue instanceof JsonObject\n+                && ((PolymerTemplate<?>) instance)\n+                .isSupportedClass(convertedType) && ((JsonObject) argValue)\n+                .hasKey(\"nodeId\");\n+    }\n+\n+    /**\n+     * Get the template model object and type.\n+     *\n+     * @param template\n+     *         polymer template to get model from\n+     * @param argValue\n+     *         argument value\n+     * @param convertedType\n+     *         value type\n+     * @return the provided model value\n+     * @throws IllegalStateException\n+     *         if the component is not attached to the UI\n+         */\n+        public static Object getTemplateItem(Component template,\n+                JsonObject argValue, Type convertedType) {\n+            final Optional<UI> ui = template.getUI();\n+            if (ui.isPresent()) {\n+                StateNode node = ui.get().getInternals().getStateTree()\n+                        .getNodeById((int) argValue.getNumber(\"nodeId\"));\n+\n+                ModelType propertyType = ((PolymerTemplate<?>) template)", "originalCommit": "d292c8de532e639ae82ada71cad245cfb657b71f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}