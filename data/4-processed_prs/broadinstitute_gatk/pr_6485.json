{"pr_number": 6485, "pr_title": "Fix several bugs involving getReadCoordinateForReferenceCoordinate", "pr_createdAt": "2020-03-05T05:04:26Z", "pr_url": "https://github.com/broadinstitute/gatk/pull/6485", "timeline": [{"oid": "626e2db8029f6e9ee28ae6c6d359fa7a07479fbc", "url": "https://github.com/broadinstitute/gatk/commit/626e2db8029f6e9ee28ae6c6d359fa7a07479fbc", "message": "delete unused methods from ReadPosRankSumTest", "committedDate": "2020-03-03T18:55:42Z", "type": "commit"}, {"oid": "fc8f9444264482d134cd40168ad79afe1af62cb2", "url": "https://github.com/broadinstitute/gatk/commit/fc8f9444264482d134cd40168ad79afe1af62cb2", "message": "delete unused getMaxReadLength method", "committedDate": "2020-03-03T18:56:50Z", "type": "commit"}, {"oid": "06a2021787cb79322305bf22e51f05eac543a605", "url": "https://github.com/broadinstitute/gatk/commit/06a2021787cb79322305bf22e51f05eac543a605", "message": "rewrote getReadCoordinateForReferenceCoordinate", "committedDate": "2020-03-05T14:56:01Z", "type": "forcePushed"}, {"oid": "aa2f2bafb641d037263e43e107ee2c3ae866852b", "url": "https://github.com/broadinstitute/gatk/commit/aa2f2bafb641d037263e43e107ee2c3ae866852b", "message": "rewrote getReadCoordinateForReferenceCoordinate", "committedDate": "2020-03-05T16:16:23Z", "type": "commit"}, {"oid": "aa2f2bafb641d037263e43e107ee2c3ae866852b", "url": "https://github.com/broadinstitute/gatk/commit/aa2f2bafb641d037263e43e107ee2c3ae866852b", "message": "rewrote getReadCoordinateForReferenceCoordinate", "committedDate": "2020-03-05T16:16:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzOTkyOA==", "url": "https://github.com/broadinstitute/gatk/pull/6485#discussion_r389139928", "bodyText": "Does soft start mean the first base including soft-clipped bases? Or excluding?", "author": "takutosato", "createdAt": "2020-03-06T20:56:34Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/read/ReadUtils.java", "diffHunk": "@@ -666,205 +666,72 @@ public static int getSoftEnd(final GATKRead read) {\n         return softEnd;\n     }\n \n-    public static int getReadCoordinateForReferenceCoordinateUpToEndOfRead(final GATKRead read, final int refCoord, final ClippingTail tail) {\n-        return getReadCoordinateForReferenceCoordinateUpToEndOfRead(read, refCoord, tail, false);\n-    }\n-\n-    public static int getReadCoordinateForReferenceCoordinateUpToEndOfRead(final GATKRead read, final int refCoord, final ClippingTail tail, final boolean allowGoalNotReached) {\n-        final int leftmostSafeVariantPosition = Math.max(read.getSoftStart(), refCoord);\n-        return getReadCoordinateForReferenceCoordinate(read.getSoftStart(), read.getCigar(), leftmostSafeVariantPosition, tail, allowGoalNotReached);\n-    }\n-\n     /**\n-     * Pre-processes the results of {@link #getReadCoordinateForReferenceCoordinate(int, Cigar, int, boolean)} to take care of\n-     * two corner cases:\n-     *\n-     * 1. If clipping the right tail (end of the read) getReadCoordinateForReferenceCoordinate and fall inside\n-     * a deletion return the base after the deletion. If clipping the left tail (beginning of the read) it\n-     * doesn't matter because it already returns the previous base by default.\n-     *\n-     * 2. If clipping the left tail (beginning of the read) getReadCoordinateForReferenceCoordinate and the\n-     * read starts with an insertion, and you're requesting the first read based coordinate, it will skip\n-     * the leading insertion (because it has the same reference coordinate as the following base).\n-     *\n-     * @return the read coordinate corresponding to the requested reference coordinate for clipping.\n-     */\n-    public static int getReadCoordinateForReferenceCoordinate(final GATKRead read, final int refCoord, final ClippingTail tail) {\n-        return getReadCoordinateForReferenceCoordinate(read.getSoftStart(), read.getCigar(), refCoord, tail, false);\n+     * Find the index within a read's bases corresponding to a given position in the reference, along with the cigar operator of\n+     * the element containing that base.  If the reference coordinate occurs within a deletion, the first index after the deletion is returned.\n+     * Note that this treats soft-clipped bases as if they align with the reference, which is useful for hard-clipping reads with soft clips.\n+     *\n+     * @param alignmentStart        The soft start of the read on the reference", "originalCommit": "aa2f2bafb641d037263e43e107ee2c3ae866852b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE0Nzg1NA==", "url": "https://github.com/broadinstitute/gatk/pull/6485#discussion_r389147854", "bodyText": "I see, including", "author": "takutosato", "createdAt": "2020-03-06T21:15:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTEzOTkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE0Mzg2Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6485#discussion_r389143866", "bodyText": "Could you rename CLIPPING_GOAL_NOT_REACHED? I have a personal grudge against this particular variable. It used to scare me away from looking into it, and it feels out of place given that the clipping code and this method are now de-coupled. Maybe READ_INDEX_NOT_FOUND", "author": "takutosato", "createdAt": "2020-03-06T21:06:20Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/read/ReadUtils.java", "diffHunk": "@@ -666,205 +666,72 @@ public static int getSoftEnd(final GATKRead read) {\n         return softEnd;\n     }\n \n-    public static int getReadCoordinateForReferenceCoordinateUpToEndOfRead(final GATKRead read, final int refCoord, final ClippingTail tail) {\n-        return getReadCoordinateForReferenceCoordinateUpToEndOfRead(read, refCoord, tail, false);\n-    }\n-\n-    public static int getReadCoordinateForReferenceCoordinateUpToEndOfRead(final GATKRead read, final int refCoord, final ClippingTail tail, final boolean allowGoalNotReached) {\n-        final int leftmostSafeVariantPosition = Math.max(read.getSoftStart(), refCoord);\n-        return getReadCoordinateForReferenceCoordinate(read.getSoftStart(), read.getCigar(), leftmostSafeVariantPosition, tail, allowGoalNotReached);\n-    }\n-\n     /**\n-     * Pre-processes the results of {@link #getReadCoordinateForReferenceCoordinate(int, Cigar, int, boolean)} to take care of\n-     * two corner cases:\n-     *\n-     * 1. If clipping the right tail (end of the read) getReadCoordinateForReferenceCoordinate and fall inside\n-     * a deletion return the base after the deletion. If clipping the left tail (beginning of the read) it\n-     * doesn't matter because it already returns the previous base by default.\n-     *\n-     * 2. If clipping the left tail (beginning of the read) getReadCoordinateForReferenceCoordinate and the\n-     * read starts with an insertion, and you're requesting the first read based coordinate, it will skip\n-     * the leading insertion (because it has the same reference coordinate as the following base).\n-     *\n-     * @return the read coordinate corresponding to the requested reference coordinate for clipping.\n-     */\n-    public static int getReadCoordinateForReferenceCoordinate(final GATKRead read, final int refCoord, final ClippingTail tail) {\n-        return getReadCoordinateForReferenceCoordinate(read.getSoftStart(), read.getCigar(), refCoord, tail, false);\n+     * Find the index within a read's bases corresponding to a given position in the reference, along with the cigar operator of\n+     * the element containing that base.  If the reference coordinate occurs within a deletion, the first index after the deletion is returned.\n+     * Note that this treats soft-clipped bases as if they align with the reference, which is useful for hard-clipping reads with soft clips.\n+     *\n+     * @param alignmentStart        The soft start of the read on the reference\n+     * @param cigar                 The read's cigar\n+     * @param refCoord              The target reference coordinate\n+     * @return                      If the reference coordinate occurs before the read start or after the read end {@code CLIPPING_GOAL_NOT_REACHED};\n+     *                              if the reference coordinate falls within an alignment block of the read's cigar, the corresponding read coordinate;\n+     *                              if the reference coordinate falls within a deletion, the first read coordinate after the deletion.  Note: if the last cigar element is\n+     *                              a deletion (which isn't meaningful), it returns {@code CLIPPING_GOAL_NOT_REACHED}.\n+     */\n+    public static Pair<Integer, CigarOperator> getReadCoordinateForReferenceCoordinate(final int alignmentStart, final Cigar cigar, final int refCoord) {\n+        if (refCoord < alignmentStart) {\n+            return new MutablePair<>(CLIPPING_GOAL_NOT_REACHED, null);", "originalCommit": "aa2f2bafb641d037263e43e107ee2c3ae866852b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA5NjI4Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6485#discussion_r390096287", "bodyText": "Agreed.  done", "author": "davidbenjamin", "createdAt": "2020-03-10T05:01:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE0Mzg2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE0NzA2OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6485#discussion_r389147069", "bodyText": "Maybe it wouldn't hurt to say \"Find the zero-based index within a read's bases corresponding to a given 1-based position in the reference.'", "author": "takutosato", "createdAt": "2020-03-06T21:14:13Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/read/ReadUtils.java", "diffHunk": "@@ -666,205 +666,72 @@ public static int getSoftEnd(final GATKRead read) {\n         return softEnd;\n     }\n \n-    public static int getReadCoordinateForReferenceCoordinateUpToEndOfRead(final GATKRead read, final int refCoord, final ClippingTail tail) {\n-        return getReadCoordinateForReferenceCoordinateUpToEndOfRead(read, refCoord, tail, false);\n-    }\n-\n-    public static int getReadCoordinateForReferenceCoordinateUpToEndOfRead(final GATKRead read, final int refCoord, final ClippingTail tail, final boolean allowGoalNotReached) {\n-        final int leftmostSafeVariantPosition = Math.max(read.getSoftStart(), refCoord);\n-        return getReadCoordinateForReferenceCoordinate(read.getSoftStart(), read.getCigar(), leftmostSafeVariantPosition, tail, allowGoalNotReached);\n-    }\n-\n     /**\n-     * Pre-processes the results of {@link #getReadCoordinateForReferenceCoordinate(int, Cigar, int, boolean)} to take care of\n-     * two corner cases:\n-     *\n-     * 1. If clipping the right tail (end of the read) getReadCoordinateForReferenceCoordinate and fall inside\n-     * a deletion return the base after the deletion. If clipping the left tail (beginning of the read) it\n-     * doesn't matter because it already returns the previous base by default.\n-     *\n-     * 2. If clipping the left tail (beginning of the read) getReadCoordinateForReferenceCoordinate and the\n-     * read starts with an insertion, and you're requesting the first read based coordinate, it will skip\n-     * the leading insertion (because it has the same reference coordinate as the following base).\n-     *\n-     * @return the read coordinate corresponding to the requested reference coordinate for clipping.\n-     */\n-    public static int getReadCoordinateForReferenceCoordinate(final GATKRead read, final int refCoord, final ClippingTail tail) {\n-        return getReadCoordinateForReferenceCoordinate(read.getSoftStart(), read.getCigar(), refCoord, tail, false);\n+     * Find the index within a read's bases corresponding to a given position in the reference, along with the cigar operator of", "originalCommit": "aa2f2bafb641d037263e43e107ee2c3ae866852b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA5NDMxNg==", "url": "https://github.com/broadinstitute/gatk/pull/6485#discussion_r390094316", "bodyText": "done", "author": "davidbenjamin", "createdAt": "2020-03-10T04:51:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE0NzA2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1MzA4OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6485#discussion_r389153089", "bodyText": "getReadIndexForReferenceCoordinate might be a better name for this function, to contrast the 0-based index of a read and the 1-based coordinate of the reference.\nBut maybe it doesn't bother others and it would be kind of a messy change so I leave it totally up to you.", "author": "takutosato", "createdAt": "2020-03-06T21:28:49Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/read/ReadUtils.java", "diffHunk": "@@ -666,205 +666,72 @@ public static int getSoftEnd(final GATKRead read) {\n         return softEnd;\n     }\n \n-    public static int getReadCoordinateForReferenceCoordinateUpToEndOfRead(final GATKRead read, final int refCoord, final ClippingTail tail) {\n-        return getReadCoordinateForReferenceCoordinateUpToEndOfRead(read, refCoord, tail, false);\n-    }\n-\n-    public static int getReadCoordinateForReferenceCoordinateUpToEndOfRead(final GATKRead read, final int refCoord, final ClippingTail tail, final boolean allowGoalNotReached) {\n-        final int leftmostSafeVariantPosition = Math.max(read.getSoftStart(), refCoord);\n-        return getReadCoordinateForReferenceCoordinate(read.getSoftStart(), read.getCigar(), leftmostSafeVariantPosition, tail, allowGoalNotReached);\n-    }\n-\n     /**\n-     * Pre-processes the results of {@link #getReadCoordinateForReferenceCoordinate(int, Cigar, int, boolean)} to take care of\n-     * two corner cases:\n-     *\n-     * 1. If clipping the right tail (end of the read) getReadCoordinateForReferenceCoordinate and fall inside\n-     * a deletion return the base after the deletion. If clipping the left tail (beginning of the read) it\n-     * doesn't matter because it already returns the previous base by default.\n-     *\n-     * 2. If clipping the left tail (beginning of the read) getReadCoordinateForReferenceCoordinate and the\n-     * read starts with an insertion, and you're requesting the first read based coordinate, it will skip\n-     * the leading insertion (because it has the same reference coordinate as the following base).\n-     *\n-     * @return the read coordinate corresponding to the requested reference coordinate for clipping.\n-     */\n-    public static int getReadCoordinateForReferenceCoordinate(final GATKRead read, final int refCoord, final ClippingTail tail) {\n-        return getReadCoordinateForReferenceCoordinate(read.getSoftStart(), read.getCigar(), refCoord, tail, false);\n+     * Find the index within a read's bases corresponding to a given position in the reference, along with the cigar operator of\n+     * the element containing that base.  If the reference coordinate occurs within a deletion, the first index after the deletion is returned.\n+     * Note that this treats soft-clipped bases as if they align with the reference, which is useful for hard-clipping reads with soft clips.\n+     *\n+     * @param alignmentStart        The soft start of the read on the reference\n+     * @param cigar                 The read's cigar\n+     * @param refCoord              The target reference coordinate\n+     * @return                      If the reference coordinate occurs before the read start or after the read end {@code CLIPPING_GOAL_NOT_REACHED};\n+     *                              if the reference coordinate falls within an alignment block of the read's cigar, the corresponding read coordinate;\n+     *                              if the reference coordinate falls within a deletion, the first read coordinate after the deletion.  Note: if the last cigar element is\n+     *                              a deletion (which isn't meaningful), it returns {@code CLIPPING_GOAL_NOT_REACHED}.\n+     */\n+    public static Pair<Integer, CigarOperator> getReadCoordinateForReferenceCoordinate(final int alignmentStart, final Cigar cigar, final int refCoord) {", "originalCommit": "aa2f2bafb641d037263e43e107ee2c3ae866852b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA5NDYwNg==", "url": "https://github.com/broadinstitute/gatk/pull/6485#discussion_r390094606", "bodyText": "done", "author": "davidbenjamin", "createdAt": "2020-03-10T04:53:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTE1MzA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwNjc0Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6485#discussion_r389806742", "bodyText": "Is this checking that there are non-variant bases (i.e. bases that are not in the variant context) on either side of the inserted allele?", "author": "takutosato", "createdAt": "2020-03-09T16:27:45Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/haplotype/Haplotype.java", "diffHunk": "@@ -197,9 +197,17 @@ public void setCigar( final Cigar cigar ) {\n \n     public Haplotype insertAllele( final Allele refAllele, final Allele altAllele, final int refInsertLocation, final int genomicInsertLocation ) {\n         // refInsertLocation is in ref haplotype offset coordinates NOT genomic coordinates\n-        final int haplotypeInsertLocation = ReadUtils.getReadCoordinateForReferenceCoordinate(alignmentStartHapwrtRef, cigar, refInsertLocation, ClippingTail.RIGHT_TAIL, true);\n-        final byte[] myBases = this.getBases();\n-        if( haplotypeInsertLocation == -1 || haplotypeInsertLocation + refAllele.length() >= myBases.length ) { // desired change falls inside deletion so don't bother creating a new haplotype\n+        final Pair<Integer, CigarOperator> haplotypeInsertLocationAndOperator = ReadUtils.getReadCoordinateForReferenceCoordinate(alignmentStartHapwrtRef, cigar, refInsertLocation);\n+\n+        // can't insert outside the haplotype or into a deletion\n+        if( haplotypeInsertLocationAndOperator.getLeft() == ReadUtils.CLIPPING_GOAL_NOT_REACHED || !haplotypeInsertLocationAndOperator.getRight().consumesReadBases() ) {\n+            return null;\n+        }\n+        final int haplotypeInsertLocation = haplotypeInsertLocationAndOperator.getLeft();\n+        final byte[] myBases = getBases();\n+\n+        // can't insert if we don't have any sequence after the inserted alt allele to span the new variant\n+        if (haplotypeInsertLocation + refAllele.length() >= myBases.length) {", "originalCommit": "aa2f2bafb641d037263e43e107ee2c3ae866852b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA5NTY0Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6485#discussion_r390095642", "bodyText": "If the ref allele has n bases, you can think of the alt allele as deleting n - 1 bases (eg ACT -> A) followed, optionally by replacing those n - 1 bases (in the case of a MNP eg ACT -> A -> AGG).  Either way, if the haplotype doesn't contain those n - 1 bases it doesn't make sense to perform this transformation.\nThat is, suppose our haplotype is . . .ATTG.  Then we can insert an ATT -> A deletion by removing the TT, but we can't insert an ATTGC -> A deletion because the C is not there.", "author": "davidbenjamin", "createdAt": "2020-03-10T04:58:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwNjc0Mg=="}], "type": "inlineReview"}, {"oid": "eaf08531e647d8825c1b56f429d3e3924d6c644a", "url": "https://github.com/broadinstitute/gatk/commit/eaf08531e647d8825c1b56f429d3e3924d6c644a", "message": "Review edits", "committedDate": "2020-03-10T05:01:08Z", "type": "commit"}]}