{"pr_number": 6886, "pr_title": "Added functionality to better handle indels/spanning deletions in the cigar base quality adjustment code.", "pr_createdAt": "2020-10-14T17:35:54Z", "pr_url": "https://github.com/broadinstitute/gatk/pull/6886", "timeline": [{"oid": "cc7a21c08b14937b5400ff8fe0e58d4cffa940c8", "url": "https://github.com/broadinstitute/gatk/commit/cc7a21c08b14937b5400ff8fe0e58d4cffa940c8", "message": "added funcitonality to better handle indels/spanning deletions in the cigar for overlap bq adjustment code", "committedDate": "2020-10-14T17:32:22Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYyOTg4MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6886#discussion_r505629881", "bodyText": "You can extract the common +1 outside of the Math.min.", "author": "davidbenjamin", "createdAt": "2020-10-15T15:19:30Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/fragments/FragmentUtils.java", "diffHunk": "@@ -47,42 +47,48 @@ public static void adjustQualsOfOverlappingPairedFragments(final Pair<GATKRead,\n         final Pair<Integer, CigarOperator> offsetAndOperator = ReadUtils.getReadIndexForReferenceCoordinate(firstRead, secondRead.getStart());\n         final CigarOperator operator = offsetAndOperator.getRight();\n         final int offset = offsetAndOperator.getLeft();\n-        if (offset == ReadUtils.READ_INDEX_NOT_FOUND) { // no overlap\n+        if (offset == ReadUtils.READ_INDEX_NOT_FOUND || operator.isClipping()) { // no overlap or only overlap in clipped region\n             return;\n         }\n \n+        // Compute the final aligned base indexes for both since there might be right base softclips\n+        final int firstReadEndBase = ReadUtils.getReadIndexForReferenceCoordinate(firstRead, firstRead.getEnd()).getLeft();\n+        final int secondReadEndBase = ReadUtils.getReadIndexForReferenceCoordinate(secondRead, secondRead.getEnd()).getLeft();\n \n         // TODO: we should be careful about the case where {@code operator} is a deletion; that is, when the second read start falls in a deletion of the first read\n         // TODO: however, the issue is bigger than simply getting the start correctly, because the code below assumes that all bases of both reads are aligned in their overlap.\n         // TODO: Any indel that occurs in one read and not the other will spoil things.  Really, the correct thing to do is a Smith-Waterman (or other) alignment of the reads\n         // TODO: in their overlap and correct the double-counting for all aligned bases.\n         // TODO: a cheaper solution would be to cap all quals in the overlap region by half of the PCR qual.\n         final int firstReadStop = offset;\n-        final int numOverlappingBases = Math.min(firstRead.getLength() - firstReadStop, secondRead.getLength());\n+        final int secondOffset = ReadUtils.getReadIndexForReferenceCoordinate(secondRead, secondRead.getStart()).getLeft(); //This operation handles softclipped bases in the qual/base array\n+        final int numOverlappingBases = Math.min(firstReadEndBase + 1 - firstReadStop, secondReadEndBase + 1 - secondOffset); // Add 1 here because if R1 ends on the same base that R2 starts then there is 1 base of overlap not 0", "originalCommit": "cc7a21c08b14937b5400ff8fe0e58d4cffa940c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTYzNDI5OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6886#discussion_r505634299", "bodyText": "This comment seems detached from its code.", "author": "davidbenjamin", "createdAt": "2020-10-15T15:25:24Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/fragments/FragmentUtils.java", "diffHunk": "@@ -47,42 +47,48 @@ public static void adjustQualsOfOverlappingPairedFragments(final Pair<GATKRead,\n         final Pair<Integer, CigarOperator> offsetAndOperator = ReadUtils.getReadIndexForReferenceCoordinate(firstRead, secondRead.getStart());\n         final CigarOperator operator = offsetAndOperator.getRight();\n         final int offset = offsetAndOperator.getLeft();\n-        if (offset == ReadUtils.READ_INDEX_NOT_FOUND) { // no overlap\n+        if (offset == ReadUtils.READ_INDEX_NOT_FOUND || operator.isClipping()) { // no overlap or only overlap in clipped region\n             return;\n         }\n \n+        // Compute the final aligned base indexes for both since there might be right base softclips\n+        final int firstReadEndBase = ReadUtils.getReadIndexForReferenceCoordinate(firstRead, firstRead.getEnd()).getLeft();\n+        final int secondReadEndBase = ReadUtils.getReadIndexForReferenceCoordinate(secondRead, secondRead.getEnd()).getLeft();\n \n         // TODO: we should be careful about the case where {@code operator} is a deletion; that is, when the second read start falls in a deletion of the first read\n         // TODO: however, the issue is bigger than simply getting the start correctly, because the code below assumes that all bases of both reads are aligned in their overlap.\n         // TODO: Any indel that occurs in one read and not the other will spoil things.  Really, the correct thing to do is a Smith-Waterman (or other) alignment of the reads\n         // TODO: in their overlap and correct the double-counting for all aligned bases.\n         // TODO: a cheaper solution would be to cap all quals in the overlap region by half of the PCR qual.\n         final int firstReadStop = offset;\n-        final int numOverlappingBases = Math.min(firstRead.getLength() - firstReadStop, secondRead.getLength());\n+        final int secondOffset = ReadUtils.getReadIndexForReferenceCoordinate(secondRead, secondRead.getStart()).getLeft(); //This operation handles softclipped bases in the qual/base array\n+        final int numOverlappingBases = Math.min(firstReadEndBase + 1 - firstReadStop, secondReadEndBase + 1 - secondOffset); // Add 1 here because if R1 ends on the same base that R2 starts then there is 1 base of overlap not 0\n \n         final byte[] firstReadBases = firstRead.getBases();\n         final byte[] firstReadQuals = firstRead.getBaseQualities();\n         final byte[] secondReadBases = secondRead.getBases();\n         final byte[] secondReadQuals = secondRead.getBaseQualities();\n+        // adjustments to make to handle softclipping bases", "originalCommit": "cc7a21c08b14937b5400ff8fe0e58d4cffa940c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0MTI3OA==", "url": "https://github.com/broadinstitute/gatk/pull/6886#discussion_r505641278", "bodyText": "Overlaping needs a second 'p', and other needs to be capitalized.", "author": "davidbenjamin", "createdAt": "2020-10-15T15:34:52Z", "path": "src/test/java/org/broadinstitute/hellbender/utils/fragments/FragmentUtilsUnitTest.java", "diffHunk": "@@ -76,4 +76,110 @@ public void testAdjustingTwoReads(final GATKRead read1, final GATKRead read2, fi\n             Assert.assertEquals(read2.getBaseQualities()[i], HIGH_QUALITY);\n         }\n     }\n+\n+\n+    // Generate a bunch of reads with softclips that do not overlap with the other read.\n+    @DataProvider(name = \"AdjustFragmentsTestSoftClipsNotOverlapping\")\n+    public Object[][] createAdjustFragmentsTestSoftClips() throws Exception {\n+        List<Object[]> tests = new ArrayList<>();\n+\n+        final String leftFlank = \"CCC\";\n+        final String rightFlank = \"AAA\";\n+        final String allOverlappingBases = \"ACGTACGTGGAACCTTAG\";\n+        for ( int overlapSize = 1; overlapSize < allOverlappingBases.length(); overlapSize++ ) {\n+            for (int leftSoftclip = 0; leftSoftclip <= leftFlank.length(); leftSoftclip++) {\n+                for (int rightSoftclip = 0; rightSoftclip <= rightFlank.length(); rightSoftclip++) {\n+                    final String overlappingBases = allOverlappingBases.substring(0, overlapSize);\n+                    final byte[] overlappingBaseQuals = new byte[overlapSize];\n+                    for ( int i = 0; i < overlapSize; i++ ) {\n+                        overlappingBaseQuals[i] = HIGH_QUALITY;\n+                    }\n+                    final GATKRead read1  = makeOverlappingRead(leftFlank, HIGH_QUALITY, overlappingBases, overlappingBaseQuals, \"\", HIGH_QUALITY, 1, leftSoftclip, 0);\n+                    final GATKRead read2  = makeOverlappingRead(\"\", HIGH_QUALITY, overlappingBases, overlappingBaseQuals, rightFlank, HIGH_QUALITY, leftFlank.length() + 1, 0, rightSoftclip);\n+                    tests.add(new Object[]{read1, read2, overlapSize});\n+                }\n+            }\n+        }\n+        return tests.toArray(new Object[][]{});\n+    }\n+\n+    // Assert that despite the softclips that the reads are being properly\n+    @Test(dataProvider = \"AdjustFragmentsTestSoftClipsNotOverlapping\")\n+    public void testAdjustingTwoReadsWithSoftClipping(final GATKRead read1, final GATKRead read2, final int overlapSize) {\n+        FragmentUtils.adjustQualsOfOverlappingPairedFragments(ImmutablePair.of(read1, read2), true, OptionalInt.empty(), OptionalInt.empty());\n+\n+        for ( int i = 0; i < read1.getLength() - overlapSize; i++ ) {\n+            Assert.assertEquals(read1.getBaseQualities()[i], HIGH_QUALITY);\n+        }\n+        for ( int i = read1.getLength() - overlapSize; i < read1.getLength(); i++ ) {\n+            Assert.assertEquals(read1.getBaseQualities()[i], OVERLAPPING_QUALITY);\n+        }\n+\n+        for ( int i = 0; i < overlapSize; i++ ) {\n+            Assert.assertEquals(read2.getBaseQualities()[i], OVERLAPPING_QUALITY);\n+        }\n+        for ( int i = overlapSize; i < read2.getLength(); i++ ) {\n+            Assert.assertEquals(read2.getBaseQualities()[i], HIGH_QUALITY);\n+        }\n+    }\n+\n+\n+    // Generate a bunch of reads with softclips that are overlapping with the other read (and allow for reads with no overlap at all except for softclips)\n+    @DataProvider(name = \"AdjustFragmentsTestSoftClipsInOverlapRegion\")\n+    public Object[][] createAdjustFragmentsTestSoftClipsInOverlapRegion() throws Exception {\n+        List<Object[]> tests = new ArrayList<>();\n+\n+        final String leftFlank = \"CCC\";\n+        final String rightFlank = \"AAA\";\n+        final String allOverlappingBases = \"ACGTACGTGGAACCTTAG\";\n+        for ( int overlapSize = 1; overlapSize < allOverlappingBases.length(); overlapSize++ ) {\n+            for (int leftSoftclip = 0; leftSoftclip <= overlapSize; leftSoftclip++) {\n+                for (int rightSoftclip = 0; rightSoftclip <= overlapSize; rightSoftclip++) {\n+                    final String overlappingBases = allOverlappingBases.substring(0, overlapSize);\n+                    final byte[] overlappingBaseQuals = new byte[overlapSize];\n+                    for ( int i = 0; i < overlapSize; i++ ) {\n+                        overlappingBaseQuals[i] = HIGH_QUALITY;\n+                    }\n+                    // Flipped so that the softclips occur in the overlapping region instead\n+                    final GATKRead read1  = makeOverlappingRead(leftFlank, HIGH_QUALITY, overlappingBases, overlappingBaseQuals, \"\", HIGH_QUALITY, 1, 0, rightSoftclip);\n+                    final GATKRead read2  = makeOverlappingRead(\"\", HIGH_QUALITY, overlappingBases, overlappingBaseQuals, rightFlank, HIGH_QUALITY, leftFlank.length() + 1, leftSoftclip, 0);\n+                    tests.add(new Object[]{read1, rightSoftclip, read2, leftSoftclip, overlapSize});\n+                }\n+            }\n+        }\n+        return tests.toArray(new Object[][]{});\n+    }\n+\n+    // Assert that despite the softclips that the reads are being properly\n+    @Test(dataProvider = \"AdjustFragmentsTestSoftClipsInOverlapRegion\")\n+    public void testAdjustingTwoReadsWithSoftClippingOverlapingEachother(final GATKRead read1, final int read1Softclips, final GATKRead read2, final int read2Softclips, final int overlapSize) {", "originalCommit": "cc7a21c08b14937b5400ff8fe0e58d4cffa940c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0MTY0Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6886#discussion_r505641647", "bodyText": "properly _________?", "author": "davidbenjamin", "createdAt": "2020-10-15T15:35:24Z", "path": "src/test/java/org/broadinstitute/hellbender/utils/fragments/FragmentUtilsUnitTest.java", "diffHunk": "@@ -76,4 +76,110 @@ public void testAdjustingTwoReads(final GATKRead read1, final GATKRead read2, fi\n             Assert.assertEquals(read2.getBaseQualities()[i], HIGH_QUALITY);\n         }\n     }\n+\n+\n+    // Generate a bunch of reads with softclips that do not overlap with the other read.\n+    @DataProvider(name = \"AdjustFragmentsTestSoftClipsNotOverlapping\")\n+    public Object[][] createAdjustFragmentsTestSoftClips() throws Exception {\n+        List<Object[]> tests = new ArrayList<>();\n+\n+        final String leftFlank = \"CCC\";\n+        final String rightFlank = \"AAA\";\n+        final String allOverlappingBases = \"ACGTACGTGGAACCTTAG\";\n+        for ( int overlapSize = 1; overlapSize < allOverlappingBases.length(); overlapSize++ ) {\n+            for (int leftSoftclip = 0; leftSoftclip <= leftFlank.length(); leftSoftclip++) {\n+                for (int rightSoftclip = 0; rightSoftclip <= rightFlank.length(); rightSoftclip++) {\n+                    final String overlappingBases = allOverlappingBases.substring(0, overlapSize);\n+                    final byte[] overlappingBaseQuals = new byte[overlapSize];\n+                    for ( int i = 0; i < overlapSize; i++ ) {\n+                        overlappingBaseQuals[i] = HIGH_QUALITY;\n+                    }\n+                    final GATKRead read1  = makeOverlappingRead(leftFlank, HIGH_QUALITY, overlappingBases, overlappingBaseQuals, \"\", HIGH_QUALITY, 1, leftSoftclip, 0);\n+                    final GATKRead read2  = makeOverlappingRead(\"\", HIGH_QUALITY, overlappingBases, overlappingBaseQuals, rightFlank, HIGH_QUALITY, leftFlank.length() + 1, 0, rightSoftclip);\n+                    tests.add(new Object[]{read1, read2, overlapSize});\n+                }\n+            }\n+        }\n+        return tests.toArray(new Object[][]{});\n+    }\n+\n+    // Assert that despite the softclips that the reads are being properly", "originalCommit": "cc7a21c08b14937b5400ff8fe0e58d4cffa940c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY0NDQ5NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6886#discussion_r505644495", "bodyText": "Could you put in a test with indels with a comment that the behavior is not yet ideal?  It would help future efforts by clarifying exactly which cases currently don't work right.", "author": "davidbenjamin", "createdAt": "2020-10-15T15:39:17Z", "path": "src/test/java/org/broadinstitute/hellbender/utils/fragments/FragmentUtilsUnitTest.java", "diffHunk": "@@ -76,4 +76,110 @@ public void testAdjustingTwoReads(final GATKRead read1, final GATKRead read2, fi\n             Assert.assertEquals(read2.getBaseQualities()[i], HIGH_QUALITY);\n         }\n     }\n+\n+\n+    // Generate a bunch of reads with softclips that do not overlap with the other read.\n+    @DataProvider(name = \"AdjustFragmentsTestSoftClipsNotOverlapping\")\n+    public Object[][] createAdjustFragmentsTestSoftClips() throws Exception {\n+        List<Object[]> tests = new ArrayList<>();\n+\n+        final String leftFlank = \"CCC\";\n+        final String rightFlank = \"AAA\";\n+        final String allOverlappingBases = \"ACGTACGTGGAACCTTAG\";\n+        for ( int overlapSize = 1; overlapSize < allOverlappingBases.length(); overlapSize++ ) {\n+            for (int leftSoftclip = 0; leftSoftclip <= leftFlank.length(); leftSoftclip++) {\n+                for (int rightSoftclip = 0; rightSoftclip <= rightFlank.length(); rightSoftclip++) {\n+                    final String overlappingBases = allOverlappingBases.substring(0, overlapSize);\n+                    final byte[] overlappingBaseQuals = new byte[overlapSize];\n+                    for ( int i = 0; i < overlapSize; i++ ) {\n+                        overlappingBaseQuals[i] = HIGH_QUALITY;\n+                    }\n+                    final GATKRead read1  = makeOverlappingRead(leftFlank, HIGH_QUALITY, overlappingBases, overlappingBaseQuals, \"\", HIGH_QUALITY, 1, leftSoftclip, 0);\n+                    final GATKRead read2  = makeOverlappingRead(\"\", HIGH_QUALITY, overlappingBases, overlappingBaseQuals, rightFlank, HIGH_QUALITY, leftFlank.length() + 1, 0, rightSoftclip);\n+                    tests.add(new Object[]{read1, read2, overlapSize});\n+                }\n+            }\n+        }\n+        return tests.toArray(new Object[][]{});\n+    }\n+\n+    // Assert that despite the softclips that the reads are being properly\n+    @Test(dataProvider = \"AdjustFragmentsTestSoftClipsNotOverlapping\")\n+    public void testAdjustingTwoReadsWithSoftClipping(final GATKRead read1, final GATKRead read2, final int overlapSize) {", "originalCommit": "cc7a21c08b14937b5400ff8fe0e58d4cffa940c8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "baa6e543e5d04fa9441bbbcab8a2f79b18cdf152", "url": "https://github.com/broadinstitute/gatk/commit/baa6e543e5d04fa9441bbbcab8a2f79b18cdf152", "message": "Responded to review comments", "committedDate": "2020-10-15T16:54:11Z", "type": "commit"}]}