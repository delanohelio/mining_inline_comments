{"pr_number": 6427, "pr_title": "Rewrote leftAlignIndels code -- it now always works, even for multiple indels", "pr_createdAt": "2020-01-30T06:01:25Z", "pr_url": "https://github.com/broadinstitute/gatk/pull/6427", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk1NTUxNA==", "url": "https://github.com/broadinstitute/gatk/pull/6427#discussion_r372955514", "bodyText": "This looks like an unrelated change, did you intend to include in this PR?", "author": "kachulis", "createdAt": "2020-01-30T13:46:36Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/annotator/ReadPosRankSumTest.java", "diffHunk": "@@ -69,6 +70,9 @@ public static OptionalDouble getReadPosition(final GATKRead read, final int refL\n         final int leadingHardClips = firstElement.getOperator() == CigarOperator.HARD_CLIP ? firstElement.getLength() : 0;\n         final int trailingHardClips = lastElement.getOperator() == CigarOperator.HARD_CLIP ? lastElement.getLength() : 0;\n \n+        if (offset >= cigar.getReadLength()) {\n+            return OptionalDouble.empty();", "originalCommit": "8dce665c614dce6f2a95dcad328613bec44b856a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1OTk2NA==", "url": "https://github.com/broadinstitute/gatk/pull/6427#discussion_r374859964", "bodyText": "It's intentional.  A test was failing because correct left-alignment exposed an edge case.  I'm about to issue a PR related to ReadPosRankSumTest that will re-do this code.", "author": "davidbenjamin", "createdAt": "2020-02-04T18:56:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjk1NTUxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA0NjY4NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6427#discussion_r373046685", "bodyText": "Can just use cigar.getReferenceLength() or cigar.getPaddedReferenceLength()", "author": "kachulis", "createdAt": "2020-01-30T16:15:28Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/read/AlignmentUtils.java", "diffHunk": "@@ -763,178 +766,166 @@ private static boolean needsConsolidation(final Cigar c) {\n         return false;\n     }\n \n+\n+    private static int lengthOnRead(final CigarElement element) {\n+        return element.getOperator().consumesReadBases() ? element.getLength() : 0;\n+    }\n+\n+    private static int lengthOnReference(final CigarElement element) {\n+        return element.getOperator().consumesReferenceBases() ? element.getLength() : 0;\n+    }\n+\n     /**\n      * Takes the alignment of the read sequence <code>readSeq</code> to the reference sequence <code>refSeq</code>\n-     * starting at 0-based position <code>refIndex</code> on the <code>refSeq</code> and specified by its <code>cigar</code>.\n-     * The last argument <code>readIndex</code> specifies 0-based position on the read where the alignment described by the\n-     * <code>cigar</code> starts. Usually cigars specify alignments of the whole read to the ref, so that readIndex is normally 0.\n-     * Use non-zero readIndex only when the alignment cigar represents alignment of a part of the read. The refIndex in this case\n-     * should be the position where the alignment of that part of the read starts at. In other words, both refIndex and readIndex are\n-     * always the positions where the cigar starts on the ref and on the read, respectively.\n+     * starting at 0-based position <code>readStart</code> on the <code>ref</code> and specified by its <code>cigar</code>.\n      * <p/>\n      * If the alignment has one or more indels, this method attempts to move them left across a stretch of repetitive bases.\n      * For instance, if the original cigar specifies that (any) one AT is deleted from a repeat sequence TATATATA, the output\n      * cigar will always mark the leftmost AT as deleted. If there is no indel in the original cigar or if the indel position\n      * is determined unambiguously (i.e. inserted/deleted sequence is not repeated), the original cigar is returned.\n      *\n-     * Note that currently we do not actually support the case where there is more than one indel in the alignment.  We will throw\n-     * an exception if there is -- unless the\n      *\n      * @param cigar     structure of the original alignment\n-     * @param refSeq    reference sequence the read is aligned to\n-     * @param readSeq   read sequence\n-     * @param refIndex  0-based alignment start position on ref\n-     * @param readIndex 0-based alignment start position on read\n-     * @param leftmostAllowedAlignment left align indel no further left than this index (0-based)\n-     * @param doNotThrowExceptionForMultipleIndels  if true we will not throw an exception if we encounter multiple indels in the alignment will instead will return the original cigar\n+     * @param ref    reference sequence the read is aligned to\n+     * @param read   read sequence\n+     * @param readStart  0-based alignment start position on ref\n      * @return a non-null cigar, in which the indels are guaranteed to be placed at the leftmost possible position across a repeat (if any)\n      */\n+    public static Cigar leftAlignIndels(final Cigar cigar, final byte[] ref, final byte[] read, final int readStart) {\n+        ParamUtils.isPositiveOrZero(readStart, \"read start within reference base array must be non-negative\");\n \n-    public static Cigar leftAlignIndel(Cigar cigar, final byte[] refSeq, final byte[] readSeq, final int refIndex, final int readIndex, final int leftmostAllowedAlignment,final boolean doNotThrowExceptionForMultipleIndels) {\n-        ensureLeftAlignmentHasGoodArguments(cigar, refSeq, readSeq, refIndex, readIndex);\n-\n-        final int numIndels = countIndelElements(cigar);\n-        if ( numIndels == 0 )\n+        if (cigar.getCigarElements().stream().noneMatch(elem -> elem.getOperator().isIndel())) {\n             return cigar;\n-        if ( numIndels == 1 )\n-            return leftAlignSingleIndel(cigar, refSeq, readSeq, refIndex, readIndex, leftmostAllowedAlignment,true);\n+        }\n \n-        // if we got here then there is more than 1 indel in the alignment\n-        if ( doNotThrowExceptionForMultipleIndels )\n-            return cigar;\n+        // we need reference bases from the start of the read to the rightmost indel\n+        final int lastIndel = IntStream.range(0, cigar.numCigarElements()).filter(n -> cigar.getCigarElement(n).getOperator().isIndel()).max().getAsInt();\n+        final int necessaryRefLength = readStart + cigar.getCigarElements().stream().limit(lastIndel + 1).mapToInt(e -> lengthOnReference(e)).sum();\n+        Utils.validateArg(necessaryRefLength <= ref.length, \"read goes past end of reference\");\n+\n+        // at this point, we are one base past the end of the read.  Now we traverse the cigar from right to left\n+        final List<CigarElement> resultRightToLeft = new ArrayList<>();\n+        final int refLength = cigar.getCigarElements().stream().mapToInt(e -> lengthOnReference(e)).sum();", "originalCommit": "8dce665c614dce6f2a95dcad328613bec44b856a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg0MTg0Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6427#discussion_r374841842", "bodyText": "done", "author": "davidbenjamin", "createdAt": "2020-02-04T18:22:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA0NjY4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA4MTg2NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6427#discussion_r373081865", "bodyText": "rather have a single compound conditional than a while + if-else break.", "author": "kachulis", "createdAt": "2020-01-30T17:16:00Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/read/AlignmentUtils.java", "diffHunk": "@@ -763,178 +766,166 @@ private static boolean needsConsolidation(final Cigar c) {\n         return false;\n     }\n \n+\n+    private static int lengthOnRead(final CigarElement element) {\n+        return element.getOperator().consumesReadBases() ? element.getLength() : 0;\n+    }\n+\n+    private static int lengthOnReference(final CigarElement element) {\n+        return element.getOperator().consumesReferenceBases() ? element.getLength() : 0;\n+    }\n+\n     /**\n      * Takes the alignment of the read sequence <code>readSeq</code> to the reference sequence <code>refSeq</code>\n-     * starting at 0-based position <code>refIndex</code> on the <code>refSeq</code> and specified by its <code>cigar</code>.\n-     * The last argument <code>readIndex</code> specifies 0-based position on the read where the alignment described by the\n-     * <code>cigar</code> starts. Usually cigars specify alignments of the whole read to the ref, so that readIndex is normally 0.\n-     * Use non-zero readIndex only when the alignment cigar represents alignment of a part of the read. The refIndex in this case\n-     * should be the position where the alignment of that part of the read starts at. In other words, both refIndex and readIndex are\n-     * always the positions where the cigar starts on the ref and on the read, respectively.\n+     * starting at 0-based position <code>readStart</code> on the <code>ref</code> and specified by its <code>cigar</code>.\n      * <p/>\n      * If the alignment has one or more indels, this method attempts to move them left across a stretch of repetitive bases.\n      * For instance, if the original cigar specifies that (any) one AT is deleted from a repeat sequence TATATATA, the output\n      * cigar will always mark the leftmost AT as deleted. If there is no indel in the original cigar or if the indel position\n      * is determined unambiguously (i.e. inserted/deleted sequence is not repeated), the original cigar is returned.\n      *\n-     * Note that currently we do not actually support the case where there is more than one indel in the alignment.  We will throw\n-     * an exception if there is -- unless the\n      *\n      * @param cigar     structure of the original alignment\n-     * @param refSeq    reference sequence the read is aligned to\n-     * @param readSeq   read sequence\n-     * @param refIndex  0-based alignment start position on ref\n-     * @param readIndex 0-based alignment start position on read\n-     * @param leftmostAllowedAlignment left align indel no further left than this index (0-based)\n-     * @param doNotThrowExceptionForMultipleIndels  if true we will not throw an exception if we encounter multiple indels in the alignment will instead will return the original cigar\n+     * @param ref    reference sequence the read is aligned to\n+     * @param read   read sequence\n+     * @param readStart  0-based alignment start position on ref\n      * @return a non-null cigar, in which the indels are guaranteed to be placed at the leftmost possible position across a repeat (if any)\n      */\n+    public static Cigar leftAlignIndels(final Cigar cigar, final byte[] ref, final byte[] read, final int readStart) {\n+        ParamUtils.isPositiveOrZero(readStart, \"read start within reference base array must be non-negative\");\n \n-    public static Cigar leftAlignIndel(Cigar cigar, final byte[] refSeq, final byte[] readSeq, final int refIndex, final int readIndex, final int leftmostAllowedAlignment,final boolean doNotThrowExceptionForMultipleIndels) {\n-        ensureLeftAlignmentHasGoodArguments(cigar, refSeq, readSeq, refIndex, readIndex);\n-\n-        final int numIndels = countIndelElements(cigar);\n-        if ( numIndels == 0 )\n+        if (cigar.getCigarElements().stream().noneMatch(elem -> elem.getOperator().isIndel())) {\n             return cigar;\n-        if ( numIndels == 1 )\n-            return leftAlignSingleIndel(cigar, refSeq, readSeq, refIndex, readIndex, leftmostAllowedAlignment,true);\n+        }\n \n-        // if we got here then there is more than 1 indel in the alignment\n-        if ( doNotThrowExceptionForMultipleIndels )\n-            return cigar;\n+        // we need reference bases from the start of the read to the rightmost indel\n+        final int lastIndel = IntStream.range(0, cigar.numCigarElements()).filter(n -> cigar.getCigarElement(n).getOperator().isIndel()).max().getAsInt();\n+        final int necessaryRefLength = readStart + cigar.getCigarElements().stream().limit(lastIndel + 1).mapToInt(e -> lengthOnReference(e)).sum();\n+        Utils.validateArg(necessaryRefLength <= ref.length, \"read goes past end of reference\");\n+\n+        // at this point, we are one base past the end of the read.  Now we traverse the cigar from right to left\n+        final List<CigarElement> resultRightToLeft = new ArrayList<>();\n+        final int refLength = cigar.getCigarElements().stream().mapToInt(e -> lengthOnReference(e)).sum();\n+        final IndexRange refIndelRange = new IndexRange(readStart + refLength, readStart + refLength);\n+        final IndexRange readIndelRange = new IndexRange(read.length,read.length);\n+        for (int n = cigar.numCigarElements() - 1; n >= 0; n--) {\n+            final CigarElement element = cigar.getCigarElement(n);\n+            // if it's an indel, just accumulate the read and ref bases consumed.  We won't shift the indel until we hit an alignment\n+            // block or the read start.\n+            if (element.getOperator().isIndel()) {\n+                refIndelRange.shiftStartLeft(lengthOnReference(element));\n+                readIndelRange.shiftStartLeft(lengthOnRead(element));\n+            } else if (refIndelRange.size() == 0 && readIndelRange.size() == 0) {   // no indel, just add the cigar element to the result\n+                resultRightToLeft.add(element);\n+                refIndelRange.shiftLeft(lengthOnReference(element));\n+                readIndelRange.shiftLeft(lengthOnRead(element));\n+            } else {    // there's an indel that we need to left-align\n+                // we can left-align into match cigar elements but not into clips\n+                final int maxShift = element.getOperator().isAlignment() ? element.getLength() : 0;\n+                final Pair<Integer, Integer> shifts = leftAlignAlleles(Arrays.asList(ref, read), Arrays.asList(refIndelRange, readIndelRange), maxShift);\n+\n+                // account for new match alignments on the right due to left-alignment\n+                resultRightToLeft.add(new CigarElement(shifts.getRight(), CigarOperator.MATCH_OR_MISMATCH));\n+\n+                // emit if we didn't go all the way to the start of an alignment block OR we have reached clips OR we have reached the start of the cigar\n+                final boolean emitIndel = n == 0 || shifts.getLeft() < maxShift || !element.getOperator().isAlignment();\n+                final int remainingBasesOnLeft = element.getLength() - shifts.getLeft();\n+\n+                if (emitIndel) {  // some of this alignment block remains after left-alignment -- emit the indel\n+                    resultRightToLeft.add(new CigarElement(refIndelRange.size(), CigarOperator.DELETION));\n+                    resultRightToLeft.add(new CigarElement(readIndelRange.size(), CigarOperator.INSERTION));\n+                    refIndelRange.shiftEndLeft(refIndelRange.size());       // ref is empty and points to start of left-aligned indel\n+                    readIndelRange.shiftEndLeft(readIndelRange.size());     // read is empty and points to start of left-aligned indel\n+                    refIndelRange.shiftLeft(remainingBasesOnLeft);          // ref is empty and points to end of element preceding this match block\n+                    readIndelRange.shiftLeft(remainingBasesOnLeft);         // read is empty and points to end of element preceding this match block\n+                }\n+                resultRightToLeft.add(new CigarElement(remainingBasesOnLeft, element.getOperator()));\n+            }\n+        }\n \n-        throw new UnsupportedOperationException(\"attempting to left align a CIGAR that has more than 1 indel in its alignment but this functionality has not been implemented yet\");\n-    }\n-    public static Cigar leftAlignIndel(Cigar cigar, final byte[] refSeq, final byte[] readSeq, final int refIndex, final int readIndex, final boolean doNotThrowExceptionForMultipleIndels) {\n-        return leftAlignIndel(cigar, refSeq, readSeq, refIndex, readIndex, 0, doNotThrowExceptionForMultipleIndels);\n-    }\n+        // account for any indels at the start of the cigar that weren't processed because they have no adjacent non-indel element to the left\n+        resultRightToLeft.add(new CigarElement(refIndelRange.size(), CigarOperator.DELETION));\n+        resultRightToLeft.add(new CigarElement(readIndelRange.size(), CigarOperator.INSERTION));\n \n-    private static void ensureLeftAlignmentHasGoodArguments(final Cigar cigar, final byte[] refSeq, final byte[] readSeq, final int refIndex, final int readIndex) {\n-        Utils.nonNull( cigar );\n-        Utils.nonNull( refSeq );\n-        Utils.nonNull( readSeq );\n-        if ( refIndex < 0 ) throw new IllegalArgumentException(\"attempting to left align with a reference index less than 0\");\n-        if ( readIndex < 0 ) throw new IllegalArgumentException(\"attempting to left align with a read index less than 0\");\n+        Utils.validateArg(readIndelRange.getStart() == 0, \"Given cigar does not account for all bases of the read\");\n+        return AlignmentUtils.consolidateCigar(new Cigar(Lists.reverse(resultRightToLeft)));\n     }\n \n     /**\n-     * Counts the number of I/D operators\n+     *  Example usage:  reference = GAAT, read = GAAAT (insertion of one A) and we initially consider the insertion of the A to occur before\n+     *  the T.  Thus the reference range of this allele is [3,3) (no bases) and the read range is [3,4).  This will be left-aligned so that\n+     *  the insertion occurs after the G, so that the ranges become [1,1) and [1,2) and the returned shifts are 2 bases for both the start and end\n+     *  of the range.\n      *\n-     * @param cigar   cigar to check -- cannot be null\n-     * @return  non-negative count of indel operators\n-     */\n-    private static int countIndelElements(final Cigar cigar) {\n-        int indelCount = 0;\n-        for ( CigarElement ce : cigar.getCigarElements() ) {\n-            if ( ce.getOperator() == CigarOperator.D || ce.getOperator() == CigarOperator.I )\n-                indelCount++;\n-        }\n-        return indelCount;\n-    }\n-\n-    /**\n-     * See the documentation for AlignmentUtils.leftAlignIndel() for more details.\n+     *  If the given allele ranges are not parsimonious, for example [3,4) and [3,5) in the above example to include the common T in both alleles,\n+     *  the resulting ranges will be shifted by different amounts.  In this case, the shifts are 2 bases in the front and 3 at the end.\n      *\n-     * This flavor of the left alignment works if and only if the alignment has one - and only one - indel.\n-     * An exception is thrown if there are no indels or more than 1 indel in the alignment.\n+     *  Note that we use the convention that the ref allele in the case of an alt insertion, or the alt allele in case of a deletion, is represented\n+     *  by [n,n) where n is the last aligned coordinate before the indel.  This makes sense when you think in terms of alignment CIGARs: \n      *\n-     * @param cigar     structure of the original alignment -- cannot be null\n-     * @param refSeq    reference sequence the read is aligned to\n-     * @param readSeq   read sequence\n-     * @param refIndex  0-based alignment start position on ref\n-     * @param readIndex 0-based alignment start position on read\n-     * @param leftmostAllowedAlignment left align indel no further left than this index (0-based)\n-     * @param cleanupCigar if true, we'll cleanup the resulting cigar element, removing 0 length elements and deletions from the first cigar position\n-     * @return a non-null cigar, in which the single indel is guaranteed to be placed at the leftmost possible position across a repeat (if any)\n+     * @param sequences bases of sequences containing different alleles -- could be reference, a haplotype, a read, or subsequences thereof\n+     * @param bounds    initial ranges (inclusive start, exclusive end) of alleles in same order as {@code sequences}\n+     * @param maxShift  maximum allowable shift left.  This may be less than the amount demanded by the array bounds.  For example, when\n+     *                  left-aligning a read with multiple indels, we don't want to realign one indel past another (if they \"collide\" we merge\n+     *                  them into a single indel and continue -- see {@link AlignmentUtils::leftAlignIndels}\n+     * @return          The number of bases the alleles were shifted left such that they still represented the same event.\n      */\n-    public static Cigar leftAlignSingleIndel(Cigar cigar, final byte[] refSeq, final byte[] readSeq, final int refIndex, final int readIndex, final int leftmostAllowedAlignment,final boolean cleanupCigar) {\n-        ensureLeftAlignmentHasGoodArguments(cigar, refSeq, readSeq, refIndex, readIndex);\n-\n-        int indexOfIndel = -1;\n-        for (int i = 0; i < cigar.numCigarElements(); i++) {\n-            CigarElement ce = cigar.getCigarElement(i);\n-            if (ce.getOperator() == CigarOperator.D || ce.getOperator() == CigarOperator.I) {\n-                // if there is more than 1 indel, exception out\n-                if (indexOfIndel != -1)\n-                    throw new IllegalArgumentException(\"attempting to left align a CIGAR that has more than 1 indel in its alignment\");\n-                indexOfIndel = i;\n+    public static Pair<Integer, Integer> leftAlignAlleles(final List<byte[]> sequences, final List<IndexRange> bounds, final int maxShift) {\n+        Utils.nonEmpty(sequences);\n+        Utils.validateArg(sequences.size() == bounds.size(), \"Must have one initial allele range per sequence\");\n+        bounds.forEach(bound -> Utils.validateArg(maxShift <= bound.getStart(), \"maxShift goes past the start of a sequence\"));\n+\n+        int startShift = 0;\n+        int endShift = 0;\n+\n+        // consume any redundant shared bases at the end of the alleles\n+        int minSize = bounds.stream().mapToInt(IndexRange::size).min().getAsInt();\n+        while (minSize > 0) {\n+            if (lastBaseOnRightIsSame(sequences, bounds)) {", "originalCommit": "8dce665c614dce6f2a95dcad328613bec44b856a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg0MjMxMw==", "url": "https://github.com/broadinstitute/gatk/pull/6427#discussion_r374842313", "bodyText": "True.  done", "author": "davidbenjamin", "createdAt": "2020-02-04T18:22:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzA4MTg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3Mjc1Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6427#discussion_r373172752", "bodyText": "End with period (or include forgotten examples?)", "author": "kachulis", "createdAt": "2020-01-30T20:19:32Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/read/AlignmentUtils.java", "diffHunk": "@@ -763,178 +766,166 @@ private static boolean needsConsolidation(final Cigar c) {\n         return false;\n     }\n \n+\n+    private static int lengthOnRead(final CigarElement element) {\n+        return element.getOperator().consumesReadBases() ? element.getLength() : 0;\n+    }\n+\n+    private static int lengthOnReference(final CigarElement element) {\n+        return element.getOperator().consumesReferenceBases() ? element.getLength() : 0;\n+    }\n+\n     /**\n      * Takes the alignment of the read sequence <code>readSeq</code> to the reference sequence <code>refSeq</code>\n-     * starting at 0-based position <code>refIndex</code> on the <code>refSeq</code> and specified by its <code>cigar</code>.\n-     * The last argument <code>readIndex</code> specifies 0-based position on the read where the alignment described by the\n-     * <code>cigar</code> starts. Usually cigars specify alignments of the whole read to the ref, so that readIndex is normally 0.\n-     * Use non-zero readIndex only when the alignment cigar represents alignment of a part of the read. The refIndex in this case\n-     * should be the position where the alignment of that part of the read starts at. In other words, both refIndex and readIndex are\n-     * always the positions where the cigar starts on the ref and on the read, respectively.\n+     * starting at 0-based position <code>readStart</code> on the <code>ref</code> and specified by its <code>cigar</code>.\n      * <p/>\n      * If the alignment has one or more indels, this method attempts to move them left across a stretch of repetitive bases.\n      * For instance, if the original cigar specifies that (any) one AT is deleted from a repeat sequence TATATATA, the output\n      * cigar will always mark the leftmost AT as deleted. If there is no indel in the original cigar or if the indel position\n      * is determined unambiguously (i.e. inserted/deleted sequence is not repeated), the original cigar is returned.\n      *\n-     * Note that currently we do not actually support the case where there is more than one indel in the alignment.  We will throw\n-     * an exception if there is -- unless the\n      *\n      * @param cigar     structure of the original alignment\n-     * @param refSeq    reference sequence the read is aligned to\n-     * @param readSeq   read sequence\n-     * @param refIndex  0-based alignment start position on ref\n-     * @param readIndex 0-based alignment start position on read\n-     * @param leftmostAllowedAlignment left align indel no further left than this index (0-based)\n-     * @param doNotThrowExceptionForMultipleIndels  if true we will not throw an exception if we encounter multiple indels in the alignment will instead will return the original cigar\n+     * @param ref    reference sequence the read is aligned to\n+     * @param read   read sequence\n+     * @param readStart  0-based alignment start position on ref\n      * @return a non-null cigar, in which the indels are guaranteed to be placed at the leftmost possible position across a repeat (if any)\n      */\n+    public static Cigar leftAlignIndels(final Cigar cigar, final byte[] ref, final byte[] read, final int readStart) {\n+        ParamUtils.isPositiveOrZero(readStart, \"read start within reference base array must be non-negative\");\n \n-    public static Cigar leftAlignIndel(Cigar cigar, final byte[] refSeq, final byte[] readSeq, final int refIndex, final int readIndex, final int leftmostAllowedAlignment,final boolean doNotThrowExceptionForMultipleIndels) {\n-        ensureLeftAlignmentHasGoodArguments(cigar, refSeq, readSeq, refIndex, readIndex);\n-\n-        final int numIndels = countIndelElements(cigar);\n-        if ( numIndels == 0 )\n+        if (cigar.getCigarElements().stream().noneMatch(elem -> elem.getOperator().isIndel())) {\n             return cigar;\n-        if ( numIndels == 1 )\n-            return leftAlignSingleIndel(cigar, refSeq, readSeq, refIndex, readIndex, leftmostAllowedAlignment,true);\n+        }\n \n-        // if we got here then there is more than 1 indel in the alignment\n-        if ( doNotThrowExceptionForMultipleIndels )\n-            return cigar;\n+        // we need reference bases from the start of the read to the rightmost indel\n+        final int lastIndel = IntStream.range(0, cigar.numCigarElements()).filter(n -> cigar.getCigarElement(n).getOperator().isIndel()).max().getAsInt();\n+        final int necessaryRefLength = readStart + cigar.getCigarElements().stream().limit(lastIndel + 1).mapToInt(e -> lengthOnReference(e)).sum();\n+        Utils.validateArg(necessaryRefLength <= ref.length, \"read goes past end of reference\");\n+\n+        // at this point, we are one base past the end of the read.  Now we traverse the cigar from right to left\n+        final List<CigarElement> resultRightToLeft = new ArrayList<>();\n+        final int refLength = cigar.getCigarElements().stream().mapToInt(e -> lengthOnReference(e)).sum();\n+        final IndexRange refIndelRange = new IndexRange(readStart + refLength, readStart + refLength);\n+        final IndexRange readIndelRange = new IndexRange(read.length,read.length);\n+        for (int n = cigar.numCigarElements() - 1; n >= 0; n--) {\n+            final CigarElement element = cigar.getCigarElement(n);\n+            // if it's an indel, just accumulate the read and ref bases consumed.  We won't shift the indel until we hit an alignment\n+            // block or the read start.\n+            if (element.getOperator().isIndel()) {\n+                refIndelRange.shiftStartLeft(lengthOnReference(element));\n+                readIndelRange.shiftStartLeft(lengthOnRead(element));\n+            } else if (refIndelRange.size() == 0 && readIndelRange.size() == 0) {   // no indel, just add the cigar element to the result\n+                resultRightToLeft.add(element);\n+                refIndelRange.shiftLeft(lengthOnReference(element));\n+                readIndelRange.shiftLeft(lengthOnRead(element));\n+            } else {    // there's an indel that we need to left-align\n+                // we can left-align into match cigar elements but not into clips\n+                final int maxShift = element.getOperator().isAlignment() ? element.getLength() : 0;\n+                final Pair<Integer, Integer> shifts = leftAlignAlleles(Arrays.asList(ref, read), Arrays.asList(refIndelRange, readIndelRange), maxShift);\n+\n+                // account for new match alignments on the right due to left-alignment\n+                resultRightToLeft.add(new CigarElement(shifts.getRight(), CigarOperator.MATCH_OR_MISMATCH));\n+\n+                // emit if we didn't go all the way to the start of an alignment block OR we have reached clips OR we have reached the start of the cigar\n+                final boolean emitIndel = n == 0 || shifts.getLeft() < maxShift || !element.getOperator().isAlignment();\n+                final int remainingBasesOnLeft = element.getLength() - shifts.getLeft();\n+\n+                if (emitIndel) {  // some of this alignment block remains after left-alignment -- emit the indel\n+                    resultRightToLeft.add(new CigarElement(refIndelRange.size(), CigarOperator.DELETION));\n+                    resultRightToLeft.add(new CigarElement(readIndelRange.size(), CigarOperator.INSERTION));\n+                    refIndelRange.shiftEndLeft(refIndelRange.size());       // ref is empty and points to start of left-aligned indel\n+                    readIndelRange.shiftEndLeft(readIndelRange.size());     // read is empty and points to start of left-aligned indel\n+                    refIndelRange.shiftLeft(remainingBasesOnLeft);          // ref is empty and points to end of element preceding this match block\n+                    readIndelRange.shiftLeft(remainingBasesOnLeft);         // read is empty and points to end of element preceding this match block\n+                }\n+                resultRightToLeft.add(new CigarElement(remainingBasesOnLeft, element.getOperator()));\n+            }\n+        }\n \n-        throw new UnsupportedOperationException(\"attempting to left align a CIGAR that has more than 1 indel in its alignment but this functionality has not been implemented yet\");\n-    }\n-    public static Cigar leftAlignIndel(Cigar cigar, final byte[] refSeq, final byte[] readSeq, final int refIndex, final int readIndex, final boolean doNotThrowExceptionForMultipleIndels) {\n-        return leftAlignIndel(cigar, refSeq, readSeq, refIndex, readIndex, 0, doNotThrowExceptionForMultipleIndels);\n-    }\n+        // account for any indels at the start of the cigar that weren't processed because they have no adjacent non-indel element to the left\n+        resultRightToLeft.add(new CigarElement(refIndelRange.size(), CigarOperator.DELETION));\n+        resultRightToLeft.add(new CigarElement(readIndelRange.size(), CigarOperator.INSERTION));\n \n-    private static void ensureLeftAlignmentHasGoodArguments(final Cigar cigar, final byte[] refSeq, final byte[] readSeq, final int refIndex, final int readIndex) {\n-        Utils.nonNull( cigar );\n-        Utils.nonNull( refSeq );\n-        Utils.nonNull( readSeq );\n-        if ( refIndex < 0 ) throw new IllegalArgumentException(\"attempting to left align with a reference index less than 0\");\n-        if ( readIndex < 0 ) throw new IllegalArgumentException(\"attempting to left align with a read index less than 0\");\n+        Utils.validateArg(readIndelRange.getStart() == 0, \"Given cigar does not account for all bases of the read\");\n+        return AlignmentUtils.consolidateCigar(new Cigar(Lists.reverse(resultRightToLeft)));\n     }\n \n     /**\n-     * Counts the number of I/D operators\n+     *  Example usage:  reference = GAAT, read = GAAAT (insertion of one A) and we initially consider the insertion of the A to occur before\n+     *  the T.  Thus the reference range of this allele is [3,3) (no bases) and the read range is [3,4).  This will be left-aligned so that\n+     *  the insertion occurs after the G, so that the ranges become [1,1) and [1,2) and the returned shifts are 2 bases for both the start and end\n+     *  of the range.\n      *\n-     * @param cigar   cigar to check -- cannot be null\n-     * @return  non-negative count of indel operators\n-     */\n-    private static int countIndelElements(final Cigar cigar) {\n-        int indelCount = 0;\n-        for ( CigarElement ce : cigar.getCigarElements() ) {\n-            if ( ce.getOperator() == CigarOperator.D || ce.getOperator() == CigarOperator.I )\n-                indelCount++;\n-        }\n-        return indelCount;\n-    }\n-\n-    /**\n-     * See the documentation for AlignmentUtils.leftAlignIndel() for more details.\n+     *  If the given allele ranges are not parsimonious, for example [3,4) and [3,5) in the above example to include the common T in both alleles,\n+     *  the resulting ranges will be shifted by different amounts.  In this case, the shifts are 2 bases in the front and 3 at the end.\n      *\n-     * This flavor of the left alignment works if and only if the alignment has one - and only one - indel.\n-     * An exception is thrown if there are no indels or more than 1 indel in the alignment.\n+     *  Note that we use the convention that the ref allele in the case of an alt insertion, or the alt allele in case of a deletion, is represented\n+     *  by [n,n) where n is the last aligned coordinate before the indel.  This makes sense when you think in terms of alignment CIGARs: ", "originalCommit": "8dce665c614dce6f2a95dcad328613bec44b856a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg0MzU4MA==", "url": "https://github.com/broadinstitute/gatk/pull/6427#discussion_r374843580", "bodyText": "done", "author": "davidbenjamin", "createdAt": "2020-02-04T18:25:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE3Mjc1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE4MTE0Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6427#discussion_r373181147", "bodyText": "I think this code is left aligning and partially making parsimonious; it only make the representation parsimonious if the common base is on the right.  If we are going to be trimming in this method, I think we should allow trimming on both sides, and rename the method something like normalizeAlleles.", "author": "kachulis", "createdAt": "2020-01-30T20:38:33Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/read/AlignmentUtils.java", "diffHunk": "@@ -763,178 +766,166 @@ private static boolean needsConsolidation(final Cigar c) {\n         return false;\n     }\n \n+\n+    private static int lengthOnRead(final CigarElement element) {\n+        return element.getOperator().consumesReadBases() ? element.getLength() : 0;\n+    }\n+\n+    private static int lengthOnReference(final CigarElement element) {\n+        return element.getOperator().consumesReferenceBases() ? element.getLength() : 0;\n+    }\n+\n     /**\n      * Takes the alignment of the read sequence <code>readSeq</code> to the reference sequence <code>refSeq</code>\n-     * starting at 0-based position <code>refIndex</code> on the <code>refSeq</code> and specified by its <code>cigar</code>.\n-     * The last argument <code>readIndex</code> specifies 0-based position on the read where the alignment described by the\n-     * <code>cigar</code> starts. Usually cigars specify alignments of the whole read to the ref, so that readIndex is normally 0.\n-     * Use non-zero readIndex only when the alignment cigar represents alignment of a part of the read. The refIndex in this case\n-     * should be the position where the alignment of that part of the read starts at. In other words, both refIndex and readIndex are\n-     * always the positions where the cigar starts on the ref and on the read, respectively.\n+     * starting at 0-based position <code>readStart</code> on the <code>ref</code> and specified by its <code>cigar</code>.\n      * <p/>\n      * If the alignment has one or more indels, this method attempts to move them left across a stretch of repetitive bases.\n      * For instance, if the original cigar specifies that (any) one AT is deleted from a repeat sequence TATATATA, the output\n      * cigar will always mark the leftmost AT as deleted. If there is no indel in the original cigar or if the indel position\n      * is determined unambiguously (i.e. inserted/deleted sequence is not repeated), the original cigar is returned.\n      *\n-     * Note that currently we do not actually support the case where there is more than one indel in the alignment.  We will throw\n-     * an exception if there is -- unless the\n      *\n      * @param cigar     structure of the original alignment\n-     * @param refSeq    reference sequence the read is aligned to\n-     * @param readSeq   read sequence\n-     * @param refIndex  0-based alignment start position on ref\n-     * @param readIndex 0-based alignment start position on read\n-     * @param leftmostAllowedAlignment left align indel no further left than this index (0-based)\n-     * @param doNotThrowExceptionForMultipleIndels  if true we will not throw an exception if we encounter multiple indels in the alignment will instead will return the original cigar\n+     * @param ref    reference sequence the read is aligned to\n+     * @param read   read sequence\n+     * @param readStart  0-based alignment start position on ref\n      * @return a non-null cigar, in which the indels are guaranteed to be placed at the leftmost possible position across a repeat (if any)\n      */\n+    public static Cigar leftAlignIndels(final Cigar cigar, final byte[] ref, final byte[] read, final int readStart) {\n+        ParamUtils.isPositiveOrZero(readStart, \"read start within reference base array must be non-negative\");\n \n-    public static Cigar leftAlignIndel(Cigar cigar, final byte[] refSeq, final byte[] readSeq, final int refIndex, final int readIndex, final int leftmostAllowedAlignment,final boolean doNotThrowExceptionForMultipleIndels) {\n-        ensureLeftAlignmentHasGoodArguments(cigar, refSeq, readSeq, refIndex, readIndex);\n-\n-        final int numIndels = countIndelElements(cigar);\n-        if ( numIndels == 0 )\n+        if (cigar.getCigarElements().stream().noneMatch(elem -> elem.getOperator().isIndel())) {\n             return cigar;\n-        if ( numIndels == 1 )\n-            return leftAlignSingleIndel(cigar, refSeq, readSeq, refIndex, readIndex, leftmostAllowedAlignment,true);\n+        }\n \n-        // if we got here then there is more than 1 indel in the alignment\n-        if ( doNotThrowExceptionForMultipleIndels )\n-            return cigar;\n+        // we need reference bases from the start of the read to the rightmost indel\n+        final int lastIndel = IntStream.range(0, cigar.numCigarElements()).filter(n -> cigar.getCigarElement(n).getOperator().isIndel()).max().getAsInt();\n+        final int necessaryRefLength = readStart + cigar.getCigarElements().stream().limit(lastIndel + 1).mapToInt(e -> lengthOnReference(e)).sum();\n+        Utils.validateArg(necessaryRefLength <= ref.length, \"read goes past end of reference\");\n+\n+        // at this point, we are one base past the end of the read.  Now we traverse the cigar from right to left\n+        final List<CigarElement> resultRightToLeft = new ArrayList<>();\n+        final int refLength = cigar.getCigarElements().stream().mapToInt(e -> lengthOnReference(e)).sum();\n+        final IndexRange refIndelRange = new IndexRange(readStart + refLength, readStart + refLength);\n+        final IndexRange readIndelRange = new IndexRange(read.length,read.length);\n+        for (int n = cigar.numCigarElements() - 1; n >= 0; n--) {\n+            final CigarElement element = cigar.getCigarElement(n);\n+            // if it's an indel, just accumulate the read and ref bases consumed.  We won't shift the indel until we hit an alignment\n+            // block or the read start.\n+            if (element.getOperator().isIndel()) {\n+                refIndelRange.shiftStartLeft(lengthOnReference(element));\n+                readIndelRange.shiftStartLeft(lengthOnRead(element));\n+            } else if (refIndelRange.size() == 0 && readIndelRange.size() == 0) {   // no indel, just add the cigar element to the result\n+                resultRightToLeft.add(element);\n+                refIndelRange.shiftLeft(lengthOnReference(element));\n+                readIndelRange.shiftLeft(lengthOnRead(element));\n+            } else {    // there's an indel that we need to left-align\n+                // we can left-align into match cigar elements but not into clips\n+                final int maxShift = element.getOperator().isAlignment() ? element.getLength() : 0;\n+                final Pair<Integer, Integer> shifts = leftAlignAlleles(Arrays.asList(ref, read), Arrays.asList(refIndelRange, readIndelRange), maxShift);\n+\n+                // account for new match alignments on the right due to left-alignment\n+                resultRightToLeft.add(new CigarElement(shifts.getRight(), CigarOperator.MATCH_OR_MISMATCH));\n+\n+                // emit if we didn't go all the way to the start of an alignment block OR we have reached clips OR we have reached the start of the cigar\n+                final boolean emitIndel = n == 0 || shifts.getLeft() < maxShift || !element.getOperator().isAlignment();\n+                final int remainingBasesOnLeft = element.getLength() - shifts.getLeft();\n+\n+                if (emitIndel) {  // some of this alignment block remains after left-alignment -- emit the indel\n+                    resultRightToLeft.add(new CigarElement(refIndelRange.size(), CigarOperator.DELETION));\n+                    resultRightToLeft.add(new CigarElement(readIndelRange.size(), CigarOperator.INSERTION));\n+                    refIndelRange.shiftEndLeft(refIndelRange.size());       // ref is empty and points to start of left-aligned indel\n+                    readIndelRange.shiftEndLeft(readIndelRange.size());     // read is empty and points to start of left-aligned indel\n+                    refIndelRange.shiftLeft(remainingBasesOnLeft);          // ref is empty and points to end of element preceding this match block\n+                    readIndelRange.shiftLeft(remainingBasesOnLeft);         // read is empty and points to end of element preceding this match block\n+                }\n+                resultRightToLeft.add(new CigarElement(remainingBasesOnLeft, element.getOperator()));\n+            }\n+        }\n \n-        throw new UnsupportedOperationException(\"attempting to left align a CIGAR that has more than 1 indel in its alignment but this functionality has not been implemented yet\");\n-    }\n-    public static Cigar leftAlignIndel(Cigar cigar, final byte[] refSeq, final byte[] readSeq, final int refIndex, final int readIndex, final boolean doNotThrowExceptionForMultipleIndels) {\n-        return leftAlignIndel(cigar, refSeq, readSeq, refIndex, readIndex, 0, doNotThrowExceptionForMultipleIndels);\n-    }\n+        // account for any indels at the start of the cigar that weren't processed because they have no adjacent non-indel element to the left\n+        resultRightToLeft.add(new CigarElement(refIndelRange.size(), CigarOperator.DELETION));\n+        resultRightToLeft.add(new CigarElement(readIndelRange.size(), CigarOperator.INSERTION));\n \n-    private static void ensureLeftAlignmentHasGoodArguments(final Cigar cigar, final byte[] refSeq, final byte[] readSeq, final int refIndex, final int readIndex) {\n-        Utils.nonNull( cigar );\n-        Utils.nonNull( refSeq );\n-        Utils.nonNull( readSeq );\n-        if ( refIndex < 0 ) throw new IllegalArgumentException(\"attempting to left align with a reference index less than 0\");\n-        if ( readIndex < 0 ) throw new IllegalArgumentException(\"attempting to left align with a read index less than 0\");\n+        Utils.validateArg(readIndelRange.getStart() == 0, \"Given cigar does not account for all bases of the read\");\n+        return AlignmentUtils.consolidateCigar(new Cigar(Lists.reverse(resultRightToLeft)));\n     }\n \n     /**\n-     * Counts the number of I/D operators\n+     *  Example usage:  reference = GAAT, read = GAAAT (insertion of one A) and we initially consider the insertion of the A to occur before\n+     *  the T.  Thus the reference range of this allele is [3,3) (no bases) and the read range is [3,4).  This will be left-aligned so that\n+     *  the insertion occurs after the G, so that the ranges become [1,1) and [1,2) and the returned shifts are 2 bases for both the start and end\n+     *  of the range.\n      *\n-     * @param cigar   cigar to check -- cannot be null\n-     * @return  non-negative count of indel operators\n-     */\n-    private static int countIndelElements(final Cigar cigar) {\n-        int indelCount = 0;\n-        for ( CigarElement ce : cigar.getCigarElements() ) {\n-            if ( ce.getOperator() == CigarOperator.D || ce.getOperator() == CigarOperator.I )\n-                indelCount++;\n-        }\n-        return indelCount;\n-    }\n-\n-    /**\n-     * See the documentation for AlignmentUtils.leftAlignIndel() for more details.\n+     *  If the given allele ranges are not parsimonious, for example [3,4) and [3,5) in the above example to include the common T in both alleles,\n+     *  the resulting ranges will be shifted by different amounts.  In this case, the shifts are 2 bases in the front and 3 at the end.\n      *\n-     * This flavor of the left alignment works if and only if the alignment has one - and only one - indel.\n-     * An exception is thrown if there are no indels or more than 1 indel in the alignment.\n+     *  Note that we use the convention that the ref allele in the case of an alt insertion, or the alt allele in case of a deletion, is represented\n+     *  by [n,n) where n is the last aligned coordinate before the indel.  This makes sense when you think in terms of alignment CIGARs: \n      *\n-     * @param cigar     structure of the original alignment -- cannot be null\n-     * @param refSeq    reference sequence the read is aligned to\n-     * @param readSeq   read sequence\n-     * @param refIndex  0-based alignment start position on ref\n-     * @param readIndex 0-based alignment start position on read\n-     * @param leftmostAllowedAlignment left align indel no further left than this index (0-based)\n-     * @param cleanupCigar if true, we'll cleanup the resulting cigar element, removing 0 length elements and deletions from the first cigar position\n-     * @return a non-null cigar, in which the single indel is guaranteed to be placed at the leftmost possible position across a repeat (if any)\n+     * @param sequences bases of sequences containing different alleles -- could be reference, a haplotype, a read, or subsequences thereof\n+     * @param bounds    initial ranges (inclusive start, exclusive end) of alleles in same order as {@code sequences}\n+     * @param maxShift  maximum allowable shift left.  This may be less than the amount demanded by the array bounds.  For example, when\n+     *                  left-aligning a read with multiple indels, we don't want to realign one indel past another (if they \"collide\" we merge\n+     *                  them into a single indel and continue -- see {@link AlignmentUtils::leftAlignIndels}\n+     * @return          The number of bases the alleles were shifted left such that they still represented the same event.\n      */\n-    public static Cigar leftAlignSingleIndel(Cigar cigar, final byte[] refSeq, final byte[] readSeq, final int refIndex, final int readIndex, final int leftmostAllowedAlignment,final boolean cleanupCigar) {\n-        ensureLeftAlignmentHasGoodArguments(cigar, refSeq, readSeq, refIndex, readIndex);\n-\n-        int indexOfIndel = -1;\n-        for (int i = 0; i < cigar.numCigarElements(); i++) {\n-            CigarElement ce = cigar.getCigarElement(i);\n-            if (ce.getOperator() == CigarOperator.D || ce.getOperator() == CigarOperator.I) {\n-                // if there is more than 1 indel, exception out\n-                if (indexOfIndel != -1)\n-                    throw new IllegalArgumentException(\"attempting to left align a CIGAR that has more than 1 indel in its alignment\");\n-                indexOfIndel = i;\n+    public static Pair<Integer, Integer> leftAlignAlleles(final List<byte[]> sequences, final List<IndexRange> bounds, final int maxShift) {", "originalCommit": "8dce665c614dce6f2a95dcad328613bec44b856a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5ODc0Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6427#discussion_r374898742", "bodyText": "done", "author": "davidbenjamin", "createdAt": "2020-02-04T20:15:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE4MTE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE4OTc4MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6427#discussion_r373189781", "bodyText": "alternatively, if leftAlignAlleles is adjusted to make alignment fully parsimonious (perhaps with the parsimonious part optional, though I don't really understand why we allow that with the dont-trim-alleles option), then everything can be done though that method and we don't need to separate out into two different steps.", "author": "kachulis", "createdAt": "2020-01-30T20:57:51Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/variantutils/LeftAlignAndTrimVariants.java", "diffHunk": "@@ -352,127 +289,56 @@ protected int trimAlign(final VariantContext vc, final ReferenceContext ref) {\n      * @param ref Reference context\n      * @return new VC.\n      */\n-    protected VariantContext leftAlign(final VariantContext vc, final ReferenceContext ref) {\n-        if (!vc.isSimpleIndel()) {\n+    @VisibleForTesting\n+    static VariantContext leftAlign(final VariantContext vc, final ReferenceContext ref, final int maxLeadingBases) {\n+        if (!vc.isIndel()) {\n             return vc;\n         }\n \n-        // get the indel length\n-        final int indelLength = Math.abs(vc.getIndelLengths().get(0));\n+        for(int leadingBases = 10; leadingBases < maxLeadingBases; leadingBases *= 2) {\n+            final int refStart = Math.max(vc.getStart() - leadingBases, 1);\n \n-        // check that indel isn't too long\n-        if (indelLength > maxIndelSize) {\n-            logger.info(String.format(\"%s (%d) at position %s:%d; skipping that record. Set --max-indel-length >= %d\",\n-                    \"Indel is too long\", indelLength, vc.getContig(), vc.getStart(), indelLength));\n-            numSkippedForLength++;\n-            if (indelLength > longestSkippedVariant) {\n-                longestSkippedVariant = indelLength;\n-            }\n-            //still write out variant, just don't try to left align\n-            return vc;\n-        }\n+            // reference sequence starting before the variant (to give space for left-alignment) and ending at the variant end\n+            final byte[] refSeq = ref.getBases(new SimpleInterval(vc.getContig(), refStart, vc.getEnd()));\n+\n+            final int variantOffsetInRef = vc.getStart() - refStart;\n+\n+            final List<byte[]> sequences = vc.getAlleles().stream().map(a -> {\n+                final byte[] result = new byte[variantOffsetInRef + a.length()];\n+                System.arraycopy(refSeq, 0, result, 0, variantOffsetInRef);\n+                System.arraycopy(a.getBases(), 0, result, variantOffsetInRef, a.length());\n+                return result;\n+            }).collect(Collectors.toList());\n \n-        int leadingBases = Math.max(50, indelLength);\n-\n-        while (leadingBases < maxLeadingBases) {\n-            ref.setWindow(leadingBases, maxIndelSize);\n-            final byte[] refSeq = ref.getBases();\n-\n-            // create an indel haplotype.\n-            //\n-            final int originalIndex = vc.getStart() - ref.getWindow().getStart() + 1;\n-            final byte[] originalIndel = makeHaplotype(vc, refSeq, originalIndex, indelLength);\n-            // create a CIGAR string to represent the event\n-            ArrayList<CigarElement> elements = new ArrayList<CigarElement>();\n-            elements.add(new CigarElement(originalIndex, CigarOperator.M));\n-            elements.add(new CigarElement(indelLength, vc.isSimpleDeletion() ? CigarOperator.D : CigarOperator.I));\n-            elements.add(new CigarElement(refSeq.length - originalIndex, CigarOperator.M));\n-            Cigar originalCigar = new Cigar(elements);\n-\n-            // align no further left than base after previous variant\n-            int leftmostAllowedAlignment = furthestEndOfEarlierVariant - ref.getWindow().getStart() + 2;\n-            // left align the CIGAR\n-            Cigar newCigar = AlignmentUtils.leftAlignIndel(originalCigar, refSeq, originalIndel, 0, 0, leftmostAllowedAlignment, true);\n-            if (newCigar.equals(originalCigar)) {\n+            final List<IndexRange> alleleRanges = vc.getAlleles().stream()\n+                    .map(a -> new IndexRange(variantOffsetInRef + 1, variantOffsetInRef + a.length()))\n+                    .collect(Collectors.toList());\n+\n+            // note that this also shifts the index ranges as a side effect, so below they can be used to output allele bases\n+            // since trimming is performed elsewhere, we care only about the start shift\n+            final int shift = AlignmentUtils.leftAlignAlleles(sequences, alleleRanges, variantOffsetInRef).getLeft();", "originalCommit": "8dce665c614dce6f2a95dcad328613bec44b856a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg5ODY3NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6427#discussion_r374898675", "bodyText": "done", "author": "davidbenjamin", "createdAt": "2020-02-04T20:14:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE4OTc4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE5OTU4MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6427#discussion_r373199581", "bodyText": "you can use element.getOperator() (like you do below) instead of CigarOperator.MATCH_OR_MISMATCH to avoid throwing out information", "author": "kachulis", "createdAt": "2020-01-30T21:20:43Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/read/AlignmentUtils.java", "diffHunk": "@@ -763,178 +766,166 @@ private static boolean needsConsolidation(final Cigar c) {\n         return false;\n     }\n \n+\n+    private static int lengthOnRead(final CigarElement element) {\n+        return element.getOperator().consumesReadBases() ? element.getLength() : 0;\n+    }\n+\n+    private static int lengthOnReference(final CigarElement element) {\n+        return element.getOperator().consumesReferenceBases() ? element.getLength() : 0;\n+    }\n+\n     /**\n      * Takes the alignment of the read sequence <code>readSeq</code> to the reference sequence <code>refSeq</code>\n-     * starting at 0-based position <code>refIndex</code> on the <code>refSeq</code> and specified by its <code>cigar</code>.\n-     * The last argument <code>readIndex</code> specifies 0-based position on the read where the alignment described by the\n-     * <code>cigar</code> starts. Usually cigars specify alignments of the whole read to the ref, so that readIndex is normally 0.\n-     * Use non-zero readIndex only when the alignment cigar represents alignment of a part of the read. The refIndex in this case\n-     * should be the position where the alignment of that part of the read starts at. In other words, both refIndex and readIndex are\n-     * always the positions where the cigar starts on the ref and on the read, respectively.\n+     * starting at 0-based position <code>readStart</code> on the <code>ref</code> and specified by its <code>cigar</code>.\n      * <p/>\n      * If the alignment has one or more indels, this method attempts to move them left across a stretch of repetitive bases.\n      * For instance, if the original cigar specifies that (any) one AT is deleted from a repeat sequence TATATATA, the output\n      * cigar will always mark the leftmost AT as deleted. If there is no indel in the original cigar or if the indel position\n      * is determined unambiguously (i.e. inserted/deleted sequence is not repeated), the original cigar is returned.\n      *\n-     * Note that currently we do not actually support the case where there is more than one indel in the alignment.  We will throw\n-     * an exception if there is -- unless the\n      *\n      * @param cigar     structure of the original alignment\n-     * @param refSeq    reference sequence the read is aligned to\n-     * @param readSeq   read sequence\n-     * @param refIndex  0-based alignment start position on ref\n-     * @param readIndex 0-based alignment start position on read\n-     * @param leftmostAllowedAlignment left align indel no further left than this index (0-based)\n-     * @param doNotThrowExceptionForMultipleIndels  if true we will not throw an exception if we encounter multiple indels in the alignment will instead will return the original cigar\n+     * @param ref    reference sequence the read is aligned to\n+     * @param read   read sequence\n+     * @param readStart  0-based alignment start position on ref\n      * @return a non-null cigar, in which the indels are guaranteed to be placed at the leftmost possible position across a repeat (if any)\n      */\n+    public static Cigar leftAlignIndels(final Cigar cigar, final byte[] ref, final byte[] read, final int readStart) {\n+        ParamUtils.isPositiveOrZero(readStart, \"read start within reference base array must be non-negative\");\n \n-    public static Cigar leftAlignIndel(Cigar cigar, final byte[] refSeq, final byte[] readSeq, final int refIndex, final int readIndex, final int leftmostAllowedAlignment,final boolean doNotThrowExceptionForMultipleIndels) {\n-        ensureLeftAlignmentHasGoodArguments(cigar, refSeq, readSeq, refIndex, readIndex);\n-\n-        final int numIndels = countIndelElements(cigar);\n-        if ( numIndels == 0 )\n+        if (cigar.getCigarElements().stream().noneMatch(elem -> elem.getOperator().isIndel())) {\n             return cigar;\n-        if ( numIndels == 1 )\n-            return leftAlignSingleIndel(cigar, refSeq, readSeq, refIndex, readIndex, leftmostAllowedAlignment,true);\n+        }\n \n-        // if we got here then there is more than 1 indel in the alignment\n-        if ( doNotThrowExceptionForMultipleIndels )\n-            return cigar;\n+        // we need reference bases from the start of the read to the rightmost indel\n+        final int lastIndel = IntStream.range(0, cigar.numCigarElements()).filter(n -> cigar.getCigarElement(n).getOperator().isIndel()).max().getAsInt();\n+        final int necessaryRefLength = readStart + cigar.getCigarElements().stream().limit(lastIndel + 1).mapToInt(e -> lengthOnReference(e)).sum();\n+        Utils.validateArg(necessaryRefLength <= ref.length, \"read goes past end of reference\");\n+\n+        // at this point, we are one base past the end of the read.  Now we traverse the cigar from right to left\n+        final List<CigarElement> resultRightToLeft = new ArrayList<>();\n+        final int refLength = cigar.getCigarElements().stream().mapToInt(e -> lengthOnReference(e)).sum();\n+        final IndexRange refIndelRange = new IndexRange(readStart + refLength, readStart + refLength);\n+        final IndexRange readIndelRange = new IndexRange(read.length,read.length);\n+        for (int n = cigar.numCigarElements() - 1; n >= 0; n--) {\n+            final CigarElement element = cigar.getCigarElement(n);\n+            // if it's an indel, just accumulate the read and ref bases consumed.  We won't shift the indel until we hit an alignment\n+            // block or the read start.\n+            if (element.getOperator().isIndel()) {\n+                refIndelRange.shiftStartLeft(lengthOnReference(element));\n+                readIndelRange.shiftStartLeft(lengthOnRead(element));\n+            } else if (refIndelRange.size() == 0 && readIndelRange.size() == 0) {   // no indel, just add the cigar element to the result\n+                resultRightToLeft.add(element);\n+                refIndelRange.shiftLeft(lengthOnReference(element));\n+                readIndelRange.shiftLeft(lengthOnRead(element));\n+            } else {    // there's an indel that we need to left-align\n+                // we can left-align into match cigar elements but not into clips\n+                final int maxShift = element.getOperator().isAlignment() ? element.getLength() : 0;\n+                final Pair<Integer, Integer> shifts = leftAlignAlleles(Arrays.asList(ref, read), Arrays.asList(refIndelRange, readIndelRange), maxShift);\n+\n+                // account for new match alignments on the right due to left-alignment\n+                resultRightToLeft.add(new CigarElement(shifts.getRight(), CigarOperator.MATCH_OR_MISMATCH));", "originalCommit": "8dce665c614dce6f2a95dcad328613bec44b856a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1ODYwNg==", "url": "https://github.com/broadinstitute/gatk/pull/6427#discussion_r374858606", "bodyText": "It's different here because below we're re-emitting a shorter version of a cigar element that already existed.  Here we're creating something new resulting from the left-alignment.", "author": "davidbenjamin", "createdAt": "2020-02-04T18:54:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE5OTU4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYzOTg2OA==", "url": "https://github.com/broadinstitute/gatk/pull/6427#discussion_r373639868", "bodyText": "final", "author": "kachulis", "createdAt": "2020-01-31T19:12:38Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/LeftAlignIndels.java", "diffHunk": "@@ -66,25 +64,19 @@ public boolean requiresReference() {\n \n     @Override\n     public void onTraversalStart() {\n-        outputWriter = createSAMWriter(IOUtils.getPath(OUTPUT), true);\n+        outputWriter = createSAMWriter(IOUtils.getPath(output), true);\n     }\n \n     @Override\n     public void apply( GATKRead read, ReferenceContext ref, FeatureContext featureContext ) {\n-        // we can not deal with screwy records\n-        if ( read.isUnmapped() || read.numCigarElements() == 0 ) {\n+        // we can not deal with screwy records, and reads with a single cigar element are a trivial case\n+        if ( read.isUnmapped() || read.numCigarElements() <= 1 ) {\n             outputWriter.addRead(read);\n             return;\n         }\n \n-        // move existing indels (for 1 indel reads only) to leftmost position within identical sequence\n-        int numBlocks = AlignmentUtils.getNumAlignmentBlocks(read);\n-        if ( numBlocks == 2 ) {\n-            // We checked in onTraversalStart() that a reference is present, so ref.get() is safe\n-            Cigar newCigar = AlignmentUtils.leftAlignIndel(CigarUtils.trimReadToUnclippedBases(read.getCigar()), ref.getBases(), read.getBases(), 0, 0, true);\n-            newCigar = CigarUtils.reclipCigar(newCigar, read);\n-            read.setCigar(newCigar);\n-        }\n+        Cigar newCigar = AlignmentUtils.leftAlignIndels(read.getCigar(), ref.getBases(), read.getBases(), 0);", "originalCommit": "8dce665c614dce6f2a95dcad328613bec44b856a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1NzA0NA==", "url": "https://github.com/broadinstitute/gatk/pull/6427#discussion_r374857044", "bodyText": "done", "author": "davidbenjamin", "createdAt": "2020-02-04T18:51:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzYzOTg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY5NTA1Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6427#discussion_r373695057", "bodyText": "I think this actually requires much more careful handling.  Left aligning in the presence of other variants is more complicated than just left aligning each variant separately and leaving them where they fall.  For example, when a deletion moves from after a SNP to before a SNP, the position of the SNP record needs to change, otherwise you have actually changed the represented haplotype, which we definitely want to avoid.", "author": "kachulis", "createdAt": "2020-01-31T21:32:29Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/variantutils/LeftAlignAndTrimVariants.java", "diffHunk": "@@ -175,39 +176,21 @@\n     private boolean suppressReferencePath = false;\n \n     private VariantContextWriter vcfWriter = null;\n-    private int numRealignedVariants;\n-    private int numVariantsSplit;\n-    private int numVariantsSplitTo;\n-    private int numVariantsTrimmed;\n-    @VisibleForTesting\n-    int numSkippedForLength;\n-    @VisibleForTesting\n-    int longestSkippedVariant;\n-    private int furthestEndOfEarlierVariant;\n-    private String currentContig;\n \n-    /**\n-     * Set up the VCF writer, samples\n-     */\n+    // it is possible that left-alignment changes the order of variants.  For example, an indel in an STR may left align past a\n+    // SNP in the same STR that doesn't move.  Thus we can only emit variants that are sufficiently far behind the current one.\n+    PriorityQueue<VariantContext> pendingVariants;", "originalCommit": "8dce665c614dce6f2a95dcad328613bec44b856a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg1NTM3Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6427#discussion_r374855377", "bodyText": "Thanks for the catch and the offline explanation.  Done.", "author": "davidbenjamin", "createdAt": "2020-02-04T18:48:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzY5NTA1Nw=="}], "type": "inlineReview"}, {"oid": "13c8db5eed9741e8071aa493a474f1c0382259b6", "url": "https://github.com/broadinstitute/gatk/commit/13c8db5eed9741e8071aa493a474f1c0382259b6", "message": "review edits", "committedDate": "2020-02-05T05:18:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkzODg5NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6427#discussion_r375938895", "bodyText": "I believe there is a bug here (quite possibly originating prior to this PR).  If maxLeadingBases is greater than 10, but not a multiple of 10, there can be problems.  Suppose maxLeadingBases=15, and the indel should be left aligned that full amount.  leadingBases will initialize to 10, and the indel will left align the full 10 bases.  leadingBases will then double to 20, the for loop condition will be false, and the variant won't be shifted left at all.  I think this is easy to fix, just needs a slight adjustment to the control flow logic.\nAlso would be nice to have a test of this type of case, to ensure it is handled correctly.", "author": "kachulis", "createdAt": "2020-02-06T16:24:17Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/variantutils/LeftAlignAndTrimVariants.java", "diffHunk": "@@ -352,127 +273,56 @@ protected int trimAlign(final VariantContext vc, final ReferenceContext ref) {\n      * @param ref Reference context\n      * @return new VC.\n      */\n-    protected VariantContext leftAlign(final VariantContext vc, final ReferenceContext ref) {\n-        if (!vc.isSimpleIndel()) {\n+    @VisibleForTesting\n+    static VariantContext leftAlignAndTrim(final VariantContext vc, final ReferenceContext ref, final int maxLeadingBases, final boolean trim) {\n+        if (!vc.isIndel() || maxLeadingBases <= 0) {\n             return vc;\n         }\n \n-        // get the indel length\n-        final int indelLength = Math.abs(vc.getIndelLengths().get(0));\n+        for(int leadingBases = Math.min(maxLeadingBases, 10); leadingBases <= maxLeadingBases; leadingBases *= 2) {", "originalCommit": "13c8db5eed9741e8071aa493a474f1c0382259b6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjA4Mjk3Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6427#discussion_r376082976", "bodyText": "done", "author": "davidbenjamin", "createdAt": "2020-02-06T21:09:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTkzODg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQyMzc2OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6427#discussion_r376423769", "bodyText": "Don't need the Math.min here, since it's the condition in the for loop.", "author": "kachulis", "createdAt": "2020-02-07T14:39:18Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/variantutils/LeftAlignAndTrimVariants.java", "diffHunk": "@@ -279,7 +279,8 @@ static VariantContext leftAlignAndTrim(final VariantContext vc, final ReferenceC\n             return vc;\n         }\n \n-        for(int leadingBases = Math.min(maxLeadingBases, 10); leadingBases <= maxLeadingBases; leadingBases *= 2) {\n+\n+        for(int leadingBases = Math.min(maxLeadingBases, 10); leadingBases <= maxLeadingBases; leadingBases = Math.min(2*leadingBases, maxLeadingBases)) {\n             final int refStart = Math.max(vc.getStart() - Math.min(leadingBases, maxLeadingBases), 1);", "originalCommit": "22c7836a1f9ce30712942f34e47ff1dcd2927c14", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQ0ODE0MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6427#discussion_r376448141", "bodyText": "I agree.", "author": "davidbenjamin", "createdAt": "2020-02-07T15:22:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjQyMzc2OQ=="}], "type": "inlineReview"}, {"oid": "9fae3e50c77fa69a564dd433f6c6790393494501", "url": "https://github.com/broadinstitute/gatk/commit/9fae3e50c77fa69a564dd433f6c6790393494501", "message": "rebase test files", "committedDate": "2020-02-07T16:54:58Z", "type": "forcePushed"}, {"oid": "1a8ef5d84d8d253cca44a7ffade8c4862ec92b65", "url": "https://github.com/broadinstitute/gatk/commit/1a8ef5d84d8d253cca44a7ffade8c4862ec92b65", "message": "Rewrote leftAlignIndels code -- it now always works, even for multiple indels", "committedDate": "2020-02-07T19:22:17Z", "type": "forcePushed"}, {"oid": "88315b918331f925312f9d6ed056427c8efb85b4", "url": "https://github.com/broadinstitute/gatk/commit/88315b918331f925312f9d6ed056427c8efb85b4", "message": "Rewrote leftAlignIndels code -- it now always works, even for multiple indels", "committedDate": "2020-02-07T20:52:00Z", "type": "commit"}, {"oid": "ba09f3a2de2e689aa26ab58be6777d62f72ad04c", "url": "https://github.com/broadinstitute/gatk/commit/ba09f3a2de2e689aa26ab58be6777d62f72ad04c", "message": "more rebase", "committedDate": "2020-02-07T20:53:23Z", "type": "commit"}, {"oid": "ba09f3a2de2e689aa26ab58be6777d62f72ad04c", "url": "https://github.com/broadinstitute/gatk/commit/ba09f3a2de2e689aa26ab58be6777d62f72ad04c", "message": "more rebase", "committedDate": "2020-02-07T20:53:23Z", "type": "forcePushed"}]}