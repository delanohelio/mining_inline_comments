{"pr_number": 6477, "pr_title": "Updated Funcotator to support ENSEMBL GTF files (and non-human species).", "pr_createdAt": "2020-03-02T18:46:49Z", "pr_url": "https://github.com/broadinstitute/gatk/pull/6477", "timeline": [{"oid": "56946054b064ad72f2caac3f6801a7556908abf3", "url": "https://github.com/broadinstitute/gatk/commit/56946054b064ad72f2caac3f6801a7556908abf3", "message": "Rebasing and fixed failing tests.", "committedDate": "2020-03-03T16:44:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYwMDEyNA==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r386600124", "bodyText": "I would just delete this if you're switching away from the enum.", "author": "lbergelson", "createdAt": "2020-03-02T19:24:56Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/funcotator/BaseFuncotatorArgumentCollection.java", "diffHunk": "@@ -15,18 +15,29 @@\n abstract class BaseFuncotatorArgumentCollection implements Serializable {\n     private static final long serialVersionUID = 1L;\n \n-    protected enum FuncotatorReferenceVersion {\n-        hg19(\"hg19\"),hg38(\"hg38\"),b37(\"b37\");\n-\n-        private final String stringRepresentation;\n-\n-        FuncotatorReferenceVersion(final String stringRepresentation) {\n-            this.stringRepresentation = stringRepresentation;\n-        }\n-\n-        @Override\n-        public String toString() { return stringRepresentation; }\n-    }\n+//    protected enum FuncotatorReferenceVersion {", "originalCommit": "dcfbbfe0136c8ff0bab8bb520fe5e1ea8eedae72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1MjI2Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387852262", "bodyText": "Oops.  Yeah - I meant to take this out eventually, just commented it out while I was working on it.\nFixed!", "author": "jonn-smith", "createdAt": "2020-03-04T18:28:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYwMDEyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYwNTM5Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r386605396", "bodyText": "You could drop the throws here but it doesn't really matter since the superclass throws.", "author": "lbergelson", "createdAt": "2020-03-02T19:34:51Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/codecs/gtf/AbstractGtfCodec.java", "diffHunk": "@@ -0,0 +1,344 @@\n+package org.broadinstitute.hellbender.utils.codecs.gtf;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.util.CloserUtil;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.LocationAware;\n+import htsjdk.tribble.AbstractFeatureCodec;\n+import htsjdk.tribble.Feature;\n+import htsjdk.tribble.FeatureCodecHeader;\n+import htsjdk.tribble.readers.*;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+\n+import java.io.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+public abstract class AbstractGtfCodec<T extends Feature> extends AbstractFeatureCodec<T, LineIterator> {\n+\n+    static final Logger logger = LogManager.getLogger(AbstractGtfCodec.class);\n+\n+    //==================================================================================================================\n+    // Public Static Members:\n+    public static final String GTF_FILE_EXTENSION = \"gtf\";\n+\n+    //==================================================================================================================\n+    // Private/Protected Static Members:\n+    static final int HEADER_NUM_LINES = 5;\n+    static final String FIELD_DELIMITER = \"\\t\";\n+\n+    static final int NUM_COLUMNS = 9;\n+    static final int FEATURE_TYPE_FIELD_INDEX = 2;\n+\n+    //==================================================================================================================\n+    // Private Members:\n+\n+\n+    //==================================================================================================================\n+    // Constructors:\n+    protected AbstractGtfCodec(final Class<T> myClass) {\n+        super(myClass);\n+    }\n+\n+    //==================================================================================================================\n+    // Override Methods:\n+\n+    @Override\n+    public boolean canDecode(final String inputFilePath) {\n+\n+        boolean canDecode;\n+        try {\n+            // Simple file and name checks to start with:\n+            final Path p = IOUtil.getPath(inputFilePath);\n+\n+            canDecode = passesFileNameCheck(inputFilePath);\n+\n+            if (canDecode) {\n+\n+                // Crack open the file and look at the top of it:\n+                try ( final BufferedReader br = new BufferedReader(new InputStreamReader(Files.newInputStream(p))) ) {\n+\n+                    // TThe first HEADER_NUM_LINES compose the header of a valid GTF File:\n+                    final List<String> headerLines = new ArrayList<>(HEADER_NUM_LINES);\n+\n+                    for (int i = 0; i < HEADER_NUM_LINES; ++i) {\n+                        final String line = br.readLine();\n+                        if ( line == null ) {\n+                            break;\n+                        }\n+                        headerLines.add( line );\n+                    }\n+\n+                    // Validate our header:\n+                    canDecode = validateHeader(headerLines);\n+                }\n+\n+            }\n+        }\n+        catch (final FileNotFoundException ex) {\n+            logger.warn(\"File does not exist! - \" + inputFilePath + \" - returning can decode as failure.\");\n+            canDecode = false;\n+        }\n+        catch (final IOException ex) {\n+            logger.warn(\"Caught IOException on file: \" + inputFilePath + \" - returning can decode as failure.\");\n+            canDecode = false;\n+        }\n+\n+        return canDecode;\n+    }\n+\n+    // ============================================================================================================\n+    // Trivial override methods that are pulled form AsciiFeatureCodec\n+    // This was done to ensure that this was a reasonable Codec class (with good interfaces for reading features).\n+\n+    @Override\n+    public void close(final LineIterator lineIterator) {\n+        CloserUtil.close(lineIterator);\n+    }\n+\n+    @Override\n+    public boolean isDone(final LineIterator lineIterator) {\n+        return !lineIterator.hasNext();\n+    }\n+\n+    @Override\n+    public LineIterator makeSourceFromStream(final InputStream bufferedInputStream) {\n+        return new LineIteratorImpl(new SynchronousLineReader(bufferedInputStream));\n+    }\n+\n+    @Override\n+    public FeatureCodecHeader readHeader(final LineIterator lineIterator) throws IOException {", "originalCommit": "dcfbbfe0136c8ff0bab8bb520fe5e1ea8eedae72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMjMyOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r386632329", "bodyText": "If the header contains any useful information that a client might want to access, then it would make sense to declare a more specific header type and return that.", "author": "lbergelson", "createdAt": "2020-03-02T20:29:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYwNTM5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1MjgzMg==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387852832", "bodyText": "Sounds good.\nBy and large the header is irrelevant to the user.  It contains metadata that can be used for validation, but I can't really think of a reason the user would want to look at it.", "author": "jonn-smith", "createdAt": "2020-03-04T18:29:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYwNTM5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyOTIxOA==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r386629218", "bodyText": "This says it's WAY to many commented out lines I think it's really any amount more than the expected.", "author": "lbergelson", "createdAt": "2020-03-02T20:23:16Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/codecs/gtf/AbstractGtfCodec.java", "diffHunk": "@@ -0,0 +1,344 @@\n+package org.broadinstitute.hellbender.utils.codecs.gtf;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.util.CloserUtil;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.LocationAware;\n+import htsjdk.tribble.AbstractFeatureCodec;\n+import htsjdk.tribble.Feature;\n+import htsjdk.tribble.FeatureCodecHeader;\n+import htsjdk.tribble.readers.*;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+\n+import java.io.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+public abstract class AbstractGtfCodec<T extends Feature> extends AbstractFeatureCodec<T, LineIterator> {\n+\n+    static final Logger logger = LogManager.getLogger(AbstractGtfCodec.class);\n+\n+    //==================================================================================================================\n+    // Public Static Members:\n+    public static final String GTF_FILE_EXTENSION = \"gtf\";\n+\n+    //==================================================================================================================\n+    // Private/Protected Static Members:\n+    static final int HEADER_NUM_LINES = 5;\n+    static final String FIELD_DELIMITER = \"\\t\";\n+\n+    static final int NUM_COLUMNS = 9;\n+    static final int FEATURE_TYPE_FIELD_INDEX = 2;\n+\n+    //==================================================================================================================\n+    // Private Members:\n+\n+\n+    //==================================================================================================================\n+    // Constructors:\n+    protected AbstractGtfCodec(final Class<T> myClass) {\n+        super(myClass);\n+    }\n+\n+    //==================================================================================================================\n+    // Override Methods:\n+\n+    @Override\n+    public boolean canDecode(final String inputFilePath) {\n+\n+        boolean canDecode;\n+        try {\n+            // Simple file and name checks to start with:\n+            final Path p = IOUtil.getPath(inputFilePath);\n+\n+            canDecode = passesFileNameCheck(inputFilePath);\n+\n+            if (canDecode) {\n+\n+                // Crack open the file and look at the top of it:\n+                try ( final BufferedReader br = new BufferedReader(new InputStreamReader(Files.newInputStream(p))) ) {\n+\n+                    // TThe first HEADER_NUM_LINES compose the header of a valid GTF File:\n+                    final List<String> headerLines = new ArrayList<>(HEADER_NUM_LINES);\n+\n+                    for (int i = 0; i < HEADER_NUM_LINES; ++i) {\n+                        final String line = br.readLine();\n+                        if ( line == null ) {\n+                            break;\n+                        }\n+                        headerLines.add( line );\n+                    }\n+\n+                    // Validate our header:\n+                    canDecode = validateHeader(headerLines);\n+                }\n+\n+            }\n+        }\n+        catch (final FileNotFoundException ex) {\n+            logger.warn(\"File does not exist! - \" + inputFilePath + \" - returning can decode as failure.\");\n+            canDecode = false;\n+        }\n+        catch (final IOException ex) {\n+            logger.warn(\"Caught IOException on file: \" + inputFilePath + \" - returning can decode as failure.\");\n+            canDecode = false;\n+        }\n+\n+        return canDecode;\n+    }\n+\n+    // ============================================================================================================\n+    // Trivial override methods that are pulled form AsciiFeatureCodec\n+    // This was done to ensure that this was a reasonable Codec class (with good interfaces for reading features).\n+\n+    @Override\n+    public void close(final LineIterator lineIterator) {\n+        CloserUtil.close(lineIterator);\n+    }\n+\n+    @Override\n+    public boolean isDone(final LineIterator lineIterator) {\n+        return !lineIterator.hasNext();\n+    }\n+\n+    @Override\n+    public LineIterator makeSourceFromStream(final InputStream bufferedInputStream) {\n+        return new LineIteratorImpl(new SynchronousLineReader(bufferedInputStream));\n+    }\n+\n+    @Override\n+    public FeatureCodecHeader readHeader(final LineIterator lineIterator) throws IOException {\n+        return new FeatureCodecHeader(readActualHeader(lineIterator), FeatureCodecHeader.NO_HEADER_END);\n+    }\n+\n+    @Override\n+    public LocationAware makeIndexableSourceFromStream(final InputStream bufferedInputStream) {\n+        return new AsciiLineReaderIterator(AsciiLineReader.from(bufferedInputStream));\n+    }\n+\n+    //==================================================================================================================\n+    // Static Methods:\n+\n+    /**\n+     * Aggregates the given feature sets into a single gene feature.\n+     *\n+     * The given gene is updated using modifiers.\n+     * {@code exonStore} and {@code leafFeatureStore} are cleared of all data.\n+     *\n+     * @param gene {@link GencodeGtfGeneFeature} into which to aggregate features.\n+     * @param transcript {@link GencodeGtfTranscriptFeature} to insert into {@code gene}\n+     * @param exonStore {@link List} of {@link GencodeGtfExonFeature}s to insert into corresponding {@link GencodeGtfTranscriptFeature} {@code transcript}\n+     * @param leafFeatureStore {@link List} of {@link GencodeGtfFeature}s to insert into corresponding {@link GencodeGtfExonFeature} objects in {@code exonStore}\n+     */\n+    static void aggregateRecordsIntoGeneFeature(final GencodeGtfGeneFeature gene,\n+                                                final GencodeGtfTranscriptFeature transcript,\n+                                                final List< GencodeGtfExonFeature > exonStore,\n+                                                final List< GencodeGtfFeature > leafFeatureStore ) {\n+\n+        // OK, we go through the record and consolidate the sub parts of the record.\n+        // We must consolidate these records through grouping by genomic position.\n+\n+        // Loop through the Exons and put the correct leaf features into each:\n+        for ( final GencodeGtfExonFeature exon : exonStore ) {\n+            for ( final Iterator<GencodeGtfFeature> iterator = leafFeatureStore.iterator(); iterator.hasNext(); ) {\n+\n+                final GencodeGtfFeature feature = iterator.next();\n+\n+                // Features that are within the extents of an exon belong in that exon:\n+                if ( exon.contains(feature) ) {\n+\n+                    final GencodeGtfFeature.FeatureType featureType = feature.getFeatureType();\n+\n+                    // Add the feature to the correct place in the exon:\n+                    switch (featureType) {\n+                        case CDS:\n+                            exon.setCds((GencodeGtfCDSFeature) feature);\n+                            break;\n+                        case START_CODON:\n+                            exon.setStartCodon((GencodeGtfStartCodonFeature) feature);\n+                            break;\n+                        case STOP_CODON:\n+                            exon.setStopCodon((GencodeGtfStopCodonFeature) feature);\n+                            break;\n+                        case UTR:\n+                            transcript.addUtr((GencodeGtfUTRFeature) feature);\n+                            break;\n+                        case SELENOCYSTEINE:\n+                            transcript.addSelenocysteine(((GencodeGtfSelenocysteineFeature) feature));\n+                            break;\n+                        default:\n+                            throw new UserException.MalformedFile(\n+                                    \"Found unexpected Feature Type in GENCODE GTF File (line \" +\n+                                            feature.getFeatureOrderNumber() + \"): \" +\n+                                            featureType.toString()\n+                            );\n+                    }\n+\n+                    // We have used this iterator item.\n+                    // We should remove it now so we don't keep going through the list each exon.\n+                    iterator.remove();\n+                }\n+            }\n+\n+            // Now insert this exon into the transcript:\n+            transcript.addExon(exon);\n+        }\n+\n+        // Add in the transcript:\n+        gene.addTranscript(transcript);\n+\n+        // Clear the input data:\n+        exonStore.clear();\n+        leafFeatureStore.clear();\n+    }\n+\n+    //==================================================================================================================\n+    // Instance Methods:\n+\n+    /**\n+     * Split the given line in a GTF file into fields.\n+     * Throws a {@link UserException} if the file is not valid.\n+     * @param line {@link String} containing one line of a GTF file to split.\n+     * @return A {@link String[]} with each entry containing a field from the GTF line.\n+     */\n+    String[] splitGtfLine(final String line) {\n+        // Split the line into different GTF Fields\n+        // Note that we're using -1 as the limit so that empty tokens will still be counted\n+        // (as opposed to discarded).\n+        final String[] splitLine = line.split(FIELD_DELIMITER, -1);\n+\n+        // Ensure the file is at least trivially well-formed:\n+        if (splitLine.length != NUM_COLUMNS) {\n+            throw new UserException.MalformedFile(\"Found an invalid number of columns in the given GTF file on line \"\n+                    + getCurrentLineNumber() + \" - Given: \" + splitLine.length + \" Expected: \" + NUM_COLUMNS + \" : \" + line);\n+        }\n+        return splitLine;\n+    }\n+\n+    /**\n+     * Read in lines from the given {@link LineIterator} and put them in the header file.\n+     * Will read until the lines no longer start with comments.\n+     * @param reader {@link LineIterator} a reader pointing at the top of a GTF file.\n+     */\n+    void ingestHeaderLines(final LineIterator reader) {\n+        int numHeaderLinesRead = 0;\n+        while ( reader.hasNext() ) {\n+            final String line = reader.peek();\n+\n+            // The file will start with commented out lines.\n+            // Grab them until there are no more commented out lines.\n+            if ( line.startsWith(getLineComment()) ) {\n+\n+                // Sanity check for if a file has\n+                // WAY too many commented out lines at the top:", "originalCommit": "dcfbbfe0136c8ff0bab8bb520fe5e1ea8eedae72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1NDM3Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387854373", "bodyText": "Fair enough!  Fixed.", "author": "jonn-smith", "createdAt": "2020-03-04T18:32:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYyOTIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMDA0Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r386630042", "bodyText": "No one ever calls this with throw = true so you could get rid of that path if you want.  I assume it's useful for debugging though or it wouldn't exist in the first place.", "author": "lbergelson", "createdAt": "2020-03-02T20:25:04Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/codecs/gtf/AbstractGtfCodec.java", "diffHunk": "@@ -0,0 +1,344 @@\n+package org.broadinstitute.hellbender.utils.codecs.gtf;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.util.CloserUtil;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.LocationAware;\n+import htsjdk.tribble.AbstractFeatureCodec;\n+import htsjdk.tribble.Feature;\n+import htsjdk.tribble.FeatureCodecHeader;\n+import htsjdk.tribble.readers.*;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+\n+import java.io.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+public abstract class AbstractGtfCodec<T extends Feature> extends AbstractFeatureCodec<T, LineIterator> {\n+\n+    static final Logger logger = LogManager.getLogger(AbstractGtfCodec.class);\n+\n+    //==================================================================================================================\n+    // Public Static Members:\n+    public static final String GTF_FILE_EXTENSION = \"gtf\";\n+\n+    //==================================================================================================================\n+    // Private/Protected Static Members:\n+    static final int HEADER_NUM_LINES = 5;\n+    static final String FIELD_DELIMITER = \"\\t\";\n+\n+    static final int NUM_COLUMNS = 9;\n+    static final int FEATURE_TYPE_FIELD_INDEX = 2;\n+\n+    //==================================================================================================================\n+    // Private Members:\n+\n+\n+    //==================================================================================================================\n+    // Constructors:\n+    protected AbstractGtfCodec(final Class<T> myClass) {\n+        super(myClass);\n+    }\n+\n+    //==================================================================================================================\n+    // Override Methods:\n+\n+    @Override\n+    public boolean canDecode(final String inputFilePath) {\n+\n+        boolean canDecode;\n+        try {\n+            // Simple file and name checks to start with:\n+            final Path p = IOUtil.getPath(inputFilePath);\n+\n+            canDecode = passesFileNameCheck(inputFilePath);\n+\n+            if (canDecode) {\n+\n+                // Crack open the file and look at the top of it:\n+                try ( final BufferedReader br = new BufferedReader(new InputStreamReader(Files.newInputStream(p))) ) {\n+\n+                    // TThe first HEADER_NUM_LINES compose the header of a valid GTF File:\n+                    final List<String> headerLines = new ArrayList<>(HEADER_NUM_LINES);\n+\n+                    for (int i = 0; i < HEADER_NUM_LINES; ++i) {\n+                        final String line = br.readLine();\n+                        if ( line == null ) {\n+                            break;\n+                        }\n+                        headerLines.add( line );\n+                    }\n+\n+                    // Validate our header:\n+                    canDecode = validateHeader(headerLines);\n+                }\n+\n+            }\n+        }\n+        catch (final FileNotFoundException ex) {\n+            logger.warn(\"File does not exist! - \" + inputFilePath + \" - returning can decode as failure.\");\n+            canDecode = false;\n+        }\n+        catch (final IOException ex) {\n+            logger.warn(\"Caught IOException on file: \" + inputFilePath + \" - returning can decode as failure.\");\n+            canDecode = false;\n+        }\n+\n+        return canDecode;\n+    }\n+\n+    // ============================================================================================================\n+    // Trivial override methods that are pulled form AsciiFeatureCodec\n+    // This was done to ensure that this was a reasonable Codec class (with good interfaces for reading features).\n+\n+    @Override\n+    public void close(final LineIterator lineIterator) {\n+        CloserUtil.close(lineIterator);\n+    }\n+\n+    @Override\n+    public boolean isDone(final LineIterator lineIterator) {\n+        return !lineIterator.hasNext();\n+    }\n+\n+    @Override\n+    public LineIterator makeSourceFromStream(final InputStream bufferedInputStream) {\n+        return new LineIteratorImpl(new SynchronousLineReader(bufferedInputStream));\n+    }\n+\n+    @Override\n+    public FeatureCodecHeader readHeader(final LineIterator lineIterator) throws IOException {\n+        return new FeatureCodecHeader(readActualHeader(lineIterator), FeatureCodecHeader.NO_HEADER_END);\n+    }\n+\n+    @Override\n+    public LocationAware makeIndexableSourceFromStream(final InputStream bufferedInputStream) {\n+        return new AsciiLineReaderIterator(AsciiLineReader.from(bufferedInputStream));\n+    }\n+\n+    //==================================================================================================================\n+    // Static Methods:\n+\n+    /**\n+     * Aggregates the given feature sets into a single gene feature.\n+     *\n+     * The given gene is updated using modifiers.\n+     * {@code exonStore} and {@code leafFeatureStore} are cleared of all data.\n+     *\n+     * @param gene {@link GencodeGtfGeneFeature} into which to aggregate features.\n+     * @param transcript {@link GencodeGtfTranscriptFeature} to insert into {@code gene}\n+     * @param exonStore {@link List} of {@link GencodeGtfExonFeature}s to insert into corresponding {@link GencodeGtfTranscriptFeature} {@code transcript}\n+     * @param leafFeatureStore {@link List} of {@link GencodeGtfFeature}s to insert into corresponding {@link GencodeGtfExonFeature} objects in {@code exonStore}\n+     */\n+    static void aggregateRecordsIntoGeneFeature(final GencodeGtfGeneFeature gene,\n+                                                final GencodeGtfTranscriptFeature transcript,\n+                                                final List< GencodeGtfExonFeature > exonStore,\n+                                                final List< GencodeGtfFeature > leafFeatureStore ) {\n+\n+        // OK, we go through the record and consolidate the sub parts of the record.\n+        // We must consolidate these records through grouping by genomic position.\n+\n+        // Loop through the Exons and put the correct leaf features into each:\n+        for ( final GencodeGtfExonFeature exon : exonStore ) {\n+            for ( final Iterator<GencodeGtfFeature> iterator = leafFeatureStore.iterator(); iterator.hasNext(); ) {\n+\n+                final GencodeGtfFeature feature = iterator.next();\n+\n+                // Features that are within the extents of an exon belong in that exon:\n+                if ( exon.contains(feature) ) {\n+\n+                    final GencodeGtfFeature.FeatureType featureType = feature.getFeatureType();\n+\n+                    // Add the feature to the correct place in the exon:\n+                    switch (featureType) {\n+                        case CDS:\n+                            exon.setCds((GencodeGtfCDSFeature) feature);\n+                            break;\n+                        case START_CODON:\n+                            exon.setStartCodon((GencodeGtfStartCodonFeature) feature);\n+                            break;\n+                        case STOP_CODON:\n+                            exon.setStopCodon((GencodeGtfStopCodonFeature) feature);\n+                            break;\n+                        case UTR:\n+                            transcript.addUtr((GencodeGtfUTRFeature) feature);\n+                            break;\n+                        case SELENOCYSTEINE:\n+                            transcript.addSelenocysteine(((GencodeGtfSelenocysteineFeature) feature));\n+                            break;\n+                        default:\n+                            throw new UserException.MalformedFile(\n+                                    \"Found unexpected Feature Type in GENCODE GTF File (line \" +\n+                                            feature.getFeatureOrderNumber() + \"): \" +\n+                                            featureType.toString()\n+                            );\n+                    }\n+\n+                    // We have used this iterator item.\n+                    // We should remove it now so we don't keep going through the list each exon.\n+                    iterator.remove();\n+                }\n+            }\n+\n+            // Now insert this exon into the transcript:\n+            transcript.addExon(exon);\n+        }\n+\n+        // Add in the transcript:\n+        gene.addTranscript(transcript);\n+\n+        // Clear the input data:\n+        exonStore.clear();\n+        leafFeatureStore.clear();\n+    }\n+\n+    //==================================================================================================================\n+    // Instance Methods:\n+\n+    /**\n+     * Split the given line in a GTF file into fields.\n+     * Throws a {@link UserException} if the file is not valid.\n+     * @param line {@link String} containing one line of a GTF file to split.\n+     * @return A {@link String[]} with each entry containing a field from the GTF line.\n+     */\n+    String[] splitGtfLine(final String line) {\n+        // Split the line into different GTF Fields\n+        // Note that we're using -1 as the limit so that empty tokens will still be counted\n+        // (as opposed to discarded).\n+        final String[] splitLine = line.split(FIELD_DELIMITER, -1);\n+\n+        // Ensure the file is at least trivially well-formed:\n+        if (splitLine.length != NUM_COLUMNS) {\n+            throw new UserException.MalformedFile(\"Found an invalid number of columns in the given GTF file on line \"\n+                    + getCurrentLineNumber() + \" - Given: \" + splitLine.length + \" Expected: \" + NUM_COLUMNS + \" : \" + line);\n+        }\n+        return splitLine;\n+    }\n+\n+    /**\n+     * Read in lines from the given {@link LineIterator} and put them in the header file.\n+     * Will read until the lines no longer start with comments.\n+     * @param reader {@link LineIterator} a reader pointing at the top of a GTF file.\n+     */\n+    void ingestHeaderLines(final LineIterator reader) {\n+        int numHeaderLinesRead = 0;\n+        while ( reader.hasNext() ) {\n+            final String line = reader.peek();\n+\n+            // The file will start with commented out lines.\n+            // Grab them until there are no more commented out lines.\n+            if ( line.startsWith(getLineComment()) ) {\n+\n+                // Sanity check for if a file has\n+                // WAY too many commented out lines at the top:\n+                if (numHeaderLinesRead > HEADER_NUM_LINES) {\n+                    throw new UserException.MalformedFile(\n+                            \"File header is longer than expected: \" + numHeaderLinesRead + \" > \" + HEADER_NUM_LINES\n+                    );\n+                }\n+\n+                getHeader().add(line);\n+                reader.next();\n+                ++numHeaderLinesRead;\n+            }\n+            else {\n+                break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Checks that the given header line number starts with the given text.\n+     * @param header A {@link List<String>} containing a header to validate.\n+     * @param lineNum Line number in the header to check.\n+     * @param startingText {@link String} containing text that the line should start with\n+     * @return {@code true} IFF the header line number {@code lineNum} starts with {@code startingText}; {@code false} otherwise.\n+     */\n+    boolean checkHeaderLineStartsWith(final List<String> header, final int lineNum, final String startingText) {\n+        return checkHeaderLineStartsWith(header, lineNum, startingText, false);\n+    }\n+\n+    /**\n+     * Checks that the given header line number starts with the given text.\n+     * @param header A {@link List<String>} containing a header to validate.\n+     * @param lineNum Line number in the header to check.\n+     * @param startingText {@link String} containing text that the line should start with\n+     * @param throwIfInvalid If {@code true} will throw a {@link UserException} instead of returning false.\n+     * @return {@code true} IFF the header line number {@code lineNum} starts with {@code startingText}; {@code false} otherwise.\n+     */\n+    boolean checkHeaderLineStartsWith(final List<String> header, final int lineNum, final String startingText, final boolean throwIfInvalid ) {", "originalCommit": "dcfbbfe0136c8ff0bab8bb520fe5e1ea8eedae72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg1NDcwNA==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387854704", "bodyText": "Yeah - this was in there so when I was adding in new data files I could see where the problems are.  I think it's useful to keep for now.  Maybe I'll throw a test in to make sure it's used.", "author": "jonn-smith", "createdAt": "2020-03-04T18:32:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMDA0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzMDQ0Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r386630446", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @return The {@link String} a line beings with to indicate that line is commented out.\n          \n          \n            \n                 * @return The {@link String} a line begins with to indicate that line is commented out.", "author": "lbergelson", "createdAt": "2020-03-02T20:25:53Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/codecs/gtf/AbstractGtfCodec.java", "diffHunk": "@@ -0,0 +1,344 @@\n+package org.broadinstitute.hellbender.utils.codecs.gtf;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.util.CloserUtil;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.samtools.util.LocationAware;\n+import htsjdk.tribble.AbstractFeatureCodec;\n+import htsjdk.tribble.Feature;\n+import htsjdk.tribble.FeatureCodecHeader;\n+import htsjdk.tribble.readers.*;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+\n+import java.io.*;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+public abstract class AbstractGtfCodec<T extends Feature> extends AbstractFeatureCodec<T, LineIterator> {\n+\n+    static final Logger logger = LogManager.getLogger(AbstractGtfCodec.class);\n+\n+    //==================================================================================================================\n+    // Public Static Members:\n+    public static final String GTF_FILE_EXTENSION = \"gtf\";\n+\n+    //==================================================================================================================\n+    // Private/Protected Static Members:\n+    static final int HEADER_NUM_LINES = 5;\n+    static final String FIELD_DELIMITER = \"\\t\";\n+\n+    static final int NUM_COLUMNS = 9;\n+    static final int FEATURE_TYPE_FIELD_INDEX = 2;\n+\n+    //==================================================================================================================\n+    // Private Members:\n+\n+\n+    //==================================================================================================================\n+    // Constructors:\n+    protected AbstractGtfCodec(final Class<T> myClass) {\n+        super(myClass);\n+    }\n+\n+    //==================================================================================================================\n+    // Override Methods:\n+\n+    @Override\n+    public boolean canDecode(final String inputFilePath) {\n+\n+        boolean canDecode;\n+        try {\n+            // Simple file and name checks to start with:\n+            final Path p = IOUtil.getPath(inputFilePath);\n+\n+            canDecode = passesFileNameCheck(inputFilePath);\n+\n+            if (canDecode) {\n+\n+                // Crack open the file and look at the top of it:\n+                try ( final BufferedReader br = new BufferedReader(new InputStreamReader(Files.newInputStream(p))) ) {\n+\n+                    // TThe first HEADER_NUM_LINES compose the header of a valid GTF File:\n+                    final List<String> headerLines = new ArrayList<>(HEADER_NUM_LINES);\n+\n+                    for (int i = 0; i < HEADER_NUM_LINES; ++i) {\n+                        final String line = br.readLine();\n+                        if ( line == null ) {\n+                            break;\n+                        }\n+                        headerLines.add( line );\n+                    }\n+\n+                    // Validate our header:\n+                    canDecode = validateHeader(headerLines);\n+                }\n+\n+            }\n+        }\n+        catch (final FileNotFoundException ex) {\n+            logger.warn(\"File does not exist! - \" + inputFilePath + \" - returning can decode as failure.\");\n+            canDecode = false;\n+        }\n+        catch (final IOException ex) {\n+            logger.warn(\"Caught IOException on file: \" + inputFilePath + \" - returning can decode as failure.\");\n+            canDecode = false;\n+        }\n+\n+        return canDecode;\n+    }\n+\n+    // ============================================================================================================\n+    // Trivial override methods that are pulled form AsciiFeatureCodec\n+    // This was done to ensure that this was a reasonable Codec class (with good interfaces for reading features).\n+\n+    @Override\n+    public void close(final LineIterator lineIterator) {\n+        CloserUtil.close(lineIterator);\n+    }\n+\n+    @Override\n+    public boolean isDone(final LineIterator lineIterator) {\n+        return !lineIterator.hasNext();\n+    }\n+\n+    @Override\n+    public LineIterator makeSourceFromStream(final InputStream bufferedInputStream) {\n+        return new LineIteratorImpl(new SynchronousLineReader(bufferedInputStream));\n+    }\n+\n+    @Override\n+    public FeatureCodecHeader readHeader(final LineIterator lineIterator) throws IOException {\n+        return new FeatureCodecHeader(readActualHeader(lineIterator), FeatureCodecHeader.NO_HEADER_END);\n+    }\n+\n+    @Override\n+    public LocationAware makeIndexableSourceFromStream(final InputStream bufferedInputStream) {\n+        return new AsciiLineReaderIterator(AsciiLineReader.from(bufferedInputStream));\n+    }\n+\n+    //==================================================================================================================\n+    // Static Methods:\n+\n+    /**\n+     * Aggregates the given feature sets into a single gene feature.\n+     *\n+     * The given gene is updated using modifiers.\n+     * {@code exonStore} and {@code leafFeatureStore} are cleared of all data.\n+     *\n+     * @param gene {@link GencodeGtfGeneFeature} into which to aggregate features.\n+     * @param transcript {@link GencodeGtfTranscriptFeature} to insert into {@code gene}\n+     * @param exonStore {@link List} of {@link GencodeGtfExonFeature}s to insert into corresponding {@link GencodeGtfTranscriptFeature} {@code transcript}\n+     * @param leafFeatureStore {@link List} of {@link GencodeGtfFeature}s to insert into corresponding {@link GencodeGtfExonFeature} objects in {@code exonStore}\n+     */\n+    static void aggregateRecordsIntoGeneFeature(final GencodeGtfGeneFeature gene,\n+                                                final GencodeGtfTranscriptFeature transcript,\n+                                                final List< GencodeGtfExonFeature > exonStore,\n+                                                final List< GencodeGtfFeature > leafFeatureStore ) {\n+\n+        // OK, we go through the record and consolidate the sub parts of the record.\n+        // We must consolidate these records through grouping by genomic position.\n+\n+        // Loop through the Exons and put the correct leaf features into each:\n+        for ( final GencodeGtfExonFeature exon : exonStore ) {\n+            for ( final Iterator<GencodeGtfFeature> iterator = leafFeatureStore.iterator(); iterator.hasNext(); ) {\n+\n+                final GencodeGtfFeature feature = iterator.next();\n+\n+                // Features that are within the extents of an exon belong in that exon:\n+                if ( exon.contains(feature) ) {\n+\n+                    final GencodeGtfFeature.FeatureType featureType = feature.getFeatureType();\n+\n+                    // Add the feature to the correct place in the exon:\n+                    switch (featureType) {\n+                        case CDS:\n+                            exon.setCds((GencodeGtfCDSFeature) feature);\n+                            break;\n+                        case START_CODON:\n+                            exon.setStartCodon((GencodeGtfStartCodonFeature) feature);\n+                            break;\n+                        case STOP_CODON:\n+                            exon.setStopCodon((GencodeGtfStopCodonFeature) feature);\n+                            break;\n+                        case UTR:\n+                            transcript.addUtr((GencodeGtfUTRFeature) feature);\n+                            break;\n+                        case SELENOCYSTEINE:\n+                            transcript.addSelenocysteine(((GencodeGtfSelenocysteineFeature) feature));\n+                            break;\n+                        default:\n+                            throw new UserException.MalformedFile(\n+                                    \"Found unexpected Feature Type in GENCODE GTF File (line \" +\n+                                            feature.getFeatureOrderNumber() + \"): \" +\n+                                            featureType.toString()\n+                            );\n+                    }\n+\n+                    // We have used this iterator item.\n+                    // We should remove it now so we don't keep going through the list each exon.\n+                    iterator.remove();\n+                }\n+            }\n+\n+            // Now insert this exon into the transcript:\n+            transcript.addExon(exon);\n+        }\n+\n+        // Add in the transcript:\n+        gene.addTranscript(transcript);\n+\n+        // Clear the input data:\n+        exonStore.clear();\n+        leafFeatureStore.clear();\n+    }\n+\n+    //==================================================================================================================\n+    // Instance Methods:\n+\n+    /**\n+     * Split the given line in a GTF file into fields.\n+     * Throws a {@link UserException} if the file is not valid.\n+     * @param line {@link String} containing one line of a GTF file to split.\n+     * @return A {@link String[]} with each entry containing a field from the GTF line.\n+     */\n+    String[] splitGtfLine(final String line) {\n+        // Split the line into different GTF Fields\n+        // Note that we're using -1 as the limit so that empty tokens will still be counted\n+        // (as opposed to discarded).\n+        final String[] splitLine = line.split(FIELD_DELIMITER, -1);\n+\n+        // Ensure the file is at least trivially well-formed:\n+        if (splitLine.length != NUM_COLUMNS) {\n+            throw new UserException.MalformedFile(\"Found an invalid number of columns in the given GTF file on line \"\n+                    + getCurrentLineNumber() + \" - Given: \" + splitLine.length + \" Expected: \" + NUM_COLUMNS + \" : \" + line);\n+        }\n+        return splitLine;\n+    }\n+\n+    /**\n+     * Read in lines from the given {@link LineIterator} and put them in the header file.\n+     * Will read until the lines no longer start with comments.\n+     * @param reader {@link LineIterator} a reader pointing at the top of a GTF file.\n+     */\n+    void ingestHeaderLines(final LineIterator reader) {\n+        int numHeaderLinesRead = 0;\n+        while ( reader.hasNext() ) {\n+            final String line = reader.peek();\n+\n+            // The file will start with commented out lines.\n+            // Grab them until there are no more commented out lines.\n+            if ( line.startsWith(getLineComment()) ) {\n+\n+                // Sanity check for if a file has\n+                // WAY too many commented out lines at the top:\n+                if (numHeaderLinesRead > HEADER_NUM_LINES) {\n+                    throw new UserException.MalformedFile(\n+                            \"File header is longer than expected: \" + numHeaderLinesRead + \" > \" + HEADER_NUM_LINES\n+                    );\n+                }\n+\n+                getHeader().add(line);\n+                reader.next();\n+                ++numHeaderLinesRead;\n+            }\n+            else {\n+                break;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Checks that the given header line number starts with the given text.\n+     * @param header A {@link List<String>} containing a header to validate.\n+     * @param lineNum Line number in the header to check.\n+     * @param startingText {@link String} containing text that the line should start with\n+     * @return {@code true} IFF the header line number {@code lineNum} starts with {@code startingText}; {@code false} otherwise.\n+     */\n+    boolean checkHeaderLineStartsWith(final List<String> header, final int lineNum, final String startingText) {\n+        return checkHeaderLineStartsWith(header, lineNum, startingText, false);\n+    }\n+\n+    /**\n+     * Checks that the given header line number starts with the given text.\n+     * @param header A {@link List<String>} containing a header to validate.\n+     * @param lineNum Line number in the header to check.\n+     * @param startingText {@link String} containing text that the line should start with\n+     * @param throwIfInvalid If {@code true} will throw a {@link UserException} instead of returning false.\n+     * @return {@code true} IFF the header line number {@code lineNum} starts with {@code startingText}; {@code false} otherwise.\n+     */\n+    boolean checkHeaderLineStartsWith(final List<String> header, final int lineNum, final String startingText, final boolean throwIfInvalid ) {\n+        if ( !header.get(lineNum).startsWith(getLineComment() + startingText) ) {\n+            if ( throwIfInvalid ) {\n+                throw new UserException.MalformedFile(\n+                        getGtfFileType() + \" GTF Header line \" + (lineNum+1) + \" does not contain expected information (\" +\n+                                getLineComment() + startingText + \"): \" + header.get(lineNum));\n+            }\n+            else {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /** @return The current line number for this AbstractGtfCodec. */\n+    abstract int getCurrentLineNumber();\n+\n+    /** @return The header AbstractGtfCodec. */\n+    abstract List<String> getHeader();\n+\n+    /**\n+     * @return The {@link String} a line beings with to indicate that line is commented out.", "originalCommit": "dcfbbfe0136c8ff0bab8bb520fe5e1ea8eedae72", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNDcwNg==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r386634706", "bodyText": "The spacing here is weird.  I can't t tell if it's aligned this way on purpose or if it's some weird tab artifact.", "author": "lbergelson", "createdAt": "2020-03-02T20:34:33Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/codecs/gtf/EnsemblGtfCodec.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package org.broadinstitute.hellbender.utils.codecs.gtf;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.tribble.readers.LineIterator;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Codec to decode data in GTF format from ENSEMBL.\n+ * According to ENSEMBL, GTF files downloaded from them conform to GFF version 2 (http://gmod.org/wiki/GFF2).\n+ */\n+final public class EnsemblGtfCodec extends AbstractGtfCodec<GencodeGtfFeature> {\n+\n+    private static final Logger logger = LogManager.getLogger(EnsemblGtfCodec.class);\n+\n+    //==================================================================================================================\n+    // Public Static Members:\n+\n+    public static String GTF_FILE_TYPE_STRING = \"ENSEMBL\";\n+\n+    //==================================================================================================================\n+    // Private Static Members:\n+\n+    //==================================================================================================================\n+    // Private Members:\n+\n+    private final List<String> header         = new ArrayList<>();\n+    private int                currentLineNum = 1;", "originalCommit": "dcfbbfe0136c8ff0bab8bb520fe5e1ea8eedae72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2NDI0NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387864245", "bodyText": "It's on purpose, but it does look odd.  I set my IntelliJ to align variable names, types, and values.\nI've reformatted the line below these to make it look more purposeful.", "author": "jonn-smith", "createdAt": "2020-03-04T18:50:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNDcwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNjA2MA==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r386636060", "bodyText": "Is there a case when this wouldn't be clear? I imagine this method is meant to be called exactly once?   Should it throw if header isn't clear?", "author": "lbergelson", "createdAt": "2020-03-02T20:37:20Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/codecs/gtf/EnsemblGtfCodec.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package org.broadinstitute.hellbender.utils.codecs.gtf;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.tribble.readers.LineIterator;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Codec to decode data in GTF format from ENSEMBL.\n+ * According to ENSEMBL, GTF files downloaded from them conform to GFF version 2 (http://gmod.org/wiki/GFF2).\n+ */\n+final public class EnsemblGtfCodec extends AbstractGtfCodec<GencodeGtfFeature> {\n+\n+    private static final Logger logger = LogManager.getLogger(EnsemblGtfCodec.class);\n+\n+    //==================================================================================================================\n+    // Public Static Members:\n+\n+    public static String GTF_FILE_TYPE_STRING = \"ENSEMBL\";\n+\n+    //==================================================================================================================\n+    // Private Static Members:\n+\n+    //==================================================================================================================\n+    // Private Members:\n+\n+    private final List<String> header         = new ArrayList<>();\n+    private int                currentLineNum = 1;\n+    private String version = \"\";\n+\n+    //==================================================================================================================\n+    // Constructors:\n+\n+    public EnsemblGtfCodec() {\n+        super(GencodeGtfFeature.class);\n+    }\n+\n+    //==================================================================================================================\n+    // Override Methods:\n+\n+    @Override\n+    String getGtfFileType() {\n+        return GTF_FILE_TYPE_STRING;\n+    }\n+\n+    @Override\n+    String getLineComment() {\n+        return \"#!\";\n+    }\n+\n+    @Override\n+    int getCurrentLineNumber() {\n+        return currentLineNum;\n+    }\n+\n+    @Override\n+    List<String> getHeader() {\n+        return header;\n+    }\n+\n+    @Override\n+    boolean passesFileNameCheck(final String inputFilePath) {\n+        try {\n+            final Path p = IOUtil.getPath(inputFilePath);\n+\n+            return p.getFileName().toString().toLowerCase().endsWith(\".\" + GTF_FILE_EXTENSION);\n+        }\n+        catch (final FileNotFoundException ex) {\n+            logger.warn(\"File does not exist! - \" + inputFilePath + \" - returning name check as failure.\");\n+        }\n+        catch (final IOException ex) {\n+            logger.warn(\"Caught IOException on file: \" + inputFilePath + \" - returning name check as failure.\");\n+        }\n+\n+        return false;\n+    }\n+\n+    @Override\n+    List<String> readActualHeader(final LineIterator reader) {\n+\n+        // Make sure we start with a clear header:\n+        header.clear();", "originalCommit": "dcfbbfe0136c8ff0bab8bb520fe5e1ea8eedae72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2NjczMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387866731", "bodyText": "This is a hold-over from an earlier implementation of the GencodeGtfCodec and a copy/paste thing.  I don't think it should ever be populated when this is called, and in fact, I think this call to clear can be removed.", "author": "jonn-smith", "createdAt": "2020-03-04T18:55:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNjA2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY0NTQyNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r386645425", "bodyText": "This method is nearly identical to its counterpart in GencodeGtfCodec.  As far as I can see the only difference is how you get the version number and how it's validated.  It seems like it could and probably should be refactored to a single shared implementation that takes the version number as a parameter, and calls an overridden validate method.", "author": "lbergelson", "createdAt": "2020-03-02T20:57:04Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/codecs/gtf/EnsemblGtfCodec.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package org.broadinstitute.hellbender.utils.codecs.gtf;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.tribble.readers.LineIterator;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Codec to decode data in GTF format from ENSEMBL.\n+ * According to ENSEMBL, GTF files downloaded from them conform to GFF version 2 (http://gmod.org/wiki/GFF2).\n+ */\n+final public class EnsemblGtfCodec extends AbstractGtfCodec<GencodeGtfFeature> {\n+\n+    private static final Logger logger = LogManager.getLogger(EnsemblGtfCodec.class);\n+\n+    //==================================================================================================================\n+    // Public Static Members:\n+\n+    public static String GTF_FILE_TYPE_STRING = \"ENSEMBL\";\n+\n+    //==================================================================================================================\n+    // Private Static Members:\n+\n+    //==================================================================================================================\n+    // Private Members:\n+\n+    private final List<String> header         = new ArrayList<>();\n+    private int                currentLineNum = 1;\n+    private String version = \"\";\n+\n+    //==================================================================================================================\n+    // Constructors:\n+\n+    public EnsemblGtfCodec() {\n+        super(GencodeGtfFeature.class);\n+    }\n+\n+    //==================================================================================================================\n+    // Override Methods:\n+\n+    @Override\n+    String getGtfFileType() {\n+        return GTF_FILE_TYPE_STRING;\n+    }\n+\n+    @Override\n+    String getLineComment() {\n+        return \"#!\";\n+    }\n+\n+    @Override\n+    int getCurrentLineNumber() {\n+        return currentLineNum;\n+    }\n+\n+    @Override\n+    List<String> getHeader() {\n+        return header;\n+    }\n+\n+    @Override\n+    boolean passesFileNameCheck(final String inputFilePath) {\n+        try {\n+            final Path p = IOUtil.getPath(inputFilePath);\n+\n+            return p.getFileName().toString().toLowerCase().endsWith(\".\" + GTF_FILE_EXTENSION);\n+        }\n+        catch (final FileNotFoundException ex) {\n+            logger.warn(\"File does not exist! - \" + inputFilePath + \" - returning name check as failure.\");\n+        }\n+        catch (final IOException ex) {\n+            logger.warn(\"Caught IOException on file: \" + inputFilePath + \" - returning name check as failure.\");\n+        }\n+\n+        return false;\n+    }\n+\n+    @Override\n+    List<String> readActualHeader(final LineIterator reader) {\n+\n+        // Make sure we start with a clear header:\n+        header.clear();\n+\n+        // Read in the header lines:\n+        ingestHeaderLines(reader);\n+\n+        // Validate our header:\n+        validateHeader(header, true);\n+\n+        // Set our line number to be the line of the first actual Feature:\n+        currentLineNum = HEADER_NUM_LINES + 1;\n+\n+        return header;\n+    }\n+\n+    @Override\n+    public GencodeGtfFeature decode(final LineIterator lineIterator) {", "originalCommit": "dcfbbfe0136c8ff0bab8bb520fe5e1ea8eedae72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2NTAyNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387865025", "bodyText": "Consolidated.", "author": "jonn-smith", "createdAt": "2020-03-04T18:51:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY0NTQyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY0Nzk2MA==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r386647960", "bodyText": "extract out the shared validation here if possible", "author": "lbergelson", "createdAt": "2020-03-02T21:02:26Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/codecs/gtf/EnsemblGtfCodec.java", "diffHunk": "@@ -0,0 +1,358 @@\n+package org.broadinstitute.hellbender.utils.codecs.gtf;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.tribble.readers.LineIterator;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Codec to decode data in GTF format from ENSEMBL.\n+ * According to ENSEMBL, GTF files downloaded from them conform to GFF version 2 (http://gmod.org/wiki/GFF2).\n+ */\n+final public class EnsemblGtfCodec extends AbstractGtfCodec<GencodeGtfFeature> {\n+\n+    private static final Logger logger = LogManager.getLogger(EnsemblGtfCodec.class);\n+\n+    //==================================================================================================================\n+    // Public Static Members:\n+\n+    public static String GTF_FILE_TYPE_STRING = \"ENSEMBL\";\n+\n+    //==================================================================================================================\n+    // Private Static Members:\n+\n+    //==================================================================================================================\n+    // Private Members:\n+\n+    private final List<String> header         = new ArrayList<>();\n+    private int                currentLineNum = 1;\n+    private String version = \"\";\n+\n+    //==================================================================================================================\n+    // Constructors:\n+\n+    public EnsemblGtfCodec() {\n+        super(GencodeGtfFeature.class);\n+    }\n+\n+    //==================================================================================================================\n+    // Override Methods:\n+\n+    @Override\n+    String getGtfFileType() {\n+        return GTF_FILE_TYPE_STRING;\n+    }\n+\n+    @Override\n+    String getLineComment() {\n+        return \"#!\";\n+    }\n+\n+    @Override\n+    int getCurrentLineNumber() {\n+        return currentLineNum;\n+    }\n+\n+    @Override\n+    List<String> getHeader() {\n+        return header;\n+    }\n+\n+    @Override\n+    boolean passesFileNameCheck(final String inputFilePath) {\n+        try {\n+            final Path p = IOUtil.getPath(inputFilePath);\n+\n+            return p.getFileName().toString().toLowerCase().endsWith(\".\" + GTF_FILE_EXTENSION);\n+        }\n+        catch (final FileNotFoundException ex) {\n+            logger.warn(\"File does not exist! - \" + inputFilePath + \" - returning name check as failure.\");\n+        }\n+        catch (final IOException ex) {\n+            logger.warn(\"Caught IOException on file: \" + inputFilePath + \" - returning name check as failure.\");\n+        }\n+\n+        return false;\n+    }\n+\n+    @Override\n+    List<String> readActualHeader(final LineIterator reader) {\n+\n+        // Make sure we start with a clear header:\n+        header.clear();\n+\n+        // Read in the header lines:\n+        ingestHeaderLines(reader);\n+\n+        // Validate our header:\n+        validateHeader(header, true);\n+\n+        // Set our line number to be the line of the first actual Feature:\n+        currentLineNum = HEADER_NUM_LINES + 1;\n+\n+        return header;\n+    }\n+\n+    @Override\n+    public GencodeGtfFeature decode(final LineIterator lineIterator) {\n+\n+        GencodeGtfFeature decodedFeature = null;\n+\n+        // Create some caches for our data (as we need to group it):\n+        GencodeGtfGeneFeature gene = null;\n+        GencodeGtfTranscriptFeature transcript = null;\n+        final List<GencodeGtfExonFeature> exonStore = new ArrayList<>();\n+        final List<GencodeGtfFeature> leafFeatureStore = new ArrayList<>();\n+\n+        boolean needToFlushRecords = false;\n+\n+        // Accumulate lines until we have a full gene and all of its internal features:\n+        while ( lineIterator.hasNext() ) {\n+\n+            final String line = lineIterator.peek();\n+\n+            // We must assume we can get header lines.\n+            // If we get a header line, we return null.\n+            // This allows indexing to work.\n+            if ( line.startsWith(getLineComment()) ) {\n+                lineIterator.next();\n+                return null;\n+            }\n+\n+            // Split the line into different GTF Fields\n+            final String[] splitLine = splitGtfLine(line);\n+\n+            // We need to key off the feature type to collapse our accumulated records:\n+            final GencodeGtfFeature.FeatureType featureType = GencodeGtfFeature.FeatureType.getEnum( splitLine[FEATURE_TYPE_FIELD_INDEX] );\n+\n+            // Create a baseline feature to add into our data:\n+            final GencodeGtfFeature feature = GencodeGtfFeature.create(splitLine, GTF_FILE_TYPE_STRING);\n+\n+            // Make sure we keep track of the line number for if and when we need to write the file back out:\n+            feature.setFeatureOrderNumber(currentLineNum);\n+\n+            // Set our UCSC version number:\n+            feature.setUcscGenomeVersion(getVersionFromHeader());\n+\n+            // Once we see another gene we take all accumulated records and combine them into the\n+            // current GencodeGtfFeature.\n+            // Then we then break out of the loop and return the last full gene object.\n+            if ((gene != null) && (featureType == GencodeGtfFeature.FeatureType.GENE)) {\n+\n+                aggregateRecordsIntoGeneFeature(gene, transcript, exonStore, leafFeatureStore);\n+\n+                // If we found a new gene line, we set our decodedFeature to be\n+                // the gene we just finished building.\n+                //\n+                // We intentionally break here so that we do not call lineIterator.next().\n+                // This is so that the new gene (i.e. the one that triggered us to be in this if statement)\n+                // remains intact for the next call to decode.\n+                decodedFeature = gene;\n+\n+                needToFlushRecords = false;\n+\n+                break;\n+            }\n+            // Once we see a transcript we aggregate our data into our current gene object and\n+            // set the current transcript object to the new transcript we just read.\n+            // Then we continue reading from the line iterator.\n+            else if ((transcript != null) && (featureType == GencodeGtfFeature.FeatureType.TRANSCRIPT)) {\n+\n+                aggregateRecordsIntoGeneFeature(gene, transcript, exonStore, leafFeatureStore);\n+\n+                transcript = (GencodeGtfTranscriptFeature) feature;\n+                ++currentLineNum;\n+\n+                needToFlushRecords = true;\n+            }\n+            else {\n+                // We have not reached the end of this set of gene / transcript records.\n+                // We must cache these records together so we can create a meaningful data hierarchy from them all.\n+                // Records are stored in their Feature form, not string form.\n+\n+                // Add the feature to the correct storage unit for easy assembly later:\n+                switch (featureType) {\n+                    case GENE:\n+                        gene = (GencodeGtfGeneFeature)feature;\n+                        break;\n+                    case TRANSCRIPT:\n+                        transcript = (GencodeGtfTranscriptFeature)feature;\n+                        break;\n+                    case EXON:\n+                        exonStore.add((GencodeGtfExonFeature)feature);\n+                        break;\n+                    default:\n+                        leafFeatureStore.add(feature);\n+                        break;\n+                }\n+\n+                needToFlushRecords = false;\n+                ++currentLineNum;\n+            }\n+\n+            // Increment our iterator here so we don't accidentally miss any features from the following gene\n+            lineIterator.next();\n+        }\n+\n+        // For the last record in the file, we need to do one final check to make sure that we don't miss it.\n+        // This is because there will not be a subsequent `gene` line to read:\n+        if ( (gene != null) && (needToFlushRecords || (!exonStore.isEmpty()) || (!leafFeatureStore.isEmpty())) ) {\n+\n+            aggregateRecordsIntoGeneFeature(gene, transcript, exonStore, leafFeatureStore);\n+            decodedFeature = gene;\n+        }\n+\n+        // If we have other records left over we should probably yell a lot,\n+        // as this is bad.\n+        //\n+        // However, this should never actually happen.\n+        //\n+        if ( (!exonStore.isEmpty()) || (!leafFeatureStore.isEmpty()) ) {\n+\n+            if (!exonStore.isEmpty()) {\n+                logger.error(\"Gene Feature Aggregation: Exon store not empty: \" + exonStore.toString());\n+            }\n+\n+            if (!leafFeatureStore.isEmpty()) {\n+                logger.error(\"Gene Feature Aggregation: leaf feature store not empty: \" + leafFeatureStore.toString());\n+            }\n+\n+            final String msg = \"Aggregated data left over after parsing complete: Exons: \" + exonStore.size() + \" ; LeafFeatures: \" + leafFeatureStore.size();\n+            throw new GATKException.ShouldNeverReachHereException(msg);\n+        }\n+\n+        // Now we validate our feature before returning it:\n+        if ( ! validateEnsemblGtfFeature( decodedFeature ) ) {\n+            throw new UserException.MalformedFile(\"Decoded feature is not valid: \" + decodedFeature);\n+        }\n+\n+        return decodedFeature;\n+    }\n+\n+    /**\n+     * Get the version information from the header.\n+     */\n+    private String getVersionFromHeader() {\n+        // header version is of the form:\n+        //     #!genome-version ASM584v2\n+        // So we get the stuff after the space:\n+        return header.get(1).split(\"[ \\t]\")[1];\n+    }\n+\n+    //==================================================================================================================\n+    // Static Methods:\n+\n+    /**\n+     * Validates a given {@link GencodeGtfFeature} against a given version of the ENSEMBL GTF file spec.\n+     * This method ensures that all required fields are defined, but does not interrogate their values.\n+     * @param feature A {@link GencodeGtfFeature} to validate.\n+     * @return True if {@code feature} contains all required fields for the given GENCODE GTF version, {@code gtfVersion}\n+     */\n+    public static boolean validateEnsemblGtfFeature(final GencodeGtfFeature feature) {", "originalCommit": "dcfbbfe0136c8ff0bab8bb520fe5e1ea8eedae72", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2NTE0Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387865147", "bodyText": "Consolidated.", "author": "jonn-smith", "createdAt": "2020-03-04T18:52:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY0Nzk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgwMTk1Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387801952", "bodyText": "should this check that we've read as many headerlines as we expect?", "author": "lbergelson", "createdAt": "2020-03-04T16:57:32Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/codecs/gtf/AbstractGtfCodec.java", "diffHunk": "@@ -446,264 +410,157 @@ static public boolean validateGencodeGtfFeature(final GencodeGtfFeature feature,\n         return true;\n     }\n \n-    @Override\n-    public boolean canDecode(final String inputFilePath) {\n-\n-        boolean canDecode;\n-        try {\n-            // Simple file and name checks to start with:\n-            Path p = IOUtil.getPath(inputFilePath);\n-\n-            canDecode = p.getFileName().toString().toLowerCase().startsWith(GENCODE_GTF_FILE_PREFIX) &&\n-                        p.getFileName().toString().toLowerCase().endsWith(\".\" + GENCODE_GTF_FILE_EXTENSION);\n-\n-            if (canDecode) {\n-\n-                // Crack open the file and look at the top of it:\n-                try ( BufferedReader br = new BufferedReader(new InputStreamReader(Files.newInputStream(p))) ) {\n-\n-                    // TThe first HEADER_NUM_LINES compose the header of a valid GTF File:\n-                    final List<String> headerLines = new ArrayList<>(HEADER_NUM_LINES);\n-\n-                    for (int i = 0; i < HEADER_NUM_LINES; ++i) {\n-                        final String line = br.readLine();\n-                        if ( line == null ) {\n-                            break;\n-                        }\n-                        headerLines.add( line );\n-                    }\n-\n-                    // Validate our header:\n-                    canDecode = validateHeader(headerLines);\n-                }\n-\n-            }\n-        }\n-        catch (final FileNotFoundException ex) {\n-            logger.warn(\"File does not exist! - \" + inputFilePath + \" - returning can decode as failure.\");\n-            canDecode = false;\n-        }\n-        catch (final IOException ex) {\n-            logger.warn(\"Caught IOException on file: \" + inputFilePath + \" - returning can decode as failure.\");\n-            canDecode = false;\n-        }\n-\n-        return canDecode;\n-    }\n-\n-    // ============================================================================================================\n-\n     /**\n-     * Check if the given header of a tentative GENCODE GTF file is, in fact, the header to such a file.\n-     * @param header Header lines to check for conformity to GENCODE GTF specifications.\n-     * @return true if the given {@code header} is that of a GENCODE GTF file; false otherwise.\n+     * Split the given line in a GTF file into fields.\n+     * Throws a {@link UserException} if the file is not valid.\n+     * @param line {@link String} containing one line of a GTF file to split.\n+     * @return A {@link String[]} with each entry containing a field from the GTF line.\n      */\n-    @VisibleForTesting\n-    static boolean validateHeader(final List<String> header) {\n-        return validateHeader(header, false);\n+    String[] splitGtfLine(final String line) {\n+        // Split the line into different GTF Fields\n+        // Note that we're using -1 as the limit so that empty tokens will still be counted\n+        // (as opposed to discarded).\n+        final String[] splitLine = line.split(FIELD_DELIMITER, -1);\n+\n+        // Ensure the file is at least trivially well-formed:\n+        if (splitLine.length != NUM_COLUMNS) {\n+            throw new UserException.MalformedFile(\"Found an invalid number of columns in the given GTF file on line \"\n+                    + getCurrentLineNumber() + \" - Given: \" + splitLine.length + \" Expected: \" + NUM_COLUMNS + \" : \" + line);\n+        }\n+        return splitLine;\n     }\n \n     /**\n-     * Check if the given header of a tentative GENCODE GTF file is, in fact, the header to such a file.\n-     * @param header Header lines to check for conformity to GENCODE GTF specifications.\n-     * @param throwIfInvalid If true, will throw a {@link UserException.MalformedFile} if the header is invalid.\n-     * @return true if the given {@code header} is that of a GENCODE GTF file; false otherwise.\n+     * Read in lines from the given {@link LineIterator} and put them in the header file.\n+     * Will read until the lines no longer start with comments.\n+     * @param reader {@link LineIterator} a reader pointing at the top of a GTF file.\n      */\n-    @VisibleForTesting\n-    static boolean validateHeader(final List<String> header, final boolean throwIfInvalid) {\n-\n-        if ( header.size() != HEADER_NUM_LINES) {\n-            if ( throwIfInvalid ) {\n-                throw new UserException.MalformedFile(\n-                        \"GENCODE GTF Header is of unexpected length: \" +\n-                        header.size() + \" != \" + HEADER_NUM_LINES);\n-            }\n-            else {\n-                return false;\n-            }\n-        }\n-\n-        // Check the normal commented fields:\n-        if ( !header.get(0).startsWith(\"##description:\") ) {\n-            if ( throwIfInvalid ) {\n-                throw new UserException.MalformedFile(\n-                        \"GENCODE GTF Header line 1 does not contain expected description specification (\" +\n-                        \"##description:): \" + header.get(0));\n-            }\n-            else {\n-                return false;\n-            }\n-        }\n-\n-        if ( !header.get(0).contains(\"version\") ) {\n-            if ( throwIfInvalid ) {\n-                throw new UserException.MalformedFile(\n-                        \"GENCODE GTF Header line 1 does not contain version specification: \" +\n-                                header.get(0));\n-            }\n-            else {\n-                return false;\n-            }\n-        }\n+    void ingestHeaderLines(final LineIterator reader) {\n+        int numHeaderLinesRead = 0;\n+        while ( reader.hasNext() ) {\n+            final String line = reader.peek();\n \n-        // Grab the version from the file and make sure it's within the acceptable range:\n-        final Matcher versionMatcher = VERSION_PATTERN.matcher(header.get(0));\n-        if ( !versionMatcher.find() ) {\n-            if ( throwIfInvalid ) {\n-                throw new UserException.MalformedFile(\n-                        \"GENCODE GTF Header line 1 does not contain version number: \" +\n-                                header.get(0));\n-            }\n-            else {\n-                return false;\n-            }\n-        }\n+            // The file will start with commented out lines.\n+            // Grab them until there are no more commented out lines.\n+            if ( line.startsWith(getLineComment()) ) {\n \n-        try {\n-            final int versionNumber = Integer.valueOf(versionMatcher.group(1));\n-            if (versionNumber < GENCODE_GTF_MIN_VERSION_NUM_INCLUSIVE) {\n-                final String message = \"GENCODE GTF Header line 1 has an out-of-date (< v\" + GENCODE_GTF_MIN_VERSION_NUM_INCLUSIVE + \" version number (\" +\n-                        versionNumber + \"): \" + header.get(0);\n-                if (throwIfInvalid) {\n-                    throw new UserException.MalformedFile(message);\n-                } else {\n-                    logger.warn(message + \"   Continuing, but errors may occur.\");\n+                // Sanity check for if a file has\n+                // WAY too many commented out lines at the top:\n+                if (numHeaderLinesRead > HEADER_NUM_LINES) {\n+                    throw new UserException.MalformedFile(\n+                            \"File header is longer than expected: \" + numHeaderLinesRead + \" > \" + HEADER_NUM_LINES\n+                    );\n                 }\n-            }\n-\n-            if (versionNumber > GENCODE_GTF_MAX_VERSION_NUM_INCLUSIVE) {\n-                    logger.warn(\"GENCODE GTF Header line 1 has a version number that is above maximum tested version (v \" + GENCODE_GTF_MAX_VERSION_NUM_INCLUSIVE + \") (given: \" +\n-                            versionNumber + \"): \" + header.get(0) + \"   Continuing, but errors may occur.\");\n-            }\n-        }\n-        catch (final NumberFormatException ex) {\n-            if ( throwIfInvalid ) {\n-                throw new UserException(\"Could not create number value for version: \" + versionMatcher.group(1), ex);\n-            }\n-            else {\n-                return false;\n-            }\n-        }\n-\n-        if ( !header.get(1).startsWith(\"##provider: GENCODE\") ) {\n-            if ( throwIfInvalid ) {\n-                throw new UserException.MalformedFile(\n-                        \"GENCODE GTF Header line 2 does not contain expected provider specification (\" +\n-                                \"##provider: GENCODE): \" + header.get(1));\n-            }\n-            else {\n-                return false;\n-            }\n-        }\n \n-        if ( !header.get(2).startsWith(\"##contact: gencode\") ) {\n-            if ( throwIfInvalid ) {\n-                throw new UserException.MalformedFile(\n-                        \"GENCODE GTF Header line 2 does not contain expected contact information (\" +\n-                                \"##contact: gencode): \" + header.get(2));\n+                getHeader().add(line);\n+                reader.next();\n+                ++numHeaderLinesRead;\n             }\n             else {\n-                return false;\n+                break;", "originalCommit": "1f1dd64f88e369a2bc96095201bda6f0f8cbf527", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2NzQwNA==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387867404", "bodyText": "No - this method just reads in the header.  It's always followed by a subsequent call to validateHeader which does this.", "author": "jonn-smith", "createdAt": "2020-03-04T18:56:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgwMTk1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgwMjgwOA==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387802808", "bodyText": "why is it lineNum + 1 when the checked line is lineNum", "author": "lbergelson", "createdAt": "2020-03-04T16:58:51Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/codecs/gtf/AbstractGtfCodec.java", "diffHunk": "@@ -446,264 +410,157 @@ static public boolean validateGencodeGtfFeature(final GencodeGtfFeature feature,\n         return true;\n     }\n \n-    @Override\n-    public boolean canDecode(final String inputFilePath) {\n-\n-        boolean canDecode;\n-        try {\n-            // Simple file and name checks to start with:\n-            Path p = IOUtil.getPath(inputFilePath);\n-\n-            canDecode = p.getFileName().toString().toLowerCase().startsWith(GENCODE_GTF_FILE_PREFIX) &&\n-                        p.getFileName().toString().toLowerCase().endsWith(\".\" + GENCODE_GTF_FILE_EXTENSION);\n-\n-            if (canDecode) {\n-\n-                // Crack open the file and look at the top of it:\n-                try ( BufferedReader br = new BufferedReader(new InputStreamReader(Files.newInputStream(p))) ) {\n-\n-                    // TThe first HEADER_NUM_LINES compose the header of a valid GTF File:\n-                    final List<String> headerLines = new ArrayList<>(HEADER_NUM_LINES);\n-\n-                    for (int i = 0; i < HEADER_NUM_LINES; ++i) {\n-                        final String line = br.readLine();\n-                        if ( line == null ) {\n-                            break;\n-                        }\n-                        headerLines.add( line );\n-                    }\n-\n-                    // Validate our header:\n-                    canDecode = validateHeader(headerLines);\n-                }\n-\n-            }\n-        }\n-        catch (final FileNotFoundException ex) {\n-            logger.warn(\"File does not exist! - \" + inputFilePath + \" - returning can decode as failure.\");\n-            canDecode = false;\n-        }\n-        catch (final IOException ex) {\n-            logger.warn(\"Caught IOException on file: \" + inputFilePath + \" - returning can decode as failure.\");\n-            canDecode = false;\n-        }\n-\n-        return canDecode;\n-    }\n-\n-    // ============================================================================================================\n-\n     /**\n-     * Check if the given header of a tentative GENCODE GTF file is, in fact, the header to such a file.\n-     * @param header Header lines to check for conformity to GENCODE GTF specifications.\n-     * @return true if the given {@code header} is that of a GENCODE GTF file; false otherwise.\n+     * Split the given line in a GTF file into fields.\n+     * Throws a {@link UserException} if the file is not valid.\n+     * @param line {@link String} containing one line of a GTF file to split.\n+     * @return A {@link String[]} with each entry containing a field from the GTF line.\n      */\n-    @VisibleForTesting\n-    static boolean validateHeader(final List<String> header) {\n-        return validateHeader(header, false);\n+    String[] splitGtfLine(final String line) {\n+        // Split the line into different GTF Fields\n+        // Note that we're using -1 as the limit so that empty tokens will still be counted\n+        // (as opposed to discarded).\n+        final String[] splitLine = line.split(FIELD_DELIMITER, -1);\n+\n+        // Ensure the file is at least trivially well-formed:\n+        if (splitLine.length != NUM_COLUMNS) {\n+            throw new UserException.MalformedFile(\"Found an invalid number of columns in the given GTF file on line \"\n+                    + getCurrentLineNumber() + \" - Given: \" + splitLine.length + \" Expected: \" + NUM_COLUMNS + \" : \" + line);\n+        }\n+        return splitLine;\n     }\n \n     /**\n-     * Check if the given header of a tentative GENCODE GTF file is, in fact, the header to such a file.\n-     * @param header Header lines to check for conformity to GENCODE GTF specifications.\n-     * @param throwIfInvalid If true, will throw a {@link UserException.MalformedFile} if the header is invalid.\n-     * @return true if the given {@code header} is that of a GENCODE GTF file; false otherwise.\n+     * Read in lines from the given {@link LineIterator} and put them in the header file.\n+     * Will read until the lines no longer start with comments.\n+     * @param reader {@link LineIterator} a reader pointing at the top of a GTF file.\n      */\n-    @VisibleForTesting\n-    static boolean validateHeader(final List<String> header, final boolean throwIfInvalid) {\n-\n-        if ( header.size() != HEADER_NUM_LINES) {\n-            if ( throwIfInvalid ) {\n-                throw new UserException.MalformedFile(\n-                        \"GENCODE GTF Header is of unexpected length: \" +\n-                        header.size() + \" != \" + HEADER_NUM_LINES);\n-            }\n-            else {\n-                return false;\n-            }\n-        }\n-\n-        // Check the normal commented fields:\n-        if ( !header.get(0).startsWith(\"##description:\") ) {\n-            if ( throwIfInvalid ) {\n-                throw new UserException.MalformedFile(\n-                        \"GENCODE GTF Header line 1 does not contain expected description specification (\" +\n-                        \"##description:): \" + header.get(0));\n-            }\n-            else {\n-                return false;\n-            }\n-        }\n-\n-        if ( !header.get(0).contains(\"version\") ) {\n-            if ( throwIfInvalid ) {\n-                throw new UserException.MalformedFile(\n-                        \"GENCODE GTF Header line 1 does not contain version specification: \" +\n-                                header.get(0));\n-            }\n-            else {\n-                return false;\n-            }\n-        }\n+    void ingestHeaderLines(final LineIterator reader) {\n+        int numHeaderLinesRead = 0;\n+        while ( reader.hasNext() ) {\n+            final String line = reader.peek();\n \n-        // Grab the version from the file and make sure it's within the acceptable range:\n-        final Matcher versionMatcher = VERSION_PATTERN.matcher(header.get(0));\n-        if ( !versionMatcher.find() ) {\n-            if ( throwIfInvalid ) {\n-                throw new UserException.MalformedFile(\n-                        \"GENCODE GTF Header line 1 does not contain version number: \" +\n-                                header.get(0));\n-            }\n-            else {\n-                return false;\n-            }\n-        }\n+            // The file will start with commented out lines.\n+            // Grab them until there are no more commented out lines.\n+            if ( line.startsWith(getLineComment()) ) {\n \n-        try {\n-            final int versionNumber = Integer.valueOf(versionMatcher.group(1));\n-            if (versionNumber < GENCODE_GTF_MIN_VERSION_NUM_INCLUSIVE) {\n-                final String message = \"GENCODE GTF Header line 1 has an out-of-date (< v\" + GENCODE_GTF_MIN_VERSION_NUM_INCLUSIVE + \" version number (\" +\n-                        versionNumber + \"): \" + header.get(0);\n-                if (throwIfInvalid) {\n-                    throw new UserException.MalformedFile(message);\n-                } else {\n-                    logger.warn(message + \"   Continuing, but errors may occur.\");\n+                // Sanity check for if a file has\n+                // WAY too many commented out lines at the top:\n+                if (numHeaderLinesRead > HEADER_NUM_LINES) {\n+                    throw new UserException.MalformedFile(\n+                            \"File header is longer than expected: \" + numHeaderLinesRead + \" > \" + HEADER_NUM_LINES\n+                    );\n                 }\n-            }\n-\n-            if (versionNumber > GENCODE_GTF_MAX_VERSION_NUM_INCLUSIVE) {\n-                    logger.warn(\"GENCODE GTF Header line 1 has a version number that is above maximum tested version (v \" + GENCODE_GTF_MAX_VERSION_NUM_INCLUSIVE + \") (given: \" +\n-                            versionNumber + \"): \" + header.get(0) + \"   Continuing, but errors may occur.\");\n-            }\n-        }\n-        catch (final NumberFormatException ex) {\n-            if ( throwIfInvalid ) {\n-                throw new UserException(\"Could not create number value for version: \" + versionMatcher.group(1), ex);\n-            }\n-            else {\n-                return false;\n-            }\n-        }\n-\n-        if ( !header.get(1).startsWith(\"##provider: GENCODE\") ) {\n-            if ( throwIfInvalid ) {\n-                throw new UserException.MalformedFile(\n-                        \"GENCODE GTF Header line 2 does not contain expected provider specification (\" +\n-                                \"##provider: GENCODE): \" + header.get(1));\n-            }\n-            else {\n-                return false;\n-            }\n-        }\n \n-        if ( !header.get(2).startsWith(\"##contact: gencode\") ) {\n-            if ( throwIfInvalid ) {\n-                throw new UserException.MalformedFile(\n-                        \"GENCODE GTF Header line 2 does not contain expected contact information (\" +\n-                                \"##contact: gencode): \" + header.get(2));\n+                getHeader().add(line);\n+                reader.next();\n+                ++numHeaderLinesRead;\n             }\n             else {\n-                return false;\n+                break;\n             }\n         }\n+    }\n \n-        if ( !header.get(3).startsWith(\"##format: gtf\") ) {\n-            if ( throwIfInvalid ) {\n-                throw new UserException.MalformedFile(\n-                        \"GENCODE GTF Header line 4 does not contain expected format specification (\" +\n-                                \"##format: gtf): \" + header.get(3));\n-            }\n-            else {\n-                return false;\n-            }\n-        }\n+    /**\n+     * Checks that the given header line number starts with the given text.\n+     * @param header A {@link List<String>} containing a header to validate.\n+     * @param lineNum Line number in the header to check.\n+     * @param startingText {@link String} containing text that the line should start with\n+     * @return {@code true} IFF the header line number {@code lineNum} starts with {@code startingText}; {@code false} otherwise.\n+     */\n+    boolean checkHeaderLineStartsWith(final List<String> header, final int lineNum, final String startingText) {\n+        return checkHeaderLineStartsWith(header, lineNum, startingText, false);\n+    }\n \n-        if ( !header.get(4).startsWith(\"##date:\") ) {\n+    /**\n+     * Checks that the given header line number starts with the given text.\n+     * @param header A {@link List<String>} containing a header to validate.\n+     * @param lineNum Line number in the header to check.\n+     * @param startingText {@link String} containing text that the line should start with\n+     * @param throwIfInvalid If {@code true} will throw a {@link UserException} instead of returning false.\n+     * @return {@code true} IFF the header line number {@code lineNum} starts with {@code startingText}; {@code false} otherwise.\n+     */\n+    boolean checkHeaderLineStartsWith(final List<String> header, final int lineNum, final String startingText, final boolean throwIfInvalid ) {\n+        if ( !header.get(lineNum).startsWith(getLineComment() + startingText) ) {\n             if ( throwIfInvalid ) {\n                 throw new UserException.MalformedFile(\n-                        \"GENCODE GTF Header line 5 does not contain expected date information (\" +\n-                                \"##date:): \" + header.get(4));\n+                        getGtfFileType() + \" GTF Header line \" + (lineNum+1) + \" does not contain expected information (\" +", "originalCommit": "1f1dd64f88e369a2bc96095201bda6f0f8cbf527", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2NzgwMA==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387867800", "bodyText": "To display to a user in normal line numbers.\nMost text editors begin with line number 1 (as opposed to zero).", "author": "jonn-smith", "createdAt": "2020-03-04T18:57:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgwMjgwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyODM1NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387828355", "bodyText": "this link doesn't work for me. I think you mean:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * GENCODE GTF Files are defined here: https://www.gencodegenes.org/data_format.html\n          \n          \n            \n             * GENCODE GTF Files are defined here: https://www.gencodegenes.org/pages/data_format.html", "author": "lbergelson", "createdAt": "2020-03-04T17:43:56Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/codecs/gtf/GencodeGtfCodec.java", "diffHunk": "@@ -0,0 +1,326 @@\n+package org.broadinstitute.hellbender.utils.codecs.gtf;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.tribble.AbstractFeatureCodec;\n+import htsjdk.tribble.readers.LineIterator;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * {@link htsjdk.tribble.Tribble} Codec to read data from a GENCODE GTF file.\n+ *\n+ * GENCODE GTF Files are defined here: https://www.gencodegenes.org/data_format.html", "originalCommit": "1f1dd64f88e369a2bc96095201bda6f0f8cbf527", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2ODQ1OA==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387868458", "bodyText": "Fair enough - this link worked when the codec was written in 2017.", "author": "jonn-smith", "createdAt": "2020-03-04T18:58:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyODM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyOTgxOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387829819", "bodyText": "dead link, https://www.gencodegenes.org/human/releases.html maybe?", "author": "lbergelson", "createdAt": "2020-03-04T17:46:33Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/codecs/gtf/GencodeGtfCodec.java", "diffHunk": "@@ -0,0 +1,326 @@\n+package org.broadinstitute.hellbender.utils.codecs.gtf;\n+\n+import com.google.common.annotations.VisibleForTesting;\n+import htsjdk.samtools.util.IOUtil;\n+import htsjdk.tribble.AbstractFeatureCodec;\n+import htsjdk.tribble.readers.LineIterator;\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.broadinstitute.hellbender.exceptions.GATKException;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+\n+import java.io.FileNotFoundException;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * {@link htsjdk.tribble.Tribble} Codec to read data from a GENCODE GTF file.\n+ *\n+ * GENCODE GTF Files are defined here: https://www.gencodegenes.org/data_format.html\n+ *\n+ * This codec will scan through a GENCODE GTF file and return {@link GencodeGtfFeature} objects.\n+ * {@link GencodeGtfFeature} objects contain fields that have sub-features.  All features are\n+ * grouped by gene (this is the natural formatting of a GENCODE GTF file).\n+ *\n+ * All fields exist in the Abstract {@link GencodeGtfFeature}.  The subclasses contain representations of the logical\n+ * data hierarchy that reflect how the data were presented in the feature file itself (to preserve the natural\n+ * grouping by gene).\n+ * The {@link GencodeGtfFeature} logical data hierarchy (NOT the class hierarchy) is as follows\n+ * (with | representing a \"has a\" relationship)\n+ *\n+ * +--> {@link GencodeGtfGeneFeature}\n+ *    |\n+ *    +--> {@link GencodeGtfTranscriptFeature}\n+ *       |\n+ *       +--> {@link GencodeGtfSelenocysteineFeature}\n+ *       +--> {@link GencodeGtfUTRFeature}\n+ *       +--> {@link GencodeGtfExonFeature}\n+ *          |\n+ *          +--> {@link GencodeGtfCDSFeature}\n+ *          +--> {@link GencodeGtfStartCodonFeature}\n+ *          +--> {@link GencodeGtfStopCodonFeature}\n+ *\n+ * {@link htsjdk.tribble.Tribble} indexing has been tested and works as expected.\n+ * Does not support {@link htsjdk.tribble.index.tabix.TabixIndex} indexing.\n+ *\n+ * Unlike many other {@link htsjdk.tribble.Tribble} codecs, this one scans multiple input file lines to produce\n+ * a single feature.  This is due to how GENCODE GTF files are structured (essentially grouped by contig and gene).\n+ * For this reason, {@link GencodeGtfCodec} inherits from {@link AbstractFeatureCodec}, as opposed to {@link htsjdk.tribble.AsciiFeatureCodec}\n+ * (i.e. {@link htsjdk.tribble.AsciiFeatureCodec}s read a single line at a time, and {@link AbstractFeatureCodec} do not have that explicit purpose).\n+ *\n+ * Created by jonn on 7/21/17.\n+ */\n+final public class GencodeGtfCodec extends AbstractGtfCodec {\n+\n+    private static final Logger logger = LogManager.getLogger(GencodeGtfCodec.class);\n+\n+    private static final int GENCODE_GTF_MIN_VERSION_NUM_INCLUSIVE = 19;\n+\n+    /**\n+     * Maximum version of gencode that will not generate a warning.  This parser will still attempt to parse versions above this number, but a warning about potential errors will appear.\n+     */\n+    private static final int GENCODE_GTF_MAX_VERSION_NUM_INCLUSIVE = 28;\n+\n+    public static final String GENCODE_GTF_FILE_PREFIX = \"gencode\";\n+    public static final String GTF_FILE_TYPE_STRING = \"GENCODE\";\n+\n+    private int currentLineNum = 1;\n+    private final List<String> header = new ArrayList<>();\n+    private static final int HEADER_NUM_LINES = 5;\n+\n+    private static final Pattern VERSION_PATTERN = Pattern.compile(\"version (\\\\d+)\");\n+    private int versionNumber;\n+\n+    // ============================================================================================================\n+\n+    /**\n+     * Gets the UCSC version corresponding to the given gencode version.\n+     * Version equivalences obtained here:\n+     *\n+     *  https://genome.ucsc.edu/FAQ/FAQreleases.html\n+     *  https://www.gencodegenes.org/releases/", "originalCommit": "1f1dd64f88e369a2bc96095201bda6f0f8cbf527", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg2OTE2NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387869165", "bodyText": "Yeah - again, these links were created when I wrote the file in 2017 and were valid then.", "author": "jonn-smith", "createdAt": "2020-03-04T18:59:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgyOTgxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgzNDcxMg==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387834712", "bodyText": "This comment is on the above previously existing code, you might want to check the result of versionMatcher.find() and throw a nice error if it's false.", "author": "lbergelson", "createdAt": "2020-03-04T17:55:32Z", "path": "src/main/java/org/broadinstitute/hellbender/utils/codecs/gtf/GencodeGtfCodec.java", "diffHunk": "@@ -295,15 +159,11 @@ private void setVersionNumber() {\n     /**", "originalCommit": "1f1dd64f88e369a2bc96095201bda6f0f8cbf527", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3MDM4Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387870386", "bodyText": "Sure.  I'll throw a UserException.MalformedFile.", "author": "jonn-smith", "createdAt": "2020-03-04T19:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzgzNDcxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0MTkzMw==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387841933", "bodyText": "I might add one with valid lines, but some are missing.", "author": "lbergelson", "createdAt": "2020-03-04T18:09:07Z", "path": "src/test/java/org/broadinstitute/hellbender/utils/codecs/gtf/EnsemblGtfCodecUnitTest.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.broadinstitute.hellbender.utils.codecs.gtf;\n+\n+import org.broadinstitute.hellbender.GATKBaseTest;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Test class for the ENSEMBL GTF Reader.\n+ * Modeled after the TableCodecUnitTest, with extras specific to this file format.\n+ * Created by jonn on 2020 02 28.\n+ */\n+public class EnsemblGtfCodecUnitTest extends GATKBaseTest {\n+\n+    private static final String testResourceDir = publicTestDir + \"org/broadinstitute/hellbender/utils/codecs/gtf/\";\n+    private static final String eColiTestDir = publicTestDir + \"org/broadinstitute/hellbender/tools/funcotator/ecoli_ds/gencode/ASM584v2/\";\n+\n+    @DataProvider\n+    public Object[][] canDecodeProvider() {\n+\n+        return new Object[][] {\n+                { \"a.tsv\"     , testResourceDir, false },                                    // Wrong File name / extension\n+                { \"a.table.gz\", testResourceDir, false },                                    // Wrong File name / extension\n+                { \"a.bed\"     , testResourceDir, false },                                    // Wrong File name / extension\n+                { \"a.bcf\"     , testResourceDir, false },                                    // Wrong File name / extension\n+                { \"a.hapmap\"  , testResourceDir, false },                                    // Wrong File name / extension\n+                { \"a.refseq\"  , testResourceDir, false },                                    // Wrong File name / extension\n+                { \"a.beagle\"  , testResourceDir, false },                                    // Wrong File name / extension\n+                { \"a.table\"   , testResourceDir, false },                                    // Wrong File name / extension\n+\n+                { \"gencode.v26.annotation.gtf.tsv\", testResourceDir, false},                 // Wrong File name / extension\n+                { \"gencode.v26.annotation.tgz\"    , testResourceDir, false},                 // Wrong File name / extension\n+                { \"gencode.v26.annotation.tar.gz\" , testResourceDir, false},                 // Wrong File name / extension\n+\n+                { \"gencode.gtf\"                                , testResourceDir, false},    // File does not exist\n+                { \"gencode.v26.primary_assembly.annotation.gtf\", testResourceDir, false},    // File does not exist\n+                { \"gencode.v26.long_noncoding_RNAs.gtf\"        , testResourceDir, false},    // File does not exist\n+\n+                { \"gencode.invalid_short_header.gtf\"           , testResourceDir, false},    // File exists, has invalid header\n+                { \"gencode.invalid_malformed_header.gtf\"       , testResourceDir, false},    // File exists, has invalid header\n+                { \"gencode.invalid_malformed_header_desc.gtf\"  , testResourceDir, false},    // File exists, has invalid header\n+                { \"gencode.invalid_malformed_header_prov.gtf\"  , testResourceDir, false},    // File exists, has invalid header\n+                { \"gencode.invalid_malformed_header_cont.gtf\"  , testResourceDir, false},    // File exists, has invalid header\n+                { \"gencode.invalid_malformed_header_form.gtf\"  , testResourceDir, false},    // File exists, has invalid header\n+                { \"gencode.invalid_malformed_header_date.gtf\"  , testResourceDir, false},    // File exists, has invalid header\n+\n+                { \"gencode.valid1.gtf\"                           , testResourceDir, false},   // Not an Ensembl GTF file\n+                { \"gencode.valid_gencode_file2.gtf\"              , testResourceDir, false},   // Not an Ensembl GTF file\n+                { \"gencode.and.this.is.a.valid.one.too.table.gtf\", testResourceDir, false},   // Not an Ensembl GTF file\n+\n+                { \"Escherichia_coli_str_k_12_substr_mg1655.ASM584v2.44.gtf\", eColiTestDir, true},   // Name doesn't start with 'gencode'\n+        };\n+    }\n+\n+    @Test(dataProvider = \"canDecodeProvider\")\n+    public void testCanDecode(final String fileName, final String containingFolder, final boolean expected) {\n+        final EnsemblGtfCodec ensemblGtfCodec = new EnsemblGtfCodec();\n+        Assert.assertEquals(ensemblGtfCodec.canDecode(containingFolder + fileName), expected, fileName);\n+    }\n+\n+    @DataProvider\n+    public Object[][] headerProvider() {\n+        return new Object[][] {\n+\n+                { new ArrayList<String>(), false },                             // Wrong length header\n+                { Arrays.asList( \"\",\n+                        \"\",\n+                        \"\",\n+                        \"\",\n+                        \"\"  ),\n+                        false },                                // Bad content\n+                { Arrays.asList( \"##descr\",\n+                        \"##provider: GENCODE\",\n+                        \"##contact: gencode-help@sanger.ac.uk\",\n+                        \"##format: gtf\",\n+                        \"##date: 2017-04-08\" ),\n+                        false },                                // Bad header - description\n+                { Arrays.asList( \"##description: THIS IS A SAMPLE\",\n+                        \"##provider: GARBAGEDAY\",\n+                        \"##contact: gencode-help@sanger.ac.uk\",\n+                        \"##format: gtf\",\n+                        \"##date: 2017-04-08\" ),\n+                        false },                                // Bad header - provider\n+                { Arrays.asList( \"##description: THIS IS A SAMPLE\",\n+                        \"##provider: GENCODE\",\n+                        \"##contact: gencode@NORTHPOLE.pl\",\n+                        \"##format: gtf\",\n+                        \"##date: 2017-04-08\" ),\n+                        false },                                // Bad header - contact\n+                { Arrays.asList( \"##description: THIS IS A SAMPLE\",\n+                        \"##provider: GENCODE\",\n+                        \"##contact: SANTACLAUSE@sanger.ac.uk\",\n+                        \"##format: gtf\",\n+                        \"##date: 2017-04-08\" ),\n+                        false },                                // Bad header - contact\n+                { Arrays.asList( \"##description: THIS IS A SAMPLE\",\n+                        \"##provider: GENCODE\",\n+                        \"##contact: gencode-help@sanger.ac.uk\",\n+                        \"##format: dumpy\",\n+                        \"##date: 2017-04-08\" ),\n+                        false },                                // Bad header - format\n+                { Arrays.asList( \"##description: THIS IS A SAMPLE\",\n+                        \"##provider: GENCODE\",\n+                        \"##contact: gencode-help@sanger.ac.uk\",\n+                        \"##format: gtf\",\n+                        \"##doom: ID Software\" ),\n+                        false },                                // Bad header - date\n+                { Arrays.asList( \"##description: evidence-based annotation of the human genome (GRCh37), version 19 (Ensembl 74)\",\n+                        \"##provider: GENCODE\",\n+                        \"##contact: gencode@sanger.ac.uk\",\n+                        \"##format: gtf\",\n+                        \"##date: 2014-07-25\" ),\n+                        false },                                // Good GENCODE Header, but BAD ENSEMBL header!\n+                { Arrays.asList( \"##description: evidence-based annotation of the human genome (GRCh38), version 26 (Ensembl 88)\",\n+                        \"##provider: GENCODE\",\n+                        \"##contact: gencode-help@sanger.ac.uk\",\n+                        \"##format: gtf\",\n+                        \"##date: 2014-07-25\" ),\n+                        false },                                 // Good GENCODE Header, but BAD ENSEMBL header!\n+\n+                // -------------\n+\n+                { Arrays.asList( \"#!genome-build ASM584v2\",\n+                        \"#!genome-version ASM584v2\",\n+                        \"#!genome-date 2014-08\",\n+                        \"#!genome-build-accession GCA_000005845.2\",\n+                        \"#!genebuild-last-updated 2014-08\" ),\n+                        true },                                           // Good Ensembl GTF Header!\n+\n+                { Arrays.asList( \"ASM584v2\",\n+                        \"#!genome-version ASM584v2\",\n+                        \"#!genome-date 2014-08\",\n+                        \"#!genome-build-accession GCA_000005845.2\",\n+                        \"#!genebuild-last-updated 2014-08\" ),\n+                        false },                                           // Bad header - genome-build\n+                { Arrays.asList( \"#!genome-build ASM584v2\",\n+                        \"ASM584v2\",\n+                        \"#!genome-date 2014-08\",\n+                        \"#!genome-build-accession GCA_000005845.2\",\n+                        \"#!genebuild-last-updated 2014-08\" ),\n+                        false },                                           // Bad header - genome-version\n+                { Arrays.asList( \"#!genome-build ASM584v2\",\n+                        \"#!genome-version ASM584v2\",\n+                        \"#2014-08\",\n+                        \"#!genome-build-accession GCA_000005845.2\",\n+                        \"#!genebuild-last-updated 2014-08\" ),\n+                        false },                                           // Bad header - genome-date\n+                { Arrays.asList( \"#!genome-build ASM584v2\",\n+                        \"#!genome-version ASM584v2\",\n+                        \"#!genome-date 2014-08\",\n+                        \"#GCA_000005845.2\",\n+                        \"#!genebuild-last-updated 2014-08\" ),\n+                        false },                                           // Bad header - genome-build-accession\n+                { Arrays.asList( \"#!genome-build ASM584v2\",\n+                        \"#!genome-version ASM584v2\",\n+                        \"#!genome-date 2014-08\",\n+                        \"#!genome-build-accession GCA_000005845.2\",\n+                        \"#2014-08\" ),\n+                        false },                                           // Bad header - genebuild-last-updated", "originalCommit": "1f1dd64f88e369a2bc96095201bda6f0f8cbf527", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3MDgzMw==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387870833", "bodyText": "sure.  Fixed.", "author": "jonn-smith", "createdAt": "2020-03-04T19:02:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0MTkzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0MjI3NA==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387842274", "bodyText": "similar to above comment, add a too short header.", "author": "lbergelson", "createdAt": "2020-03-04T18:09:49Z", "path": "src/test/java/org/broadinstitute/hellbender/utils/codecs/gtf/GencodeGtfCodecUnitTest.java", "diffHunk": "@@ -3495,6 +3498,46 @@ private GencodeGtfGeneFeature createGencodeGtfGene_gencode_v19_and_this_is_a_val\n                                  \"##date: 2014-07-25\" ),\n                                  true },                                 // Good Header!\n \n+                // -------------\n+\n+                { Arrays.asList( \"#!genome-build ASM584v2\",\n+                        \"#!genome-version ASM584v2\",\n+                        \"#!genome-date 2014-08\",", "originalCommit": "1f1dd64f88e369a2bc96095201bda6f0f8cbf527", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3MTU0OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387871549", "bodyText": "Sure.  Fixed.", "author": "jonn-smith", "createdAt": "2020-03-04T19:03:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0MjI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0NDA1NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387844055", "bodyText": "It would be good to check that the using the index to look up records gets you the ones you wanted as part of this test.", "author": "lbergelson", "createdAt": "2020-03-04T18:12:57Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/IndexFeatureFileIntegrationTest.java", "diffHunk": "@@ -410,4 +408,22 @@ public void testVCFWithNoRecords() {\n         Assert.assertTrue(output.length() > 0);\n     }\n \n+    @Test\n+    public void testEnsemblGtfIndex() {", "originalCommit": "1f1dd64f88e369a2bc96095201bda6f0f8cbf527", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg3ODY3Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387878676", "bodyText": "Sounds good.  I've added a couple parts to the test that does this.", "author": "jonn-smith", "createdAt": "2020-03-04T19:17:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0NDA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0NTEzNA==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387845134", "bodyText": "It would be good to have a test in here that reads the header and decodes some records.  I know there are integration test that do that, but it's good to have one here too that's separate from funcotator.  It doesn't have to be extremely extensive, just enough to show that it returns a few expected records.", "author": "lbergelson", "createdAt": "2020-03-04T18:15:05Z", "path": "src/test/java/org/broadinstitute/hellbender/utils/codecs/gtf/EnsemblGtfCodecUnitTest.java", "diffHunk": "@@ -0,0 +1,174 @@\n+package org.broadinstitute.hellbender.utils.codecs.gtf;\n+\n+import org.broadinstitute.hellbender.GATKBaseTest;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+/**\n+ * Test class for the ENSEMBL GTF Reader.\n+ * Modeled after the TableCodecUnitTest, with extras specific to this file format.\n+ * Created by jonn on 2020 02 28.\n+ */\n+public class EnsemblGtfCodecUnitTest extends GATKBaseTest {", "originalCommit": "1f1dd64f88e369a2bc96095201bda6f0f8cbf527", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg5MjUyMA==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387892520", "bodyText": "Sounds good.  I'll make a test for it.", "author": "jonn-smith", "createdAt": "2020-03-04T19:42:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzg0NTEzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk2MjM4Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387962383", "bodyText": "This should be in a try() block so it gets closed.", "author": "lbergelson", "createdAt": "2020-03-04T22:04:34Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/IndexFeatureFileIntegrationTest.java", "diffHunk": "@@ -410,20 +416,77 @@ public void testVCFWithNoRecords() {\n \n     @Test\n     public void testEnsemblGtfIndex() {\n-        final File testFile = new File(\"src/test/resources/org/broadinstitute/hellbender/tools/funcotator/ecoli_ds/gencode/ASM584v2/Escherichia_coli_str_k_12_substr_mg1655.ASM584v2.44.gtf\");\n         final File outName = createTempFile(\"Escherichia_coli_str_k_12_substr_mg1655.ASM584v2.44.gtf.\", \".idx\");\n \n         final String[] args = {\n-                \"-I\" ,  testFile.getAbsolutePath(),\n+                \"-I\" ,  ENSEMBL_GTF_TEST_FILE.getAbsolutePath(),\n                 \"-O\" ,  outName.getAbsolutePath()\n         };\n         final Object res = this.runCommandLine(args);\n         Assert.assertEquals(res, outName.getAbsolutePath());\n \n         final Index index = IndexFactory.loadIndex(res.toString());\n         Assert.assertTrue(index instanceof LinearIndex);\n-        Assert.assertEquals(index.getSequenceNames(), Arrays.asList(\"Chromosome\"));\n-        checkIndex(index, Arrays.asList(\"Chromosome\"));\n+        Assert.assertEquals(index.getSequenceNames(), Collections.singletonList(\"Chromosome\"));\n+        checkIndex(index, Collections.singletonList(\"Chromosome\"));\n+    }\n+\n+    @DataProvider\n+    Object[][] provideForTestEnsemblGtfIndexQuery() {\n+        return new Object[][] {\n+                {\n+                        new SimpleInterval(\"Chromosome\", 3019160, 3020500),\n+                        1,\n+                        new SimpleInterval[] {new SimpleInterval(\"Chromosome\", 3019161, 3020489)},\n+                        new String[] {\"b2879\"},\n+                        new String[] {\"ssnA\"},\n+                },\n+                {\n+                        new SimpleInterval(\"Chromosome\", 3286269, 3288786),\n+                        4,\n+                        new SimpleInterval[] {\n+                                new SimpleInterval(\"Chromosome\", 3285478, 3286269),\n+                                new SimpleInterval(\"Chromosome\", 3286270, 3287025),\n+                                new SimpleInterval(\"Chromosome\", 3287426, 3288010),\n+                                new SimpleInterval(\"Chromosome\", 3288090, 3288785),\n+                        },\n+                        new String[] {\n+                                \"b3140\",\n+                                \"b3141\",\n+                                \"b3142\",\n+                                \"b3143\",\n+                        },\n+                        new String[] {\n+                                \"agaD\",\n+                                \"agaI\",\n+                                \"yraH\",\n+                                \"yraI\",\n+                        },\n+                }\n+        };\n     }\n \n+    @Test(dataProvider = \"provideForTestEnsemblGtfIndexQuery\")\n+    public void testEnsemblGtfIndexQuery(final SimpleInterval interval,\n+                                         final Integer expectedNumResults,\n+                                         final SimpleInterval[] expectedFeatureIntervals,\n+                                         final String[] expectedGeneIds,\n+                                         final String[] expectedGeneNames) {\n+        // Test that we can query the file:\n+        final FeatureDataSource<GencodeGtfFeature> featureReader = new FeatureDataSource<>(ENSEMBL_GTF_TEST_FILE);", "originalCommit": "a960224c37d35d271c7bfc0fdf55eaa07c089316", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM4NTMwMw==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r388385303", "bodyText": "Ah!  Yup.  Fixed.", "author": "jonn-smith", "createdAt": "2020-03-05T15:53:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk2MjM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk2MjgyMg==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387962822", "bodyText": "\ud83d\udc4d", "author": "lbergelson", "createdAt": "2020-03-04T22:05:26Z", "path": "src/test/java/org/broadinstitute/hellbender/utils/codecs/gtf/AbstractGtfCodecUnitTest.java", "diffHunk": "@@ -0,0 +1,60 @@\n+package org.broadinstitute.hellbender.utils.codecs.gtf;\n+\n+import org.broadinstitute.hellbender.GATKBaseTest;\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.testng.Assert;\n+import org.testng.annotations.DataProvider;\n+import org.testng.annotations.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Test class for the {@link AbstractGtfCodec}.\n+ * Modeled after the {@link org.broadinstitute.hellbender.utils.codecs.table.TableCodecUnitTest}, with extras specific to this file format.\n+ * Created by jonn on 7/27/17.\n+ */\n+public class AbstractGtfCodecUnitTest extends GATKBaseTest {\n+\n+    List<String> prependCommentToArrayElements(final String[] elements, final String comment) {\n+        return Arrays.stream(elements).map(s -> comment + s).collect(Collectors.toList());\n+    }\n+\n+    @DataProvider\n+    Object[][] provideForCheckHeaderLineStartsWith() {\n+\n+        final GencodeGtfCodec gencodeGtfCodec = new GencodeGtfCodec();\n+        final EnsemblGtfCodec ensemblGtfCodec = new EnsemblGtfCodec();\n+\n+        return new Object[][] {\n+                {gencodeGtfCodec, prependCommentToArrayElements(new String[] {\"LINE_1\", \"LINE_2\", \"LINE_3\", \"LINE_4\", \"LINE_5\"}, gencodeGtfCodec.getLineComment()), 0, \"LINE_1\", true},\n+                {gencodeGtfCodec, prependCommentToArrayElements(new String[] {\"LINE_1\", \"LINE_2\", \"LINE_3\", \"LINE_4\", \"LINE_5\"}, gencodeGtfCodec.getLineComment()), 0, \"LINE_2\", false},\n+                {ensemblGtfCodec, prependCommentToArrayElements(new String[] {\"LINE_1\", \"LINE_2\", \"LINE_3\", \"LINE_4\", \"LINE_5\"}, ensemblGtfCodec.getLineComment()), 0, \"LINE_1\", true},\n+                {ensemblGtfCodec, prependCommentToArrayElements(new String[] {\"LINE_1\", \"LINE_2\", \"LINE_3\", \"LINE_4\", \"LINE_5\"}, ensemblGtfCodec.getLineComment()), 0, \"LINE_2\", false},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"provideForCheckHeaderLineStartsWith\")\n+    void testCheckHeaderLineStartsWith(final AbstractGtfCodec codec, final List<String> header, final int lineNum,\n+                                       final String startingText, final boolean expected) {\n+        Assert.assertEquals(codec.checkHeaderLineStartsWith(header, lineNum, startingText), expected);\n+    }\n+\n+    @DataProvider\n+    Object[][] provideForCheckHeaderLineStartsWith_WithThrow() {\n+        final GencodeGtfCodec gencodeGtfCodec = new GencodeGtfCodec();\n+        final EnsemblGtfCodec ensemblGtfCodec = new EnsemblGtfCodec();\n+\n+        return new Object[][] {\n+                {gencodeGtfCodec, prependCommentToArrayElements(new String[] {\"LINE_1\", \"LINE_2\", \"LINE_3\", \"LINE_4\", \"LINE_5\"}, gencodeGtfCodec.getLineComment()), 0, \"LINE_2\"},\n+                {ensemblGtfCodec, prependCommentToArrayElements(new String[] {\"LINE_1\", \"LINE_2\", \"LINE_3\", \"LINE_4\", \"LINE_5\"}, ensemblGtfCodec.getLineComment()), 0, \"LINE_2\"},\n+        };\n+    }\n+\n+    @Test(dataProvider = \"provideForCheckHeaderLineStartsWith_WithThrow\", expectedExceptions = UserException.MalformedFile.class)\n+    void testCheckHeaderLineStartsWith_WithThrow(final AbstractGtfCodec codec, final List<String> header, final int lineNum,\n+                                       final String startingText) {\n+        codec.checkHeaderLineStartsWith(header, lineNum, startingText, true);", "originalCommit": "a960224c37d35d271c7bfc0fdf55eaa07c089316", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk2MzI0NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r387963245", "bodyText": "ugh, yeah, I can see why this was a pain", "author": "lbergelson", "createdAt": "2020-03-04T22:06:23Z", "path": "src/test/java/org/broadinstitute/hellbender/utils/codecs/gtf/EnsemblGtfCodecUnitTest.java", "diffHunk": "@@ -16,8 +19,96 @@\n  */\n public class EnsemblGtfCodecUnitTest extends GATKBaseTest {\n \n-    private static final String testResourceDir = publicTestDir + \"org/broadinstitute/hellbender/utils/codecs/gtf/\";\n-    private static final String eColiTestDir = publicTestDir + \"org/broadinstitute/hellbender/tools/funcotator/ecoli_ds/gencode/ASM584v2/\";\n+    private static final String testResourceDir           = publicTestDir + \"org/broadinstitute/hellbender/utils/codecs/gtf/\";\n+    private static final String eColiTestDir              = publicTestDir + \"org/broadinstitute/hellbender/tools/funcotator/ecoli_ds/gencode/ASM584v2/\";\n+    private static final String ECOLI_UCSC_GENOME_VERSION = \"ASM584v2\";\n+    private static final String ECOLI_CONTIG_NAME         = \"Chromosome\";\n+\n+    private GencodeGtfFeature createEcoliEnsemblGene(final int startingFeatureOrder, final String geneId, final String geneName, final int geneStart,\n+                                             final int geneEnd, final String transcriptId, final String transcriptName,\n+                                             final String exonId, final int cdsStart, final int cdsEnd) {\n+\n+        // Placeholder for constant extra data:\n+        final String geneAnonymousOptionalFields = \" gene_source \\\"ena\\\";\";\n+        final String transcriptAnonymousOptionalFields = geneAnonymousOptionalFields + \" transcript_source \\\"ena\\\";\";\n+\n+        int featureOrderNum = startingFeatureOrder;\n+\n+        GencodeGtfFeatureBaseData data;\n+\n+        data = new GencodeGtfFeatureBaseData(EnsemblGtfCodec.GTF_FILE_TYPE_STRING, featureOrderNum++, ECOLI_CONTIG_NAME, GencodeGtfFeature.AnnotationSource.ena, GencodeGtfFeature.FeatureType.GENE,", "originalCommit": "a960224c37d35d271c7bfc0fdf55eaa07c089316", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODM4NTExNw==", "url": "https://github.com/broadinstitute/gatk/pull/6477#discussion_r388385117", "bodyText": "It wasn't so bad when I figured out the format of the ecoli files.  the helper methods really made it much easier.", "author": "jonn-smith", "createdAt": "2020-03-05T15:53:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzk2MzI0NQ=="}], "type": "inlineReview"}, {"oid": "184ba3ef87abd59507bc6b3133d1cf4c72d965a2", "url": "https://github.com/broadinstitute/gatk/commit/184ba3ef87abd59507bc6b3133d1cf4c72d965a2", "message": "Updated Funcotator to support ENSEMBL GTF files (and non-human species).\n\n- Refactored GencodeGtfCodec to enable parsing of ENSEMBL GTF files.\n- Created AbstractGtfCodec and EnsemblGtfCodec.\n- Updated Funcotator and Funcotation Factories to allow ENSEMBL-based\nGTF files.\n- Added an e. coli data sources folder, reference, VCF, and expected\ndata for testing.\n- Added tests for ENSEMBL GTF files.\n- Fixes #6180", "committedDate": "2020-03-05T16:31:15Z", "type": "commit"}, {"oid": "184ba3ef87abd59507bc6b3133d1cf4c72d965a2", "url": "https://github.com/broadinstitute/gatk/commit/184ba3ef87abd59507bc6b3133d1cf4c72d965a2", "message": "Updated Funcotator to support ENSEMBL GTF files (and non-human species).\n\n- Refactored GencodeGtfCodec to enable parsing of ENSEMBL GTF files.\n- Created AbstractGtfCodec and EnsemblGtfCodec.\n- Updated Funcotator and Funcotation Factories to allow ENSEMBL-based\nGTF files.\n- Added an e. coli data sources folder, reference, VCF, and expected\ndata for testing.\n- Added tests for ENSEMBL GTF files.\n- Fixes #6180", "committedDate": "2020-03-05T16:31:15Z", "type": "forcePushed"}, {"oid": "0b48e91d7792ad24621c90fd876871782e61da81", "url": "https://github.com/broadinstitute/gatk/commit/0b48e91d7792ad24621c90fd876871782e61da81", "message": "Adding in large files.", "committedDate": "2020-03-05T16:41:08Z", "type": "commit"}, {"oid": "7f586ab36e31cd38652ebf46f76df4adc065d021", "url": "https://github.com/broadinstitute/gatk/commit/7f586ab36e31cd38652ebf46f76df4adc065d021", "message": "Fixing file paths to point to large files.", "committedDate": "2020-03-05T17:26:23Z", "type": "commit"}]}