{"pr_number": 6822, "pr_title": "ah - use new GT encoding", "pr_createdAt": "2020-09-15T18:58:04Z", "pr_url": "https://github.com/broadinstitute/gatk/pull/6822", "timeline": [{"oid": "f18a80d90165c7cfcefdbf73dc32f48385c0f161", "url": "https://github.com/broadinstitute/gatk/commit/f18a80d90165c7cfcefdbf73dc32f48385c0f161", "message": "change GTs to single character, drop hom ref, add sample metrics to sample metadata tsv", "committedDate": "2020-09-15T17:42:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyMTgyMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6822#discussion_r488921821", "bodyText": "Is there only one line in the metrics file? If so, can you put in a check for that?", "author": "meganshand", "createdAt": "2020-09-15T19:34:34Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/variantdb/arrays/ArraySampleTsvCreator.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package org.broadinstitute.hellbender.tools.variantdb.arrays;\n+\n+import org.broadinstitute.hellbender.exceptions.UserException;\n+import org.broadinstitute.hellbender.tools.variantdb.IngestConstants;\n+import org.broadinstitute.hellbender.utils.tsv.SimpleXSVWriter;\n+\n+import java.io.*;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class ArraySampleTsvCreator {\n+\n+    private SimpleXSVWriter sampleMetadataWriter = null;\n+    private Map<String, String> metricsMap;\n+\n+\n+    public ArraySampleTsvCreator(String metricsFilepath) {\n+        BufferedReader reader = null;\n+        try {\n+            String columns = null;\n+            String values = null;\n+            reader = new BufferedReader(new FileReader(metricsFilepath));\n+            String line = reader.readLine();\n+            while (line != null) {\n+                if (!line.startsWith(\"#\") && !line.trim().isEmpty()) {\n+                    if (columns == null) {\n+                        columns = line;\n+                    } else {\n+                        values = line;", "originalCommit": "f18a80d90165c7cfcefdbf73dc32f48385c0f161", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkyOTcwMg==", "url": "https://github.com/broadinstitute/gatk/pull/6822#discussion_r488929702", "bodyText": "Should this comment be deleted too?", "author": "meganshand", "createdAt": "2020-09-15T19:43:49Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/variantdb/arrays/RawArrayFieldEnum.java", "diffHunk": "@@ -30,67 +36,39 @@ public String getColumnValue(VariantContext variant, ProbeInfo probeInfo, String\n \n     // This where the validation step (required vs not) lives  -- fail if there is missing data for a required field", "originalCommit": "f18a80d90165c7cfcefdbf73dc32f48385c0f161", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "010c3b6ba0ee16821ba04d680fadd463024f3000", "url": "https://github.com/broadinstitute/gatk/commit/010c3b6ba0ee16821ba04d680fadd463024f3000", "message": "update based on PR feedback", "committedDate": "2020-09-16T13:26:39Z", "type": "commit"}, {"oid": "42063f72a87187a5845d7e4c041ba3ad10e0fdf3", "url": "https://github.com/broadinstitute/gatk/commit/42063f72a87187a5845d7e4c041ba3ad10e0fdf3", "message": "fix errors", "committedDate": "2020-09-16T13:40:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ3NDY5Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6822#discussion_r489474692", "bodyText": "I'm so surprised this code doesn't exist anywhere?  the VCFWriter must be doing (largely) the same thing?", "author": "kcibul", "createdAt": "2020-09-16T14:19:06Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/variantdb/CommonCode.java", "diffHunk": "@@ -1,29 +1,51 @@\n package org.broadinstitute.hellbender.tools.variantdb;\n \n import htsjdk.samtools.SAMSequenceDictionary;\n+import htsjdk.variant.variantcontext.Allele;\n+import htsjdk.variant.variantcontext.VariantContext;\n import htsjdk.variant.vcf.*;\n+import org.apache.commons.lang.StringUtils;\n+import org.broadinstitute.hellbender.tools.variantdb.arrays.RawArrayTsvCreator;\n+import org.broadinstitute.hellbender.utils.genotyper.IndexedAlleleList;\n import org.broadinstitute.hellbender.utils.variant.GATKVCFConstants;\n import org.broadinstitute.hellbender.utils.variant.GATKVCFHeaderLines;\n \n+import java.util.ArrayList;\n import java.util.HashSet;\n+import java.util.List;\n import java.util.Set;\n \n //TODO rename this or get rid of it. a place holder for now\n public class CommonCode {\n-    public static final String NORMX = \"NORMX\";\n-    public static final String NORMY = \"NORMY\";\n-    public static final String BAF = \"BAF\";\n-    public static final String LRR = \"LRR\";\n \n \n+    public static String getGTString(final VariantContext variant) {", "originalCommit": "42063f72a87187a5845d7e4c041ba3ad10e0fdf3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU1MjA4NA==", "url": "https://github.com/broadinstitute/gatk/pull/6822#discussion_r489552084", "bodyText": "yes, but it is very embedded in the actual writing of the output and in htsjdk which for some reason i think it's more difficult for us to modify to make it modular.", "author": "ahaessly", "createdAt": "2020-09-16T16:01:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ3NDY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ3NjE4Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6822#discussion_r489476186", "bodyText": "what if it's not two?  should we throw an exception?", "author": "kcibul", "createdAt": "2020-09-16T14:21:04Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/variantdb/arrays/RawArrayFieldEnum.java", "diffHunk": "@@ -3,126 +3,96 @@\n import htsjdk.variant.variantcontext.Allele;\n import htsjdk.variant.variantcontext.Genotype;\n import htsjdk.variant.variantcontext.VariantContext;\n+import org.broadinstitute.hellbender.tools.variantdb.CommonCode;\n import org.broadinstitute.hellbender.tools.variantdb.arrays.tables.ProbeInfo;\n \n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n \n /**\n  * Expected headers for the  uncompressed array table\n- *     sample, // req\n- *     probe_id, // req\n- *     GT_encoded,\n+ *     sample, // required\n+ *     probe_id, // required\n+ *     GT_encoded, // required\n  *     NORMX, // intensity\n  *     NORMY, // intensity\n  *     BAF // b allele fraction --> AD proxy\n  *     LRR // Log R ratio --> intensity value instead of DP\n  * \n- * Headers for the compressed array table\n- *     basic_array_data\n- *     raw_array_data\n  */\n \n public enum RawArrayFieldEnum {\n-    sample_id {\n-        public String getColumnValue(VariantContext variant, ProbeInfo probeInfo, String sampleId) {\n-            return sampleId;\n-        }\n-    },\n-\n-    // This where the validation step (required vs not) lives  -- fail if there is missing data for a required field\n-    // and just leave it empty if not required\n-    basic_array_data {\n-        public String getColumnValue(final VariantContext variant, ProbeInfo probeInfo, String sampleId) {\n-            String gt = GT_encoded.getColumnValue(variant, probeInfo, sampleId);\n-            BasicArrayData.ArrayGenotype agt;\n-            if (\".\".equals(gt)) {\n-                agt = BasicArrayData.ArrayGenotype.NO_CALL;\n-            } else {\n-                agt = BasicArrayData.ArrayGenotype.valueOf(gt);\n-            }\n-            BasicArrayData d = new BasicArrayData(Integer.parseInt(sampleId), (int) probeInfo.probeId, agt);\n-            return String.valueOf(d.encode());\n-        }\n-    },\n-\n-    raw_array_data {\n-        private Float convert(String s) {\n-            if (s == null || \"\".equals(s) || \"null\".equals(s) ) {\n-                return null;\n-            } else {\n-                return Float.parseFloat(s);                \n-            }\n-        }\n+    // fail if there is missing data for a required field\n+    // and return the string \"null\" if there is missing data for an optional field\n \n-        public String getColumnValue(final VariantContext variant, ProbeInfo probeInfo, String sampleId) {\n-            String normx = NORMX.getColumnValue(variant, probeInfo, sampleId);\n-            String normy = NORMY.getColumnValue(variant, probeInfo, sampleId);\n-            String baf = BAF.getColumnValue(variant, probeInfo, sampleId);\n-            String lrr = LRR.getColumnValue(variant, probeInfo, sampleId);\n+    sample_id,\n+    probe_id,\n+    GT_encoded { // Required\n+        public String getColumnValue(final VariantContext variant) {\n+            List<Integer> alleleIndexes = CommonCode.getGTAlleleIndexes(variant);\n \n-            RawArrayData d = new RawArrayData(convert(normx),\n-                                              convert(normy),\n-                                              convert(baf),\n-                                              convert(lrr)\n-                                              );\n-            return String.valueOf(d.encode());\n-        }\n-    },\n-\n-    probe_id { // Required\n-        public String getColumnValue(final VariantContext variant, ProbeInfo probeInfo, String sampleId) {\n-            return String.valueOf(probeInfo.probeId);\n-        }\n-    },\n-\n-    GT_encoded {\n-        public String getColumnValue(final VariantContext variant, ProbeInfo probeInfo, String sampleId) {\n-            Genotype g = variant.getGenotype(0);\n             RawArrayTsvCreator.GT_encoding gt = RawArrayTsvCreator.GT_encoding.MISSING;\n-            if (g.isHomRef() || g.isHomVar()) {\n-                Allele allele = g.getAllele(0);\n-                if (allele.basesMatch(probeInfo.alleleA)) {\n-                    gt = RawArrayTsvCreator.GT_encoding.AA;\n-                } else if (allele.basesMatch(probeInfo.alleleB)) {\n-                    gt = RawArrayTsvCreator.GT_encoding.BB;\n+            if (alleleIndexes.size() == 2) {", "originalCommit": "42063f72a87187a5845d7e4c041ba3ad10e0fdf3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU1MjExNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6822#discussion_r489552115", "bodyText": "added a warning", "author": "ahaessly", "createdAt": "2020-09-16T16:01:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ3NjE4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ3NzA3OA==", "url": "https://github.com/broadinstitute/gatk/pull/6822#discussion_r489477078", "bodyText": "do you mean the string null or an actual null?", "author": "kcibul", "createdAt": "2020-09-16T14:22:14Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/variantdb/arrays/RawArrayFieldEnum.java", "diffHunk": "@@ -3,126 +3,96 @@\n import htsjdk.variant.variantcontext.Allele;\n import htsjdk.variant.variantcontext.Genotype;\n import htsjdk.variant.variantcontext.VariantContext;\n+import org.broadinstitute.hellbender.tools.variantdb.CommonCode;\n import org.broadinstitute.hellbender.tools.variantdb.arrays.tables.ProbeInfo;\n \n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n \n /**\n  * Expected headers for the  uncompressed array table\n- *     sample, // req\n- *     probe_id, // req\n- *     GT_encoded,\n+ *     sample, // required\n+ *     probe_id, // required\n+ *     GT_encoded, // required\n  *     NORMX, // intensity\n  *     NORMY, // intensity\n  *     BAF // b allele fraction --> AD proxy\n  *     LRR // Log R ratio --> intensity value instead of DP\n  * \n- * Headers for the compressed array table\n- *     basic_array_data\n- *     raw_array_data\n  */\n \n public enum RawArrayFieldEnum {\n-    sample_id {\n-        public String getColumnValue(VariantContext variant, ProbeInfo probeInfo, String sampleId) {\n-            return sampleId;\n-        }\n-    },\n-\n-    // This where the validation step (required vs not) lives  -- fail if there is missing data for a required field\n-    // and just leave it empty if not required\n-    basic_array_data {\n-        public String getColumnValue(final VariantContext variant, ProbeInfo probeInfo, String sampleId) {\n-            String gt = GT_encoded.getColumnValue(variant, probeInfo, sampleId);\n-            BasicArrayData.ArrayGenotype agt;\n-            if (\".\".equals(gt)) {\n-                agt = BasicArrayData.ArrayGenotype.NO_CALL;\n-            } else {\n-                agt = BasicArrayData.ArrayGenotype.valueOf(gt);\n-            }\n-            BasicArrayData d = new BasicArrayData(Integer.parseInt(sampleId), (int) probeInfo.probeId, agt);\n-            return String.valueOf(d.encode());\n-        }\n-    },\n-\n-    raw_array_data {\n-        private Float convert(String s) {\n-            if (s == null || \"\".equals(s) || \"null\".equals(s) ) {\n-                return null;\n-            } else {\n-                return Float.parseFloat(s);                \n-            }\n-        }\n+    // fail if there is missing data for a required field\n+    // and return the string \"null\" if there is missing data for an optional field\n \n-        public String getColumnValue(final VariantContext variant, ProbeInfo probeInfo, String sampleId) {\n-            String normx = NORMX.getColumnValue(variant, probeInfo, sampleId);\n-            String normy = NORMY.getColumnValue(variant, probeInfo, sampleId);\n-            String baf = BAF.getColumnValue(variant, probeInfo, sampleId);\n-            String lrr = LRR.getColumnValue(variant, probeInfo, sampleId);\n+    sample_id,\n+    probe_id,\n+    GT_encoded { // Required\n+        public String getColumnValue(final VariantContext variant) {\n+            List<Integer> alleleIndexes = CommonCode.getGTAlleleIndexes(variant);\n \n-            RawArrayData d = new RawArrayData(convert(normx),\n-                                              convert(normy),\n-                                              convert(baf),\n-                                              convert(lrr)\n-                                              );\n-            return String.valueOf(d.encode());\n-        }\n-    },\n-\n-    probe_id { // Required\n-        public String getColumnValue(final VariantContext variant, ProbeInfo probeInfo, String sampleId) {\n-            return String.valueOf(probeInfo.probeId);\n-        }\n-    },\n-\n-    GT_encoded {\n-        public String getColumnValue(final VariantContext variant, ProbeInfo probeInfo, String sampleId) {\n-            Genotype g = variant.getGenotype(0);\n             RawArrayTsvCreator.GT_encoding gt = RawArrayTsvCreator.GT_encoding.MISSING;\n-            if (g.isHomRef() || g.isHomVar()) {\n-                Allele allele = g.getAllele(0);\n-                if (allele.basesMatch(probeInfo.alleleA)) {\n-                    gt = RawArrayTsvCreator.GT_encoding.AA;\n-                } else if (allele.basesMatch(probeInfo.alleleB)) {\n-                    gt = RawArrayTsvCreator.GT_encoding.BB;\n+            if (alleleIndexes.size() == 2) {\n+                Set<Integer> uniqueAlleleIndexes = new HashSet<>(alleleIndexes);\n+\n+                if (uniqueAlleleIndexes.size() == 1) {\n+                    // we know it's HOM something\n+                    if (uniqueAlleleIndexes.contains(0)) {\n+                        gt = RawArrayTsvCreator.GT_encoding.HOM_REF;\n+                    } else if (uniqueAlleleIndexes.contains(1)) {\n+                        gt = RawArrayTsvCreator.GT_encoding.HOM_VAR;\n+                    } else if (uniqueAlleleIndexes.contains(2)) {\n+                        gt = RawArrayTsvCreator.GT_encoding.HOM_ALT2;\n+                    }\n                 } else {\n-                    throw new IllegalStateException(\"allele: \" + allele + \" must match either A: \" + probeInfo.alleleA + \" or B: \" + probeInfo.alleleB);\n+                    // we know its het\n+                    if (uniqueAlleleIndexes.containsAll(new HashSet<>(Arrays.asList(0, 1)))) {\n+                        gt = RawArrayTsvCreator.GT_encoding.HET0_1;\n+                    } else if (uniqueAlleleIndexes.containsAll(new HashSet<>(Arrays.asList(1, 2))))\n+                        gt = RawArrayTsvCreator.GT_encoding.HET1_2;\n                 }\n-            } else if (g.isHet()) {\n-                gt = RawArrayTsvCreator.GT_encoding.AB;\n             }\n-            return gt.getValue();\n+            return gt == RawArrayTsvCreator.value_to_drop ? \"null\" : gt.getValue();", "originalCommit": "42063f72a87187a5845d7e4c041ba3ad10e0fdf3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU1MjUzMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6822#discussion_r489552531", "bodyText": "yes, the actual string \"null\". the tsv needs some value and the bq import will convert it to an actual null in the db. added to the comment to explain", "author": "ahaessly", "createdAt": "2020-09-16T16:02:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQ3NzA3OA=="}], "type": "inlineReview"}, {"oid": "b36a4eaec55ac5f0c17e1b2111ac037cdc50e919", "url": "https://github.com/broadinstitute/gatk/commit/b36a4eaec55ac5f0c17e1b2111ac037cdc50e919", "message": "add warning", "committedDate": "2020-09-16T16:00:12Z", "type": "commit"}]}