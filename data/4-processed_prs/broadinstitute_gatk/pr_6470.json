{"pr_number": 6470, "pr_title": "Pileup-based read error corrector", "pr_createdAt": "2020-02-27T02:56:46Z", "pr_url": "https://github.com/broadinstitute/gatk/pull/6470", "timeline": [{"oid": "8db63276ec7f7f76736dc26d3a6b6449ad26f267", "url": "https://github.com/broadinstitute/gatk/commit/8db63276ec7f7f76736dc26d3a6b6449ad26f267", "message": "Pileup-based read error corrector", "committedDate": "2020-02-26T02:10:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg3MjU4NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6470#discussion_r385872585", "bodyText": "override annotation", "author": "takutosato", "createdAt": "2020-02-28T19:10:48Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/PileupReadErrorCorrector.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package org.broadinstitute.hellbender.tools.walkers.haplotypecaller;\n+\n+import htsjdk.samtools.SAMFileHeader;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.AlignmentContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.Mutect2Engine;\n+import org.broadinstitute.hellbender.utils.Nucleotide;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.downsampling.DownsamplingMethod;\n+import org.broadinstitute.hellbender.utils.locusiterator.LocusIteratorByState;\n+import org.broadinstitute.hellbender.utils.pileup.PileupElement;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.broadinstitute.hellbender.utils.read.ReadUtils;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class PileupReadErrorCorrector implements ReadErrorCorrector {\n+    private final double logOddsThreshold;\n+    private final SAMFileHeader header;\n+    private final List<Byte> altQualBuffer = new ArrayList<>();\n+\n+    private static final byte GOOD_QUAL = 30;\n+\n+    // if there are {@code INDEL_SPAN} mismatches with {@code INDEL_SPAN} bases at the end of the read, there may be an indel\n+    // and we don't correct bases\n+    private static final int INDEL_SPAN = 15;\n+    private static final int INDEL_MISMATCHES = 3;\n+\n+    public PileupReadErrorCorrector(final double logOddsThreshold, final SAMFileHeader header) {\n+        this.logOddsThreshold = logOddsThreshold;\n+        this.header = header;\n+    }\n+\n+    public final List<GATKRead> correctReads(final Collection<GATKRead> originalRreads) {", "originalCommit": "8db63276ec7f7f76736dc26d3a6b6449ad26f267", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA3NjczOA==", "url": "https://github.com/broadinstitute/gatk/pull/6470#discussion_r386076738", "bodyText": "done", "author": "davidbenjamin", "createdAt": "2020-03-01T04:47:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg3MjU4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg3MzMzMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6470#discussion_r385873331", "bodyText": "originalRreads -> originalReads?", "author": "takutosato", "createdAt": "2020-02-28T19:12:33Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/PileupReadErrorCorrector.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package org.broadinstitute.hellbender.tools.walkers.haplotypecaller;\n+\n+import htsjdk.samtools.SAMFileHeader;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.AlignmentContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.Mutect2Engine;\n+import org.broadinstitute.hellbender.utils.Nucleotide;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.downsampling.DownsamplingMethod;\n+import org.broadinstitute.hellbender.utils.locusiterator.LocusIteratorByState;\n+import org.broadinstitute.hellbender.utils.pileup.PileupElement;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.broadinstitute.hellbender.utils.read.ReadUtils;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class PileupReadErrorCorrector implements ReadErrorCorrector {\n+    private final double logOddsThreshold;\n+    private final SAMFileHeader header;\n+    private final List<Byte> altQualBuffer = new ArrayList<>();\n+\n+    private static final byte GOOD_QUAL = 30;\n+\n+    // if there are {@code INDEL_SPAN} mismatches with {@code INDEL_SPAN} bases at the end of the read, there may be an indel\n+    // and we don't correct bases\n+    private static final int INDEL_SPAN = 15;\n+    private static final int INDEL_MISMATCHES = 3;\n+\n+    public PileupReadErrorCorrector(final double logOddsThreshold, final SAMFileHeader header) {\n+        this.logOddsThreshold = logOddsThreshold;\n+        this.header = header;\n+    }\n+\n+    public final List<GATKRead> correctReads(final Collection<GATKRead> originalRreads) {", "originalCommit": "8db63276ec7f7f76736dc26d3a6b6449ad26f267", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA3ODA0OA==", "url": "https://github.com/broadinstitute/gatk/pull/6470#discussion_r386078048", "bodyText": "done", "author": "davidbenjamin", "createdAt": "2020-03-01T05:17:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg3MzMzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg4NDE4Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6470#discussion_r385884182", "bodyText": "This chunk doesn't get triggered by the UnitTest\u2014why?", "author": "takutosato", "createdAt": "2020-02-28T19:36:40Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/PileupReadErrorCorrector.java", "diffHunk": "@@ -0,0 +1,105 @@\n+package org.broadinstitute.hellbender.tools.walkers.haplotypecaller;\n+\n+import htsjdk.samtools.SAMFileHeader;\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.broadinstitute.hellbender.engine.AlignmentContext;\n+import org.broadinstitute.hellbender.tools.walkers.mutect.Mutect2Engine;\n+import org.broadinstitute.hellbender.utils.Nucleotide;\n+import org.broadinstitute.hellbender.utils.Utils;\n+import org.broadinstitute.hellbender.utils.downsampling.DownsamplingMethod;\n+import org.broadinstitute.hellbender.utils.locusiterator.LocusIteratorByState;\n+import org.broadinstitute.hellbender.utils.pileup.PileupElement;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.broadinstitute.hellbender.utils.read.ReadUtils;\n+\n+import java.util.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+public class PileupReadErrorCorrector implements ReadErrorCorrector {\n+    private final double logOddsThreshold;\n+    private final SAMFileHeader header;\n+    private final List<Byte> altQualBuffer = new ArrayList<>();\n+\n+    private static final byte GOOD_QUAL = 30;\n+\n+    // if there are {@code INDEL_SPAN} mismatches with {@code INDEL_SPAN} bases at the end of the read, there may be an indel\n+    // and we don't correct bases\n+    private static final int INDEL_SPAN = 15;\n+    private static final int INDEL_MISMATCHES = 3;\n+\n+    public PileupReadErrorCorrector(final double logOddsThreshold, final SAMFileHeader header) {\n+        this.logOddsThreshold = logOddsThreshold;\n+        this.header = header;\n+    }\n+\n+    public final List<GATKRead> correctReads(final Collection<GATKRead> originalRreads) {\n+        final List<GATKRead> reads = originalRreads.stream().map(GATKRead::deepCopy).collect(Collectors.toList());\n+\n+        final Iterator<AlignmentContext> locusIterator = new LocusIteratorByState(reads.iterator(), DownsamplingMethod.NONE,\n+                false, ReadUtils.getSamplesFromHeader(header), header, false);\n+\n+        final Map<GATKRead, List<Pair<Integer, Byte>>> potentialCorrections = reads.stream().collect(Collectors.toMap(read -> read, read -> new ArrayList<>()));\n+\n+        Utils.stream(locusIterator).map(AlignmentContext::getBasePileup).forEach(pileup -> {\n+            final Nucleotide.Counter counter = new Nucleotide.Counter();\n+            pileup.forEach(pe -> counter.add(pe.getBase()));\n+\n+            final Optional<Nucleotide> pluralityBase = Nucleotide.STANDARD_BASES.stream().max(Comparator.comparingLong(counter::get));\n+            if (!pluralityBase.isPresent()) {\n+                return;\n+            }\n+            // TODO: not really the ref\n+            final byte ref = pluralityBase.get().encodeAsByte();\n+            altQualBuffer.clear();\n+\n+            int refCount = 0;\n+            for (final PileupElement pe : pileup) {\n+                // TODO: pe.getBase() == ref\n+                if (pe.getBase() == ref) {\n+                    refCount++;\n+                } else {\n+                    altQualBuffer.add(pe.getQual());\n+                }\n+            }\n+\n+            final double logOdds = Mutect2Engine.logLikelihoodRatio(refCount, altQualBuffer);\n+            // TODO: what if there is a good variant and an error?\n+            if (logOdds < logOddsThreshold) {\n+                for (final PileupElement pe : pileup) {\n+                    if (pe.getBase() != ref && !(pe.isDeletion() || pe.isBeforeInsertion() || pe.isAfterDeletionEnd() || pe.isBeforeDeletionStart() || pe.isAfterInsertion() || pe.isAfterSoftClip())) {\n+                        potentialCorrections.get(pe.getRead()).add(ImmutablePair.of(pe.getOffset(), ref));\n+                    }\n+                }\n+            }\n+\n+        });\n+\n+        potentialCorrections.entrySet().forEach(entry -> {\n+            final GATKRead read = entry.getKey();\n+            final byte[] bases = read.getBasesNoCopy();\n+            final int length = bases.length;\n+            final byte[] quals = read.getBaseQualitiesNoCopy();\n+            final List<Pair<Integer, Byte>> edits = entry.getValue();\n+            final int size = edits.size();\n+\n+            int firstEdit = 0;\n+            for (int n = 0; n + INDEL_MISMATCHES < size && edits.get(n + INDEL_MISMATCHES - 1).getLeft() - edits.get(n).getLeft() < INDEL_SPAN; n++) {\n+                firstEdit = n + INDEL_MISMATCHES;\n+            }\n+\n+            int lastEdit = size - 1;\n+            for (int n = size - 1; n >= INDEL_MISMATCHES - 1 && edits.get(n).getLeft() - edits.get(n - INDEL_MISMATCHES + 1).getLeft()  < INDEL_SPAN; n--) {\n+                lastEdit = n - INDEL_MISMATCHES;\n+            }\n+\n+            for (int n = firstEdit; n <= lastEdit; n++) {\n+                bases[edits.get(n).getLeft()] = edits.get(n).getRight();\n+                quals[edits.get(n).getLeft()] = GOOD_QUAL;", "originalCommit": "8db63276ec7f7f76736dc26d3a6b6449ad26f267", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA3ODAzNg==", "url": "https://github.com/broadinstitute/gatk/pull/6470#discussion_r386078036", "bodyText": "It does now.  Totally rewrote the test.", "author": "davidbenjamin", "createdAt": "2020-03-01T05:17:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg4NDE4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5OTA0OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6470#discussion_r385899049", "bodyText": "pretty sure we need finalizedReadList.get(numGoodReads+k).getBases(); here. And when I change it the tests fail\u2014the bad reads are not corrected.", "author": "takutosato", "createdAt": "2020-02-28T20:07:38Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/PileupReadErrorCorrectorUnitTest.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package org.broadinstitute.hellbender.tools.walkers.haplotypecaller;\n+\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMReadGroupRecord;\n+import org.broadinstitute.hellbender.utils.read.ArtificialReadUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.testng.Assert.*;\n+\n+public class PileupReadErrorCorrectorUnitTest {\n+\n+    @Test\n+    public void TestErrorCorrection() {\n+        final String refChunk = \"GCATAAACATGGCTCACTGC\";\n+        final String refChunkHard = \"AGCCTTGAACTCCTGGGCTCAAGTGATCCTCCTGCCTCAGTTTCCCATGTAGCTGGGACCACAGGTGGGGGCTCCACCCCTGGCTGATTTTTTTTTTTTTTTTTTTTTGAGATAGGGT\";\n+\n+        final String sample = \"sample\";\n+        final SAMReadGroupRecord rg = new SAMReadGroupRecord(\"rgID\");\n+        rg.setSample(sample);\n+        rg.setPlatform(\"illumina\");\n+        final SAMFileHeader header = ArtificialReadUtils.createArtificialSamHeaderWithReadGroup(rg);\n+\n+        final int numGoodReads = 500;\n+        final int numBadReads = 10;\n+        final int readLength = 15;\n+        final List<GATKRead> finalizedReadList = new ArrayList<GATKRead>(numGoodReads);\n+        int offset = 0;\n+        final byte[] quals = new byte[readLength];\n+\n+        Arrays.fill(quals,(byte)30);\n+\n+        for (int k=0; k < numGoodReads; k++) {\n+            final byte[] bases = Arrays.copyOfRange(refChunk.getBytes(),offset,offset+readLength);\n+            final GATKRead read = ArtificialReadUtils.createArtificialRead(header, bases, quals,readLength+\"M\");\n+            read.setName(\"good_read\" + k);\n+            read.setReadGroup(rg.getReadGroupId());\n+            finalizedReadList.add(read);\n+            offset++;\n+            if (offset >= refChunk.length()-readLength)\n+                offset = 0;\n+        }\n+        offset = 2;\n+        // coverage profile is now perfectly triangular with \"good\" bases. Inject now bad bases with errors in them.\n+        for (int k=0; k < numBadReads; k++) {\n+            final byte[] bases = finalizedReadList.get(k).getBases().clone();\n+            bases[offset] = 'N';\n+            final GATKRead read = ArtificialReadUtils.createArtificialRead(header, bases, quals, readLength + \"M\");\n+            read.setName(\"bad_read\" + k);\n+            read.setReadGroup(rg.getReadGroupId());\n+            finalizedReadList.add(read);\n+            offset += 7;\n+            if (offset >= readLength)\n+                offset = 4; // just some randomly circulating offset for error position\n+        }\n+\n+        // now correct all reads\n+        final ReadErrorCorrector readErrorCorrector = new PileupReadErrorCorrector(3.0, header);\n+        readErrorCorrector.correctReads(finalizedReadList);\n+\n+        // check that corrected reads have exactly same content as original reads\n+        for (int k=0; k < numBadReads; k++) {\n+            final byte[] badBases = finalizedReadList.get(k).getBases();", "originalCommit": "8db63276ec7f7f76736dc26d3a6b6449ad26f267", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA3Nzk5Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6470#discussion_r386077996", "bodyText": "done", "author": "davidbenjamin", "createdAt": "2020-03-01T05:16:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5OTA0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5OTM1OA==", "url": "https://github.com/broadinstitute/gatk/pull/6470#discussion_r385899358", "bodyText": "I'm surprised that LocusIteratorByState works without start positions, let alone with unsorted reads.", "author": "takutosato", "createdAt": "2020-02-28T20:08:22Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/PileupReadErrorCorrectorUnitTest.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package org.broadinstitute.hellbender.tools.walkers.haplotypecaller;\n+\n+import htsjdk.samtools.SAMFileHeader;\n+import htsjdk.samtools.SAMReadGroupRecord;\n+import org.broadinstitute.hellbender.utils.read.ArtificialReadUtils;\n+import org.broadinstitute.hellbender.utils.read.GATKRead;\n+import org.testng.Assert;\n+import org.testng.annotations.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static org.testng.Assert.*;\n+\n+public class PileupReadErrorCorrectorUnitTest {\n+\n+    @Test\n+    public void TestErrorCorrection() {\n+        final String refChunk = \"GCATAAACATGGCTCACTGC\";\n+        final String refChunkHard = \"AGCCTTGAACTCCTGGGCTCAAGTGATCCTCCTGCCTCAGTTTCCCATGTAGCTGGGACCACAGGTGGGGGCTCCACCCCTGGCTGATTTTTTTTTTTTTTTTTTTTTGAGATAGGGT\";\n+\n+        final String sample = \"sample\";\n+        final SAMReadGroupRecord rg = new SAMReadGroupRecord(\"rgID\");\n+        rg.setSample(sample);\n+        rg.setPlatform(\"illumina\");\n+        final SAMFileHeader header = ArtificialReadUtils.createArtificialSamHeaderWithReadGroup(rg);\n+\n+        final int numGoodReads = 500;\n+        final int numBadReads = 10;\n+        final int readLength = 15;\n+        final List<GATKRead> finalizedReadList = new ArrayList<GATKRead>(numGoodReads);\n+        int offset = 0;\n+        final byte[] quals = new byte[readLength];\n+\n+        Arrays.fill(quals,(byte)30);\n+\n+        for (int k=0; k < numGoodReads; k++) {\n+            final byte[] bases = Arrays.copyOfRange(refChunk.getBytes(),offset,offset+readLength);\n+            final GATKRead read = ArtificialReadUtils.createArtificialRead(header, bases, quals,readLength+\"M\");\n+            read.setName(\"good_read\" + k);\n+            read.setReadGroup(rg.getReadGroupId());", "originalCommit": "8db63276ec7f7f76736dc26d3a6b6449ad26f267", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTkwMTE1NA==", "url": "https://github.com/broadinstitute/gatk/pull/6470#discussion_r385901154", "bodyText": "All of these start at the same position (1:10000). I think you intended to slide the start position by offset. Adding the start positions to each read should do the trick (and then sort before you pass the list to LocusIteratorByState).", "author": "takutosato", "createdAt": "2020-02-28T20:12:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5OTM1OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA3Nzk4NQ==", "url": "https://github.com/broadinstitute/gatk/pull/6470#discussion_r386077985", "bodyText": "done + done", "author": "davidbenjamin", "createdAt": "2020-03-01T05:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5OTM1OA=="}], "type": "inlineReview"}, {"oid": "dd4664158702331b933116ea3a2bc85bcf5b64cc", "url": "https://github.com/broadinstitute/gatk/commit/dd4664158702331b933116ea3a2bc85bcf5b64cc", "message": "edits", "committedDate": "2020-03-01T05:18:34Z", "type": "commit"}]}