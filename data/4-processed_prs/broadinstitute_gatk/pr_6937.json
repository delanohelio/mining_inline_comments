{"pr_number": 6937, "pr_title": "Add physical phasing information to spanning deletion alleles", "pr_createdAt": "2020-11-04T15:12:38Z", "pr_url": "https://github.com/broadinstitute/gatk/pull/6937", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDcxNjA2NA==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r520716064", "bodyText": "I'm mildly surprised that htsjdk will generate .|., but I don't object.  On the whole the PGT makes this extended combined GVCF format so much easier for me to parse visually.", "author": "ldgauthier", "createdAt": "2020-11-10T16:53:06Z", "path": "src/test/resources/org/broadinstitute/hellbender/tools/walkers/CombineGVCFs/newMQcalc.combined.g.vcf", "diffHunk": "@@ -7792,23 +7792,23 @@\n 20\t10068151\t.\tA\t<NON_REF>\t.\t.\tEND=10068154\tGT:DP:GQ:MIN_DP:PL\t./.:29:63:28:0,63,945\t./.:31:57:30:0,57,855\n 20\t10068155\t.\tA\t<NON_REF>\t.\t.\t.\tGT:DP:GQ:MIN_DP:PL\t./.:29:63:28:0,63,945\t./.:30:47:30:0,47,863\n 20\t10068156\t.\tA\t<NON_REF>\t.\t.\tEND=10068157\tGT:DP:GQ:MIN_DP:PL\t./.:27:57:27:0,57,855\t./.:34:51:33:0,51,765\n-20\t10068158\t.\tGTGTATATATATA\tG,<NON_REF>\t.\t.\tBaseQRankSum=-8.420e-01;DP=59;ExcessHet=3.01;MQRankSum=0.328;RAW_MQandDP=89764,28;ReadPosRankSum=0.524\tGT:AD:DP:GQ:MIN_DP:PL:SB\t./.:3,4,0:7:57:.:105,0,57,114,69,183:0,3,2,2\t./.:.:31:54:31:0,54,810,54,810,810\n-20\t10068159\t.\tT\t*,<NON_REF>\t.\t.\tDP=60\tGT:AD:DP:GQ:MIN_DP:PL:SB\t./.:3,4,0:7:57:.:105,0,57,114,69,183:0,3,2,2\t./.:.:33:45:32:0,45,675,45,675,675\n-20\t10068160\t.\tGTATATATATATGTA\tG,*,<NON_REF>\t.\t.\tDP=64;ExcessHet=3.01;RAW_MQandDP=101405,32\tGT:AD:DP:GQ:MIN_DP:PL:SB\t./.:0,2,4,0:6:53:.:706,158,131,98,0,53,489,171,104,458:0,0,2,4\t./.:.:33:45:32:0,45,675,45,675,675,45,675,675,675\n-20\t10068161\t.\tT\t*,<NON_REF>\t.\t.\tDP=63\tGT:AD:DP:GQ:MIN_DP:PL:SB\t./.:0,4,0:6:53:.:706,98,53,489,104,458:0,0,2,4\t./.:.:32:6:31:0,6,90,6,90,90\n-20\t10068162\t.\tA\t*,<NON_REF>\t.\t.\tDP=63\tGT:AD:DP:GQ:MIN_DP:PL:SB\t./.:0,4,0:6:53:.:706,98,53,489,104,458:0,0,2,4\t./.:.:32:6:31:0,6,90,6,90,90\n-20\t10068163\t.\tT\t*,<NON_REF>\t.\t.\tDP=63\tGT:AD:DP:GQ:MIN_DP:PL:SB\t./.:0,4,0:6:53:.:706,98,53,489,104,458:0,0,2,4\t./.:.:32:6:31:0,6,90,6,90,90\n-20\t10068164\t.\tA\t*,<NON_REF>\t.\t.\tDP=63\tGT:AD:DP:GQ:MIN_DP:PL:SB\t./.:0,4,0:6:53:.:706,98,53,489,104,458:0,0,2,4\t./.:.:32:6:31:0,6,90,6,90,90\n-20\t10068165\t.\tT\t*,<NON_REF>\t.\t.\tDP=63\tGT:AD:DP:GQ:MIN_DP:PL:SB\t./.:0,4,0:6:53:.:706,98,53,489,104,458:0,0,2,4\t./.:.:32:6:31:0,6,90,6,90,90\n-20\t10068166\t.\tATATATG\tA,*,<NON_REF>\t.\t.\tBaseQRankSum=-9.800e-01;ClippingRankSum=0.00;DP=57;ExcessHet=3.01;MQRankSum=0.00;RAW_MQandDP=88000,25;ReadPosRankSum=-6.600e-01\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t./.:0,0,4,0:6:53:.:.:706,489,458,98,104,53,489,458,104,458:.:0,0,2,4\t./.:2,9,0,0:11:22:0|1:10068166_ATATATG_A:218,0,22,224,49,273,224,49,273,273:10068166:2,0,3,6\n-20\t10068167\t.\tT\t*,<NON_REF>\t.\t.\tDP=57\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t./.:0,4,0:6:53:.:.:706,98,53,489,104,458:.:0,0,2,4\t./.:2,9,0:11:22:0|1:10068166_ATATATG_A:218,0,22,224,49,273:10068166:2,0,3,6\n-20\t10068168\t.\tATATG\tA,*,<NON_REF>\t.\t.\tBaseQRankSum=0.447;ClippingRankSum=0.00;DP=57;ExcessHet=3.01;MQRankSum=0.00;RAW_MQandDP=88000,25;ReadPosRankSum=0.660\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t./.:0,0,4,0:6:53:.:.:706,489,458,98,104,53,489,458,104,458:.:0,0,2,4\t./.:9,2,0,0:11:22:1|0:10068166_ATATATG_A:22,0,218,49,224,273,49,224,273,273:10068166:3,6,2,0\n-20\t10068169\t.\tT\t*,<NON_REF>\t.\t.\tDP=57\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t./.:0,4,0:6:53:.:.:706,98,53,489,104,458:.:0,0,2,4\t./.:9,2,0:11:22:1|0:10068166_ATATATG_A:22,0,218,49,224,273:10068166:3,6,2,0\n-20\t10068170\t.\tA\t*,<NON_REF>\t.\t.\tDP=57\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t./.:0,4,0:6:53:.:.:706,98,53,489,104,458:.:0,0,2,4\t./.:9,2,0:11:22:1|0:10068166_ATATATG_A:22,0,218,49,224,273:10068166:3,6,2,0\n-20\t10068171\t.\tT\t*,<NON_REF>\t.\t.\tDP=57\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t./.:0,4,0:6:53:.:.:706,98,53,489,104,458:.:0,0,2,4\t./.:9,2,0:11:22:1|0:10068166_ATATATG_A:22,0,218,49,224,273:10068166:3,6,2,0\n-20\t10068172\t.\tG\t*,<NON_REF>\t.\t.\tDP=57\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t./.:0,4,0:6:53:.:.:706,98,53,489,104,458:.:0,0,2,4\t./.:9,2,0:11:22:1|0:10068166_ATATATG_A:22,0,218,49,224,273:10068166:3,6,2,0\n-20\t10068173\t.\tT\t*,<NON_REF>\t.\t.\tDP=61\tGT:AD:DP:GQ:MIN_DP:PL:SB\t./.:0,4,0:6:53:.:706,98,53,489,104,458:0,0,2,4\t./.:.:29:0:29:0,0,115,0,115,115\n-20\t10068174\t.\tA\t*,<NON_REF>\t.\t.\tDP=61\tGT:AD:DP:GQ:MIN_DP:PL:SB\t./.:0,4,0:6:53:.:706,98,53,489,104,458:0,0,2,4\t./.:.:29:39:29:0,39,585,39,585,585\n+20\t10068158\t.\tGTGTATATATATA\tG,<NON_REF>\t.\t.\tBaseQRankSum=-8.420e-01;DP=59;ExcessHet=3.01;MQRankSum=0.328;RAW_MQandDP=89764,28;ReadPosRankSum=0.524\tGT:AD:DP:GQ:MIN_DP:PGT:PID:PL:PS:SB\t.|.:3,4,0:7:57:.:0|1:10068158_GTGTATATATATA_G:105,0,57,114,69,183:10068158:0,3,2,2\t./.:.:31:54:31:.:.:0,54,810,54,810,810\n+20\t10068159\t.\tT\t*,<NON_REF>\t.\t.\tDP=60\tGT:AD:DP:GQ:MIN_DP:PGT:PID:PL:PS:SB\t.|.:3,4,0:7:57:.:0|1:10068158_GTGTATATATATA_G:105,0,57,114,69,183:10068158:0,3,2,2\t./.:.:33:45:32:.:.:0,45,675,45,675,675\n+20\t10068160\t.\tGTATATATATATGTA\tG,*,<NON_REF>\t.\t.\tDP=64;ExcessHet=3.01;RAW_MQandDP=101405,32\tGT:AD:DP:GQ:MIN_DP:PGT:PID:PL:PS:SB\t.|.:0,2,4,0:6:53:.:1|0:10068158_GTGTATATATATA_G:706,158,131,98,0,53,489,171,104,458:10068158:0,0,2,4\t./.:.:33:45:32:.:.:0,45,675,45,675,675,45,675,675,675\n+20\t10068161\t.\tT\t*,<NON_REF>\t.\t.\tDP=63\tGT:AD:DP:GQ:MIN_DP:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:.:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:.:32:6:31:.:.:0,6,90,6,90,90\n+20\t10068162\t.\tA\t*,<NON_REF>\t.\t.\tDP=63\tGT:AD:DP:GQ:MIN_DP:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:.:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:.:32:6:31:.:.:0,6,90,6,90,90\n+20\t10068163\t.\tT\t*,<NON_REF>\t.\t.\tDP=63\tGT:AD:DP:GQ:MIN_DP:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:.:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:.:32:6:31:.:.:0,6,90,6,90,90\n+20\t10068164\t.\tA\t*,<NON_REF>\t.\t.\tDP=63\tGT:AD:DP:GQ:MIN_DP:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:.:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:.:32:6:31:.:.:0,6,90,6,90,90\n+20\t10068165\t.\tT\t*,<NON_REF>\t.\t.\tDP=63\tGT:AD:DP:GQ:MIN_DP:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:.:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:.:32:6:31:.:.:0,6,90,6,90,90\n+20\t10068166\t.\tATATATG\tA,*,<NON_REF>\t.\t.\tBaseQRankSum=-9.800e-01;ClippingRankSum=0.00;DP=57;ExcessHet=3.01;MQRankSum=0.00;RAW_MQandDP=88000,25;ReadPosRankSum=-6.600e-01\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t.|.:0,0,4,0:6:53:1|0:10068158_GTGTATATATATA_G:706,489,458,98,104,53,489,458,104,458:10068158:0,0,2,4\t./.:2,9,0,0:11:22:0|1:10068166_ATATATG_A:218,0,22,224,49,273,224,49,273,273:10068166:2,0,3,6\n+20\t10068167\t.\tT\t*,<NON_REF>\t.\t.\tDP=57\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:2,9,0:11:22:0|1:10068166_ATATATG_A:218,0,22,224,49,273:10068166:2,0,3,6\n+20\t10068168\t.\tATATG\tA,*,<NON_REF>\t.\t.\tBaseQRankSum=0.447;ClippingRankSum=0.00;DP=57;ExcessHet=3.01;MQRankSum=0.00;RAW_MQandDP=88000,25;ReadPosRankSum=0.660\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t.|.:0,0,4,0:6:53:1|0:10068158_GTGTATATATATA_G:706,489,458,98,104,53,489,458,104,458:10068158:0,0,2,4\t./.:9,2,0,0:11:22:1|0:10068166_ATATATG_A:22,0,218,49,224,273,49,224,273,273:10068166:3,6,2,0\n+20\t10068169\t.\tT\t*,<NON_REF>\t.\t.\tDP=57\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:9,2,0:11:22:1|0:10068166_ATATATG_A:22,0,218,49,224,273:10068166:3,6,2,0\n+20\t10068170\t.\tA\t*,<NON_REF>\t.\t.\tDP=57\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:9,2,0:11:22:1|0:10068166_ATATATG_A:22,0,218,49,224,273:10068166:3,6,2,0\n+20\t10068171\t.\tT\t*,<NON_REF>\t.\t.\tDP=57\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:9,2,0:11:22:1|0:10068166_ATATATG_A:22,0,218,49,224,273:10068166:3,6,2,0\n+20\t10068172\t.\tG\t*,<NON_REF>\t.\t.\tDP=57\tGT:AD:DP:GQ:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:9,2,0:11:22:1|0:10068166_ATATATG_A:22,0,218,49,224,273:10068166:3,6,2,0\n+20\t10068173\t.\tT\t*,<NON_REF>\t.\t.\tDP=61\tGT:AD:DP:GQ:MIN_DP:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:.:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:.:29:0:29:.:.:0,0,115,0,115,115\n+20\t10068174\t.\tA\t*,<NON_REF>\t.\t.\tDP=61\tGT:AD:DP:GQ:MIN_DP:PGT:PID:PL:PS:SB\t.|.:0,4,0:6:53:.:1|0:10068158_GTGTATATATATA_G:706,98,53,489,104,458:10068158:0,0,2,4\t./.:.:29:39:29:.:.:0,39,585,39,585,585", "originalCommit": "6d161736d534a3b468e5054a5415c6784d632578", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3MDAyOQ==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r520870029", "bodyText": "I know this wasn't you, but can we clarify with \"return -1\" or something?  I expected a literal Exception.", "author": "ldgauthier", "createdAt": "2020-11-10T20:59:06Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtilsUnitTest.java", "diffHunk": "@@ -720,27 +720,60 @@ public void testGetEventMapper(final VariantContext mergedVc,\n \n         // test no phased variants, empty map\n         final Map<VariantContext, Pair<Integer, String>> nonePhased1 = new HashMap<>();\n-        tests.add(new Object[]{calls, nonePhased1, 0, 0, 0});\n+        tests.add(new Object[]{calls, nonePhased1, 0, 0, 0, calls});\n \n         // test no phased variants, full map, exception expected", "originalCommit": "6d161736d534a3b468e5054a5415c6784d632578", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjEyNzAzNw==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r526127037", "bodyText": "I've modified this test to not use the -1 return codes; it seems better to explicitly check for the exception.", "author": "cwhelan", "createdAt": "2020-11-18T14:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3MDAyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjg1MzI2MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r532853261", "bodyText": "Thanks!", "author": "ldgauthier", "createdAt": "2020-11-30T19:42:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3MDAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NjI5Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r520876293", "bodyText": "If the ref for the deletion is AA and the remaining haplotype is AAAA, then isn't the deletion not left aligned?  I don't know if that matters at this point in the code, but I don't want to complicate things.", "author": "ldgauthier", "createdAt": "2020-11-10T21:11:37Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtilsUnitTest.java", "diffHunk": "@@ -895,6 +934,33 @@ public void testConstructPhaseGroups(final List<VariantContext> calls,\n         haplotypeMap.put(vc4, haplotypes4complete);\n         tests.add(new Object[]{calls, new HashMap<>(haplotypeMap), 0, 0, 0, 0, 0});\n \n+        final Allele refForDel = Allele.create(\"AA\", true);\n+        final Allele altDel = Allele.create(\"A\", false);\n+\n+        final VariantContext delVC = new VariantContextBuilder().chr(\"20\").start(3).stop(4).alleles(Arrays.asList(refForDel, altDel)).make();\n+        final VariantContext spannedSnpVC = new VariantContextBuilder().chr(\"20\").start(4).stop(4).alleles(Arrays.asList(ref, Allele.SPAN_DEL, altT)).make();\n+\n+        final Haplotype spandelHap = new Haplotype(\"AAAA\".getBytes());", "originalCommit": "6d161736d534a3b468e5054a5415c6784d632578", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjEyNzM0Mw==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r526127343", "bodyText": "Updated this test data with a more informative and easy-to-follow haplotype that avoids this problem.", "author": "cwhelan", "createdAt": "2020-11-18T14:26:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDg3NjI5Mw=="}], "type": "inlineReview"}, {"oid": "150e9e3af2747153cb78e85872e18d59dbb5b692", "url": "https://github.com/broadinstitute/gatk/commit/150e9e3af2747153cb78e85872e18d59dbb5b692", "message": "update exception-expecting test in testConstructPhaseGroups for clarity; change test data in testConstructPhaseSetMapping to avoid left-align confusion", "committedDate": "2020-11-18T14:23:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMxODM0OA==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r526318348", "bodyText": "What about mixed hets with no ref allele or span del?  Is there any reason it can't be simply 0: first allele in the VariantContext's allele list, 1: second allele in same list?", "author": "davidbenjamin", "createdAt": "2020-11-18T18:17:21Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -65,6 +65,8 @@\n     // get realigned incorrectly.  See https://github.com/broadinstitute/gatk/issues/5060\n     public static final int MINIMUM_READ_LENGTH_AFTER_TRIMMING = 10;\n \n+    // this notation can be interpreted as a representation of the alleles present on the two phased haplotypes at the site:", "originalCommit": "150e9e3af2747153cb78e85872e18d59dbb5b692", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxNzkxMw==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r530517913", "bodyText": "I've left the current functionality as is, in that it only phases sites that are biallelic with a single site-specific alternate allele. Even with this restriction, though, we can't guarantee the order of alternate alleles in the VC's allele list, and in some cases the * allele ends up at index 1 (ie the allele list is REF, *, ALT), in which case the indexing schemes become more confusing.", "author": "cwhelan", "createdAt": "2020-11-25T16:54:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMxODM0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMyMDgxMw==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r526320813", "bodyText": "If we're going to continue to handle only the case of a single alt allele, then we should modify the code a few lines up to test not just if ( ! isBiallelic(call) ) but rather test for biallelic sites where one allele is ref.", "author": "davidbenjamin", "createdAt": "2020-11-18T18:21:12Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -639,9 +641,8 @@ public static void annotateReadLikelihoodsWithSupportedAlleles(final VariantCont\n             }\n \n             // keep track of the haplotypes that contain this particular alternate allele\n-            final Allele alt = call.getAlternateAllele(0);\n-            final Predicate<VariantContext> hasThisAlt = vc -> (vc.getStart() == call.getStart() && vc.getAlternateAlleles().contains(alt)) ||\n-                    (Allele.SPAN_DEL.equals(alt) && vc.getStart() < call.getStart() && vc.getEnd() >= call.getStart());\n+            final Allele alt = getSiteSpecificAlternateAllele(call);", "originalCommit": "150e9e3af2747153cb78e85872e18d59dbb5b692", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxOTAyMw==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r530519023", "bodyText": "The isBiallelic method for this class was already testing for that condition (but wasn't aware of * alleles). I've renamed the method to make it clear that it's explicitly testing for the case where the site is biallelic with a single site-specific alt allele.", "author": "cwhelan", "createdAt": "2020-11-25T16:55:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMyMDgxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMyMjA1OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r526322059", "bodyText": "return vc.isBiallelic() || vc.getAlternateAlleles().stream().filter(isSiteSpecificAltAllele).count() == 1", "author": "davidbenjamin", "createdAt": "2020-11-18T18:23:14Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -801,10 +811,23 @@ else if ( ! phaseSetMapping.containsKey(comp) ){\n      * Is this variant bi-allelic?  This implementation is very much specific to this class so shouldn't be pulled out into a generalized place.\n      *\n      * @param vc the variant context\n-     * @return true if this variant context is bi-allelic, ignoring the NON-REF symbolic allele, false otherwise\n+     * @return true if this variant context is bi-allelic, ignoring the NON-REF symbolic allele and '*' symbolic allele, false otherwise\n      */\n     private static boolean isBiallelic(final VariantContext vc) {\n-        return vc.isBiallelic() || (vc.getNAlleles() == 3 && vc.getAlternateAlleles().contains(Allele.NON_REF_ALLELE));\n+        if (vc.isBiallelic()) return true;", "originalCommit": "150e9e3af2747153cb78e85872e18d59dbb5b692", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxOTQyNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r530519425", "bodyText": "Done, but then I realized that the vc.isBiallelic() part is redundant with the second part of the test so I removed it.", "author": "cwhelan", "createdAt": "2020-11-25T16:56:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMyMjA1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMyNDA1OA==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r526324058", "bodyText": "return !(a.isReference() || a.isNonRefAllele() || Allele.SPAN_DEL.equals(a))", "author": "davidbenjamin", "createdAt": "2020-11-18T18:26:26Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -801,10 +811,23 @@ else if ( ! phaseSetMapping.containsKey(comp) ){\n      * Is this variant bi-allelic?  This implementation is very much specific to this class so shouldn't be pulled out into a generalized place.\n      *\n      * @param vc the variant context\n-     * @return true if this variant context is bi-allelic, ignoring the NON-REF symbolic allele, false otherwise\n+     * @return true if this variant context is bi-allelic, ignoring the NON-REF symbolic allele and '*' symbolic allele, false otherwise\n      */\n     private static boolean isBiallelic(final VariantContext vc) {\n-        return vc.isBiallelic() || (vc.getNAlleles() == 3 && vc.getAlternateAlleles().contains(Allele.NON_REF_ALLELE));\n+        if (vc.isBiallelic()) return true;\n+        final long siteSpecificAltAlleles = vc.getAlternateAlleles().stream().filter(a -> isSiteSpecificAltAllele(a)).count();\n+        return siteSpecificAltAlleles == 1L;\n+    }\n+\n+    /**\n+     * A site-specific alternate allele is one that represents concrete (i.e. not NONREF) variation that begins at the\n+     * site (i.e. not '*', which represents a concrete alternate allele that begins upstream of the current site).\n+     */\n+    private static boolean isSiteSpecificAltAllele(final Allele a) {\n+        if(a.isReference()) return false;", "originalCommit": "150e9e3af2747153cb78e85872e18d59dbb5b692", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxOTQ4Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r530519487", "bodyText": "Done", "author": "cwhelan", "createdAt": "2020-11-25T16:56:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMyNDA1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMyNDYyMQ==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r526324621", "bodyText": "Let's capitalize these constants: PHASE_01.", "author": "davidbenjamin", "createdAt": "2020-11-18T18:27:16Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -65,6 +65,8 @@\n     // get realigned incorrectly.  See https://github.com/broadinstitute/gatk/issues/5060\n     public static final int MINIMUM_READ_LENGTH_AFTER_TRIMMING = 10;\n \n+    // this notation can be interpreted as a representation of the alleles present on the two phased haplotypes at the site:\n+    // \"0\": REF or '*'; \"1\": site-specific alt allele", "originalCommit": "150e9e3af2747153cb78e85872e18d59dbb5b692", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxOTc5MQ==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r530519791", "bodyText": "Done, and converted to enums as per your comment below.", "author": "cwhelan", "createdAt": "2020-11-25T16:57:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMyNDYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMyNTg2NA==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r526325864", "bodyText": "This is truly petty but I would prefer checking g.isHet() first, since the phase genotype string is only relevant if it's a het.", "author": "davidbenjamin", "createdAt": "2020-11-18T18:29:15Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -829,9 +852,18 @@ private static VariantContext phaseVC(final VariantContext vc, final String ID,\n         final List<Genotype> phasedGenotypes = new ArrayList<>();\n         for ( final Genotype g : vc.getGenotypes() ) {\n             final List<Allele> alleles = g.getAlleles();\n-            if (phaseGT.equals(phase10) && g.isHet()) Collections.reverse(alleles); // swap the alleles if heterozygous\n+            final List<Allele> newAlleles = new ArrayList<>(alleles);\n+            if (phaseGT.equals(phase10) && g.isHet()) {", "originalCommit": "150e9e3af2747153cb78e85872e18d59dbb5b692", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUxOTYyNQ==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r530519625", "bodyText": "done", "author": "cwhelan", "createdAt": "2020-11-25T16:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMyNTg2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMzMDI1OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r526330259", "bodyText": "I think this series of nested conditionals could be simplified as:\nfinal int phasedFirstAlleleIndex = phaseGT.equals(phase10) ? 0 : 1;\nif (g.isHet() && ! isSiteSpecificAltAllele(newAlleles.get(phasedFirstAlleleIndex))) {\n    Collections.reverse(newAlleles);\n}\n\nI would also consider making the phase GTs into an enum instead of hardcoded strings, and giving it a method to extract which index, 0 or 1, is first.", "author": "davidbenjamin", "createdAt": "2020-11-18T18:36:14Z", "path": "src/main/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtils.java", "diffHunk": "@@ -829,9 +852,18 @@ private static VariantContext phaseVC(final VariantContext vc, final String ID,\n         final List<Genotype> phasedGenotypes = new ArrayList<>();\n         for ( final Genotype g : vc.getGenotypes() ) {\n             final List<Allele> alleles = g.getAlleles();\n-            if (phaseGT.equals(phase10) && g.isHet()) Collections.reverse(alleles); // swap the alleles if heterozygous\n+            final List<Allele> newAlleles = new ArrayList<>(alleles);\n+            if (phaseGT.equals(phase10) && g.isHet()) {", "originalCommit": "150e9e3af2747153cb78e85872e18d59dbb5b692", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyMDA0Nw==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r530520047", "bodyText": "Good suggestions, I've implemented these changes.", "author": "cwhelan", "createdAt": "2020-11-25T16:57:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMzMDI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMzMDQ5Ng==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r526330496", "bodyText": "Camel case these", "author": "davidbenjamin", "createdAt": "2020-11-18T18:36:38Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtilsUnitTest.java", "diffHunk": "@@ -720,27 +720,62 @@ public void testGetEventMapper(final VariantContext mergedVc,\n \n         // test no phased variants, empty map\n         final Map<VariantContext, Pair<Integer, String>> nonePhased1 = new HashMap<>();\n-        tests.add(new Object[]{calls, nonePhased1, 0, 0, 0});\n+        tests.add(new Object[]{calls, nonePhased1, 0, 0, 0, calls, null});\n \n         // test no phased variants, full map, exception expected\n+        final IllegalStateException tooSmallPhaseGroupException = new IllegalStateException(\"Somehow we have a group of phased variants that has fewer than 2 members\");\n+\n         final Map<VariantContext, Pair<Integer, String>> nonePhased2 = new HashMap<>();\n-        nonePhased2.put(vc1, Pair.of(0, \"0/1\"));\n-        nonePhased2.put(vc2, Pair.of(1, \"0/1\"));\n-        nonePhased2.put(vc3, Pair.of(2, \"0/1\"));\n-        tests.add(new Object[]{calls, nonePhased2, 3, -1, -1});\n+        nonePhased2.put(vc1, Pair.of(0, \"0|1\"));\n+        nonePhased2.put(vc2, Pair.of(1, \"0|1\"));\n+        nonePhased2.put(vc3, Pair.of(2, \"0|1\"));\n+        tests.add(new Object[]{calls, nonePhased2, 3, -1, -1, calls, tooSmallPhaseGroupException});\n \n         // test 2 phased variants\n+        final Genotype g1P = new GenotypeBuilder().alleles(Arrays.asList(ref, altC)).phased(true).make();\n+        final VariantContext vc1P = new VariantContextBuilder().chr(\"20\").start(1).stop(1).alleles(Arrays.asList(ref, altC)).genotypes(g1P).make();\n+        final Genotype g2P = new GenotypeBuilder().alleles(Arrays.asList(altC, ref)).phased(true).make();\n+        final VariantContext vc2P = new VariantContextBuilder().chr(\"20\").start(2).stop(2).alleles(Arrays.asList(ref, altC)).genotypes(g2P).make();\n+        final List<VariantContext> phasedCalls = Arrays.asList(vc1P, vc2P, vc3);\n+\n         final Map<VariantContext, Pair<Integer, String>> twoPhased = new HashMap<>();\n-        twoPhased.put(vc1, Pair.of(0, \"0/1\"));\n-        twoPhased.put(vc2, Pair.of(0, \"0/1\"));\n-        tests.add(new Object[]{calls, twoPhased, 1, 1, 2});\n+        twoPhased.put(vc1, Pair.of(0, \"0|1\"));\n+        twoPhased.put(vc2, Pair.of(0, \"1|0\"));\n+        tests.add(new Object[]{calls, twoPhased, 1, 1, 2, phasedCalls, null});\n \n         // test all phased variants\n+        final Genotype g3P = new GenotypeBuilder().alleles(Arrays.asList(ref, altC)).phased(true).make();\n+        final VariantContext vc3P = new VariantContextBuilder().chr(\"20\").start(3).stop(3).alleles(Arrays.asList(ref, altC)).genotypes(g3P).make();\n+        final List<VariantContext> phasedCalls2 = Arrays.asList(vc1P, vc2P, vc3P);\n+\n         final Map<VariantContext, Pair<Integer, String>> allPhased = new HashMap<>();\n-        allPhased.put(vc1, Pair.of(0, \"0/1\"));\n-        allPhased.put(vc2, Pair.of(0, \"0/1\"));\n-        allPhased.put(vc3, Pair.of(0, \"0/1\"));\n-        tests.add(new Object[]{calls, allPhased, 1, 1, 3});\n+        allPhased.put(vc1, Pair.of(0, \"0|1\"));\n+        allPhased.put(vc2, Pair.of(0, \"1|0\"));\n+        allPhased.put(vc3, Pair.of(0, \"0|1\"));\n+        tests.add(new Object[]{calls, allPhased, 1, 1, 3, phasedCalls2, null});\n+\n+        // test a spanning deletion case: unphased snp, deletion, spanned snp\n+        final Allele delref = Allele.create(\"AA\", true);", "originalCommit": "150e9e3af2747153cb78e85872e18d59dbb5b692", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyMDA5OQ==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r530520099", "bodyText": "done", "author": "cwhelan", "createdAt": "2020-11-25T16:57:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMzMDQ5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMzMDYxMw==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r526330613", "bodyText": "camel case", "author": "davidbenjamin", "createdAt": "2020-11-18T18:36:51Z", "path": "src/test/java/org/broadinstitute/hellbender/tools/walkers/haplotypecaller/AssemblyBasedCallerUtilsUnitTest.java", "diffHunk": "@@ -720,27 +720,62 @@ public void testGetEventMapper(final VariantContext mergedVc,\n \n         // test no phased variants, empty map\n         final Map<VariantContext, Pair<Integer, String>> nonePhased1 = new HashMap<>();\n-        tests.add(new Object[]{calls, nonePhased1, 0, 0, 0});\n+        tests.add(new Object[]{calls, nonePhased1, 0, 0, 0, calls, null});\n \n         // test no phased variants, full map, exception expected\n+        final IllegalStateException tooSmallPhaseGroupException = new IllegalStateException(\"Somehow we have a group of phased variants that has fewer than 2 members\");\n+\n         final Map<VariantContext, Pair<Integer, String>> nonePhased2 = new HashMap<>();\n-        nonePhased2.put(vc1, Pair.of(0, \"0/1\"));\n-        nonePhased2.put(vc2, Pair.of(1, \"0/1\"));\n-        nonePhased2.put(vc3, Pair.of(2, \"0/1\"));\n-        tests.add(new Object[]{calls, nonePhased2, 3, -1, -1});\n+        nonePhased2.put(vc1, Pair.of(0, \"0|1\"));\n+        nonePhased2.put(vc2, Pair.of(1, \"0|1\"));\n+        nonePhased2.put(vc3, Pair.of(2, \"0|1\"));\n+        tests.add(new Object[]{calls, nonePhased2, 3, -1, -1, calls, tooSmallPhaseGroupException});\n \n         // test 2 phased variants\n+        final Genotype g1P = new GenotypeBuilder().alleles(Arrays.asList(ref, altC)).phased(true).make();\n+        final VariantContext vc1P = new VariantContextBuilder().chr(\"20\").start(1).stop(1).alleles(Arrays.asList(ref, altC)).genotypes(g1P).make();\n+        final Genotype g2P = new GenotypeBuilder().alleles(Arrays.asList(altC, ref)).phased(true).make();\n+        final VariantContext vc2P = new VariantContextBuilder().chr(\"20\").start(2).stop(2).alleles(Arrays.asList(ref, altC)).genotypes(g2P).make();\n+        final List<VariantContext> phasedCalls = Arrays.asList(vc1P, vc2P, vc3);\n+\n         final Map<VariantContext, Pair<Integer, String>> twoPhased = new HashMap<>();\n-        twoPhased.put(vc1, Pair.of(0, \"0/1\"));\n-        twoPhased.put(vc2, Pair.of(0, \"0/1\"));\n-        tests.add(new Object[]{calls, twoPhased, 1, 1, 2});\n+        twoPhased.put(vc1, Pair.of(0, \"0|1\"));\n+        twoPhased.put(vc2, Pair.of(0, \"1|0\"));\n+        tests.add(new Object[]{calls, twoPhased, 1, 1, 2, phasedCalls, null});\n \n         // test all phased variants\n+        final Genotype g3P = new GenotypeBuilder().alleles(Arrays.asList(ref, altC)).phased(true).make();\n+        final VariantContext vc3P = new VariantContextBuilder().chr(\"20\").start(3).stop(3).alleles(Arrays.asList(ref, altC)).genotypes(g3P).make();\n+        final List<VariantContext> phasedCalls2 = Arrays.asList(vc1P, vc2P, vc3P);\n+\n         final Map<VariantContext, Pair<Integer, String>> allPhased = new HashMap<>();\n-        allPhased.put(vc1, Pair.of(0, \"0/1\"));\n-        allPhased.put(vc2, Pair.of(0, \"0/1\"));\n-        allPhased.put(vc3, Pair.of(0, \"0/1\"));\n-        tests.add(new Object[]{calls, allPhased, 1, 1, 3});\n+        allPhased.put(vc1, Pair.of(0, \"0|1\"));\n+        allPhased.put(vc2, Pair.of(0, \"1|0\"));\n+        allPhased.put(vc3, Pair.of(0, \"0|1\"));\n+        tests.add(new Object[]{calls, allPhased, 1, 1, 3, phasedCalls2, null});\n+\n+        // test a spanning deletion case: unphased snp, deletion, spanned snp\n+        final Allele delref = Allele.create(\"AA\", true);\n+        final Allele delalt = Allele.create(\"A\", false);\n+\n+\n+        final Genotype g4 = new GenotypeBuilder().alleles(Arrays.asList(delref, delalt)).make();\n+        final VariantContext vc4 = new VariantContextBuilder().chr(\"20\").start(3).stop(4).alleles(Arrays.asList(delref, delalt)).genotypes(g4).make();\n+        final Genotype g5 = new GenotypeBuilder().alleles(Arrays.asList(Allele.SPAN_DEL, altC)).make();\n+        final VariantContext vc5 = new VariantContextBuilder().chr(\"20\").start(4).stop(4).alleles(Arrays.asList(ref, Allele.SPAN_DEL, altC)).genotypes(g5).make();\n+\n+        final Genotype g4P = new GenotypeBuilder().alleles(Arrays.asList(delref, delalt)).phased(true).make();\n+        final VariantContext vc4P = new VariantContextBuilder().chr(\"20\").start(3).stop(4).alleles(Arrays.asList(delref, delalt)).genotypes(g4P).make();\n+        final Genotype g5P = new GenotypeBuilder().alleles(Arrays.asList(altC, Allele.SPAN_DEL)).phased(true).make();\n+        final VariantContext vc5P = new VariantContextBuilder().chr(\"20\").start(4).stop(4).alleles(Arrays.asList(ref, Allele.SPAN_DEL, altC)).genotypes(g5P).make();\n+\n+        final List<VariantContext> spandelCalls = Arrays.asList(vc1, vc4, vc5);", "originalCommit": "150e9e3af2747153cb78e85872e18d59dbb5b692", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDUyMDE0Mg==", "url": "https://github.com/broadinstitute/gatk/pull/6937#discussion_r530520142", "bodyText": "done", "author": "cwhelan", "createdAt": "2020-11-25T16:57:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjMzMDYxMw=="}], "type": "inlineReview"}, {"oid": "c0449f0f20e2bd3a6af37023a12b5c7e45d6aa92", "url": "https://github.com/broadinstitute/gatk/commit/c0449f0f20e2bd3a6af37023a12b5c7e45d6aa92", "message": "update haplotypecaller phasing to support genotypes with the * allele", "committedDate": "2020-11-25T16:46:41Z", "type": "commit"}, {"oid": "c14ca2e2707d4dbbdbc66ac255d79c98cebf774a", "url": "https://github.com/broadinstitute/gatk/commit/c14ca2e2707d4dbbdbc66ac255d79c98cebf774a", "message": "Update expected results for HaplotypeCallerIntegrationTest and CombineGVCFsIntegrationTest", "committedDate": "2020-11-25T16:46:41Z", "type": "commit"}, {"oid": "98d112ae3fac295500709fea8c96de5369a3bc36", "url": "https://github.com/broadinstitute/gatk/commit/98d112ae3fac295500709fea8c96de5369a3bc36", "message": "update integration test files", "committedDate": "2020-11-25T16:46:41Z", "type": "commit"}, {"oid": "da4e3684b67fe02868759249b17ea77a32c2572f", "url": "https://github.com/broadinstitute/gatk/commit/da4e3684b67fe02868759249b17ea77a32c2572f", "message": "add a few more comments", "committedDate": "2020-11-25T16:46:42Z", "type": "commit"}, {"oid": "7259b5d50cf811f1376570c948bf8acdd5d74343", "url": "https://github.com/broadinstitute/gatk/commit/7259b5d50cf811f1376570c948bf8acdd5d74343", "message": "update exception-expecting test in testConstructPhaseGroups for clarity; change test data in testConstructPhaseSetMapping to avoid left-align confusion", "committedDate": "2020-11-25T16:46:42Z", "type": "commit"}, {"oid": "d43a0142748f37b5204acb05191a574f94c58101", "url": "https://github.com/broadinstitute/gatk/commit/d43a0142748f37b5204acb05191a574f94c58101", "message": "updates based on PR comments", "committedDate": "2020-11-25T16:49:52Z", "type": "commit"}, {"oid": "d43a0142748f37b5204acb05191a574f94c58101", "url": "https://github.com/broadinstitute/gatk/commit/d43a0142748f37b5204acb05191a574f94c58101", "message": "updates based on PR comments", "committedDate": "2020-11-25T16:49:52Z", "type": "forcePushed"}]}