{"pr_number": 5136, "pr_title": "Fix leave stuck problem", "pr_createdAt": "2020-06-02T00:05:23Z", "pr_url": "https://github.com/ldtteam/minecolonies/pull/5136", "timeline": [{"oid": "c5ebcbcccbb5c95148b8bf58cbf903f3865d2e09", "url": "https://github.com/ldtteam/minecolonies/commit/c5ebcbcccbb5c95148b8bf58cbf903f3865d2e09", "message": "Fix leave stuck problem", "committedDate": "2020-06-01T23:59:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433679498", "bodyText": "I don't think all this dump inventory code here is necessary?", "author": "Raycoms", "createdAt": "2020-06-02T07:39:18Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -300,6 +311,65 @@ private IAIState findTrees()\n         return LUMBERJACK_CHOP_TREE;\n     }\n \n+    @NotNull\n+    @Override\n+    protected IAIState dumpInventory() {", "originalCommit": "c5ebcbcccbb5c95148b8bf58cbf903f3865d2e09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcxMjcyOA==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433712728", "bodyText": "The problem is that the worker can get stuck when a tree grows around him while he is choking down a tree, so when he then tries to bring the items back I need to check if he is stuck.\nI can reduce it to only the first few lines and then call the super dumpInventory function", "author": "Tobiti", "createdAt": "2020-06-02T08:37:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzcxNDU4Nw==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433714587", "bodyText": "did you test this? Because normally the AI should shut down completely when the head is in the leaves", "author": "Raycoms", "createdAt": "2020-06-02T08:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc0MTA1OQ==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433741059", "bodyText": "I tested it some minutes ago and its working fine :)", "author": "Tobiti", "createdAt": "2020-06-02T09:24:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc2NzU0Ng==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433767546", "bodyText": "shouldn't be necessary to copy all this code here though. If anything then you should put this in the walkToBlock override and not in copied functions.", "author": "Raycoms", "createdAt": "2020-06-02T10:10:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4NDU4NQ==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433784585", "bodyText": "But then I need to copy everything to the EntityCitizenWalkToProxy class", "author": "Tobiti", "createdAt": "2020-06-02T10:45:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4ODExMQ==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433788111", "bodyText": "The problem is that its final", "author": "Tobiti", "createdAt": "2020-06-02T10:52:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4ODIxNA==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433788214", "bodyText": "I will change that and override the function", "author": "Tobiti", "createdAt": "2020-06-02T10:52:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc4OTg2OQ==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433789869", "bodyText": "ye", "author": "Raycoms", "createdAt": "2020-06-02T10:56:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5MTM5NA==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433791394", "bodyText": "Still have the problem for the dumpInventory function, because its not calling the walkToBlock function of the ai\nInstead its calling this function on the worker:", "author": "Tobiti", "createdAt": "2020-06-02T10:58:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5MjA5Mw==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433792093", "bodyText": "Am I allowed to change it in the abstract class to the walkToBlock funtion?", "author": "Tobiti", "createdAt": "2020-06-02T11:00:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5MjUwNQ==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433792505", "bodyText": "and the walkToBlock on the AI, calls this also doesn't it? So we just redirect the dump call to this one.", "author": "Raycoms", "createdAt": "2020-06-02T11:01:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5MzA2OA==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433793068", "bodyText": "Its nearly the same", "author": "Tobiti", "createdAt": "2020-06-02T11:02:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5Mzc2MA==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433793760", "bodyText": "it returns the opposite though. So you have to take that into account.", "author": "Raycoms", "createdAt": "2020-06-02T11:03:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzc5NDQyMw==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433794423", "bodyText": "I can just remove the ! in dumpInventory :)", "author": "Tobiti", "createdAt": "2020-06-02T11:05:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY3OTQ5OA=="}], "type": "inlineReview"}, {"oid": "6bec282a454a867c6ac2285f9911d2424a4e448a", "url": "https://github.com/ldtteam/minecolonies/commit/6bec282a454a867c6ac2285f9911d2424a4e448a", "message": "Merge branch 'version/1.15' into version/1.15", "committedDate": "2020-06-02T10:46:46Z", "type": "commit"}, {"oid": "0a9a8f4254b4f85b5282b6081d3c6b3aec24c53b", "url": "https://github.com/ldtteam/minecolonies/commit/0a9a8f4254b4f85b5282b6081d3c6b3aec24c53b", "message": "Only keep the necessary part for dumpInventory", "committedDate": "2020-06-02T10:47:36Z", "type": "commit"}, {"oid": "fa5e90f4870d630e5a8707ac2a4bd66f5cf46ea6", "url": "https://github.com/ldtteam/minecolonies/commit/fa5e90f4870d630e5a8707ac2a4bd66f5cf46ea6", "message": "Merge remote-tracking branch 'origin/version/1.15' into version/1.15", "committedDate": "2020-06-02T10:47:43Z", "type": "commit"}, {"oid": "6dbc90ad45746dc30a0a219f2ac7ad97cda135cd", "url": "https://github.com/ldtteam/minecolonies/commit/6dbc90ad45746dc30a0a219f2ac7ad97cda135cd", "message": "Change to override walkToBlock", "committedDate": "2020-06-02T11:04:00Z", "type": "commit"}, {"oid": "feaafc886f3a41303244eac4036859599653dfaa", "url": "https://github.com/ldtteam/minecolonies/commit/feaafc886f3a41303244eac4036859599653dfaa", "message": "Remove ! to check right result", "committedDate": "2020-06-02T11:05:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NjAzNw==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433856037", "bodyText": "I think all you needed to add for the unstuck to work better is here to add  BlockPos nextPosUpUp = new BlockPos(next.x, next.y + 2, next.z); as it gets stuck in cases where it needs space to change height.", "author": "someaddons", "createdAt": "2020-06-02T13:01:00Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +565,93 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n-            {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-", "originalCommit": "feaafc886f3a41303244eac4036859599653dfaa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NjIwNg==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433856206", "bodyText": "see my comment above, this shouldnt be here at all", "author": "someaddons", "createdAt": "2020-06-02T13:01:15Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -227,6 +235,17 @@ protected IAIState decide()\n         return GET_RECIPE;\n     }\n \n+    @Override", "originalCommit": "feaafc886f3a41303244eac4036859599653dfaa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxNTcwOA==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433915708", "bodyText": "Done", "author": "Tobiti", "createdAt": "2020-06-02T14:21:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NjIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzEyNw==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433857127", "bodyText": "we are already using the pathing to see which leaves need to be removed, I don't think we need this general remove all around worker", "author": "someaddons", "createdAt": "2020-06-02T13:02:43Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +565,93 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n-            {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n-                {\n-                    mineBlock(nextPos);\n+            Path path = worker.getNavigator().getPath();\n+            if(path != null) {\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex()) {\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n-                {\n-                    mineBlock(nextPosUp);\n+                if(path.getCurrentPathLength() == 0){\n+                    return true;\n                 }\n             }\n+            else {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck(){\n+\n+        if (!worker.getNavigator().noPath()) {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null) {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+                // Blocks in front of the worker\n+                checkPositions.add(new BlockPos(next.x, next.y, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 1, next.z));\n+                // Block above the worker\n+                checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 2, worker.getCurrentPosition().getZ()));\n+\n+                mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+                return;\n+            }\n+        }\n+\n+        // General unstuck\n+        ArrayList<BlockPos> checkPositions = new ArrayList<>();", "originalCommit": "feaafc886f3a41303244eac4036859599653dfaa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwOTUxNA==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433909514", "bodyText": "But you dont have always a path, sometimes the path is empty or null", "author": "Tobiti", "createdAt": "2020-06-02T14:13:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzcxMQ==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433857711", "bodyText": "This function isnt going to work nicely like this, because our mineBlock() is made to mine one position after another as it works through repeated calls and a delay inbetween", "author": "someaddons", "createdAt": "2020-06-02T13:03:43Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +565,93 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n-            {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n-                {\n-                    mineBlock(nextPos);\n+            Path path = worker.getNavigator().getPath();\n+            if(path != null) {\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex()) {\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n-                {\n-                    mineBlock(nextPosUp);\n+                if(path.getCurrentPathLength() == 0){\n+                    return true;\n                 }\n             }\n+            else {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck(){\n+\n+        if (!worker.getNavigator().noPath()) {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null) {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+                // Blocks in front of the worker\n+                checkPositions.add(new BlockPos(next.x, next.y, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 1, next.z));\n+                // Block above the worker\n+                checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 2, worker.getCurrentPosition().getZ()));\n+\n+                mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+                return;\n+            }\n+        }\n+\n+        // General unstuck\n+        ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+        // Blocks in front of the worker\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY(), worker.getForward().getZ()));\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY() + 1, worker.getForward().getZ()));\n+\n+        // blocks in north of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).north());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).north());\n+\n+        // blocks in east of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).east());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).east());\n+\n+        // blocks in south of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).south());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).south());\n+\n+        // blocks in west of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).west());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).west());\n+\n+        mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+    }\n+\n+    /**\n+     * Checks blocks for tag and mines the first it fines if its the same\n+     * @param blockPositions block positions\n+     * @param tag tag to check\n+     */\n+    private boolean mineIfEqualsBlockTag(List<BlockPos> blockPositions, Tag<Block> tag){", "originalCommit": "feaafc886f3a41303244eac4036859599653dfaa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkxMjE1Mg==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r433912152", "bodyText": "Why?\nIts only adding one block per call", "author": "Tobiti", "createdAt": "2020-06-02T14:16:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDAzODY5Nw==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r434038697", "bodyText": "ye one block per call isnt enough, you need to call the same position twice, with a time delay inbetween. It simulates the harvesting with a delay before actually breaking the block. Since the AI repeatedly executes this code. You should do if(leaf) mine(leaf) and then you do nothing but wait for the next time it runs into it again, and you check for the first leaf you find again and break that one again.", "author": "someaddons", "createdAt": "2020-06-02T17:10:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA4Njk0Ng==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r434086946", "bodyText": "But that was happening before, I just moved it into a separate function to minimize the code lines", "author": "Tobiti", "createdAt": "2020-06-02T18:21:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDA5NDQzNw==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r434094437", "bodyText": "no before it was an if else, it did check first pos -> is leaf? -> mine block. Next AI update it does check first pos -> is leaf? -> mine block (block breaks). Then next AI update it does check first pos -> no leaf -> check second pos -> is leaf -> mine second", "author": "someaddons", "createdAt": "2020-06-02T18:32:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzcxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDExMTIwNQ==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r434111205", "bodyText": "And now its the same\nI starts with the first object in the list\nif leaf -> mine and return, second run, again first is leaf -> mine(break) -> return\n3rd run first is not leaf -> check second, if leaf ...", "author": "Tobiti", "createdAt": "2020-06-02T19:02:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg1NzcxMQ=="}], "type": "inlineReview"}, {"oid": "520772cc02c7ace677f785937e278368562f3e4f", "url": "https://github.com/ldtteam/minecolonies/commit/520772cc02c7ace677f785937e278368562f3e4f", "message": "Remove walkToBLock", "committedDate": "2020-06-02T14:21:07Z", "type": "commit"}, {"oid": "c6e58fb9bfb516cdd56f624e8fe77443605f20c6", "url": "https://github.com/ldtteam/minecolonies/commit/c6e58fb9bfb516cdd56f624e8fe77443605f20c6", "message": "Merge branch 'version/1.15' into version/1.15", "committedDate": "2020-06-03T16:46:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3Njk0Mw==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436276943", "bodyText": "Do these still all have to be protected?", "author": "Raycoms", "createdAt": "2020-06-06T15:23:02Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/basic/AbstractEntityAIBasic.java", "diffHunk": "@@ -114,7 +114,7 @@\n     /**\n      * Slot he is currently trying to dump.\n      */\n-    private int slotAt = 0;\n+    protected int slotAt = 0;", "originalCommit": "c6e58fb9bfb516cdd56f624e8fe77443605f20c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3ODI0Ng==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436278246", "bodyText": "brackets", "author": "Raycoms", "createdAt": "2020-06-06T15:41:52Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -413,7 +421,9 @@ private IAIState chopTree()\n         {\n             if (!walkToTree(job.getTree().getStumpLocations().get(0)))\n             {\n-                checkIfStuckOnLeaves();\n+                if(checkIfStuck()) {\n+                    tryUnstuck();\n+                }", "originalCommit": "c6e58fb9bfb516cdd56f624e8fe77443605f20c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI3ODI3Mw==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436278273", "bodyText": "code format is off", "author": "Raycoms", "createdAt": "2020-06-06T15:42:15Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +554,94 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n-            {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n-                {\n-                    mineBlock(nextPos);\n+            Path path = worker.getNavigator().getPath();\n+            if(path != null) {\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex()) {\n+                    return true;", "originalCommit": "c6e58fb9bfb516cdd56f624e8fe77443605f20c6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "860682eca37aeef4d9d15525e13bfccc6cfbffdd", "url": "https://github.com/ldtteam/minecolonies/commit/860682eca37aeef4d9d15525e13bfccc6cfbffdd", "message": "Change protected back to private", "committedDate": "2020-06-06T16:11:31Z", "type": "commit"}, {"oid": "4830dd7c40e4f1b7a88f72d5df1d40d28d4f1efb", "url": "https://github.com/ldtteam/minecolonies/commit/4830dd7c40e4f1b7a88f72d5df1d40d28d4f1efb", "message": "Merge remote-tracking branch 'origin/version/1.15' into version/1.15", "committedDate": "2020-06-06T16:11:37Z", "type": "commit"}, {"oid": "7b2585a80ae272a21b37ea14320ccb7e16c077d4", "url": "https://github.com/ldtteam/minecolonies/commit/7b2585a80ae272a21b37ea14320ccb7e16c077d4", "message": "Fix codestyle", "committedDate": "2020-06-06T16:15:13Z", "type": "commit"}, {"oid": "8e0983e2c1639a4fd640d720a75eec762658050a", "url": "https://github.com/ldtteam/minecolonies/commit/8e0983e2c1639a4fd640d720a75eec762658050a", "message": "Fix more format stuff", "committedDate": "2020-06-06T16:26:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MjMxNA==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436282314", "bodyText": "format", "author": "Raycoms", "createdAt": "2020-06-06T16:39:21Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +555,102 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n             {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex())\n                 {\n-                    mineBlock(nextPos);\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() == 0)\n                 {\n-                    mineBlock(nextPosUp);\n+                    return true;\n                 }\n             }\n+            else\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck(){", "originalCommit": "8e0983e2c1639a4fd640d720a75eec762658050a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NDA0Nw==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436284047", "bodyText": "Done :)", "author": "Tobiti", "createdAt": "2020-06-06T17:02:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MjMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MjM2Mw==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436282363", "bodyText": "This looks like you could make a\nfor each Direction in Horizontal directions\naddInDirection", "author": "Raycoms", "createdAt": "2020-06-06T16:39:55Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +555,102 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n             {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex())\n                 {\n-                    mineBlock(nextPos);\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() == 0)\n                 {\n-                    mineBlock(nextPosUp);\n+                    return true;\n                 }\n             }\n+            else\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck(){\n+\n+        if (!worker.getNavigator().noPath())\n+        {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n+            {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+\n+                // Blocks in front of the worker\n+                checkPositions.add(new BlockPos(next.x, next.y, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 1, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 2, next.z));\n+\n+                // Block above the worker\n+                checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 2, worker.getCurrentPosition().getZ()));\n+\n+                mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+                return;\n+            }\n+        }\n+\n+        // General unstuck\n+        ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+        // Blocks in front of the worker\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY(), worker.getForward().getZ()));", "originalCommit": "8e0983e2c1639a4fd640d720a75eec762658050a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NDAxNw==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436284017", "bodyText": "Done :)", "author": "Tobiti", "createdAt": "2020-06-06T17:02:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MjM2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5OTg5MA==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436299890", "bodyText": "where?", "author": "Raycoms", "createdAt": "2020-06-06T20:54:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MjM2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MjM5MQ==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436282391", "bodyText": "format this entire method too", "author": "Raycoms", "createdAt": "2020-06-06T16:40:05Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,31 +555,102 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n             {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex())\n                 {\n-                    mineBlock(nextPos);\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() == 0)\n                 {\n-                    mineBlock(nextPosUp);\n+                    return true;\n                 }\n             }\n+            else\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck(){\n+\n+        if (!worker.getNavigator().noPath())\n+        {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n+            {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+\n+                // Blocks in front of the worker\n+                checkPositions.add(new BlockPos(next.x, next.y, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 1, next.z));\n+                checkPositions.add(new BlockPos(next.x, next.y + 2, next.z));\n+\n+                // Block above the worker\n+                checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 2, worker.getCurrentPosition().getZ()));\n+\n+                mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+                return;\n+            }\n+        }\n+\n+        // General unstuck\n+        ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+        // Blocks in front of the worker\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY(), worker.getForward().getZ()));\n+        checkPositions.add(new BlockPos(worker.getForward().getX(), worker.getForward().getY() + 1, worker.getForward().getZ()));\n+\n+        // blocks in north of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).north());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).north());\n+\n+        // blocks in east of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).east());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).east());\n+\n+        // blocks in south of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).south());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).south());\n+\n+        // blocks in west of the player\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY(), worker.getCurrentPosition().getZ()).west());\n+        checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 1, worker.getCurrentPosition().getZ()).west());\n+\n+        mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+    }\n+\n+    /**\n+     * Checks blocks for tag and mines the first it fines if its the same\n+     * @param blockPositions block positions\n+     * @param tag tag to check\n+     */\n+    private boolean mineIfEqualsBlockTag(List<BlockPos> blockPositions, Tag<Block> tag){\n+        for (BlockPos currentPos : blockPositions) {", "originalCommit": "8e0983e2c1639a4fd640d720a75eec762658050a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NDA0MA==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436284040", "bodyText": "Is fixed :)", "author": "Tobiti", "createdAt": "2020-06-06T17:02:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4MjM5MQ=="}], "type": "inlineReview"}, {"oid": "0f49c329a542eb4a3944c285a4ac2d0ecdeefe8c", "url": "https://github.com/ldtteam/minecolonies/commit/0f49c329a542eb4a3944c285a4ac2d0ecdeefe8c", "message": "Fix format", "committedDate": "2020-06-06T17:01:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NDI5OA==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436284298", "bodyText": "cough", "author": "Raycoms", "createdAt": "2020-06-06T17:05:47Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,30 +555,105 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n             {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex())\n                 {\n-                    mineBlock(nextPos);\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() == 0)\n                 {\n-                    mineBlock(nextPosUp);\n+                    return true;\n+                }\n+            }\n+            else\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck()\n+    {\n+        if (!worker.getNavigator().noPath())\n+        {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n+            {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+\n+                // Blocks in front of the worker\n+                for(int i = 0; i <= 2; i++){", "originalCommit": "0f49c329a542eb4a3944c285a4ac2d0ecdeefe8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5MDExNQ==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436290115", "bodyText": "Done\ni need to change the code style in intellj", "author": "Tobiti", "createdAt": "2020-06-06T18:30:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NDI5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI5Njc0MA==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436296740", "bodyText": "you can import the codestyle from the documentation folder", "author": "someaddons", "createdAt": "2020-06-06T20:03:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI4NDI5OA=="}], "type": "inlineReview"}, {"oid": "46e54b367d3831f99afbfd9737024df8f3b404f9", "url": "https://github.com/ldtteam/minecolonies/commit/46e54b367d3831f99afbfd9737024df8f3b404f9", "message": "Fix format", "committedDate": "2020-06-06T18:29:24Z", "type": "commit"}, {"oid": "84405805207686a571c33b3f4d8c34a14a6c39a7", "url": "https://github.com/ldtteam/minecolonies/commit/84405805207686a571c33b3f4d8c34a14a6c39a7", "message": "Add direction loop", "committedDate": "2020-06-07T11:32:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1ODg5MA==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436358890", "bodyText": "There is a minecraft class for all horizontal directions =D", "author": "Raycoms", "createdAt": "2020-06-07T12:36:22Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/lumberjack/EntityAIWorkLumberjack.java", "diffHunk": "@@ -544,30 +556,98 @@ private Boolean isPassable(final BlockState blockState)\n         return blockState.getMaterial() == Material.LEAVES;\n     }\n \n+\n     /**\n      * Check if distance to block changed and if we are not moving for too long, try to get unstuck.\n      *\n      * @return false\n      */\n-    private boolean checkIfStuckOnLeaves()\n+    private boolean checkIfStuck()\n     {\n         if (!worker.getNavigator().noPath())\n         {\n-            Path pathToTree = worker.getNavigator().getPath();\n-            if (pathToTree != null && pathToTree.getCurrentPathLength() > pathToTree.getCurrentPathIndex())\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n             {\n-                PathPoint next = pathToTree.getPathPointFromIndex(pathToTree.getCurrentPathIndex());\n-                BlockPos nextPos = new BlockPos(next.x, next.y, next.z);\n-                BlockPos nextPosUp = new BlockPos(next.x, next.y + 1, next.z);\n-\n-                if (world.getBlockState(nextPos).getBlock().isIn(BlockTags.LEAVES))\n+                if (path.getCurrentPathLength() > path.getCurrentPathIndex())\n+                {\n+                    return true;\n+                }\n+                if (path.getCurrentPathLength() == 0)\n                 {\n-                    mineBlock(nextPos);\n+                    return true;\n                 }\n-                else if (world.getBlockState(nextPosUp).getBlock().isIn(BlockTags.LEAVES))\n+            }\n+            else\n+            {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Mines leaves on path and above.\n+     */\n+    private void tryUnstuck()\n+    {\n+        if (!worker.getNavigator().noPath())\n+        {\n+            Path path = worker.getNavigator().getPath();\n+            if (path != null)\n+            {\n+                // Unstuck with path\n+                ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+                PathPoint next = path.getPathPointFromIndex(path.getCurrentPathIndex());\n+\n+                // Blocks in front of the worker\n+                for(int i = 0; i <= 2; i++)\n                 {\n-                    mineBlock(nextPosUp);\n+                    checkPositions.add(new BlockPos(next.x, next.y + i, next.z));\n                 }\n+\n+                // Block above the worker\n+                checkPositions.add(new BlockPos(worker.getCurrentPosition().getX(), worker.getCurrentPosition().getY() + 2, worker.getCurrentPosition().getZ()));\n+\n+                mineIfEqualsBlockTag(checkPositions, BlockTags.LEAVES);\n+                return;\n+            }\n+        }\n+\n+        // General unstuck\n+        ArrayList<BlockPos> checkPositions = new ArrayList<>();\n+        List<Direction> directions = new ArrayList<>();\n+        directions.add(Direction.NORTH);\n+        directions.add(Direction.EAST);\n+        directions.add(Direction.WEST);\n+        directions.add(Direction.SOUTH);\n+\n+        for (Direction direction: directions)", "originalCommit": "84405805207686a571c33b3f4d8c34a14a6c39a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2Mzg0MA==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436363840", "bodyText": "Couldn't find it :(", "author": "Tobiti", "createdAt": "2020-06-07T13:33:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1ODg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2NDIwOQ==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436364209", "bodyText": "Plane.HORIZONTAL.values()", "author": "Raycoms", "createdAt": "2020-06-07T13:37:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1ODg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM2NTYyMQ==", "url": "https://github.com/ldtteam/minecolonies/pull/5136#discussion_r436365621", "bodyText": "Is done :)", "author": "Tobiti", "createdAt": "2020-06-07T13:54:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjM1ODg5MA=="}], "type": "inlineReview"}, {"oid": "89c30adc9a4906775d2f95af2c3e5f6216296f97", "url": "https://github.com/ldtteam/minecolonies/commit/89c30adc9a4906775d2f95af2c3e5f6216296f97", "message": "Use Plane.HORIZONTAL.values()", "committedDate": "2020-06-07T13:54:00Z", "type": "commit"}, {"oid": "8031d9d7c3fb80afbd7e66a20f5d119ea6121a71", "url": "https://github.com/ldtteam/minecolonies/commit/8031d9d7c3fb80afbd7e66a20f5d119ea6121a71", "message": "Merge branch 'version/1.15' into version/1.15", "committedDate": "2020-06-07T15:09:53Z", "type": "commit"}, {"oid": "eefb6cd700df814fb4babdcfe8feae2ecd884b73", "url": "https://github.com/ldtteam/minecolonies/commit/eefb6cd700df814fb4babdcfe8feae2ecd884b73", "message": "Merge branch 'version/1.15' into version/1.15", "committedDate": "2020-06-07T18:43:35Z", "type": "commit"}]}