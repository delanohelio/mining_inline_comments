{"pr_number": 5298, "pr_title": "Improve construction tape", "pr_createdAt": "2020-06-26T08:16:32Z", "pr_url": "https://github.com/ldtteam/minecolonies/pull/5298", "timeline": [{"oid": "407655c951c91b522ff1fe63f7ecdd0e3c29e2e3", "url": "https://github.com/ldtteam/minecolonies/commit/407655c951c91b522ff1fe63f7ecdd0e3c29e2e3", "message": "Change tape model to act like a FourWayBlock", "committedDate": "2020-06-23T10:47:16Z", "type": "commit"}, {"oid": "5c4562550f6ed155f2a4513100e57573f51a85bf", "url": "https://github.com/ldtteam/minecolonies/commit/5c4562550f6ed155f2a4513100e57573f51a85bf", "message": "Add multi-direction logic and default axis", "committedDate": "2020-06-24T02:05:05Z", "type": "commit"}, {"oid": "d8337c427c3f9b077b48c902febe5086e0644538", "url": "https://github.com/ldtteam/minecolonies/commit/d8337c427c3f9b077b48c902febe5086e0644538", "message": "Add dynamic hit box creation and waterlogging\n\nUse the same methods as a FourWayBlock to build the composite hit boxes\nAdd the ability for tape to be waterlogged\nRename the super class to ...FallingFourWay", "committedDate": "2020-06-24T10:25:46Z", "type": "commit"}, {"oid": "f71d33b87f4b96ed8853c680ddee514531edc8cf", "url": "https://github.com/ldtteam/minecolonies/commit/f71d33b87f4b96ed8853c680ddee514531edc8cf", "message": "Improve tape four way logic\n\nAdd condition to remove the stem if there is a T junction opposite another T junction", "committedDate": "2020-06-24T13:35:59Z", "type": "commit"}, {"oid": "b2aaeebff06e3bf8200453775d2b442c5bf73281", "url": "https://github.com/ldtteam/minecolonies/commit/b2aaeebff06e3bf8200453775d2b442c5bf73281", "message": "Rework the Helper\n\nImprove code cleanliness and efficiency in ConstructionTapeHandler\nLink to new placement state getters", "committedDate": "2020-06-25T07:07:31Z", "type": "commit"}, {"oid": "bbfedef4546938197f00d500234e4e180443e115", "url": "https://github.com/ldtteam/minecolonies/commit/bbfedef4546938197f00d500234e4e180443e115", "message": "Add tape corner logic\n\nEnsure tape marked as a corner keeps the correct sides when isolated.", "committedDate": "2020-06-25T08:24:42Z", "type": "commit"}, {"oid": "7aafb7e84f12a79995a96564f514b83d3689dc02", "url": "https://github.com/ldtteam/minecolonies/commit/7aafb7e84f12a79995a96564f514b83d3689dc02", "message": "Clean up and fix formatting\n\nMove Four Way shape logic to Abstract tape class\nRevert name of abstract falling block class to AbstractBlockMinecoloniesFalling\nGeneral formatting and doc fixes", "committedDate": "2020-06-26T05:45:30Z", "type": "commit"}, {"oid": "cd5857b66427278ec2c670f51ef41eb0dc71842c", "url": "https://github.com/ldtteam/minecolonies/commit/cd5857b66427278ec2c670f51ef41eb0dc71842c", "message": "Fix the tape held item model\n\nAdd a new model specifically for the inventory like fences have\nAdjust the standard model's post top face to not be on a dark patch of wood", "committedDate": "2020-06-26T07:11:44Z", "type": "commit"}, {"oid": "00e0d0a5cbbf363dfa41178b1d4c6fc0525f477e", "url": "https://github.com/ldtteam/minecolonies/commit/00e0d0a5cbbf363dfa41178b1d4c6fc0525f477e", "message": "Add compatibility\n\nEnsure that tape placed in older versions at least appears, and with the right orientation.", "committedDate": "2020-06-26T07:41:32Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0NDk1MA==", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446044950", "bodyText": "use lower case full name, sizeX or similar", "author": "Nightenom", "createdAt": "2020-06-26T08:31:33Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/builder/ConstructionTapeHelper.java", "diffHunk": "@@ -61,106 +56,77 @@ public static void placeConstructionTape(@NotNull final WorkOrderBuildDecoration\n      */\n     public static void placeConstructionTape(final BlockPos pos, final Tuple<Tuple<Integer, Integer>, Tuple<Integer, Integer>> corners, @NotNull final World world)\n     {\n-        if (MineColonies.getConfig().getCommon().builderPlaceConstructionTape.get())\n-        {\n-            final BlockState constructionTape = ModBlocks.blockConstructionTape.getDefaultState();\n+        if (!MineColonies.getConfig().getCommon().builderPlaceConstructionTape.get()) return;\n \n-            final int x1 = corners.getA().getA();\n-            final int x3 = corners.getA().getB();\n-            final int z1 = corners.getB().getA();\n-            final int z3 = corners.getB().getB();\n-            final int y = pos.getY();\n-            int newY;\n+        final BlockState constructionTape = ModBlocks.blockConstructionTape.getDefaultState();\n \n-            if (x1 < x3)\n-            {\n-                for (int i = x1 + 1; i < x3; i++)\n-                {\n-                    newY = checkIfPlaceable(i, y, z1, world);\n-                    final BlockPos row1 = new BlockPos(i, newY, z1);\n-                    world.setBlockState(row1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, row1));\n-                    newY = checkIfPlaceable(i, y, z3, world);\n-                    final BlockPos row2 = new BlockPos(i, newY, z3);\n-                    world.setBlockState(row2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, row2));\n-                }\n-            }\n-            else\n-            {\n-                for (int i = x3 + 1; i < x1; i++)\n-                {\n-                    newY = checkIfPlaceable(i, y, z1, world);\n-                    final BlockPos row1 = new BlockPos(i, newY, z1);\n-                    world.setBlockState(row1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, row1));\n-                    newY = checkIfPlaceable(i, y, z3, world);\n-                    final BlockPos row2 = new BlockPos(i, newY, z3);\n-                    world.setBlockState(row2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, row2));\n-                }\n-            }\n-            if (z1 < z3)\n+        final int X = Math.min(corners.getA().getA(), corners.getA().getB());\n+        final int Y = pos.getY();\n+        final int Z = Math.min(corners.getB().getA(), corners.getB().getB());\n+        int W = Math.abs(corners.getA().getB() - corners.getA().getA());\n+        int H = Math.abs(corners.getB().getB() - corners.getB().getA());", "originalCommit": "00e0d0a5cbbf363dfa41178b1d4c6fc0525f477e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0NjA4NQ==", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446046085", "bodyText": "leaves block only when not persistent, or I would say no to all", "author": "Nightenom", "createdAt": "2020-06-26T08:33:42Z", "path": "src/main/java/com/minecolonies/coremod/entity/ai/citizen/builder/ConstructionTapeHelper.java", "diffHunk": "@@ -61,106 +56,77 @@ public static void placeConstructionTape(@NotNull final WorkOrderBuildDecoration\n      */\n     public static void placeConstructionTape(final BlockPos pos, final Tuple<Tuple<Integer, Integer>, Tuple<Integer, Integer>> corners, @NotNull final World world)\n     {\n-        if (MineColonies.getConfig().getCommon().builderPlaceConstructionTape.get())\n-        {\n-            final BlockState constructionTape = ModBlocks.blockConstructionTape.getDefaultState();\n+        if (!MineColonies.getConfig().getCommon().builderPlaceConstructionTape.get()) return;\n \n-            final int x1 = corners.getA().getA();\n-            final int x3 = corners.getA().getB();\n-            final int z1 = corners.getB().getA();\n-            final int z3 = corners.getB().getB();\n-            final int y = pos.getY();\n-            int newY;\n+        final BlockState constructionTape = ModBlocks.blockConstructionTape.getDefaultState();\n \n-            if (x1 < x3)\n-            {\n-                for (int i = x1 + 1; i < x3; i++)\n-                {\n-                    newY = checkIfPlaceable(i, y, z1, world);\n-                    final BlockPos row1 = new BlockPos(i, newY, z1);\n-                    world.setBlockState(row1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, row1));\n-                    newY = checkIfPlaceable(i, y, z3, world);\n-                    final BlockPos row2 = new BlockPos(i, newY, z3);\n-                    world.setBlockState(row2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, row2));\n-                }\n-            }\n-            else\n-            {\n-                for (int i = x3 + 1; i < x1; i++)\n-                {\n-                    newY = checkIfPlaceable(i, y, z1, world);\n-                    final BlockPos row1 = new BlockPos(i, newY, z1);\n-                    world.setBlockState(row1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, row1));\n-                    newY = checkIfPlaceable(i, y, z3, world);\n-                    final BlockPos row2 = new BlockPos(i, newY, z3);\n-                    world.setBlockState(row2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, row2));\n-                }\n-            }\n-            if (z1 < z3)\n+        final int X = Math.min(corners.getA().getA(), corners.getA().getB());\n+        final int Y = pos.getY();\n+        final int Z = Math.min(corners.getB().getA(), corners.getB().getB());\n+        int W = Math.abs(corners.getA().getB() - corners.getA().getA());\n+        int H = Math.abs(corners.getB().getB() - corners.getB().getA());\n+        BlockPos working;\n+\n+        for (BlockPos place = new BlockPos(X,Y,Z); place.getX() < X+W || place.getZ() < Z+H;) {\n+            if (place.getX() < X+W)\n             {\n-                for (int i = z1 + 1; i < z3; i++)\n-                {\n-                    newY = checkIfPlaceable(x1, y, i, world);\n-                    final BlockPos row3 = new BlockPos(x1, newY, i);\n-                    world.setBlockState(row3, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.EAST), world, row3));\n-                    newY = checkIfPlaceable(x3, y, i, world);\n-                    final BlockPos row4 = new BlockPos(x3, newY, i);\n-                    world.setBlockState(row4, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.WEST), world, row4));\n-                }\n+                working = firstValidPosition(new BlockPos(place.getX(), Y, Z), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getX() == X), world, working, Direction.SOUTH)\n+                );\n+\n+                working = firstValidPosition(new BlockPos(place.getX(), Y, Z+H), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getX() == X), world, working, Direction.NORTH)\n+                );\n             }\n-            else\n+\n+            if (place.getZ() < Z+H)\n             {\n-                for (int i = z3 + 1; i < z1; i++)\n-                {\n-                    newY = checkIfPlaceable(x1, y, i, world);\n-                    final BlockPos row3 = new BlockPos(x1, newY, i);\n-                    world.setBlockState(row3, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.EAST), world, row3));\n-                    newY = checkIfPlaceable(x3, y, i, world);\n-                    final BlockPos row4 = new BlockPos(x3, newY, i);\n-                    world.setBlockState(row4, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.WEST), world, row4));\n-                }\n+                working = firstValidPosition(new BlockPos(X, Y, place.getZ()), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getZ() == Z), world, working, Direction.EAST)\n+                );\n+\n+                working = firstValidPosition(new BlockPos(X+W, Y, place.getZ()), world);\n+                world.setBlockState(working,\n+                        BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, place.getZ() == Z), world, working, place.getZ() == Z? Direction.SOUTH : Direction.WEST)\n+                );\n             }\n-            newY = checkIfPlaceable(x1, y, z1, world);\n-            final BlockPos corner1 = new BlockPos(x1, newY, z1);\n-            newY = checkIfPlaceable(x1, y, z3, world);\n-            final BlockPos corner2 = new BlockPos(x1, newY, z3);\n-            newY = checkIfPlaceable(x3, y, z1, world);\n-            final BlockPos corner3 = new BlockPos(x3, newY, z1);\n-            newY = checkIfPlaceable(x3, y, z3, world);\n-            final BlockPos corner4 = new BlockPos(x3, newY, z3);\n-            world.setBlockState(corner1, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.SOUTH), world, corner1));\n-            world.setBlockState(corner2, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.EAST), world, corner2));\n-            world.setBlockState(corner3, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.WEST), world, corner3));\n-            world.setBlockState(corner4, BlockConstructionTape.getOptimalStateForPlacement(constructionTape.with(FACING, Direction.NORTH), world, corner4));\n+\n+            place = place.south().east();\n         }\n+\n+        working = firstValidPosition(new BlockPos(X+W, Y, Z+H), world);\n+        world.setBlockState(working,\n+                BlockConstructionTape.getPlacementState(constructionTape.with(CORNER, true), world, working, Direction.WEST)\n+        );\n     }\n \n     /**\n-     * Check if a block is placeable and return new Y position.\n+     * Find and return the highest position that is directly above a non-replaceable block.\n      *\n-     * @param x     Block X position.\n-     * @param y     Block Y position.\n-     * @param z     Block Z position.\n+     * @param target the target position for the block\n      * @param world the world.\n-     * @return The new Y position.\n+     * @return The new block position.\n      */\n-\n-    public static int checkIfPlaceable(@NotNull final int x, @NotNull final int y, @NotNull final int z, @NotNull final World world)\n+    public static BlockPos firstValidPosition(@NotNull BlockPos target, @NotNull World world)\n     {\n-        BlockPos target = new BlockPos(x,y,z);\n         final Chunk chunk = world.getChunkAt(target);\n \n-        target = new BlockPos(x, chunk.getTopFilledSegment() + 16, z);\n-        while(world.getBlockState(target).getMaterial().isReplaceable())\n+        target = new BlockPos(target.getX(), chunk.getTopFilledSegment() + 16, target.getZ());\n+                \n+        while (target.getY() > 0)\n         {\n             target = target.down();\n-            if (target.getY() == 0)\n-            {\n+            \n+            if (!world.getBlockState(target).getMaterial().isReplaceable() \n+             && !(world.getBlockState(target).getBlock() instanceof LeavesBlock)", "originalCommit": "00e0d0a5cbbf363dfa41178b1d4c6fc0525f477e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1MjU0Nw==", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446052547", "bodyText": "Not quite sure what you are getting at. The point of that line is so that overhanging trees are ignored. What do you mean?", "author": "ShadowProtocol", "createdAt": "2020-06-26T08:46:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0NjA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1NDEzMg==", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446054132", "bodyText": "There is a property on leaves if they are placed manually by the player or builder. Those should not be replaced.", "author": "Raycoms", "createdAt": "2020-06-26T08:49:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0NjA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA1NDk0Mg==", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446054942", "bodyText": "I would say no to all, unless you can find air block under a row of leaves only", "author": "Nightenom", "createdAt": "2020-06-26T08:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0NjA4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA4NTM2MA==", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446085360", "bodyText": "Now does a scan for air (or something properly replaceable) below.", "author": "ShadowProtocol", "createdAt": "2020-06-26T09:51:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0NjA4NQ=="}], "type": "inlineReview"}, {"oid": "798bcd6fd2560686d977f2630229e9b3b75c5240", "url": "https://github.com/ldtteam/minecolonies/commit/798bcd6fd2560686d977f2630229e9b3b75c5240", "message": "Avoid replacement of leaves\n\nUse a forward scan to check if there is something replaceable below leaves instead\nFix some capitalization", "committedDate": "2020-06-26T09:48:53Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA4NTQxMQ==", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446085411", "bodyText": "just the formatting is off here yet.", "author": "Raycoms", "createdAt": "2020-06-26T09:51:34Z", "path": "src/api/java/com/minecolonies/api/blocks/decorative/AbstractBlockMinecoloniesConstructionTape.java", "diffHunk": "@@ -1,107 +1,125 @@\n package com.minecolonies.api.blocks.decorative;\n \n import com.minecolonies.api.blocks.AbstractBlockMinecoloniesFalling;\n-import net.minecraft.block.HorizontalBlock;\n-import net.minecraft.block.material.MaterialColor;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import net.minecraft.block.*;\n+import net.minecraft.fluid.Fluids;\n+import net.minecraft.fluid.IFluidState;\n+import net.minecraft.state.BooleanProperty;\n import net.minecraft.state.DirectionProperty;\n-import net.minecraft.state.EnumProperty;\n-import net.minecraft.util.IStringSerializable;\n+import net.minecraft.state.properties.BlockStateProperties;\n+import net.minecraft.util.Direction;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.shapes.ISelectionContext;\n+import net.minecraft.util.math.shapes.VoxelShape;\n+import net.minecraft.util.math.shapes.VoxelShapes;\n+import net.minecraft.world.IBlockReader;\n import org.jetbrains.annotations.NotNull;\n \n-public abstract class AbstractBlockMinecoloniesConstructionTape<B extends AbstractBlockMinecoloniesConstructionTape<B>> extends AbstractBlockMinecoloniesFalling<B>\n+public abstract class AbstractBlockMinecoloniesConstructionTape<B extends AbstractBlockMinecoloniesConstructionTape<B>> extends AbstractBlockMinecoloniesFalling<B> implements IWaterLoggable\n {\n+    public static final BooleanProperty NORTH = SixWayBlock.NORTH;\n+    public static final BooleanProperty EAST = SixWayBlock.EAST;\n+    public static final BooleanProperty SOUTH = SixWayBlock.SOUTH;\n+    public static final BooleanProperty WEST = SixWayBlock.WEST;\n+    public static final BooleanProperty WATERLOGGED = BlockStateProperties.WATERLOGGED;\n+\n+    protected VoxelShape[] shapes = new VoxelShape[]{};\n+\n+    private final Object2IntMap<BlockState> stateShapeMap = new Object2IntOpenHashMap<>();\n+\n     /**\n-     * The variants of the shingle slab.\n+     * The default face for when there are no connections.\n      */\n-    public static final EnumProperty<ConstructionTapeType> VARIANT = EnumProperty.create(\"variant\", ConstructionTapeType.class);\n+    public static final DirectionProperty FACING = HorizontalBlock.HORIZONTAL_FACING;\n \n     /**\n-     * The position it faces.\n+     * Implies that the tape should revert to a corner if there are no connections. Must be set explicitly. For use by the builder handler.\n      */\n-    public static final DirectionProperty FACING = HorizontalBlock.HORIZONTAL_FACING;\n+    public static final BooleanProperty CORNER = BooleanProperty.create(\"corner\");\n \n     public AbstractBlockMinecoloniesConstructionTape(final Properties properties)\n     {\n         super(properties);\n     }\n \n-    /**\n-     * Types that the {@link AbstractBlockMinecoloniesConstructionTape} supports\n-     */\n-    public enum ConstructionTapeType implements IStringSerializable\n+    @NotNull\n+    @Override\n+    public VoxelShape getShape(BlockState state, IBlockReader worldIn, BlockPos pos, ISelectionContext context)\n     {\n-        STRAIGHT(0, \"straight\", MaterialColor.WOOD),\n-        CORNER(1, \"corner\", MaterialColor.OBSIDIAN);\n-\n-        private static final ConstructionTapeType[] META_LOOKUP = new ConstructionTapeType[values().length];\n-        static\n-        {\n-            for (final ConstructionTapeType enumtype : values())\n-            {\n-                META_LOOKUP[enumtype.getMetadata()] = enumtype;\n+        return this.shapes[this.getIndex(state)];\n+    }\n+\n+    private static int getMask(Direction facing) {\n+        return 1 << facing.getHorizontalIndex();\n+    }\n+\n+    protected int getIndex(BlockState state)\n+    {\n+        return this.stateShapeMap.computeIntIfAbsent(state, (p_223007_0_) -> {\n+            int i = 0;\n+            if (p_223007_0_.get(NORTH)) {\n+                i |= getMask(Direction.NORTH);\n             }\n-        }\n-        private final int           meta;\n-        private final String        name;\n-        private final String        unlocalizedName;\n-        /**\n-         * The color that represents this entry on a map.\n-         */\n-        private final MaterialColor mapColor;\n-\n-        ConstructionTapeType(final int metaIn, final String nameIn, final MaterialColor mapColorIn)\n-        {\n-            this(metaIn, nameIn, nameIn, mapColorIn);\n-        }\n \n-        ConstructionTapeType(final int metaIn, final String nameIn, final String unlocalizedNameIn, final MaterialColor mapColorIn)\n-        {\n-            this.meta = metaIn;\n-            this.name = nameIn;\n-            this.unlocalizedName = unlocalizedNameIn;\n-            this.mapColor = mapColorIn;\n-        }\n+            if (p_223007_0_.get(EAST)) {\n+                i |= getMask(Direction.EAST);\n+            }\n \n-        public static ConstructionTapeType byMetadata(final int meta)\n-        {\n-            int tempMeta = meta;\n-            if (tempMeta < 0 || tempMeta >= META_LOOKUP.length)\n-            {\n-                tempMeta = 0;\n+            if (p_223007_0_.get(SOUTH)) {", "originalCommit": "798bcd6fd2560686d977f2630229e9b3b75c5240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA4NTQ2Nw==", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446085467", "bodyText": "here too", "author": "Raycoms", "createdAt": "2020-06-26T09:51:43Z", "path": "src/api/java/com/minecolonies/api/blocks/decorative/AbstractBlockMinecoloniesConstructionTape.java", "diffHunk": "@@ -1,107 +1,125 @@\n package com.minecolonies.api.blocks.decorative;\n \n import com.minecolonies.api.blocks.AbstractBlockMinecoloniesFalling;\n-import net.minecraft.block.HorizontalBlock;\n-import net.minecraft.block.material.MaterialColor;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import net.minecraft.block.*;\n+import net.minecraft.fluid.Fluids;\n+import net.minecraft.fluid.IFluidState;\n+import net.minecraft.state.BooleanProperty;\n import net.minecraft.state.DirectionProperty;\n-import net.minecraft.state.EnumProperty;\n-import net.minecraft.util.IStringSerializable;\n+import net.minecraft.state.properties.BlockStateProperties;\n+import net.minecraft.util.Direction;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.shapes.ISelectionContext;\n+import net.minecraft.util.math.shapes.VoxelShape;\n+import net.minecraft.util.math.shapes.VoxelShapes;\n+import net.minecraft.world.IBlockReader;\n import org.jetbrains.annotations.NotNull;\n \n-public abstract class AbstractBlockMinecoloniesConstructionTape<B extends AbstractBlockMinecoloniesConstructionTape<B>> extends AbstractBlockMinecoloniesFalling<B>\n+public abstract class AbstractBlockMinecoloniesConstructionTape<B extends AbstractBlockMinecoloniesConstructionTape<B>> extends AbstractBlockMinecoloniesFalling<B> implements IWaterLoggable\n {\n+    public static final BooleanProperty NORTH = SixWayBlock.NORTH;\n+    public static final BooleanProperty EAST = SixWayBlock.EAST;\n+    public static final BooleanProperty SOUTH = SixWayBlock.SOUTH;\n+    public static final BooleanProperty WEST = SixWayBlock.WEST;\n+    public static final BooleanProperty WATERLOGGED = BlockStateProperties.WATERLOGGED;\n+\n+    protected VoxelShape[] shapes = new VoxelShape[]{};\n+\n+    private final Object2IntMap<BlockState> stateShapeMap = new Object2IntOpenHashMap<>();\n+\n     /**\n-     * The variants of the shingle slab.\n+     * The default face for when there are no connections.\n      */\n-    public static final EnumProperty<ConstructionTapeType> VARIANT = EnumProperty.create(\"variant\", ConstructionTapeType.class);\n+    public static final DirectionProperty FACING = HorizontalBlock.HORIZONTAL_FACING;\n \n     /**\n-     * The position it faces.\n+     * Implies that the tape should revert to a corner if there are no connections. Must be set explicitly. For use by the builder handler.\n      */\n-    public static final DirectionProperty FACING = HorizontalBlock.HORIZONTAL_FACING;\n+    public static final BooleanProperty CORNER = BooleanProperty.create(\"corner\");\n \n     public AbstractBlockMinecoloniesConstructionTape(final Properties properties)\n     {\n         super(properties);\n     }\n \n-    /**\n-     * Types that the {@link AbstractBlockMinecoloniesConstructionTape} supports\n-     */\n-    public enum ConstructionTapeType implements IStringSerializable\n+    @NotNull\n+    @Override\n+    public VoxelShape getShape(BlockState state, IBlockReader worldIn, BlockPos pos, ISelectionContext context)\n     {\n-        STRAIGHT(0, \"straight\", MaterialColor.WOOD),\n-        CORNER(1, \"corner\", MaterialColor.OBSIDIAN);\n-\n-        private static final ConstructionTapeType[] META_LOOKUP = new ConstructionTapeType[values().length];\n-        static\n-        {\n-            for (final ConstructionTapeType enumtype : values())\n-            {\n-                META_LOOKUP[enumtype.getMetadata()] = enumtype;\n+        return this.shapes[this.getIndex(state)];\n+    }\n+\n+    private static int getMask(Direction facing) {\n+        return 1 << facing.getHorizontalIndex();\n+    }\n+\n+    protected int getIndex(BlockState state)\n+    {\n+        return this.stateShapeMap.computeIntIfAbsent(state, (p_223007_0_) -> {\n+            int i = 0;\n+            if (p_223007_0_.get(NORTH)) {\n+                i |= getMask(Direction.NORTH);\n             }\n-        }\n-        private final int           meta;\n-        private final String        name;\n-        private final String        unlocalizedName;\n-        /**\n-         * The color that represents this entry on a map.\n-         */\n-        private final MaterialColor mapColor;\n-\n-        ConstructionTapeType(final int metaIn, final String nameIn, final MaterialColor mapColorIn)\n-        {\n-            this(metaIn, nameIn, nameIn, mapColorIn);\n-        }\n \n-        ConstructionTapeType(final int metaIn, final String nameIn, final String unlocalizedNameIn, final MaterialColor mapColorIn)\n-        {\n-            this.meta = metaIn;\n-            this.name = nameIn;\n-            this.unlocalizedName = unlocalizedNameIn;\n-            this.mapColor = mapColorIn;\n-        }\n+            if (p_223007_0_.get(EAST)) {\n+                i |= getMask(Direction.EAST);\n+            }\n \n-        public static ConstructionTapeType byMetadata(final int meta)\n-        {\n-            int tempMeta = meta;\n-            if (tempMeta < 0 || tempMeta >= META_LOOKUP.length)\n-            {\n-                tempMeta = 0;\n+            if (p_223007_0_.get(SOUTH)) {\n+                i |= getMask(Direction.SOUTH);\n             }\n \n-            return META_LOOKUP[tempMeta];\n-        }\n+            if (p_223007_0_.get(WEST)) {\n+                i |= getMask(Direction.WEST);\n+            }\n \n-        public int getMetadata()\n-        {\n-            return this.meta;\n-        }\n+            return i;\n+        });\n+    }\n \n-        /**\n-         * The color which represents this entry on a map.\n-         * @return the material color.\n-         */\n-        public MaterialColor getMaterialColor()\n-        {\n-            return this.mapColor;\n-        }\n+    @NotNull\n+    @Override\n+    public IFluidState getFluidState(BlockState state)\n+    {\n+        return state.get(WATERLOGGED) ? Fluids.WATER.getStillFluidState(false) : super.getFluidState(state);\n+    }\n \n-        @Override\n-        public String toString()\n-        {\n-            return this.name;\n-        }\n+    protected VoxelShape[] makeShapes(float nodeWidth, float limbWidth, float nodeHeight, float limbBase, float limbTop)\n+    {\n+        float nodeStart = 8.0F - nodeWidth;\n+        float nodeEnd = 8.0F + nodeWidth;\n+        float limbStart = 8.0F - limbWidth;\n+        float limbEnd = 8.0F + limbWidth;\n \n-        @NotNull\n-        public String getName()\n-        {\n-            return this.name;\n-        }\n+        VoxelShape node  = Block.makeCuboidShape(nodeStart, 0.0F,     nodeStart, nodeEnd, nodeHeight, nodeEnd);\n+        VoxelShape north = Block.makeCuboidShape(limbStart, limbBase, 0.0F,      limbEnd, limbTop, limbEnd);\n+        VoxelShape south = Block.makeCuboidShape(limbStart, limbBase, limbStart, limbEnd, limbTop, 16.0D);\n+        VoxelShape west  = Block.makeCuboidShape(0.0F,      limbBase, limbStart, limbEnd, limbTop, limbEnd);\n+        VoxelShape east  = Block.makeCuboidShape(limbStart, limbBase, limbStart, 16.0D,   limbTop, limbEnd);\n+        VoxelShape cornernw = VoxelShapes.or(north, east);\n+        VoxelShape cornerse = VoxelShapes.or(south, west);\n+\n+        // All 16 possible block combinations, in a specific index to be retrieved by getIndex\n+        VoxelShape[] avoxelshape = new VoxelShape[]{\n+                VoxelShapes.empty(),    south,   west, cornerse, north,\n+                VoxelShapes.or(south,   north),\n+                VoxelShapes.or(west,    north),\n+                VoxelShapes.or(cornerse,north),  east,\n+                VoxelShapes.or(south,   east),\n+                VoxelShapes.or(west,    east),\n+                VoxelShapes.or(cornerse,east),   cornernw,\n+                VoxelShapes.or(south,   cornernw),\n+                VoxelShapes.or(west,    cornernw),\n+                VoxelShapes.or(cornerse,cornernw)\n+        };\n \n-        public String getTranslationKey()\n-        {\n-            return this.unlocalizedName;\n+        // Combine the arm voxel shapes with the main node for all combinations\n+        for(int i = 0; i < 16; ++i) {\n+            avoxelshape[i] = VoxelShapes.or(node, avoxelshape[i]);", "originalCommit": "798bcd6fd2560686d977f2630229e9b3b75c5240", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b1cec33b8da6111ec6b4786fbb9c3f9cc9cc9000", "url": "https://github.com/ldtteam/minecolonies/commit/b1cec33b8da6111ec6b4786fbb9c3f9cc9cc9000", "message": "Fix formatting and naming", "committedDate": "2020-06-26T09:58:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUwMzU1MA==", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446503550", "bodyText": "format", "author": "Raycoms", "createdAt": "2020-06-27T08:59:06Z", "path": "src/api/java/com/minecolonies/api/blocks/decorative/AbstractBlockMinecoloniesConstructionTape.java", "diffHunk": "@@ -1,107 +1,121 @@\n package com.minecolonies.api.blocks.decorative;\n \n import com.minecolonies.api.blocks.AbstractBlockMinecoloniesFalling;\n-import net.minecraft.block.HorizontalBlock;\n-import net.minecraft.block.material.MaterialColor;\n+import it.unimi.dsi.fastutil.objects.Object2IntMap;\n+import it.unimi.dsi.fastutil.objects.Object2IntOpenHashMap;\n+import net.minecraft.block.*;\n+import net.minecraft.fluid.Fluids;\n+import net.minecraft.fluid.IFluidState;\n+import net.minecraft.state.BooleanProperty;\n import net.minecraft.state.DirectionProperty;\n-import net.minecraft.state.EnumProperty;\n-import net.minecraft.util.IStringSerializable;\n+import net.minecraft.state.properties.BlockStateProperties;\n+import net.minecraft.util.Direction;\n+import net.minecraft.util.math.BlockPos;\n+import net.minecraft.util.math.shapes.ISelectionContext;\n+import net.minecraft.util.math.shapes.VoxelShape;\n+import net.minecraft.util.math.shapes.VoxelShapes;\n+import net.minecraft.world.IBlockReader;\n import org.jetbrains.annotations.NotNull;\n \n-public abstract class AbstractBlockMinecoloniesConstructionTape<B extends AbstractBlockMinecoloniesConstructionTape<B>> extends AbstractBlockMinecoloniesFalling<B>\n+public abstract class AbstractBlockMinecoloniesConstructionTape<B extends AbstractBlockMinecoloniesConstructionTape<B>> extends AbstractBlockMinecoloniesFalling<B> implements IWaterLoggable\n {\n+    public static final BooleanProperty NORTH = SixWayBlock.NORTH;\n+    public static final BooleanProperty EAST = SixWayBlock.EAST;\n+    public static final BooleanProperty SOUTH = SixWayBlock.SOUTH;\n+    public static final BooleanProperty WEST = SixWayBlock.WEST;\n+    public static final BooleanProperty WATERLOGGED = BlockStateProperties.WATERLOGGED;\n+\n+    protected VoxelShape[] shapes = new VoxelShape[]{};\n+\n+    private final Object2IntMap<BlockState> stateShapeMap = new Object2IntOpenHashMap<>();\n+\n     /**\n-     * The variants of the shingle slab.\n+     * The default face for when there are no connections.\n      */\n-    public static final EnumProperty<ConstructionTapeType> VARIANT = EnumProperty.create(\"variant\", ConstructionTapeType.class);\n+    public static final DirectionProperty FACING = HorizontalBlock.HORIZONTAL_FACING;\n \n     /**\n-     * The position it faces.\n+     * Implies that the tape should revert to a corner if there are no connections. Must be set explicitly. For use by the builder handler.\n      */\n-    public static final DirectionProperty FACING = HorizontalBlock.HORIZONTAL_FACING;\n+    public static final BooleanProperty CORNER = BooleanProperty.create(\"corner\");\n \n     public AbstractBlockMinecoloniesConstructionTape(final Properties properties)\n     {\n         super(properties);\n     }\n \n-    /**\n-     * Types that the {@link AbstractBlockMinecoloniesConstructionTape} supports\n-     */\n-    public enum ConstructionTapeType implements IStringSerializable\n+    @NotNull\n+    @Override\n+    public VoxelShape getShape(BlockState state, IBlockReader worldIn, BlockPos pos, ISelectionContext context)\n     {\n-        STRAIGHT(0, \"straight\", MaterialColor.WOOD),\n-        CORNER(1, \"corner\", MaterialColor.OBSIDIAN);\n+        return this.shapes[this.getIndex(state)];\n+    }\n \n-        private static final ConstructionTapeType[] META_LOOKUP = new ConstructionTapeType[values().length];\n-        static\n-        {\n-            for (final ConstructionTapeType enumtype : values())\n-            {\n-                META_LOOKUP[enumtype.getMetadata()] = enumtype;\n-            }\n-        }\n-        private final int           meta;\n-        private final String        name;\n-        private final String        unlocalizedName;\n-        /**\n-         * The color that represents this entry on a map.\n-         */\n-        private final MaterialColor mapColor;\n-\n-        ConstructionTapeType(final int metaIn, final String nameIn, final MaterialColor mapColorIn)\n-        {\n-            this(metaIn, nameIn, nameIn, mapColorIn);\n-        }\n+    private static int getMask(Direction facing) {", "originalCommit": "b1cec33b8da6111ec6b4786fbb9c3f9cc9cc9000", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUwNjMwOA==", "url": "https://github.com/ldtteam/minecolonies/pull/5298#discussion_r446506308", "bodyText": "I'll activate the IDE file formatter with the right settings now... although I don't know how I missed that many. I did try.", "author": "ShadowProtocol", "createdAt": "2020-06-27T09:35:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjUwMzU1MA=="}], "type": "inlineReview"}, {"oid": "fa1af9d47b1d78ea63c69ed7a82e84928c99316d", "url": "https://github.com/ldtteam/minecolonies/commit/fa1af9d47b1d78ea63c69ed7a82e84928c99316d", "message": "Fix formatting", "committedDate": "2020-06-27T09:31:02Z", "type": "commit"}]}