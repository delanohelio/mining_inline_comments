{"pr_number": 735, "pr_title": "Implemented private log filter JSON-RPC methods", "pr_createdAt": "2020-04-17T05:32:04Z", "pr_url": "https://github.com/hyperledger/besu/pull/735", "timeline": [{"oid": "305e5450d05ddfd37d89e51ba4ebb17e939ccd2e", "url": "https://github.com/hyperledger/besu/commit/305e5450d05ddfd37d89e51ba4ebb17e939ccd2e", "message": "[#627] Implemented private log filter JSON-RPC methods\n\nSigned-off-by: Lucas Saldanha <lucas.saldanha@consensys.net>", "committedDate": "2020-04-17T05:47:30Z", "type": "forcePushed"}, {"oid": "705af0215441571122cc95cb5295a21fc1a54a67", "url": "https://github.com/hyperledger/besu/commit/705af0215441571122cc95cb5295a21fc1a54a67", "message": "[#627] Implemented private log filter JSON-RPC methods\n\nSigned-off-by: Lucas Saldanha <lucas.saldanha@consensys.net>", "committedDate": "2020-04-17T06:13:52Z", "type": "commit"}, {"oid": "705af0215441571122cc95cb5295a21fc1a54a67", "url": "https://github.com/hyperledger/besu/commit/705af0215441571122cc95cb5295a21fc1a54a67", "message": "[#627] Implemented private log filter JSON-RPC methods\n\nSigned-off-by: Lucas Saldanha <lucas.saldanha@consensys.net>", "committedDate": "2020-04-17T06:13:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAxMjgxNA==", "url": "https://github.com/hyperledger/besu/pull/735#discussion_r410012814", "bodyText": "I renamed this method to clarify that we will only be looking for new logs here.  The fromBlockNumber is set to the head of the chain.", "author": "lucassaldanha", "createdAt": "2020-04-17T06:16:01Z", "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/filter/FilterManager.java", "diffHunk": "@@ -162,35 +162,17 @@ public void recordBlockEvent(final BlockAddedEvent event, final Blockchain block\n           }\n         });\n \n-    checkBlockchainForMatchingLogsForFilters();\n+    filterRepository.getFiltersOfType(LogFilter.class).forEach(this::addNewMatchingLogs);\n   }\n \n-  private void checkBlockchainForMatchingLogsForFilters() {\n-    filterRepository.getFiltersOfType(LogFilter.class).forEach(this::addMatchingLogs);\n-  }\n-\n-  private void addMatchingLogs(final LogFilter filter) {\n-    final long headBlockNumber = blockchainQueries.headBlockNumber();\n+  private void addNewMatchingLogs(final LogFilter filter) {", "originalCommit": "705af0215441571122cc95cb5295a21fc1a54a67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAxMzM1MQ==", "url": "https://github.com/hyperledger/besu/pull/735#discussion_r410013351", "bodyText": "This method was introduced to avoid duplication. It is used by two methods in this class.", "author": "lucassaldanha", "createdAt": "2020-04-17T06:17:48Z", "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/filter/FilterManager.java", "diffHunk": "@@ -280,6 +262,23 @@ void recordPendingTransactionEvent(final Transaction transaction) {\n     final long toBlockNumber =\n         filter.getToBlock().getNumber().orElse(blockchainQueries.headBlockNumber());\n \n-    return blockchainQueries.matchingLogs(fromBlockNumber, toBlockNumber, filter.getLogsQuery());\n+    return findLogsWithinRange(filter, fromBlockNumber, toBlockNumber);\n+  }\n+\n+  private List<LogWithMetadata> findLogsWithinRange(", "originalCommit": "705af0215441571122cc95cb5295a21fc1a54a67", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "30523690b314675521316048579400718ec0bfda", "url": "https://github.com/hyperledger/besu/commit/30523690b314675521316048579400718ec0bfda", "message": "Merge branch 'master' into priv_filter_methods", "committedDate": "2020-04-19T20:18:42Z", "type": "commit"}, {"oid": "7d6d5b47cf6c0b84ef43c7af0db4197ccf7bb9f3", "url": "https://github.com/hyperledger/besu/commit/7d6d5b47cf6c0b84ef43c7af0db4197ccf7bb9f3", "message": "Merge branch 'master' into priv_filter_methods", "committedDate": "2020-04-19T23:41:30Z", "type": "commit"}, {"oid": "697cf4b26a3de6185e2e91c8c8982f9ccb67ae5d", "url": "https://github.com/hyperledger/besu/commit/697cf4b26a3de6185e2e91c8c8982f9ccb67ae5d", "message": "Merge branch 'master' into priv_filter_methods", "committedDate": "2020-04-20T02:20:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEyMDI5Mw==", "url": "https://github.com/hyperledger/besu/pull/735#discussion_r411120293", "bodyText": "In the PrivGetFilterChanges response method you did add a comment here ...", "author": "pinges", "createdAt": "2020-04-20T06:18:47Z", "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/PrivGetFilterLogs.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.api.jsonrpc.internal.privacy.methods;\n+\n+import org.hyperledger.besu.ethereum.api.jsonrpc.RpcMethod;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequestContext;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.filter.FilterManager;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.JsonRpcMethod;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcError;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcErrorResponse;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcResponse;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcSuccessResponse;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.results.LogsResult;\n+import org.hyperledger.besu.ethereum.core.LogWithMetadata;\n+import org.hyperledger.besu.ethereum.privacy.PrivacyController;\n+\n+import java.util.List;\n+\n+public class PrivGetFilterLogs implements JsonRpcMethod {\n+\n+  private final PrivacyController privacyController;\n+  private final EnclavePublicKeyProvider enclavePublicKeyProvider;\n+  private final FilterManager filterManager;\n+\n+  public PrivGetFilterLogs(\n+      final FilterManager filterManager,\n+      final PrivacyController privacyController,\n+      final EnclavePublicKeyProvider enclavePublicKeyProvider) {\n+    this.filterManager = filterManager;\n+    this.privacyController = privacyController;\n+    this.enclavePublicKeyProvider = enclavePublicKeyProvider;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return RpcMethod.PRIV_GET_FILTER_LOGS.getMethodName();\n+  }\n+\n+  @Override\n+  public JsonRpcResponse response(final JsonRpcRequestContext request) {\n+    final String privacyGroupId = request.getRequiredParameter(0, String.class);\n+    final String filterId = request.getRequiredParameter(1, String.class);\n+\n+    checkIfPrivacyGroupMatchesAuthenticatedEnclaveKey(request, privacyGroupId);\n+\n+    final List<LogWithMetadata> logs = filterManager.logs(filterId);\n+    if (logs != null) {\n+      return new JsonRpcSuccessResponse(request.getRequest().getId(), new LogsResult(logs));\n+    }\n+", "originalCommit": "697cf4b26a3de6185e2e91c8c8982f9ccb67ae5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTE0MDE5Mg==", "url": "https://github.com/hyperledger/besu/pull/735#discussion_r411140192", "bodyText": "I'll remove the comment from the other one then :)\nI think the error msg enum already gives a good hint of the response.", "author": "lucassaldanha", "createdAt": "2020-04-20T07:01:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEyMDI5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEzMTQxNQ==", "url": "https://github.com/hyperledger/besu/pull/735#discussion_r411131415", "bodyText": "Most of the other exceptions you are checking the message as well ...", "author": "pinges", "createdAt": "2020-04-20T06:44:16Z", "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/priv/PrivGetFilterLogsTest.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.api.jsonrpc.internal.privacy.methods.priv;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequest;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequestContext;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.exception.InvalidJsonRpcParameters;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.filter.FilterManager;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.privacy.methods.EnclavePublicKeyProvider;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.privacy.methods.PrivGetFilterLogs;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcError;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcErrorResponse;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcResponse;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcSuccessResponse;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.results.LogsResult;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.LogWithMetadata;\n+import org.hyperledger.besu.ethereum.privacy.MultiTenancyValidationException;\n+import org.hyperledger.besu.ethereum.privacy.PrivacyController;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import com.google.common.collect.Lists;\n+import io.vertx.ext.auth.User;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class PrivGetFilterLogsTest {\n+\n+  private final String FILTER_ID = \"0xdbdb02abb65a2ba57a1cc0336c17ef75\";\n+  private final String ENCLAVE_KEY = \"enclave_key\";\n+  private final String PRIVACY_GROUP_ID = \"B1aVtMxLCUHmBVHXoZzzBgPbW/wj5axDpW9X8l91SGo=\";\n+\n+  @Mock private FilterManager filterManager;\n+  @Mock private PrivacyController privacyController;\n+  @Mock private EnclavePublicKeyProvider enclavePublicKeyProvider;\n+\n+  private PrivGetFilterLogs method;\n+\n+  @Before\n+  public void before() {\n+    method = new PrivGetFilterLogs(filterManager, privacyController, enclavePublicKeyProvider);\n+  }\n+\n+  @Test\n+  public void getMethodReturnsCorrectMethodName() {\n+    assertThat(method.getName()).isEqualTo(\"priv_getFilterLogs\");\n+  }\n+\n+  @Test\n+  public void privacyGroupIdIsRequired() {\n+    final JsonRpcRequestContext request = privGetFilterLogsRequest(null, \"0x1\");\n+\n+    assertThatThrownBy(() -> method.response(request))\n+        .isInstanceOf(InvalidJsonRpcParameters.class)\n+        .hasMessageContaining(\"Missing required json rpc parameter at index 0\");\n+  }\n+\n+  @Test\n+  public void filterIdIsRequired() {\n+    final JsonRpcRequestContext request = privGetFilterLogsRequest(PRIVACY_GROUP_ID, null);\n+\n+    assertThatThrownBy(() -> method.response(request))\n+        .isInstanceOf(InvalidJsonRpcParameters.class)\n+        .hasMessageContaining(\"Missing required json rpc parameter at index 1\");\n+  }\n+\n+  @Test\n+  public void correctFilterIsQueried() {\n+    final JsonRpcRequestContext request = privGetFilterLogsRequest(PRIVACY_GROUP_ID, FILTER_ID);\n+    method.response(request);\n+\n+    verify(filterManager).logs(eq(FILTER_ID));\n+  }\n+\n+  @Test\n+  public void returnExpectedLogs() {\n+    final LogWithMetadata logWithMetadata = logWithMetadata();\n+    when(filterManager.logs(eq(FILTER_ID))).thenReturn(List.of(logWithMetadata));\n+\n+    final JsonRpcResponse expectedResponse =\n+        new JsonRpcSuccessResponse(null, new LogsResult(List.of(logWithMetadata)));\n+\n+    final JsonRpcRequestContext request = privGetFilterLogsRequest(PRIVACY_GROUP_ID, FILTER_ID);\n+    final JsonRpcResponse response = method.response(request);\n+\n+    assertThat(response).usingRecursiveComparison().isEqualTo(expectedResponse);\n+  }\n+\n+  @Test\n+  public void returnEmptyListWhenLogsReturnEmpty() {\n+    when(filterManager.logs(eq(FILTER_ID))).thenReturn(Collections.emptyList());\n+\n+    final JsonRpcResponse expectedResponse =\n+        new JsonRpcSuccessResponse(null, new LogsResult(Collections.emptyList()));\n+\n+    final JsonRpcRequestContext request = privGetFilterLogsRequest(PRIVACY_GROUP_ID, FILTER_ID);\n+    final JsonRpcResponse response = method.response(request);\n+\n+    assertThat(response).usingRecursiveComparison().isEqualTo(expectedResponse);\n+  }\n+\n+  @Test\n+  public void returnFilterNotFoundWhenLogsReturnIsNull() {\n+    when(filterManager.logs(eq(FILTER_ID))).thenReturn(null);\n+\n+    final JsonRpcResponse expectedResponse =\n+        new JsonRpcErrorResponse(null, JsonRpcError.LOGS_FILTER_NOT_FOUND);\n+\n+    final JsonRpcRequestContext request = privGetFilterLogsRequest(PRIVACY_GROUP_ID, FILTER_ID);\n+    final JsonRpcResponse response = method.response(request);\n+\n+    assertThat(response).isEqualTo(expectedResponse);\n+  }\n+\n+  @Test\n+  public void multiTenancyCheckFailure() {\n+    final User user = mock(User.class);\n+\n+    when(enclavePublicKeyProvider.getEnclaveKey(any())).thenReturn(ENCLAVE_KEY);\n+    doThrow(new MultiTenancyValidationException(\"msg\"))\n+        .when(privacyController)\n+        .verifyPrivacyGroupContainsEnclavePublicKey(eq(PRIVACY_GROUP_ID), eq(ENCLAVE_KEY));\n+\n+    final JsonRpcRequestContext request =\n+        privGetFilterLogsRequestWithUser(PRIVACY_GROUP_ID, FILTER_ID, user);\n+\n+    assertThatThrownBy(() -> method.response(request))\n+        .isInstanceOf(MultiTenancyValidationException.class);", "originalCommit": "697cf4b26a3de6185e2e91c8c8982f9ccb67ae5d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEzMTU1Mg==", "url": "https://github.com/hyperledger/besu/pull/735#discussion_r411131552", "bodyText": "Most of the other exceptions you are checking the message as well ...", "author": "pinges", "createdAt": "2020-04-20T06:44:35Z", "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/priv/PrivGetFilterChangesTest.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.api.jsonrpc.internal.privacy.methods.priv;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequest;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequestContext;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.exception.InvalidJsonRpcParameters;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.filter.FilterManager;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.privacy.methods.EnclavePublicKeyProvider;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.privacy.methods.PrivGetFilterChanges;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcError;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcErrorResponse;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcResponse;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcSuccessResponse;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.results.LogsResult;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.LogWithMetadata;\n+import org.hyperledger.besu.ethereum.privacy.MultiTenancyValidationException;\n+import org.hyperledger.besu.ethereum.privacy.PrivacyController;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import com.google.common.collect.Lists;\n+import io.vertx.ext.auth.User;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class PrivGetFilterChangesTest {\n+\n+  private final String FILTER_ID = \"0xdbdb02abb65a2ba57a1cc0336c17ef75\";\n+  private final String ENCLAVE_KEY = \"enclave_key\";\n+  private final String PRIVACY_GROUP_ID = \"B1aVtMxLCUHmBVHXoZzzBgPbW/wj5axDpW9X8l91SGo=\";\n+\n+  @Mock private FilterManager filterManager;\n+  @Mock private PrivacyController privacyController;\n+  @Mock private EnclavePublicKeyProvider enclavePublicKeyProvider;\n+\n+  private PrivGetFilterChanges method;\n+\n+  @Before\n+  public void before() {\n+    method = new PrivGetFilterChanges(filterManager, privacyController, enclavePublicKeyProvider);\n+  }\n+\n+  @Test\n+  public void getMethodReturnsCorrectMethodName() {\n+    assertThat(method.getName()).isEqualTo(\"priv_getFilterChanges\");\n+  }\n+\n+  @Test\n+  public void privacyGroupIdIsRequired() {\n+    final JsonRpcRequestContext request = privGetFilterChangesRequest(null, \"0x1\");\n+\n+    assertThatThrownBy(() -> method.response(request))\n+        .isInstanceOf(InvalidJsonRpcParameters.class)\n+        .hasMessageContaining(\"Missing required json rpc parameter at index 0\");\n+  }\n+\n+  @Test\n+  public void filterIdIsRequired() {\n+    final JsonRpcRequestContext request = privGetFilterChangesRequest(PRIVACY_GROUP_ID, null);\n+\n+    assertThatThrownBy(() -> method.response(request))\n+        .isInstanceOf(InvalidJsonRpcParameters.class)\n+        .hasMessageContaining(\"Missing required json rpc parameter at index 1\");\n+  }\n+\n+  @Test\n+  public void correctFilterIsQueried() {\n+    final JsonRpcRequestContext request = privGetFilterChangesRequest(PRIVACY_GROUP_ID, FILTER_ID);\n+    method.response(request);\n+\n+    verify(filterManager).logsChanges(eq(FILTER_ID));\n+  }\n+\n+  @Test\n+  public void returnExpectedLogs() {\n+    final LogWithMetadata logWithMetadata = logWithMetadata();\n+    when(filterManager.logsChanges(eq(FILTER_ID))).thenReturn(List.of(logWithMetadata));\n+\n+    final JsonRpcResponse expectedResponse =\n+        new JsonRpcSuccessResponse(null, new LogsResult(List.of(logWithMetadata)));\n+\n+    final JsonRpcRequestContext request = privGetFilterChangesRequest(PRIVACY_GROUP_ID, FILTER_ID);\n+    final JsonRpcResponse response = method.response(request);\n+\n+    assertThat(response).usingRecursiveComparison().isEqualTo(expectedResponse);\n+  }\n+\n+  @Test\n+  public void returnEmptyListWhenLogsReturnEmpty() {\n+    when(filterManager.logsChanges(eq(FILTER_ID))).thenReturn(Collections.emptyList());\n+\n+    final JsonRpcResponse expectedResponse =\n+        new JsonRpcSuccessResponse(null, new LogsResult(Collections.emptyList()));\n+\n+    final JsonRpcRequestContext request = privGetFilterChangesRequest(PRIVACY_GROUP_ID, FILTER_ID);\n+    final JsonRpcResponse response = method.response(request);\n+\n+    assertThat(response).usingRecursiveComparison().isEqualTo(expectedResponse);\n+  }\n+\n+  @Test\n+  public void returnFilterNotFoundWhenLogsReturnIsNull() {\n+    when(filterManager.logsChanges(eq(FILTER_ID))).thenReturn(null);\n+\n+    final JsonRpcResponse expectedResponse =\n+        new JsonRpcErrorResponse(null, JsonRpcError.FILTER_NOT_FOUND);\n+\n+    final JsonRpcRequestContext request = privGetFilterChangesRequest(PRIVACY_GROUP_ID, FILTER_ID);\n+    final JsonRpcResponse response = method.response(request);\n+\n+    assertThat(response).isEqualTo(expectedResponse);\n+  }\n+\n+  @Test\n+  public void multiTenancyCheckFailure() {\n+    final User user = mock(User.class);\n+\n+    when(enclavePublicKeyProvider.getEnclaveKey(any())).thenReturn(ENCLAVE_KEY);\n+    doThrow(new MultiTenancyValidationException(\"msg\"))\n+        .when(privacyController)\n+        .verifyPrivacyGroupContainsEnclavePublicKey(eq(PRIVACY_GROUP_ID), eq(ENCLAVE_KEY));\n+\n+    final JsonRpcRequestContext request =\n+        privGetFilterChangesRequestWithUser(PRIVACY_GROUP_ID, FILTER_ID, user);\n+\n+    assertThatThrownBy(() -> method.response(request))\n+        .isInstanceOf(MultiTenancyValidationException.class);", "originalCommit": "697cf4b26a3de6185e2e91c8c8982f9ccb67ae5d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEzMjQwNg==", "url": "https://github.com/hyperledger/besu/pull/735#discussion_r411132406", "bodyText": "check the message?", "author": "pinges", "createdAt": "2020-04-20T06:46:14Z", "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/priv/PrivNewFilterTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.api.jsonrpc.internal.privacy.methods.priv;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.ArgumentMatchers.refEq;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequest;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequestContext;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.exception.InvalidJsonRpcParameters;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.filter.FilterManager;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.parameters.BlockParameter;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.parameters.FilterParameter;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.privacy.methods.EnclavePublicKeyProvider;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcError;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcErrorResponse;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcResponse;\n+import org.hyperledger.besu.ethereum.api.query.LogsQuery;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.LogTopic;\n+import org.hyperledger.besu.ethereum.privacy.MultiTenancyValidationException;\n+import org.hyperledger.besu.ethereum.privacy.PrivacyController;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import io.vertx.ext.auth.User;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class PrivNewFilterTest {\n+\n+  private final String ENCLAVE_KEY = \"enclave_key\";\n+  private final String PRIVACY_GROUP_ID = \"B1aVtMxLCUHmBVHXoZzzBgPbW/wj5axDpW9X8l91SGo=\";\n+\n+  @Mock private FilterManager filterManager;\n+  @Mock private PrivacyController privacyController;\n+  @Mock private EnclavePublicKeyProvider enclavePublicKeyProvider;\n+\n+  private PrivNewFilter method;\n+\n+  @Before\n+  public void before() {\n+    method = new PrivNewFilter(filterManager, privacyController, enclavePublicKeyProvider);\n+  }\n+\n+  @Test\n+  public void getMethodReturnsCorrectMethodName() {\n+    assertThat(method.getName()).isEqualTo(\"priv_newFilter\");\n+  }\n+\n+  @Test\n+  public void privacyGroupIdIsRequired() {\n+    final JsonRpcRequestContext request = privNewFilterRequest(null, mock(FilterParameter.class));\n+\n+    assertThatThrownBy(() -> method.response(request))\n+        .isInstanceOf(InvalidJsonRpcParameters.class)\n+        .hasMessageContaining(\"Missing required json rpc parameter at index 0\");\n+  }\n+\n+  @Test\n+  public void filterParameterIsRequired() {\n+    final JsonRpcRequestContext request = privNewFilterRequest(PRIVACY_GROUP_ID, null);\n+\n+    assertThatThrownBy(() -> method.response(request))\n+        .isInstanceOf(InvalidJsonRpcParameters.class)\n+        .hasMessageContaining(\"Missing required json rpc parameter at index 1\");\n+  }\n+\n+  @Test\n+  public void filterWithInvalidParameters() {\n+    final FilterParameter invalidFilter =\n+        new FilterParameter(\n+            \"earliest\",\n+            \"earliest\",\n+            Collections.emptyList(),\n+            Collections.emptyList(),\n+            Hash.ZERO.toHexString());\n+\n+    final JsonRpcRequestContext request = privNewFilterRequest(PRIVACY_GROUP_ID, invalidFilter);\n+\n+    final JsonRpcResponse expectedResponse =\n+        new JsonRpcErrorResponse(null, JsonRpcError.INVALID_PARAMS);\n+\n+    final JsonRpcResponse response = method.response(request);\n+\n+    assertThat(response).usingRecursiveComparison().isEqualTo(expectedResponse);\n+  }\n+\n+  @Test\n+  public void filterWithExpectedQueryIsCreated() {\n+    final BlockParameter fromBlock = new BlockParameter(\"earliest\");\n+    final BlockParameter toBlock = new BlockParameter(\"latest\");\n+    final List<Address> addresses = List.of(Address.ZERO);\n+    final List<List<LogTopic>> logTopics = List.of(List.of(LogTopic.of(Bytes32.random())));\n+\n+    final FilterParameter filter =\n+        new FilterParameter(\"earliest\", \"latest\", addresses, logTopics, null);\n+\n+    final LogsQuery expectedQuery =\n+        new LogsQuery.Builder().addresses(addresses).topics(logTopics).build();\n+\n+    final JsonRpcRequestContext request = privNewFilterRequest(PRIVACY_GROUP_ID, filter);\n+    method.response(request);\n+\n+    verify(filterManager)\n+        .installPrivateLogFilter(\n+            eq(PRIVACY_GROUP_ID), refEq(fromBlock), refEq(toBlock), eq((expectedQuery)));\n+  }\n+\n+  @Test\n+  public void multiTenancyCheckFailure() {\n+    final User user = mock(User.class);\n+    final FilterParameter filterParameter = mock(FilterParameter.class);\n+\n+    when(enclavePublicKeyProvider.getEnclaveKey(any())).thenReturn(ENCLAVE_KEY);\n+    doThrow(new MultiTenancyValidationException(\"msg\"))\n+        .when(privacyController)\n+        .verifyPrivacyGroupContainsEnclavePublicKey(eq(PRIVACY_GROUP_ID), eq(ENCLAVE_KEY));\n+\n+    final JsonRpcRequestContext request =\n+        privNewFilterRequestWithUser(PRIVACY_GROUP_ID, filterParameter, user);\n+\n+    assertThatThrownBy(() -> method.response(request))\n+        .isInstanceOf(MultiTenancyValidationException.class);\n+  }", "originalCommit": "697cf4b26a3de6185e2e91c8c8982f9ccb67ae5d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTEzMjg4OA==", "url": "https://github.com/hyperledger/besu/pull/735#discussion_r411132888", "bodyText": "check message?", "author": "pinges", "createdAt": "2020-04-20T06:47:18Z", "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/priv/PrivUninstallFilterTest.java", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.api.jsonrpc.internal.privacy.methods.priv;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequest;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequestContext;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.exception.InvalidJsonRpcParameters;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.filter.FilterManager;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.privacy.methods.EnclavePublicKeyProvider;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.privacy.methods.PrivUninstallFilter;\n+import org.hyperledger.besu.ethereum.privacy.MultiTenancyValidationException;\n+import org.hyperledger.besu.ethereum.privacy.PrivacyController;\n+\n+import io.vertx.ext.auth.User;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.Mock;\n+import org.mockito.junit.MockitoJUnitRunner;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class PrivUninstallFilterTest {\n+\n+  private final String FILTER_ID = \"0xdbdb02abb65a2ba57a1cc0336c17ef75\";\n+  private final String ENCLAVE_KEY = \"enclave_key\";\n+  private final String PRIVACY_GROUP_ID = \"B1aVtMxLCUHmBVHXoZzzBgPbW/wj5axDpW9X8l91SGo=\";\n+\n+  @Mock private FilterManager filterManager;\n+  @Mock private PrivacyController privacyController;\n+  @Mock private EnclavePublicKeyProvider enclavePublicKeyProvider;\n+\n+  private PrivUninstallFilter method;\n+\n+  @Before\n+  public void before() {\n+    method = new PrivUninstallFilter(filterManager, privacyController, enclavePublicKeyProvider);\n+  }\n+\n+  @Test\n+  public void getMethodReturnsCorrectMethodName() {\n+    assertThat(method.getName()).isEqualTo(\"priv_uninstallFilter\");\n+  }\n+\n+  @Test\n+  public void privacyGroupIdIsRequired() {\n+    final JsonRpcRequestContext request = privUninstallFilterRequest(null, \"0x1\");\n+\n+    assertThatThrownBy(() -> method.response(request))\n+        .isInstanceOf(InvalidJsonRpcParameters.class)\n+        .hasMessageContaining(\"Missing required json rpc parameter at index 0\");\n+  }\n+\n+  @Test\n+  public void filterIdIsRequired() {\n+    final JsonRpcRequestContext request = privUninstallFilterRequest(PRIVACY_GROUP_ID, null);\n+\n+    assertThatThrownBy(() -> method.response(request))\n+        .isInstanceOf(InvalidJsonRpcParameters.class)\n+        .hasMessageContaining(\"Missing required json rpc parameter at index 1\");\n+  }\n+\n+  @Test\n+  public void correctFilterIsUninstalled() {\n+    final JsonRpcRequestContext request = privUninstallFilterRequest(PRIVACY_GROUP_ID, FILTER_ID);\n+    method.response(request);\n+\n+    verify(filterManager).uninstallFilter(eq(FILTER_ID));\n+  }\n+\n+  @Test\n+  public void multiTenancyCheckFailure() {\n+    final User user = mock(User.class);\n+\n+    when(enclavePublicKeyProvider.getEnclaveKey(any())).thenReturn(ENCLAVE_KEY);\n+    doThrow(new MultiTenancyValidationException(\"msg\"))\n+        .when(privacyController)\n+        .verifyPrivacyGroupContainsEnclavePublicKey(eq(PRIVACY_GROUP_ID), eq(ENCLAVE_KEY));\n+\n+    final JsonRpcRequestContext request =\n+        privUninstallFilterRequestWithUser(PRIVACY_GROUP_ID, FILTER_ID, user);\n+\n+    assertThatThrownBy(() -> method.response(request))\n+        .isInstanceOf(MultiTenancyValidationException.class);\n+  }", "originalCommit": "697cf4b26a3de6185e2e91c8c8982f9ccb67ae5d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "25ea49f7574088bff1f13cb8a961506c3e5a893a", "url": "https://github.com/hyperledger/besu/commit/25ea49f7574088bff1f13cb8a961506c3e5a893a", "message": "PR comments\n\nSigned-off-by: Lucas Saldanha <lucas.saldanha@consensys.net>", "committedDate": "2020-04-20T07:05:23Z", "type": "commit"}]}