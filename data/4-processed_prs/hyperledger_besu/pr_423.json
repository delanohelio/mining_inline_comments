{"pr_number": 423, "pr_title": "[BESU-202] onchain privacy group management", "pr_createdAt": "2020-02-20T18:48:00Z", "pr_url": "https://github.com/hyperledger/besu/pull/423", "timeline": [{"oid": "f7d03aa2e3919092525a4a7a1eabca7944b9c454", "url": "https://github.com/hyperledger/besu/commit/f7d03aa2e3919092525a4a7a1eabca7944b9c454", "message": "on-chain-privacy-groups\n\n# Conflicts:\n#\tacceptance-tests/dsl/src/main/java/org/hyperledger/besu/tests/acceptance/dsl/transaction/privacy/PrivacyRequestFactory.java\n#\tacceptance-tests/tests/src/test/java/org/hyperledger/besu/tests/web3j/privacy/PrivCallAcceptanceTest.java\n#\tethereum/api/src/integration-test/java/org/hyperledger/besu/ethereum/api/jsonrpc/methods/PrivGetPrivateTransactionIntegrationTest.java\n#\tethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/eea/EeaSendRawTransaction.java\n#\tethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/priv/PrivFindPrivacyGroup.java\n#\tethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/priv/PrivGetTransactionReceipt.java\n#\tethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/methods/PrivJsonRpcMethods.java\n#\tethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/methods/PrivacyApiGroupJsonRpcMethods.java\n#\tethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/eea/EeaSendRawTransactionTest.java\n#\tethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/methods/PrivacyApiGroupJsonRpcMethodsTest.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/PrivacyBlockProcessor.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/ProtocolSpecBuilder.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivacyController.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivateTransactionSimulator.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/storage/PrivateStateKeyValueStorage.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/storage/PrivateStateStorage.java\n#\tethereum/core/src/test/java/org/hyperledger/besu/ethereum/privacy/DefaultPrivacyControllerTest.java\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>", "committedDate": "2020-02-20T18:48:59Z", "type": "forcePushed"}, {"oid": "2052bf62176c5441ff263ea301e4fb0f41701bd1", "url": "https://github.com/hyperledger/besu/commit/2052bf62176c5441ff263ea301e4fb0f41701bd1", "message": "on-chain-privacy-groups\n\n# Conflicts:\n#\tacceptance-tests/dsl/src/main/java/org/hyperledger/besu/tests/acceptance/dsl/transaction/privacy/PrivacyRequestFactory.java\n#\tacceptance-tests/tests/src/test/java/org/hyperledger/besu/tests/web3j/privacy/PrivCallAcceptanceTest.java\n#\tethereum/api/src/integration-test/java/org/hyperledger/besu/ethereum/api/jsonrpc/methods/PrivGetPrivateTransactionIntegrationTest.java\n#\tethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/eea/EeaSendRawTransaction.java\n#\tethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/priv/PrivFindPrivacyGroup.java\n#\tethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/priv/PrivGetTransactionReceipt.java\n#\tethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/methods/PrivJsonRpcMethods.java\n#\tethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/methods/PrivacyApiGroupJsonRpcMethods.java\n#\tethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/eea/EeaSendRawTransactionTest.java\n#\tethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/methods/PrivacyApiGroupJsonRpcMethodsTest.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/PrivacyBlockProcessor.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/ProtocolSpecBuilder.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivacyController.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivateTransactionSimulator.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/storage/PrivateStateKeyValueStorage.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/storage/PrivateStateStorage.java\n#\tethereum/core/src/test/java/org/hyperledger/besu/ethereum/privacy/DefaultPrivacyControllerTest.java\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>", "committedDate": "2020-02-20T18:52:46Z", "type": "forcePushed"}, {"oid": "93a52f465e4aa4f4a1ecb44c49a58655ce72fbd3", "url": "https://github.com/hyperledger/besu/commit/93a52f465e4aa4f4a1ecb44c49a58655ce72fbd3", "message": "on-chain-privacy-groups\n\n# Conflicts:\n#\tacceptance-tests/dsl/src/main/java/org/hyperledger/besu/tests/acceptance/dsl/transaction/privacy/PrivacyRequestFactory.java\n#\tacceptance-tests/tests/src/test/java/org/hyperledger/besu/tests/web3j/privacy/PrivCallAcceptanceTest.java\n#\tethereum/api/src/integration-test/java/org/hyperledger/besu/ethereum/api/jsonrpc/methods/PrivGetPrivateTransactionIntegrationTest.java\n#\tethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/eea/EeaSendRawTransaction.java\n#\tethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/priv/PrivFindPrivacyGroup.java\n#\tethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/priv/PrivGetTransactionReceipt.java\n#\tethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/methods/PrivJsonRpcMethods.java\n#\tethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/methods/PrivacyApiGroupJsonRpcMethods.java\n#\tethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/eea/EeaSendRawTransactionTest.java\n#\tethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/methods/PrivacyApiGroupJsonRpcMethodsTest.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/PrivacyBlockProcessor.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/ProtocolSpecBuilder.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivacyController.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivateTransactionSimulator.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/storage/PrivateStateKeyValueStorage.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/storage/PrivateStateStorage.java\n#\tethereum/core/src/test/java/org/hyperledger/besu/ethereum/privacy/DefaultPrivacyControllerTest.java\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>", "committedDate": "2020-02-20T18:55:29Z", "type": "forcePushed"}, {"oid": "a1ca6618a64f60b094d0218975ff024c73c93133", "url": "https://github.com/hyperledger/besu/commit/a1ca6618a64f60b094d0218975ff024c73c93133", "message": "on-chain-privacy-groups\n\n# Conflicts:\n#\tacceptance-tests/dsl/src/main/java/org/hyperledger/besu/tests/acceptance/dsl/transaction/privacy/PrivacyRequestFactory.java\n#\tacceptance-tests/tests/src/test/java/org/hyperledger/besu/tests/web3j/privacy/PrivCallAcceptanceTest.java\n#\tethereum/api/src/integration-test/java/org/hyperledger/besu/ethereum/api/jsonrpc/methods/PrivGetPrivateTransactionIntegrationTest.java\n#\tethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/eea/EeaSendRawTransaction.java\n#\tethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/priv/PrivFindPrivacyGroup.java\n#\tethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/priv/PrivGetTransactionReceipt.java\n#\tethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/methods/PrivJsonRpcMethods.java\n#\tethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/methods/PrivacyApiGroupJsonRpcMethods.java\n#\tethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/eea/EeaSendRawTransactionTest.java\n#\tethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/methods/PrivacyApiGroupJsonRpcMethodsTest.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/PrivacyBlockProcessor.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/ProtocolSpecBuilder.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivacyController.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivateTransactionSimulator.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/storage/PrivateStateKeyValueStorage.java\n#\tethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/storage/PrivateStateStorage.java\n#\tethereum/core/src/test/java/org/hyperledger/besu/ethereum/privacy/DefaultPrivacyControllerTest.java\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>", "committedDate": "2020-02-20T19:05:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQyMjQ2MA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r382422460", "bodyText": "This is here, because we are now adding the version number of the privacy group at the end.\nThis should be encapsulated in an Object with a writeTo and readFrom", "author": "pinges", "createdAt": "2020-02-21T06:54:01Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/DefaultPrivacyController.java", "diffHunk": "@@ -179,26 +216,282 @@ public long determineBesuNonce(\n     return result;\n   }\n \n+  @Override\n+  public Optional<String> buildAndSendAddPayload(\n+      final PrivateTransaction privateTransaction, final String enclavePublicKey) {\n+    if (isGroupAdditionTransaction(privateTransaction)) {\n+      final List<PrivateTransactionMetadata> privateTransactionMetadataList =\n+          buildTransactionMetadataList(Bytes32.wrap(privateTransaction.getPrivacyGroupId().get()));\n+      if (privateTransactionMetadataList.size() > 0) {\n+        final List<PrivateTransactionWithMetadata> privateTransactionWithMetadataList =\n+            retrievePrivateTransactions(\n+                Bytes32.wrap(privateTransaction.getPrivacyGroupId().get()),\n+                privateTransactionMetadataList,\n+                enclavePublicKey);\n+        final Bytes bytes = serializeAddToGroupPayload(privateTransactionWithMetadataList);\n+        final List<String> privateFor =\n+            getParticipantsFromParameter(privateTransaction.getPayload());\n+        return Optional.of(\n+            enclave.send(bytes.toBase64String(), enclavePublicKey, privateFor).getKey());\n+      }\n+    }\n+    return Optional.empty();\n+  }\n+\n+  @Override\n+  public PrivacyGroup retrievePrivacyGroup(final String privacyGroupId, final String enclaveKey) {\n+    return enclave.retrievePrivacyGroup(privacyGroupId);\n+  }\n+\n+  @Override\n+  public List<PrivacyGroup> findOnChainPrivacyGroup(\n+      final List<String> addresses, final String enclavePublicKey) {\n+    final ArrayList<PrivacyGroup> privacyGroups = new ArrayList<>();\n+    final PrivacyGroupHeadBlockMap privacyGroupHeadBlockMap =\n+        privateStateStorage\n+            .getPrivacyGroupHeadBlockMap(blockchain.getChainHeadHash())\n+            .orElse(PrivacyGroupHeadBlockMap.EMPTY);\n+    privacyGroupHeadBlockMap\n+        .keySet()\n+        .forEach(\n+            c -> {\n+              final List<String> participants = getExistingParticipants(c, enclavePublicKey);\n+              if (participants.containsAll(addresses)) {\n+                privacyGroups.add(\n+                    new PrivacyGroup(\n+                        c.toBase64String(), PrivacyGroup.Type.PANTHEON, \"\", \"\", participants));\n+              }\n+            });\n+    return privacyGroups;\n+  }\n+\n+  private List<String> getExistingParticipants(\n+      final Bytes privacyGroupId, final String enclavePublicKey) {\n+    // get the privateFor list from the management contract\n+    final Optional<PrivateTransactionProcessor.Result> privateTransactionSimulatorResultOptional =\n+        privateTransactionSimulator.process(\n+            privacyGroupId.toBase64String(),\n+            buildCallParams(\n+                Bytes.fromBase64String(enclavePublicKey), GET_PARTICIPANTS_METHOD_SIGNATURE));\n+\n+    if (privateTransactionSimulatorResultOptional.isPresent()\n+        && privateTransactionSimulatorResultOptional.get().isSuccessful()) {\n+      final RLPInput rlpInput =\n+          RLP.input(privateTransactionSimulatorResultOptional.get().getOutput());\n+      if (rlpInput.nextSize() > 0) {\n+        return decodeList(rlpInput.raw());\n+      } else {\n+        return Collections.emptyList();\n+      }\n+\n+    } else {\n+      // if the management contract does not exist this will prompt\n+      // Orion to resolve the privateFor\n+      return Collections.emptyList();\n+    }\n+  }\n+\n+  private List<String> decodeList(final Bytes rlpEncodedList) {\n+    final ArrayList<String> decodedElements = new ArrayList<>();\n+    // first 32 bytes is dynamic list offset\n+    final UInt256 lengthOfList = UInt256.fromBytes(rlpEncodedList.slice(32, 32)); // length of list\n+    for (int i = 0; i < lengthOfList.toLong(); ++i) {\n+      decodedElements.add(\n+          Bytes.wrap(rlpEncodedList.slice(64 + (32 * i), 32)).toBase64String()); // participant\n+    }\n+    return decodedElements;\n+  }\n+\n+  private List<String> getParticipantsFromParameter(final Bytes input) {\n+    final List<String> participants = new ArrayList<>();\n+    final Bytes mungedParticipants = input.slice(4 + 32 + 32 + 32);\n+    for (int i = 0; i <= mungedParticipants.size() - 32; i += 32) {\n+      participants.add(mungedParticipants.slice(i, 32).toBase64String());\n+    }\n+    return participants;\n+  }\n+\n+  private CallParameter buildCallParams(final Bytes enclavePublicKey, final Bytes methodCall) {\n+    return new CallParameter(\n+        Address.ZERO,\n+        Address.PRIVACY_PROXY,\n+        3000000,\n+        Wei.of(1000),\n+        Wei.ZERO,\n+        Bytes.concatenate(methodCall, enclavePublicKey));\n+  }\n+\n+  private List<PrivateTransactionMetadata> buildTransactionMetadataList(\n+      final Bytes32 privacyGroupId) {\n+    final List<PrivateTransactionMetadata> pmtHashes = new ArrayList<>();\n+    PrivacyGroupHeadBlockMap privacyGroupHeadBlockMap =\n+        privateStateStorage\n+            .getPrivacyGroupHeadBlockMap(blockchain.getChainHeadHash())\n+            .orElse(PrivacyGroupHeadBlockMap.EMPTY);\n+    if (privacyGroupHeadBlockMap.get(privacyGroupId) != null) {\n+      Hash blockHash = privacyGroupHeadBlockMap.get(privacyGroupId);\n+      while (blockHash != null) {\n+        pmtHashes.addAll(\n+            0,\n+            privateStateStorage\n+                .getPrivateBlockMetadata(blockHash, privacyGroupId)\n+                .get()\n+                .getPrivateTransactionMetadataList());\n+        blockHash = blockchain.getBlockHeader(blockHash).get().getParentHash();\n+        privacyGroupHeadBlockMap =\n+            privateStateStorage\n+                .getPrivacyGroupHeadBlockMap(blockHash)\n+                .orElse(PrivacyGroupHeadBlockMap.EMPTY);\n+        if (privacyGroupHeadBlockMap.get(privacyGroupId) != null) {\n+          blockHash = privacyGroupHeadBlockMap.get(privacyGroupId);\n+        } else {\n+          break;\n+        }\n+      }\n+    }\n+    return pmtHashes;\n+  }\n+\n+  private List<PrivateTransactionWithMetadata> retrievePrivateTransactions(\n+      final Bytes32 privacyGroupId,\n+      final List<PrivateTransactionMetadata> privateTransactionMetadataList,\n+      final String enclavePublicKey) {\n+    final ArrayList<PrivateTransactionWithMetadata> privateTransactions = new ArrayList<>();\n+    privateStateStorage\n+        .getAddDataKey(privacyGroupId)\n+        .ifPresent(key -> privateTransactions.addAll(retrieveAddBlob(key.toBase64String())));\n+    for (int i = privateTransactions.size(); i < privateTransactionMetadataList.size(); i++) {\n+      final PrivateTransactionMetadata privateTransactionMetadata =\n+          privateTransactionMetadataList.get(i);\n+      final Transaction privateMarkerTransaction =\n+          blockchain\n+              .getTransactionByHash(privateTransactionMetadata.getPrivacyMarkerTransactionHash())\n+              .orElseThrow();\n+      final ReceiveResponse receiveResponse =\n+          retrieveTransaction(\n+              privateMarkerTransaction.getPayload().slice(0, 32).toBase64String(),\n+              enclavePublicKey);\n+      final BytesValueRLPInput input =\n+          new BytesValueRLPInput(\n+              Bytes.fromBase64String(new String(receiveResponse.getPayload(), UTF_8)), false);\n+      input.enterList();\n+      privateTransactions.add(\n+          new PrivateTransactionWithMetadata(\n+              PrivateTransaction.readFrom(input), privateTransactionMetadata));\n+      input.leaveListLenient();\n+    }\n+\n+    return privateTransactions;\n+  }\n+\n+  public List<PrivateTransactionWithMetadata> retrieveAddBlob(final String addDataKey) {\n+    final ReceiveResponse addReceiveResponse = enclave.receive(addDataKey);\n+    return deserializeAddToGroupPayload(\n+        Bytes.wrap(Base64.getDecoder().decode(addReceiveResponse.getPayload())));\n+  }\n+\n+  private Bytes serializeAddToGroupPayload(\n+      final List<PrivateTransactionWithMetadata> privateTransactionWithMetadataList) {\n+\n+    final BytesValueRLPOutput rlpOutput = new BytesValueRLPOutput();\n+    rlpOutput.startList();\n+    privateTransactionWithMetadataList.forEach(\n+        privateTransactionWithMetadata -> privateTransactionWithMetadata.writeTo(rlpOutput));\n+    rlpOutput.endList();\n+\n+    return rlpOutput.encoded();\n+  }\n+\n+  private List<PrivateTransactionWithMetadata> deserializeAddToGroupPayload(\n+      final Bytes encodedAddToGroupPayload) {\n+    final ArrayList<PrivateTransactionWithMetadata> deserializedResponse = new ArrayList<>();\n+    final BytesValueRLPInput bytesValueRLPInput =\n+        new BytesValueRLPInput(encodedAddToGroupPayload, false);\n+    final int noOfEntries = bytesValueRLPInput.enterList();\n+    for (int i = 0; i < noOfEntries; i++) {\n+      deserializedResponse.add(PrivateTransactionWithMetadata.readFrom(bytesValueRLPInput));\n+    }\n+    bytesValueRLPInput.leaveList();\n+    return deserializedResponse;\n+  }\n+\n   private SendResponse sendRequest(\n       final PrivateTransaction privateTransaction, final String enclavePublicKey) {\n     final BytesValueRLPOutput rlpOutput = new BytesValueRLPOutput();\n+    rlpOutput.startList();", "originalCommit": "a1ca6618a64f60b094d0218975ff024c73c93133", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU2OTQ2Ng==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387569466", "bodyText": "this has bee fixed", "author": "iikirilov", "createdAt": "2020-03-04T10:16:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQyMjQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1MjAyOA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r382952028", "bodyText": "Is this the correct length?", "author": "josh-richardson", "createdAt": "2020-02-23T00:18:47Z", "path": "acceptance-tests/dsl/src/main/java/org/hyperledger/besu/tests/acceptance/dsl/transaction/privacy/PrivacyRequestFactory.java", "diffHunk": "@@ -167,4 +305,52 @@ public String getTransactionKey() {\n         web3jService,\n         GetTransactionCountResponse.class);\n   }\n+\n+  public static class PrivxCreatePrivacyGroup {\n+    final String privacyGroupId;\n+    final String transactionHash;\n+\n+    @JsonCreator\n+    public PrivxCreatePrivacyGroup(\n+        @JsonProperty(\"privacyGroupId\") final String privacyGroupId,\n+        @JsonProperty(\"transactionHash\") final String transactionHash) {\n+      this.privacyGroupId = privacyGroupId;\n+      this.transactionHash = transactionHash;\n+    }\n+\n+    public String getPrivacyGroupId() {\n+      return privacyGroupId;\n+    }\n+\n+    public String getTransactionHash() {\n+      return transactionHash;\n+    }\n+  }\n+\n+  private Bytes encodeParameters(final Bytes privateFrom, final List<Bytes> participants) {\n+    return Bytes.concatenate(\n+        DEFAULT_PRIVACY_ADD_METHOD_SIGNATURE, privateFrom, encodeList(participants));\n+  }\n+\n+  private Bytes encodeList(final List<Bytes> participants) {\n+    final Bytes dynamicParameterOffset = encodeLong(64);\n+    final Bytes length = encodeLong(participants.size());\n+    return Bytes.concatenate(\n+        dynamicParameterOffset,\n+        length,\n+        Bytes.fromHexString(\n+            participants.stream()\n+                .map(Bytes::toUnprefixedHexString)\n+                .collect(Collectors.joining(\"\"))));\n+  }\n+\n+  // long to uint256, 8 bytes big endian, so left padded by 24 bytes\n+  private static Bytes encodeLong(final long l) {\n+    checkArgument(l >= 0, \"Unsigned value must be positive\");\n+    final byte[] longBytes = new byte[8];", "originalCommit": "70e4c82323a2506ba17e328a7d6352e0292eb629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE1NTExMw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r383155113", "bodyText": "yes a long is 8 bytes", "author": "iikirilov", "createdAt": "2020-02-24T09:31:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1MjAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1Mjk1Nw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r382952957", "bodyText": "Should we be printing here?", "author": "josh-richardson", "createdAt": "2020-02-23T00:37:22Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/PrivacyBlockProcessor.java", "diffHunk": "@@ -40,6 +70,48 @@ public Result processBlock(\n       final BlockHeader blockHeader,\n       final List<Transaction> transactions,\n       final List<BlockHeader> ommers) {\n+    final PrivacyGroupHeadBlockMap preProcessPrivacyGroupHeadBlockMap =\n+        new PrivacyGroupHeadBlockMap(\n+            privateStateStorage\n+                .getPrivacyGroupHeadBlockMap(blockHeader.getParentHash())\n+                .orElse(PrivacyGroupHeadBlockMap.EMPTY));\n+    transactions.stream()\n+        .filter(\n+            t ->\n+                t.getTo().isPresent()\n+                    && t.getTo().equals(Optional.of(Address.ONCHAIN_PRIVACY))\n+                    && t.getPayload().size() == 64)\n+        .forEach(\n+            t -> {\n+              final Bytes32 addKey = Bytes32.wrap(t.getPayload().slice(32, 32));\n+              try {\n+                final ReceiveResponse receiveResponse = enclave.receive(addKey.toBase64String());\n+                final List<PrivateTransactionWithMetadata> privateTransactionWithMetadataList =\n+                    deserializeAddToGroupPayload(\n+                        Bytes.wrap(Base64.getDecoder().decode(receiveResponse.getPayload())));\n+                final Bytes32 privacyGroupId =\n+                    Bytes32.wrap(\n+                        privateTransactionWithMetadataList\n+                            .get(0)\n+                            .getPrivateTransaction()\n+                            .getPrivacyGroupId()\n+                            .get());\n+                if (!preProcessPrivacyGroupHeadBlockMap.containsKey(privacyGroupId)) {\n+                  final PrivateStateRehydration privateStateRehydration =\n+                      new PrivateStateRehydration(\n+                          privateStateStorage,\n+                          blockchain,\n+                          protocolSchedule,\n+                          publicWorldStateArchive,\n+                          privateWorldStateArchive);\n+                  privateStateRehydration.rehydrate(privateTransactionWithMetadataList);\n+                  privateStateStorage.updater().putAddDataKey(privacyGroupId, addKey).commit();\n+                }\n+              } catch (final EnclaveClientException e) {\n+                System.out.println();", "originalCommit": "70e4c82323a2506ba17e328a7d6352e0292eb629", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1MzUzNQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r382953535", "bodyText": "Do we want to disable this on master?", "author": "josh-richardson", "createdAt": "2020-02-23T00:50:39Z", "path": "acceptance-tests/tests/src/test/resources/log4j2.xml", "diffHunk": "@@ -15,6 +15,8 @@\n     <Logger name=\"org.hyperledger.besu.SubProcessLog\" level=\"INFO\" additivity=\"false\">\n       <AppenderRef ref=\"SubProcessConsole\" />\n     </Logger>\n+    <Logger name=\"net.consensys.orion\" level=\"OFF\" additivity=\"false\">", "originalCommit": "70e4c82323a2506ba17e328a7d6352e0292eb629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE1Mzg2MQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r383153861", "bodyText": "yes this is in the AT", "author": "iikirilov", "createdAt": "2020-02-24T09:29:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1MzUzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0NTkxMA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384545910", "bodyText": "basically the orion logs are just errors about how it cant find some payload which fills the logs with mostly useless information", "author": "iikirilov", "createdAt": "2020-02-26T14:57:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1MzUzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1MzYyNA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r382953624", "bodyText": "Could perhaps benefit from a refactor.", "author": "josh-richardson", "createdAt": "2020-02-23T00:52:14Z", "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/priv/PrivGetTransactionReceipt.java", "diffHunk": "@@ -88,24 +89,43 @@ public JsonRpcResponse response(final JsonRpcRequestContext requestContext) {\n     final Transaction pmtTransaction =\n         blockBody.getTransactions().get(pmtLocation.getTransactionIndex());\n \n-    final Hash blockhash = pmtLocation.getBlockHash();\n-    final long blockNumber = blockchain.getBlockchain().getBlockHeader(blockhash).get().getNumber();\n+    final Hash blockHash = pmtLocation.getBlockHash();\n+    final long blockNumber = blockchain.getBlockchain().getBlockHeader(blockHash).get().getNumber();\n \n     final PrivateTransaction privateTransaction;\n     final String privacyGroupId;\n     try {\n       final ReceiveResponse receiveResponse =\n           privacyController.retrieveTransaction(\n-              pmtTransaction.getPayload().toBase64String(),\n+              pmtTransaction.getPayload().slice(0, 32).toBase64String(),\n               enclavePublicKeyProvider.getEnclaveKey(requestContext.getUser()));\n       LOG.trace(\"Received private transaction information\");\n \n       final BytesValueRLPInput input =\n           new BytesValueRLPInput(\n               Bytes.fromBase64String(new String(receiveResponse.getPayload(), UTF_8)), false);\n-\n+      input.enterList();\n       privateTransaction = PrivateTransaction.readFrom(input);\n-      privacyGroupId = receiveResponse.getPrivacyGroupId();\n+      input.leaveListLenient();\n+\n+      if (privateTransaction.getPrivacyGroupId().isPresent()) {\n+        PrivacyGroup privacyGroup = null;\n+        try {\n+          privacyGroup =\n+              privacyController.retrievePrivacyGroup(\n+                  privateTransaction.getPrivacyGroupId().get().toBase64String(),\n+                  enclavePublicKeyProvider.getEnclaveKey(requestContext.getUser()));\n+        } catch (final EnclaveClientException e) {\n+          // it is an onchain group\n+        }\n+        if (privacyGroup == null) {\n+          privacyGroupId = privateTransaction.getPrivacyGroupId().get().toBase64String();\n+        } else {\n+          privacyGroupId = receiveResponse.getPrivacyGroupId();\n+        }\n+      } else {\n+        privacyGroupId = receiveResponse.getPrivacyGroupId();\n+      }", "originalCommit": "70e4c82323a2506ba17e328a7d6352e0292eb629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE1NTU1MA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r383155550", "bodyText": "any suggestions?", "author": "iikirilov", "createdAt": "2020-02-24T09:32:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1MzYyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1MzczMQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r382953731", "bodyText": "Should this be of type pantheon or onchain?", "author": "josh-richardson", "createdAt": "2020-02-23T00:54:52Z", "path": "ethereum/core/src/test/java/org/hyperledger/besu/ethereum/privacy/DefaultPrivacyControllerTest.java", "diffHunk": "@@ -203,6 +211,41 @@ public void sendValidBesuTransaction() {\n     verify(enclave).send(anyString(), eq(ENCLAVE_PUBLIC_KEY), eq(PRIVACY_GROUP_ID));\n   }\n \n+  @Test\n+  public void findOnChainPrivacyGroups() {\n+    final List<String> privacyGroupAddresses = newArrayList(ENCLAVE_PUBLIC_KEY, ENCLAVE_KEY2);\n+\n+    final PrivacyGroup privacyGroup =\n+        new PrivacyGroup(PRIVACY_GROUP_ID, Type.PANTHEON, \"\", \"\", privacyGroupAddresses);", "originalCommit": "70e4c82323a2506ba17e328a7d6352e0292eb629", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE1NDI2MQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r383154261", "bodyText": "Is there a web3j release with this type?", "author": "iikirilov", "createdAt": "2020-02-24T09:29:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1MzczMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzE4MTU2Mg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r383181562", "bodyText": "Fair. We should support this.", "author": "josh-richardson", "createdAt": "2020-02-24T10:22:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1MzczMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyNTEwNA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386225104", "bodyText": "Do we have that now?", "author": "pinges", "createdAt": "2020-03-02T07:08:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1MzczMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU1NjA1Mw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386556053", "bodyText": "I have put this in the dsl so it does not depend on web3j", "author": "iikirilov", "createdAt": "2020-03-02T18:02:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mjk1MzczMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1MjQ2MQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r383652461", "bodyText": "There are a bunch of LOG.info on this class that should be debug/trace. We shouldn't be logging every single step of the onchain privacy group creation.", "author": "lucassaldanha", "createdAt": "2020-02-25T04:27:10Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/OnChainPrivacyPrecompiledContract.java", "diffHunk": "@@ -0,0 +1,444 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.mainnet.precompiles.privacy;\n+\n+import static org.hyperledger.besu.crypto.Hash.keccak256;\n+import static org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver.EMPTY_ROOT_HASH;\n+\n+import org.hyperledger.besu.crypto.SECP256K1;\n+import org.hyperledger.besu.enclave.Enclave;\n+import org.hyperledger.besu.enclave.EnclaveClientException;\n+import org.hyperledger.besu.enclave.EnclaveIOException;\n+import org.hyperledger.besu.enclave.EnclaveServerException;\n+import org.hyperledger.besu.enclave.types.ReceiveResponse;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.DefaultEvmAccount;\n+import org.hyperledger.besu.ethereum.core.Gas;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableAccount;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.PrivacyParameters;\n+import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;\n+import org.hyperledger.besu.ethereum.core.Wei;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.debug.TraceOptions;\n+import org.hyperledger.besu.ethereum.mainnet.AbstractPrecompiledContract;\n+import org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransaction;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionProcessor;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionReceipt;\n+import org.hyperledger.besu.ethereum.privacy.Restriction;\n+import org.hyperledger.besu.ethereum.privacy.group.OnChainGroupManagement;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateBlockMetadata;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateTransactionMetadata;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLP;\n+import org.hyperledger.besu.ethereum.vm.DebugOperationTracer;\n+import org.hyperledger.besu.ethereum.vm.GasCalculator;\n+import org.hyperledger.besu.ethereum.vm.MessageFrame;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.Base64;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class OnChainPrivacyPrecompiledContract extends AbstractPrecompiledContract {", "originalCommit": "8908e6ebf53087c08cffdcce878a349349d086dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU2OTcwNQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387569705", "bodyText": "this has been fixed", "author": "iikirilov", "createdAt": "2020-03-04T10:16:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1MjQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1Mjc3Mg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r383652772", "bodyText": "We need to replace this magical hex with something that makes sense (e.g. ADD_MEMBER_FUNCTION_SIGNATURE or something better)", "author": "lucassaldanha", "createdAt": "2020-02-25T04:28:34Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/OnChainPrivacyPrecompiledContract.java", "diffHunk": "@@ -0,0 +1,444 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.mainnet.precompiles.privacy;\n+\n+import static org.hyperledger.besu.crypto.Hash.keccak256;\n+import static org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver.EMPTY_ROOT_HASH;\n+\n+import org.hyperledger.besu.crypto.SECP256K1;\n+import org.hyperledger.besu.enclave.Enclave;\n+import org.hyperledger.besu.enclave.EnclaveClientException;\n+import org.hyperledger.besu.enclave.EnclaveIOException;\n+import org.hyperledger.besu.enclave.EnclaveServerException;\n+import org.hyperledger.besu.enclave.types.ReceiveResponse;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.DefaultEvmAccount;\n+import org.hyperledger.besu.ethereum.core.Gas;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableAccount;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.PrivacyParameters;\n+import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;\n+import org.hyperledger.besu.ethereum.core.Wei;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.debug.TraceOptions;\n+import org.hyperledger.besu.ethereum.mainnet.AbstractPrecompiledContract;\n+import org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransaction;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionProcessor;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionReceipt;\n+import org.hyperledger.besu.ethereum.privacy.Restriction;\n+import org.hyperledger.besu.ethereum.privacy.group.OnChainGroupManagement;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateBlockMetadata;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateTransactionMetadata;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLP;\n+import org.hyperledger.besu.ethereum.vm.DebugOperationTracer;\n+import org.hyperledger.besu.ethereum.vm.GasCalculator;\n+import org.hyperledger.besu.ethereum.vm.MessageFrame;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.Base64;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class OnChainPrivacyPrecompiledContract extends AbstractPrecompiledContract {\n+\n+  // Dummy signature for transactions to not fail being processed.\n+  private static final SECP256K1.Signature FAKE_SIGNATURE =\n+      SECP256K1.Signature.create(SECP256K1.HALF_CURVE_ORDER, SECP256K1.HALF_CURVE_ORDER, (byte) 0);\n+\n+  private final Enclave enclave;\n+  private final WorldStateArchive privateWorldStateArchive;\n+  private final PrivateStateStorage privateStateStorage;\n+  private final PrivateStateRootResolver privateStateRootResolver;\n+  private PrivateTransactionProcessor privateTransactionProcessor;\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  public OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator, final PrivacyParameters privacyParameters) {\n+    this(\n+        gasCalculator,\n+        privacyParameters.getEnclave(),\n+        privacyParameters.getPrivateWorldStateArchive(),\n+        privacyParameters.getPrivateStateStorage());\n+  }\n+\n+  OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator,\n+      final Enclave enclave,\n+      final WorldStateArchive worldStateArchive,\n+      final PrivateStateStorage privateStateStorage) {\n+    super(\"OnChainPrivacy\", gasCalculator);\n+    this.enclave = enclave;\n+    this.privateWorldStateArchive = worldStateArchive;\n+    this.privateStateStorage = privateStateStorage;\n+    this.privateStateRootResolver = new PrivateStateRootResolver(privateStateStorage);\n+  }\n+\n+  public void setPrivateTransactionProcessor(\n+      final PrivateTransactionProcessor privateTransactionProcessor) {\n+    this.privateTransactionProcessor = privateTransactionProcessor;\n+  }\n+\n+  @Override\n+  public Gas gasRequirement(final Bytes input) {\n+    return Gas.of(0L);\n+  }\n+\n+  @Override\n+  public Bytes compute(final Bytes input, final MessageFrame messageFrame) {\n+    final ProcessableBlockHeader currentBlockHeader = messageFrame.getBlockHeader();\n+    if (!BlockHeader.class.isAssignableFrom(currentBlockHeader.getClass())) {\n+      if (!messageFrame.isPersistingPrivateState()) {\n+        // We get in here from block mining.\n+        return Bytes.EMPTY;\n+      } else {\n+        throw new IllegalArgumentException(\n+            \"The MessageFrame contains an illegal block header type. Cannot persist private block metadata without current block hash.\");\n+      }\n+    }\n+    final Hash currentBlockHash = ((BlockHeader) currentBlockHeader).getHash();\n+\n+    final String key = input.slice(0, 32).toBase64String();\n+\n+    final ReceiveResponse receiveResponse;\n+    try {\n+      receiveResponse = enclave.receive(key);\n+    } catch (final EnclaveClientException e) {\n+      LOG.debug(\"Can not fetch private transaction payload with key {}\", key, e);\n+      return Bytes.EMPTY;\n+    } catch (final EnclaveServerException e) {\n+      LOG.error(\"Enclave is responding but errored perhaps it has a misconfiguration?\", e);\n+      throw e;\n+    } catch (final EnclaveIOException e) {\n+      LOG.error(\"Can not communicate with enclave is it up?\", e);\n+      throw e;\n+    }\n+\n+    final BytesValueRLPInput bytesValueRLPInput =\n+        new BytesValueRLPInput(\n+            Bytes.wrap(Base64.getDecoder().decode(receiveResponse.getPayload())), false);\n+    bytesValueRLPInput.enterList();\n+    final PrivateTransaction privateTransaction = PrivateTransaction.readFrom(bytesValueRLPInput);\n+    final Optional<Bytes32> versionOptional;\n+    if (!bytesValueRLPInput.isEndOfCurrentList()) {\n+      versionOptional = Optional.of(bytesValueRLPInput.readBytes32());\n+    } else {\n+      versionOptional = Optional.of(Bytes32.ZERO);\n+    }\n+    bytesValueRLPInput.leaveList();\n+\n+    final WorldUpdater publicWorldState = messageFrame.getWorldState();\n+\n+    final Optional<Bytes> maybeGroupId = privateTransaction.getPrivacyGroupId();\n+    if (maybeGroupId.isEmpty()) {\n+      return Bytes.EMPTY;\n+    }\n+\n+    final Bytes32 privacyGroupId = Bytes32.wrap(maybeGroupId.get());\n+\n+    LOG.trace(\n+        \"Processing private transaction {} in privacy group {}\",\n+        privateTransaction.getHash(),\n+        privacyGroupId);\n+\n+    final PrivacyGroupHeadBlockMap privacyGroupHeadBlockMap =\n+        privateStateStorage.getPrivacyGroupHeadBlockMap(currentBlockHash).orElseThrow();\n+\n+    final Blockchain blockchain = messageFrame.getBlockchain();\n+\n+    final Hash lastRootHash =\n+        privateStateRootResolver.resolveLastStateRoot(privacyGroupId, currentBlockHash);\n+\n+    LOG.info(\"Last root hash: {}\", lastRootHash.toHexString());\n+\n+    final MutableWorldState disposablePrivateState =\n+        privateWorldStateArchive.getMutable(lastRootHash).get();\n+\n+    final WorldUpdater privateWorldStateUpdater = disposablePrivateState.updater();\n+\n+    maybeInjectDefaultManagementAndProxy(\n+        lastRootHash, disposablePrivateState, privateWorldStateUpdater);\n+\n+    final PrivateTransactionProcessor.Result canExecuteResult =\n+        checkCanExecute(\n+            messageFrame,\n+            currentBlockHeader,\n+            publicWorldState,\n+            privacyGroupId,\n+            blockchain,\n+            disposablePrivateState,\n+            privateWorldStateUpdater,\n+            OnChainGroupManagement.CAN_EXECUTE_METHOD_SIGNATURE);\n+\n+    if (privateTransaction.getPayload().toHexString().startsWith(\"0xf744b089\")", "originalCommit": "8908e6ebf53087c08cffdcce878a349349d086dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU2OTkzMA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387569930", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T10:17:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1Mjc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1NDM4OQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r383654389", "bodyText": "This whole logic + canExecuteResult.getOutput().toHexString().endsWith(\"0\") could be encapsulated into a method isContractLocked() or something that returns a boolean. This will improve readability.\nExample:\n[...]\n\nboolean isContractLocked = isContractLocked(messageFrame, currentBlockHeader, publicWorldState,\n    privacyGroupId, blockchain, disposablePrivateState, privateWorldStateUpdater);\n\nboolean isAddingParticipant = isCallingAddParticipantFunction(privateTransaction);\n\nif (isAddingParticipant && !isContractLocked) {\n  LOG.debug(\n      \"Privacy Group {} is not locked while trying to add to group with commitment {}\",\n      privacyGroupId.toHexString(),\n      messageFrame.getTransactionHash());\n  return Bytes.EMPTY;\n}\n\nif (!isAddingParticipant && isContractLocked) {\n  LOG.debug(\n      \"Privacy Group {} is locked while trying to execute transaction with commitment {}\",\n      privacyGroupId.toHexString(),\n      messageFrame.getTransactionHash());\n  return Bytes.EMPTY;\n}\n\n[...]", "author": "lucassaldanha", "createdAt": "2020-02-25T04:36:17Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/OnChainPrivacyPrecompiledContract.java", "diffHunk": "@@ -0,0 +1,444 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.mainnet.precompiles.privacy;\n+\n+import static org.hyperledger.besu.crypto.Hash.keccak256;\n+import static org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver.EMPTY_ROOT_HASH;\n+\n+import org.hyperledger.besu.crypto.SECP256K1;\n+import org.hyperledger.besu.enclave.Enclave;\n+import org.hyperledger.besu.enclave.EnclaveClientException;\n+import org.hyperledger.besu.enclave.EnclaveIOException;\n+import org.hyperledger.besu.enclave.EnclaveServerException;\n+import org.hyperledger.besu.enclave.types.ReceiveResponse;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.DefaultEvmAccount;\n+import org.hyperledger.besu.ethereum.core.Gas;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableAccount;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.PrivacyParameters;\n+import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;\n+import org.hyperledger.besu.ethereum.core.Wei;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.debug.TraceOptions;\n+import org.hyperledger.besu.ethereum.mainnet.AbstractPrecompiledContract;\n+import org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransaction;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionProcessor;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionReceipt;\n+import org.hyperledger.besu.ethereum.privacy.Restriction;\n+import org.hyperledger.besu.ethereum.privacy.group.OnChainGroupManagement;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateBlockMetadata;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateTransactionMetadata;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLP;\n+import org.hyperledger.besu.ethereum.vm.DebugOperationTracer;\n+import org.hyperledger.besu.ethereum.vm.GasCalculator;\n+import org.hyperledger.besu.ethereum.vm.MessageFrame;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.Base64;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class OnChainPrivacyPrecompiledContract extends AbstractPrecompiledContract {\n+\n+  // Dummy signature for transactions to not fail being processed.\n+  private static final SECP256K1.Signature FAKE_SIGNATURE =\n+      SECP256K1.Signature.create(SECP256K1.HALF_CURVE_ORDER, SECP256K1.HALF_CURVE_ORDER, (byte) 0);\n+\n+  private final Enclave enclave;\n+  private final WorldStateArchive privateWorldStateArchive;\n+  private final PrivateStateStorage privateStateStorage;\n+  private final PrivateStateRootResolver privateStateRootResolver;\n+  private PrivateTransactionProcessor privateTransactionProcessor;\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  public OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator, final PrivacyParameters privacyParameters) {\n+    this(\n+        gasCalculator,\n+        privacyParameters.getEnclave(),\n+        privacyParameters.getPrivateWorldStateArchive(),\n+        privacyParameters.getPrivateStateStorage());\n+  }\n+\n+  OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator,\n+      final Enclave enclave,\n+      final WorldStateArchive worldStateArchive,\n+      final PrivateStateStorage privateStateStorage) {\n+    super(\"OnChainPrivacy\", gasCalculator);\n+    this.enclave = enclave;\n+    this.privateWorldStateArchive = worldStateArchive;\n+    this.privateStateStorage = privateStateStorage;\n+    this.privateStateRootResolver = new PrivateStateRootResolver(privateStateStorage);\n+  }\n+\n+  public void setPrivateTransactionProcessor(\n+      final PrivateTransactionProcessor privateTransactionProcessor) {\n+    this.privateTransactionProcessor = privateTransactionProcessor;\n+  }\n+\n+  @Override\n+  public Gas gasRequirement(final Bytes input) {\n+    return Gas.of(0L);\n+  }\n+\n+  @Override\n+  public Bytes compute(final Bytes input, final MessageFrame messageFrame) {\n+    final ProcessableBlockHeader currentBlockHeader = messageFrame.getBlockHeader();\n+    if (!BlockHeader.class.isAssignableFrom(currentBlockHeader.getClass())) {\n+      if (!messageFrame.isPersistingPrivateState()) {\n+        // We get in here from block mining.\n+        return Bytes.EMPTY;\n+      } else {\n+        throw new IllegalArgumentException(\n+            \"The MessageFrame contains an illegal block header type. Cannot persist private block metadata without current block hash.\");\n+      }\n+    }\n+    final Hash currentBlockHash = ((BlockHeader) currentBlockHeader).getHash();\n+\n+    final String key = input.slice(0, 32).toBase64String();\n+\n+    final ReceiveResponse receiveResponse;\n+    try {\n+      receiveResponse = enclave.receive(key);\n+    } catch (final EnclaveClientException e) {\n+      LOG.debug(\"Can not fetch private transaction payload with key {}\", key, e);\n+      return Bytes.EMPTY;\n+    } catch (final EnclaveServerException e) {\n+      LOG.error(\"Enclave is responding but errored perhaps it has a misconfiguration?\", e);\n+      throw e;\n+    } catch (final EnclaveIOException e) {\n+      LOG.error(\"Can not communicate with enclave is it up?\", e);\n+      throw e;\n+    }\n+\n+    final BytesValueRLPInput bytesValueRLPInput =\n+        new BytesValueRLPInput(\n+            Bytes.wrap(Base64.getDecoder().decode(receiveResponse.getPayload())), false);\n+    bytesValueRLPInput.enterList();\n+    final PrivateTransaction privateTransaction = PrivateTransaction.readFrom(bytesValueRLPInput);\n+    final Optional<Bytes32> versionOptional;\n+    if (!bytesValueRLPInput.isEndOfCurrentList()) {\n+      versionOptional = Optional.of(bytesValueRLPInput.readBytes32());\n+    } else {\n+      versionOptional = Optional.of(Bytes32.ZERO);\n+    }\n+    bytesValueRLPInput.leaveList();\n+\n+    final WorldUpdater publicWorldState = messageFrame.getWorldState();\n+\n+    final Optional<Bytes> maybeGroupId = privateTransaction.getPrivacyGroupId();\n+    if (maybeGroupId.isEmpty()) {\n+      return Bytes.EMPTY;\n+    }\n+\n+    final Bytes32 privacyGroupId = Bytes32.wrap(maybeGroupId.get());\n+\n+    LOG.trace(\n+        \"Processing private transaction {} in privacy group {}\",\n+        privateTransaction.getHash(),\n+        privacyGroupId);\n+\n+    final PrivacyGroupHeadBlockMap privacyGroupHeadBlockMap =\n+        privateStateStorage.getPrivacyGroupHeadBlockMap(currentBlockHash).orElseThrow();\n+\n+    final Blockchain blockchain = messageFrame.getBlockchain();\n+\n+    final Hash lastRootHash =\n+        privateStateRootResolver.resolveLastStateRoot(privacyGroupId, currentBlockHash);\n+\n+    LOG.info(\"Last root hash: {}\", lastRootHash.toHexString());\n+\n+    final MutableWorldState disposablePrivateState =\n+        privateWorldStateArchive.getMutable(lastRootHash).get();\n+\n+    final WorldUpdater privateWorldStateUpdater = disposablePrivateState.updater();\n+\n+    maybeInjectDefaultManagementAndProxy(\n+        lastRootHash, disposablePrivateState, privateWorldStateUpdater);\n+\n+    final PrivateTransactionProcessor.Result canExecuteResult =\n+        checkCanExecute(\n+            messageFrame,\n+            currentBlockHeader,\n+            publicWorldState,\n+            privacyGroupId,\n+            blockchain,\n+            disposablePrivateState,\n+            privateWorldStateUpdater,\n+            OnChainGroupManagement.CAN_EXECUTE_METHOD_SIGNATURE);", "originalCommit": "8908e6ebf53087c08cffdcce878a349349d086dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDYzMDk5Mg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384630992", "bodyText": "yep - 100% more readable!", "author": "iikirilov", "createdAt": "2020-02-26T17:00:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1NDM4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU3MDA5MQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387570091", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T10:17:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY1NDM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY2ODYwMg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r383668602", "bodyText": "Shouldn't we fail the tx in this case?", "author": "lucassaldanha", "createdAt": "2020-02-25T05:41:29Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/OnChainPrivacyPrecompiledContract.java", "diffHunk": "@@ -0,0 +1,444 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.mainnet.precompiles.privacy;\n+\n+import static org.hyperledger.besu.crypto.Hash.keccak256;\n+import static org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver.EMPTY_ROOT_HASH;\n+\n+import org.hyperledger.besu.crypto.SECP256K1;\n+import org.hyperledger.besu.enclave.Enclave;\n+import org.hyperledger.besu.enclave.EnclaveClientException;\n+import org.hyperledger.besu.enclave.EnclaveIOException;\n+import org.hyperledger.besu.enclave.EnclaveServerException;\n+import org.hyperledger.besu.enclave.types.ReceiveResponse;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.DefaultEvmAccount;\n+import org.hyperledger.besu.ethereum.core.Gas;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableAccount;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.PrivacyParameters;\n+import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;\n+import org.hyperledger.besu.ethereum.core.Wei;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.debug.TraceOptions;\n+import org.hyperledger.besu.ethereum.mainnet.AbstractPrecompiledContract;\n+import org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransaction;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionProcessor;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionReceipt;\n+import org.hyperledger.besu.ethereum.privacy.Restriction;\n+import org.hyperledger.besu.ethereum.privacy.group.OnChainGroupManagement;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateBlockMetadata;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateTransactionMetadata;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLP;\n+import org.hyperledger.besu.ethereum.vm.DebugOperationTracer;\n+import org.hyperledger.besu.ethereum.vm.GasCalculator;\n+import org.hyperledger.besu.ethereum.vm.MessageFrame;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.Base64;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class OnChainPrivacyPrecompiledContract extends AbstractPrecompiledContract {\n+\n+  // Dummy signature for transactions to not fail being processed.\n+  private static final SECP256K1.Signature FAKE_SIGNATURE =\n+      SECP256K1.Signature.create(SECP256K1.HALF_CURVE_ORDER, SECP256K1.HALF_CURVE_ORDER, (byte) 0);\n+\n+  private final Enclave enclave;\n+  private final WorldStateArchive privateWorldStateArchive;\n+  private final PrivateStateStorage privateStateStorage;\n+  private final PrivateStateRootResolver privateStateRootResolver;\n+  private PrivateTransactionProcessor privateTransactionProcessor;\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  public OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator, final PrivacyParameters privacyParameters) {\n+    this(\n+        gasCalculator,\n+        privacyParameters.getEnclave(),\n+        privacyParameters.getPrivateWorldStateArchive(),\n+        privacyParameters.getPrivateStateStorage());\n+  }\n+\n+  OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator,\n+      final Enclave enclave,\n+      final WorldStateArchive worldStateArchive,\n+      final PrivateStateStorage privateStateStorage) {\n+    super(\"OnChainPrivacy\", gasCalculator);\n+    this.enclave = enclave;\n+    this.privateWorldStateArchive = worldStateArchive;\n+    this.privateStateStorage = privateStateStorage;\n+    this.privateStateRootResolver = new PrivateStateRootResolver(privateStateStorage);\n+  }\n+\n+  public void setPrivateTransactionProcessor(\n+      final PrivateTransactionProcessor privateTransactionProcessor) {\n+    this.privateTransactionProcessor = privateTransactionProcessor;\n+  }\n+\n+  @Override\n+  public Gas gasRequirement(final Bytes input) {\n+    return Gas.of(0L);\n+  }\n+\n+  @Override\n+  public Bytes compute(final Bytes input, final MessageFrame messageFrame) {\n+    final ProcessableBlockHeader currentBlockHeader = messageFrame.getBlockHeader();\n+    if (!BlockHeader.class.isAssignableFrom(currentBlockHeader.getClass())) {\n+      if (!messageFrame.isPersistingPrivateState()) {\n+        // We get in here from block mining.\n+        return Bytes.EMPTY;\n+      } else {\n+        throw new IllegalArgumentException(\n+            \"The MessageFrame contains an illegal block header type. Cannot persist private block metadata without current block hash.\");\n+      }\n+    }\n+    final Hash currentBlockHash = ((BlockHeader) currentBlockHeader).getHash();\n+\n+    final String key = input.slice(0, 32).toBase64String();\n+\n+    final ReceiveResponse receiveResponse;\n+    try {\n+      receiveResponse = enclave.receive(key);\n+    } catch (final EnclaveClientException e) {\n+      LOG.debug(\"Can not fetch private transaction payload with key {}\", key, e);\n+      return Bytes.EMPTY;\n+    } catch (final EnclaveServerException e) {\n+      LOG.error(\"Enclave is responding but errored perhaps it has a misconfiguration?\", e);\n+      throw e;\n+    } catch (final EnclaveIOException e) {\n+      LOG.error(\"Can not communicate with enclave is it up?\", e);\n+      throw e;\n+    }\n+\n+    final BytesValueRLPInput bytesValueRLPInput =\n+        new BytesValueRLPInput(\n+            Bytes.wrap(Base64.getDecoder().decode(receiveResponse.getPayload())), false);\n+    bytesValueRLPInput.enterList();\n+    final PrivateTransaction privateTransaction = PrivateTransaction.readFrom(bytesValueRLPInput);\n+    final Optional<Bytes32> versionOptional;\n+    if (!bytesValueRLPInput.isEndOfCurrentList()) {\n+      versionOptional = Optional.of(bytesValueRLPInput.readBytes32());\n+    } else {\n+      versionOptional = Optional.of(Bytes32.ZERO);\n+    }\n+    bytesValueRLPInput.leaveList();\n+\n+    final WorldUpdater publicWorldState = messageFrame.getWorldState();\n+\n+    final Optional<Bytes> maybeGroupId = privateTransaction.getPrivacyGroupId();\n+    if (maybeGroupId.isEmpty()) {\n+      return Bytes.EMPTY;\n+    }\n+\n+    final Bytes32 privacyGroupId = Bytes32.wrap(maybeGroupId.get());\n+\n+    LOG.trace(\n+        \"Processing private transaction {} in privacy group {}\",\n+        privateTransaction.getHash(),\n+        privacyGroupId);\n+\n+    final PrivacyGroupHeadBlockMap privacyGroupHeadBlockMap =\n+        privateStateStorage.getPrivacyGroupHeadBlockMap(currentBlockHash).orElseThrow();\n+\n+    final Blockchain blockchain = messageFrame.getBlockchain();\n+\n+    final Hash lastRootHash =\n+        privateStateRootResolver.resolveLastStateRoot(privacyGroupId, currentBlockHash);\n+\n+    LOG.info(\"Last root hash: {}\", lastRootHash.toHexString());\n+\n+    final MutableWorldState disposablePrivateState =\n+        privateWorldStateArchive.getMutable(lastRootHash).get();\n+\n+    final WorldUpdater privateWorldStateUpdater = disposablePrivateState.updater();\n+\n+    maybeInjectDefaultManagementAndProxy(\n+        lastRootHash, disposablePrivateState, privateWorldStateUpdater);\n+\n+    final PrivateTransactionProcessor.Result canExecuteResult =\n+        checkCanExecute(\n+            messageFrame,\n+            currentBlockHeader,\n+            publicWorldState,\n+            privacyGroupId,\n+            blockchain,\n+            disposablePrivateState,\n+            privateWorldStateUpdater,\n+            OnChainGroupManagement.CAN_EXECUTE_METHOD_SIGNATURE);\n+\n+    if (privateTransaction.getPayload().toHexString().startsWith(\"0xf744b089\")\n+        && !canExecuteResult.getOutput().toHexString().endsWith(\"0\")) {\n+      LOG.info(\n+          \"Privacy Group {} is not locked while trying to add to group with commitment {}\",\n+          privacyGroupId.toHexString(),\n+          messageFrame.getTransactionHash());\n+      return Bytes.EMPTY;", "originalCommit": "8908e6ebf53087c08cffdcce878a349349d086dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY2ODYzNA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r383668634", "bodyText": "Shouldn't we fail the tx in this case?", "author": "lucassaldanha", "createdAt": "2020-02-25T05:41:37Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/OnChainPrivacyPrecompiledContract.java", "diffHunk": "@@ -0,0 +1,444 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.mainnet.precompiles.privacy;\n+\n+import static org.hyperledger.besu.crypto.Hash.keccak256;\n+import static org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver.EMPTY_ROOT_HASH;\n+\n+import org.hyperledger.besu.crypto.SECP256K1;\n+import org.hyperledger.besu.enclave.Enclave;\n+import org.hyperledger.besu.enclave.EnclaveClientException;\n+import org.hyperledger.besu.enclave.EnclaveIOException;\n+import org.hyperledger.besu.enclave.EnclaveServerException;\n+import org.hyperledger.besu.enclave.types.ReceiveResponse;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.DefaultEvmAccount;\n+import org.hyperledger.besu.ethereum.core.Gas;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableAccount;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.PrivacyParameters;\n+import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;\n+import org.hyperledger.besu.ethereum.core.Wei;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.debug.TraceOptions;\n+import org.hyperledger.besu.ethereum.mainnet.AbstractPrecompiledContract;\n+import org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransaction;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionProcessor;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionReceipt;\n+import org.hyperledger.besu.ethereum.privacy.Restriction;\n+import org.hyperledger.besu.ethereum.privacy.group.OnChainGroupManagement;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateBlockMetadata;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateTransactionMetadata;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLP;\n+import org.hyperledger.besu.ethereum.vm.DebugOperationTracer;\n+import org.hyperledger.besu.ethereum.vm.GasCalculator;\n+import org.hyperledger.besu.ethereum.vm.MessageFrame;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.Base64;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class OnChainPrivacyPrecompiledContract extends AbstractPrecompiledContract {\n+\n+  // Dummy signature for transactions to not fail being processed.\n+  private static final SECP256K1.Signature FAKE_SIGNATURE =\n+      SECP256K1.Signature.create(SECP256K1.HALF_CURVE_ORDER, SECP256K1.HALF_CURVE_ORDER, (byte) 0);\n+\n+  private final Enclave enclave;\n+  private final WorldStateArchive privateWorldStateArchive;\n+  private final PrivateStateStorage privateStateStorage;\n+  private final PrivateStateRootResolver privateStateRootResolver;\n+  private PrivateTransactionProcessor privateTransactionProcessor;\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  public OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator, final PrivacyParameters privacyParameters) {\n+    this(\n+        gasCalculator,\n+        privacyParameters.getEnclave(),\n+        privacyParameters.getPrivateWorldStateArchive(),\n+        privacyParameters.getPrivateStateStorage());\n+  }\n+\n+  OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator,\n+      final Enclave enclave,\n+      final WorldStateArchive worldStateArchive,\n+      final PrivateStateStorage privateStateStorage) {\n+    super(\"OnChainPrivacy\", gasCalculator);\n+    this.enclave = enclave;\n+    this.privateWorldStateArchive = worldStateArchive;\n+    this.privateStateStorage = privateStateStorage;\n+    this.privateStateRootResolver = new PrivateStateRootResolver(privateStateStorage);\n+  }\n+\n+  public void setPrivateTransactionProcessor(\n+      final PrivateTransactionProcessor privateTransactionProcessor) {\n+    this.privateTransactionProcessor = privateTransactionProcessor;\n+  }\n+\n+  @Override\n+  public Gas gasRequirement(final Bytes input) {\n+    return Gas.of(0L);\n+  }\n+\n+  @Override\n+  public Bytes compute(final Bytes input, final MessageFrame messageFrame) {\n+    final ProcessableBlockHeader currentBlockHeader = messageFrame.getBlockHeader();\n+    if (!BlockHeader.class.isAssignableFrom(currentBlockHeader.getClass())) {\n+      if (!messageFrame.isPersistingPrivateState()) {\n+        // We get in here from block mining.\n+        return Bytes.EMPTY;\n+      } else {\n+        throw new IllegalArgumentException(\n+            \"The MessageFrame contains an illegal block header type. Cannot persist private block metadata without current block hash.\");\n+      }\n+    }\n+    final Hash currentBlockHash = ((BlockHeader) currentBlockHeader).getHash();\n+\n+    final String key = input.slice(0, 32).toBase64String();\n+\n+    final ReceiveResponse receiveResponse;\n+    try {\n+      receiveResponse = enclave.receive(key);\n+    } catch (final EnclaveClientException e) {\n+      LOG.debug(\"Can not fetch private transaction payload with key {}\", key, e);\n+      return Bytes.EMPTY;\n+    } catch (final EnclaveServerException e) {\n+      LOG.error(\"Enclave is responding but errored perhaps it has a misconfiguration?\", e);\n+      throw e;\n+    } catch (final EnclaveIOException e) {\n+      LOG.error(\"Can not communicate with enclave is it up?\", e);\n+      throw e;\n+    }\n+\n+    final BytesValueRLPInput bytesValueRLPInput =\n+        new BytesValueRLPInput(\n+            Bytes.wrap(Base64.getDecoder().decode(receiveResponse.getPayload())), false);\n+    bytesValueRLPInput.enterList();\n+    final PrivateTransaction privateTransaction = PrivateTransaction.readFrom(bytesValueRLPInput);\n+    final Optional<Bytes32> versionOptional;\n+    if (!bytesValueRLPInput.isEndOfCurrentList()) {\n+      versionOptional = Optional.of(bytesValueRLPInput.readBytes32());\n+    } else {\n+      versionOptional = Optional.of(Bytes32.ZERO);\n+    }\n+    bytesValueRLPInput.leaveList();\n+\n+    final WorldUpdater publicWorldState = messageFrame.getWorldState();\n+\n+    final Optional<Bytes> maybeGroupId = privateTransaction.getPrivacyGroupId();\n+    if (maybeGroupId.isEmpty()) {\n+      return Bytes.EMPTY;\n+    }\n+\n+    final Bytes32 privacyGroupId = Bytes32.wrap(maybeGroupId.get());\n+\n+    LOG.trace(\n+        \"Processing private transaction {} in privacy group {}\",\n+        privateTransaction.getHash(),\n+        privacyGroupId);\n+\n+    final PrivacyGroupHeadBlockMap privacyGroupHeadBlockMap =\n+        privateStateStorage.getPrivacyGroupHeadBlockMap(currentBlockHash).orElseThrow();\n+\n+    final Blockchain blockchain = messageFrame.getBlockchain();\n+\n+    final Hash lastRootHash =\n+        privateStateRootResolver.resolveLastStateRoot(privacyGroupId, currentBlockHash);\n+\n+    LOG.info(\"Last root hash: {}\", lastRootHash.toHexString());\n+\n+    final MutableWorldState disposablePrivateState =\n+        privateWorldStateArchive.getMutable(lastRootHash).get();\n+\n+    final WorldUpdater privateWorldStateUpdater = disposablePrivateState.updater();\n+\n+    maybeInjectDefaultManagementAndProxy(\n+        lastRootHash, disposablePrivateState, privateWorldStateUpdater);\n+\n+    final PrivateTransactionProcessor.Result canExecuteResult =\n+        checkCanExecute(\n+            messageFrame,\n+            currentBlockHeader,\n+            publicWorldState,\n+            privacyGroupId,\n+            blockchain,\n+            disposablePrivateState,\n+            privateWorldStateUpdater,\n+            OnChainGroupManagement.CAN_EXECUTE_METHOD_SIGNATURE);\n+\n+    if (privateTransaction.getPayload().toHexString().startsWith(\"0xf744b089\")\n+        && !canExecuteResult.getOutput().toHexString().endsWith(\"0\")) {\n+      LOG.info(\n+          \"Privacy Group {} is not locked while trying to add to group with commitment {}\",\n+          privacyGroupId.toHexString(),\n+          messageFrame.getTransactionHash());\n+      return Bytes.EMPTY;\n+    }\n+\n+    if (!privateTransaction.getPayload().toHexString().startsWith(\"0xf744b089\")\n+        && canExecuteResult.getOutput().toHexString().endsWith(\"0\")) {\n+      LOG.info(\n+          \"Privacy Group {} is locked while trying to execute transaction with commitment {}\",\n+          privacyGroupId.toHexString(),\n+          messageFrame.getTransactionHash());\n+      return Bytes.EMPTY;", "originalCommit": "8908e6ebf53087c08cffdcce878a349349d086dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY2ODczNg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r383668736", "bodyText": "Shouldn't we fail the tx in this case?", "author": "lucassaldanha", "createdAt": "2020-02-25T05:42:05Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/OnChainPrivacyPrecompiledContract.java", "diffHunk": "@@ -0,0 +1,444 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.mainnet.precompiles.privacy;\n+\n+import static org.hyperledger.besu.crypto.Hash.keccak256;\n+import static org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver.EMPTY_ROOT_HASH;\n+\n+import org.hyperledger.besu.crypto.SECP256K1;\n+import org.hyperledger.besu.enclave.Enclave;\n+import org.hyperledger.besu.enclave.EnclaveClientException;\n+import org.hyperledger.besu.enclave.EnclaveIOException;\n+import org.hyperledger.besu.enclave.EnclaveServerException;\n+import org.hyperledger.besu.enclave.types.ReceiveResponse;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.DefaultEvmAccount;\n+import org.hyperledger.besu.ethereum.core.Gas;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableAccount;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.PrivacyParameters;\n+import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;\n+import org.hyperledger.besu.ethereum.core.Wei;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.debug.TraceOptions;\n+import org.hyperledger.besu.ethereum.mainnet.AbstractPrecompiledContract;\n+import org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransaction;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionProcessor;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionReceipt;\n+import org.hyperledger.besu.ethereum.privacy.Restriction;\n+import org.hyperledger.besu.ethereum.privacy.group.OnChainGroupManagement;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateBlockMetadata;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateTransactionMetadata;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLP;\n+import org.hyperledger.besu.ethereum.vm.DebugOperationTracer;\n+import org.hyperledger.besu.ethereum.vm.GasCalculator;\n+import org.hyperledger.besu.ethereum.vm.MessageFrame;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.Base64;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class OnChainPrivacyPrecompiledContract extends AbstractPrecompiledContract {\n+\n+  // Dummy signature for transactions to not fail being processed.\n+  private static final SECP256K1.Signature FAKE_SIGNATURE =\n+      SECP256K1.Signature.create(SECP256K1.HALF_CURVE_ORDER, SECP256K1.HALF_CURVE_ORDER, (byte) 0);\n+\n+  private final Enclave enclave;\n+  private final WorldStateArchive privateWorldStateArchive;\n+  private final PrivateStateStorage privateStateStorage;\n+  private final PrivateStateRootResolver privateStateRootResolver;\n+  private PrivateTransactionProcessor privateTransactionProcessor;\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  public OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator, final PrivacyParameters privacyParameters) {\n+    this(\n+        gasCalculator,\n+        privacyParameters.getEnclave(),\n+        privacyParameters.getPrivateWorldStateArchive(),\n+        privacyParameters.getPrivateStateStorage());\n+  }\n+\n+  OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator,\n+      final Enclave enclave,\n+      final WorldStateArchive worldStateArchive,\n+      final PrivateStateStorage privateStateStorage) {\n+    super(\"OnChainPrivacy\", gasCalculator);\n+    this.enclave = enclave;\n+    this.privateWorldStateArchive = worldStateArchive;\n+    this.privateStateStorage = privateStateStorage;\n+    this.privateStateRootResolver = new PrivateStateRootResolver(privateStateStorage);\n+  }\n+\n+  public void setPrivateTransactionProcessor(\n+      final PrivateTransactionProcessor privateTransactionProcessor) {\n+    this.privateTransactionProcessor = privateTransactionProcessor;\n+  }\n+\n+  @Override\n+  public Gas gasRequirement(final Bytes input) {\n+    return Gas.of(0L);\n+  }\n+\n+  @Override\n+  public Bytes compute(final Bytes input, final MessageFrame messageFrame) {\n+    final ProcessableBlockHeader currentBlockHeader = messageFrame.getBlockHeader();\n+    if (!BlockHeader.class.isAssignableFrom(currentBlockHeader.getClass())) {\n+      if (!messageFrame.isPersistingPrivateState()) {\n+        // We get in here from block mining.\n+        return Bytes.EMPTY;\n+      } else {\n+        throw new IllegalArgumentException(\n+            \"The MessageFrame contains an illegal block header type. Cannot persist private block metadata without current block hash.\");\n+      }\n+    }\n+    final Hash currentBlockHash = ((BlockHeader) currentBlockHeader).getHash();\n+\n+    final String key = input.slice(0, 32).toBase64String();\n+\n+    final ReceiveResponse receiveResponse;\n+    try {\n+      receiveResponse = enclave.receive(key);\n+    } catch (final EnclaveClientException e) {\n+      LOG.debug(\"Can not fetch private transaction payload with key {}\", key, e);\n+      return Bytes.EMPTY;\n+    } catch (final EnclaveServerException e) {\n+      LOG.error(\"Enclave is responding but errored perhaps it has a misconfiguration?\", e);\n+      throw e;\n+    } catch (final EnclaveIOException e) {\n+      LOG.error(\"Can not communicate with enclave is it up?\", e);\n+      throw e;\n+    }\n+\n+    final BytesValueRLPInput bytesValueRLPInput =\n+        new BytesValueRLPInput(\n+            Bytes.wrap(Base64.getDecoder().decode(receiveResponse.getPayload())), false);\n+    bytesValueRLPInput.enterList();\n+    final PrivateTransaction privateTransaction = PrivateTransaction.readFrom(bytesValueRLPInput);\n+    final Optional<Bytes32> versionOptional;\n+    if (!bytesValueRLPInput.isEndOfCurrentList()) {\n+      versionOptional = Optional.of(bytesValueRLPInput.readBytes32());\n+    } else {\n+      versionOptional = Optional.of(Bytes32.ZERO);\n+    }\n+    bytesValueRLPInput.leaveList();\n+\n+    final WorldUpdater publicWorldState = messageFrame.getWorldState();\n+\n+    final Optional<Bytes> maybeGroupId = privateTransaction.getPrivacyGroupId();\n+    if (maybeGroupId.isEmpty()) {\n+      return Bytes.EMPTY;\n+    }\n+\n+    final Bytes32 privacyGroupId = Bytes32.wrap(maybeGroupId.get());\n+\n+    LOG.trace(\n+        \"Processing private transaction {} in privacy group {}\",\n+        privateTransaction.getHash(),\n+        privacyGroupId);\n+\n+    final PrivacyGroupHeadBlockMap privacyGroupHeadBlockMap =\n+        privateStateStorage.getPrivacyGroupHeadBlockMap(currentBlockHash).orElseThrow();\n+\n+    final Blockchain blockchain = messageFrame.getBlockchain();\n+\n+    final Hash lastRootHash =\n+        privateStateRootResolver.resolveLastStateRoot(privacyGroupId, currentBlockHash);\n+\n+    LOG.info(\"Last root hash: {}\", lastRootHash.toHexString());\n+\n+    final MutableWorldState disposablePrivateState =\n+        privateWorldStateArchive.getMutable(lastRootHash).get();\n+\n+    final WorldUpdater privateWorldStateUpdater = disposablePrivateState.updater();\n+\n+    maybeInjectDefaultManagementAndProxy(\n+        lastRootHash, disposablePrivateState, privateWorldStateUpdater);\n+\n+    final PrivateTransactionProcessor.Result canExecuteResult =\n+        checkCanExecute(\n+            messageFrame,\n+            currentBlockHeader,\n+            publicWorldState,\n+            privacyGroupId,\n+            blockchain,\n+            disposablePrivateState,\n+            privateWorldStateUpdater,\n+            OnChainGroupManagement.CAN_EXECUTE_METHOD_SIGNATURE);\n+\n+    if (privateTransaction.getPayload().toHexString().startsWith(\"0xf744b089\")\n+        && !canExecuteResult.getOutput().toHexString().endsWith(\"0\")) {\n+      LOG.info(\n+          \"Privacy Group {} is not locked while trying to add to group with commitment {}\",\n+          privacyGroupId.toHexString(),\n+          messageFrame.getTransactionHash());\n+      return Bytes.EMPTY;\n+    }\n+\n+    if (!privateTransaction.getPayload().toHexString().startsWith(\"0xf744b089\")\n+        && canExecuteResult.getOutput().toHexString().endsWith(\"0\")) {\n+      LOG.info(\n+          \"Privacy Group {} is locked while trying to execute transaction with commitment {}\",\n+          privacyGroupId.toHexString(),\n+          messageFrame.getTransactionHash());\n+      return Bytes.EMPTY;\n+    }\n+\n+    if (!onChainVersionMatches(\n+        messageFrame,\n+        currentBlockHeader,\n+        versionOptional,\n+        publicWorldState,\n+        privacyGroupId,\n+        blockchain,\n+        disposablePrivateState,\n+        privateWorldStateUpdater)) return Bytes.EMPTY;", "originalCommit": "8908e6ebf53087c08cffdcce878a349349d086dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY4NTY0OQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r383685649", "bodyText": "It looks like this method isn't being used. Did we forget to use it or should we remove it?", "author": "lucassaldanha", "createdAt": "2020-02-25T06:45:43Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/PrivacyBlockProcessor.java", "diffHunk": "@@ -51,4 +123,37 @@ public Result processBlock(\n         .commit();\n     return blockProcessor.processBlock(blockchain, worldState, blockHeader, transactions, ommers);\n   }\n+\n+  protected void rehydratePrivacyGroupHeadBlockMap(", "originalCommit": "8908e6ebf53087c08cffdcce878a349349d086dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyNTA5OQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384525099", "bodyText": "yes - this is moved inside PrivateStateRehydration", "author": "iikirilov", "createdAt": "2020-02-26T14:27:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY4NTY0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU3MDIxMQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387570211", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T10:17:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY4NTY0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY4NjUwMg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r383686502", "bodyText": "It looks like we either read the version or default it to zero. If this is the case, why do we need the Optional here?", "author": "lucassaldanha", "createdAt": "2020-02-25T06:48:27Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/OnChainPrivacyPrecompiledContract.java", "diffHunk": "@@ -0,0 +1,444 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.mainnet.precompiles.privacy;\n+\n+import static org.hyperledger.besu.crypto.Hash.keccak256;\n+import static org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver.EMPTY_ROOT_HASH;\n+\n+import org.hyperledger.besu.crypto.SECP256K1;\n+import org.hyperledger.besu.enclave.Enclave;\n+import org.hyperledger.besu.enclave.EnclaveClientException;\n+import org.hyperledger.besu.enclave.EnclaveIOException;\n+import org.hyperledger.besu.enclave.EnclaveServerException;\n+import org.hyperledger.besu.enclave.types.ReceiveResponse;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.DefaultEvmAccount;\n+import org.hyperledger.besu.ethereum.core.Gas;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableAccount;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.PrivacyParameters;\n+import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;\n+import org.hyperledger.besu.ethereum.core.Wei;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.debug.TraceOptions;\n+import org.hyperledger.besu.ethereum.mainnet.AbstractPrecompiledContract;\n+import org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransaction;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionProcessor;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionReceipt;\n+import org.hyperledger.besu.ethereum.privacy.Restriction;\n+import org.hyperledger.besu.ethereum.privacy.group.OnChainGroupManagement;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateBlockMetadata;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateTransactionMetadata;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLP;\n+import org.hyperledger.besu.ethereum.vm.DebugOperationTracer;\n+import org.hyperledger.besu.ethereum.vm.GasCalculator;\n+import org.hyperledger.besu.ethereum.vm.MessageFrame;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.Base64;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class OnChainPrivacyPrecompiledContract extends AbstractPrecompiledContract {\n+\n+  // Dummy signature for transactions to not fail being processed.\n+  private static final SECP256K1.Signature FAKE_SIGNATURE =\n+      SECP256K1.Signature.create(SECP256K1.HALF_CURVE_ORDER, SECP256K1.HALF_CURVE_ORDER, (byte) 0);\n+\n+  private final Enclave enclave;\n+  private final WorldStateArchive privateWorldStateArchive;\n+  private final PrivateStateStorage privateStateStorage;\n+  private final PrivateStateRootResolver privateStateRootResolver;\n+  private PrivateTransactionProcessor privateTransactionProcessor;\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  public OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator, final PrivacyParameters privacyParameters) {\n+    this(\n+        gasCalculator,\n+        privacyParameters.getEnclave(),\n+        privacyParameters.getPrivateWorldStateArchive(),\n+        privacyParameters.getPrivateStateStorage());\n+  }\n+\n+  OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator,\n+      final Enclave enclave,\n+      final WorldStateArchive worldStateArchive,\n+      final PrivateStateStorage privateStateStorage) {\n+    super(\"OnChainPrivacy\", gasCalculator);\n+    this.enclave = enclave;\n+    this.privateWorldStateArchive = worldStateArchive;\n+    this.privateStateStorage = privateStateStorage;\n+    this.privateStateRootResolver = new PrivateStateRootResolver(privateStateStorage);\n+  }\n+\n+  public void setPrivateTransactionProcessor(\n+      final PrivateTransactionProcessor privateTransactionProcessor) {\n+    this.privateTransactionProcessor = privateTransactionProcessor;\n+  }\n+\n+  @Override\n+  public Gas gasRequirement(final Bytes input) {\n+    return Gas.of(0L);\n+  }\n+\n+  @Override\n+  public Bytes compute(final Bytes input, final MessageFrame messageFrame) {\n+    final ProcessableBlockHeader currentBlockHeader = messageFrame.getBlockHeader();\n+    if (!BlockHeader.class.isAssignableFrom(currentBlockHeader.getClass())) {\n+      if (!messageFrame.isPersistingPrivateState()) {\n+        // We get in here from block mining.\n+        return Bytes.EMPTY;\n+      } else {\n+        throw new IllegalArgumentException(\n+            \"The MessageFrame contains an illegal block header type. Cannot persist private block metadata without current block hash.\");\n+      }\n+    }\n+    final Hash currentBlockHash = ((BlockHeader) currentBlockHeader).getHash();\n+\n+    final String key = input.slice(0, 32).toBase64String();\n+\n+    final ReceiveResponse receiveResponse;\n+    try {\n+      receiveResponse = enclave.receive(key);\n+    } catch (final EnclaveClientException e) {\n+      LOG.debug(\"Can not fetch private transaction payload with key {}\", key, e);\n+      return Bytes.EMPTY;\n+    } catch (final EnclaveServerException e) {\n+      LOG.error(\"Enclave is responding but errored perhaps it has a misconfiguration?\", e);\n+      throw e;\n+    } catch (final EnclaveIOException e) {\n+      LOG.error(\"Can not communicate with enclave is it up?\", e);\n+      throw e;\n+    }\n+\n+    final BytesValueRLPInput bytesValueRLPInput =\n+        new BytesValueRLPInput(\n+            Bytes.wrap(Base64.getDecoder().decode(receiveResponse.getPayload())), false);\n+    bytesValueRLPInput.enterList();\n+    final PrivateTransaction privateTransaction = PrivateTransaction.readFrom(bytesValueRLPInput);\n+    final Optional<Bytes32> versionOptional;", "originalCommit": "8908e6ebf53087c08cffdcce878a349349d086dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUzMzQ3Nw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384533477", "bodyText": "we don't default to zero", "author": "iikirilov", "createdAt": "2020-02-26T14:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY4NjUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDU0MzE4NQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384543185", "bodyText": "we do now :))", "author": "iikirilov", "createdAt": "2020-02-26T14:53:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY4NjUwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU3MDQ3Nw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387570477", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T10:18:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY4NjUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyMjA3MA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384322070", "bodyText": "I think we have to assume that the Version of the PG is always available when this contract is called. It should not be optional.", "author": "pinges", "createdAt": "2020-02-26T07:56:00Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/OnChainPrivacyPrecompiledContract.java", "diffHunk": "@@ -0,0 +1,444 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.mainnet.precompiles.privacy;\n+\n+import static org.hyperledger.besu.crypto.Hash.keccak256;\n+import static org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver.EMPTY_ROOT_HASH;\n+\n+import org.hyperledger.besu.crypto.SECP256K1;\n+import org.hyperledger.besu.enclave.Enclave;\n+import org.hyperledger.besu.enclave.EnclaveClientException;\n+import org.hyperledger.besu.enclave.EnclaveIOException;\n+import org.hyperledger.besu.enclave.EnclaveServerException;\n+import org.hyperledger.besu.enclave.types.ReceiveResponse;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.DefaultEvmAccount;\n+import org.hyperledger.besu.ethereum.core.Gas;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableAccount;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.PrivacyParameters;\n+import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;\n+import org.hyperledger.besu.ethereum.core.Wei;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.debug.TraceOptions;\n+import org.hyperledger.besu.ethereum.mainnet.AbstractPrecompiledContract;\n+import org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransaction;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionProcessor;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionReceipt;\n+import org.hyperledger.besu.ethereum.privacy.Restriction;\n+import org.hyperledger.besu.ethereum.privacy.group.OnChainGroupManagement;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateBlockMetadata;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateTransactionMetadata;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLP;\n+import org.hyperledger.besu.ethereum.vm.DebugOperationTracer;\n+import org.hyperledger.besu.ethereum.vm.GasCalculator;\n+import org.hyperledger.besu.ethereum.vm.MessageFrame;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.Base64;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class OnChainPrivacyPrecompiledContract extends AbstractPrecompiledContract {\n+\n+  // Dummy signature for transactions to not fail being processed.\n+  private static final SECP256K1.Signature FAKE_SIGNATURE =\n+      SECP256K1.Signature.create(SECP256K1.HALF_CURVE_ORDER, SECP256K1.HALF_CURVE_ORDER, (byte) 0);\n+\n+  private final Enclave enclave;\n+  private final WorldStateArchive privateWorldStateArchive;\n+  private final PrivateStateStorage privateStateStorage;\n+  private final PrivateStateRootResolver privateStateRootResolver;\n+  private PrivateTransactionProcessor privateTransactionProcessor;\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  public OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator, final PrivacyParameters privacyParameters) {\n+    this(\n+        gasCalculator,\n+        privacyParameters.getEnclave(),\n+        privacyParameters.getPrivateWorldStateArchive(),\n+        privacyParameters.getPrivateStateStorage());\n+  }\n+\n+  OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator,\n+      final Enclave enclave,\n+      final WorldStateArchive worldStateArchive,\n+      final PrivateStateStorage privateStateStorage) {\n+    super(\"OnChainPrivacy\", gasCalculator);\n+    this.enclave = enclave;\n+    this.privateWorldStateArchive = worldStateArchive;\n+    this.privateStateStorage = privateStateStorage;\n+    this.privateStateRootResolver = new PrivateStateRootResolver(privateStateStorage);\n+  }\n+\n+  public void setPrivateTransactionProcessor(\n+      final PrivateTransactionProcessor privateTransactionProcessor) {\n+    this.privateTransactionProcessor = privateTransactionProcessor;\n+  }\n+\n+  @Override\n+  public Gas gasRequirement(final Bytes input) {\n+    return Gas.of(0L);\n+  }\n+\n+  @Override\n+  public Bytes compute(final Bytes input, final MessageFrame messageFrame) {\n+    final ProcessableBlockHeader currentBlockHeader = messageFrame.getBlockHeader();\n+    if (!BlockHeader.class.isAssignableFrom(currentBlockHeader.getClass())) {\n+      if (!messageFrame.isPersistingPrivateState()) {\n+        // We get in here from block mining.\n+        return Bytes.EMPTY;\n+      } else {\n+        throw new IllegalArgumentException(\n+            \"The MessageFrame contains an illegal block header type. Cannot persist private block metadata without current block hash.\");\n+      }\n+    }\n+    final Hash currentBlockHash = ((BlockHeader) currentBlockHeader).getHash();\n+\n+    final String key = input.slice(0, 32).toBase64String();\n+\n+    final ReceiveResponse receiveResponse;\n+    try {\n+      receiveResponse = enclave.receive(key);\n+    } catch (final EnclaveClientException e) {\n+      LOG.debug(\"Can not fetch private transaction payload with key {}\", key, e);\n+      return Bytes.EMPTY;\n+    } catch (final EnclaveServerException e) {\n+      LOG.error(\"Enclave is responding but errored perhaps it has a misconfiguration?\", e);\n+      throw e;\n+    } catch (final EnclaveIOException e) {\n+      LOG.error(\"Can not communicate with enclave is it up?\", e);\n+      throw e;\n+    }\n+\n+    final BytesValueRLPInput bytesValueRLPInput =\n+        new BytesValueRLPInput(\n+            Bytes.wrap(Base64.getDecoder().decode(receiveResponse.getPayload())), false);\n+    bytesValueRLPInput.enterList();\n+    final PrivateTransaction privateTransaction = PrivateTransaction.readFrom(bytesValueRLPInput);\n+    final Optional<Bytes32> versionOptional;", "originalCommit": "8908e6ebf53087c08cffdcce878a349349d086dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyNDMwOQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384324309", "bodyText": "This is here because we have changed the RLP to being a list that contains the private transaction and the version.\nTo read that here we should have a class (e.g. VersionedPrivateTransaction) that reads the list. The version should always be available for transactions that end up in this precompile!", "author": "pinges", "createdAt": "2020-02-26T08:01:33Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/OnChainPrivacyPrecompiledContract.java", "diffHunk": "@@ -0,0 +1,444 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.mainnet.precompiles.privacy;\n+\n+import static org.hyperledger.besu.crypto.Hash.keccak256;\n+import static org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver.EMPTY_ROOT_HASH;\n+\n+import org.hyperledger.besu.crypto.SECP256K1;\n+import org.hyperledger.besu.enclave.Enclave;\n+import org.hyperledger.besu.enclave.EnclaveClientException;\n+import org.hyperledger.besu.enclave.EnclaveIOException;\n+import org.hyperledger.besu.enclave.EnclaveServerException;\n+import org.hyperledger.besu.enclave.types.ReceiveResponse;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.DefaultEvmAccount;\n+import org.hyperledger.besu.ethereum.core.Gas;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableAccount;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.PrivacyParameters;\n+import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;\n+import org.hyperledger.besu.ethereum.core.Wei;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.debug.TraceOptions;\n+import org.hyperledger.besu.ethereum.mainnet.AbstractPrecompiledContract;\n+import org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransaction;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionProcessor;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionReceipt;\n+import org.hyperledger.besu.ethereum.privacy.Restriction;\n+import org.hyperledger.besu.ethereum.privacy.group.OnChainGroupManagement;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateBlockMetadata;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateTransactionMetadata;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLP;\n+import org.hyperledger.besu.ethereum.vm.DebugOperationTracer;\n+import org.hyperledger.besu.ethereum.vm.GasCalculator;\n+import org.hyperledger.besu.ethereum.vm.MessageFrame;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.Base64;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class OnChainPrivacyPrecompiledContract extends AbstractPrecompiledContract {\n+\n+  // Dummy signature for transactions to not fail being processed.\n+  private static final SECP256K1.Signature FAKE_SIGNATURE =\n+      SECP256K1.Signature.create(SECP256K1.HALF_CURVE_ORDER, SECP256K1.HALF_CURVE_ORDER, (byte) 0);\n+\n+  private final Enclave enclave;\n+  private final WorldStateArchive privateWorldStateArchive;\n+  private final PrivateStateStorage privateStateStorage;\n+  private final PrivateStateRootResolver privateStateRootResolver;\n+  private PrivateTransactionProcessor privateTransactionProcessor;\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  public OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator, final PrivacyParameters privacyParameters) {\n+    this(\n+        gasCalculator,\n+        privacyParameters.getEnclave(),\n+        privacyParameters.getPrivateWorldStateArchive(),\n+        privacyParameters.getPrivateStateStorage());\n+  }\n+\n+  OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator,\n+      final Enclave enclave,\n+      final WorldStateArchive worldStateArchive,\n+      final PrivateStateStorage privateStateStorage) {\n+    super(\"OnChainPrivacy\", gasCalculator);\n+    this.enclave = enclave;\n+    this.privateWorldStateArchive = worldStateArchive;\n+    this.privateStateStorage = privateStateStorage;\n+    this.privateStateRootResolver = new PrivateStateRootResolver(privateStateStorage);\n+  }\n+\n+  public void setPrivateTransactionProcessor(\n+      final PrivateTransactionProcessor privateTransactionProcessor) {\n+    this.privateTransactionProcessor = privateTransactionProcessor;\n+  }\n+\n+  @Override\n+  public Gas gasRequirement(final Bytes input) {\n+    return Gas.of(0L);\n+  }\n+\n+  @Override\n+  public Bytes compute(final Bytes input, final MessageFrame messageFrame) {\n+    final ProcessableBlockHeader currentBlockHeader = messageFrame.getBlockHeader();\n+    if (!BlockHeader.class.isAssignableFrom(currentBlockHeader.getClass())) {\n+      if (!messageFrame.isPersistingPrivateState()) {\n+        // We get in here from block mining.\n+        return Bytes.EMPTY;\n+      } else {\n+        throw new IllegalArgumentException(\n+            \"The MessageFrame contains an illegal block header type. Cannot persist private block metadata without current block hash.\");\n+      }\n+    }\n+    final Hash currentBlockHash = ((BlockHeader) currentBlockHeader).getHash();\n+\n+    final String key = input.slice(0, 32).toBase64String();\n+\n+    final ReceiveResponse receiveResponse;\n+    try {\n+      receiveResponse = enclave.receive(key);\n+    } catch (final EnclaveClientException e) {\n+      LOG.debug(\"Can not fetch private transaction payload with key {}\", key, e);\n+      return Bytes.EMPTY;\n+    } catch (final EnclaveServerException e) {\n+      LOG.error(\"Enclave is responding but errored perhaps it has a misconfiguration?\", e);\n+      throw e;\n+    } catch (final EnclaveIOException e) {\n+      LOG.error(\"Can not communicate with enclave is it up?\", e);\n+      throw e;\n+    }\n+\n+    final BytesValueRLPInput bytesValueRLPInput =\n+        new BytesValueRLPInput(\n+            Bytes.wrap(Base64.getDecoder().decode(receiveResponse.getPayload())), false);\n+    bytesValueRLPInput.enterList();", "originalCommit": "8908e6ebf53087c08cffdcce878a349349d086dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyNTg5NQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384325895", "bodyText": "We cannot assume that the payload is a list at this point, as we might have private Txs in Orion, or we might have besus that are on the older version.\nI think the best would be if all payloads ending up here were rlp encoded as before, without the list!", "author": "pinges", "createdAt": "2020-02-26T08:05:31Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/PrivacyPrecompiledContract.java", "diffHunk": "@@ -126,7 +126,10 @@ public Bytes compute(final Bytes input, final MessageFrame messageFrame) {\n     final BytesValueRLPInput bytesValueRLPInput =\n         new BytesValueRLPInput(\n             Bytes.wrap(Base64.getDecoder().decode(receiveResponse.getPayload())), false);\n-    final PrivateTransaction privateTransaction = PrivateTransaction.readFrom(bytesValueRLPInput);\n+    bytesValueRLPInput.enterList();", "originalCommit": "8908e6ebf53087c08cffdcce878a349349d086dd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUxNjMyNQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384516325", "bodyText": "yes you are right!", "author": "iikirilov", "createdAt": "2020-02-26T14:13:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyNTg5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDUyNzAwMA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384527000", "bodyText": "i need like an enclave payload handler thing because there are 3 types of payloads now - the normal ones, versioned ones and blobs of data...", "author": "iikirilov", "createdAt": "2020-02-26T14:30:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyNTg5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMyODM2MQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384328361", "bodyText": "We have to execute the private transaction of a PMT before we are executing the PMT itself, because after the PMT is executed the beneficiary will be paid some wei, which means that the public state is changed.\nThis public state change does only happen once the private transaction for that PMT has been executed when it is executed in the normal way when importing a new block!\n(I hope that my explanation makes sense :-)", "author": "pinges", "createdAt": "2020-02-26T08:11:48Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivateGroupRehydrationBlockProcessor.java", "diffHunk": "@@ -0,0 +1,307 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy;\n+\n+import static org.hyperledger.besu.crypto.Hash.keccak256;\n+import static org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver.EMPTY_ROOT_HASH;\n+\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.DefaultEvmAccount;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableAccount;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;\n+import org.hyperledger.besu.ethereum.core.Transaction;\n+import org.hyperledger.besu.ethereum.core.TransactionReceipt;\n+import org.hyperledger.besu.ethereum.core.Wei;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.mainnet.AbstractBlockProcessor;\n+import org.hyperledger.besu.ethereum.mainnet.MainnetBlockProcessor;\n+import org.hyperledger.besu.ethereum.mainnet.MiningBeneficiaryCalculator;\n+import org.hyperledger.besu.ethereum.mainnet.TransactionProcessor;\n+import org.hyperledger.besu.ethereum.mainnet.TransactionValidationParams;\n+import org.hyperledger.besu.ethereum.privacy.group.OnChainGroupManagement;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateBlockMetadata;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateTransactionMetadata;\n+import org.hyperledger.besu.ethereum.rlp.RLP;\n+import org.hyperledger.besu.ethereum.vm.BlockHashLookup;\n+import org.hyperledger.besu.ethereum.vm.OperationTracer;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class PrivateGroupRehydrationBlockProcessor {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  static final int MAX_GENERATION = 6;\n+\n+  private final TransactionProcessor transactionProcessor;\n+  private final PrivateTransactionProcessor privateTransactionProcessor;\n+  private final MainnetBlockProcessor.TransactionReceiptFactory transactionReceiptFactory;\n+  final Wei blockReward;\n+  private final boolean skipZeroBlockRewards;\n+  private final MiningBeneficiaryCalculator miningBeneficiaryCalculator;\n+\n+  public PrivateGroupRehydrationBlockProcessor(\n+      final TransactionProcessor transactionProcessor,\n+      final PrivateTransactionProcessor privateTransactionProcessor,\n+      final MainnetBlockProcessor.TransactionReceiptFactory transactionReceiptFactory,\n+      final Wei blockReward,\n+      final MiningBeneficiaryCalculator miningBeneficiaryCalculator,\n+      final boolean skipZeroBlockRewards) {\n+    this.transactionProcessor = transactionProcessor;\n+    this.privateTransactionProcessor = privateTransactionProcessor;\n+    this.transactionReceiptFactory = transactionReceiptFactory;\n+    this.blockReward = blockReward;\n+    this.miningBeneficiaryCalculator = miningBeneficiaryCalculator;\n+    this.skipZeroBlockRewards = skipZeroBlockRewards;\n+  }\n+\n+  public AbstractBlockProcessor.Result processBlock(\n+      final Blockchain blockchain,\n+      final MutableWorldState worldState,\n+      final WorldStateArchive privateWorldStateArchive,\n+      final PrivateStateStorage privateStateStorage,\n+      final Block block,\n+      final Map<Hash, PrivateTransaction> forExecution,\n+      final List<BlockHeader> ommers) {\n+    long gasUsed = 0;\n+    final List<TransactionReceipt> receipts = new ArrayList<>();\n+\n+    final List<Transaction> transactions = block.getBody().getTransactions();\n+    final BlockHeader blockHeader = block.getHeader();\n+    for (final Transaction transaction : transactions) {\n+      final long remainingGasBudget = blockHeader.getGasLimit() - gasUsed;\n+      if (Long.compareUnsigned(transaction.getGasLimit(), remainingGasBudget) > 0) {\n+        LOG.warn(\n+            \"Transaction processing error: transaction gas limit {} exceeds available block budget remaining {}\",\n+            transaction.getGasLimit(),\n+            remainingGasBudget);\n+        return AbstractBlockProcessor.Result.failed();\n+      }\n+\n+      final WorldUpdater worldStateUpdater = worldState.updater();\n+      final BlockHashLookup blockHashLookup = new BlockHashLookup(blockHeader, blockchain);\n+      final Address miningBeneficiary =\n+          miningBeneficiaryCalculator.calculateBeneficiary(blockHeader);\n+\n+      final TransactionProcessor.Result result =\n+          transactionProcessor.processTransaction(\n+              blockchain,\n+              worldStateUpdater,\n+              blockHeader,\n+              transaction,\n+              miningBeneficiary,\n+              blockHashLookup,\n+              true,\n+              TransactionValidationParams.processingBlock());\n+      if (result.isInvalid()) {\n+        return AbstractBlockProcessor.Result.failed();\n+      }\n+\n+      worldStateUpdater.commit();\n+      gasUsed = transaction.getGasLimit() - result.getGasRemaining() + gasUsed;\n+      final TransactionReceipt transactionReceipt =\n+          transactionReceiptFactory.create(result, worldState, gasUsed);\n+      receipts.add(transactionReceipt);\n+\n+      final PrivateStateRootResolver privateStateRootResolver =\n+          new PrivateStateRootResolver(privateStateStorage);\n+      final PrivateTransaction privateTransaction = forExecution.get(transaction.getHash());\n+      if (forExecution.containsKey(transaction.getHash())) {\n+        final Hash lastRootHash =\n+            privateStateRootResolver.resolveLastStateRoot(\n+                Bytes32.wrap(privateTransaction.getPrivacyGroupId().get()),\n+                blockHeader.getParentHash());\n+\n+        final MutableWorldState disposablePrivateState =\n+            privateWorldStateArchive.getMutable(lastRootHash).get();\n+        final WorldUpdater privateStateUpdater = disposablePrivateState.updater();\n+        maybeInjectDefaultManagementAndProxy(\n+            lastRootHash, disposablePrivateState, privateStateUpdater);\n+        LOG.info(\n+            \"Pre-rehydrate root hash: {} for tx {}\",\n+            disposablePrivateState.rootHash(),\n+            privateTransaction.getHash());\n+\n+        final PrivateTransactionProcessor.Result privateResult =", "originalCommit": "8908e6ebf53087c08cffdcce878a349349d086dd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "de88c20c7559d088317922749199400274d03f59", "url": "https://github.com/hyperledger/besu/commit/de88c20c7559d088317922749199400274d03f59", "message": "Adds privacy contracts (#4)\n\n* Adds privacy contracts, however web3j-evm issue prevents tests passing\n\nSigned-off-by: Joshua Richardson <joshua@richardson.tech>\n\n* Refactor tests\n\nSigned-off-by: Joshua Richardson <joshua@richardson.tech>\n\n* Various small changes\n\nSigned-off-by: Joshua Richardson <joshua@richardson.tech>\n\n* Reverts to older web3j version\n\nSigned-off-by: Joshua Richardson <joshua@richardson.tech>\n\n* Back to sane package naming now that we've figured out the test bug\n\nSigned-off-by: Joshua Richardson <joshua@richardson.tech>\n\n* Allow deploying of contracts with params in constructor\n\nSigned-off-by: Joshua Richardson <joshua@richardson.tech>\n\n* Addresses PR comments\n\nSigned-off-by: Joshua Richardson <joshua@richardson.tech>", "committedDate": "2020-02-26T19:50:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg3ODYyNg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384878626", "bodyText": "You can be more precise by making sure that the order of the types is the same", "author": "pinges", "createdAt": "2020-02-27T02:17:46Z", "path": "acceptance-tests/dsl/src/main/java/org/hyperledger/besu/tests/acceptance/dsl/transaction/DeploySmartContractTransaction.java", "diffHunk": "@@ -33,23 +36,55 @@\n       Credentials.create(Accounts.GENESIS_ACCOUNT_ONE_PRIVATE_KEY);\n \n   private final Class<T> clazz;\n+  private final Object[] args;\n \n-  public DeploySmartContractTransaction(final Class<T> clazz) {\n+  public DeploySmartContractTransaction(final Class<T> clazz, final Object... args) {\n     this.clazz = clazz;\n+    this.args = args;\n   }\n \n   @Override\n+  @SuppressWarnings(\"rawtypes\")\n   public T execute(final NodeRequests node) {\n     try {\n-      final Method method =\n-          clazz.getMethod(\n-              \"deploy\", Web3j.class, Credentials.class, BigInteger.class, BigInteger.class);\n+      if (args != null && args.length != 0) {\n+        final ArrayList<Object> parameterObjects = new ArrayList<>();\n+        parameterObjects.addAll(\n+            Arrays.asList(node.eth(), BENEFACTOR_ONE, DEFAULT_GAS_PRICE, DEFAULT_GAS_LIMIT));\n+        parameterObjects.addAll(Arrays.asList(args));\n \n-      final Object invoked =\n-          method.invoke(\n-              METHOD_IS_STATIC, node.eth(), BENEFACTOR_ONE, DEFAULT_GAS_PRICE, DEFAULT_GAS_LIMIT);\n+        final ArrayList<Class> parameterTypes =\n+            parameterObjects.stream()\n+                .map(Object::getClass)\n+                .collect(Collectors.toCollection(ArrayList::new));\n+        parameterTypes.add(0, Web3j.class);\n+\n+        final Method method =\n+            Arrays.stream(clazz.getMethods())\n+                .filter(\n+                    i ->\n+                        i.getName().equals(\"deploy\")\n+                            && Arrays.stream(i.getParameterTypes())", "originalCommit": "de88c20c7559d088317922749199400274d03f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU4MTA5MQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387581091", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T10:36:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg3ODYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg3OTkxOA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384879918", "bodyText": "Is there something else than the default? Otherwise remove the DEFAULT_ please.", "author": "pinges", "createdAt": "2020-02-27T02:22:32Z", "path": "acceptance-tests/dsl/src/main/java/org/hyperledger/besu/tests/acceptance/dsl/transaction/privacy/PrivacyRequestFactory.java", "diffHunk": "@@ -14,26 +14,47 @@\n  */\n package org.hyperledger.besu.tests.acceptance.dsl.transaction.privacy;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static java.util.Collections.singletonList;\n \n+import org.hyperledger.besu.crypto.SecureRandomProvider;\n import org.hyperledger.besu.enclave.types.PrivacyGroup;\n import org.hyperledger.besu.ethereum.api.jsonrpc.internal.privacy.parameters.CreatePrivacyGroupParameter;\n import org.hyperledger.besu.ethereum.core.Address;\n import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyNode;\n import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivateTransactionGroupResponse;\n \n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.security.SecureRandom;\n import java.util.Collections;\n import java.util.List;\n+import java.util.stream.Collectors;\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.web3j.crypto.Credentials;\n import org.web3j.protocol.Web3jService;\n import org.web3j.protocol.besu.Besu;\n+import org.web3j.protocol.besu.response.privacy.PrivFindPrivacyGroup;\n import org.web3j.protocol.besu.response.privacy.PrivateTransactionReceipt;\n import org.web3j.protocol.core.Request;\n import org.web3j.protocol.core.Response;\n+import org.web3j.protocol.eea.crypto.PrivateTransactionEncoder;\n+import org.web3j.protocol.eea.crypto.RawPrivateTransaction;\n+import org.web3j.protocol.exceptions.TransactionException;\n+import org.web3j.tx.response.PollingPrivateTransactionReceiptProcessor;\n+import org.web3j.utils.Base64String;\n+import org.web3j.utils.Numeric;\n \n public class PrivacyRequestFactory {\n+  private static final Bytes DEFAULT_PRIVACY_ADD_METHOD_SIGNATURE =", "originalCommit": "de88c20c7559d088317922749199400274d03f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU4NTIwMw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387585203", "bodyText": "fixed - using the static onchaingroupmanagement fields", "author": "iikirilov", "createdAt": "2020-03-04T10:44:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg3OTkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg4MDAwMg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384880002", "bodyText": "s.a.", "author": "pinges", "createdAt": "2020-02-27T02:22:51Z", "path": "acceptance-tests/dsl/src/main/java/org/hyperledger/besu/tests/acceptance/dsl/transaction/privacy/PrivacyRequestFactory.java", "diffHunk": "@@ -14,26 +14,47 @@\n  */\n package org.hyperledger.besu.tests.acceptance.dsl.transaction.privacy;\n \n+import static com.google.common.base.Preconditions.checkArgument;\n import static java.util.Collections.singletonList;\n \n+import org.hyperledger.besu.crypto.SecureRandomProvider;\n import org.hyperledger.besu.enclave.types.PrivacyGroup;\n import org.hyperledger.besu.ethereum.api.jsonrpc.internal.privacy.parameters.CreatePrivacyGroupParameter;\n import org.hyperledger.besu.ethereum.core.Address;\n import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyNode;\n import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivateTransactionGroupResponse;\n \n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.security.SecureRandom;\n import java.util.Collections;\n import java.util.List;\n+import java.util.stream.Collectors;\n \n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.web3j.crypto.Credentials;\n import org.web3j.protocol.Web3jService;\n import org.web3j.protocol.besu.Besu;\n+import org.web3j.protocol.besu.response.privacy.PrivFindPrivacyGroup;\n import org.web3j.protocol.besu.response.privacy.PrivateTransactionReceipt;\n import org.web3j.protocol.core.Request;\n import org.web3j.protocol.core.Response;\n+import org.web3j.protocol.eea.crypto.PrivateTransactionEncoder;\n+import org.web3j.protocol.eea.crypto.RawPrivateTransaction;\n+import org.web3j.protocol.exceptions.TransactionException;\n+import org.web3j.tx.response.PollingPrivateTransactionReceiptProcessor;\n+import org.web3j.utils.Base64String;\n+import org.web3j.utils.Numeric;\n \n public class PrivacyRequestFactory {\n+  private static final Bytes DEFAULT_PRIVACY_ADD_METHOD_SIGNATURE =\n+      Bytes.fromHexString(\"0xf744b089\");\n+  private static final Bytes DEFAULT_PRIVACY_LOCK_METHOD_SIGNATURE =", "originalCommit": "de88c20c7559d088317922749199400274d03f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU4NTMwNA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387585304", "bodyText": "s.a.", "author": "iikirilov", "createdAt": "2020-03-04T10:44:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg4MDAwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg4OTkxMA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384889910", "bodyText": "maybe rename this method to createAddPayload or something?", "author": "pinges", "createdAt": "2020-02-27T03:02:58Z", "path": "acceptance-tests/dsl/src/main/java/org/hyperledger/besu/tests/acceptance/dsl/transaction/privacy/PrivacyRequestFactory.java", "diffHunk": "@@ -93,6 +115,122 @@ public String getTransactionKey() {\n     }\n   }\n \n+  public String privxAddToPrivacyGroup(\n+      final Base64String privacyGroupId, final PrivacyNode adder, final List<String> addresses)\n+      throws IOException, TransactionException {\n+\n+    final BigInteger nonce =\n+        besuClient\n+            .privGetTransactionCount(adder.getAddress().toHexString(), privacyGroupId)\n+            .send()\n+            .getTransactionCount();\n+\n+    final Bytes payload =\n+        encodeParameters(", "originalCommit": "de88c20c7559d088317922749199400274d03f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU4NTgzNg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387585836", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T10:45:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg4OTkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MDk1NA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384890954", "bodyText": "s/PrivxCreatePrivacyGroup/PrivxCreatePrivacyGroupResponse/", "author": "pinges", "createdAt": "2020-02-27T03:07:42Z", "path": "acceptance-tests/dsl/src/main/java/org/hyperledger/besu/tests/acceptance/dsl/transaction/privacy/PrivacyRequestFactory.java", "diffHunk": "@@ -167,4 +305,52 @@ public String getTransactionKey() {\n         web3jService,\n         GetTransactionCountResponse.class);\n   }\n+\n+  public static class PrivxCreatePrivacyGroup {", "originalCommit": "de88c20c7559d088317922749199400274d03f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU4Njk0NA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387586944", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T10:47:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MDk1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MjEyMQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384892121", "bodyText": "A constant would be nice, like TEST_KEY?", "author": "pinges", "createdAt": "2020-02-27T03:12:59Z", "path": "acceptance-tests/tests/src/test/java/org/hyperledger/besu/tests/acceptance/privacy/multitenancy/MultiTenancyAcceptanceTest.java", "diffHunk": "@@ -99,9 +99,9 @@ public void privGetPrivateTransactionSuccessShouldReturnExpectedPrivateTransacti\n     final PrivateTransaction validSignedPrivateTransaction =\n         getValidSignedPrivateTransaction(senderAddress);\n \n-    receiveEnclaveStub(getRLPOutput(validSignedPrivateTransaction));\n+    receiveEnclaveStub(validSignedPrivateTransaction);\n     retrievePrivacyGroupEnclaveStub();\n-    sendEnclaveStub(\"testKey\");\n+    sendEnclaveStub(\"sgFkVOyFndZe/5SAZJO5UYbrl7pezHetveriBBWWnE8=\");", "originalCommit": "de88c20c7559d088317922749199400274d03f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU4ODg2NQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387588865", "bodyText": "fixed - there is already a KEY1 field with this value in this test", "author": "iikirilov", "createdAt": "2020-03-04T10:51:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5MjEyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5NDQ2Nw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384894467", "bodyText": "You should be able to ensure they are happening in the right order by waiting for the transaction to be mined and imported, e.g. by doing the alice.verify(privateTransactionVerifier.validPrivateTransactionReceipt ...)", "author": "pinges", "createdAt": "2020-02-27T03:23:26Z", "path": "acceptance-tests/tests/src/test/java/org/hyperledger/besu/tests/web3j/privacy/OnChainPrivacyAcceptanceTest.java", "diffHunk": "@@ -0,0 +1,374 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.tests.web3j.privacy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.hyperledger.besu.crypto.SecureRandomProvider;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyAcceptanceTestBase;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyNode;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.privacy.PrivacyRequestFactory.PrivxCreatePrivacyGroup;\n+import org.hyperledger.besu.tests.web3j.generated.EventEmitter;\n+\n+import java.math.BigInteger;\n+import java.security.SecureRandom;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.web3j.protocol.besu.response.privacy.PrivacyGroup;\n+import org.web3j.protocol.besu.response.privacy.PrivateTransactionReceipt;\n+import org.web3j.protocol.core.methods.response.Log;\n+import org.web3j.protocol.core.methods.response.TransactionReceipt;\n+import org.web3j.utils.Base64String;\n+\n+public class OnChainPrivacyAcceptanceTest extends PrivacyAcceptanceTestBase {\n+  private static final long POW_CHAIN_ID = 2018;\n+\n+  private PrivacyNode alice;\n+  private PrivacyNode bob;\n+  private PrivacyNode charlie;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    alice =\n+        privacyBesu.createPrivateTransactionEnabledMinerNode(\n+            \"node1\", privacyAccountResolver.resolve(0), Address.PRIVACY);\n+    bob =\n+        privacyBesu.createPrivateTransactionEnabledNode(\n+            \"node2\", privacyAccountResolver.resolve(1), Address.PRIVACY);\n+    charlie =\n+        privacyBesu.createPrivateTransactionEnabledNode(\n+            \"node3\", privacyAccountResolver.resolve(2), Address.PRIVACY);\n+    privacyCluster.start(alice, bob, charlie);\n+  }\n+\n+  @Test\n+  public void nodeCanCreatePrivacyGroup() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice, alice, bob));\n+\n+    assertThat(privxCreatePrivacyGroup).isNotNull();\n+\n+    final PrivacyGroup expectedGroup =\n+        new PrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey(), bob.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    bob.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final String getParticipantsCallHash =\n+        alice.execute(\n+            privateContractTransactions.callOnChainPermissioningSmartContract(\n+                Address.PRIVACY_PROXY.toHexString(),\n+                \"0x0b0235be\" // get participants method signature\n+                    + Bytes.fromBase64String(alice.getEnclaveKey()).toUnprefixedHexString(),\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privxCreatePrivacyGroup.getPrivacyGroupId()));\n+\n+    final PrivateTransactionReceipt expectedReceipt =\n+        new PrivateTransactionReceipt(\n+            null,\n+            alice.getAddress().toHexString(),\n+            Address.PRIVACY_PROXY.toHexString(),\n+            \"0x0000000000000000000000000000000000000000000000000000000000000020\" // dynamic\n+                // array offset\n+                + \"0000000000000000000000000000000000000000000000000000000000000002\" // length\n+                // of array\n+                + Bytes.fromBase64String(alice.getEnclaveKey()).toUnprefixedHexString() // first\n+                // element\n+                + Bytes.fromBase64String(bob.getEnclaveKey()).toUnprefixedHexString(), // second\n+            // element\n+            Collections.emptyList(),\n+            null,\n+            null,\n+            alice.getEnclaveKey(),\n+            null,\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            \"0x1\",\n+            null);\n+\n+    alice.verify(\n+        privateTransactionVerifier.validPrivateTransactionReceipt(\n+            getParticipantsCallHash, expectedReceipt));\n+\n+    bob.verify(\n+        privateTransactionVerifier.validPrivateTransactionReceipt(\n+            getParticipantsCallHash, expectedReceipt));\n+  }\n+\n+  @Test\n+  public void deployingMustGiveValidReceipt() {\n+    final SecureRandom secureRandom = SecureRandomProvider.createSecureRandom();\n+    final byte[] bytes = new byte[32];\n+    secureRandom.nextBytes(bytes);\n+    final Bytes privacyGroupId = Bytes.wrap(bytes);\n+\n+    final EventEmitter eventEmitter =\n+        alice.execute(\n+            privateContractTransactions.createSmartContractWithPrivacyGroupId(\n+                EventEmitter.class,\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privacyGroupId.toBase64String()));\n+\n+    privateContractVerifier\n+        .validPrivateContractDeployed(\n+            eventEmitter.getContractAddress(), alice.getAddress().toString())\n+        .verify(eventEmitter);\n+  }\n+\n+  @Test\n+  public void canAddParticipantToGroup() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice, alice, bob));\n+\n+    assertThat(privxCreatePrivacyGroup).isNotNull();\n+\n+    final PrivacyGroup expectedGroup =\n+        new PrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey(), bob.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    bob.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final EventEmitter eventEmitter =\n+        alice.execute(\n+            privateContractTransactions.createSmartContractWithPrivacyGroupId(\n+                EventEmitter.class,\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privxCreatePrivacyGroup.getPrivacyGroupId()));\n+\n+    privateContractVerifier\n+        .validPrivateContractDeployed(\n+            eventEmitter.getContractAddress(), alice.getAddress().toString())\n+        .verify(eventEmitter);\n+\n+    alice.execute(\n+        privacyTransactions.privxLockContract(privxCreatePrivacyGroup.getPrivacyGroupId(), alice));\n+\n+    alice.execute(\n+        privacyTransactions.addToPrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(), alice, charlie));\n+\n+    final PrivacyGroup expectedGroupAfterCharlieIsAdded =\n+        new PrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(\n+                alice.getEnclaveKey(), bob.getEnclaveKey(), charlie.getEnclaveKey()));\n+\n+    alice.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+\n+    bob.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+\n+    charlie.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+  }\n+\n+  // Depends on transaction ordering enforced in the test,", "originalCommit": "de88c20c7559d088317922749199400274d03f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU4OTAzNw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387589037", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T10:51:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg5NDQ2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkwNzI1Mg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384907252", "bodyText": "I think we should fail if there are no participants! It does not make sense to have a group without members, because nobody can use it!!", "author": "pinges", "createdAt": "2020-02-27T04:26:07Z", "path": "acceptance-tests/tests/src/test/java/org/hyperledger/besu/tests/web3j/privacy/contracts/PrivacyGroupTest.java", "diffHunk": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.tests.web3j.privacy.contracts;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.hyperledger.besu.privacy.contracts.generated.PrivacyGroup;\n+import org.hyperledger.besu.tests.acceptance.dsl.AcceptanceTestBase;\n+import org.hyperledger.besu.tests.acceptance.dsl.node.BesuNode;\n+\n+import java.math.BigInteger;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.web3j.protocol.exceptions.TransactionException;\n+import org.web3j.utils.Base64String;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class PrivacyGroupTest extends AcceptanceTestBase {\n+\n+  private final Base64String firstParticipant =\n+      Base64String.wrap(\"A1aVtMxLCUHmBVHXoZzzBgPbW/wj5axDpW9X8l91SGo=\");\n+  private final Base64String secondParticipant =\n+      Base64String.wrap(\"Ko2bVqD+nNlNYL5EE7y3IdOnviftjiizpjRt+HTuFBs=\");\n+  private final Base64String thirdParticipant =\n+      Base64String.wrap(\"Jo2bVqD+nNlNYL5EE7y3IdOnviftjiizpjRt+HTuFBs=\");\n+  private PrivacyGroup privacyGroup;\n+\n+  private static final String RAW_FIRST_PARTICIPANT =\n+      \"0x0b0235be035695b4cc4b0941e60551d7a19cf30603db5bfc23e5ac43a56f57f25f75486a\";\n+  private static final String RAW_ADD_PARTICIPANT =\n+      \"0xf744b089035695b4cc4b0941e60551d7a19cf30603db5bfc23e5ac43a56f57f25f75486a000000000000000000000000000000000000000000000000000000000000004000000000000000000000000000000000000000000000000000000000000000012a8d9b56a0fe9cd94d60be4413bcb721d3a7be27ed8e28b3a6346df874ee141b\";\n+  private static final String RAW_LOCK = \"0xf83d08ba\";\n+  private static final String RAW_UNLOCK = \"0xa69df4b5\";\n+  private static final String RAW_CAN_EXECUTE = \"0x78b90337\";\n+  private static final String RAW_GET_VERSION = \"0x0d8e6e2c\";\n+\n+  private BesuNode minerNode;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    minerNode = besu.createMinerNode(\"node\");\n+    cluster.start(minerNode);\n+    privacyGroup = minerNode.execute(contractTransactions.createSmartContract(PrivacyGroup.class));\n+  }\n+\n+  @Test\n+  public void rlp() throws Exception {\n+    final String contractAddress = \"0x42699a7612a82f1d9c36148af9c77354759b210b\";\n+    assertThat(privacyGroup.isValid()).isEqualTo(true);\n+    contractVerifier.validTransactionReceipt(contractAddress).verify(privacyGroup);\n+    // 0x0b0235be\n+    assertThat(RAW_FIRST_PARTICIPANT)\n+        .isEqualTo(privacyGroup.getParticipants(firstParticipant.raw()).encodeFunctionCall());\n+    // 0xf744b089\n+    assertThat(RAW_ADD_PARTICIPANT)\n+        .isEqualTo(\n+            privacyGroup\n+                .addParticipants(\n+                    firstParticipant.raw(), Collections.singletonList(secondParticipant.raw()))\n+                .encodeFunctionCall());\n+    assertThat(RAW_LOCK).isEqualTo(privacyGroup.lock().encodeFunctionCall());\n+    assertThat(RAW_UNLOCK).isEqualTo(privacyGroup.unlock().encodeFunctionCall());\n+    assertThat(RAW_CAN_EXECUTE).isEqualTo(privacyGroup.canExecute().encodeFunctionCall());\n+    assertThat(RAW_GET_VERSION).isEqualTo(privacyGroup.getVersion().encodeFunctionCall());\n+  }\n+\n+  @Test\n+  @Ignore(\"returns '0x' which causes web3j to throw exception instead of return empty list\")\n+  public void deploysWithZeroParticipant() throws Exception {", "originalCommit": "de88c20c7559d088317922749199400274d03f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA1NzA1NA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r385057054", "bodyText": "it is part of the injection process - implicitly whoever created the group is in the group because it is injected. However for this to work the contract should have no constructor - this is why the test is here.\nIn the future, if/when we refactor the proxy contract to better we can remove this", "author": "iikirilov", "createdAt": "2020-02-27T11:02:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkwNzI1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkxMTUxMA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384911510", "bodyText": "s/send/participants/", "author": "pinges", "createdAt": "2020-02-27T04:47:02Z", "path": "acceptance-tests/tests/src/test/java/org/hyperledger/besu/tests/web3j/privacy/contracts/PrivacyProxyTest.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.tests.web3j.privacy.contracts;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.hyperledger.besu.privacy.contracts.generated.PrivacyGroup;\n+import org.hyperledger.besu.privacy.contracts.generated.PrivacyProxy;\n+import org.hyperledger.besu.tests.acceptance.dsl.AcceptanceTestBase;\n+import org.hyperledger.besu.tests.acceptance.dsl.node.BesuNode;\n+\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.web3j.utils.Base64String;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class PrivacyProxyTest extends AcceptanceTestBase {\n+\n+  private final Base64String firstParticipant =\n+      Base64String.wrap(\"93Ky7lXwFkMc7+ckoFgUMku5bpr9tz4zhmWmk9RlNng=\");\n+  private final Base64String secondParticipant =\n+      Base64String.wrap(\"9iaJ6OObl6TUWYjXAOyZsL0VaDPwF+tRFkMwwYSeqqw=\");\n+  private final Base64String thirdParticipant =\n+      Base64String.wrap(\"Jo2bVqD+nNlNYL5EE7y3IdOnviftjiizpjRt+HTuFBs=\");\n+  private PrivacyProxy privacyProxy;\n+\n+  private static final String RAW_FIRST_PARTICIPANT =\n+      \"0x0b0235bef772b2ee55f016431cefe724a05814324bb96e9afdb73e338665a693d4653678\";\n+  private static final String RAW_ADD_PARTICIPANT =\n+      \"0xf744b089f772b2ee55f016431cefe724a05814324bb96e9afdb73e338665a693d465367800000000000000000000000000000000000000000000000000000000000000400000000000000000000000000000000000000000000000000000000000000000\";\n+\n+  private BesuNode minerNode;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    minerNode = besu.createMinerNode(\"node\");\n+    cluster.start(minerNode);\n+    PrivacyGroup privacyGroup =\n+        minerNode.execute(contractTransactions.createSmartContract(PrivacyGroup.class));\n+    privacyProxy =\n+        minerNode.execute(\n+            contractTransactions.createSmartContract(\n+                PrivacyProxy.class, privacyGroup.getContractAddress()));\n+  }\n+\n+  @Test\n+  public void rlp() throws Exception {\n+    assertThat(privacyProxy.isValid()).isEqualTo(true);\n+    contractVerifier\n+        .validTransactionReceipt(privacyProxy.getContractAddress())\n+        .verify(privacyProxy);\n+    // 0x0b0235be\n+    assertThat(RAW_FIRST_PARTICIPANT)\n+        .isEqualTo(privacyProxy.getParticipants(firstParticipant.raw()).encodeFunctionCall());\n+    // 0xf744b089\n+    assertThat(RAW_ADD_PARTICIPANT)\n+        .isEqualTo(\n+            privacyProxy\n+                .addParticipants(firstParticipant.raw(), Collections.emptyList())\n+                .encodeFunctionCall());\n+  }\n+\n+  @Ignore(\"return 0x which causes web3j to throw exception instead of return empty list\")\n+  @Test\n+  public void deploysWithNoParticipant() throws Exception {\n+    final List<byte[]> send = privacyProxy.getParticipants(firstParticipant.raw()).send();\n+    assertThat(send.size()).isEqualTo(0);\n+  }\n+\n+  @Test\n+  public void canAddParticipants() throws Exception {\n+    privacyProxy\n+        .addParticipants(firstParticipant.raw(), Collections.singletonList(secondParticipant.raw()))\n+        .send();\n+    final List<byte[]> send = privacyProxy.getParticipants(firstParticipant.raw()).send();\n+    assertThat(send.size()).isEqualTo(2);\n+    assertThat(firstParticipant.raw()).isEqualTo(send.get(0));\n+    assertThat(secondParticipant.raw()).isEqualTo(send.get(1));\n+  }\n+\n+  @Test\n+  public void canUpgrade() throws Exception {\n+    privacyProxy\n+        .addParticipants(firstParticipant.raw(), Collections.singletonList(secondParticipant.raw()))\n+        .send();\n+    final List<byte[]> send = privacyProxy.getParticipants(firstParticipant.raw()).send();\n+    assertThat(send.size()).isEqualTo(2);\n+    assertThat(firstParticipant.raw()).isEqualTo(send.get(0));\n+    assertThat(secondParticipant.raw()).isEqualTo(send.get(1));\n+\n+    final PrivacyGroup upgradedContract =\n+        minerNode.execute(contractTransactions.createSmartContract(PrivacyGroup.class));\n+\n+    privacyProxy.upgradeTo(upgradedContract.getContractAddress()).send();\n+    privacyProxy\n+        .addParticipants(firstParticipant.raw(), Collections.singletonList(secondParticipant.raw()))\n+        .send();\n+    final List<byte[]> send2 = privacyProxy.getParticipants(firstParticipant.raw()).send();\n+    assertThat(send2.size()).isEqualTo(2);\n+    assertThat(firstParticipant.raw()).isEqualTo(send2.get(0));\n+    assertThat(secondParticipant.raw()).isEqualTo(send2.get(1));\n+  }\n+\n+  @Test\n+  public void canAddTwiceToContractWhenCallLock() throws Exception {\n+    privacyProxy\n+        .addParticipants(firstParticipant.raw(), Collections.singletonList(thirdParticipant.raw()))\n+        .send();\n+    privacyProxy.lock().send();\n+    privacyProxy\n+        .addParticipants(firstParticipant.raw(), Collections.singletonList(secondParticipant.raw()))\n+        .send();\n+    final List<byte[]> send = privacyProxy.getParticipants(firstParticipant.raw()).send();", "originalCommit": "de88c20c7559d088317922749199400274d03f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU5MDUyMw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387590523", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T10:54:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkxMTUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkxMjg5Mg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384912892", "bodyText": "can we use the VersionedPrivacyTransaction here?", "author": "pinges", "createdAt": "2020-02-27T04:53:48Z", "path": "ethereum/api/src/integration-test/java/org/hyperledger/besu/ethereum/api/jsonrpc/methods/PrivGetPrivateTransactionIntegrationTest.java", "diffHunk": "@@ -158,7 +158,9 @@ public void returnsStoredPrivateTransaction() {\n     when(returnedTransaction.getTransaction()).thenReturn(justTransaction);\n \n     final BytesValueRLPOutput bvrlp = new BytesValueRLPOutput();\n+    bvrlp.startList();", "originalCommit": "de88c20c7559d088317922749199400274d03f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU5MDk2NA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387590964", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T10:55:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkxMjg5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzNzQwMQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384937401", "bodyText": "How does this work? You have not created the privacy group yet?", "author": "pinges", "createdAt": "2020-02-27T06:39:36Z", "path": "acceptance-tests/tests/src/test/java/org/hyperledger/besu/tests/web3j/privacy/OnChainPrivacyAcceptanceTest.java", "diffHunk": "@@ -0,0 +1,374 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.tests.web3j.privacy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.hyperledger.besu.crypto.SecureRandomProvider;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyAcceptanceTestBase;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyNode;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.privacy.PrivacyRequestFactory.PrivxCreatePrivacyGroup;\n+import org.hyperledger.besu.tests.web3j.generated.EventEmitter;\n+\n+import java.math.BigInteger;\n+import java.security.SecureRandom;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.web3j.protocol.besu.response.privacy.PrivacyGroup;\n+import org.web3j.protocol.besu.response.privacy.PrivateTransactionReceipt;\n+import org.web3j.protocol.core.methods.response.Log;\n+import org.web3j.protocol.core.methods.response.TransactionReceipt;\n+import org.web3j.utils.Base64String;\n+\n+public class OnChainPrivacyAcceptanceTest extends PrivacyAcceptanceTestBase {\n+  private static final long POW_CHAIN_ID = 2018;\n+\n+  private PrivacyNode alice;\n+  private PrivacyNode bob;\n+  private PrivacyNode charlie;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    alice =\n+        privacyBesu.createPrivateTransactionEnabledMinerNode(\n+            \"node1\", privacyAccountResolver.resolve(0), Address.PRIVACY);\n+    bob =\n+        privacyBesu.createPrivateTransactionEnabledNode(\n+            \"node2\", privacyAccountResolver.resolve(1), Address.PRIVACY);\n+    charlie =\n+        privacyBesu.createPrivateTransactionEnabledNode(\n+            \"node3\", privacyAccountResolver.resolve(2), Address.PRIVACY);\n+    privacyCluster.start(alice, bob, charlie);\n+  }\n+\n+  @Test\n+  public void nodeCanCreatePrivacyGroup() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice, alice, bob));\n+\n+    assertThat(privxCreatePrivacyGroup).isNotNull();\n+\n+    final PrivacyGroup expectedGroup =\n+        new PrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey(), bob.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    bob.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final String getParticipantsCallHash =\n+        alice.execute(\n+            privateContractTransactions.callOnChainPermissioningSmartContract(\n+                Address.PRIVACY_PROXY.toHexString(),\n+                \"0x0b0235be\" // get participants method signature\n+                    + Bytes.fromBase64String(alice.getEnclaveKey()).toUnprefixedHexString(),\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privxCreatePrivacyGroup.getPrivacyGroupId()));\n+\n+    final PrivateTransactionReceipt expectedReceipt =\n+        new PrivateTransactionReceipt(\n+            null,\n+            alice.getAddress().toHexString(),\n+            Address.PRIVACY_PROXY.toHexString(),\n+            \"0x0000000000000000000000000000000000000000000000000000000000000020\" // dynamic\n+                // array offset\n+                + \"0000000000000000000000000000000000000000000000000000000000000002\" // length\n+                // of array\n+                + Bytes.fromBase64String(alice.getEnclaveKey()).toUnprefixedHexString() // first\n+                // element\n+                + Bytes.fromBase64String(bob.getEnclaveKey()).toUnprefixedHexString(), // second\n+            // element\n+            Collections.emptyList(),\n+            null,\n+            null,\n+            alice.getEnclaveKey(),\n+            null,\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            \"0x1\",\n+            null);\n+\n+    alice.verify(\n+        privateTransactionVerifier.validPrivateTransactionReceipt(\n+            getParticipantsCallHash, expectedReceipt));\n+\n+    bob.verify(\n+        privateTransactionVerifier.validPrivateTransactionReceipt(\n+            getParticipantsCallHash, expectedReceipt));\n+  }\n+\n+  @Test\n+  public void deployingMustGiveValidReceipt() {\n+    final SecureRandom secureRandom = SecureRandomProvider.createSecureRandom();\n+    final byte[] bytes = new byte[32];\n+    secureRandom.nextBytes(bytes);\n+    final Bytes privacyGroupId = Bytes.wrap(bytes);\n+\n+    final EventEmitter eventEmitter =", "originalCommit": "de88c20c7559d088317922749199400274d03f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA1NTc3Nw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r385055777", "bodyText": "the first transaction is a contract deploy - you are the only participant in the group - you did not create the group using the endpoint (i.e. orion does know about it) - it is a new onchain group", "author": "iikirilov", "createdAt": "2020-02-27T11:00:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzNzQwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ1MDMyMg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r385450322", "bodyText": "But I thought that the only way to create an onchain group was to call the add() in the contract. A new group will always have the management contracts and the contract should be in the locked status until the add() is called ...\nI'll check that in the code :-)", "author": "pinges", "createdAt": "2020-02-28T00:38:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzNzQwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwMjExMg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r385502112", "bodyText": "I've checked it, and the contract is not deployed, because the privacy group is locked. The verify is not checking whether the deploy transaction was successful!", "author": "pinges", "createdAt": "2020-02-28T04:26:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzNzQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzNzU4OQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384937589", "bodyText": "How can the contract be deployed in a privacy group that does not exist?", "author": "pinges", "createdAt": "2020-02-27T06:40:18Z", "path": "acceptance-tests/tests/src/test/java/org/hyperledger/besu/tests/web3j/privacy/OnChainPrivacyAcceptanceTest.java", "diffHunk": "@@ -0,0 +1,374 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.tests.web3j.privacy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.hyperledger.besu.crypto.SecureRandomProvider;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyAcceptanceTestBase;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyNode;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.privacy.PrivacyRequestFactory.PrivxCreatePrivacyGroup;\n+import org.hyperledger.besu.tests.web3j.generated.EventEmitter;\n+\n+import java.math.BigInteger;\n+import java.security.SecureRandom;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.Before;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.web3j.protocol.besu.response.privacy.PrivacyGroup;\n+import org.web3j.protocol.besu.response.privacy.PrivateTransactionReceipt;\n+import org.web3j.protocol.core.methods.response.Log;\n+import org.web3j.protocol.core.methods.response.TransactionReceipt;\n+import org.web3j.utils.Base64String;\n+\n+public class OnChainPrivacyAcceptanceTest extends PrivacyAcceptanceTestBase {\n+  private static final long POW_CHAIN_ID = 2018;\n+\n+  private PrivacyNode alice;\n+  private PrivacyNode bob;\n+  private PrivacyNode charlie;\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    alice =\n+        privacyBesu.createPrivateTransactionEnabledMinerNode(\n+            \"node1\", privacyAccountResolver.resolve(0), Address.PRIVACY);\n+    bob =\n+        privacyBesu.createPrivateTransactionEnabledNode(\n+            \"node2\", privacyAccountResolver.resolve(1), Address.PRIVACY);\n+    charlie =\n+        privacyBesu.createPrivateTransactionEnabledNode(\n+            \"node3\", privacyAccountResolver.resolve(2), Address.PRIVACY);\n+    privacyCluster.start(alice, bob, charlie);\n+  }\n+\n+  @Test\n+  public void nodeCanCreatePrivacyGroup() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice, alice, bob));\n+\n+    assertThat(privxCreatePrivacyGroup).isNotNull();\n+\n+    final PrivacyGroup expectedGroup =\n+        new PrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey(), bob.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    bob.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final String getParticipantsCallHash =\n+        alice.execute(\n+            privateContractTransactions.callOnChainPermissioningSmartContract(\n+                Address.PRIVACY_PROXY.toHexString(),\n+                \"0x0b0235be\" // get participants method signature\n+                    + Bytes.fromBase64String(alice.getEnclaveKey()).toUnprefixedHexString(),\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privxCreatePrivacyGroup.getPrivacyGroupId()));\n+\n+    final PrivateTransactionReceipt expectedReceipt =\n+        new PrivateTransactionReceipt(\n+            null,\n+            alice.getAddress().toHexString(),\n+            Address.PRIVACY_PROXY.toHexString(),\n+            \"0x0000000000000000000000000000000000000000000000000000000000000020\" // dynamic\n+                // array offset\n+                + \"0000000000000000000000000000000000000000000000000000000000000002\" // length\n+                // of array\n+                + Bytes.fromBase64String(alice.getEnclaveKey()).toUnprefixedHexString() // first\n+                // element\n+                + Bytes.fromBase64String(bob.getEnclaveKey()).toUnprefixedHexString(), // second\n+            // element\n+            Collections.emptyList(),\n+            null,\n+            null,\n+            alice.getEnclaveKey(),\n+            null,\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            \"0x1\",\n+            null);\n+\n+    alice.verify(\n+        privateTransactionVerifier.validPrivateTransactionReceipt(\n+            getParticipantsCallHash, expectedReceipt));\n+\n+    bob.verify(\n+        privateTransactionVerifier.validPrivateTransactionReceipt(\n+            getParticipantsCallHash, expectedReceipt));\n+  }\n+\n+  @Test\n+  public void deployingMustGiveValidReceipt() {\n+    final SecureRandom secureRandom = SecureRandomProvider.createSecureRandom();\n+    final byte[] bytes = new byte[32];\n+    secureRandom.nextBytes(bytes);\n+    final Bytes privacyGroupId = Bytes.wrap(bytes);\n+\n+    final EventEmitter eventEmitter =\n+        alice.execute(\n+            privateContractTransactions.createSmartContractWithPrivacyGroupId(\n+                EventEmitter.class,\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privacyGroupId.toBase64String()));\n+\n+    privateContractVerifier\n+        .validPrivateContractDeployed(", "originalCommit": "de88c20c7559d088317922749199400274d03f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA1NTkwNQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r385055905", "bodyText": "s.a.", "author": "iikirilov", "createdAt": "2020-02-27T11:00:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDkzNzU4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk5NjgzMQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r384996831", "bodyText": "I would like to refactor the respond() in a way that the code can be better understood. I find it very confusing and I think that we might miss some edge cases ... I think what I do not like is that we have to check what kind of private transaction we are handling in a lot of different places, not only in this method.\nWould be nice if the DefaultPrivacyController sendRequest() method did not to handle the privateFors/privacyGroupId stuff, but only do what it is was meant to do (check if access should be granted when multi-tenancy is enabled).\nI think it would be easier to understand and to make sure that we do not miss anything:\n...\nif (privateTransaction.getPrivateFor.isPresent) {\nif (isGroupAdditionTransaction) {\n// set the right precompile address, etc.\n} else {\n// normal eea private transaction, precompile contract address can be set, list of private for addresses created, etc.\n}\n}else if (privateTransaction.getPrivacyGroupId().isPresent {\nif (isOnChainPrivateTransaction) {\n// get the privateFors from on chain management contract, set the precompile contract address\n} else {\n// Orion style privacy group id, set precompile contract address\n}", "author": "pinges", "createdAt": "2020-02-27T09:14:39Z", "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/eea/EeaSendRawTransaction.java", "diffHunk": "@@ -70,6 +75,10 @@ public JsonRpcResponse response(final JsonRpcRequestContext requestContext) {\n       final PrivateTransaction privateTransaction =\n           PrivateTransaction.readFrom(RLP.input(Bytes.fromHexString(rawPrivateTransaction)));\n \n+      final Optional<String> addPayloadEnclaveKey =", "originalCommit": "de88c20c7559d088317922749199400274d03f59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA3NTc4Mg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r385075782", "bodyText": "We have that logic in at least two places (probably more). Might be a good idea to reuse that code ...", "author": "pinges", "createdAt": "2020-02-27T11:44:12Z", "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/priv/PrivGetTransactionReceipt.java", "diffHunk": "@@ -88,24 +89,48 @@ public JsonRpcResponse response(final JsonRpcRequestContext requestContext) {\n     final Transaction pmtTransaction =\n         blockBody.getTransactions().get(pmtLocation.getTransactionIndex());\n \n-    final Hash blockhash = pmtLocation.getBlockHash();\n-    final long blockNumber = blockchain.getBlockchain().getBlockHeader(blockhash).get().getNumber();\n+    final Hash blockHash = pmtLocation.getBlockHash();\n+    final long blockNumber = blockchain.getBlockchain().getBlockHeader(blockHash).get().getNumber();\n \n     final PrivateTransaction privateTransaction;\n     final String privacyGroupId;\n     try {\n       final ReceiveResponse receiveResponse =\n           privacyController.retrieveTransaction(\n-              pmtTransaction.getPayload().toBase64String(),\n+              pmtTransaction.getPayload().slice(0, 32).toBase64String(),\n               enclavePublicKeyProvider.getEnclaveKey(requestContext.getUser()));\n       LOG.trace(\"Received private transaction information\");\n \n       final BytesValueRLPInput input =\n           new BytesValueRLPInput(\n               Bytes.fromBase64String(new String(receiveResponse.getPayload(), UTF_8)), false);\n-\n-      privateTransaction = PrivateTransaction.readFrom(input);\n-      privacyGroupId = receiveResponse.getPrivacyGroupId();\n+      input.enterList();", "originalCommit": "de88c20c7559d088317922749199400274d03f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU5MTUzMg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387591532", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T10:56:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA3NTc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4MDAzMg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r385080032", "bodyText": "The whole logic to find out what the privacyGroupId is looks a bit too complicated. If there is a privacyGroupId in the private transaction, we could just use that, if not just use the privacyGroupId returned in the receiveResponse ...", "author": "pinges", "createdAt": "2020-02-27T11:54:10Z", "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/priv/PrivGetTransactionReceipt.java", "diffHunk": "@@ -88,24 +89,48 @@ public JsonRpcResponse response(final JsonRpcRequestContext requestContext) {\n     final Transaction pmtTransaction =\n         blockBody.getTransactions().get(pmtLocation.getTransactionIndex());\n \n-    final Hash blockhash = pmtLocation.getBlockHash();\n-    final long blockNumber = blockchain.getBlockchain().getBlockHeader(blockhash).get().getNumber();\n+    final Hash blockHash = pmtLocation.getBlockHash();\n+    final long blockNumber = blockchain.getBlockchain().getBlockHeader(blockHash).get().getNumber();\n \n     final PrivateTransaction privateTransaction;\n     final String privacyGroupId;\n     try {\n       final ReceiveResponse receiveResponse =\n           privacyController.retrieveTransaction(\n-              pmtTransaction.getPayload().toBase64String(),\n+              pmtTransaction.getPayload().slice(0, 32).toBase64String(),\n               enclavePublicKeyProvider.getEnclaveKey(requestContext.getUser()));\n       LOG.trace(\"Received private transaction information\");\n \n       final BytesValueRLPInput input =\n           new BytesValueRLPInput(\n               Bytes.fromBase64String(new String(receiveResponse.getPayload(), UTF_8)), false);\n-\n-      privateTransaction = PrivateTransaction.readFrom(input);\n-      privacyGroupId = receiveResponse.getPrivacyGroupId();\n+      input.enterList();\n+      if (input.nextIsList()) {\n+        privateTransaction = PrivateTransaction.readFrom(input);\n+        input.leaveListLenient();\n+      } else {\n+        input.reset();\n+        privateTransaction = PrivateTransaction.readFrom(input);\n+      }\n+\n+      if (privateTransaction.getPrivacyGroupId().isPresent()) {", "originalCommit": "de88c20c7559d088317922749199400274d03f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU5MTYxOQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387591619", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T10:56:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA4MDAzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwOTQ0OQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r385509449", "bodyText": "Why do we need the startList?", "author": "pinges", "createdAt": "2020-02-28T05:07:14Z", "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/priv/PrivGetPrivateTransactionTest.java", "diffHunk": "@@ -143,7 +143,9 @@ public void returnsPrivateTransactionLegacy() {\n             new JsonRpcRequest(\"1\", \"priv_getPrivateTransaction\", params), user);\n \n     final BytesValueRLPOutput bvrlp = new BytesValueRLPOutput();\n+    bvrlp.startList();", "originalCommit": "de88c20c7559d088317922749199400274d03f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU5MzAwMw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387593003", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T10:59:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwOTQ0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwOTQ3MA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r385509470", "bodyText": "s.a.", "author": "pinges", "createdAt": "2020-02-28T05:07:25Z", "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/priv/PrivGetPrivateTransactionTest.java", "diffHunk": "@@ -180,7 +182,9 @@ public void returnsPrivateTransactionGroup() {\n         new JsonRpcRequestContext(new JsonRpcRequest(\"1\", \"priv_getPrivateTransaction\", params));\n \n     final BytesValueRLPOutput bvrlp = new BytesValueRLPOutput();\n+    bvrlp.startList();", "originalCommit": "de88c20c7559d088317922749199400274d03f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU5Mjk4MQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387592981", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T10:59:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUwOTQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUxMDY2Mg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r385510662", "bodyText": "I'm sure we could get rid of some of these \"magic\" numbers ...", "author": "pinges", "createdAt": "2020-02-28T05:13:27Z", "path": "ethereum/api/src/test/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/priv/PrivGetTransactionReceiptTest.java", "diffHunk": "@@ -132,7 +133,7 @@\n           null,\n           0,\n           0,\n-          Hash.fromHexString(\"0x65348ddfe0b282c26862b4610a8c45fd8486a93ae6e2b197836c826b4b671848\"),\n+          Hash.fromHexString(transaction.getHash().toHexString()),\n           Hash.fromHexString(\"0x43ef5094212ba4862d6b310a3d337c3478fdf942c5ed3f8e792ad93d6d96994d\"),", "originalCommit": "de88c20c7559d088317922749199400274d03f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU5NzUyMQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387597521", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T11:08:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUxMDY2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUzMTE5Mg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r385531192", "bodyText": "Need to think about whether there is a better way to get the archive to the PrivacyBlockProcessor ...", "author": "pinges", "createdAt": "2020-02-28T06:44:21Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/ProtocolSchedule.java", "diffHunk": "@@ -26,4 +27,7 @@\n   Optional<BigInteger> getChainId();\n \n   void setTransactionFilter(TransactionFilter transactionFilter);\n+\n+  void setPublicWorldStateArchiveForPrivacyBlockProcessor(", "originalCommit": "de88c20c7559d088317922749199400274d03f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU5NzgxNg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387597816", "bodyText": "not without some major changes, I don't think", "author": "iikirilov", "createdAt": "2020-03-04T11:08:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUzMTE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUzMjYyNw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r385532627", "bodyText": "s.a.", "author": "pinges", "createdAt": "2020-02-28T06:50:11Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/ProtocolSpec.java", "diffHunk": "@@ -288,4 +289,10 @@ public GasCalculator getGasCalculator() {\n   public void setTransactionFilter(final TransactionFilter transactionFilter) {\n     transactionValidator.setTransactionFilter(transactionFilter);\n   }\n+\n+  public void setPublicWorldStateArchiveForPrivacyBlockProcessor(", "originalCommit": "de88c20c7559d088317922749199400274d03f59", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU5ODAxOA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387598018", "bodyText": "s.a.", "author": "iikirilov", "createdAt": "2020-03-04T11:09:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUzMjYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTUzOTUxNg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r385539516", "bodyText": "A Simulator, where we can pass in the state would be cool ...", "author": "pinges", "createdAt": "2020-02-28T07:14:13Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/OnChainPrivacyPrecompiledContract.java", "diffHunk": "@@ -0,0 +1,456 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.mainnet.precompiles.privacy;\n+\n+import static org.hyperledger.besu.crypto.Hash.keccak256;\n+import static org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver.EMPTY_ROOT_HASH;\n+\n+import org.hyperledger.besu.crypto.SECP256K1;\n+import org.hyperledger.besu.enclave.Enclave;\n+import org.hyperledger.besu.enclave.EnclaveClientException;\n+import org.hyperledger.besu.enclave.EnclaveIOException;\n+import org.hyperledger.besu.enclave.EnclaveServerException;\n+import org.hyperledger.besu.enclave.types.ReceiveResponse;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.DefaultEvmAccount;\n+import org.hyperledger.besu.ethereum.core.Gas;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableAccount;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.PrivacyParameters;\n+import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;\n+import org.hyperledger.besu.ethereum.core.Wei;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.debug.TraceOptions;\n+import org.hyperledger.besu.ethereum.mainnet.AbstractPrecompiledContract;\n+import org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransaction;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionProcessor;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionReceipt;\n+import org.hyperledger.besu.ethereum.privacy.Restriction;\n+import org.hyperledger.besu.ethereum.privacy.VersionedPrivateTransaction;\n+import org.hyperledger.besu.ethereum.privacy.group.OnChainGroupManagement;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateBlockMetadata;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateTransactionMetadata;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLP;\n+import org.hyperledger.besu.ethereum.vm.DebugOperationTracer;\n+import org.hyperledger.besu.ethereum.vm.GasCalculator;\n+import org.hyperledger.besu.ethereum.vm.MessageFrame;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.Base64;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class OnChainPrivacyPrecompiledContract extends AbstractPrecompiledContract {\n+\n+  // Dummy signature for transactions to not fail being processed.\n+  private static final SECP256K1.Signature FAKE_SIGNATURE =\n+      SECP256K1.Signature.create(SECP256K1.HALF_CURVE_ORDER, SECP256K1.HALF_CURVE_ORDER, (byte) 0);\n+\n+  private final Enclave enclave;\n+  private final WorldStateArchive privateWorldStateArchive;\n+  private final PrivateStateStorage privateStateStorage;\n+  private final PrivateStateRootResolver privateStateRootResolver;\n+  private PrivateTransactionProcessor privateTransactionProcessor;\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  public OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator, final PrivacyParameters privacyParameters) {\n+    this(\n+        gasCalculator,\n+        privacyParameters.getEnclave(),\n+        privacyParameters.getPrivateWorldStateArchive(),\n+        privacyParameters.getPrivateStateStorage());\n+  }\n+\n+  OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator,\n+      final Enclave enclave,\n+      final WorldStateArchive worldStateArchive,\n+      final PrivateStateStorage privateStateStorage) {\n+    super(\"OnChainPrivacy\", gasCalculator);\n+    this.enclave = enclave;\n+    this.privateWorldStateArchive = worldStateArchive;\n+    this.privateStateStorage = privateStateStorage;\n+    this.privateStateRootResolver = new PrivateStateRootResolver(privateStateStorage);\n+  }\n+\n+  public void setPrivateTransactionProcessor(\n+      final PrivateTransactionProcessor privateTransactionProcessor) {\n+    this.privateTransactionProcessor = privateTransactionProcessor;\n+  }\n+\n+  @Override\n+  public Gas gasRequirement(final Bytes input) {\n+    return Gas.of(0L);\n+  }\n+\n+  @Override\n+  public Bytes compute(final Bytes input, final MessageFrame messageFrame) {\n+    final ProcessableBlockHeader currentBlockHeader = messageFrame.getBlockHeader();\n+    if (!BlockHeader.class.isAssignableFrom(currentBlockHeader.getClass())) {\n+      if (!messageFrame.isPersistingPrivateState()) {\n+        // We get in here from block mining.\n+        return Bytes.EMPTY;\n+      } else {\n+        throw new IllegalArgumentException(\n+            \"The MessageFrame contains an illegal block header type. Cannot persist private block metadata without current block hash.\");\n+      }\n+    }\n+    final Hash currentBlockHash = ((BlockHeader) currentBlockHeader).getHash();\n+\n+    final String key = input.slice(0, 32).toBase64String();\n+\n+    final ReceiveResponse receiveResponse;\n+    try {\n+      receiveResponse = enclave.receive(key);\n+    } catch (final EnclaveClientException e) {\n+      LOG.debug(\"Can not fetch private transaction payload with key {}\", key, e);\n+      return Bytes.EMPTY;\n+    } catch (final EnclaveServerException e) {\n+      LOG.error(\"Enclave is responding but errored perhaps it has a misconfiguration?\", e);\n+      throw e;\n+    } catch (final EnclaveIOException e) {\n+      LOG.error(\"Can not communicate with enclave is it up?\", e);\n+      throw e;\n+    }\n+\n+    final BytesValueRLPInput bytesValueRLPInput =\n+        new BytesValueRLPInput(\n+            Bytes.wrap(Base64.getDecoder().decode(receiveResponse.getPayload())), false);\n+    final VersionedPrivateTransaction versionedPrivateTransaction =\n+        VersionedPrivateTransaction.readFrom(bytesValueRLPInput);\n+    final PrivateTransaction privateTransaction =\n+        versionedPrivateTransaction.getPrivateTransaction();\n+    final Bytes32 version = versionedPrivateTransaction.getVersion();\n+\n+    final WorldUpdater publicWorldState = messageFrame.getWorldState();\n+\n+    final Optional<Bytes> maybeGroupId = privateTransaction.getPrivacyGroupId();\n+    if (maybeGroupId.isEmpty()) {\n+      return Bytes.EMPTY;\n+    }\n+\n+    final Bytes32 privacyGroupId = Bytes32.wrap(maybeGroupId.get());\n+\n+    LOG.debug(\n+        \"Processing private transaction {} in privacy group {}\",\n+        privateTransaction.getHash(),\n+        privacyGroupId);\n+\n+    final PrivacyGroupHeadBlockMap privacyGroupHeadBlockMap =\n+        privateStateStorage.getPrivacyGroupHeadBlockMap(currentBlockHash).orElseThrow();\n+\n+    final Blockchain blockchain = messageFrame.getBlockchain();\n+\n+    final Hash lastRootHash =\n+        privateStateRootResolver.resolveLastStateRoot(privacyGroupId, currentBlockHash);\n+\n+    final MutableWorldState disposablePrivateState =\n+        privateWorldStateArchive.getMutable(lastRootHash).get();\n+\n+    final WorldUpdater privateWorldStateUpdater = disposablePrivateState.updater();\n+\n+    maybeInjectDefaultManagementAndProxy(\n+        lastRootHash, disposablePrivateState, privateWorldStateUpdater);\n+\n+    final boolean isAddingParticipant =\n+        privateTransaction\n+            .getPayload()\n+            .toHexString()\n+            .startsWith(OnChainGroupManagement.ADD_TO_GROUP_METHOD_SIGNATURE.toHexString());\n+\n+    final boolean isContractLocked =\n+        isContractLocked(\n+            messageFrame,\n+            currentBlockHeader,\n+            publicWorldState,\n+            privacyGroupId,\n+            blockchain,\n+            disposablePrivateState,\n+            privateWorldStateUpdater,\n+            OnChainGroupManagement.CAN_EXECUTE_METHOD_SIGNATURE);\n+\n+    if (isAddingParticipant && !isContractLocked) {\n+      LOG.debug(\n+          \"Privacy Group {} is not locked while trying to add to group with commitment {}\",\n+          privacyGroupId.toHexString(),\n+          messageFrame.getTransactionHash());\n+      return Bytes.EMPTY;\n+    }\n+\n+    if (!isAddingParticipant && isContractLocked) {\n+      LOG.debug(\n+          \"Privacy Group {} is locked while trying to execute transaction with commitment {}\",\n+          privacyGroupId.toHexString(),\n+          messageFrame.getTransactionHash());\n+      return Bytes.EMPTY;\n+    }\n+\n+    if (!onChainVersionMatches(\n+        messageFrame,\n+        currentBlockHeader,\n+        version,\n+        publicWorldState,\n+        privacyGroupId,\n+        blockchain,\n+        disposablePrivateState,\n+        privateWorldStateUpdater)) return Bytes.EMPTY;\n+\n+    final PrivateTransactionProcessor.Result result =\n+        privateTransactionProcessor.processTransaction(\n+            blockchain,\n+            publicWorldState,\n+            privateWorldStateUpdater,\n+            currentBlockHeader,\n+            privateTransaction,\n+            messageFrame.getMiningBeneficiary(),\n+            new DebugOperationTracer(TraceOptions.DEFAULT),\n+            messageFrame.getBlockHashLookup(),\n+            privacyGroupId);\n+\n+    if (result.isInvalid() || !result.isSuccessful()) {\n+      LOG.error(\n+          \"Failed to process private transaction {}: {}\",\n+          privateTransaction.getHash(),\n+          result.getValidationResult().getErrorMessage());\n+      return Bytes.EMPTY;\n+    }\n+\n+    if (messageFrame.isPersistingPrivateState()) {\n+      persistPrivateState(\n+          messageFrame.getTransactionHash(),\n+          currentBlockHash,\n+          privateTransaction,\n+          privacyGroupId,\n+          privacyGroupHeadBlockMap,\n+          disposablePrivateState,\n+          privateWorldStateUpdater,\n+          result);\n+    }\n+\n+    return result.getOutput();\n+  }\n+\n+  protected boolean isContractLocked(\n+      final MessageFrame messageFrame,\n+      final ProcessableBlockHeader currentBlockHeader,\n+      final WorldUpdater publicWorldState,\n+      final Bytes32 privacyGroupId,\n+      final Blockchain blockchain,\n+      final MutableWorldState disposablePrivateState,\n+      final WorldUpdater privateWorldStateUpdater,\n+      final Bytes canExecuteMethodSignature) {\n+    final PrivateTransactionProcessor.Result result =\n+        checkCanExecute(\n+            messageFrame,\n+            currentBlockHeader,\n+            publicWorldState,\n+            privacyGroupId,\n+            blockchain,\n+            disposablePrivateState,\n+            privateWorldStateUpdater,\n+            canExecuteMethodSignature);\n+    return result.getOutput().toHexString().endsWith(\"0\");\n+  }\n+\n+  protected PrivateTransactionProcessor.Result checkCanExecute(\n+      final MessageFrame messageFrame,\n+      final ProcessableBlockHeader currentBlockHeader,\n+      final WorldUpdater publicWorldState,\n+      final Bytes32 privacyGroupId,\n+      final Blockchain currentBlockchain,\n+      final MutableWorldState disposablePrivateState,\n+      final WorldUpdater privateWorldStateUpdater,\n+      final Bytes canExecuteMethodSignature) {\n+    // We need the \"lock status\" of the group for every single transaction but we don't want this\n+    // call to affect the state\n+    // privateTransactionProcessor.processTransaction(...) commits the state if the process was\n+    // successful before it returns\n+    final MutableWorldState canExecutePrivateState =\n+        privateWorldStateArchive.getMutable(disposablePrivateState.rootHash()).get();\n+    final WorldUpdater canExecuteUpdater = canExecutePrivateState.updater();\n+\n+    return privateTransactionProcessor.processTransaction(", "originalCommit": "de88c20c7559d088317922749199400274d03f59", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE2Nzk4Nw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386167987", "bodyText": "Thinking about the name privxLockContract ... We are not really locking a contract, we are locking the privacyGroup!", "author": "pinges", "createdAt": "2020-03-02T01:55:12Z", "path": "acceptance-tests/tests/src/test/java/org/hyperledger/besu/tests/web3j/privacy/OnChainPrivacyAcceptanceTest.java", "diffHunk": "@@ -0,0 +1,399 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.tests.web3j.privacy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.tests.acceptance.dsl.condition.eth.EthConditions;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyAcceptanceTestBase;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyNode;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.miner.MinerTransactions;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.privacy.PrivacyRequestFactory.PrivxCreatePrivacyGroup;\n+import org.hyperledger.besu.tests.web3j.generated.EventEmitter;\n+\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.web3j.protocol.besu.response.privacy.PrivacyGroup;\n+import org.web3j.protocol.besu.response.privacy.PrivateTransactionReceipt;\n+import org.web3j.protocol.core.methods.response.Log;\n+import org.web3j.protocol.core.methods.response.TransactionReceipt;\n+import org.web3j.utils.Base64String;\n+\n+public class OnChainPrivacyAcceptanceTest extends PrivacyAcceptanceTestBase {\n+  private static final long POW_CHAIN_ID = 2018;\n+\n+  private PrivacyNode alice;\n+  private PrivacyNode bob;\n+  private PrivacyNode charlie;\n+\n+  private final MinerTransactions minerTransactions = new MinerTransactions();\n+  private final EthConditions ethConditions = new EthConditions(ethTransactions);\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    alice =\n+        privacyBesu.createPrivateTransactionEnabledMinerNode(\n+            \"node1\", privacyAccountResolver.resolve(0), Address.PRIVACY);\n+    bob =\n+        privacyBesu.createPrivateTransactionEnabledNode(\n+            \"node2\", privacyAccountResolver.resolve(1), Address.PRIVACY);\n+    charlie =\n+        privacyBesu.createPrivateTransactionEnabledNode(\n+            \"node3\", privacyAccountResolver.resolve(2), Address.PRIVACY);\n+    privacyCluster.start(alice, bob, charlie);\n+  }\n+\n+  @Test\n+  public void nodeCanCreatePrivacyGroup() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice, alice, bob));\n+\n+    assertThat(privxCreatePrivacyGroup).isNotNull();\n+\n+    final PrivacyGroup expectedGroup =\n+        new PrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey(), bob.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    bob.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final String getParticipantsCallHash =\n+        alice.execute(\n+            privateContractTransactions.callOnChainPermissioningSmartContract(\n+                Address.PRIVACY_PROXY.toHexString(),\n+                \"0x0b0235be\" // get participants method signature\n+                    + Bytes.fromBase64String(alice.getEnclaveKey()).toUnprefixedHexString(),\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privxCreatePrivacyGroup.getPrivacyGroupId()));\n+\n+    final PrivateTransactionReceipt expectedReceipt =\n+        new PrivateTransactionReceipt(\n+            null,\n+            alice.getAddress().toHexString(),\n+            Address.PRIVACY_PROXY.toHexString(),\n+            \"0x0000000000000000000000000000000000000000000000000000000000000020\" // dynamic\n+                // array offset\n+                + \"0000000000000000000000000000000000000000000000000000000000000002\" // length\n+                // of array\n+                + Bytes.fromBase64String(alice.getEnclaveKey()).toUnprefixedHexString() // first\n+                // element\n+                + Bytes.fromBase64String(bob.getEnclaveKey()).toUnprefixedHexString(), // second\n+            // element\n+            Collections.emptyList(),\n+            null,\n+            null,\n+            alice.getEnclaveKey(),\n+            null,\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            \"0x1\",\n+            null);\n+\n+    alice.verify(\n+        privateTransactionVerifier.validPrivateTransactionReceipt(\n+            getParticipantsCallHash, expectedReceipt));\n+\n+    bob.verify(\n+        privateTransactionVerifier.validPrivateTransactionReceipt(\n+            getParticipantsCallHash, expectedReceipt));\n+  }\n+\n+  @Test\n+  public void deployingMustGiveValidReceipt() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice));\n+\n+    final PrivacyGroup expectedGroup =\n+        new PrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final EventEmitter eventEmitter =\n+        alice.execute(\n+            privateContractTransactions.createSmartContractWithPrivacyGroupId(\n+                EventEmitter.class,\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privxCreatePrivacyGroup.getPrivacyGroupId()));\n+\n+    privateContractVerifier\n+        .validPrivateContractDeployed(\n+            eventEmitter.getContractAddress(), alice.getAddress().toString())\n+        .verify(eventEmitter);\n+  }\n+\n+  @Test\n+  public void canAddParticipantToGroup() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice, alice, bob));\n+\n+    assertThat(privxCreatePrivacyGroup).isNotNull();\n+\n+    final PrivacyGroup expectedGroup =\n+        new PrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey(), bob.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    bob.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final EventEmitter eventEmitter =\n+        alice.execute(\n+            privateContractTransactions.createSmartContractWithPrivacyGroupId(\n+                EventEmitter.class,\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privxCreatePrivacyGroup.getPrivacyGroupId()));\n+\n+    privateContractVerifier\n+        .validPrivateContractDeployed(\n+            eventEmitter.getContractAddress(), alice.getAddress().toString())\n+        .verify(eventEmitter);\n+\n+    alice.execute(\n+        privacyTransactions.privxLockContract(privxCreatePrivacyGroup.getPrivacyGroupId(), alice));\n+\n+    alice.execute(\n+        privacyTransactions.addToPrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(), alice, charlie));\n+\n+    final PrivacyGroup expectedGroupAfterCharlieIsAdded =\n+        new PrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(\n+                alice.getEnclaveKey(), bob.getEnclaveKey(), charlie.getEnclaveKey()));\n+\n+    alice.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+\n+    bob.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+\n+    charlie.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+  }\n+\n+  @Test\n+  public void bobCanAddCharlieAfterBeingAddedByAlice() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice, alice));\n+\n+    assertThat(privxCreatePrivacyGroup).isNotNull();\n+\n+    final String privacyGroupId = privxCreatePrivacyGroup.getPrivacyGroupId();\n+    final PrivacyGroup expectedGroup =\n+        new PrivacyGroup(\n+            privacyGroupId,\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final EventEmitter eventEmitter =\n+        alice.execute(\n+            privateContractTransactions.createSmartContractWithPrivacyGroupId(\n+                EventEmitter.class,\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privacyGroupId));\n+    privateContractVerifier\n+        .validPrivateContractDeployed(\n+            eventEmitter.getContractAddress(), alice.getAddress().toString())\n+        .verify(eventEmitter);\n+\n+    alice.execute(privacyTransactions.privxLockContract(privacyGroupId, alice));", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE2OTEyMg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386169122", "bodyText": "constant would be nice", "author": "pinges", "createdAt": "2020-03-02T02:02:51Z", "path": "acceptance-tests/tests/src/test/java/org/hyperledger/besu/tests/web3j/privacy/OnChainPrivacyAcceptanceTest.java", "diffHunk": "@@ -0,0 +1,399 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.tests.web3j.privacy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.tests.acceptance.dsl.condition.eth.EthConditions;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyAcceptanceTestBase;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyNode;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.miner.MinerTransactions;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.privacy.PrivacyRequestFactory.PrivxCreatePrivacyGroup;\n+import org.hyperledger.besu.tests.web3j.generated.EventEmitter;\n+\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.web3j.protocol.besu.response.privacy.PrivacyGroup;\n+import org.web3j.protocol.besu.response.privacy.PrivateTransactionReceipt;\n+import org.web3j.protocol.core.methods.response.Log;\n+import org.web3j.protocol.core.methods.response.TransactionReceipt;\n+import org.web3j.utils.Base64String;\n+\n+public class OnChainPrivacyAcceptanceTest extends PrivacyAcceptanceTestBase {\n+  private static final long POW_CHAIN_ID = 2018;\n+\n+  private PrivacyNode alice;\n+  private PrivacyNode bob;\n+  private PrivacyNode charlie;\n+\n+  private final MinerTransactions minerTransactions = new MinerTransactions();\n+  private final EthConditions ethConditions = new EthConditions(ethTransactions);\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    alice =\n+        privacyBesu.createPrivateTransactionEnabledMinerNode(\n+            \"node1\", privacyAccountResolver.resolve(0), Address.PRIVACY);\n+    bob =\n+        privacyBesu.createPrivateTransactionEnabledNode(\n+            \"node2\", privacyAccountResolver.resolve(1), Address.PRIVACY);\n+    charlie =\n+        privacyBesu.createPrivateTransactionEnabledNode(\n+            \"node3\", privacyAccountResolver.resolve(2), Address.PRIVACY);\n+    privacyCluster.start(alice, bob, charlie);\n+  }\n+\n+  @Test\n+  public void nodeCanCreatePrivacyGroup() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice, alice, bob));\n+\n+    assertThat(privxCreatePrivacyGroup).isNotNull();\n+\n+    final PrivacyGroup expectedGroup =\n+        new PrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey(), bob.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    bob.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final String getParticipantsCallHash =\n+        alice.execute(\n+            privateContractTransactions.callOnChainPermissioningSmartContract(\n+                Address.PRIVACY_PROXY.toHexString(),\n+                \"0x0b0235be\" // get participants method signature\n+                    + Bytes.fromBase64String(alice.getEnclaveKey()).toUnprefixedHexString(),\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privxCreatePrivacyGroup.getPrivacyGroupId()));\n+\n+    final PrivateTransactionReceipt expectedReceipt =\n+        new PrivateTransactionReceipt(\n+            null,\n+            alice.getAddress().toHexString(),\n+            Address.PRIVACY_PROXY.toHexString(),\n+            \"0x0000000000000000000000000000000000000000000000000000000000000020\" // dynamic\n+                // array offset\n+                + \"0000000000000000000000000000000000000000000000000000000000000002\" // length\n+                // of array\n+                + Bytes.fromBase64String(alice.getEnclaveKey()).toUnprefixedHexString() // first\n+                // element\n+                + Bytes.fromBase64String(bob.getEnclaveKey()).toUnprefixedHexString(), // second\n+            // element\n+            Collections.emptyList(),\n+            null,\n+            null,\n+            alice.getEnclaveKey(),\n+            null,\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            \"0x1\",\n+            null);\n+\n+    alice.verify(\n+        privateTransactionVerifier.validPrivateTransactionReceipt(\n+            getParticipantsCallHash, expectedReceipt));\n+\n+    bob.verify(\n+        privateTransactionVerifier.validPrivateTransactionReceipt(\n+            getParticipantsCallHash, expectedReceipt));\n+  }\n+\n+  @Test\n+  public void deployingMustGiveValidReceipt() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice));\n+\n+    final PrivacyGroup expectedGroup =\n+        new PrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final EventEmitter eventEmitter =\n+        alice.execute(\n+            privateContractTransactions.createSmartContractWithPrivacyGroupId(\n+                EventEmitter.class,\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privxCreatePrivacyGroup.getPrivacyGroupId()));\n+\n+    privateContractVerifier\n+        .validPrivateContractDeployed(\n+            eventEmitter.getContractAddress(), alice.getAddress().toString())\n+        .verify(eventEmitter);\n+  }\n+\n+  @Test\n+  public void canAddParticipantToGroup() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice, alice, bob));\n+\n+    assertThat(privxCreatePrivacyGroup).isNotNull();\n+\n+    final PrivacyGroup expectedGroup =\n+        new PrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey(), bob.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    bob.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final EventEmitter eventEmitter =\n+        alice.execute(\n+            privateContractTransactions.createSmartContractWithPrivacyGroupId(\n+                EventEmitter.class,\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privxCreatePrivacyGroup.getPrivacyGroupId()));\n+\n+    privateContractVerifier\n+        .validPrivateContractDeployed(\n+            eventEmitter.getContractAddress(), alice.getAddress().toString())\n+        .verify(eventEmitter);\n+\n+    alice.execute(\n+        privacyTransactions.privxLockContract(privxCreatePrivacyGroup.getPrivacyGroupId(), alice));\n+\n+    alice.execute(\n+        privacyTransactions.addToPrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(), alice, charlie));\n+\n+    final PrivacyGroup expectedGroupAfterCharlieIsAdded =\n+        new PrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(\n+                alice.getEnclaveKey(), bob.getEnclaveKey(), charlie.getEnclaveKey()));\n+\n+    alice.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+\n+    bob.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+\n+    charlie.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+  }\n+\n+  @Test\n+  public void bobCanAddCharlieAfterBeingAddedByAlice() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice, alice));\n+\n+    assertThat(privxCreatePrivacyGroup).isNotNull();\n+\n+    final String privacyGroupId = privxCreatePrivacyGroup.getPrivacyGroupId();\n+    final PrivacyGroup expectedGroup =\n+        new PrivacyGroup(\n+            privacyGroupId,\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final EventEmitter eventEmitter =\n+        alice.execute(\n+            privateContractTransactions.createSmartContractWithPrivacyGroupId(\n+                EventEmitter.class,\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privacyGroupId));\n+    privateContractVerifier\n+        .validPrivateContractDeployed(\n+            eventEmitter.getContractAddress(), alice.getAddress().toString())\n+        .verify(eventEmitter);\n+\n+    alice.execute(privacyTransactions.privxLockContract(privacyGroupId, alice));\n+\n+    alice.execute(privacyTransactions.addToPrivacyGroup(privacyGroupId, alice, bob));\n+\n+    final PrivacyGroup expectedGroupAfterBobIsAdded =\n+        new PrivacyGroup(\n+            privacyGroupId,\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey(), bob.getEnclaveKey()));\n+\n+    alice.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroupAfterBobIsAdded));\n+\n+    bob.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroupAfterBobIsAdded));\n+\n+    bob.execute(privacyTransactions.privxLockContract(privacyGroupId, bob));\n+\n+    alice.execute(minerTransactions.minerStop());\n+\n+    alice.getBesu().verify(ethConditions.miningStatus(false));\n+\n+    final BigInteger pendingTransactionFilterId =\n+        alice.execute(ethTransactions.newPendingTransactionsFilter());\n+\n+    final String callHash =\n+        alice.execute(\n+            privateContractTransactions.callOnChainPermissioningSmartContract(\n+                eventEmitter.getContractAddress(),\n+                eventEmitter.value().encodeFunctionCall(),\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privacyGroupId));\n+\n+    final String bobAddHash =\n+        bob.execute(privacyTransactions.addToPrivacyGroup(privacyGroupId, bob, charlie));\n+\n+    alice\n+        .getBesu()\n+        .verify(\n+            ethConditions.expectNewPendingTransactions(\n+                pendingTransactionFilterId, Arrays.asList(callHash, bobAddHash)));\n+\n+    alice.execute(minerTransactions.minerStart());\n+\n+    alice.getBesu().verify(ethConditions.miningStatus(true));\n+\n+    final PrivacyGroup expectedGroupAfterCharlieIsAdded =\n+        new PrivacyGroup(\n+            privacyGroupId,\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(\n+                alice.getEnclaveKey(), bob.getEnclaveKey(), charlie.getEnclaveKey()));\n+\n+    alice.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+\n+    bob.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+\n+    charlie.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+\n+    final Optional<TransactionReceipt> aliceAddReceipt =\n+        alice.execute(ethTransactions.getTransactionReceipt(bobAddHash));\n+    assertThat(aliceAddReceipt.get().getStatus())\n+        .isEqualTo(\"0x1\"); // this means the PMT for the \"add\" succeeded which is what we expect\n+\n+    final Optional<TransactionReceipt> alicePublicReceipt =\n+        alice.execute(ethTransactions.getTransactionReceipt(callHash));\n+    if (alicePublicReceipt.isPresent()) {\n+      assertThat(alicePublicReceipt.get().getBlockHash())\n+          .isEqualTo(\n+              aliceAddReceipt\n+                  .get()\n+                  .getBlockHash()); // ensure that \"add\" and \"call\" are in the same block\n+      assertThat(alicePublicReceipt.get().getStatus())\n+          .isEqualTo(\n+              \"0x1\"); // this means the PMT for the \"call\" succeeded which is what we expect because\n+      // it is in the same block as the \"add\" and there is no way to tell that this\n+      // will happen before the block is mined\n+    }\n+\n+    final PrivateTransactionReceipt aliceReceipt =\n+        alice.execute(privacyTransactions.getPrivateTransactionReceipt(callHash));\n+    assertThat(aliceReceipt.getStatus())\n+        .isEqualTo(\n+            \"0x0\"); // this means the \"call\" failed which is what we expect because the group was\n+    // locked!\n+    final PrivateTransactionReceipt bobReceipt =\n+        alice.execute(privacyTransactions.getPrivateTransactionReceipt(callHash));\n+    assertThat(bobReceipt.getStatus())\n+        .isEqualTo(\n+            \"0x0\"); // this means the \"call\" failed which is what we expect because the group was\n+    // locked!\n+\n+    final String storeHash =\n+        charlie.execute(\n+            privateContractTransactions.callOnChainPermissioningSmartContract(\n+                eventEmitter.getContractAddress(),\n+                eventEmitter.store(BigInteger.valueOf(1337)).encodeFunctionCall(),\n+                charlie.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                charlie.getEnclaveKey(),\n+                privacyGroupId));\n+\n+    final PrivateTransactionReceipt expectedReceipt =\n+        new PrivateTransactionReceipt(\n+            null,\n+            charlie.getAddress().toHexString(),\n+            eventEmitter.getContractAddress(),\n+            \"0x\",\n+            Collections.singletonList(\n+                new Log(\n+                    false,\n+                    \"0x0\",\n+                    \"0x0\",\n+                    storeHash,\n+                    null,\n+                    null,\n+                    eventEmitter.getContractAddress(),\n+                    \"0x000000000000000000000000f17f52151ebef6c7334fad080c5704d77216b7320000000000000000000000000000000000000000000000000000000000000539\",", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE2OTE3MA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386169170", "bodyText": "constant would be nice", "author": "pinges", "createdAt": "2020-03-02T02:03:08Z", "path": "acceptance-tests/tests/src/test/java/org/hyperledger/besu/tests/web3j/privacy/OnChainPrivacyAcceptanceTest.java", "diffHunk": "@@ -0,0 +1,399 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.tests.web3j.privacy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.tests.acceptance.dsl.condition.eth.EthConditions;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyAcceptanceTestBase;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyNode;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.miner.MinerTransactions;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.privacy.PrivacyRequestFactory.PrivxCreatePrivacyGroup;\n+import org.hyperledger.besu.tests.web3j.generated.EventEmitter;\n+\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.web3j.protocol.besu.response.privacy.PrivacyGroup;\n+import org.web3j.protocol.besu.response.privacy.PrivateTransactionReceipt;\n+import org.web3j.protocol.core.methods.response.Log;\n+import org.web3j.protocol.core.methods.response.TransactionReceipt;\n+import org.web3j.utils.Base64String;\n+\n+public class OnChainPrivacyAcceptanceTest extends PrivacyAcceptanceTestBase {\n+  private static final long POW_CHAIN_ID = 2018;\n+\n+  private PrivacyNode alice;\n+  private PrivacyNode bob;\n+  private PrivacyNode charlie;\n+\n+  private final MinerTransactions minerTransactions = new MinerTransactions();\n+  private final EthConditions ethConditions = new EthConditions(ethTransactions);\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    alice =\n+        privacyBesu.createPrivateTransactionEnabledMinerNode(\n+            \"node1\", privacyAccountResolver.resolve(0), Address.PRIVACY);\n+    bob =\n+        privacyBesu.createPrivateTransactionEnabledNode(\n+            \"node2\", privacyAccountResolver.resolve(1), Address.PRIVACY);\n+    charlie =\n+        privacyBesu.createPrivateTransactionEnabledNode(\n+            \"node3\", privacyAccountResolver.resolve(2), Address.PRIVACY);\n+    privacyCluster.start(alice, bob, charlie);\n+  }\n+\n+  @Test\n+  public void nodeCanCreatePrivacyGroup() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice, alice, bob));\n+\n+    assertThat(privxCreatePrivacyGroup).isNotNull();\n+\n+    final PrivacyGroup expectedGroup =\n+        new PrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey(), bob.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    bob.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final String getParticipantsCallHash =\n+        alice.execute(\n+            privateContractTransactions.callOnChainPermissioningSmartContract(\n+                Address.PRIVACY_PROXY.toHexString(),\n+                \"0x0b0235be\" // get participants method signature\n+                    + Bytes.fromBase64String(alice.getEnclaveKey()).toUnprefixedHexString(),\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privxCreatePrivacyGroup.getPrivacyGroupId()));\n+\n+    final PrivateTransactionReceipt expectedReceipt =\n+        new PrivateTransactionReceipt(\n+            null,\n+            alice.getAddress().toHexString(),\n+            Address.PRIVACY_PROXY.toHexString(),\n+            \"0x0000000000000000000000000000000000000000000000000000000000000020\" // dynamic\n+                // array offset\n+                + \"0000000000000000000000000000000000000000000000000000000000000002\" // length\n+                // of array\n+                + Bytes.fromBase64String(alice.getEnclaveKey()).toUnprefixedHexString() // first\n+                // element\n+                + Bytes.fromBase64String(bob.getEnclaveKey()).toUnprefixedHexString(), // second\n+            // element\n+            Collections.emptyList(),\n+            null,\n+            null,\n+            alice.getEnclaveKey(),\n+            null,\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            \"0x1\",\n+            null);\n+\n+    alice.verify(\n+        privateTransactionVerifier.validPrivateTransactionReceipt(\n+            getParticipantsCallHash, expectedReceipt));\n+\n+    bob.verify(\n+        privateTransactionVerifier.validPrivateTransactionReceipt(\n+            getParticipantsCallHash, expectedReceipt));\n+  }\n+\n+  @Test\n+  public void deployingMustGiveValidReceipt() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice));\n+\n+    final PrivacyGroup expectedGroup =\n+        new PrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final EventEmitter eventEmitter =\n+        alice.execute(\n+            privateContractTransactions.createSmartContractWithPrivacyGroupId(\n+                EventEmitter.class,\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privxCreatePrivacyGroup.getPrivacyGroupId()));\n+\n+    privateContractVerifier\n+        .validPrivateContractDeployed(\n+            eventEmitter.getContractAddress(), alice.getAddress().toString())\n+        .verify(eventEmitter);\n+  }\n+\n+  @Test\n+  public void canAddParticipantToGroup() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice, alice, bob));\n+\n+    assertThat(privxCreatePrivacyGroup).isNotNull();\n+\n+    final PrivacyGroup expectedGroup =\n+        new PrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey(), bob.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    bob.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final EventEmitter eventEmitter =\n+        alice.execute(\n+            privateContractTransactions.createSmartContractWithPrivacyGroupId(\n+                EventEmitter.class,\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privxCreatePrivacyGroup.getPrivacyGroupId()));\n+\n+    privateContractVerifier\n+        .validPrivateContractDeployed(\n+            eventEmitter.getContractAddress(), alice.getAddress().toString())\n+        .verify(eventEmitter);\n+\n+    alice.execute(\n+        privacyTransactions.privxLockContract(privxCreatePrivacyGroup.getPrivacyGroupId(), alice));\n+\n+    alice.execute(\n+        privacyTransactions.addToPrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(), alice, charlie));\n+\n+    final PrivacyGroup expectedGroupAfterCharlieIsAdded =\n+        new PrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(\n+                alice.getEnclaveKey(), bob.getEnclaveKey(), charlie.getEnclaveKey()));\n+\n+    alice.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+\n+    bob.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+\n+    charlie.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+  }\n+\n+  @Test\n+  public void bobCanAddCharlieAfterBeingAddedByAlice() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice, alice));\n+\n+    assertThat(privxCreatePrivacyGroup).isNotNull();\n+\n+    final String privacyGroupId = privxCreatePrivacyGroup.getPrivacyGroupId();\n+    final PrivacyGroup expectedGroup =\n+        new PrivacyGroup(\n+            privacyGroupId,\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final EventEmitter eventEmitter =\n+        alice.execute(\n+            privateContractTransactions.createSmartContractWithPrivacyGroupId(\n+                EventEmitter.class,\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privacyGroupId));\n+    privateContractVerifier\n+        .validPrivateContractDeployed(\n+            eventEmitter.getContractAddress(), alice.getAddress().toString())\n+        .verify(eventEmitter);\n+\n+    alice.execute(privacyTransactions.privxLockContract(privacyGroupId, alice));\n+\n+    alice.execute(privacyTransactions.addToPrivacyGroup(privacyGroupId, alice, bob));\n+\n+    final PrivacyGroup expectedGroupAfterBobIsAdded =\n+        new PrivacyGroup(\n+            privacyGroupId,\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey(), bob.getEnclaveKey()));\n+\n+    alice.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroupAfterBobIsAdded));\n+\n+    bob.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroupAfterBobIsAdded));\n+\n+    bob.execute(privacyTransactions.privxLockContract(privacyGroupId, bob));\n+\n+    alice.execute(minerTransactions.minerStop());\n+\n+    alice.getBesu().verify(ethConditions.miningStatus(false));\n+\n+    final BigInteger pendingTransactionFilterId =\n+        alice.execute(ethTransactions.newPendingTransactionsFilter());\n+\n+    final String callHash =\n+        alice.execute(\n+            privateContractTransactions.callOnChainPermissioningSmartContract(\n+                eventEmitter.getContractAddress(),\n+                eventEmitter.value().encodeFunctionCall(),\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privacyGroupId));\n+\n+    final String bobAddHash =\n+        bob.execute(privacyTransactions.addToPrivacyGroup(privacyGroupId, bob, charlie));\n+\n+    alice\n+        .getBesu()\n+        .verify(\n+            ethConditions.expectNewPendingTransactions(\n+                pendingTransactionFilterId, Arrays.asList(callHash, bobAddHash)));\n+\n+    alice.execute(minerTransactions.minerStart());\n+\n+    alice.getBesu().verify(ethConditions.miningStatus(true));\n+\n+    final PrivacyGroup expectedGroupAfterCharlieIsAdded =\n+        new PrivacyGroup(\n+            privacyGroupId,\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(\n+                alice.getEnclaveKey(), bob.getEnclaveKey(), charlie.getEnclaveKey()));\n+\n+    alice.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+\n+    bob.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+\n+    charlie.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+\n+    final Optional<TransactionReceipt> aliceAddReceipt =\n+        alice.execute(ethTransactions.getTransactionReceipt(bobAddHash));\n+    assertThat(aliceAddReceipt.get().getStatus())\n+        .isEqualTo(\"0x1\"); // this means the PMT for the \"add\" succeeded which is what we expect\n+\n+    final Optional<TransactionReceipt> alicePublicReceipt =\n+        alice.execute(ethTransactions.getTransactionReceipt(callHash));\n+    if (alicePublicReceipt.isPresent()) {\n+      assertThat(alicePublicReceipt.get().getBlockHash())\n+          .isEqualTo(\n+              aliceAddReceipt\n+                  .get()\n+                  .getBlockHash()); // ensure that \"add\" and \"call\" are in the same block\n+      assertThat(alicePublicReceipt.get().getStatus())\n+          .isEqualTo(\n+              \"0x1\"); // this means the PMT for the \"call\" succeeded which is what we expect because\n+      // it is in the same block as the \"add\" and there is no way to tell that this\n+      // will happen before the block is mined\n+    }\n+\n+    final PrivateTransactionReceipt aliceReceipt =\n+        alice.execute(privacyTransactions.getPrivateTransactionReceipt(callHash));\n+    assertThat(aliceReceipt.getStatus())\n+        .isEqualTo(\n+            \"0x0\"); // this means the \"call\" failed which is what we expect because the group was\n+    // locked!\n+    final PrivateTransactionReceipt bobReceipt =\n+        alice.execute(privacyTransactions.getPrivateTransactionReceipt(callHash));\n+    assertThat(bobReceipt.getStatus())\n+        .isEqualTo(\n+            \"0x0\"); // this means the \"call\" failed which is what we expect because the group was\n+    // locked!\n+\n+    final String storeHash =\n+        charlie.execute(\n+            privateContractTransactions.callOnChainPermissioningSmartContract(\n+                eventEmitter.getContractAddress(),\n+                eventEmitter.store(BigInteger.valueOf(1337)).encodeFunctionCall(),\n+                charlie.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                charlie.getEnclaveKey(),\n+                privacyGroupId));\n+\n+    final PrivateTransactionReceipt expectedReceipt =\n+        new PrivateTransactionReceipt(\n+            null,\n+            charlie.getAddress().toHexString(),\n+            eventEmitter.getContractAddress(),\n+            \"0x\",\n+            Collections.singletonList(\n+                new Log(\n+                    false,\n+                    \"0x0\",\n+                    \"0x0\",\n+                    storeHash,\n+                    null,\n+                    null,\n+                    eventEmitter.getContractAddress(),\n+                    \"0x000000000000000000000000f17f52151ebef6c7334fad080c5704d77216b7320000000000000000000000000000000000000000000000000000000000000539\",\n+                    null,\n+                    Collections.singletonList(\n+                        \"0xc9db20adedc6cf2b5d25252b101ab03e124902a73fcb12b753f3d1aaa2d8f9f5\"))),", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE3MTYxOQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386171619", "bodyText": "Could we add another valid private transaction in the privacy group at this point please, maybe one that changes the state of the group.\nAnd it would be nice if we could check that charlie, once he was successfully added to the group, can get the receipts for the valid transactions that happened before bob was added, and the receipt for the private transaction that you are going to add here.", "author": "pinges", "createdAt": "2020-03-02T02:19:51Z", "path": "acceptance-tests/tests/src/test/java/org/hyperledger/besu/tests/web3j/privacy/OnChainPrivacyAcceptanceTest.java", "diffHunk": "@@ -0,0 +1,399 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.tests.web3j.privacy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.tests.acceptance.dsl.condition.eth.EthConditions;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyAcceptanceTestBase;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyNode;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.miner.MinerTransactions;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.privacy.PrivacyRequestFactory.PrivxCreatePrivacyGroup;\n+import org.hyperledger.besu.tests.web3j.generated.EventEmitter;\n+\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.web3j.protocol.besu.response.privacy.PrivacyGroup;\n+import org.web3j.protocol.besu.response.privacy.PrivateTransactionReceipt;\n+import org.web3j.protocol.core.methods.response.Log;\n+import org.web3j.protocol.core.methods.response.TransactionReceipt;\n+import org.web3j.utils.Base64String;\n+\n+public class OnChainPrivacyAcceptanceTest extends PrivacyAcceptanceTestBase {\n+  private static final long POW_CHAIN_ID = 2018;\n+\n+  private PrivacyNode alice;\n+  private PrivacyNode bob;\n+  private PrivacyNode charlie;\n+\n+  private final MinerTransactions minerTransactions = new MinerTransactions();\n+  private final EthConditions ethConditions = new EthConditions(ethTransactions);\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    alice =\n+        privacyBesu.createPrivateTransactionEnabledMinerNode(\n+            \"node1\", privacyAccountResolver.resolve(0), Address.PRIVACY);\n+    bob =\n+        privacyBesu.createPrivateTransactionEnabledNode(\n+            \"node2\", privacyAccountResolver.resolve(1), Address.PRIVACY);\n+    charlie =\n+        privacyBesu.createPrivateTransactionEnabledNode(\n+            \"node3\", privacyAccountResolver.resolve(2), Address.PRIVACY);\n+    privacyCluster.start(alice, bob, charlie);\n+  }\n+\n+  @Test\n+  public void nodeCanCreatePrivacyGroup() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice, alice, bob));\n+\n+    assertThat(privxCreatePrivacyGroup).isNotNull();\n+\n+    final PrivacyGroup expectedGroup =\n+        new PrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey(), bob.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    bob.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final String getParticipantsCallHash =\n+        alice.execute(\n+            privateContractTransactions.callOnChainPermissioningSmartContract(\n+                Address.PRIVACY_PROXY.toHexString(),\n+                \"0x0b0235be\" // get participants method signature\n+                    + Bytes.fromBase64String(alice.getEnclaveKey()).toUnprefixedHexString(),\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privxCreatePrivacyGroup.getPrivacyGroupId()));\n+\n+    final PrivateTransactionReceipt expectedReceipt =\n+        new PrivateTransactionReceipt(\n+            null,\n+            alice.getAddress().toHexString(),\n+            Address.PRIVACY_PROXY.toHexString(),\n+            \"0x0000000000000000000000000000000000000000000000000000000000000020\" // dynamic\n+                // array offset\n+                + \"0000000000000000000000000000000000000000000000000000000000000002\" // length\n+                // of array\n+                + Bytes.fromBase64String(alice.getEnclaveKey()).toUnprefixedHexString() // first\n+                // element\n+                + Bytes.fromBase64String(bob.getEnclaveKey()).toUnprefixedHexString(), // second\n+            // element\n+            Collections.emptyList(),\n+            null,\n+            null,\n+            alice.getEnclaveKey(),\n+            null,\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            \"0x1\",\n+            null);\n+\n+    alice.verify(\n+        privateTransactionVerifier.validPrivateTransactionReceipt(\n+            getParticipantsCallHash, expectedReceipt));\n+\n+    bob.verify(\n+        privateTransactionVerifier.validPrivateTransactionReceipt(\n+            getParticipantsCallHash, expectedReceipt));\n+  }\n+\n+  @Test\n+  public void deployingMustGiveValidReceipt() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice));\n+\n+    final PrivacyGroup expectedGroup =\n+        new PrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final EventEmitter eventEmitter =\n+        alice.execute(\n+            privateContractTransactions.createSmartContractWithPrivacyGroupId(\n+                EventEmitter.class,\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privxCreatePrivacyGroup.getPrivacyGroupId()));\n+\n+    privateContractVerifier\n+        .validPrivateContractDeployed(\n+            eventEmitter.getContractAddress(), alice.getAddress().toString())\n+        .verify(eventEmitter);\n+  }\n+\n+  @Test\n+  public void canAddParticipantToGroup() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice, alice, bob));\n+\n+    assertThat(privxCreatePrivacyGroup).isNotNull();\n+\n+    final PrivacyGroup expectedGroup =\n+        new PrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey(), bob.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    bob.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final EventEmitter eventEmitter =\n+        alice.execute(\n+            privateContractTransactions.createSmartContractWithPrivacyGroupId(\n+                EventEmitter.class,\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privxCreatePrivacyGroup.getPrivacyGroupId()));\n+\n+    privateContractVerifier\n+        .validPrivateContractDeployed(\n+            eventEmitter.getContractAddress(), alice.getAddress().toString())\n+        .verify(eventEmitter);\n+\n+    alice.execute(\n+        privacyTransactions.privxLockContract(privxCreatePrivacyGroup.getPrivacyGroupId(), alice));\n+\n+    alice.execute(\n+        privacyTransactions.addToPrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(), alice, charlie));\n+\n+    final PrivacyGroup expectedGroupAfterCharlieIsAdded =\n+        new PrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(\n+                alice.getEnclaveKey(), bob.getEnclaveKey(), charlie.getEnclaveKey()));\n+\n+    alice.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+\n+    bob.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+\n+    charlie.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+  }\n+\n+  @Test\n+  public void bobCanAddCharlieAfterBeingAddedByAlice() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice, alice));\n+\n+    assertThat(privxCreatePrivacyGroup).isNotNull();\n+\n+    final String privacyGroupId = privxCreatePrivacyGroup.getPrivacyGroupId();\n+    final PrivacyGroup expectedGroup =\n+        new PrivacyGroup(\n+            privacyGroupId,\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final EventEmitter eventEmitter =\n+        alice.execute(\n+            privateContractTransactions.createSmartContractWithPrivacyGroupId(\n+                EventEmitter.class,\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privacyGroupId));\n+    privateContractVerifier\n+        .validPrivateContractDeployed(\n+            eventEmitter.getContractAddress(), alice.getAddress().toString())\n+        .verify(eventEmitter);\n+\n+    alice.execute(privacyTransactions.privxLockContract(privacyGroupId, alice));\n+\n+    alice.execute(privacyTransactions.addToPrivacyGroup(privacyGroupId, alice, bob));\n+\n+    final PrivacyGroup expectedGroupAfterBobIsAdded =\n+        new PrivacyGroup(\n+            privacyGroupId,\n+            PrivacyGroup.Type.PANTHEON,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey(), bob.getEnclaveKey()));\n+\n+    alice.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroupAfterBobIsAdded));\n+\n+    bob.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroupAfterBobIsAdded));\n+", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE3ODU3NA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386178574", "bodyText": "This means that if all the members of the group have been removed you can add yourself as a member by calling the add with your enclave key...\nNot sure whether that is a feature or a bug ...", "author": "pinges", "createdAt": "2020-03-02T03:00:29Z", "path": "privacy-contracts/src/main/solidity/PrivacyGroup.sol", "diffHunk": "@@ -0,0 +1,106 @@\n+pragma solidity ^0.5.9;\n+import \"./PrivacyInterface.sol\";\n+\n+contract PrivacyGroup is PrivacyInterface {\n+\n+    bool private _canExecute;\n+    int private _version;\n+    bytes32[] private distributionList;\n+    mapping(bytes32 => uint256) private distributionIndexOf;\n+\n+    function getVersion() external view returns (int) {\n+        return _version;\n+    }\n+\n+    // overrides\n+    function canExecute() external view returns (bool) {\n+        return _canExecute;\n+    }\n+\n+    function lock() public {\n+        require(_canExecute);\n+        _canExecute = false;\n+    }\n+\n+    function unlock() public {\n+        require(!_canExecute);\n+        _canExecute = true;\n+    }\n+\n+    function addParticipants(bytes32 _enclaveKey, bytes32[] memory _accounts) public returns (bool) {\n+        require(!_canExecute);\n+        if(distributionList.length == 0) {\n+            addParticipant(_enclaveKey);", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY3MjA0Mg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386672042", "bodyText": "hmm - I am not too worried because that will not cause a root mismatch anywhere but it might be something to discuss", "author": "iikirilov", "createdAt": "2020-03-02T21:50:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE3ODU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc5NjMwOQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386796309", "bodyText": "I don't think this is a problem, as, if the list of members is empty nobody would be able to call the add(), is that right?", "author": "pinges", "createdAt": "2020-03-03T04:42:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE3ODU3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU5OTAzMA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387599030", "bodyText": "no - whoever calls the add first will be the owner of the group", "author": "iikirilov", "createdAt": "2020-03-04T11:11:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE3ODU3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE4OTIwMg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386189202", "bodyText": "Do you know when this is going to happen? I can't think of a case where the privacy group id is not present in the private transaction, at least not for on-chain privacy.", "author": "pinges", "createdAt": "2020-03-02T04:04:46Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/OnChainPrivacyPrecompiledContract.java", "diffHunk": "@@ -0,0 +1,466 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.mainnet.precompiles.privacy;\n+\n+import static org.hyperledger.besu.crypto.Hash.keccak256;\n+import static org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver.EMPTY_ROOT_HASH;\n+\n+import org.hyperledger.besu.crypto.SECP256K1;\n+import org.hyperledger.besu.enclave.Enclave;\n+import org.hyperledger.besu.enclave.EnclaveClientException;\n+import org.hyperledger.besu.enclave.EnclaveIOException;\n+import org.hyperledger.besu.enclave.EnclaveServerException;\n+import org.hyperledger.besu.enclave.types.ReceiveResponse;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.DefaultEvmAccount;\n+import org.hyperledger.besu.ethereum.core.Gas;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableAccount;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.PrivacyParameters;\n+import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;\n+import org.hyperledger.besu.ethereum.core.Wei;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.debug.TraceOptions;\n+import org.hyperledger.besu.ethereum.mainnet.AbstractPrecompiledContract;\n+import org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransaction;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionProcessor;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionReceipt;\n+import org.hyperledger.besu.ethereum.privacy.Restriction;\n+import org.hyperledger.besu.ethereum.privacy.VersionedPrivateTransaction;\n+import org.hyperledger.besu.ethereum.privacy.group.OnChainGroupManagement;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateBlockMetadata;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateTransactionMetadata;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLP;\n+import org.hyperledger.besu.ethereum.vm.DebugOperationTracer;\n+import org.hyperledger.besu.ethereum.vm.GasCalculator;\n+import org.hyperledger.besu.ethereum.vm.MessageFrame;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.Base64;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class OnChainPrivacyPrecompiledContract extends AbstractPrecompiledContract {\n+\n+  // Dummy signature for transactions to not fail being processed.\n+  private static final SECP256K1.Signature FAKE_SIGNATURE =\n+      SECP256K1.Signature.create(SECP256K1.HALF_CURVE_ORDER, SECP256K1.HALF_CURVE_ORDER, (byte) 0);\n+\n+  private final Enclave enclave;\n+  private final WorldStateArchive privateWorldStateArchive;\n+  private final PrivateStateStorage privateStateStorage;\n+  private final PrivateStateRootResolver privateStateRootResolver;\n+  private PrivateTransactionProcessor privateTransactionProcessor;\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  public OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator, final PrivacyParameters privacyParameters) {\n+    this(\n+        gasCalculator,\n+        privacyParameters.getEnclave(),\n+        privacyParameters.getPrivateWorldStateArchive(),\n+        privacyParameters.getPrivateStateStorage());\n+  }\n+\n+  OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator,\n+      final Enclave enclave,\n+      final WorldStateArchive worldStateArchive,\n+      final PrivateStateStorage privateStateStorage) {\n+    super(\"OnChainPrivacy\", gasCalculator);\n+    this.enclave = enclave;\n+    this.privateWorldStateArchive = worldStateArchive;\n+    this.privateStateStorage = privateStateStorage;\n+    this.privateStateRootResolver = new PrivateStateRootResolver(privateStateStorage);\n+  }\n+\n+  public void setPrivateTransactionProcessor(\n+      final PrivateTransactionProcessor privateTransactionProcessor) {\n+    this.privateTransactionProcessor = privateTransactionProcessor;\n+  }\n+\n+  @Override\n+  public Gas gasRequirement(final Bytes input) {\n+    return Gas.of(0L);\n+  }\n+\n+  @Override\n+  public Bytes compute(final Bytes input, final MessageFrame messageFrame) {\n+    final ProcessableBlockHeader currentBlockHeader = messageFrame.getBlockHeader();\n+    if (!BlockHeader.class.isAssignableFrom(currentBlockHeader.getClass())) {\n+      if (!messageFrame.isPersistingPrivateState()) {\n+        // We get in here from block mining.\n+        return Bytes.EMPTY;\n+      } else {\n+        throw new IllegalArgumentException(\n+            \"The MessageFrame contains an illegal block header type. Cannot persist private block metadata without current block hash.\");\n+      }\n+    }\n+    final Hash currentBlockHash = ((BlockHeader) currentBlockHeader).getHash();\n+\n+    final String key = input.slice(0, 32).toBase64String();\n+\n+    final ReceiveResponse receiveResponse;\n+    try {\n+      receiveResponse = enclave.receive(key);\n+    } catch (final EnclaveClientException e) {\n+      LOG.debug(\"Can not fetch private transaction payload with key {}\", key, e);\n+      return Bytes.EMPTY;\n+    } catch (final EnclaveServerException e) {\n+      LOG.error(\"Enclave is responding but errored perhaps it has a misconfiguration?\", e);\n+      throw e;\n+    } catch (final EnclaveIOException e) {\n+      LOG.error(\"Can not communicate with enclave is it up?\", e);\n+      throw e;\n+    }\n+\n+    final BytesValueRLPInput bytesValueRLPInput =\n+        new BytesValueRLPInput(\n+            Bytes.wrap(Base64.getDecoder().decode(receiveResponse.getPayload())), false);\n+    final VersionedPrivateTransaction versionedPrivateTransaction =\n+        VersionedPrivateTransaction.readFrom(bytesValueRLPInput);\n+    final PrivateTransaction privateTransaction =\n+        versionedPrivateTransaction.getPrivateTransaction();\n+    final Bytes32 version = versionedPrivateTransaction.getVersion();\n+\n+    final WorldUpdater publicWorldState = messageFrame.getWorldState();\n+\n+    final Optional<Bytes> maybeGroupId = privateTransaction.getPrivacyGroupId();\n+    if (maybeGroupId.isEmpty()) {\n+      return Bytes.EMPTY;", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYwMDUyNw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387600527", "bodyText": "Yes this can be empty if you accidentally send a legacy private transaction to the on-chain precompile.", "author": "iikirilov", "createdAt": "2020-03-04T11:14:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE4OTIwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE4OTgyNw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386189827", "bodyText": "better name might be \"isPrivacyGroupLocked\" ...", "author": "pinges", "createdAt": "2020-03-02T04:08:53Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/OnChainPrivacyPrecompiledContract.java", "diffHunk": "@@ -0,0 +1,466 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.mainnet.precompiles.privacy;\n+\n+import static org.hyperledger.besu.crypto.Hash.keccak256;\n+import static org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver.EMPTY_ROOT_HASH;\n+\n+import org.hyperledger.besu.crypto.SECP256K1;\n+import org.hyperledger.besu.enclave.Enclave;\n+import org.hyperledger.besu.enclave.EnclaveClientException;\n+import org.hyperledger.besu.enclave.EnclaveIOException;\n+import org.hyperledger.besu.enclave.EnclaveServerException;\n+import org.hyperledger.besu.enclave.types.ReceiveResponse;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.DefaultEvmAccount;\n+import org.hyperledger.besu.ethereum.core.Gas;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableAccount;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.PrivacyParameters;\n+import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;\n+import org.hyperledger.besu.ethereum.core.Wei;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.debug.TraceOptions;\n+import org.hyperledger.besu.ethereum.mainnet.AbstractPrecompiledContract;\n+import org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransaction;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionProcessor;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionReceipt;\n+import org.hyperledger.besu.ethereum.privacy.Restriction;\n+import org.hyperledger.besu.ethereum.privacy.VersionedPrivateTransaction;\n+import org.hyperledger.besu.ethereum.privacy.group.OnChainGroupManagement;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateBlockMetadata;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateTransactionMetadata;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLP;\n+import org.hyperledger.besu.ethereum.vm.DebugOperationTracer;\n+import org.hyperledger.besu.ethereum.vm.GasCalculator;\n+import org.hyperledger.besu.ethereum.vm.MessageFrame;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.Base64;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class OnChainPrivacyPrecompiledContract extends AbstractPrecompiledContract {\n+\n+  // Dummy signature for transactions to not fail being processed.\n+  private static final SECP256K1.Signature FAKE_SIGNATURE =\n+      SECP256K1.Signature.create(SECP256K1.HALF_CURVE_ORDER, SECP256K1.HALF_CURVE_ORDER, (byte) 0);\n+\n+  private final Enclave enclave;\n+  private final WorldStateArchive privateWorldStateArchive;\n+  private final PrivateStateStorage privateStateStorage;\n+  private final PrivateStateRootResolver privateStateRootResolver;\n+  private PrivateTransactionProcessor privateTransactionProcessor;\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  public OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator, final PrivacyParameters privacyParameters) {\n+    this(\n+        gasCalculator,\n+        privacyParameters.getEnclave(),\n+        privacyParameters.getPrivateWorldStateArchive(),\n+        privacyParameters.getPrivateStateStorage());\n+  }\n+\n+  OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator,\n+      final Enclave enclave,\n+      final WorldStateArchive worldStateArchive,\n+      final PrivateStateStorage privateStateStorage) {\n+    super(\"OnChainPrivacy\", gasCalculator);\n+    this.enclave = enclave;\n+    this.privateWorldStateArchive = worldStateArchive;\n+    this.privateStateStorage = privateStateStorage;\n+    this.privateStateRootResolver = new PrivateStateRootResolver(privateStateStorage);\n+  }\n+\n+  public void setPrivateTransactionProcessor(\n+      final PrivateTransactionProcessor privateTransactionProcessor) {\n+    this.privateTransactionProcessor = privateTransactionProcessor;\n+  }\n+\n+  @Override\n+  public Gas gasRequirement(final Bytes input) {\n+    return Gas.of(0L);\n+  }\n+\n+  @Override\n+  public Bytes compute(final Bytes input, final MessageFrame messageFrame) {\n+    final ProcessableBlockHeader currentBlockHeader = messageFrame.getBlockHeader();\n+    if (!BlockHeader.class.isAssignableFrom(currentBlockHeader.getClass())) {\n+      if (!messageFrame.isPersistingPrivateState()) {\n+        // We get in here from block mining.\n+        return Bytes.EMPTY;\n+      } else {\n+        throw new IllegalArgumentException(\n+            \"The MessageFrame contains an illegal block header type. Cannot persist private block metadata without current block hash.\");\n+      }\n+    }\n+    final Hash currentBlockHash = ((BlockHeader) currentBlockHeader).getHash();\n+\n+    final String key = input.slice(0, 32).toBase64String();\n+\n+    final ReceiveResponse receiveResponse;\n+    try {\n+      receiveResponse = enclave.receive(key);\n+    } catch (final EnclaveClientException e) {\n+      LOG.debug(\"Can not fetch private transaction payload with key {}\", key, e);\n+      return Bytes.EMPTY;\n+    } catch (final EnclaveServerException e) {\n+      LOG.error(\"Enclave is responding but errored perhaps it has a misconfiguration?\", e);\n+      throw e;\n+    } catch (final EnclaveIOException e) {\n+      LOG.error(\"Can not communicate with enclave is it up?\", e);\n+      throw e;\n+    }\n+\n+    final BytesValueRLPInput bytesValueRLPInput =\n+        new BytesValueRLPInput(\n+            Bytes.wrap(Base64.getDecoder().decode(receiveResponse.getPayload())), false);\n+    final VersionedPrivateTransaction versionedPrivateTransaction =\n+        VersionedPrivateTransaction.readFrom(bytesValueRLPInput);\n+    final PrivateTransaction privateTransaction =\n+        versionedPrivateTransaction.getPrivateTransaction();\n+    final Bytes32 version = versionedPrivateTransaction.getVersion();\n+\n+    final WorldUpdater publicWorldState = messageFrame.getWorldState();\n+\n+    final Optional<Bytes> maybeGroupId = privateTransaction.getPrivacyGroupId();\n+    if (maybeGroupId.isEmpty()) {\n+      return Bytes.EMPTY;\n+    }\n+\n+    final Bytes32 privacyGroupId = Bytes32.wrap(maybeGroupId.get());\n+\n+    LOG.debug(\n+        \"Processing private transaction {} in privacy group {}\",\n+        privateTransaction.getHash(),\n+        privacyGroupId);\n+\n+    final PrivacyGroupHeadBlockMap privacyGroupHeadBlockMap =\n+        privateStateStorage.getPrivacyGroupHeadBlockMap(currentBlockHash).orElseThrow();\n+\n+    final Blockchain blockchain = messageFrame.getBlockchain();\n+\n+    final Hash lastRootHash =\n+        privateStateRootResolver.resolveLastStateRoot(privacyGroupId, currentBlockHash);\n+\n+    final MutableWorldState disposablePrivateState =\n+        privateWorldStateArchive.getMutable(lastRootHash).get();\n+\n+    final WorldUpdater privateWorldStateUpdater = disposablePrivateState.updater();\n+\n+    maybeInjectDefaultManagementAndProxy(\n+        lastRootHash, disposablePrivateState, privateWorldStateUpdater);\n+\n+    final boolean isAddingParticipant =\n+        privateTransaction\n+            .getPayload()\n+            .toHexString()\n+            .startsWith(OnChainGroupManagement.ADD_TO_GROUP_METHOD_SIGNATURE.toHexString());\n+\n+    final boolean isContractLocked =\n+        isContractLocked(", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5MDA2OA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386190068", "bodyText": "onChainPrivacyGroupVersionMatches", "author": "pinges", "createdAt": "2020-03-02T04:10:28Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/OnChainPrivacyPrecompiledContract.java", "diffHunk": "@@ -0,0 +1,466 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.mainnet.precompiles.privacy;\n+\n+import static org.hyperledger.besu.crypto.Hash.keccak256;\n+import static org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver.EMPTY_ROOT_HASH;\n+\n+import org.hyperledger.besu.crypto.SECP256K1;\n+import org.hyperledger.besu.enclave.Enclave;\n+import org.hyperledger.besu.enclave.EnclaveClientException;\n+import org.hyperledger.besu.enclave.EnclaveIOException;\n+import org.hyperledger.besu.enclave.EnclaveServerException;\n+import org.hyperledger.besu.enclave.types.ReceiveResponse;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.DefaultEvmAccount;\n+import org.hyperledger.besu.ethereum.core.Gas;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableAccount;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.PrivacyParameters;\n+import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;\n+import org.hyperledger.besu.ethereum.core.Wei;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.debug.TraceOptions;\n+import org.hyperledger.besu.ethereum.mainnet.AbstractPrecompiledContract;\n+import org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransaction;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionProcessor;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionReceipt;\n+import org.hyperledger.besu.ethereum.privacy.Restriction;\n+import org.hyperledger.besu.ethereum.privacy.VersionedPrivateTransaction;\n+import org.hyperledger.besu.ethereum.privacy.group.OnChainGroupManagement;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateBlockMetadata;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateTransactionMetadata;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLP;\n+import org.hyperledger.besu.ethereum.vm.DebugOperationTracer;\n+import org.hyperledger.besu.ethereum.vm.GasCalculator;\n+import org.hyperledger.besu.ethereum.vm.MessageFrame;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.Base64;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class OnChainPrivacyPrecompiledContract extends AbstractPrecompiledContract {\n+\n+  // Dummy signature for transactions to not fail being processed.\n+  private static final SECP256K1.Signature FAKE_SIGNATURE =\n+      SECP256K1.Signature.create(SECP256K1.HALF_CURVE_ORDER, SECP256K1.HALF_CURVE_ORDER, (byte) 0);\n+\n+  private final Enclave enclave;\n+  private final WorldStateArchive privateWorldStateArchive;\n+  private final PrivateStateStorage privateStateStorage;\n+  private final PrivateStateRootResolver privateStateRootResolver;\n+  private PrivateTransactionProcessor privateTransactionProcessor;\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  public OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator, final PrivacyParameters privacyParameters) {\n+    this(\n+        gasCalculator,\n+        privacyParameters.getEnclave(),\n+        privacyParameters.getPrivateWorldStateArchive(),\n+        privacyParameters.getPrivateStateStorage());\n+  }\n+\n+  OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator,\n+      final Enclave enclave,\n+      final WorldStateArchive worldStateArchive,\n+      final PrivateStateStorage privateStateStorage) {\n+    super(\"OnChainPrivacy\", gasCalculator);\n+    this.enclave = enclave;\n+    this.privateWorldStateArchive = worldStateArchive;\n+    this.privateStateStorage = privateStateStorage;\n+    this.privateStateRootResolver = new PrivateStateRootResolver(privateStateStorage);\n+  }\n+\n+  public void setPrivateTransactionProcessor(\n+      final PrivateTransactionProcessor privateTransactionProcessor) {\n+    this.privateTransactionProcessor = privateTransactionProcessor;\n+  }\n+\n+  @Override\n+  public Gas gasRequirement(final Bytes input) {\n+    return Gas.of(0L);\n+  }\n+\n+  @Override\n+  public Bytes compute(final Bytes input, final MessageFrame messageFrame) {\n+    final ProcessableBlockHeader currentBlockHeader = messageFrame.getBlockHeader();\n+    if (!BlockHeader.class.isAssignableFrom(currentBlockHeader.getClass())) {\n+      if (!messageFrame.isPersistingPrivateState()) {\n+        // We get in here from block mining.\n+        return Bytes.EMPTY;\n+      } else {\n+        throw new IllegalArgumentException(\n+            \"The MessageFrame contains an illegal block header type. Cannot persist private block metadata without current block hash.\");\n+      }\n+    }\n+    final Hash currentBlockHash = ((BlockHeader) currentBlockHeader).getHash();\n+\n+    final String key = input.slice(0, 32).toBase64String();\n+\n+    final ReceiveResponse receiveResponse;\n+    try {\n+      receiveResponse = enclave.receive(key);\n+    } catch (final EnclaveClientException e) {\n+      LOG.debug(\"Can not fetch private transaction payload with key {}\", key, e);\n+      return Bytes.EMPTY;\n+    } catch (final EnclaveServerException e) {\n+      LOG.error(\"Enclave is responding but errored perhaps it has a misconfiguration?\", e);\n+      throw e;\n+    } catch (final EnclaveIOException e) {\n+      LOG.error(\"Can not communicate with enclave is it up?\", e);\n+      throw e;\n+    }\n+\n+    final BytesValueRLPInput bytesValueRLPInput =\n+        new BytesValueRLPInput(\n+            Bytes.wrap(Base64.getDecoder().decode(receiveResponse.getPayload())), false);\n+    final VersionedPrivateTransaction versionedPrivateTransaction =\n+        VersionedPrivateTransaction.readFrom(bytesValueRLPInput);\n+    final PrivateTransaction privateTransaction =\n+        versionedPrivateTransaction.getPrivateTransaction();\n+    final Bytes32 version = versionedPrivateTransaction.getVersion();\n+\n+    final WorldUpdater publicWorldState = messageFrame.getWorldState();\n+\n+    final Optional<Bytes> maybeGroupId = privateTransaction.getPrivacyGroupId();\n+    if (maybeGroupId.isEmpty()) {\n+      return Bytes.EMPTY;\n+    }\n+\n+    final Bytes32 privacyGroupId = Bytes32.wrap(maybeGroupId.get());\n+\n+    LOG.debug(\n+        \"Processing private transaction {} in privacy group {}\",\n+        privateTransaction.getHash(),\n+        privacyGroupId);\n+\n+    final PrivacyGroupHeadBlockMap privacyGroupHeadBlockMap =\n+        privateStateStorage.getPrivacyGroupHeadBlockMap(currentBlockHash).orElseThrow();\n+\n+    final Blockchain blockchain = messageFrame.getBlockchain();\n+\n+    final Hash lastRootHash =\n+        privateStateRootResolver.resolveLastStateRoot(privacyGroupId, currentBlockHash);\n+\n+    final MutableWorldState disposablePrivateState =\n+        privateWorldStateArchive.getMutable(lastRootHash).get();\n+\n+    final WorldUpdater privateWorldStateUpdater = disposablePrivateState.updater();\n+\n+    maybeInjectDefaultManagementAndProxy(\n+        lastRootHash, disposablePrivateState, privateWorldStateUpdater);\n+\n+    final boolean isAddingParticipant =\n+        privateTransaction\n+            .getPayload()\n+            .toHexString()\n+            .startsWith(OnChainGroupManagement.ADD_TO_GROUP_METHOD_SIGNATURE.toHexString());\n+\n+    final boolean isContractLocked =\n+        isContractLocked(\n+            messageFrame,\n+            currentBlockHeader,\n+            publicWorldState,\n+            privacyGroupId,\n+            blockchain,\n+            disposablePrivateState,\n+            privateWorldStateUpdater,\n+            OnChainGroupManagement.CAN_EXECUTE_METHOD_SIGNATURE);\n+\n+    if (isAddingParticipant && !isContractLocked) {\n+      LOG.debug(\n+          \"Privacy Group {} is not locked while trying to add to group with commitment {}\",\n+          privacyGroupId.toHexString(),\n+          messageFrame.getTransactionHash());\n+      return Bytes.EMPTY;\n+    }\n+\n+    if (!isAddingParticipant && isContractLocked) {\n+      LOG.debug(\n+          \"Privacy Group {} is locked while trying to execute transaction with commitment {}\",\n+          privacyGroupId.toHexString(),\n+          messageFrame.getTransactionHash());\n+      return Bytes.EMPTY;\n+    }\n+\n+    if (!onChainVersionMatches(", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5MDcyOQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386190729", "bodyText": "That should be a constant ....", "author": "pinges", "createdAt": "2020-03-02T04:14:45Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/OnChainPrivacyPrecompiledContract.java", "diffHunk": "@@ -0,0 +1,466 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.mainnet.precompiles.privacy;\n+\n+import static org.hyperledger.besu.crypto.Hash.keccak256;\n+import static org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver.EMPTY_ROOT_HASH;\n+\n+import org.hyperledger.besu.crypto.SECP256K1;\n+import org.hyperledger.besu.enclave.Enclave;\n+import org.hyperledger.besu.enclave.EnclaveClientException;\n+import org.hyperledger.besu.enclave.EnclaveIOException;\n+import org.hyperledger.besu.enclave.EnclaveServerException;\n+import org.hyperledger.besu.enclave.types.ReceiveResponse;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.DefaultEvmAccount;\n+import org.hyperledger.besu.ethereum.core.Gas;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableAccount;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.PrivacyParameters;\n+import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;\n+import org.hyperledger.besu.ethereum.core.Wei;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.debug.TraceOptions;\n+import org.hyperledger.besu.ethereum.mainnet.AbstractPrecompiledContract;\n+import org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransaction;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionProcessor;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionReceipt;\n+import org.hyperledger.besu.ethereum.privacy.Restriction;\n+import org.hyperledger.besu.ethereum.privacy.VersionedPrivateTransaction;\n+import org.hyperledger.besu.ethereum.privacy.group.OnChainGroupManagement;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateBlockMetadata;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateTransactionMetadata;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLP;\n+import org.hyperledger.besu.ethereum.vm.DebugOperationTracer;\n+import org.hyperledger.besu.ethereum.vm.GasCalculator;\n+import org.hyperledger.besu.ethereum.vm.MessageFrame;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.Base64;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class OnChainPrivacyPrecompiledContract extends AbstractPrecompiledContract {\n+\n+  // Dummy signature for transactions to not fail being processed.\n+  private static final SECP256K1.Signature FAKE_SIGNATURE =\n+      SECP256K1.Signature.create(SECP256K1.HALF_CURVE_ORDER, SECP256K1.HALF_CURVE_ORDER, (byte) 0);\n+\n+  private final Enclave enclave;\n+  private final WorldStateArchive privateWorldStateArchive;\n+  private final PrivateStateStorage privateStateStorage;\n+  private final PrivateStateRootResolver privateStateRootResolver;\n+  private PrivateTransactionProcessor privateTransactionProcessor;\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  public OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator, final PrivacyParameters privacyParameters) {\n+    this(\n+        gasCalculator,\n+        privacyParameters.getEnclave(),\n+        privacyParameters.getPrivateWorldStateArchive(),\n+        privacyParameters.getPrivateStateStorage());\n+  }\n+\n+  OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator,\n+      final Enclave enclave,\n+      final WorldStateArchive worldStateArchive,\n+      final PrivateStateStorage privateStateStorage) {\n+    super(\"OnChainPrivacy\", gasCalculator);\n+    this.enclave = enclave;\n+    this.privateWorldStateArchive = worldStateArchive;\n+    this.privateStateStorage = privateStateStorage;\n+    this.privateStateRootResolver = new PrivateStateRootResolver(privateStateStorage);\n+  }\n+\n+  public void setPrivateTransactionProcessor(\n+      final PrivateTransactionProcessor privateTransactionProcessor) {\n+    this.privateTransactionProcessor = privateTransactionProcessor;\n+  }\n+\n+  @Override\n+  public Gas gasRequirement(final Bytes input) {\n+    return Gas.of(0L);\n+  }\n+\n+  @Override\n+  public Bytes compute(final Bytes input, final MessageFrame messageFrame) {\n+    final ProcessableBlockHeader currentBlockHeader = messageFrame.getBlockHeader();\n+    if (!BlockHeader.class.isAssignableFrom(currentBlockHeader.getClass())) {\n+      if (!messageFrame.isPersistingPrivateState()) {\n+        // We get in here from block mining.\n+        return Bytes.EMPTY;\n+      } else {\n+        throw new IllegalArgumentException(\n+            \"The MessageFrame contains an illegal block header type. Cannot persist private block metadata without current block hash.\");\n+      }\n+    }\n+    final Hash currentBlockHash = ((BlockHeader) currentBlockHeader).getHash();\n+\n+    final String key = input.slice(0, 32).toBase64String();\n+\n+    final ReceiveResponse receiveResponse;\n+    try {\n+      receiveResponse = enclave.receive(key);\n+    } catch (final EnclaveClientException e) {\n+      LOG.debug(\"Can not fetch private transaction payload with key {}\", key, e);\n+      return Bytes.EMPTY;\n+    } catch (final EnclaveServerException e) {\n+      LOG.error(\"Enclave is responding but errored perhaps it has a misconfiguration?\", e);\n+      throw e;\n+    } catch (final EnclaveIOException e) {\n+      LOG.error(\"Can not communicate with enclave is it up?\", e);\n+      throw e;\n+    }\n+\n+    final BytesValueRLPInput bytesValueRLPInput =\n+        new BytesValueRLPInput(\n+            Bytes.wrap(Base64.getDecoder().decode(receiveResponse.getPayload())), false);\n+    final VersionedPrivateTransaction versionedPrivateTransaction =\n+        VersionedPrivateTransaction.readFrom(bytesValueRLPInput);\n+    final PrivateTransaction privateTransaction =\n+        versionedPrivateTransaction.getPrivateTransaction();\n+    final Bytes32 version = versionedPrivateTransaction.getVersion();\n+\n+    final WorldUpdater publicWorldState = messageFrame.getWorldState();\n+\n+    final Optional<Bytes> maybeGroupId = privateTransaction.getPrivacyGroupId();\n+    if (maybeGroupId.isEmpty()) {\n+      return Bytes.EMPTY;\n+    }\n+\n+    final Bytes32 privacyGroupId = Bytes32.wrap(maybeGroupId.get());\n+\n+    LOG.debug(\n+        \"Processing private transaction {} in privacy group {}\",\n+        privateTransaction.getHash(),\n+        privacyGroupId);\n+\n+    final PrivacyGroupHeadBlockMap privacyGroupHeadBlockMap =\n+        privateStateStorage.getPrivacyGroupHeadBlockMap(currentBlockHash).orElseThrow();\n+\n+    final Blockchain blockchain = messageFrame.getBlockchain();\n+\n+    final Hash lastRootHash =\n+        privateStateRootResolver.resolveLastStateRoot(privacyGroupId, currentBlockHash);\n+\n+    final MutableWorldState disposablePrivateState =\n+        privateWorldStateArchive.getMutable(lastRootHash).get();\n+\n+    final WorldUpdater privateWorldStateUpdater = disposablePrivateState.updater();\n+\n+    maybeInjectDefaultManagementAndProxy(\n+        lastRootHash, disposablePrivateState, privateWorldStateUpdater);\n+\n+    final boolean isAddingParticipant =\n+        privateTransaction\n+            .getPayload()\n+            .toHexString()\n+            .startsWith(OnChainGroupManagement.ADD_TO_GROUP_METHOD_SIGNATURE.toHexString());\n+\n+    final boolean isContractLocked =\n+        isContractLocked(\n+            messageFrame,\n+            currentBlockHeader,\n+            publicWorldState,\n+            privacyGroupId,\n+            blockchain,\n+            disposablePrivateState,\n+            privateWorldStateUpdater,\n+            OnChainGroupManagement.CAN_EXECUTE_METHOD_SIGNATURE);\n+\n+    if (isAddingParticipant && !isContractLocked) {\n+      LOG.debug(\n+          \"Privacy Group {} is not locked while trying to add to group with commitment {}\",\n+          privacyGroupId.toHexString(),\n+          messageFrame.getTransactionHash());\n+      return Bytes.EMPTY;\n+    }\n+\n+    if (!isAddingParticipant && isContractLocked) {\n+      LOG.debug(\n+          \"Privacy Group {} is locked while trying to execute transaction with commitment {}\",\n+          privacyGroupId.toHexString(),\n+          messageFrame.getTransactionHash());\n+      return Bytes.EMPTY;\n+    }\n+\n+    if (!onChainVersionMatches(\n+        messageFrame,\n+        currentBlockHeader,\n+        version,\n+        publicWorldState,\n+        privacyGroupId,\n+        blockchain,\n+        disposablePrivateState,\n+        privateWorldStateUpdater)) return Bytes.EMPTY;\n+\n+    final PrivateTransactionProcessor.Result result =\n+        privateTransactionProcessor.processTransaction(\n+            blockchain,\n+            publicWorldState,\n+            privateWorldStateUpdater,\n+            currentBlockHeader,\n+            privateTransaction,\n+            messageFrame.getMiningBeneficiary(),\n+            new DebugOperationTracer(TraceOptions.DEFAULT),\n+            messageFrame.getBlockHashLookup(),\n+            privacyGroupId);\n+\n+    if (result.isInvalid() || !result.isSuccessful()) {\n+      LOG.error(\n+          \"Failed to process private transaction {}: {}\",\n+          privateTransaction.getHash(),\n+          result.getValidationResult().getErrorMessage());\n+      return Bytes.EMPTY;\n+    }\n+\n+    if (messageFrame.isPersistingPrivateState()) {\n+      persistPrivateState(\n+          messageFrame.getTransactionHash(),\n+          currentBlockHash,\n+          privateTransaction,\n+          privacyGroupId,\n+          privacyGroupHeadBlockMap,\n+          disposablePrivateState,\n+          privateWorldStateUpdater,\n+          result,\n+          privateTransaction.getPayload());\n+    }\n+\n+    return result.getOutput();\n+  }\n+\n+  protected boolean isContractLocked(\n+      final MessageFrame messageFrame,\n+      final ProcessableBlockHeader currentBlockHeader,\n+      final WorldUpdater publicWorldState,\n+      final Bytes32 privacyGroupId,\n+      final Blockchain blockchain,\n+      final MutableWorldState disposablePrivateState,\n+      final WorldUpdater privateWorldStateUpdater,\n+      final Bytes canExecuteMethodSignature) {", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5MzU2NA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386193564", "bodyText": "Do we really want to remove that from the map? If yes, I thought that this would only be done on the node that is being removed ....", "author": "pinges", "createdAt": "2020-03-02T04:32:55Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/OnChainPrivacyPrecompiledContract.java", "diffHunk": "@@ -0,0 +1,466 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.mainnet.precompiles.privacy;\n+\n+import static org.hyperledger.besu.crypto.Hash.keccak256;\n+import static org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver.EMPTY_ROOT_HASH;\n+\n+import org.hyperledger.besu.crypto.SECP256K1;\n+import org.hyperledger.besu.enclave.Enclave;\n+import org.hyperledger.besu.enclave.EnclaveClientException;\n+import org.hyperledger.besu.enclave.EnclaveIOException;\n+import org.hyperledger.besu.enclave.EnclaveServerException;\n+import org.hyperledger.besu.enclave.types.ReceiveResponse;\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.DefaultEvmAccount;\n+import org.hyperledger.besu.ethereum.core.Gas;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableAccount;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.PrivacyParameters;\n+import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;\n+import org.hyperledger.besu.ethereum.core.Wei;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.debug.TraceOptions;\n+import org.hyperledger.besu.ethereum.mainnet.AbstractPrecompiledContract;\n+import org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransaction;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionProcessor;\n+import org.hyperledger.besu.ethereum.privacy.PrivateTransactionReceipt;\n+import org.hyperledger.besu.ethereum.privacy.Restriction;\n+import org.hyperledger.besu.ethereum.privacy.VersionedPrivateTransaction;\n+import org.hyperledger.besu.ethereum.privacy.group.OnChainGroupManagement;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateBlockMetadata;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateTransactionMetadata;\n+import org.hyperledger.besu.ethereum.rlp.BytesValueRLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLP;\n+import org.hyperledger.besu.ethereum.vm.DebugOperationTracer;\n+import org.hyperledger.besu.ethereum.vm.GasCalculator;\n+import org.hyperledger.besu.ethereum.vm.MessageFrame;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.Base64;\n+import java.util.Optional;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class OnChainPrivacyPrecompiledContract extends AbstractPrecompiledContract {\n+\n+  // Dummy signature for transactions to not fail being processed.\n+  private static final SECP256K1.Signature FAKE_SIGNATURE =\n+      SECP256K1.Signature.create(SECP256K1.HALF_CURVE_ORDER, SECP256K1.HALF_CURVE_ORDER, (byte) 0);\n+\n+  private final Enclave enclave;\n+  private final WorldStateArchive privateWorldStateArchive;\n+  private final PrivateStateStorage privateStateStorage;\n+  private final PrivateStateRootResolver privateStateRootResolver;\n+  private PrivateTransactionProcessor privateTransactionProcessor;\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  public OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator, final PrivacyParameters privacyParameters) {\n+    this(\n+        gasCalculator,\n+        privacyParameters.getEnclave(),\n+        privacyParameters.getPrivateWorldStateArchive(),\n+        privacyParameters.getPrivateStateStorage());\n+  }\n+\n+  OnChainPrivacyPrecompiledContract(\n+      final GasCalculator gasCalculator,\n+      final Enclave enclave,\n+      final WorldStateArchive worldStateArchive,\n+      final PrivateStateStorage privateStateStorage) {\n+    super(\"OnChainPrivacy\", gasCalculator);\n+    this.enclave = enclave;\n+    this.privateWorldStateArchive = worldStateArchive;\n+    this.privateStateStorage = privateStateStorage;\n+    this.privateStateRootResolver = new PrivateStateRootResolver(privateStateStorage);\n+  }\n+\n+  public void setPrivateTransactionProcessor(\n+      final PrivateTransactionProcessor privateTransactionProcessor) {\n+    this.privateTransactionProcessor = privateTransactionProcessor;\n+  }\n+\n+  @Override\n+  public Gas gasRequirement(final Bytes input) {\n+    return Gas.of(0L);\n+  }\n+\n+  @Override\n+  public Bytes compute(final Bytes input, final MessageFrame messageFrame) {\n+    final ProcessableBlockHeader currentBlockHeader = messageFrame.getBlockHeader();\n+    if (!BlockHeader.class.isAssignableFrom(currentBlockHeader.getClass())) {\n+      if (!messageFrame.isPersistingPrivateState()) {\n+        // We get in here from block mining.\n+        return Bytes.EMPTY;\n+      } else {\n+        throw new IllegalArgumentException(\n+            \"The MessageFrame contains an illegal block header type. Cannot persist private block metadata without current block hash.\");\n+      }\n+    }\n+    final Hash currentBlockHash = ((BlockHeader) currentBlockHeader).getHash();\n+\n+    final String key = input.slice(0, 32).toBase64String();\n+\n+    final ReceiveResponse receiveResponse;\n+    try {\n+      receiveResponse = enclave.receive(key);\n+    } catch (final EnclaveClientException e) {\n+      LOG.debug(\"Can not fetch private transaction payload with key {}\", key, e);\n+      return Bytes.EMPTY;\n+    } catch (final EnclaveServerException e) {\n+      LOG.error(\"Enclave is responding but errored perhaps it has a misconfiguration?\", e);\n+      throw e;\n+    } catch (final EnclaveIOException e) {\n+      LOG.error(\"Can not communicate with enclave is it up?\", e);\n+      throw e;\n+    }\n+\n+    final BytesValueRLPInput bytesValueRLPInput =\n+        new BytesValueRLPInput(\n+            Bytes.wrap(Base64.getDecoder().decode(receiveResponse.getPayload())), false);\n+    final VersionedPrivateTransaction versionedPrivateTransaction =\n+        VersionedPrivateTransaction.readFrom(bytesValueRLPInput);\n+    final PrivateTransaction privateTransaction =\n+        versionedPrivateTransaction.getPrivateTransaction();\n+    final Bytes32 version = versionedPrivateTransaction.getVersion();\n+\n+    final WorldUpdater publicWorldState = messageFrame.getWorldState();\n+\n+    final Optional<Bytes> maybeGroupId = privateTransaction.getPrivacyGroupId();\n+    if (maybeGroupId.isEmpty()) {\n+      return Bytes.EMPTY;\n+    }\n+\n+    final Bytes32 privacyGroupId = Bytes32.wrap(maybeGroupId.get());\n+\n+    LOG.debug(\n+        \"Processing private transaction {} in privacy group {}\",\n+        privateTransaction.getHash(),\n+        privacyGroupId);\n+\n+    final PrivacyGroupHeadBlockMap privacyGroupHeadBlockMap =\n+        privateStateStorage.getPrivacyGroupHeadBlockMap(currentBlockHash).orElseThrow();\n+\n+    final Blockchain blockchain = messageFrame.getBlockchain();\n+\n+    final Hash lastRootHash =\n+        privateStateRootResolver.resolveLastStateRoot(privacyGroupId, currentBlockHash);\n+\n+    final MutableWorldState disposablePrivateState =\n+        privateWorldStateArchive.getMutable(lastRootHash).get();\n+\n+    final WorldUpdater privateWorldStateUpdater = disposablePrivateState.updater();\n+\n+    maybeInjectDefaultManagementAndProxy(\n+        lastRootHash, disposablePrivateState, privateWorldStateUpdater);\n+\n+    final boolean isAddingParticipant =\n+        privateTransaction\n+            .getPayload()\n+            .toHexString()\n+            .startsWith(OnChainGroupManagement.ADD_TO_GROUP_METHOD_SIGNATURE.toHexString());\n+\n+    final boolean isContractLocked =\n+        isContractLocked(\n+            messageFrame,\n+            currentBlockHeader,\n+            publicWorldState,\n+            privacyGroupId,\n+            blockchain,\n+            disposablePrivateState,\n+            privateWorldStateUpdater,\n+            OnChainGroupManagement.CAN_EXECUTE_METHOD_SIGNATURE);\n+\n+    if (isAddingParticipant && !isContractLocked) {\n+      LOG.debug(\n+          \"Privacy Group {} is not locked while trying to add to group with commitment {}\",\n+          privacyGroupId.toHexString(),\n+          messageFrame.getTransactionHash());\n+      return Bytes.EMPTY;\n+    }\n+\n+    if (!isAddingParticipant && isContractLocked) {\n+      LOG.debug(\n+          \"Privacy Group {} is locked while trying to execute transaction with commitment {}\",\n+          privacyGroupId.toHexString(),\n+          messageFrame.getTransactionHash());\n+      return Bytes.EMPTY;\n+    }\n+\n+    if (!onChainVersionMatches(\n+        messageFrame,\n+        currentBlockHeader,\n+        version,\n+        publicWorldState,\n+        privacyGroupId,\n+        blockchain,\n+        disposablePrivateState,\n+        privateWorldStateUpdater)) return Bytes.EMPTY;\n+\n+    final PrivateTransactionProcessor.Result result =\n+        privateTransactionProcessor.processTransaction(\n+            blockchain,\n+            publicWorldState,\n+            privateWorldStateUpdater,\n+            currentBlockHeader,\n+            privateTransaction,\n+            messageFrame.getMiningBeneficiary(),\n+            new DebugOperationTracer(TraceOptions.DEFAULT),\n+            messageFrame.getBlockHashLookup(),\n+            privacyGroupId);\n+\n+    if (result.isInvalid() || !result.isSuccessful()) {\n+      LOG.error(\n+          \"Failed to process private transaction {}: {}\",\n+          privateTransaction.getHash(),\n+          result.getValidationResult().getErrorMessage());\n+      return Bytes.EMPTY;\n+    }\n+\n+    if (messageFrame.isPersistingPrivateState()) {\n+      persistPrivateState(\n+          messageFrame.getTransactionHash(),\n+          currentBlockHash,\n+          privateTransaction,\n+          privacyGroupId,\n+          privacyGroupHeadBlockMap,\n+          disposablePrivateState,\n+          privateWorldStateUpdater,\n+          result,\n+          privateTransaction.getPayload());\n+    }\n+\n+    return result.getOutput();\n+  }\n+\n+  protected boolean isContractLocked(\n+      final MessageFrame messageFrame,\n+      final ProcessableBlockHeader currentBlockHeader,\n+      final WorldUpdater publicWorldState,\n+      final Bytes32 privacyGroupId,\n+      final Blockchain blockchain,\n+      final MutableWorldState disposablePrivateState,\n+      final WorldUpdater privateWorldStateUpdater,\n+      final Bytes canExecuteMethodSignature) {\n+    final PrivateTransactionProcessor.Result result =\n+        checkCanExecute(\n+            messageFrame,\n+            currentBlockHeader,\n+            publicWorldState,\n+            privacyGroupId,\n+            blockchain,\n+            disposablePrivateState,\n+            privateWorldStateUpdater,\n+            canExecuteMethodSignature);\n+    return result.getOutput().toHexString().endsWith(\"0\");\n+  }\n+\n+  protected PrivateTransactionProcessor.Result checkCanExecute(\n+      final MessageFrame messageFrame,\n+      final ProcessableBlockHeader currentBlockHeader,\n+      final WorldUpdater publicWorldState,\n+      final Bytes32 privacyGroupId,\n+      final Blockchain currentBlockchain,\n+      final MutableWorldState disposablePrivateState,\n+      final WorldUpdater privateWorldStateUpdater,\n+      final Bytes canExecuteMethodSignature) {\n+    // We need the \"lock status\" of the group for every single transaction but we don't want this\n+    // call to affect the state\n+    // privateTransactionProcessor.processTransaction(...) commits the state if the process was\n+    // successful before it returns\n+    final MutableWorldState canExecutePrivateState =\n+        privateWorldStateArchive.getMutable(disposablePrivateState.rootHash()).get();\n+    final WorldUpdater canExecuteUpdater = canExecutePrivateState.updater();\n+\n+    return privateTransactionProcessor.processTransaction(\n+        currentBlockchain,\n+        publicWorldState,\n+        canExecuteUpdater,\n+        currentBlockHeader,\n+        buildSimulationTransaction(\n+            privacyGroupId, privateWorldStateUpdater, canExecuteMethodSignature),\n+        messageFrame.getMiningBeneficiary(),\n+        new DebugOperationTracer(TraceOptions.DEFAULT),\n+        messageFrame.getBlockHashLookup(),\n+        privacyGroupId);\n+  }\n+\n+  protected void maybeInjectDefaultManagementAndProxy(\n+      final Hash lastRootHash,\n+      final MutableWorldState disposablePrivateState,\n+      final WorldUpdater privateWorldStateUpdater) {\n+    if (lastRootHash.equals(EMPTY_ROOT_HASH)) {\n+      // inject management\n+      final DefaultEvmAccount managementPrecompile =\n+          privateWorldStateUpdater.createAccount(Address.DEFAULT_PRIVACY_MANAGEMENT);\n+      final MutableAccount mutableManagementPrecompiled = managementPrecompile.getMutable();\n+      // this is the code for the simple management contract\n+      mutableManagementPrecompiled.setCode(OnChainGroupManagement.DEFAULT_GROUP_MANAGEMENT_CODE);\n+\n+      // inject proxy\n+      final DefaultEvmAccount proxyPrecompile =\n+          privateWorldStateUpdater.createAccount(Address.PRIVACY_PROXY);\n+      final MutableAccount mutableProxyPrecompiled = proxyPrecompile.getMutable();\n+      // this is the code for the proxy contract\n+      mutableProxyPrecompiled.setCode(OnChainGroupManagement.DEFAULT_PROXY_PRECOMPILED_CODE);\n+      // manually set the management contract address so the proxy can trust it\n+      mutableProxyPrecompiled.setStorageValue(\n+          UInt256.ZERO, UInt256.fromBytes(Bytes32.leftPad(Address.DEFAULT_PRIVACY_MANAGEMENT)));\n+\n+      privateWorldStateUpdater.commit();\n+      disposablePrivateState.persist();\n+    }\n+  }\n+\n+  protected boolean onChainVersionMatches(\n+      final MessageFrame messageFrame,\n+      final ProcessableBlockHeader currentBlockHeader,\n+      final Bytes32 version,\n+      final WorldUpdater publicWorldState,\n+      final Bytes32 privacyGroupId,\n+      final Blockchain currentBlockchain,\n+      final MutableWorldState disposablePrivateState,\n+      final WorldUpdater privateWorldStateUpdater) {\n+    // We need the \"version\" of the group for every single transaction but we don't want this\n+    // call to affect the state\n+    // privateTransactionProcessor.processTransaction(...) commits the state if the process was\n+    // successful before it returns\n+    final PrivateTransactionProcessor.Result getVersionResult =\n+        checkCanExecute(\n+            messageFrame,\n+            currentBlockHeader,\n+            publicWorldState,\n+            privacyGroupId,\n+            currentBlockchain,\n+            disposablePrivateState,\n+            privateWorldStateUpdater,\n+            OnChainGroupManagement.GET_VERSION_METHOD_SIGNATURE);\n+\n+    if (version.equals(getVersionResult.getOutput())) {\n+      return true;\n+    }\n+    LOG.debug(\n+        \"Privacy Group {} version mismatch for commitment {}: expecting {} but got {}\",\n+        privacyGroupId.toBase64String(),\n+        messageFrame.getTransactionHash(),\n+        getVersionResult.getOutput(),\n+        version);\n+    return false;\n+  }\n+\n+  protected void persistPrivateState(\n+      final Hash commitmentHash,\n+      final Hash currentBlockHash,\n+      final PrivateTransaction privateTransaction,\n+      final Bytes32 privacyGroupId,\n+      final PrivacyGroupHeadBlockMap privacyGroupHeadBlockMap,\n+      final MutableWorldState disposablePrivateState,\n+      final WorldUpdater privateWorldStateUpdater,\n+      final PrivateTransactionProcessor.Result result,\n+      final Bytes payload) {\n+\n+    LOG.trace(\n+        \"Persisting private state {} for privacyGroup {}\",\n+        disposablePrivateState.rootHash(),\n+        privacyGroupId);\n+    privateWorldStateUpdater.commit();\n+    disposablePrivateState.persist();\n+\n+    final PrivateStateStorage.Updater privateStateUpdater = privateStateStorage.updater();\n+\n+    updatePrivateBlockMetadata(\n+        commitmentHash,\n+        currentBlockHash,\n+        privacyGroupId,\n+        disposablePrivateState.rootHash(),\n+        privateStateUpdater);\n+\n+    final Bytes32 txHash = keccak256(RLP.encode(privateTransaction::writeTo));\n+\n+    final int txStatus =\n+        result.getStatus() == PrivateTransactionProcessor.Result.Status.SUCCESSFUL ? 1 : 0;\n+\n+    final PrivateTransactionReceipt privateTransactionReceipt =\n+        new PrivateTransactionReceipt(\n+            txStatus, result.getLogs(), result.getOutput(), result.getRevertReason());\n+\n+    privateStateUpdater.putTransactionReceipt(currentBlockHash, txHash, privateTransactionReceipt);\n+\n+    if (!privacyGroupHeadBlockMap.contains(Bytes32.wrap(privacyGroupId), currentBlockHash)) {\n+      privacyGroupHeadBlockMap.put(Bytes32.wrap(privacyGroupId), currentBlockHash);\n+      privateStateUpdater.putPrivacyGroupHeadBlockMap(\n+          currentBlockHash, new PrivacyGroupHeadBlockMap(privacyGroupHeadBlockMap));\n+    }\n+\n+    if (payload\n+        .toHexString()\n+        .startsWith(OnChainGroupManagement.REMOVE_PARTICIPANT_METHOD_SIGNATURE.toHexString())) {\n+      privacyGroupHeadBlockMap.remove(Bytes32.wrap(privacyGroupId));", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYwMjIzNA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387602234", "bodyText": "Yes - this is fine - all the nodes that are not being removed should continue to track the group. The reason this is here is so you can do add -> remove -> add .\nWe should discuss this on a call if you are not happy because I exhausted all other options before doing this.", "author": "iikirilov", "createdAt": "2020-03-04T11:18:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5MzU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5MzgzOA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386193838", "bodyText": "I guess that was only needed when you were debugging this stuff ....", "author": "pinges", "createdAt": "2020-03-02T04:34:39Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/PrivacyPrecompiledContract.java", "diffHunk": "@@ -126,7 +126,9 @@ public Bytes compute(final Bytes input, final MessageFrame messageFrame) {\n     final BytesValueRLPInput bytesValueRLPInput =\n         new BytesValueRLPInput(\n             Bytes.wrap(Base64.getDecoder().decode(receiveResponse.getPayload())), false);\n-    final PrivateTransaction privateTransaction = PrivateTransaction.readFrom(bytesValueRLPInput);\n+    LOG.info(bytesValueRLPInput.raw().toHexString());", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NDY0MA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386194640", "bodyText": "Do we really have to check that we are allowed to produce a PMT when we are in multi tenancy mode?\nI think that this class was meant to be there to check whether users should be allowed to access privacy group specific information when we are in multi tenancy mode.", "author": "pinges", "createdAt": "2020-03-02T04:39:42Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/DefaultPrivacyController.java", "diffHunk": "@@ -122,6 +150,15 @@ public Transaction createPrivacyMarkerTransaction(\n     return privateMarkerTransactionFactory.create(transactionEnclaveKey, privateTransaction);\n   }\n \n+  @Override\n+  public Transaction createPrivacyMarkerTransaction(", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYwMzIxMg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387603212", "bodyText": "the multi tenancy controller just delegates to the default controller which delegates to the privacy marker transaction factory.\nNo checks are done for this method", "author": "iikirilov", "createdAt": "2020-03-04T11:20:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NDY0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NjM1Mw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386196353", "bodyText": "We should either remove the other createPrivacyMarkerTransaction method (without the prcompile address) or at least make it use this method.", "author": "pinges", "createdAt": "2020-03-02T04:50:01Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/DefaultPrivacyController.java", "diffHunk": "@@ -122,6 +150,15 @@ public Transaction createPrivacyMarkerTransaction(\n     return privateMarkerTransactionFactory.create(transactionEnclaveKey, privateTransaction);\n   }\n \n+  @Override\n+  public Transaction createPrivacyMarkerTransaction(", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYwMzk0Mg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387603942", "bodyText": "the privacy marker transaction factory resolves the address if it is not available - i.e. we cannot do what you are suggesting inside the privacy controller.", "author": "iikirilov", "createdAt": "2020-03-04T11:21:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NjM1Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYwNDA3OA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387604078", "bodyText": "at least not without a sizeable refactor", "author": "iikirilov", "createdAt": "2020-03-04T11:22:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjE5NjM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIwMTE2MQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386201161", "bodyText": "It will only find on chain groups, so maybe we should call it PivxFindOnChainPrivacyGroup?", "author": "pinges", "createdAt": "2020-03-02T05:18:23Z", "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/privx/PrivxFindPrivacyGroup.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.api.jsonrpc.internal.privacy.methods.privx;\n+\n+import static org.apache.logging.log4j.LogManager.getLogger;\n+\n+import org.hyperledger.besu.enclave.types.PrivacyGroup;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.RpcMethod;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequestContext;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.JsonRpcMethod;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.privacy.methods.EnclavePublicKeyProvider;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcResponse;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcSuccessResponse;\n+import org.hyperledger.besu.ethereum.privacy.PrivacyController;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+public class PrivxFindPrivacyGroup implements JsonRpcMethod {\n+\n+  private static final Logger LOG = getLogger();\n+  private final PrivacyController privacyController;\n+  private final EnclavePublicKeyProvider enclavePublicKeyProvider;\n+\n+  public PrivxFindPrivacyGroup(", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYwNDUzMw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387604533", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T11:23:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIwMTE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIwMTUzMQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386201531", "bodyText": "We have to check whether the caller is a member of the privacy groups(s) retrurned by this class. The right spot to check that is probably the MultiTenancyController.", "author": "pinges", "createdAt": "2020-03-02T05:20:35Z", "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/privx/PrivxFindPrivacyGroup.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.api.jsonrpc.internal.privacy.methods.privx;\n+\n+import static org.apache.logging.log4j.LogManager.getLogger;\n+\n+import org.hyperledger.besu.enclave.types.PrivacyGroup;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.RpcMethod;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.JsonRpcRequestContext;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.methods.JsonRpcMethod;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.privacy.methods.EnclavePublicKeyProvider;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcResponse;\n+import org.hyperledger.besu.ethereum.api.jsonrpc.internal.response.JsonRpcSuccessResponse;\n+import org.hyperledger.besu.ethereum.privacy.PrivacyController;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.apache.logging.log4j.Logger;\n+\n+public class PrivxFindPrivacyGroup implements JsonRpcMethod {\n+\n+  private static final Logger LOG = getLogger();\n+  private final PrivacyController privacyController;\n+  private final EnclavePublicKeyProvider enclavePublicKeyProvider;\n+\n+  public PrivxFindPrivacyGroup(\n+      final PrivacyController privacyController,\n+      final EnclavePublicKeyProvider enclavePublicKeyProvider) {\n+    this.privacyController = privacyController;\n+    this.enclavePublicKeyProvider = enclavePublicKeyProvider;\n+  }\n+\n+  @Override\n+  public String getName() {\n+    return RpcMethod.PRIVX_FIND_PRIVACY_GROUP.getMethodName();\n+  }\n+\n+  @Override\n+  public JsonRpcResponse response(final JsonRpcRequestContext requestContext) {\n+    LOG.trace(\"Executing {}\", RpcMethod.PRIVX_FIND_PRIVACY_GROUP.getMethodName());", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYwNTEzMg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387605132", "bodyText": "this already happens inside the default privacy controller", "author": "iikirilov", "createdAt": "2020-03-04T11:24:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIwMTUzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIwNjE5Nw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386206197", "bodyText": "Not sure this belongs here. We should discuss that on the next call.", "author": "pinges", "createdAt": "2020-03-02T05:45:08Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/MultiTenancyPrivacyController.java", "diffHunk": "@@ -124,6 +133,27 @@ public long determineBesuNonce(\n         privacyGroupId, enclavePublicKey, callParams, blockNumber);\n   }\n \n+  @Override\n+  public Optional<String> buildAndSendAddPayload(\n+      final PrivateTransaction privateTransaction, final String enclaveKey) {", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYwNTI4Mg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387605282", "bodyText": "ok", "author": "iikirilov", "createdAt": "2020-03-04T11:25:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIwNjE5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIwNjQwMg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386206402", "bodyText": "Do we have to check whether the caller is a member of the group returned?", "author": "pinges", "createdAt": "2020-03-02T05:46:01Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/MultiTenancyPrivacyController.java", "diffHunk": "@@ -124,6 +133,27 @@ public long determineBesuNonce(\n         privacyGroupId, enclavePublicKey, callParams, blockNumber);\n   }\n \n+  @Override\n+  public Optional<String> buildAndSendAddPayload(\n+      final PrivateTransaction privateTransaction, final String enclaveKey) {\n+    verifyPrivateFromMatchesEnclavePublicKey(\n+        privateTransaction.getPrivateFrom().toBase64String(), enclaveKey);\n+    verifyPrivacyGroupContainsEnclavePublicKey(\n+        privateTransaction.getPrivacyGroupId().get().toBase64String(), enclaveKey);\n+    return privacyController.buildAndSendAddPayload(privateTransaction, enclaveKey);\n+  }\n+\n+  @Override\n+  public PrivacyGroup retrievePrivacyGroup(final String privacyGroupId, final String enclaveKey) {\n+    return privacyController.retrievePrivacyGroup(privacyGroupId, enclaveKey);", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQyNTQzNw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386425437", "bodyText": "Seems that PrivGetTransactionReceipt calls this without verifying so I believe so.", "author": "josh-richardson", "createdAt": "2020-03-02T14:30:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIwNjQwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYwNTk1Mg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387605952", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T11:26:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIwNjQwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxNDY1Nw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386214657", "bodyText": "that can probably be removed, or at least be debug, or trace ...", "author": "pinges", "createdAt": "2020-03-02T06:25:25Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivateGroupRehydrationBlockProcessor.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy;\n+\n+import static org.hyperledger.besu.crypto.Hash.keccak256;\n+import static org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver.EMPTY_ROOT_HASH;\n+\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.DefaultEvmAccount;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableAccount;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;\n+import org.hyperledger.besu.ethereum.core.Transaction;\n+import org.hyperledger.besu.ethereum.core.TransactionReceipt;\n+import org.hyperledger.besu.ethereum.core.Wei;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.mainnet.AbstractBlockProcessor;\n+import org.hyperledger.besu.ethereum.mainnet.MainnetBlockProcessor;\n+import org.hyperledger.besu.ethereum.mainnet.MiningBeneficiaryCalculator;\n+import org.hyperledger.besu.ethereum.mainnet.TransactionProcessor;\n+import org.hyperledger.besu.ethereum.mainnet.TransactionValidationParams;\n+import org.hyperledger.besu.ethereum.privacy.group.OnChainGroupManagement;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateBlockMetadata;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateTransactionMetadata;\n+import org.hyperledger.besu.ethereum.rlp.RLP;\n+import org.hyperledger.besu.ethereum.vm.BlockHashLookup;\n+import org.hyperledger.besu.ethereum.vm.OperationTracer;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class PrivateGroupRehydrationBlockProcessor {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  static final int MAX_GENERATION = 6;\n+\n+  private final TransactionProcessor transactionProcessor;\n+  private final PrivateTransactionProcessor privateTransactionProcessor;\n+  private final MainnetBlockProcessor.TransactionReceiptFactory transactionReceiptFactory;\n+  final Wei blockReward;\n+  private final boolean skipZeroBlockRewards;\n+  private final MiningBeneficiaryCalculator miningBeneficiaryCalculator;\n+\n+  public PrivateGroupRehydrationBlockProcessor(\n+      final TransactionProcessor transactionProcessor,\n+      final PrivateTransactionProcessor privateTransactionProcessor,\n+      final MainnetBlockProcessor.TransactionReceiptFactory transactionReceiptFactory,\n+      final Wei blockReward,\n+      final MiningBeneficiaryCalculator miningBeneficiaryCalculator,\n+      final boolean skipZeroBlockRewards) {\n+    this.transactionProcessor = transactionProcessor;\n+    this.privateTransactionProcessor = privateTransactionProcessor;\n+    this.transactionReceiptFactory = transactionReceiptFactory;\n+    this.blockReward = blockReward;\n+    this.miningBeneficiaryCalculator = miningBeneficiaryCalculator;\n+    this.skipZeroBlockRewards = skipZeroBlockRewards;\n+  }\n+\n+  public AbstractBlockProcessor.Result processBlock(\n+      final Blockchain blockchain,\n+      final MutableWorldState worldState,\n+      final WorldStateArchive privateWorldStateArchive,\n+      final PrivateStateStorage privateStateStorage,\n+      final Block block,\n+      final Map<Hash, PrivateTransaction> forExecution,\n+      final List<BlockHeader> ommers) {\n+    long gasUsed = 0;\n+    final List<TransactionReceipt> receipts = new ArrayList<>();\n+\n+    final List<Transaction> transactions = block.getBody().getTransactions();\n+    final BlockHeader blockHeader = block.getHeader();\n+    for (final Transaction transaction : transactions) {\n+\n+      final long remainingGasBudget = blockHeader.getGasLimit() - gasUsed;\n+      if (Long.compareUnsigned(transaction.getGasLimit(), remainingGasBudget) > 0) {\n+        LOG.warn(\n+            \"Transaction processing error: transaction gas limit {} exceeds available block budget remaining {}\",\n+            transaction.getGasLimit(),\n+            remainingGasBudget);\n+        return AbstractBlockProcessor.Result.failed();\n+      }\n+\n+      final WorldUpdater worldStateUpdater = worldState.updater();\n+      final BlockHashLookup blockHashLookup = new BlockHashLookup(blockHeader, blockchain);\n+      final Address miningBeneficiary =\n+          miningBeneficiaryCalculator.calculateBeneficiary(blockHeader);\n+\n+      final PrivateStateRootResolver privateStateRootResolver =\n+          new PrivateStateRootResolver(privateStateStorage);\n+      if (forExecution.containsKey(transaction.getHash())) {\n+        final PrivateTransaction privateTransaction = forExecution.get(transaction.getHash());\n+        final Hash lastRootHash =\n+            privateStateRootResolver.resolveLastStateRoot(\n+                Bytes32.wrap(privateTransaction.getPrivacyGroupId().get()),\n+                blockHeader.getParentHash());\n+\n+        final MutableWorldState disposablePrivateState =\n+            privateWorldStateArchive.getMutable(lastRootHash).get();\n+        final WorldUpdater privateStateUpdater = disposablePrivateState.updater();\n+        maybeInjectDefaultManagementAndProxy(\n+            lastRootHash, disposablePrivateState, privateStateUpdater);\n+        LOG.info(\n+            \"Pre-rehydrate root hash: {} for tx {}\",\n+            disposablePrivateState.rootHash(),\n+            privateTransaction.getHash());\n+\n+        final PrivateTransactionProcessor.Result privateResult =\n+            privateTransactionProcessor.processTransaction(\n+                blockchain,\n+                worldStateUpdater.updater(),\n+                privateStateUpdater,\n+                blockHeader,\n+                privateTransaction,\n+                miningBeneficiary,\n+                OperationTracer.NO_TRACING,\n+                new BlockHashLookup(blockHeader, blockchain),\n+                privateTransaction.getPrivacyGroupId().get());\n+        persistPrivateState(\n+            transaction.getHash(),\n+            blockHeader.getHash(),\n+            privateTransaction,\n+            Bytes32.wrap(privateTransaction.getPrivacyGroupId().get()),\n+            disposablePrivateState,\n+            privateStateUpdater,\n+            privateStateStorage,\n+            privateResult);\n+        LOG.info(\"Post-rehydrate root hash: {}\", disposablePrivateState.rootHash());", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYwNjU1Ng==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387606556", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T11:27:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxNDY1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxNTc1MA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386215750", "bodyText": "this should be set to false, which means that any private transaction in the block will not be executed and will no persist anything!", "author": "pinges", "createdAt": "2020-03-02T06:30:10Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivateGroupRehydrationBlockProcessor.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy;\n+\n+import static org.hyperledger.besu.crypto.Hash.keccak256;\n+import static org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver.EMPTY_ROOT_HASH;\n+\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.DefaultEvmAccount;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableAccount;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;\n+import org.hyperledger.besu.ethereum.core.Transaction;\n+import org.hyperledger.besu.ethereum.core.TransactionReceipt;\n+import org.hyperledger.besu.ethereum.core.Wei;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.mainnet.AbstractBlockProcessor;\n+import org.hyperledger.besu.ethereum.mainnet.MainnetBlockProcessor;\n+import org.hyperledger.besu.ethereum.mainnet.MiningBeneficiaryCalculator;\n+import org.hyperledger.besu.ethereum.mainnet.TransactionProcessor;\n+import org.hyperledger.besu.ethereum.mainnet.TransactionValidationParams;\n+import org.hyperledger.besu.ethereum.privacy.group.OnChainGroupManagement;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateBlockMetadata;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateTransactionMetadata;\n+import org.hyperledger.besu.ethereum.rlp.RLP;\n+import org.hyperledger.besu.ethereum.vm.BlockHashLookup;\n+import org.hyperledger.besu.ethereum.vm.OperationTracer;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class PrivateGroupRehydrationBlockProcessor {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  static final int MAX_GENERATION = 6;\n+\n+  private final TransactionProcessor transactionProcessor;\n+  private final PrivateTransactionProcessor privateTransactionProcessor;\n+  private final MainnetBlockProcessor.TransactionReceiptFactory transactionReceiptFactory;\n+  final Wei blockReward;\n+  private final boolean skipZeroBlockRewards;\n+  private final MiningBeneficiaryCalculator miningBeneficiaryCalculator;\n+\n+  public PrivateGroupRehydrationBlockProcessor(\n+      final TransactionProcessor transactionProcessor,\n+      final PrivateTransactionProcessor privateTransactionProcessor,\n+      final MainnetBlockProcessor.TransactionReceiptFactory transactionReceiptFactory,\n+      final Wei blockReward,\n+      final MiningBeneficiaryCalculator miningBeneficiaryCalculator,\n+      final boolean skipZeroBlockRewards) {\n+    this.transactionProcessor = transactionProcessor;\n+    this.privateTransactionProcessor = privateTransactionProcessor;\n+    this.transactionReceiptFactory = transactionReceiptFactory;\n+    this.blockReward = blockReward;\n+    this.miningBeneficiaryCalculator = miningBeneficiaryCalculator;\n+    this.skipZeroBlockRewards = skipZeroBlockRewards;\n+  }\n+\n+  public AbstractBlockProcessor.Result processBlock(\n+      final Blockchain blockchain,\n+      final MutableWorldState worldState,\n+      final WorldStateArchive privateWorldStateArchive,\n+      final PrivateStateStorage privateStateStorage,\n+      final Block block,\n+      final Map<Hash, PrivateTransaction> forExecution,\n+      final List<BlockHeader> ommers) {\n+    long gasUsed = 0;\n+    final List<TransactionReceipt> receipts = new ArrayList<>();\n+\n+    final List<Transaction> transactions = block.getBody().getTransactions();\n+    final BlockHeader blockHeader = block.getHeader();\n+    for (final Transaction transaction : transactions) {\n+\n+      final long remainingGasBudget = blockHeader.getGasLimit() - gasUsed;\n+      if (Long.compareUnsigned(transaction.getGasLimit(), remainingGasBudget) > 0) {\n+        LOG.warn(\n+            \"Transaction processing error: transaction gas limit {} exceeds available block budget remaining {}\",\n+            transaction.getGasLimit(),\n+            remainingGasBudget);\n+        return AbstractBlockProcessor.Result.failed();\n+      }\n+\n+      final WorldUpdater worldStateUpdater = worldState.updater();\n+      final BlockHashLookup blockHashLookup = new BlockHashLookup(blockHeader, blockchain);\n+      final Address miningBeneficiary =\n+          miningBeneficiaryCalculator.calculateBeneficiary(blockHeader);\n+\n+      final PrivateStateRootResolver privateStateRootResolver =\n+          new PrivateStateRootResolver(privateStateStorage);\n+      if (forExecution.containsKey(transaction.getHash())) {\n+        final PrivateTransaction privateTransaction = forExecution.get(transaction.getHash());\n+        final Hash lastRootHash =\n+            privateStateRootResolver.resolveLastStateRoot(\n+                Bytes32.wrap(privateTransaction.getPrivacyGroupId().get()),\n+                blockHeader.getParentHash());\n+\n+        final MutableWorldState disposablePrivateState =\n+            privateWorldStateArchive.getMutable(lastRootHash).get();\n+        final WorldUpdater privateStateUpdater = disposablePrivateState.updater();\n+        maybeInjectDefaultManagementAndProxy(\n+            lastRootHash, disposablePrivateState, privateStateUpdater);\n+        LOG.info(\n+            \"Pre-rehydrate root hash: {} for tx {}\",\n+            disposablePrivateState.rootHash(),\n+            privateTransaction.getHash());\n+\n+        final PrivateTransactionProcessor.Result privateResult =\n+            privateTransactionProcessor.processTransaction(\n+                blockchain,\n+                worldStateUpdater.updater(),\n+                privateStateUpdater,\n+                blockHeader,\n+                privateTransaction,\n+                miningBeneficiary,\n+                OperationTracer.NO_TRACING,\n+                new BlockHashLookup(blockHeader, blockchain),\n+                privateTransaction.getPrivacyGroupId().get());\n+        persistPrivateState(\n+            transaction.getHash(),\n+            blockHeader.getHash(),\n+            privateTransaction,\n+            Bytes32.wrap(privateTransaction.getPrivacyGroupId().get()),\n+            disposablePrivateState,\n+            privateStateUpdater,\n+            privateStateStorage,\n+            privateResult);\n+        LOG.info(\"Post-rehydrate root hash: {}\", disposablePrivateState.rootHash());\n+      }\n+\n+      final TransactionProcessor.Result result =\n+          transactionProcessor.processTransaction(\n+              blockchain,\n+              worldStateUpdater,\n+              blockHeader,\n+              transaction,\n+              miningBeneficiary,\n+              blockHashLookup,\n+              true,", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYwODQ2OQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387608469", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T11:31:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxNTc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxNjI0Mw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386216243", "bodyText": "We have the same method in the precompile. Can we reuse the code?", "author": "pinges", "createdAt": "2020-03-02T06:32:14Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivateGroupRehydrationBlockProcessor.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy;\n+\n+import static org.hyperledger.besu.crypto.Hash.keccak256;\n+import static org.hyperledger.besu.ethereum.privacy.PrivateStateRootResolver.EMPTY_ROOT_HASH;\n+\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.DefaultEvmAccount;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableAccount;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.ProcessableBlockHeader;\n+import org.hyperledger.besu.ethereum.core.Transaction;\n+import org.hyperledger.besu.ethereum.core.TransactionReceipt;\n+import org.hyperledger.besu.ethereum.core.Wei;\n+import org.hyperledger.besu.ethereum.core.WorldUpdater;\n+import org.hyperledger.besu.ethereum.mainnet.AbstractBlockProcessor;\n+import org.hyperledger.besu.ethereum.mainnet.MainnetBlockProcessor;\n+import org.hyperledger.besu.ethereum.mainnet.MiningBeneficiaryCalculator;\n+import org.hyperledger.besu.ethereum.mainnet.TransactionProcessor;\n+import org.hyperledger.besu.ethereum.mainnet.TransactionValidationParams;\n+import org.hyperledger.besu.ethereum.privacy.group.OnChainGroupManagement;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateBlockMetadata;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateTransactionMetadata;\n+import org.hyperledger.besu.ethereum.rlp.RLP;\n+import org.hyperledger.besu.ethereum.vm.BlockHashLookup;\n+import org.hyperledger.besu.ethereum.vm.OperationTracer;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes32;\n+import org.apache.tuweni.units.bigints.UInt256;\n+\n+public class PrivateGroupRehydrationBlockProcessor {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  static final int MAX_GENERATION = 6;\n+\n+  private final TransactionProcessor transactionProcessor;\n+  private final PrivateTransactionProcessor privateTransactionProcessor;\n+  private final MainnetBlockProcessor.TransactionReceiptFactory transactionReceiptFactory;\n+  final Wei blockReward;\n+  private final boolean skipZeroBlockRewards;\n+  private final MiningBeneficiaryCalculator miningBeneficiaryCalculator;\n+\n+  public PrivateGroupRehydrationBlockProcessor(\n+      final TransactionProcessor transactionProcessor,\n+      final PrivateTransactionProcessor privateTransactionProcessor,\n+      final MainnetBlockProcessor.TransactionReceiptFactory transactionReceiptFactory,\n+      final Wei blockReward,\n+      final MiningBeneficiaryCalculator miningBeneficiaryCalculator,\n+      final boolean skipZeroBlockRewards) {\n+    this.transactionProcessor = transactionProcessor;\n+    this.privateTransactionProcessor = privateTransactionProcessor;\n+    this.transactionReceiptFactory = transactionReceiptFactory;\n+    this.blockReward = blockReward;\n+    this.miningBeneficiaryCalculator = miningBeneficiaryCalculator;\n+    this.skipZeroBlockRewards = skipZeroBlockRewards;\n+  }\n+\n+  public AbstractBlockProcessor.Result processBlock(\n+      final Blockchain blockchain,\n+      final MutableWorldState worldState,\n+      final WorldStateArchive privateWorldStateArchive,\n+      final PrivateStateStorage privateStateStorage,\n+      final Block block,\n+      final Map<Hash, PrivateTransaction> forExecution,\n+      final List<BlockHeader> ommers) {\n+    long gasUsed = 0;\n+    final List<TransactionReceipt> receipts = new ArrayList<>();\n+\n+    final List<Transaction> transactions = block.getBody().getTransactions();\n+    final BlockHeader blockHeader = block.getHeader();\n+    for (final Transaction transaction : transactions) {\n+\n+      final long remainingGasBudget = blockHeader.getGasLimit() - gasUsed;\n+      if (Long.compareUnsigned(transaction.getGasLimit(), remainingGasBudget) > 0) {\n+        LOG.warn(\n+            \"Transaction processing error: transaction gas limit {} exceeds available block budget remaining {}\",\n+            transaction.getGasLimit(),\n+            remainingGasBudget);\n+        return AbstractBlockProcessor.Result.failed();\n+      }\n+\n+      final WorldUpdater worldStateUpdater = worldState.updater();\n+      final BlockHashLookup blockHashLookup = new BlockHashLookup(blockHeader, blockchain);\n+      final Address miningBeneficiary =\n+          miningBeneficiaryCalculator.calculateBeneficiary(blockHeader);\n+\n+      final PrivateStateRootResolver privateStateRootResolver =\n+          new PrivateStateRootResolver(privateStateStorage);\n+      if (forExecution.containsKey(transaction.getHash())) {\n+        final PrivateTransaction privateTransaction = forExecution.get(transaction.getHash());\n+        final Hash lastRootHash =\n+            privateStateRootResolver.resolveLastStateRoot(\n+                Bytes32.wrap(privateTransaction.getPrivacyGroupId().get()),\n+                blockHeader.getParentHash());\n+\n+        final MutableWorldState disposablePrivateState =\n+            privateWorldStateArchive.getMutable(lastRootHash).get();\n+        final WorldUpdater privateStateUpdater = disposablePrivateState.updater();\n+        maybeInjectDefaultManagementAndProxy(\n+            lastRootHash, disposablePrivateState, privateStateUpdater);\n+        LOG.info(\n+            \"Pre-rehydrate root hash: {} for tx {}\",\n+            disposablePrivateState.rootHash(),\n+            privateTransaction.getHash());\n+\n+        final PrivateTransactionProcessor.Result privateResult =\n+            privateTransactionProcessor.processTransaction(\n+                blockchain,\n+                worldStateUpdater.updater(),\n+                privateStateUpdater,\n+                blockHeader,\n+                privateTransaction,\n+                miningBeneficiary,\n+                OperationTracer.NO_TRACING,\n+                new BlockHashLookup(blockHeader, blockchain),\n+                privateTransaction.getPrivacyGroupId().get());\n+        persistPrivateState(\n+            transaction.getHash(),\n+            blockHeader.getHash(),\n+            privateTransaction,\n+            Bytes32.wrap(privateTransaction.getPrivacyGroupId().get()),\n+            disposablePrivateState,\n+            privateStateUpdater,\n+            privateStateStorage,\n+            privateResult);\n+        LOG.info(\"Post-rehydrate root hash: {}\", disposablePrivateState.rootHash());\n+      }\n+\n+      final TransactionProcessor.Result result =\n+          transactionProcessor.processTransaction(\n+              blockchain,\n+              worldStateUpdater,\n+              blockHeader,\n+              transaction,\n+              miningBeneficiary,\n+              blockHashLookup,\n+              true,\n+              TransactionValidationParams.processingBlock());\n+      if (result.isInvalid()) {\n+        return AbstractBlockProcessor.Result.failed();\n+      }\n+\n+      worldStateUpdater.commit();\n+      gasUsed = transaction.getGasLimit() - result.getGasRemaining() + gasUsed;\n+      final TransactionReceipt transactionReceipt =\n+          transactionReceiptFactory.create(result, worldState, gasUsed);\n+      receipts.add(transactionReceipt);\n+    }\n+\n+    if (!rewardCoinbase(worldState, blockHeader, ommers, skipZeroBlockRewards)) {\n+      return AbstractBlockProcessor.Result.failed();\n+    }\n+\n+    return AbstractBlockProcessor.Result.successful(receipts);\n+  }\n+\n+  protected void persistPrivateState(\n+      final Hash commitmentHash,\n+      final Hash currentBlockHash,\n+      final PrivateTransaction privateTransaction,\n+      final Bytes32 privacyGroupId,\n+      final MutableWorldState disposablePrivateState,\n+      final WorldUpdater privateWorldStateUpdater,\n+      final PrivateStateStorage privateStateStorage,\n+      final PrivateTransactionProcessor.Result result) {\n+\n+    LOG.trace(\n+        \"Persisting private state {} for privacyGroup {}\",\n+        disposablePrivateState.rootHash(),\n+        privacyGroupId);\n+    privateWorldStateUpdater.commit();\n+    disposablePrivateState.persist();\n+\n+    final PrivateStateStorage.Updater privateStateUpdater = privateStateStorage.updater();\n+\n+    updatePrivateBlockMetadata(\n+        commitmentHash,\n+        currentBlockHash,\n+        privacyGroupId,\n+        disposablePrivateState.rootHash(),\n+        privateStateUpdater,\n+        privateStateStorage);\n+\n+    final Bytes32 txHash = keccak256(RLP.encode(privateTransaction::writeTo));\n+\n+    final int txStatus =\n+        result.getStatus() == PrivateTransactionProcessor.Result.Status.SUCCESSFUL ? 1 : 0;\n+\n+    final PrivateTransactionReceipt privateTransactionReceipt =\n+        new PrivateTransactionReceipt(\n+            txStatus, result.getLogs(), result.getOutput(), result.getRevertReason());\n+\n+    privateStateUpdater.putTransactionReceipt(currentBlockHash, txHash, privateTransactionReceipt);\n+    final PrivacyGroupHeadBlockMap privacyGroupHeadBlockMap =\n+        privateStateStorage.getPrivacyGroupHeadBlockMap(currentBlockHash).get();\n+    if (!privacyGroupHeadBlockMap.contains(Bytes32.wrap(privacyGroupId), currentBlockHash)) {\n+      privacyGroupHeadBlockMap.put(Bytes32.wrap(privacyGroupId), currentBlockHash);\n+      privateStateUpdater.putPrivacyGroupHeadBlockMap(\n+          currentBlockHash, new PrivacyGroupHeadBlockMap(privacyGroupHeadBlockMap));\n+    }\n+    privateStateUpdater.commit();\n+  }\n+\n+  protected void maybeInjectDefaultManagementAndProxy(", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYwNzkwMg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387607902", "bodyText": "not easily - but we can move the precompile in the block processor :)", "author": "iikirilov", "createdAt": "2020-03-04T11:30:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxNjI0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxNjk1MA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386216950", "bodyText": "Is just returning the right thing to do here? I guess something went wrong when we get here. The minimum should be a LOG.error or something ...\nMaybe if we do throw this will cause this error being logged somewhere else?", "author": "pinges", "createdAt": "2020-03-02T06:35:33Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivateStateRehydration.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy;\n+\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.chain.TransactionLocation;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.Transaction;\n+import org.hyperledger.besu.ethereum.mainnet.ProtocolSchedule;\n+import org.hyperledger.besu.ethereum.mainnet.ProtocolSpec;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class PrivateStateRehydration {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final PrivateStateStorage privateStateStorage;\n+  private final Blockchain blockchain;\n+  private final ProtocolSchedule<?> protocolSchedule;\n+  private final WorldStateArchive publicWorldStateArchive;\n+  private final WorldStateArchive privateWorldStateArchive;\n+\n+  public PrivateStateRehydration(\n+      final PrivateStateStorage privateStateStorage,\n+      final Blockchain blockchain,\n+      final ProtocolSchedule<?> protocolSchedule,\n+      final WorldStateArchive publicWorldStateArchive,\n+      final WorldStateArchive privateWorldStateArchive) {\n+    this.privateStateStorage = privateStateStorage;\n+    this.blockchain = blockchain;\n+    this.protocolSchedule = protocolSchedule;\n+    this.publicWorldStateArchive = publicWorldStateArchive;\n+    this.privateWorldStateArchive = privateWorldStateArchive;\n+  }\n+\n+  public void rehydrate(\n+      final List<PrivateTransactionWithMetadata> privateTransactionWithMetadataList) {\n+    final long rehydrationStartTimestamp = System.currentTimeMillis();\n+    final long chainHeadBlockNumber = blockchain.getChainHeadBlockNumber();\n+    final Optional<Bytes> maybeGroupId =\n+        privateTransactionWithMetadataList.get(0).getPrivateTransaction().getPrivacyGroupId();\n+    if (maybeGroupId.isEmpty()) {\n+      return;", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYxMDA5NA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387610094", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T11:35:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxNjk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxNzc4Mg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386217782", "bodyText": "should be more than just a return. Something went wrong when that happens.", "author": "pinges", "createdAt": "2020-03-02T06:38:59Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivateStateRehydration.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy;\n+\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.chain.TransactionLocation;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.Transaction;\n+import org.hyperledger.besu.ethereum.mainnet.ProtocolSchedule;\n+import org.hyperledger.besu.ethereum.mainnet.ProtocolSpec;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class PrivateStateRehydration {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final PrivateStateStorage privateStateStorage;\n+  private final Blockchain blockchain;\n+  private final ProtocolSchedule<?> protocolSchedule;\n+  private final WorldStateArchive publicWorldStateArchive;\n+  private final WorldStateArchive privateWorldStateArchive;\n+\n+  public PrivateStateRehydration(\n+      final PrivateStateStorage privateStateStorage,\n+      final Blockchain blockchain,\n+      final ProtocolSchedule<?> protocolSchedule,\n+      final WorldStateArchive publicWorldStateArchive,\n+      final WorldStateArchive privateWorldStateArchive) {\n+    this.privateStateStorage = privateStateStorage;\n+    this.blockchain = blockchain;\n+    this.protocolSchedule = protocolSchedule;\n+    this.publicWorldStateArchive = publicWorldStateArchive;\n+    this.privateWorldStateArchive = privateWorldStateArchive;\n+  }\n+\n+  public void rehydrate(\n+      final List<PrivateTransactionWithMetadata> privateTransactionWithMetadataList) {\n+    final long rehydrationStartTimestamp = System.currentTimeMillis();\n+    final long chainHeadBlockNumber = blockchain.getChainHeadBlockNumber();\n+    final Optional<Bytes> maybeGroupId =\n+        privateTransactionWithMetadataList.get(0).getPrivateTransaction().getPrivacyGroupId();\n+    if (maybeGroupId.isEmpty()) {\n+      return;\n+    }\n+    final Bytes32 privacyGroupId = Bytes32.wrap(maybeGroupId.get());\n+\n+    LOG.info(\"Rehydrating privacy group {}\", privacyGroupId.toBase64String());\n+\n+    // check if there is a privacyGroupHeadBlockMap for the first block ...\n+    final boolean needEmptyPrivacyGroupHeadBlockMap =\n+        privateStateStorage\n+            .getPrivacyGroupHeadBlockMap(\n+                getBlockHashForIndex(0, privateTransactionWithMetadataList))\n+            .isEmpty();\n+    if (needEmptyPrivacyGroupHeadBlockMap) {\n+      privateStateStorage\n+          .updater()\n+          .putPrivacyGroupHeadBlockMap(\n+              getBlockHashForIndex(0, privateTransactionWithMetadataList),\n+              PrivacyGroupHeadBlockMap.EMPTY)\n+          .commit();\n+    }\n+\n+    for (int i = 0; i < privateTransactionWithMetadataList.size(); i++) {\n+      // find out which block this transaction is in\n+      final Hash blockHash = getBlockHashForIndex(i, privateTransactionWithMetadataList);\n+\n+      // if there are multiple pmts in the list we can increment our index i. At the end of the\n+      // while loop i will be the index of the last PMT (for this group) that is in this block.\n+      while (i + 1 < privateTransactionWithMetadataList.size()\n+          && blockHash.equals(getBlockHashForIndex(i + 1, privateTransactionWithMetadataList))) {\n+        i++;\n+      }\n+\n+      final Hash lastPmtHash =\n+          privateTransactionWithMetadataList\n+              .get(i)\n+              .getPrivateTransactionMetadata()\n+              .getPrivacyMarkerTransactionHash();\n+\n+      final Optional<TransactionLocation> transactionLocationOfLastPmtInBlock =\n+          blockchain.getTransactionLocation(lastPmtHash);\n+      if (transactionLocationOfLastPmtInBlock.isEmpty()) {\n+        return;", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYxMDA3NQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387610075", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T11:35:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxNzc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxODE1NA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386218154", "bodyText": "should this be info? I guess debug would be better ...", "author": "pinges", "createdAt": "2020-03-02T06:40:28Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivateStateRehydration.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy;\n+\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.chain.TransactionLocation;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.Transaction;\n+import org.hyperledger.besu.ethereum.mainnet.ProtocolSchedule;\n+import org.hyperledger.besu.ethereum.mainnet.ProtocolSpec;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class PrivateStateRehydration {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final PrivateStateStorage privateStateStorage;\n+  private final Blockchain blockchain;\n+  private final ProtocolSchedule<?> protocolSchedule;\n+  private final WorldStateArchive publicWorldStateArchive;\n+  private final WorldStateArchive privateWorldStateArchive;\n+\n+  public PrivateStateRehydration(\n+      final PrivateStateStorage privateStateStorage,\n+      final Blockchain blockchain,\n+      final ProtocolSchedule<?> protocolSchedule,\n+      final WorldStateArchive publicWorldStateArchive,\n+      final WorldStateArchive privateWorldStateArchive) {\n+    this.privateStateStorage = privateStateStorage;\n+    this.blockchain = blockchain;\n+    this.protocolSchedule = protocolSchedule;\n+    this.publicWorldStateArchive = publicWorldStateArchive;\n+    this.privateWorldStateArchive = privateWorldStateArchive;\n+  }\n+\n+  public void rehydrate(\n+      final List<PrivateTransactionWithMetadata> privateTransactionWithMetadataList) {\n+    final long rehydrationStartTimestamp = System.currentTimeMillis();\n+    final long chainHeadBlockNumber = blockchain.getChainHeadBlockNumber();\n+    final Optional<Bytes> maybeGroupId =\n+        privateTransactionWithMetadataList.get(0).getPrivateTransaction().getPrivacyGroupId();\n+    if (maybeGroupId.isEmpty()) {\n+      return;\n+    }\n+    final Bytes32 privacyGroupId = Bytes32.wrap(maybeGroupId.get());\n+\n+    LOG.info(\"Rehydrating privacy group {}\", privacyGroupId.toBase64String());\n+\n+    // check if there is a privacyGroupHeadBlockMap for the first block ...\n+    final boolean needEmptyPrivacyGroupHeadBlockMap =\n+        privateStateStorage\n+            .getPrivacyGroupHeadBlockMap(\n+                getBlockHashForIndex(0, privateTransactionWithMetadataList))\n+            .isEmpty();\n+    if (needEmptyPrivacyGroupHeadBlockMap) {\n+      privateStateStorage\n+          .updater()\n+          .putPrivacyGroupHeadBlockMap(\n+              getBlockHashForIndex(0, privateTransactionWithMetadataList),\n+              PrivacyGroupHeadBlockMap.EMPTY)\n+          .commit();\n+    }\n+\n+    for (int i = 0; i < privateTransactionWithMetadataList.size(); i++) {\n+      // find out which block this transaction is in\n+      final Hash blockHash = getBlockHashForIndex(i, privateTransactionWithMetadataList);\n+\n+      // if there are multiple pmts in the list we can increment our index i. At the end of the\n+      // while loop i will be the index of the last PMT (for this group) that is in this block.\n+      while (i + 1 < privateTransactionWithMetadataList.size()\n+          && blockHash.equals(getBlockHashForIndex(i + 1, privateTransactionWithMetadataList))) {\n+        i++;\n+      }\n+\n+      final Hash lastPmtHash =\n+          privateTransactionWithMetadataList\n+              .get(i)\n+              .getPrivateTransactionMetadata()\n+              .getPrivacyMarkerTransactionHash();\n+\n+      final Optional<TransactionLocation> transactionLocationOfLastPmtInBlock =\n+          blockchain.getTransactionLocation(lastPmtHash);\n+      if (transactionLocationOfLastPmtInBlock.isEmpty()) {\n+        return;\n+      }\n+\n+      final Block block = blockchain.getBlockByHash(blockHash).orElseThrow(RuntimeException::new);\n+      final BlockHeader blockHeader = block.getHeader();\n+      LOG.info(", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYxMDUwNA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387610504", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T11:36:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxODE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxODYwNA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386218604", "bodyText": "That comment is not correct anymore ...", "author": "pinges", "createdAt": "2020-03-02T06:42:35Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivateStateRehydration.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy;\n+\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.chain.TransactionLocation;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.Transaction;\n+import org.hyperledger.besu.ethereum.mainnet.ProtocolSchedule;\n+import org.hyperledger.besu.ethereum.mainnet.ProtocolSpec;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class PrivateStateRehydration {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final PrivateStateStorage privateStateStorage;\n+  private final Blockchain blockchain;\n+  private final ProtocolSchedule<?> protocolSchedule;\n+  private final WorldStateArchive publicWorldStateArchive;\n+  private final WorldStateArchive privateWorldStateArchive;\n+\n+  public PrivateStateRehydration(\n+      final PrivateStateStorage privateStateStorage,\n+      final Blockchain blockchain,\n+      final ProtocolSchedule<?> protocolSchedule,\n+      final WorldStateArchive publicWorldStateArchive,\n+      final WorldStateArchive privateWorldStateArchive) {\n+    this.privateStateStorage = privateStateStorage;\n+    this.blockchain = blockchain;\n+    this.protocolSchedule = protocolSchedule;\n+    this.publicWorldStateArchive = publicWorldStateArchive;\n+    this.privateWorldStateArchive = privateWorldStateArchive;\n+  }\n+\n+  public void rehydrate(\n+      final List<PrivateTransactionWithMetadata> privateTransactionWithMetadataList) {\n+    final long rehydrationStartTimestamp = System.currentTimeMillis();\n+    final long chainHeadBlockNumber = blockchain.getChainHeadBlockNumber();\n+    final Optional<Bytes> maybeGroupId =\n+        privateTransactionWithMetadataList.get(0).getPrivateTransaction().getPrivacyGroupId();\n+    if (maybeGroupId.isEmpty()) {\n+      return;\n+    }\n+    final Bytes32 privacyGroupId = Bytes32.wrap(maybeGroupId.get());\n+\n+    LOG.info(\"Rehydrating privacy group {}\", privacyGroupId.toBase64String());\n+\n+    // check if there is a privacyGroupHeadBlockMap for the first block ...\n+    final boolean needEmptyPrivacyGroupHeadBlockMap =\n+        privateStateStorage\n+            .getPrivacyGroupHeadBlockMap(\n+                getBlockHashForIndex(0, privateTransactionWithMetadataList))\n+            .isEmpty();\n+    if (needEmptyPrivacyGroupHeadBlockMap) {\n+      privateStateStorage\n+          .updater()\n+          .putPrivacyGroupHeadBlockMap(\n+              getBlockHashForIndex(0, privateTransactionWithMetadataList),\n+              PrivacyGroupHeadBlockMap.EMPTY)\n+          .commit();\n+    }\n+\n+    for (int i = 0; i < privateTransactionWithMetadataList.size(); i++) {\n+      // find out which block this transaction is in\n+      final Hash blockHash = getBlockHashForIndex(i, privateTransactionWithMetadataList);\n+\n+      // if there are multiple pmts in the list we can increment our index i. At the end of the\n+      // while loop i will be the index of the last PMT (for this group) that is in this block.\n+      while (i + 1 < privateTransactionWithMetadataList.size()\n+          && blockHash.equals(getBlockHashForIndex(i + 1, privateTransactionWithMetadataList))) {\n+        i++;\n+      }\n+\n+      final Hash lastPmtHash =\n+          privateTransactionWithMetadataList\n+              .get(i)\n+              .getPrivateTransactionMetadata()\n+              .getPrivacyMarkerTransactionHash();\n+\n+      final Optional<TransactionLocation> transactionLocationOfLastPmtInBlock =\n+          blockchain.getTransactionLocation(lastPmtHash);\n+      if (transactionLocationOfLastPmtInBlock.isEmpty()) {\n+        return;\n+      }\n+\n+      final Block block = blockchain.getBlockByHash(blockHash).orElseThrow(RuntimeException::new);\n+      final BlockHeader blockHeader = block.getHeader();\n+      LOG.info(\n+          \"Rehydrating block {} ({}/{}), {}\",\n+          blockHash,\n+          blockHeader.getNumber(),\n+          chainHeadBlockNumber,\n+          block.getBody().getTransactions().stream()\n+              .map(Transaction::getHash)\n+              .collect(Collectors.toList()));\n+\n+      final ProtocolSpec<?> protocolSpec =\n+          protocolSchedule.getByBlockNumber(blockchain.getBlockHeader(blockHash).get().getNumber());\n+      final PrivateGroupRehydrationBlockProcessor privateGroupRehydrationBlockProcessor =\n+          new PrivateGroupRehydrationBlockProcessor(\n+              protocolSpec.getTransactionProcessor(),\n+              protocolSpec.getPrivateTransactionProcessor(),\n+              protocolSpec.getTransactionReceiptFactory(),\n+              protocolSpec.getBlockReward(),\n+              protocolSpec.getMiningBeneficiaryCalculator(),\n+              protocolSpec.isSkipZeroBlockRewards());\n+\n+      final MutableWorldState publicWorldState =\n+          blockchain\n+              .getBlockHeader(blockHeader.getParentHash())\n+              .map(BlockHeader::getStateRoot)\n+              .flatMap(publicWorldStateArchive::getMutable)\n+              .orElseThrow(RuntimeException::new);\n+\n+      // build the map to be used by the privacy precompile to ge the private transactions and", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYxMTI1MA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387611250", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T11:37:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIxODYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyMDE3NA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386220174", "bodyText": "I'm not sure the else can ever happen. When we are rehydrating we are in the process of importing a block that contains the add() private transaction, which means that this should be the head of chain.", "author": "pinges", "createdAt": "2020-03-02T06:48:57Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivateStateRehydration.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy;\n+\n+import org.hyperledger.besu.ethereum.chain.Blockchain;\n+import org.hyperledger.besu.ethereum.chain.TransactionLocation;\n+import org.hyperledger.besu.ethereum.core.Block;\n+import org.hyperledger.besu.ethereum.core.BlockHeader;\n+import org.hyperledger.besu.ethereum.core.Hash;\n+import org.hyperledger.besu.ethereum.core.MutableWorldState;\n+import org.hyperledger.besu.ethereum.core.Transaction;\n+import org.hyperledger.besu.ethereum.mainnet.ProtocolSchedule;\n+import org.hyperledger.besu.ethereum.mainnet.ProtocolSpec;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivacyGroupHeadBlockMap;\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateStateStorage;\n+import org.hyperledger.besu.ethereum.worldstate.WorldStateArchive;\n+\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.tuweni.bytes.Bytes;\n+import org.apache.tuweni.bytes.Bytes32;\n+\n+public class PrivateStateRehydration {\n+\n+  private static final Logger LOG = LogManager.getLogger();\n+\n+  private final PrivateStateStorage privateStateStorage;\n+  private final Blockchain blockchain;\n+  private final ProtocolSchedule<?> protocolSchedule;\n+  private final WorldStateArchive publicWorldStateArchive;\n+  private final WorldStateArchive privateWorldStateArchive;\n+\n+  public PrivateStateRehydration(\n+      final PrivateStateStorage privateStateStorage,\n+      final Blockchain blockchain,\n+      final ProtocolSchedule<?> protocolSchedule,\n+      final WorldStateArchive publicWorldStateArchive,\n+      final WorldStateArchive privateWorldStateArchive) {\n+    this.privateStateStorage = privateStateStorage;\n+    this.blockchain = blockchain;\n+    this.protocolSchedule = protocolSchedule;\n+    this.publicWorldStateArchive = publicWorldStateArchive;\n+    this.privateWorldStateArchive = privateWorldStateArchive;\n+  }\n+\n+  public void rehydrate(\n+      final List<PrivateTransactionWithMetadata> privateTransactionWithMetadataList) {\n+    final long rehydrationStartTimestamp = System.currentTimeMillis();\n+    final long chainHeadBlockNumber = blockchain.getChainHeadBlockNumber();\n+    final Optional<Bytes> maybeGroupId =\n+        privateTransactionWithMetadataList.get(0).getPrivateTransaction().getPrivacyGroupId();\n+    if (maybeGroupId.isEmpty()) {\n+      return;\n+    }\n+    final Bytes32 privacyGroupId = Bytes32.wrap(maybeGroupId.get());\n+\n+    LOG.info(\"Rehydrating privacy group {}\", privacyGroupId.toBase64String());\n+\n+    // check if there is a privacyGroupHeadBlockMap for the first block ...\n+    final boolean needEmptyPrivacyGroupHeadBlockMap =\n+        privateStateStorage\n+            .getPrivacyGroupHeadBlockMap(\n+                getBlockHashForIndex(0, privateTransactionWithMetadataList))\n+            .isEmpty();\n+    if (needEmptyPrivacyGroupHeadBlockMap) {\n+      privateStateStorage\n+          .updater()\n+          .putPrivacyGroupHeadBlockMap(\n+              getBlockHashForIndex(0, privateTransactionWithMetadataList),\n+              PrivacyGroupHeadBlockMap.EMPTY)\n+          .commit();\n+    }\n+\n+    for (int i = 0; i < privateTransactionWithMetadataList.size(); i++) {\n+      // find out which block this transaction is in\n+      final Hash blockHash = getBlockHashForIndex(i, privateTransactionWithMetadataList);\n+\n+      // if there are multiple pmts in the list we can increment our index i. At the end of the\n+      // while loop i will be the index of the last PMT (for this group) that is in this block.\n+      while (i + 1 < privateTransactionWithMetadataList.size()\n+          && blockHash.equals(getBlockHashForIndex(i + 1, privateTransactionWithMetadataList))) {\n+        i++;\n+      }\n+\n+      final Hash lastPmtHash =\n+          privateTransactionWithMetadataList\n+              .get(i)\n+              .getPrivateTransactionMetadata()\n+              .getPrivacyMarkerTransactionHash();\n+\n+      final Optional<TransactionLocation> transactionLocationOfLastPmtInBlock =\n+          blockchain.getTransactionLocation(lastPmtHash);\n+      if (transactionLocationOfLastPmtInBlock.isEmpty()) {\n+        return;\n+      }\n+\n+      final Block block = blockchain.getBlockByHash(blockHash).orElseThrow(RuntimeException::new);\n+      final BlockHeader blockHeader = block.getHeader();\n+      LOG.info(\n+          \"Rehydrating block {} ({}/{}), {}\",\n+          blockHash,\n+          blockHeader.getNumber(),\n+          chainHeadBlockNumber,\n+          block.getBody().getTransactions().stream()\n+              .map(Transaction::getHash)\n+              .collect(Collectors.toList()));\n+\n+      final ProtocolSpec<?> protocolSpec =\n+          protocolSchedule.getByBlockNumber(blockchain.getBlockHeader(blockHash).get().getNumber());\n+      final PrivateGroupRehydrationBlockProcessor privateGroupRehydrationBlockProcessor =\n+          new PrivateGroupRehydrationBlockProcessor(\n+              protocolSpec.getTransactionProcessor(),\n+              protocolSpec.getPrivateTransactionProcessor(),\n+              protocolSpec.getTransactionReceiptFactory(),\n+              protocolSpec.getBlockReward(),\n+              protocolSpec.getMiningBeneficiaryCalculator(),\n+              protocolSpec.isSkipZeroBlockRewards());\n+\n+      final MutableWorldState publicWorldState =\n+          blockchain\n+              .getBlockHeader(blockHeader.getParentHash())\n+              .map(BlockHeader::getStateRoot)\n+              .flatMap(publicWorldStateArchive::getMutable)\n+              .orElseThrow(RuntimeException::new);\n+\n+      // build the map to be used by the privacy precompile to ge the private transactions and\n+      // metadata inside the precompile\n+      final LinkedHashMap<Hash, PrivateTransaction> enclaveMap = new LinkedHashMap<>();\n+      for (int j = 0; j < privateTransactionWithMetadataList.size(); j++) {\n+        final PrivateTransactionWithMetadata transactionWithMetadata =\n+            privateTransactionWithMetadataList.get(j);\n+        enclaveMap.put(\n+            transactionWithMetadata\n+                .getPrivateTransactionMetadata()\n+                .getPrivacyMarkerTransactionHash(),\n+            transactionWithMetadata.getPrivateTransaction());\n+      }\n+\n+      privateGroupRehydrationBlockProcessor.processBlock(\n+          blockchain,\n+          publicWorldState,\n+          privateWorldStateArchive,\n+          privateStateStorage,\n+          block,\n+          enclaveMap,\n+          block.getBody().getOmmers());\n+\n+      // check the resulting private state against the state in the meta data\n+      final Optional<Hash> latestStateRoot =\n+          privateStateStorage\n+              .getPrivateBlockMetadata(blockHash, privacyGroupId)\n+              .orElseThrow()\n+              .getLatestStateRoot();\n+      if (latestStateRoot.isPresent()) {\n+        if (!latestStateRoot\n+            .get()\n+            .equals(\n+                privateTransactionWithMetadataList\n+                    .get(i)\n+                    .getPrivateTransactionMetadata()\n+                    .getStateRoot())) {\n+          throw new RuntimeException();\n+        }\n+      }\n+      // fix the privacy group header block map for the blocks between the current block and the\n+      // next block containing a pmt for this privacy group\n+      if (i + 1 < privateTransactionWithMetadataList.size()) {\n+        rehydratePrivacyGroupHeadBlockMap(\n+            privacyGroupId,\n+            blockHash,\n+            blockchain,\n+            getBlockNumberForIndex(i, privateTransactionWithMetadataList),\n+            getBlockNumberForIndex(i + 1, privateTransactionWithMetadataList));\n+      } else {", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYxMjA1NA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387612054", "bodyText": "you need to rehydrate the map from block which has the lock to the block which has the add\nthe else will be called after rehydrating the lock - the add will be processed after the rehydration is complete", "author": "iikirilov", "createdAt": "2020-03-04T11:39:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyMDE3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyMjE4OA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386222188", "bodyText": "Do we need both of these abstract methods? At least we should use only the protected create method that takes the precompile address as a parameter for both of these ...", "author": "pinges", "createdAt": "2020-03-02T06:57:22Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/markertransaction/PrivateMarkerTransactionFactory.java", "diffHunk": "@@ -36,6 +36,11 @@ private Address getPrivacyPrecompileAddress() {\n   public abstract Transaction create(\n       final String transactionEnclaveKey, final PrivateTransaction privateTransaction);\n \n+  public abstract Transaction create(\n+      final String transactionEnclaveKey,", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYxMzExOQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387613119", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T11:41:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyMjE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyNDIyNg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386224226", "bodyText": "Don't we need the VersionedPrivateTransaction here? Rehydration seems to work, but I thought that the version should be necessary so we do not execute transactions with the wrong version ...\nOr do private transactions that were sent with the wrong version not make their way into this list?", "author": "pinges", "createdAt": "2020-03-02T07:05:24Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/PrivateTransactionWithMetadata.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.ethereum.privacy;\n+\n+import org.hyperledger.besu.ethereum.privacy.storage.PrivateTransactionMetadata;\n+import org.hyperledger.besu.ethereum.rlp.RLPException;\n+import org.hyperledger.besu.ethereum.rlp.RLPInput;\n+import org.hyperledger.besu.ethereum.rlp.RLPOutput;\n+\n+import java.util.Objects;\n+\n+public class PrivateTransactionWithMetadata {\n+  private final PrivateTransaction privateTransaction;\n+  private final PrivateTransactionMetadata privateTransactionMetadata;\n+\n+  public static PrivateTransactionWithMetadata readFrom(final RLPInput input) throws RLPException {\n+    input.enterList();\n+    final PrivateTransaction privateTransaction = PrivateTransaction.readFrom(input.readAsRlp());\n+    final PrivateTransactionMetadata privateTransactionMetadata =\n+        PrivateTransactionMetadata.readFrom(input.readAsRlp());\n+    input.leaveList();\n+    return new PrivateTransactionWithMetadata(privateTransaction, privateTransactionMetadata);\n+  }\n+\n+  public PrivateTransactionWithMetadata(\n+      final PrivateTransaction privateTransaction,", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyNDY0Nw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386224647", "bodyText": "Constant?", "author": "pinges", "createdAt": "2020-03-02T07:07:05Z", "path": "ethereum/core/src/test/java/org/hyperledger/besu/ethereum/mainnet/precompiles/privacy/PrivacyPrecompiledContractTest.java", "diffHunk": "@@ -145,12 +130,14 @@ public void testPayloadFoundInEnclave() {\n         new PrivacyPrecompiledContract(\n             new SpuriousDragonGasCalculator(), enclave, worldStateArchive, privateStateStorage);\n     contract.setPrivateTransactionProcessor(mockPrivateTxProcessor());\n+    final String privacyGroupId = \"8lDVI66RZHIrBsolz6Kn88Rd+WsJ4hUjb4hsh29xW/o=\";", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyNTI5Nw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386225297", "bodyText": "Constant? And the next line ...", "author": "pinges", "createdAt": "2020-03-02T07:09:41Z", "path": "ethereum/core/src/test/java/org/hyperledger/besu/ethereum/privacy/DefaultPrivacyControllerTest.java", "diffHunk": "@@ -203,6 +211,41 @@ public void sendValidBesuTransaction() {\n     verify(enclave).send(anyString(), eq(ENCLAVE_PUBLIC_KEY), eq(PRIVACY_GROUP_ID));\n   }\n \n+  @Test\n+  public void findOnChainPrivacyGroups() {\n+    final List<String> privacyGroupAddresses = newArrayList(ENCLAVE_PUBLIC_KEY, ENCLAVE_KEY2);\n+\n+    final PrivacyGroup privacyGroup =\n+        new PrivacyGroup(PRIVACY_GROUP_ID, Type.PANTHEON, \"\", \"\", privacyGroupAddresses);\n+\n+    final PrivacyGroupHeadBlockMap privacyGroupHeadBlockMap =\n+        new PrivacyGroupHeadBlockMap(\n+            Map.of(Bytes32.wrap(Bytes.fromBase64String(PRIVACY_GROUP_ID)), Hash.ZERO));\n+    when(privateStateStorage.getPrivacyGroupHeadBlockMap(any()))\n+        .thenReturn(Optional.of(privacyGroupHeadBlockMap));\n+    when(privateTransactionSimulator.process(any(), any()))\n+        .thenReturn(\n+            Optional.of(\n+                new PrivateTransactionProcessor.Result(\n+                    TransactionProcessor.Result.Status.SUCCESSFUL,\n+                    emptyList(),\n+                    0,\n+                    Bytes.fromHexString(\n+                        \"0x0000000000000000000000000000000000000000000000000000000000000020\"", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyNjY5MA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386226690", "bodyText": "I think we should give that contract a name that is more descriptive. What about DefaultOnChainPrivacyGroupManagementContract?\nMaybe without the OnChain?", "author": "pinges", "createdAt": "2020-03-02T07:15:04Z", "path": "privacy-contracts/src/main/solidity/PrivacyGroup.sol", "diffHunk": "@@ -0,0 +1,106 @@\n+pragma solidity ^0.5.9;\n+import \"./PrivacyInterface.sol\";\n+\n+contract PrivacyGroup is PrivacyInterface {", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYxMzg0Nw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387613847", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T11:43:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyNjY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyNjkxMw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386226913", "bodyText": "OnChainPrivacyGroupManagementInterface?", "author": "pinges", "createdAt": "2020-03-02T07:15:50Z", "path": "privacy-contracts/src/main/solidity/PrivacyInterface.sol", "diffHunk": "@@ -0,0 +1,18 @@\n+pragma solidity ^0.5.9;\n+\n+interface PrivacyInterface {", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYxMzk2MQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387613961", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T11:43:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyNjkxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyNzA0Mw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386227043", "bodyText": "OnChainPrivacyGroupManagementProxy?", "author": "pinges", "createdAt": "2020-03-02T07:16:22Z", "path": "privacy-contracts/src/main/solidity/PrivacyProxy.sol", "diffHunk": "@@ -0,0 +1,56 @@\n+pragma solidity ^0.5.12;\n+\n+import \"./PrivacyInterface.sol\";\n+\n+contract PrivacyProxy is PrivacyInterface {", "originalCommit": "20477103821e263adf10ab0cf1a92e9e68decade", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYxNDk3NA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387614974", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T11:46:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjIyNzA0Mw=="}], "type": "inlineReview"}, {"oid": "901d0e8cfab0568a877bc9e47ffdc7b66da9cb6b", "url": "https://github.com/hyperledger/besu/commit/901d0e8cfab0568a877bc9e47ffdc7b66da9cb6b", "message": "fix retrieving private transaction data after being added to group\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>", "committedDate": "2020-03-02T18:00:28Z", "type": "forcePushed"}, {"oid": "826118608ae4aea2e0d71e42ef360b736a88077e", "url": "https://github.com/hyperledger/besu/commit/826118608ae4aea2e0d71e42ef360b736a88077e", "message": "Merge pull request #5 from josh-richardson/2020-privacy-contracts-comments\n\nAddresses various comments from Stefan\n\nSigned-off-by: Joshua Richardson <joshua@richardson.tech>", "committedDate": "2020-03-02T21:54:22Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc5Nzg3Mw==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386797873", "bodyText": "Sorry, that was my fault. I asked whether we need to check that here!\nBut we are already checking if the addresses does contain the enclavePublicKey, so only privacy groups that contain the enclavePublicKey will be returned here!\nSorry, but please do remove that check :-)", "author": "pinges", "createdAt": "2020-03-03T04:50:18Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/MultiTenancyPrivacyController.java", "diffHunk": "@@ -83,7 +84,11 @@ public String deletePrivacyGroup(final String privacyGroupId, final String encla\n       throw new MultiTenancyValidationException(\n           \"Privacy group addresses must contain the enclave public key\");\n     }\n-    return privacyController.findPrivacyGroup(addresses, enclavePublicKey);\n+    PrivacyGroup[] resultantGroups =\n+        privacyController.findPrivacyGroup(addresses, enclavePublicKey);\n+    return Arrays.stream(resultantGroups)\n+        .filter(g -> g.getMembers().contains(enclavePublicKey))", "originalCommit": "826118608ae4aea2e0d71e42ef360b736a88077e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYxNTIwNA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387615204", "bodyText": "awesome!", "author": "iikirilov", "createdAt": "2020-03-04T11:46:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc5Nzg3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxNDczNA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386814734", "bodyText": "this is a bit funny, because the verifyPrivacyGroupContains ... method does call privacyController.retrievePrivacyGroup :-)\nI think we should do the pirvacyController.retrievePrivacyGroup() call first and then check if the enclavePublicKey is part of the group before we are returning it!", "author": "pinges", "createdAt": "2020-03-03T06:04:03Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/MultiTenancyPrivacyController.java", "diffHunk": "@@ -127,6 +141,34 @@ public long determineBesuNonce(\n         privacyGroupId, enclavePublicKey, callParams, blockNumber);\n   }\n \n+  @Override\n+  public Optional<String> buildAndSendAddPayload(\n+      final PrivateTransaction privateTransaction, final String enclaveKey) {\n+    verifyPrivateFromMatchesEnclavePublicKey(\n+        privateTransaction.getPrivateFrom().toBase64String(), enclaveKey);\n+    verifyPrivacyGroupContainsEnclavePublicKey(\n+        privateTransaction.getPrivacyGroupId().get().toBase64String(), enclaveKey);\n+    return privacyController.buildAndSendAddPayload(privateTransaction, enclaveKey);\n+  }\n+\n+  @Override\n+  public PrivacyGroup retrievePrivacyGroup(\n+      final String privacyGroupId, final String enclavePublicKey) {\n+    verifyPrivacyGroupContainsEnclavePublicKey(privacyGroupId, enclavePublicKey);", "originalCommit": "826118608ae4aea2e0d71e42ef360b736a88077e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzYxNzM1OQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387617359", "bodyText": "fixed", "author": "iikirilov", "createdAt": "2020-03-04T11:51:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxNDczNA=="}], "type": "inlineReview"}, {"oid": "bfd223e7d9a2849d6c5d8550ee12478630365dde", "url": "https://github.com/hyperledger/besu/commit/bfd223e7d9a2849d6c5d8550ee12478630365dde", "message": "Rebase errors\n\nSigned-off-by: Joshua Richardson <joshua@richardson.tech>", "committedDate": "2020-03-03T14:44:19Z", "type": "forcePushed"}, {"oid": "3e4af3699cbca5898873a4ceb5c639f6c19c78ea", "url": "https://github.com/hyperledger/besu/commit/3e4af3699cbca5898873a4ceb5c639f6c19c78ea", "message": "spotless\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>", "committedDate": "2020-03-04T13:48:22Z", "type": "forcePushed"}, {"oid": "652a96f712f0dfc77ea426d1e07ac3806f61e030", "url": "https://github.com/hyperledger/besu/commit/652a96f712f0dfc77ea426d1e07ac3806f61e030", "message": "fix test\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>", "committedDate": "2020-03-04T14:51:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg0MDAwNA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r386840004", "bodyText": "here we definetly have to check whether the enclaveKey is part of the asList!", "author": "pinges", "createdAt": "2020-03-03T07:33:03Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/privacy/MultiTenancyPrivacyController.java", "diffHunk": "@@ -127,6 +141,34 @@ public long determineBesuNonce(\n         privacyGroupId, enclavePublicKey, callParams, blockNumber);\n   }\n \n+  @Override\n+  public Optional<String> buildAndSendAddPayload(\n+      final PrivateTransaction privateTransaction, final String enclaveKey) {\n+    verifyPrivateFromMatchesEnclavePublicKey(\n+        privateTransaction.getPrivateFrom().toBase64String(), enclaveKey);\n+    verifyPrivacyGroupContainsEnclavePublicKey(\n+        privateTransaction.getPrivacyGroupId().get().toBase64String(), enclaveKey);\n+    return privacyController.buildAndSendAddPayload(privateTransaction, enclaveKey);\n+  }\n+\n+  @Override\n+  public PrivacyGroup retrievePrivacyGroup(\n+      final String privacyGroupId, final String enclavePublicKey) {\n+    verifyPrivacyGroupContainsEnclavePublicKey(privacyGroupId, enclavePublicKey);\n+    return privacyController.retrievePrivacyGroup(privacyGroupId, enclavePublicKey);\n+  }\n+\n+  @Override\n+  public List<PrivacyGroup> findOnChainPrivacyGroup(\n+      final List<String> asList, final String enclaveKey) {\n+    return privacyController.findOnChainPrivacyGroup(asList, enclaveKey);", "originalCommit": "826118608ae4aea2e0d71e42ef360b736a88077e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQyMDIyNg==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387420226", "bodyText": "Do we need the type here? This is an OnChainPrivacyGroup ...", "author": "pinges", "createdAt": "2020-03-04T02:45:24Z", "path": "acceptance-tests/tests/src/test/java/org/hyperledger/besu/tests/web3j/privacy/OnChainPrivacyAcceptanceTest.java", "diffHunk": "@@ -0,0 +1,427 @@\n+/*\n+ * Copyright ConsenSys AG.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with\n+ * the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on\n+ * an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the\n+ * specific language governing permissions and limitations under the License.\n+ *\n+ * SPDX-License-Identifier: Apache-2.0\n+ */\n+package org.hyperledger.besu.tests.web3j.privacy;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import org.hyperledger.besu.ethereum.core.Address;\n+import org.hyperledger.besu.tests.acceptance.dsl.condition.eth.EthConditions;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyAcceptanceTestBase;\n+import org.hyperledger.besu.tests.acceptance.dsl.privacy.PrivacyNode;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.miner.MinerTransactions;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.privacy.PrivacyRequestFactory.OnChainPrivacyGroup;\n+import org.hyperledger.besu.tests.acceptance.dsl.transaction.privacy.PrivacyRequestFactory.PrivxCreatePrivacyGroup;\n+import org.hyperledger.besu.tests.web3j.generated.EventEmitter;\n+\n+import java.math.BigInteger;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+import org.apache.tuweni.bytes.Bytes;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.web3j.protocol.besu.response.privacy.PrivateTransactionReceipt;\n+import org.web3j.protocol.core.methods.response.Log;\n+import org.web3j.protocol.core.methods.response.TransactionReceipt;\n+import org.web3j.utils.Base64String;\n+\n+public class OnChainPrivacyAcceptanceTest extends PrivacyAcceptanceTestBase {\n+  private static final long POW_CHAIN_ID = 2018;\n+\n+  private PrivacyNode alice;\n+  private PrivacyNode bob;\n+  private PrivacyNode charlie;\n+\n+  private final MinerTransactions minerTransactions = new MinerTransactions();\n+  private final EthConditions ethConditions = new EthConditions(ethTransactions);\n+\n+  private static final String EXPECTED_STORE_OUTPUT_DATA =\n+      \"0x000000000000000000000000f17f52151ebef6c7334fad080c5704d77216b7320000000000000000000000000000000000000000000000000000000000000539\";\n+  private static final String EXPECTED_STORE_EVENT_TOPIC =\n+      \"0xc9db20adedc6cf2b5d25252b101ab03e124902a73fcb12b753f3d1aaa2d8f9f5\";\n+\n+  @Before\n+  public void setUp() throws Exception {\n+    alice =\n+        privacyBesu.createPrivateTransactionEnabledMinerNode(\n+            \"node1\", privacyAccountResolver.resolve(0), Address.PRIVACY);\n+    bob =\n+        privacyBesu.createPrivateTransactionEnabledNode(\n+            \"node2\", privacyAccountResolver.resolve(1), Address.PRIVACY);\n+    charlie =\n+        privacyBesu.createPrivateTransactionEnabledNode(\n+            \"node3\", privacyAccountResolver.resolve(2), Address.PRIVACY);\n+    privacyCluster.start(alice, bob, charlie);\n+  }\n+\n+  @Test\n+  public void nodeCanCreatePrivacyGroup() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice, alice, bob));\n+\n+    assertThat(privxCreatePrivacyGroup).isNotNull();\n+\n+    final OnChainPrivacyGroup expectedGroup =\n+        new OnChainPrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            OnChainPrivacyGroup.Type.ONCHAIN,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey(), bob.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    bob.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final String getParticipantsCallHash =\n+        alice.execute(\n+            privateContractTransactions.callOnChainPermissioningSmartContract(\n+                Address.PRIVACY_PROXY.toHexString(),\n+                \"0x0b0235be\" // get participants method signature\n+                    + Bytes.fromBase64String(alice.getEnclaveKey()).toUnprefixedHexString(),\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privxCreatePrivacyGroup.getPrivacyGroupId()));\n+\n+    final PrivateTransactionReceipt expectedReceipt =\n+        new PrivateTransactionReceipt(\n+            null,\n+            alice.getAddress().toHexString(),\n+            Address.PRIVACY_PROXY.toHexString(),\n+            \"0x0000000000000000000000000000000000000000000000000000000000000020\" // dynamic\n+                // array offset\n+                + \"0000000000000000000000000000000000000000000000000000000000000002\" // length\n+                // of array\n+                + Bytes.fromBase64String(alice.getEnclaveKey()).toUnprefixedHexString() // first\n+                // element\n+                + Bytes.fromBase64String(bob.getEnclaveKey()).toUnprefixedHexString(), // second\n+            // element\n+            Collections.emptyList(),\n+            null,\n+            null,\n+            alice.getEnclaveKey(),\n+            null,\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            \"0x1\",\n+            null);\n+\n+    alice.verify(\n+        privateTransactionVerifier.validPrivateTransactionReceipt(\n+            getParticipantsCallHash, expectedReceipt));\n+\n+    bob.verify(\n+        privateTransactionVerifier.validPrivateTransactionReceipt(\n+            getParticipantsCallHash, expectedReceipt));\n+  }\n+\n+  @Test\n+  public void deployingMustGiveValidReceipt() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice));\n+\n+    final OnChainPrivacyGroup expectedGroup =\n+        new OnChainPrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            OnChainPrivacyGroup.Type.ONCHAIN,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final EventEmitter eventEmitter =\n+        alice.execute(\n+            privateContractTransactions.createSmartContractWithPrivacyGroupId(\n+                EventEmitter.class,\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privxCreatePrivacyGroup.getPrivacyGroupId()));\n+\n+    privateContractVerifier\n+        .validPrivateContractDeployed(\n+            eventEmitter.getContractAddress(), alice.getAddress().toString())\n+        .verify(eventEmitter);\n+  }\n+\n+  @Test\n+  public void canAddParticipantToGroup() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice, alice, bob));\n+\n+    assertThat(privxCreatePrivacyGroup).isNotNull();\n+\n+    final OnChainPrivacyGroup expectedGroup =\n+        new OnChainPrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            OnChainPrivacyGroup.Type.ONCHAIN,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey(), bob.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    bob.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final EventEmitter eventEmitter =\n+        alice.execute(\n+            privateContractTransactions.createSmartContractWithPrivacyGroupId(\n+                EventEmitter.class,\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privxCreatePrivacyGroup.getPrivacyGroupId()));\n+\n+    privateContractVerifier\n+        .validPrivateContractDeployed(\n+            eventEmitter.getContractAddress(), alice.getAddress().toString())\n+        .verify(eventEmitter);\n+\n+    alice.execute(\n+        privacyTransactions.privxLockPrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(), alice));\n+\n+    alice.execute(\n+        privacyTransactions.addToPrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(), alice, charlie));\n+\n+    final OnChainPrivacyGroup expectedGroupAfterCharlieIsAdded =\n+        new OnChainPrivacyGroup(\n+            privxCreatePrivacyGroup.getPrivacyGroupId(),\n+            OnChainPrivacyGroup.Type.ONCHAIN,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(\n+                alice.getEnclaveKey(), bob.getEnclaveKey(), charlie.getEnclaveKey()));\n+\n+    alice.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+\n+    bob.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+\n+    charlie.verify(\n+        privateTransactionVerifier.validOnChainPrivacyGroupExists(\n+            expectedGroupAfterCharlieIsAdded));\n+  }\n+\n+  @Test\n+  public void bobCanAddCharlieAfterBeingAddedByAlice() {\n+    final PrivxCreatePrivacyGroup privxCreatePrivacyGroup =\n+        alice.execute(privacyTransactions.createOnChainPrivacyGroup(alice, alice));\n+\n+    assertThat(privxCreatePrivacyGroup).isNotNull();\n+\n+    final String privacyGroupId = privxCreatePrivacyGroup.getPrivacyGroupId();\n+    final OnChainPrivacyGroup expectedGroup =\n+        new OnChainPrivacyGroup(\n+            privacyGroupId,\n+            OnChainPrivacyGroup.Type.ONCHAIN,\n+            \"\",\n+            \"\",\n+            Base64String.wrapList(alice.getEnclaveKey()));\n+\n+    alice.verify(privateTransactionVerifier.validOnChainPrivacyGroupExists(expectedGroup));\n+\n+    final EventEmitter eventEmitter =\n+        alice.execute(\n+            privateContractTransactions.createSmartContractWithPrivacyGroupId(\n+                EventEmitter.class,\n+                alice.getTransactionSigningKey(),\n+                POW_CHAIN_ID,\n+                alice.getEnclaveKey(),\n+                privacyGroupId));\n+    privateContractVerifier\n+        .validPrivateContractDeployed(\n+            eventEmitter.getContractAddress(), alice.getAddress().toString())\n+        .verify(eventEmitter);\n+\n+    final String aliceLockHash =\n+        alice.execute(privacyTransactions.privxLockPrivacyGroup(privacyGroupId, alice));\n+\n+    alice.execute(privacyTransactions.addToPrivacyGroup(privacyGroupId, alice, bob));\n+\n+    final OnChainPrivacyGroup expectedGroupAfterBobIsAdded =\n+        new OnChainPrivacyGroup(\n+            privacyGroupId,\n+            OnChainPrivacyGroup.Type.ONCHAIN,", "originalCommit": "bfd223e7d9a2849d6c5d8550ee12478630365dde", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQyODI3NQ==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387428275", "bodyText": "nit: privacyGroupId can be final", "author": "pinges", "createdAt": "2020-03-04T03:15:01Z", "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/priv/PrivGetPrivateTransaction.java", "diffHunk": "@@ -71,32 +81,81 @@ public JsonRpcResponse response(final JsonRpcRequestContext requestContext) {\n     if (resultTransaction == null) {\n       return new JsonRpcSuccessResponse(requestContext.getRequest().getId(), null);\n     }\n-    try {\n-      LOG.trace(\"Fetching transaction information\");\n-      final ReceiveResponse receiveResponse =\n-          privacyController.retrieveTransaction(\n-              resultTransaction.getTransaction().getPayload().toBase64String(),\n-              enclavePublicKeyProvider.getEnclaveKey(requestContext.getUser()));\n-      LOG.trace(\"Received transaction information\");\n \n-      final BytesValueRLPInput input =\n-          new BytesValueRLPInput(\n-              Bytes.fromBase64String(new String(receiveResponse.getPayload(), UTF_8)), false);\n+    final String payloadKey =\n+        resultTransaction.getTransaction().getPayload().slice(0, 32).toBase64String();\n+    final String enclaveKey = enclavePublicKeyProvider.getEnclaveKey(requestContext.getUser());\n+    final Optional<PrivateTransaction> privateTransaction =\n+        findPrivateTransactionInEnclave(\n+            payloadKey, enclaveKey, resultTransaction.getBlockHash().get());\n \n-      final PrivateTransaction privateTransaction = PrivateTransaction.readFrom(input);\n-      if (privateTransaction.getPrivacyGroupId().isPresent()) {\n+    if (privateTransaction.isPresent()) {\n+      if (privateTransaction.get().getPrivacyGroupId().isPresent()) {\n         return new JsonRpcSuccessResponse(\n             requestContext.getRequest().getId(),\n-            new PrivateTransactionGroupResult(privateTransaction));\n+            new PrivateTransactionGroupResult(privateTransaction.get()));\n       } else {\n         return new JsonRpcSuccessResponse(\n             requestContext.getRequest().getId(),\n-            new PrivateTransactionLegacyResult(privateTransaction));\n+            new PrivateTransactionLegacyResult(privateTransaction.get()));\n       }\n-    } catch (final Exception e) {\n-      LOG.error(\"Failed to fetch private transaction\", e);\n+    } else {\n       return new JsonRpcErrorResponse(\n           requestContext.getRequest().getId(), JsonRpcError.ENCLAVE_ERROR);\n     }\n   }\n+\n+  private Optional<PrivateTransaction> findPrivateTransactionInEnclave(\n+      final String payloadKey, final String enclaveKey, final Hash blockHash) {\n+    PrivateTransaction privateTransaction = null;\n+    try {\n+      LOG.trace(\"Fetching transaction information\");\n+      final ReceiveResponse receiveResponse =\n+          privacyController.retrieveTransaction(payloadKey, enclaveKey);\n+\n+      final BytesValueRLPInput input =\n+          new BytesValueRLPInput(\n+              Bytes.fromBase64String(new String(receiveResponse.getPayload(), UTF_8)), false);\n+      input.enterList();\n+      if (input.nextIsList()) {\n+        privateTransaction = PrivateTransaction.readFrom(input);\n+        input.leaveListLenient();\n+      } else {\n+        input.reset();\n+        privateTransaction = PrivateTransaction.readFrom(input);\n+      }\n+      LOG.trace(\"Received transaction information\");\n+    } catch (final Exception e) {\n+      LOG.trace(\"Fetching transaction information from add blob\");\n+      final Optional<PrivacyGroupHeadBlockMap> privacyGroupHeadBlockMapOptional =\n+          privateStateStorage.getPrivacyGroupHeadBlockMap(blockHash);\n+      if (privacyGroupHeadBlockMapOptional.isPresent()) {\n+        for (Bytes32 privacyGroupId : privacyGroupHeadBlockMapOptional.get().keySet()) {", "originalCommit": "bfd223e7d9a2849d6c5d8550ee12478630365dde", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQyODU5Ng==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387428596", "bodyText": "nit: can be final", "author": "pinges", "createdAt": "2020-03-04T03:16:21Z", "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/priv/PrivGetPrivateTransaction.java", "diffHunk": "@@ -71,32 +81,81 @@ public JsonRpcResponse response(final JsonRpcRequestContext requestContext) {\n     if (resultTransaction == null) {\n       return new JsonRpcSuccessResponse(requestContext.getRequest().getId(), null);\n     }\n-    try {\n-      LOG.trace(\"Fetching transaction information\");\n-      final ReceiveResponse receiveResponse =\n-          privacyController.retrieveTransaction(\n-              resultTransaction.getTransaction().getPayload().toBase64String(),\n-              enclavePublicKeyProvider.getEnclaveKey(requestContext.getUser()));\n-      LOG.trace(\"Received transaction information\");\n \n-      final BytesValueRLPInput input =\n-          new BytesValueRLPInput(\n-              Bytes.fromBase64String(new String(receiveResponse.getPayload(), UTF_8)), false);\n+    final String payloadKey =\n+        resultTransaction.getTransaction().getPayload().slice(0, 32).toBase64String();\n+    final String enclaveKey = enclavePublicKeyProvider.getEnclaveKey(requestContext.getUser());\n+    final Optional<PrivateTransaction> privateTransaction =\n+        findPrivateTransactionInEnclave(\n+            payloadKey, enclaveKey, resultTransaction.getBlockHash().get());\n \n-      final PrivateTransaction privateTransaction = PrivateTransaction.readFrom(input);\n-      if (privateTransaction.getPrivacyGroupId().isPresent()) {\n+    if (privateTransaction.isPresent()) {\n+      if (privateTransaction.get().getPrivacyGroupId().isPresent()) {\n         return new JsonRpcSuccessResponse(\n             requestContext.getRequest().getId(),\n-            new PrivateTransactionGroupResult(privateTransaction));\n+            new PrivateTransactionGroupResult(privateTransaction.get()));\n       } else {\n         return new JsonRpcSuccessResponse(\n             requestContext.getRequest().getId(),\n-            new PrivateTransactionLegacyResult(privateTransaction));\n+            new PrivateTransactionLegacyResult(privateTransaction.get()));\n       }\n-    } catch (final Exception e) {\n-      LOG.error(\"Failed to fetch private transaction\", e);\n+    } else {\n       return new JsonRpcErrorResponse(\n           requestContext.getRequest().getId(), JsonRpcError.ENCLAVE_ERROR);\n     }\n   }\n+\n+  private Optional<PrivateTransaction> findPrivateTransactionInEnclave(\n+      final String payloadKey, final String enclaveKey, final Hash blockHash) {\n+    PrivateTransaction privateTransaction = null;\n+    try {\n+      LOG.trace(\"Fetching transaction information\");\n+      final ReceiveResponse receiveResponse =\n+          privacyController.retrieveTransaction(payloadKey, enclaveKey);\n+\n+      final BytesValueRLPInput input =\n+          new BytesValueRLPInput(\n+              Bytes.fromBase64String(new String(receiveResponse.getPayload(), UTF_8)), false);\n+      input.enterList();\n+      if (input.nextIsList()) {\n+        privateTransaction = PrivateTransaction.readFrom(input);\n+        input.leaveListLenient();\n+      } else {\n+        input.reset();\n+        privateTransaction = PrivateTransaction.readFrom(input);\n+      }\n+      LOG.trace(\"Received transaction information\");\n+    } catch (final Exception e) {\n+      LOG.trace(\"Fetching transaction information from add blob\");\n+      final Optional<PrivacyGroupHeadBlockMap> privacyGroupHeadBlockMapOptional =\n+          privateStateStorage.getPrivacyGroupHeadBlockMap(blockHash);\n+      if (privacyGroupHeadBlockMapOptional.isPresent()) {\n+        for (Bytes32 privacyGroupId : privacyGroupHeadBlockMapOptional.get().keySet()) {\n+          final Optional<Bytes32> addDataKey = privateStateStorage.getAddDataKey(privacyGroupId);\n+          if (addDataKey.isPresent()) {\n+            final List<PrivateTransactionWithMetadata> privateTransactionWithMetadataList =\n+                privacyController.retrieveAddBlob(addDataKey.get().toBase64String());\n+            for (PrivateTransactionWithMetadata privateTransactionWithMetadata :", "originalCommit": "bfd223e7d9a2849d6c5d8550ee12478630365dde", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzQ3NjUxMA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r387476510", "bodyText": "I think it would be a lot easier to use the PMT hash that is contained in the PrivateTransactionWithMetadata.PrivateTransactionMetadata to identify the right private transaction. We do have the PMT hash here!\nSomething like:\nif (privateTransactionWithMetadata.getPrivateTransactionMetadata().getPrivacyMarkerTransactionHash().equals(privacyMarkerTransactionHash)) {\nprivateTransaction = privateTransactionWithMetadata.getPrivateTransaction();\nbreak;\n}", "author": "pinges", "createdAt": "2020-03-04T06:50:32Z", "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/jsonrpc/internal/privacy/methods/priv/PrivGetPrivateTransaction.java", "diffHunk": "@@ -71,32 +81,81 @@ public JsonRpcResponse response(final JsonRpcRequestContext requestContext) {\n     if (resultTransaction == null) {\n       return new JsonRpcSuccessResponse(requestContext.getRequest().getId(), null);\n     }\n-    try {\n-      LOG.trace(\"Fetching transaction information\");\n-      final ReceiveResponse receiveResponse =\n-          privacyController.retrieveTransaction(\n-              resultTransaction.getTransaction().getPayload().toBase64String(),\n-              enclavePublicKeyProvider.getEnclaveKey(requestContext.getUser()));\n-      LOG.trace(\"Received transaction information\");\n \n-      final BytesValueRLPInput input =\n-          new BytesValueRLPInput(\n-              Bytes.fromBase64String(new String(receiveResponse.getPayload(), UTF_8)), false);\n+    final String payloadKey =\n+        resultTransaction.getTransaction().getPayload().slice(0, 32).toBase64String();\n+    final String enclaveKey = enclavePublicKeyProvider.getEnclaveKey(requestContext.getUser());\n+    final Optional<PrivateTransaction> privateTransaction =\n+        findPrivateTransactionInEnclave(\n+            payloadKey, enclaveKey, resultTransaction.getBlockHash().get());\n \n-      final PrivateTransaction privateTransaction = PrivateTransaction.readFrom(input);\n-      if (privateTransaction.getPrivacyGroupId().isPresent()) {\n+    if (privateTransaction.isPresent()) {\n+      if (privateTransaction.get().getPrivacyGroupId().isPresent()) {\n         return new JsonRpcSuccessResponse(\n             requestContext.getRequest().getId(),\n-            new PrivateTransactionGroupResult(privateTransaction));\n+            new PrivateTransactionGroupResult(privateTransaction.get()));\n       } else {\n         return new JsonRpcSuccessResponse(\n             requestContext.getRequest().getId(),\n-            new PrivateTransactionLegacyResult(privateTransaction));\n+            new PrivateTransactionLegacyResult(privateTransaction.get()));\n       }\n-    } catch (final Exception e) {\n-      LOG.error(\"Failed to fetch private transaction\", e);\n+    } else {\n       return new JsonRpcErrorResponse(\n           requestContext.getRequest().getId(), JsonRpcError.ENCLAVE_ERROR);\n     }\n   }\n+\n+  private Optional<PrivateTransaction> findPrivateTransactionInEnclave(\n+      final String payloadKey, final String enclaveKey, final Hash blockHash) {\n+    PrivateTransaction privateTransaction = null;\n+    try {\n+      LOG.trace(\"Fetching transaction information\");\n+      final ReceiveResponse receiveResponse =\n+          privacyController.retrieveTransaction(payloadKey, enclaveKey);\n+\n+      final BytesValueRLPInput input =\n+          new BytesValueRLPInput(\n+              Bytes.fromBase64String(new String(receiveResponse.getPayload(), UTF_8)), false);\n+      input.enterList();\n+      if (input.nextIsList()) {\n+        privateTransaction = PrivateTransaction.readFrom(input);\n+        input.leaveListLenient();\n+      } else {\n+        input.reset();\n+        privateTransaction = PrivateTransaction.readFrom(input);\n+      }\n+      LOG.trace(\"Received transaction information\");\n+    } catch (final Exception e) {\n+      LOG.trace(\"Fetching transaction information from add blob\");\n+      final Optional<PrivacyGroupHeadBlockMap> privacyGroupHeadBlockMapOptional =\n+          privateStateStorage.getPrivacyGroupHeadBlockMap(blockHash);\n+      if (privacyGroupHeadBlockMapOptional.isPresent()) {\n+        for (Bytes32 privacyGroupId : privacyGroupHeadBlockMapOptional.get().keySet()) {\n+          final Optional<Bytes32> addDataKey = privateStateStorage.getAddDataKey(privacyGroupId);\n+          if (addDataKey.isPresent()) {\n+            final List<PrivateTransactionWithMetadata> privateTransactionWithMetadataList =\n+                privacyController.retrieveAddBlob(addDataKey.get().toBase64String());\n+            for (PrivateTransactionWithMetadata privateTransactionWithMetadata :\n+                privateTransactionWithMetadataList) {\n+              final Hash privacyMarkerTransactionHash =\n+                  privateTransactionWithMetadata\n+                      .getPrivateTransactionMetadata()\n+                      .getPrivacyMarkerTransactionHash();\n+              if (blockchain\n+                  .transactionByHash(privacyMarkerTransactionHash)\n+                  .get()\n+                  .getTransaction()\n+                  .getPayload()\n+                  .toBase64String()\n+                  .equals(payloadKey)) {", "originalCommit": "bfd223e7d9a2849d6c5d8550ee12478630365dde", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "583d9b3f1ae381cec3585b48663a33be12e80da2", "url": "https://github.com/hyperledger/besu/commit/583d9b3f1ae381cec3585b48663a33be12e80da2", "message": "address comments\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>", "committedDate": "2020-03-05T20:27:43Z", "type": "forcePushed"}, {"oid": "52a35a6b438c97a07f6d0a0385e877e6256ba68f", "url": "https://github.com/hyperledger/besu/commit/52a35a6b438c97a07f6d0a0385e877e6256ba68f", "message": "on-chain-privacy-groups\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nfix some test failures\n\nSigned-off-by: Stefan Pingel <stefan.pingel@consensys.net>\n\nfix unused field\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\ntest fix\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\ntest fix\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\ntest fix\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\naddress comments\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nAdds privacy contracts (#4)\n\n* Adds privacy contracts, however web3j-evm issue prevents tests passing\n\n* Refactor tests\n\n* Various small changes\n\n* Reverts to older web3j version\n\n* Back to sane package naming now that we've figured out the test bug\n\n* Allow deploying of contracts with params in constructor\n\n* Addresses PR comments\n\nSigned-off-by: Joshua Richardson <joshua@richardson.tech>\n\nFix bug in transaction test\n\nSigned-off-by: Joshua Richardson <joshua@richardson.tech>\n\nmake AT transaction mining order deterministic\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nmake AT transaction mining order deterministic\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nfix getting re-added to a privacy group bug\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nfix compile\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nfix retrieving private transaction data after being added to group\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nadd privacy group to dsl\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\non-chain-privacy-groups\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nAddresses various comments from Stefan\n\nSigned-off-by: Joshua Richardson <joshua@richardson.tech>\n\nAddresses some more comments\n\nSigned-off-by: Joshua Richardson <joshua@richardson.tech>\n\nRebase errors\n\nSigned-off-by: Joshua Richardson <joshua@richardson.tech>\n\naddress comments\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nspotless\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nfix test\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nfix dsl\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\naddress comments\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nrefactor\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>", "committedDate": "2020-03-05T21:17:24Z", "type": "commit"}, {"oid": "52a35a6b438c97a07f6d0a0385e877e6256ba68f", "url": "https://github.com/hyperledger/besu/commit/52a35a6b438c97a07f6d0a0385e877e6256ba68f", "message": "on-chain-privacy-groups\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nfix some test failures\n\nSigned-off-by: Stefan Pingel <stefan.pingel@consensys.net>\n\nfix unused field\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\ntest fix\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\ntest fix\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\ntest fix\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\naddress comments\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nAdds privacy contracts (#4)\n\n* Adds privacy contracts, however web3j-evm issue prevents tests passing\n\n* Refactor tests\n\n* Various small changes\n\n* Reverts to older web3j version\n\n* Back to sane package naming now that we've figured out the test bug\n\n* Allow deploying of contracts with params in constructor\n\n* Addresses PR comments\n\nSigned-off-by: Joshua Richardson <joshua@richardson.tech>\n\nFix bug in transaction test\n\nSigned-off-by: Joshua Richardson <joshua@richardson.tech>\n\nmake AT transaction mining order deterministic\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nmake AT transaction mining order deterministic\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nfix getting re-added to a privacy group bug\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nfix compile\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nfix retrieving private transaction data after being added to group\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nadd privacy group to dsl\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\non-chain-privacy-groups\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nAddresses various comments from Stefan\n\nSigned-off-by: Joshua Richardson <joshua@richardson.tech>\n\nAddresses some more comments\n\nSigned-off-by: Joshua Richardson <joshua@richardson.tech>\n\nRebase errors\n\nSigned-off-by: Joshua Richardson <joshua@richardson.tech>\n\naddress comments\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nspotless\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nfix test\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nfix dsl\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\naddress comments\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>\n\nrefactor\n\nSigned-off-by: Ivaylo Kirilov <iikirilov@gmail.com>", "committedDate": "2020-03-05T21:17:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODE0OTc1OA==", "url": "https://github.com/hyperledger/besu/pull/423#discussion_r388149758", "bodyText": "The isMember check is done in the addParticipant as well, can be removed here or in the addParticipant :-)", "author": "pinges", "createdAt": "2020-03-05T08:49:02Z", "path": "privacy-contracts/src/main/solidity/DefaultOnChainPrivacyGroupManagementContract.sol", "diffHunk": "@@ -0,0 +1,106 @@\n+pragma solidity ^0.5.9;\n+import \"./OnChainPrivacyGroupManagementInterface.sol\";\n+\n+contract DefaultOnChainPrivacyGroupManagementContract is OnChainPrivacyGroupManagementInterface {\n+\n+    bool private _canExecute;\n+    int private _version;\n+    bytes32[] private distributionList;\n+    mapping(bytes32 => uint256) private distributionIndexOf;\n+\n+    function getVersion() external view returns (int) {\n+        return _version;\n+    }\n+\n+    // overrides\n+    function canExecute() external view returns (bool) {\n+        return _canExecute;\n+    }\n+\n+    function lock() public {\n+        require(_canExecute);\n+        _canExecute = false;\n+    }\n+\n+    function unlock() public {\n+        require(!_canExecute);\n+        _canExecute = true;\n+    }\n+\n+    function addParticipants(bytes32 _enclaveKey, bytes32[] memory _accounts) public returns (bool) {\n+        require(!_canExecute);\n+        if(distributionList.length == 0) {\n+            addParticipant(_enclaveKey);\n+        }\n+        require(isMember(_enclaveKey));\n+        bool result = addAll(_enclaveKey, _accounts);\n+        _canExecute = true;\n+        _version++;\n+        return result;\n+    }\n+\n+    function removeParticipant(bytes32 _enclaveKey, bytes32 _account) public returns (bool) {\n+        require(isMember(_enclaveKey));\n+        return removeInternal(_account);\n+    }\n+\n+    function getParticipants(bytes32 _enclaveKey) public view returns (bytes32[] memory) {\n+        require(isMember(_enclaveKey));\n+        return distributionList;\n+    }\n+\n+\n+    //internal functions\n+    function addAll(bytes32 _enclaveKey, bytes32[] memory _accounts) internal returns (bool) {\n+        bool allAdded = true;\n+        for (uint i = 0; i < _accounts.length; i++) {\n+            if (_enclaveKey == _accounts[i]) {\n+                emit ParticipantAdded(false, _accounts[i], \"Adding own account as a Member is not permitted\");\n+                allAdded = allAdded && false;\n+            } else if (isMember(_accounts[i])) {", "originalCommit": "ad66fd22ff430fc34cb60f12dd55d587288c0fd9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}