{"pr_number": 411, "pr_title": "LogBloomCache - make sure the current segment is filled", "pr_createdAt": "2020-02-19T01:21:27Z", "pr_url": "https://github.com/hyperledger/besu/pull/411", "timeline": [{"oid": "fcd6fcfe714b96c1e674316250a5ac25f7f6ae4b", "url": "https://github.com/hyperledger/besu/commit/fcd6fcfe714b96c1e674316250a5ac25f7f6ae4b", "message": "LogBloomCache - make sure the current segment is filled\n\nMake sure we cache the current cache segment with all of the data from\nthe beginning of the segment.  Use a flip file approach since it will be\n a partial file until done.\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-02-19T01:20:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzNjM5MQ==", "url": "https://github.com/hyperledger/besu/pull/411#discussion_r381036391", "bodyText": "This while loop near the chain head on EthScheduler seems to be approximating a listener. The whole logs caching endeavor reminds me of pruning in that way. Where there's something that needs to be done in bulk (marking the whole state trie of one special block <-> doing all the caching for previous segments) and one that is done with a listener (marking new nodes from new blocks with a listener on the state storage <-> random access writing the log blooms for recent blocks). Could a similar approach be useful here?", "author": "RatanRSur", "createdAt": "2020-02-19T01:49:22Z", "path": "ethereum/api/src/main/java/org/hyperledger/besu/ethereum/api/query/TransactionLogBloomCacher.java", "diffHunk": "@@ -128,27 +132,63 @@ private void fillCacheFile(\n     }\n   }\n \n-  public void cacheLogsBloomForBlockHeader(\n+  void cacheLogsBloomForBlockHeader(\n       final BlockHeader blockHeader,\n       final Optional<File> reusedCacheFile,\n       final boolean ensureChecks) {\n     try {\n+      if (cachingStatus.cachingCount.incrementAndGet() != 1) {\n+        return;\n+      }\n       final long blockNumber = blockHeader.getNumber();\n       LOG.debug(\"Caching logs bloom for block {}.\", \"0x\" + Long.toHexString(blockNumber));\n       if (ensureChecks) {\n         ensurePreviousSegmentsArePresent(blockNumber);\n       }\n       final File cacheFile = reusedCacheFile.orElse(calculateCacheFileName(blockNumber, cacheDir));\n-      if (!cacheFile.exists()) {\n-        Files.createFile(cacheFile.toPath());\n+      if (cacheFile.exists()) {\n+        cacheSingleBlock(blockHeader, cacheFile);\n+      } else {\n+        scheduler.scheduleComputationTask(this::populateLatestSegment);\n+      }\n+    } catch (final IOException e) {\n+      LOG.error(\"Unhandled caching exception.\", e);\n+    } finally {\n+      cachingStatus.cachingCount.decrementAndGet();\n+    }\n+  }\n+\n+  private void cacheSingleBlock(final BlockHeader blockHeader, final File cacheFile)\n+      throws IOException {\n+    try (final RandomAccessFile writer = new RandomAccessFile(cacheFile, \"rw\")) {\n+      final long offset = (blockHeader.getNumber() % BLOCKS_PER_BLOOM_CACHE) * BLOOM_BITS_LENGTH;\n+      writer.seek(offset);\n+      writer.write(ensureBloomBitsAreCorrectLength(blockHeader.getLogsBloom().toArray()));\n+    }\n+  }\n+\n+  private boolean populateLatestSegment() {\n+    try {\n+      long blockNumber = blockchain.getChainHeadBlockNumber();\n+      final File currentFile = calculateCacheFileName(CURRENT, cacheDir);\n+      final long segmentNumber = blockNumber / BLOCKS_PER_BLOOM_CACHE;\n+      try (final OutputStream out = new FileOutputStream(currentFile)) {\n+        fillCacheFile(segmentNumber * BLOCKS_PER_BLOOM_CACHE, blockNumber, out);\n       }\n-      try (RandomAccessFile writer = new RandomAccessFile(cacheFile, \"rw\")) {\n-        final long offset = (blockNumber / BLOCKS_PER_BLOOM_CACHE) * BLOOM_BITS_LENGTH;\n-        writer.seek(offset);\n-        writer.write(ensureBloomBitsAreCorrectLength(blockHeader.getLogsBloom().toArray()));\n+      while (blockNumber <= blockchain.getChainHeadBlockNumber()\n+          && (blockNumber % BLOCKS_PER_BLOOM_CACHE != 0)) {\n+        cacheSingleBlock(blockchain.getBlockHeader(blockNumber).orElseThrow(), currentFile);\n+        blockNumber++;", "originalCommit": "fcd6fcfe714b96c1e674316250a5ac25f7f6ae4b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTM1OTMxNw==", "url": "https://github.com/hyperledger/besu/pull/411#discussion_r381359317", "bodyText": "This is catching up for the case where more blocks could have shown up in the interim while caching the current segment.  We could do it with a listener but I am concerned that the readability would further suffer, since we would need to put the newly arrived blocks to the side while we finish up caching the segment and then while we pop off a listened object yet another one could show up.  This class already is a tad bit hard to read and making a do this while we are behind keeps that logic isolated to one method.", "author": "shemnon", "createdAt": "2020-02-19T15:19:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTAzNjM5MQ=="}], "type": "inlineReview"}, {"oid": "882789ee45de2ac7b37c3708f7b4aac9e9e0cc04", "url": "https://github.com/hyperledger/besu/commit/882789ee45de2ac7b37c3708f7b4aac9e9e0cc04", "message": "Merge branch 'master' into cachecurrent", "committedDate": "2020-02-19T08:00:45Z", "type": "commit"}, {"oid": "5d91d23071e7649eb22f6b5416074aa4ab869102", "url": "https://github.com/hyperledger/besu/commit/5d91d23071e7649eb22f6b5416074aa4ab869102", "message": "Merge branch 'master' into cachecurrent", "committedDate": "2020-02-19T16:14:42Z", "type": "commit"}]}