{"pr_number": 1046, "pr_title": "Move EVM memory to a flat bytes array", "pr_createdAt": "2020-06-04T18:26:46Z", "pr_url": "https://github.com/hyperledger/besu/pull/1046", "timeline": [{"oid": "cd4e21e219da573c79685fb77436d2756daf7e83", "url": "https://github.com/hyperledger/besu/commit/cd4e21e219da573c79685fb77436d2756daf7e83", "message": "Move EVM memory to a flat bytes array\n\nPerformance measurements have indicated that the list of Bytes32 for\nmemory is not performant enough. Moving to a byte array reduces wrapper\nobject thrashing as well as simplifying cross-word boundary logic (there\nare no boundaries).\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-06-04T18:26:07Z", "type": "commit"}, {"oid": "4db40c816980e52fbea62100d86ff158220a05bf", "url": "https://github.com/hyperledger/besu/commit/4db40c816980e52fbea62100d86ff158220a05bf", "message": "Merge branch 'master' into bytesMemory", "committedDate": "2020-06-04T18:26:52Z", "type": "commit"}, {"oid": "e3109763a41f8c9e4ecdcc8811f897a9c4996610", "url": "https://github.com/hyperledger/besu/commit/e3109763a41f8c9e4ecdcc8811f897a9c4996610", "message": "spotless\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-06-04T18:35:48Z", "type": "commit"}, {"oid": "8af503bfe8a56a116812e7f491276cf931d1c65d", "url": "https://github.com/hyperledger/besu/commit/8af503bfe8a56a116812e7f491276cf931d1c65d", "message": "tracing likes this copy method better\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-06-04T21:05:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0MTQ0Mw==", "url": "https://github.com/hyperledger/besu/pull/1046#discussion_r435541443", "bodyText": "Can we make this int just like we did in  asByteIndex?", "author": "RatanRSur", "createdAt": "2020-06-04T20:51:43Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/Memory.java", "diffHunk": "@@ -228,7 +195,7 @@ public int hashCode() {\n    * @return The current number of active bytes stored in memory.\n    */\n   long getActiveBytes() {\n-    return (long) data.size() * Bytes32.SIZE;\n+    return (long) data.length;", "originalCommit": "e3109763a41f8c9e4ecdcc8811f897a9c4996610", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2NzM2OA==", "url": "https://github.com/hyperledger/besu/pull/1046#discussion_r435567368", "bodyText": "sure", "author": "shemnon", "createdAt": "2020-06-04T21:37:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0MTQ0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0MTkwOQ==", "url": "https://github.com/hyperledger/besu/pull/1046#discussion_r435541909", "bodyText": "Oh cool, I didn't know about this method.", "author": "RatanRSur", "createdAt": "2020-06-04T20:52:36Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/Memory.java", "diffHunk": "@@ -190,15 +159,13 @@ void ensureCapacityForBytes(final long address, final int numBytes) {\n    * @param newActiveWords The new number of active words to expand to.\n    */\n   private void maybeExpandCapacity(final int newActiveWords) {\n-    if (data.size() >= newActiveWords) return;\n+    if (dataSize256 >= newActiveWords) return;\n \n     // Require full capacity to guarantee we don't resize more than once.\n-    data.ensureCapacity(newActiveWords);\n-    final int toAdd = newActiveWords - data.size();\n-    for (int i = 0; i < toAdd; i++) {\n-      data.add(MutableBytes32.create());\n-    }\n-    this.activeWords = UInt256.valueOf(data.size());\n+    final byte[] newData = new byte[newActiveWords * Bytes32.SIZE];\n+    System.arraycopy(data, 0, newData, 0, data.length);", "originalCommit": "e3109763a41f8c9e4ecdcc8811f897a9c4996610", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2NTA0NA==", "url": "https://github.com/hyperledger/besu/pull/1046#discussion_r435565044", "bodyText": "And it's a 'JVM intrinsic candidate' which means it goes straight to assembly fairly quickly.", "author": "shemnon", "createdAt": "2020-06-04T21:32:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0MTkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0MjIyMQ==", "url": "https://github.com/hyperledger/besu/pull/1046#discussion_r435542221", "bodyText": "I love seeing so much deleted code!", "author": "RatanRSur", "createdAt": "2020-06-04T20:53:04Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/Memory.java", "diffHunk": "@@ -258,42 +225,10 @@ public Bytes getBytes(final UInt256 location, final UInt256 numBytes) {\n       return Bytes.EMPTY;\n     }\n \n-    final long start = asByteIndex(location);\n+    final int start = asByteIndex(location);\n \n     ensureCapacityForBytes(start, length);\n-\n-    // Index of last byte to set.\n-    final long end = start + length - 1;\n-\n-    final int startWord = wordForByte(start);\n-    final int idxInStart = indexInWord(start);\n-    final int endWord = wordForByte(end);\n-    final int idxInEnd = indexInWord(end);\n-\n-    if (startWord == endWord) {\n-      // Bytes within a word, fast-path.\n-      final Bytes bytes = data.get(startWord);\n-      return idxInStart == 0 && length == Bytes32.SIZE\n-          //          ? bytes.copy()\n-          //          : bytes.slice(idxInStart, length).copy();\n-          ? bytes\n-          : bytes.slice(idxInStart, length);\n-    }\n-\n-    // Spans multiple word, slower path.\n-    final int bytesInStartWord = Bytes32.SIZE - idxInStart;\n-    final int bytesInEndWord = idxInEnd + 1;\n-\n-    final MutableBytes result = MutableBytes.create(length);\n-    int resultIdx = 0;\n-    data.get(startWord).slice(idxInStart).copyTo(result, resultIdx);\n-    resultIdx += bytesInStartWord;\n-    for (int i = startWord + 1; i < endWord; i++) {\n-      data.get(i).copyTo(result, resultIdx);\n-      resultIdx += Bytes32.SIZE;\n-    }\n-    data.get(endWord).slice(0, bytesInEndWord).copyTo(result, resultIdx);\n-    return result;\n+    return Bytes.wrap(data, location.intValue(), numBytes.intValue()).copy();", "originalCommit": "e3109763a41f8c9e4ecdcc8811f897a9c4996610", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0NzUwMA==", "url": "https://github.com/hyperledger/besu/pull/1046#discussion_r435547500", "bodyText": "Is MAX_BYTES different now that we are using a straight byte[] instead of ArrayList?", "author": "RatanRSur", "createdAt": "2020-06-04T21:03:27Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/Memory.java", "diffHunk": "@@ -98,9 +72,9 @@ private void checkByteIndex(final long v) {\n     if (v < 0 || v >= MAX_BYTES) throw overflow(v);", "originalCommit": "e3109763a41f8c9e4ecdcc8811f897a9c4996610", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU1OTIxMA==", "url": "https://github.com/hyperledger/besu/pull/1046#discussion_r435559210", "bodyText": "Yes, it's max int now.  fixing", "author": "shemnon", "createdAt": "2020-06-04T21:21:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0NzUwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0NzgxMg==", "url": "https://github.com/hyperledger/besu/pull/1046#discussion_r435547812", "bodyText": "Should we use asByteIndex here?", "author": "RatanRSur", "createdAt": "2020-06-04T21:04:02Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/Memory.java", "diffHunk": "@@ -341,72 +276,26 @@ public void setBytes(\n    * @param location the location in memory at which to start copying the bytes of {@code value}.\n    * @param numBytes the number of bytes to set in memory. Note that this value may differ from\n    *     {@code value.size()}: if {@code numBytes < value.size()} bytes, only {@code numBytes} will\n-   *     be copied from {@code value}; if {@code numBytes < value.size()}, then only the bytes in\n+   *     be copied from {@code value}; if {@code numBytes > value.size()}, then only the bytes in\n    *     {@code value} will be copied, but the memory will be expanded if necessary to cover {@code\n    *     numBytes} (in other words, {@link #getActiveWords()} will return a value consistent with\n    *     having set {@code numBytes} bytes, even if less than that have been concretely set due to\n    *     {@code value} being smaller).\n    * @param taintedValue the bytes to copy to memory from {@code location}.\n    */\n   public void setBytes(final UInt256 location, final UInt256 numBytes, final Bytes taintedValue) {\n-    if (numBytes.isZero()) {\n-      return;\n-    }\n-\n-    final long start = asByteIndex(location);\n-    final int length = asByteLength(numBytes);\n-\n-    ensureCapacityForBytes(start, length);\n-\n-    // We've properly expanded memory as needed. We now have simply have to copy the\n-    // min(length, value.size()) first bytes of value and clear any bytes that exceed value's length\n-    if (taintedValue.isEmpty()) {\n-      clearBytes(location, numBytes);\n-      return;\n-    }\n-    final Bytes value;\n-    if (taintedValue.size() > length) {\n-      value = taintedValue.slice(0, length);\n-    } else if (taintedValue.size() < length) {\n-      value = taintedValue;\n-      clearBytes(location.add(taintedValue.size()), numBytes.subtract(taintedValue.size()));\n-    } else {\n-      value = taintedValue;\n-    }\n-\n-    // Index of last byte to set.\n-    final long end = start + value.size() - 1;\n-\n-    final int startWord = wordForByte(start);\n-    final int idxInStart = indexInWord(start);\n-    final int endWord = wordForByte(end);\n-\n-    if (startWord == endWord) {\n-      // Bytes within a word, fast-path.\n-      final MutableBytes mb = data.get(startWord).mutableCopy();\n-\n-      value.copyTo(mb, idxInStart);\n-      data.set(startWord, (Bytes32) mb.copy());\n-      return;\n-    }\n-\n-    // Spans multiple word, slower path.\n-    final int bytesInStartWord = Bytes32.SIZE - idxInStart;\n-\n-    int valueIdx = 0;\n-    final MutableBytes startMutable = data.get(startWord).mutableCopy();\n-    value.slice(valueIdx, bytesInStartWord).copyTo(startMutable, idxInStart);\n-    data.set(startWord, (Bytes32) startMutable.copy());\n-    valueIdx += bytesInStartWord;\n-    for (int i = startWord + 1; i < endWord; i++) {\n-      final MutableBytes mb = data.get(i).mutableCopy();\n-      value.slice(valueIdx, Bytes32.SIZE).copyTo(mb);\n-      data.set(i, (Bytes32) mb.copy());\n-      valueIdx += Bytes32.SIZE;\n+    final int copySize = numBytes.intValue();", "originalCommit": "e3109763a41f8c9e4ecdcc8811f897a9c4996610", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2NDY0MA==", "url": "https://github.com/hyperledger/besu/pull/1046#discussion_r435564640", "bodyText": "Actually asByteLength for this one, but we should be doing it for the start.", "author": "shemnon", "createdAt": "2020-06-04T21:31:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU0NzgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU1MzkzMg==", "url": "https://github.com/hyperledger/besu/pull/1046#discussion_r435553932", "bodyText": "Leaving this comment as a marker to myself to get back to understanding why we need this line.", "author": "RatanRSur", "createdAt": "2020-06-04T21:14:20Z", "path": "ethereum/core/src/main/java/org/hyperledger/besu/ethereum/vm/Memory.java", "diffHunk": "@@ -341,72 +276,26 @@ public void setBytes(\n    * @param location the location in memory at which to start copying the bytes of {@code value}.\n    * @param numBytes the number of bytes to set in memory. Note that this value may differ from\n    *     {@code value.size()}: if {@code numBytes < value.size()} bytes, only {@code numBytes} will\n-   *     be copied from {@code value}; if {@code numBytes < value.size()}, then only the bytes in\n+   *     be copied from {@code value}; if {@code numBytes > value.size()}, then only the bytes in\n    *     {@code value} will be copied, but the memory will be expanded if necessary to cover {@code\n    *     numBytes} (in other words, {@link #getActiveWords()} will return a value consistent with\n    *     having set {@code numBytes} bytes, even if less than that have been concretely set due to\n    *     {@code value} being smaller).\n    * @param taintedValue the bytes to copy to memory from {@code location}.\n    */\n   public void setBytes(final UInt256 location, final UInt256 numBytes, final Bytes taintedValue) {\n-    if (numBytes.isZero()) {\n-      return;\n-    }\n-\n-    final long start = asByteIndex(location);\n-    final int length = asByteLength(numBytes);\n-\n-    ensureCapacityForBytes(start, length);\n-\n-    // We've properly expanded memory as needed. We now have simply have to copy the\n-    // min(length, value.size()) first bytes of value and clear any bytes that exceed value's length\n-    if (taintedValue.isEmpty()) {\n-      clearBytes(location, numBytes);\n-      return;\n-    }\n-    final Bytes value;\n-    if (taintedValue.size() > length) {\n-      value = taintedValue.slice(0, length);\n-    } else if (taintedValue.size() < length) {\n-      value = taintedValue;\n-      clearBytes(location.add(taintedValue.size()), numBytes.subtract(taintedValue.size()));\n-    } else {\n-      value = taintedValue;\n-    }\n-\n-    // Index of last byte to set.\n-    final long end = start + value.size() - 1;\n-\n-    final int startWord = wordForByte(start);\n-    final int idxInStart = indexInWord(start);\n-    final int endWord = wordForByte(end);\n-\n-    if (startWord == endWord) {\n-      // Bytes within a word, fast-path.\n-      final MutableBytes mb = data.get(startWord).mutableCopy();\n-\n-      value.copyTo(mb, idxInStart);\n-      data.set(startWord, (Bytes32) mb.copy());\n-      return;\n-    }\n-\n-    // Spans multiple word, slower path.\n-    final int bytesInStartWord = Bytes32.SIZE - idxInStart;\n-\n-    int valueIdx = 0;\n-    final MutableBytes startMutable = data.get(startWord).mutableCopy();\n-    value.slice(valueIdx, bytesInStartWord).copyTo(startMutable, idxInStart);\n-    data.set(startWord, (Bytes32) startMutable.copy());\n-    valueIdx += bytesInStartWord;\n-    for (int i = startWord + 1; i < endWord; i++) {\n-      final MutableBytes mb = data.get(i).mutableCopy();\n-      value.slice(valueIdx, Bytes32.SIZE).copyTo(mb);\n-      data.set(i, (Bytes32) mb.copy());\n-      valueIdx += Bytes32.SIZE;\n+    final int copySize = numBytes.intValue();\n+    if (copySize > 0) {\n+      final int srcLength = taintedValue.size();\n+      final int locationInt = location.intValue();\n+      ensureCapacityForBytes(locationInt, copySize);\n+      if (srcLength >= copySize) {\n+        System.arraycopy(taintedValue.toArrayUnsafe(), 0, data, locationInt, copySize);\n+      } else {\n+        Arrays.fill(data, locationInt, locationInt + copySize, (byte) 0);", "originalCommit": "e3109763a41f8c9e4ecdcc8811f897a9c4996610", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU1ODc5OQ==", "url": "https://github.com/hyperledger/besu/pull/1046#discussion_r435558799", "bodyText": "For the case where what we are copying is shorter than the desired destination the EVM specifies we should fill the unspecified memory with zeros.  There are reference tests enforcing this.", "author": "shemnon", "createdAt": "2020-06-04T21:20:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU1MzkzMg=="}], "type": "inlineReview"}, {"oid": "8b5535d4dbb18fc5d2764bf648b8405f49201825", "url": "https://github.com/hyperledger/besu/commit/8b5535d4dbb18fc5d2764bf648b8405f49201825", "message": "boundary checking\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-06-04T21:30:58Z", "type": "commit"}, {"oid": "c31596a30998069076a6cde8e99123ec8cbbb389", "url": "https://github.com/hyperledger/besu/commit/c31596a30998069076a6cde8e99123ec8cbbb389", "message": "more boundary checking changes\n\nSigned-off-by: Danno Ferrin <danno.ferrin@gmail.com>", "committedDate": "2020-06-04T21:37:41Z", "type": "commit"}, {"oid": "16c8a9986bd5918449595364aabc54e4527c5129", "url": "https://github.com/hyperledger/besu/commit/16c8a9986bd5918449595364aabc54e4527c5129", "message": "Merge branch 'master' into bytesMemory", "committedDate": "2020-06-04T21:38:18Z", "type": "commit"}]}