{"pr_number": 10176, "pr_title": "Correctly propagate exceptions from inbound operations in all cases", "pr_createdAt": "2020-04-09T07:10:51Z", "pr_url": "https://github.com/netty/netty/pull/10176", "timeline": [{"oid": "4665bebfbe5c5f954e7465e094cf193393616d44", "url": "https://github.com/netty/netty/commit/4665bebfbe5c5f954e7465e094cf193393616d44", "message": "Correctly propagate exceptions from inbound operations in all cases\n\nMotivation:\n\nIn AbstractChannelHandlerContext we had some code where we tried to guard against endless loops caused by exceptions thrown by exceptionCaught(...) that would trigger exceptionCaught again. This code was proplematic for two reasons:\n - It is quite expensive as we need to compare all the stacks\n - We may end up not notify another handlers exceptionCaught(...) if in our exeuction stack we triggered actions that will cause an exceptionCaught somewhere else in the pipeline\n\nModifications:\n\n- Just remove the detection code as we already handle everything correctly when we invoke exceptionCaught(...)\n- Add unit tests\n\nResult:\n\nEnsure we always notify correctly and also fixes performance issue reported as https://github.com/netty/netty/issues/10165", "committedDate": "2020-04-09T07:05:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzMzgzMg==", "url": "https://github.com/netty/netty/pull/10176#discussion_r406033832", "bodyText": "Best way to solve the stacktrace inspecting issue :)", "author": "slandelle", "createdAt": "2020-04-09T08:16:26Z", "path": "transport/src/main/java/io/netty/channel/AbstractChannelHandlerContext.java", "diffHunk": "@@ -814,39 +814,6 @@ private static void notifyOutboundHandlerException(Throwable cause, ChannelPromi\n         PromiseNotificationUtil.tryFailure(promise, cause, promise instanceof VoidChannelPromise ? null : logger);\n     }\n \n-    private void notifyHandlerException(Throwable cause) {\n-        if (inExceptionCaught(cause)) {\n-            if (logger.isWarnEnabled()) {\n-                logger.warn(\n-                        \"An exception was thrown by a user handler \" +\n-                                \"while handling an exceptionCaught event\", cause);\n-            }\n-            return;\n-        }\n-\n-        invokeExceptionCaught(cause);\n-    }\n-\n-    private static boolean inExceptionCaught(Throwable cause) {\n-        do {\n-            StackTraceElement[] trace = cause.getStackTrace();", "originalCommit": "4665bebfbe5c5f954e7465e094cf193393616d44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzNDIzMw==", "url": "https://github.com/netty/netty/pull/10176#discussion_r406034233", "bodyText": "@slandelle exactly :D ... no code is the best code.", "author": "normanmaurer", "createdAt": "2020-04-09T08:17:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzMzgzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzODc2OQ==", "url": "https://github.com/netty/netty/pull/10176#discussion_r406038769", "bodyText": "@trustin @slandelle this is the interesting part in terms of bug-fixing.", "author": "normanmaurer", "createdAt": "2020-04-09T08:24:58Z", "path": "transport/src/test/java/io/netty/channel/DefaultChannelPipelineTest.java", "diffHunk": "@@ -333,6 +334,87 @@ public void testChannelHandlerContextNavigation() {\n         verifyContextNumber(pipeline, HANDLER_ARRAY_LEN * 2);\n     }\n \n+    @Test(timeout = 3000)\n+    public void testThrowInExceptionCaught() throws InterruptedException {\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        final AtomicInteger counter = new AtomicInteger();\n+        Channel channel = new LocalChannel();\n+        try {\n+            group.register(channel).syncUninterruptibly();\n+            channel.pipeline().addLast(new ChannelInboundHandlerAdapter() {\n+                class TestException extends Exception { }\n+\n+                @Override\n+                public void channelReadComplete(ChannelHandlerContext ctx) throws Exception {\n+                    throw new TestException();\n+                }\n+\n+                @Override\n+                public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+                    if (cause instanceof TestException) {\n+                        ctx.executor().execute(new Runnable() {\n+                            @Override\n+                            public void run() {\n+                                latch.countDown();\n+                            }\n+                        });\n+                    }\n+                    counter.incrementAndGet();\n+                    throw new Exception();\n+                }\n+            });\n+\n+            channel.pipeline().fireChannelReadComplete();\n+            latch.await();\n+            assertEquals(1, counter.get());\n+        } finally {\n+            channel.close().syncUninterruptibly();\n+        }\n+    }\n+\n+    @Test(timeout = 3000)\n+    public void testThrowInOtherHandlerAfterInvokedFromExceptionCaught() throws InterruptedException {", "originalCommit": "4665bebfbe5c5f954e7465e094cf193393616d44", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzOTEwMw==", "url": "https://github.com/netty/netty/pull/10176#discussion_r406039103", "bodyText": "This test fails before the change .", "author": "normanmaurer", "createdAt": "2020-04-09T08:25:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjAzODc2OQ=="}], "type": "inlineReview"}]}