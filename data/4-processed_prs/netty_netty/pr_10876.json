{"pr_number": 10876, "pr_title": "Ensure we only register native methods once", "pr_createdAt": "2020-12-17T14:25:09Z", "pr_url": "https://github.com/netty/netty/pull/10876", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEyOTg5MA==", "url": "https://github.com/netty/netty/pull/10876#discussion_r545129890", "bodyText": "Removed all this stuff as we can easily share it.", "author": "normanmaurer", "createdAt": "2020-12-17T14:26:07Z", "path": "transport-native-unix-common/pom.xml", "diffHunk": "@@ -180,136 +122,17 @@\n       <properties>\n         <jni.platform>linux</jni.platform>\n       </properties>\n-      <build>\n-        <plugins>\n-          <plugin>\n-            <artifactId>maven-antrun-plugin</artifactId>\n-            <executions>\n-              <!-- Build the additional JAR that contains the native library. -->\n-              <execution>\n-                <id>native-jar</id>\n-                <phase>package</phase>\n-                <goals>\n-                  <goal>run</goal>\n-                </goals>\n-                <configuration>\n-                  <target>\n-                    <copy todir=\"${nativeJarWorkdir}\">\n-                      <zipfileset src=\"${defaultJarFile}\" />\n-                    </copy>\n-                    <copy todir=\"${nativeJarWorkdir}\" includeEmptyDirs=\"false\">\n-                      <zipfileset dir=\"${nativeLibOnlyDir}\" />\n-                      <regexpmapper handledirsep=\"yes\" from=\"^(?:[^/]+/)*([^/]+)$\" to=\"META-INF/native/lib/\\1\" />\n-                    </copy>\n-                    <copy todir=\"${nativeJarWorkdir}\" includeEmptyDirs=\"false\">\n-                      <zipfileset dir=\"${nativeIncludeDir}\" />\n-                      <regexpmapper handledirsep=\"yes\" from=\"^(?:[^/]+/)*([^/]+).h$\" to=\"META-INF/native/include/\\1.h\" />\n-                    </copy>\n-                    <copy todir=\"${nativeJarWorkdir}\" includeEmptyDirs=\"false\">\n-                      <zipfileset dir=\"${jniUtilIncludeDir}\" />\n-                      <regexpmapper handledirsep=\"yes\" from=\"^(?:[^/]+/)*([^/]+).h$\" to=\"META-INF/native/include/\\1.h\" />\n-                    </copy>\n-                    <jar destfile=\"${nativeJarFile}\" manifest=\"${nativeJarWorkdir}/META-INF/MANIFEST.MF\" basedir=\"${nativeJarWorkdir}\" index=\"true\" excludes=\"META-INF/MANIFEST.MF,META-INF/INDEX.LIST\" />\n-                    <attachartifact file=\"${nativeJarFile}\" classifier=\"${jni.classifier}\" type=\"jar\" />\n-                  </target>\n-                </configuration>\n-              </execution>\n-              <!-- invoke the make file to build a static library -->\n-              <execution>\n-                <id>build-native-lib</id>\n-                <phase>generate-sources</phase>\n-                <goals>\n-                  <goal>run</goal>\n-                </goals>\n-                <configuration>\n-                  <target>\n-                    <exec executable=\"${exe.make}\" failonerror=\"true\" resolveexecutable=\"true\">\n-                      <env key=\"CC\" value=\"${exe.compiler}\" />\n-                      <env key=\"AR\" value=\"${exe.archiver}\" />\n-                      <env key=\"LIB_DIR\" value=\"${nativeLibOnlyDir}\" />\n-                      <env key=\"OBJ_DIR\" value=\"${nativeObjsOnlyDir}\" />\n-                      <env key=\"JNI_PLATFORM\" value=\"${jni.platform}\" />\n-                      <env key=\"CFLAGS\" value=\"-O3 -Werror -Wno-attributes -fPIC -fno-omit-frame-pointer -Wunused-variable -fvisibility=hidden\" />\n-                      <env key=\"LDFLAGS\" value=\"-Wl,--no-as-needed -lrt\" />\n-                      <env key=\"LIB_NAME\" value=\"${nativeLibName}\" />\n-                    </exec>\n-                  </target>\n-                </configuration>\n-              </execution>\n-            </executions>\n-          </plugin>\n-        </plugins>\n-      </build>\n     </profile>\n     <profile>\n       <id>linux-aarch64</id>\n       <properties>\n         <!-- use aarch_64 as this is also what os.detected.arch will use on an aarch64 system -->\n+        <nativeLibArch>aarch_64</nativeLibArch>\n         <jni.classifier>${os.detected.name}-aarch_64</jni.classifier>\n         <jni.platform>linux</jni.platform>\n         <exe.compiler>aarch64-linux-gnu-gcc</exe.compiler>\n         <exe.archiver>aarch64-linux-gnu-ar</exe.archiver>\n       </properties>\n-      <build>\n-        <plugins>\n-          <plugin>\n-            <artifactId>maven-antrun-plugin</artifactId>\n-            <executions>\n-              <!-- Build the additional JAR that contains the native library. -->\n-              <execution>\n-                <id>native-jar</id>\n-                <phase>package</phase>\n-                <goals>\n-                  <goal>run</goal>\n-                </goals>\n-                <configuration>\n-                  <target>\n-                    <copy todir=\"${nativeJarWorkdir}\">\n-                      <zipfileset src=\"${defaultJarFile}\" />\n-                    </copy>\n-                    <copy todir=\"${nativeJarWorkdir}\" includeEmptyDirs=\"false\">\n-                      <zipfileset dir=\"${nativeLibOnlyDir}\" />\n-                      <regexpmapper handledirsep=\"yes\" from=\"^(?:[^/]+/)*([^/]+)$\" to=\"META-INF/native/lib/\\1\" />\n-                    </copy>\n-                    <copy todir=\"${nativeJarWorkdir}\" includeEmptyDirs=\"false\">\n-                      <zipfileset dir=\"${nativeIncludeDir}\" />\n-                      <regexpmapper handledirsep=\"yes\" from=\"^(?:[^/]+/)*([^/]+).h$\" to=\"META-INF/native/include/\\1.h\" />\n-                    </copy>\n-                    <copy todir=\"${nativeJarWorkdir}\" includeEmptyDirs=\"false\">\n-                      <zipfileset dir=\"${jniUtilIncludeDir}\" />\n-                      <regexpmapper handledirsep=\"yes\" from=\"^(?:[^/]+/)*([^/]+).h$\" to=\"META-INF/native/include/\\1.h\" />\n-                    </copy>\n-                    <jar destfile=\"${nativeJarFile}\" manifest=\"${nativeJarWorkdir}/META-INF/MANIFEST.MF\" basedir=\"${nativeJarWorkdir}\" index=\"true\" excludes=\"META-INF/MANIFEST.MF,META-INF/INDEX.LIST\" />\n-                    <attachartifact file=\"${nativeJarFile}\" classifier=\"${jni.classifier}\" type=\"jar\" />\n-                  </target>\n-                </configuration>\n-              </execution>\n-              <!-- invoke the make file to build a static library -->\n-              <execution>\n-                <id>build-native-lib</id>\n-                <phase>generate-sources</phase>\n-                <goals>\n-                  <goal>run</goal>\n-                </goals>\n-                <configuration>\n-                  <target>\n-                    <exec executable=\"${exe.make}\" failonerror=\"true\" resolveexecutable=\"true\">\n-                      <env key=\"CC\" value=\"${exe.compiler}\" />\n-                      <env key=\"AR\" value=\"${exe.archiver}\" />\n-                      <env key=\"LIB_DIR\" value=\"${nativeLibOnlyDir}\" />\n-                      <env key=\"OBJ_DIR\" value=\"${nativeObjsOnlyDir}\" />\n-                      <env key=\"JNI_PLATFORM\" value=\"${jni.platform}\" />\n-                      <env key=\"CFLAGS\" value=\"-O3 -Werror -Wno-attributes -fPIC -fno-omit-frame-pointer -Wunused-variable -fvisibility=hidden\" />\n-                      <env key=\"LDFLAGS\" value=\"-Wl,--no-as-needed -lrt\" />\n-                      <env key=\"LIB_NAME\" value=\"${nativeLibName}\" />\n-                    </exec>\n-                  </target>\n-                </configuration>\n-              </execution>\n-            </executions>\n-          </plugin>\n-        </plugins>\n-      </build>", "originalCommit": "7d41696b4e7f3f0c2ee64fe9db867e4f0d79db26", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "53724131d644b7eb05696fc6c5cf66964b267b3f", "url": "https://github.com/netty/netty/commit/53724131d644b7eb05696fc6c5cf66964b267b3f", "message": "Ensure we only register native methods once\n\nMotivation:\n\nWe need to ensure we only register native methods once as otherwise we may end up in an \"invalid\" state. The problem here was that before it was basically the responsibility the user of transport-native-unix-common to register the methods. This is error prone as there may be multiple users of these on the classpath at the same time.\n\nModifications:\n\n- Provide a way to init native lib without register the native methods of the provided classes. This is needed to be able to re-use functionality which is exposed to our internal native code\n- Use flatten plugin to correctly resolve classifier and so have the correct dependency\n- Call Unix.* method to ensure we register the methods correctly once\n- Include native lib as well in the native jars of unix-common\n\nResult:\n\nBe able to have multiple artifacts of the classpath that depends on the unix-common. Related to https://github.com/netty/netty-incubator-transport-io_uring/issues/15", "committedDate": "2020-12-17T14:28:27Z", "type": "forcePushed"}, {"oid": "974ff29c94e9dd3fb570db13a23d9bba25ff5984", "url": "https://github.com/netty/netty/commit/974ff29c94e9dd3fb570db13a23d9bba25ff5984", "message": "Ensure we only register native methods once\n\nMotivation:\n\nWe need to ensure we only register native methods once as otherwise we may end up in an \"invalid\" state. The problem here was that before it was basically the responsibility the user of transport-native-unix-common to register the methods. This is error prone as there may be multiple users of these on the classpath at the same time.\n\nModifications:\n\n- Provide a way to init native lib without register the native methods of the provided classes. This is needed to be able to re-use functionality which is exposed to our internal native code\n- Use flatten plugin to correctly resolve classifier and so have the correct dependency\n- Call Unix.* method to ensure we register the methods correctly once\n- Include native lib as well in the native jars of unix-common\n\nResult:\n\nBe able to have multiple artifacts of the classpath that depends on the unix-common. Related to https://github.com/netty/netty-incubator-transport-io_uring/issues/15", "committedDate": "2020-12-18T08:41:01Z", "type": "commit"}, {"oid": "974ff29c94e9dd3fb570db13a23d9bba25ff5984", "url": "https://github.com/netty/netty/commit/974ff29c94e9dd3fb570db13a23d9bba25ff5984", "message": "Ensure we only register native methods once\n\nMotivation:\n\nWe need to ensure we only register native methods once as otherwise we may end up in an \"invalid\" state. The problem here was that before it was basically the responsibility the user of transport-native-unix-common to register the methods. This is error prone as there may be multiple users of these on the classpath at the same time.\n\nModifications:\n\n- Provide a way to init native lib without register the native methods of the provided classes. This is needed to be able to re-use functionality which is exposed to our internal native code\n- Use flatten plugin to correctly resolve classifier and so have the correct dependency\n- Call Unix.* method to ensure we register the methods correctly once\n- Include native lib as well in the native jars of unix-common\n\nResult:\n\nBe able to have multiple artifacts of the classpath that depends on the unix-common. Related to https://github.com/netty/netty-incubator-transport-io_uring/issues/15", "committedDate": "2020-12-18T08:41:01Z", "type": "forcePushed"}]}