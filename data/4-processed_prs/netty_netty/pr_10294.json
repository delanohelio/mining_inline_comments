{"pr_number": 10294, "pr_title": "Guard against re-entrancy issues while draining AbstractCoalescingBuf\u2026", "pr_createdAt": "2020-05-14T09:59:19Z", "pr_url": "https://github.com/netty/netty/pull/10294", "timeline": [{"oid": "462dbb87b3552bfa143c992a305ee122a7aa5f1e", "url": "https://github.com/netty/netty/commit/462dbb87b3552bfa143c992a305ee122a7aa5f1e", "message": "Guard against re-entrancy issues while draining AbstractCoalescingBufferQueue\n\nMotivation:\n\nAbstractCoalescingBufferQueue had a bug which could lead to an empty queue while still report bytes left. This was due the fact that we decremented the pending bytes before draining the queue one-by-one. The problem here is that while the queue is drained we may notify the promise which may add again buffers to the queue for which we never decrement the bytes while we drain these\n\nModifications:\n\n- Decrement the pending bytes every time we drain a buffer from the queue\n- Add unit tests\n\nResult:\n\nFixes https://github.com/netty/netty/issues/10286", "committedDate": "2020-05-14T10:04:43Z", "type": "commit"}, {"oid": "462dbb87b3552bfa143c992a305ee122a7aa5f1e", "url": "https://github.com/netty/netty/commit/462dbb87b3552bfa143c992a305ee122a7aa5f1e", "message": "Guard against re-entrancy issues while draining AbstractCoalescingBufferQueue\n\nMotivation:\n\nAbstractCoalescingBufferQueue had a bug which could lead to an empty queue while still report bytes left. This was due the fact that we decremented the pending bytes before draining the queue one-by-one. The problem here is that while the queue is drained we may notify the promise which may add again buffers to the queue for which we never decrement the bytes while we drain these\n\nModifications:\n\n- Decrement the pending bytes every time we drain a buffer from the queue\n- Add unit tests\n\nResult:\n\nFixes https://github.com/netty/netty/issues/10286", "committedDate": "2020-05-14T10:04:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3Nzk3Mw==", "url": "https://github.com/netty/netty/pull/10294#discussion_r425077973", "bodyText": "If you suppose that\n\"while the queue is drained we may notify the promise which may add again buffers to the queue\", the fix seems not correct enough.\nThrere is raise condition between incrementReadableBytes\nint nextReadableBytes = readableBytes + increment;\n...\nreadableBytes = nextReadableBytes;\n\nand decrementReadableBytes\nreadableBytes -= decrement;\nSeems to me #readableBytes should be AtomicInteger.\nassert readableBytes == 0; // looks cool", "author": "progulin", "createdAt": "2020-05-14T11:52:41Z", "path": "transport/src/main/java/io/netty/channel/AbstractCoalescingBufferQueue.java", "diffHunk": "@@ -221,28 +222,31 @@ public final void copyTo(AbstractCoalescingBufferQueue dest) {\n      * @param ctx The context to write all elements to.\n      */\n     public final void writeAndRemoveAll(ChannelHandlerContext ctx) {\n-        decrementReadableBytes(readableBytes);\n         Throwable pending = null;\n         ByteBuf previousBuf = null;\n         for (;;) {\n             Object entry = bufAndListenerPairs.poll();\n             try {\n                 if (entry == null) {\n                     if (previousBuf != null) {\n+                        decrementReadableBytes(previousBuf.readableBytes());", "originalCommit": "462dbb87b3552bfa143c992a305ee122a7aa5f1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3OTAzMQ==", "url": "https://github.com/netty/netty/pull/10294#discussion_r425079031", "bodyText": "@progulin maybe I am missing something but this is only meant to be used by a single thread. What race you are talking about ?", "author": "normanmaurer", "createdAt": "2020-05-14T11:54:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3Nzk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA4NzMwNQ==", "url": "https://github.com/netty/netty/pull/10294#discussion_r425087305", "bodyText": "I supposed writeAndRemoveAll/releaseAndCompleteAll is one thread and another which does add/addFirst.\nIf single thread is used, there is no sence to duplicate decrementReadableBytes() calls.\nUnpached version set readableBytes to zero decrementReadableBytes(readableBytes); and clear queue into cycle for (;;). The same does patched.", "author": "progulin", "createdAt": "2020-05-14T12:10:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3Nzk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA5MTU3MQ==", "url": "https://github.com/netty/netty/pull/10294#discussion_r425091571", "bodyText": "@progulin yes all is the single threaded... Sorry I have no idea what you are talking about. The problem is the promise may be notified and so the ChannelFutureListener may call add(...) while we are in the for loop. All of this is in the same thread. Just run the unit test with the unpatched version and you will see it fails.", "author": "normanmaurer", "createdAt": "2020-05-14T12:18:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3Nzk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA5NzY5MA==", "url": "https://github.com/netty/netty/pull/10294#discussion_r425097690", "bodyText": "ChannelFutureListener may call add(...)\n\nUgu! Now I see. Thank you. Great patch.", "author": "progulin", "createdAt": "2020-05-14T12:29:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTA3Nzk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIzOTA4OQ==", "url": "https://github.com/netty/netty/pull/10294#discussion_r425239089", "bodyText": "consider just doing buffer.release() now that you have the cast, this code is in a try/catch and will ensure all elements are drained.", "author": "Scottmitch", "createdAt": "2020-05-14T15:44:55Z", "path": "transport/src/main/java/io/netty/channel/AbstractCoalescingBufferQueue.java", "diffHunk": "@@ -335,7 +338,9 @@ private void releaseAndCompleteAll(ChannelFuture future) {\n             }\n             try {\n                 if (entry instanceof ByteBuf) {\n-                    safeRelease(entry);\n+                    ByteBuf buffer = (ByteBuf) entry;\n+                    decrementReadableBytes(buffer.readableBytes());\n+                    safeRelease(buffer);", "originalCommit": "462dbb87b3552bfa143c992a305ee122a7aa5f1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTYxMTY1OQ==", "url": "https://github.com/netty/netty/pull/10294#discussion_r425611659", "bodyText": "let's just keep it as it is for now to keep the changes to a minimum", "author": "normanmaurer", "createdAt": "2020-05-15T07:18:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTIzOTA4OQ=="}], "type": "inlineReview"}]}