{"pr_number": 10498, "pr_title": "[Feature] PcapWriteHandler Support", "pr_createdAt": "2020-08-24T08:08:39Z", "pr_url": "https://github.com/netty/netty/pull/10498", "timeline": [{"oid": "462bd27304c1aa56e72ce85188047f4f3ffcfbd5", "url": "https://github.com/netty/netty/commit/462bd27304c1aa56e72ce85188047f4f3ffcfbd5", "message": "Pcap Writer", "committedDate": "2020-08-24T08:06:38Z", "type": "commit"}, {"oid": "692ab3683167003e9660db6150e2f5a2c85cb603", "url": "https://github.com/netty/netty/commit/692ab3683167003e9660db6150e2f5a2c85cb603", "message": "Fix srcAddr and dstAddr", "committedDate": "2020-08-24T08:12:51Z", "type": "commit"}, {"oid": "55b652803517ac9bb2fea5eff85a5ff34af59dd7", "url": "https://github.com/netty/netty/commit/55b652803517ac9bb2fea5eff85a5ff34af59dd7", "message": "Add license headers", "committedDate": "2020-08-24T08:17:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMTAyOQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475521029", "bodyText": "nit:  I think the method name is a bit misleading as we not really create a packet but we write it to the given ByteBuf. So consider to rename the method and use void as the return method to make it clear it not creates a new ByteBuf.\nSame comment is true for all the other places in the code with the same pattern", "author": "normanmaurer", "createdAt": "2020-08-24T11:02:03Z", "path": "handler/src/main/java/io/netty/handler/pcap/packet/UDPPacket.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap.packet;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+public final class UDPPacket {\n+\n+    /**\n+     * Create UDP Packet\n+     *\n+     * @param byteBuf ByteBuf where Packet data will be set\n+     * @param payload Payload of this Packet\n+     * @param srcPort Source Port\n+     * @param dstPort Destination Port\n+     */\n+    public static ByteBuf createPacket(ByteBuf byteBuf, ByteBuf payload, int srcPort, int dstPort) {", "originalCommit": "55b652803517ac9bb2fea5eff85a5ff34af59dd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUzNjgxMQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475536811", "bodyText": "Done", "author": "hyperxpro", "createdAt": "2020-08-24T11:34:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMTAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMTE1Mg==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475521152", "bodyText": "this should be package-private and should have a private constructor", "author": "normanmaurer", "createdAt": "2020-08-24T11:02:20Z", "path": "handler/src/main/java/io/netty/handler/pcap/packet/UDPPacket.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap.packet;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+public final class UDPPacket {", "originalCommit": "55b652803517ac9bb2fea5eff85a5ff34af59dd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMTE4Nw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475521187", "bodyText": "this should be package-private and should have a private constructor", "author": "normanmaurer", "createdAt": "2020-08-24T11:02:25Z", "path": "handler/src/main/java/io/netty/handler/pcap/packet/TCPPacket.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap.packet;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+public final class TCPPacket {", "originalCommit": "55b652803517ac9bb2fea5eff85a5ff34af59dd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMTM0OA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475521348", "bodyText": "same comment as for UDPPacket.createPacket", "author": "normanmaurer", "createdAt": "2020-08-24T11:02:48Z", "path": "handler/src/main/java/io/netty/handler/pcap/packet/TCPPacket.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap.packet;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+public final class TCPPacket {\n+    /**\n+     * Create TCP Packet\n+     *\n+     * @param byteBuf ByteBuf where Packet data will be set\n+     * @param payload Payload of this Packet\n+     * @param srcPort Source Port\n+     * @param dstPort Destination Port\n+     */\n+    public static ByteBuf createPacket(ByteBuf byteBuf, ByteBuf payload, int srcPort, int dstPort) {", "originalCommit": "55b652803517ac9bb2fea5eff85a5ff34af59dd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMTQwNQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475521405", "bodyText": "same comment as for UDPPacket.createPacket", "author": "normanmaurer", "createdAt": "2020-08-24T11:02:53Z", "path": "handler/src/main/java/io/netty/handler/pcap/packet/IPPacket.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap.packet;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+public final class IPPacket {\n+\n+    /**\n+     * Create IPv4 Packet for UDP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of UDP\n+     * @param srcAddress Source IPv4 Address\n+     * @param dstAddress Destination IPv4 Address\n+     */\n+    public static ByteBuf createUDPv4(ByteBuf byteBuf, ByteBuf payload, int srcAddress, int dstAddress) {\n+        return createPacketV4(byteBuf, payload, 17, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Create IPv6 Packet for UDP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of UDP\n+     * @param srcAddress Source IPv6 Address\n+     * @param dstAddress Destination IPv6 Address\n+     */\n+    public static ByteBuf createUDPv6(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress) {\n+        return createPacketV6(byteBuf, payload, 17, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Create IPv4 Packet for TCP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of TCP\n+     * @param srcAddress Source IPv4 Address\n+     * @param dstAddress Destination IPv4 Address\n+     */\n+    public static ByteBuf createTCP4(ByteBuf byteBuf, ByteBuf payload, int srcAddress, int dstAddress) {\n+        return createPacketV4(byteBuf, payload, 6, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Create IPv6 Packet for TCP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of TCP\n+     * @param srcAddress Source IPv6 Address\n+     * @param dstAddress Destination IPv6 Address\n+     */\n+    public static ByteBuf createTCP6(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress) {\n+        return createPacketV6(byteBuf, payload, 6, srcAddress, dstAddress);\n+    }\n+\n+    private static ByteBuf createPacketV4(ByteBuf byteBuf, ByteBuf payload, int protocol, int srcAddress,\n+                                          int dstAddress) {\n+        byteBuf.writeByte(0x45);      //  Version + IHL\n+        byteBuf.writeByte(0x00);      //  DSCP\n+        byteBuf.writeShort(payload.readableBytes() + 20); // Length\n+        byteBuf.writeShort(0x0000);   // Identification\n+        byteBuf.writeShort(0x0000);   // Fragment\n+        byteBuf.writeByte(0xff);      // TTL\n+        byteBuf.writeByte(protocol);  // Protocol\n+        byteBuf.writeShort(0);        // Checksum\n+        byteBuf.writeInt(srcAddress); // Source IPv4 Address\n+        byteBuf.writeInt(dstAddress); // Destination IPv4 Address\n+        byteBuf.writeBytes(payload);  // Payload of L4\n+        return byteBuf;\n+    }\n+\n+    private static ByteBuf createPacketV6(ByteBuf byteBuf, ByteBuf payload, int protocol, byte[] srcAddress,", "originalCommit": "55b652803517ac9bb2fea5eff85a5ff34af59dd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMTQzNQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475521435", "bodyText": "same comment as for UDPPacket.createPacket", "author": "normanmaurer", "createdAt": "2020-08-24T11:02:58Z", "path": "handler/src/main/java/io/netty/handler/pcap/packet/IPPacket.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap.packet;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+public final class IPPacket {\n+\n+    /**\n+     * Create IPv4 Packet for UDP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of UDP\n+     * @param srcAddress Source IPv4 Address\n+     * @param dstAddress Destination IPv4 Address\n+     */\n+    public static ByteBuf createUDPv4(ByteBuf byteBuf, ByteBuf payload, int srcAddress, int dstAddress) {\n+        return createPacketV4(byteBuf, payload, 17, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Create IPv6 Packet for UDP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of UDP\n+     * @param srcAddress Source IPv6 Address\n+     * @param dstAddress Destination IPv6 Address\n+     */\n+    public static ByteBuf createUDPv6(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress) {\n+        return createPacketV6(byteBuf, payload, 17, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Create IPv4 Packet for TCP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of TCP\n+     * @param srcAddress Source IPv4 Address\n+     * @param dstAddress Destination IPv4 Address\n+     */\n+    public static ByteBuf createTCP4(ByteBuf byteBuf, ByteBuf payload, int srcAddress, int dstAddress) {\n+        return createPacketV4(byteBuf, payload, 6, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Create IPv6 Packet for TCP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of TCP\n+     * @param srcAddress Source IPv6 Address\n+     * @param dstAddress Destination IPv6 Address\n+     */\n+    public static ByteBuf createTCP6(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress) {\n+        return createPacketV6(byteBuf, payload, 6, srcAddress, dstAddress);\n+    }\n+\n+    private static ByteBuf createPacketV4(ByteBuf byteBuf, ByteBuf payload, int protocol, int srcAddress,", "originalCommit": "55b652803517ac9bb2fea5eff85a5ff34af59dd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMTQ1Nw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475521457", "bodyText": "same comment as for UDPPacket.createPacket", "author": "normanmaurer", "createdAt": "2020-08-24T11:03:01Z", "path": "handler/src/main/java/io/netty/handler/pcap/packet/IPPacket.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap.packet;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+public final class IPPacket {\n+\n+    /**\n+     * Create IPv4 Packet for UDP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of UDP\n+     * @param srcAddress Source IPv4 Address\n+     * @param dstAddress Destination IPv4 Address\n+     */\n+    public static ByteBuf createUDPv4(ByteBuf byteBuf, ByteBuf payload, int srcAddress, int dstAddress) {\n+        return createPacketV4(byteBuf, payload, 17, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Create IPv6 Packet for UDP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of UDP\n+     * @param srcAddress Source IPv6 Address\n+     * @param dstAddress Destination IPv6 Address\n+     */\n+    public static ByteBuf createUDPv6(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress) {\n+        return createPacketV6(byteBuf, payload, 17, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Create IPv4 Packet for TCP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of TCP\n+     * @param srcAddress Source IPv4 Address\n+     * @param dstAddress Destination IPv4 Address\n+     */\n+    public static ByteBuf createTCP4(ByteBuf byteBuf, ByteBuf payload, int srcAddress, int dstAddress) {\n+        return createPacketV4(byteBuf, payload, 6, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Create IPv6 Packet for TCP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of TCP\n+     * @param srcAddress Source IPv6 Address\n+     * @param dstAddress Destination IPv6 Address\n+     */\n+    public static ByteBuf createTCP6(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress) {", "originalCommit": "55b652803517ac9bb2fea5eff85a5ff34af59dd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMTQ4MA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475521480", "bodyText": "same comment as for UDPPacket.createPacket", "author": "normanmaurer", "createdAt": "2020-08-24T11:03:04Z", "path": "handler/src/main/java/io/netty/handler/pcap/packet/IPPacket.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap.packet;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+public final class IPPacket {\n+\n+    /**\n+     * Create IPv4 Packet for UDP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of UDP\n+     * @param srcAddress Source IPv4 Address\n+     * @param dstAddress Destination IPv4 Address\n+     */\n+    public static ByteBuf createUDPv4(ByteBuf byteBuf, ByteBuf payload, int srcAddress, int dstAddress) {\n+        return createPacketV4(byteBuf, payload, 17, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Create IPv6 Packet for UDP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of UDP\n+     * @param srcAddress Source IPv6 Address\n+     * @param dstAddress Destination IPv6 Address\n+     */\n+    public static ByteBuf createUDPv6(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress) {\n+        return createPacketV6(byteBuf, payload, 17, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Create IPv4 Packet for TCP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of TCP\n+     * @param srcAddress Source IPv4 Address\n+     * @param dstAddress Destination IPv4 Address\n+     */\n+    public static ByteBuf createTCP4(ByteBuf byteBuf, ByteBuf payload, int srcAddress, int dstAddress) {", "originalCommit": "55b652803517ac9bb2fea5eff85a5ff34af59dd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMTQ5OQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475521499", "bodyText": "same comment as for UDPPacket.createPacket", "author": "normanmaurer", "createdAt": "2020-08-24T11:03:06Z", "path": "handler/src/main/java/io/netty/handler/pcap/packet/IPPacket.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap.packet;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+public final class IPPacket {\n+\n+    /**\n+     * Create IPv4 Packet for UDP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of UDP\n+     * @param srcAddress Source IPv4 Address\n+     * @param dstAddress Destination IPv4 Address\n+     */\n+    public static ByteBuf createUDPv4(ByteBuf byteBuf, ByteBuf payload, int srcAddress, int dstAddress) {\n+        return createPacketV4(byteBuf, payload, 17, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Create IPv6 Packet for UDP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of UDP\n+     * @param srcAddress Source IPv6 Address\n+     * @param dstAddress Destination IPv6 Address\n+     */\n+    public static ByteBuf createUDPv6(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress) {", "originalCommit": "55b652803517ac9bb2fea5eff85a5ff34af59dd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMTUyMQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475521521", "bodyText": "same comment as for UDPPacket.createPacket", "author": "normanmaurer", "createdAt": "2020-08-24T11:03:09Z", "path": "handler/src/main/java/io/netty/handler/pcap/packet/IPPacket.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap.packet;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+public final class IPPacket {\n+\n+    /**\n+     * Create IPv4 Packet for UDP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of UDP\n+     * @param srcAddress Source IPv4 Address\n+     * @param dstAddress Destination IPv4 Address\n+     */\n+    public static ByteBuf createUDPv4(ByteBuf byteBuf, ByteBuf payload, int srcAddress, int dstAddress) {", "originalCommit": "55b652803517ac9bb2fea5eff85a5ff34af59dd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMTYzOQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475521639", "bodyText": "package-private and private constructor", "author": "normanmaurer", "createdAt": "2020-08-24T11:03:26Z", "path": "handler/src/main/java/io/netty/handler/pcap/packet/IPPacket.java", "diffHunk": "@@ -0,0 +1,97 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap.packet;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+public final class IPPacket {", "originalCommit": "55b652803517ac9bb2fea5eff85a5ff34af59dd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMTY4Nw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475521687", "bodyText": "same comment as for UDPPacket.createPacket", "author": "normanmaurer", "createdAt": "2020-08-24T11:03:30Z", "path": "handler/src/main/java/io/netty/handler/pcap/packet/EthernetPacket.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap.packet;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+public final class EthernetPacket {\n+\n+    public static final byte[] DUMMY_ADDRESS = new byte[]{-86, -69, -52, -35, -18, -1};\n+\n+    /**\n+     * Create IPv4 Ethernet Packet\n+     *\n+     * @param byteBuf    ByteBuf where Ethernet Packet data will be set\n+     * @param payload    Payload of IPv4\n+     * @param srcAddress Source MAC Address\n+     * @param dstAddress Destination MAC Address\n+     */\n+    public static ByteBuf createIPv4(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress) {\n+        return EthernetPacket.createPacket(byteBuf, payload, srcAddress, dstAddress, 0x0800);\n+    }\n+\n+    /**\n+     * Create IPv6 Ethernet Packet\n+     *\n+     * @param byteBuf    ByteBuf where Ethernet Packet data will be set\n+     * @param payload    Payload of IPv6\n+     * @param srcAddress Source MAC Address\n+     * @param dstAddress Destination MAC Address\n+     */\n+    public static ByteBuf createIPv6(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress) {\n+        return EthernetPacket.createPacket(byteBuf, payload, srcAddress, dstAddress, 0x86dd);\n+    }\n+\n+    private static ByteBuf createPacket(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress,", "originalCommit": "55b652803517ac9bb2fea5eff85a5ff34af59dd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMTcxNg==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475521716", "bodyText": "same comment as for UDPPacket.createPacket", "author": "normanmaurer", "createdAt": "2020-08-24T11:03:32Z", "path": "handler/src/main/java/io/netty/handler/pcap/packet/EthernetPacket.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap.packet;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+public final class EthernetPacket {\n+\n+    public static final byte[] DUMMY_ADDRESS = new byte[]{-86, -69, -52, -35, -18, -1};\n+\n+    /**\n+     * Create IPv4 Ethernet Packet\n+     *\n+     * @param byteBuf    ByteBuf where Ethernet Packet data will be set\n+     * @param payload    Payload of IPv4\n+     * @param srcAddress Source MAC Address\n+     * @param dstAddress Destination MAC Address\n+     */\n+    public static ByteBuf createIPv4(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress) {\n+        return EthernetPacket.createPacket(byteBuf, payload, srcAddress, dstAddress, 0x0800);\n+    }\n+\n+    /**\n+     * Create IPv6 Ethernet Packet\n+     *\n+     * @param byteBuf    ByteBuf where Ethernet Packet data will be set\n+     * @param payload    Payload of IPv6\n+     * @param srcAddress Source MAC Address\n+     * @param dstAddress Destination MAC Address\n+     */\n+    public static ByteBuf createIPv6(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress) {", "originalCommit": "55b652803517ac9bb2fea5eff85a5ff34af59dd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMTc1Mw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475521753", "bodyText": "same comment as for UDPPacket.createPacket", "author": "normanmaurer", "createdAt": "2020-08-24T11:03:36Z", "path": "handler/src/main/java/io/netty/handler/pcap/packet/EthernetPacket.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap.packet;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+public final class EthernetPacket {\n+\n+    public static final byte[] DUMMY_ADDRESS = new byte[]{-86, -69, -52, -35, -18, -1};\n+\n+    /**\n+     * Create IPv4 Ethernet Packet\n+     *\n+     * @param byteBuf    ByteBuf where Ethernet Packet data will be set\n+     * @param payload    Payload of IPv4\n+     * @param srcAddress Source MAC Address\n+     * @param dstAddress Destination MAC Address\n+     */\n+    public static ByteBuf createIPv4(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress) {", "originalCommit": "55b652803517ac9bb2fea5eff85a5ff34af59dd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMTg4NQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475521885", "bodyText": "This is \"dangerous\" as it is modifiable", "author": "normanmaurer", "createdAt": "2020-08-24T11:03:55Z", "path": "handler/src/main/java/io/netty/handler/pcap/packet/EthernetPacket.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap.packet;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+public final class EthernetPacket {\n+\n+    public static final byte[] DUMMY_ADDRESS = new byte[]{-86, -69, -52, -35, -18, -1};", "originalCommit": "55b652803517ac9bb2fea5eff85a5ff34af59dd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMTk3Nw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475521977", "bodyText": "package private and private constructor", "author": "normanmaurer", "createdAt": "2020-08-24T11:04:05Z", "path": "handler/src/main/java/io/netty/handler/pcap/packet/EthernetPacket.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap.packet;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+public final class EthernetPacket {", "originalCommit": "55b652803517ac9bb2fea5eff85a5ff34af59dd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMjI4OA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475522288", "bodyText": "no need to copy() use duplicate()", "author": "normanmaurer", "createdAt": "2020-08-24T11:04:45Z", "path": "handler/src/main/java/io/netty/handler/pcap/WritePCAPHandler.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.pcap.packet.EthernetPacket;\n+import io.netty.handler.pcap.packet.IPPacket;\n+import io.netty.handler.pcap.packet.TCPPacket;\n+import io.netty.handler.pcap.packet.UDPPacket;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public final class WritePCAPHandler extends ChannelDuplexHandler {\n+\n+    private final Protocol protocol;\n+    private final PCapFileWriter pCapFileWriter;\n+\n+    public WritePCAPHandler(Protocol protocol, String destinationFile) throws IOException {\n+        this(protocol, new File(destinationFile));\n+    }\n+\n+    public WritePCAPHandler(Protocol protocol, File destinationFile) throws IOException {\n+        this.protocol = protocol;\n+        this.pCapFileWriter = new PCapFileWriter(destinationFile);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        writePacket(ctx, msg, false);\n+        super.channelRead(ctx, msg);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        writePacket(ctx, msg, true);\n+        super.write(ctx, msg, promise);\n+    }\n+\n+    private void writePacket(ChannelHandlerContext ctx, Object msg, boolean isWrite) throws IOException {\n+        if (msg instanceof ByteBuf) {\n+            // Copy the ByteBuf\n+            ByteBuf packet = ((ByteBuf) msg).copy();", "originalCommit": "55b652803517ac9bb2fea5eff85a5ff34af59dd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMjc4Mw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475522783", "bodyText": "same comment as for UDPPacket.createPacket", "author": "normanmaurer", "createdAt": "2020-08-24T11:05:40Z", "path": "handler/src/main/java/io/netty/handler/pcap/PcapHeaders.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+public final class PcapHeaders {\n+\n+    /**\n+     * Generate Pcap Global Header\n+     * @param byteBuf byteBuf ByteBuf where we'll write header data\n+     */\n+    public static ByteBuf generateGlobalHeader(ByteBuf byteBuf) {", "originalCommit": "55b652803517ac9bb2fea5eff85a5ff34af59dd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMjgzMg==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475522832", "bodyText": "same comment as for UDPPacket.createPacket", "author": "normanmaurer", "createdAt": "2020-08-24T11:05:47Z", "path": "handler/src/main/java/io/netty/handler/pcap/PcapHeaders.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+public final class PcapHeaders {\n+\n+    /**\n+     * Generate Pcap Global Header\n+     * @param byteBuf byteBuf ByteBuf where we'll write header data\n+     */\n+    public static ByteBuf generateGlobalHeader(ByteBuf byteBuf) {\n+        byteBuf.writeInt(0xa1b2c3d4); // magic_number\n+        byteBuf.writeShort(2);        // version_major\n+        byteBuf.writeShort(4);        // version_minor\n+        byteBuf.writeInt(0);          // thiszone\n+        byteBuf.writeInt(0);          // sigfigs\n+        byteBuf.writeInt(0xffff);     // snaplen\n+        byteBuf.writeInt(1);          // network\n+        return byteBuf;\n+    }\n+\n+    /**\n+     * Generate Pcap Packet Header\n+     *\n+     * @param byteBuf ByteBuf where we'll write header data\n+     * @param ts_sec   timestamp seconds\n+     * @param ts_usec  timestamp microseconds\n+     * @param incl_len number of octets of packet saved in file\n+     * @param orig_len actual length of packet\n+     */\n+    public static ByteBuf generatePacketHeader(ByteBuf byteBuf, int ts_sec, int ts_usec, int incl_len, int orig_len) {", "originalCommit": "55b652803517ac9bb2fea5eff85a5ff34af59dd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMjk2Mg==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475522962", "bodyText": "should be package-private and private constructor", "author": "normanmaurer", "createdAt": "2020-08-24T11:06:05Z", "path": "handler/src/main/java/io/netty/handler/pcap/PcapHeaders.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+public final class PcapHeaders {", "originalCommit": "55b652803517ac9bb2fea5eff85a5ff34af59dd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTUyMzA4NA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475523084", "bodyText": "private private ?", "author": "normanmaurer", "createdAt": "2020-08-24T11:06:23Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCapFileWriter.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+public final class PCapFileWriter implements Closeable {", "originalCommit": "55b652803517ac9bb2fea5eff85a5ff34af59dd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3b0b4104d870d434db4701bfc5c0bcead9c97c72", "url": "https://github.com/netty/netty/commit/3b0b4104d870d434db4701bfc5c0bcead9c97c72", "message": "code improvements", "committedDate": "2020-08-24T11:30:39Z", "type": "commit"}, {"oid": "27613b726c039d42eb9ec6c549605ea3e8128963", "url": "https://github.com/netty/netty/commit/27613b726c039d42eb9ec6c549605ea3e8128963", "message": "Fix EthernetPacket IPv4 and IPv6 bug", "committedDate": "2020-08-24T12:38:49Z", "type": "commit"}, {"oid": "d97371572828fe435d2f796feebef161de8be9a4", "url": "https://github.com/netty/netty/commit/d97371572828fe435d2f796feebef161de8be9a4", "message": "Handle TCP and UDP traffic in seperate methods", "committedDate": "2020-08-24T12:43:12Z", "type": "commit"}, {"oid": "b208aa91d1b1e02f5fe3b75482f7d3482286688b", "url": "https://github.com/netty/netty/commit/b208aa91d1b1e02f5fe3b75482f7d3482286688b", "message": "some improvements", "committedDate": "2020-08-24T13:00:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU3NzgzMw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475577833", "bodyText": "nit: I would rename all of these methods to write* as this is what these do at the end.", "author": "normanmaurer", "createdAt": "2020-08-24T12:53:58Z", "path": "handler/src/main/java/io/netty/handler/pcap/EthernetPacket.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class EthernetPacket {\n+\n+    private static final byte[] DUMMY_ADDRESS = new byte[]{-86, -69, -52, -35, -18, -1};\n+\n+    private EthernetPacket() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Create IPv4 Ethernet Packet. It uses a dummy MAC address for both source and destination.\n+     *\n+     * @param byteBuf    ByteBuf where Ethernet Packet data will be set\n+     * @param payload    Payload of IPv4\n+     */\n+    static void createIPv4(ByteBuf byteBuf, ByteBuf payload) {", "originalCommit": "d97371572828fe435d2f796feebef161de8be9a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU3OTU2OA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475579568", "bodyText": "missing byteBuf.release() after usage.", "author": "normanmaurer", "createdAt": "2020-08-24T12:55:16Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCapFileWriter.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+final class PCapFileWriter implements Closeable {\n+    private final long myStartTime = System.nanoTime();\n+    private final FileOutputStream fileOutputStream;\n+\n+    PCapFileWriter(File file) throws IOException {\n+        fileOutputStream = new FileOutputStream(file);\n+\n+        ByteBuf byteBuf = Unpooled.buffer();\n+        PcapHeaders.generateGlobalHeader(byteBuf);\n+        fileOutputStream.write(ByteBufUtil.getBytes(byteBuf));", "originalCommit": "d97371572828fe435d2f796feebef161de8be9a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU3OTgwMw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475579803", "bodyText": "use byteBuf.readBytes(fileOutputStream)", "author": "normanmaurer", "createdAt": "2020-08-24T12:55:40Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCapFileWriter.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+final class PCapFileWriter implements Closeable {\n+    private final long myStartTime = System.nanoTime();\n+    private final FileOutputStream fileOutputStream;\n+\n+    PCapFileWriter(File file) throws IOException {\n+        fileOutputStream = new FileOutputStream(file);\n+\n+        ByteBuf byteBuf = Unpooled.buffer();\n+        PcapHeaders.generateGlobalHeader(byteBuf);\n+        fileOutputStream.write(ByteBufUtil.getBytes(byteBuf));", "originalCommit": "d97371572828fe435d2f796feebef161de8be9a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU4MDYxNA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475580614", "bodyText": "why even depend on the file here and not change the constructor to use ...(OutputStream out) ? Also when doing so rename the the class to PCapWriter", "author": "normanmaurer", "createdAt": "2020-08-24T12:57:04Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCapFileWriter.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+final class PCapFileWriter implements Closeable {\n+    private final long myStartTime = System.nanoTime();\n+    private final FileOutputStream fileOutputStream;\n+\n+    PCapFileWriter(File file) throws IOException {\n+        fileOutputStream = new FileOutputStream(file);", "originalCommit": "d97371572828fe435d2f796feebef161de8be9a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU4MTM0MA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475581340", "bodyText": "again use byteBuf.readBytes(fileOutputStream) and packet.readBytes(fileOutputStream);", "author": "normanmaurer", "createdAt": "2020-08-24T12:58:15Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCapFileWriter.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+\n+final class PCapFileWriter implements Closeable {\n+    private final long myStartTime = System.nanoTime();\n+    private final FileOutputStream fileOutputStream;\n+\n+    PCapFileWriter(File file) throws IOException {\n+        fileOutputStream = new FileOutputStream(file);\n+\n+        ByteBuf byteBuf = Unpooled.buffer();\n+        PcapHeaders.generateGlobalHeader(byteBuf);\n+        fileOutputStream.write(ByteBufUtil.getBytes(byteBuf));\n+    }\n+\n+    void writePacket(ByteBuf byteBuf, ByteBuf packet) throws IOException {\n+        long difference = System.nanoTime() - myStartTime;\n+\n+        PcapHeaders.generatePacketHeader(\n+                byteBuf,\n+                (int) (difference / 1000000000),\n+                (int) difference / 1000000,\n+                packet.readableBytes(),\n+                packet.readableBytes()\n+        );\n+\n+        fileOutputStream.write(ByteBufUtil.getBytes(byteBuf));\n+        fileOutputStream.write(ByteBufUtil.getBytes(packet));", "originalCommit": "d97371572828fe435d2f796feebef161de8be9a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU4MjM4OQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475582389", "bodyText": "nit: I wonder if you also want to handle DatagramPacket for protocol == Protocol.UDP ?", "author": "normanmaurer", "createdAt": "2020-08-24T13:00:01Z", "path": "handler/src/main/java/io/netty/handler/pcap/WritePCAPHandler.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public final class WritePCAPHandler extends ChannelDuplexHandler {\n+\n+    private final Protocol protocol;\n+    private final PCapFileWriter pCapFileWriter;\n+\n+    public WritePCAPHandler(Protocol protocol, String destinationFile) throws IOException {\n+        this(protocol, new File(destinationFile));\n+    }\n+\n+    public WritePCAPHandler(Protocol protocol, File destinationFile) throws IOException {\n+        this.protocol = protocol;\n+        this.pCapFileWriter = new PCapFileWriter(destinationFile);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        writePacket(ctx, msg, false);\n+        super.channelRead(ctx, msg);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        writePacket(ctx, msg, true);\n+        super.write(ctx, msg, promise);\n+    }\n+\n+    private void writePacket(ChannelHandlerContext ctx, Object msg, boolean isWrite) throws IOException {\n+        if (msg instanceof ByteBuf) {\n+            // Duplicate the ByteBuf\n+            ByteBuf packet = ((ByteBuf) msg).duplicate();\n+\n+            InetSocketAddress srcAddr;\n+            InetSocketAddress dstAddr;\n+            /*\n+             * When `isWrite` it true, it means we're sending data from Netty to somewhere else.\n+             * In this case, source address will be `localAddress` and destination address will\n+             * be `remoteAddress`.\n+             *\n+             * When `isWrite` is false, it means we're reading data from somewhere else in Netty.\n+             * In this case, source address will be `remoteAddress` and destination address will\n+             * be `localAddress`.\n+             */\n+            if (isWrite) {\n+                srcAddr = (InetSocketAddress) ctx.channel().localAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+            } else {\n+                srcAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().localAddress();\n+            }\n+\n+            if (protocol == Protocol.TCP) {\n+                handleTCP(ctx, srcAddr, dstAddr, packet);\n+            } else {\n+                handleUDP(ctx, srcAddr, dstAddr, packet);\n+            }\n+        }", "originalCommit": "d97371572828fe435d2f796feebef161de8be9a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTU4Mjg3MQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r475582871", "bodyText": "better would be to do this in handlerRemoved(....)", "author": "normanmaurer", "createdAt": "2020-08-24T13:00:48Z", "path": "handler/src/main/java/io/netty/handler/pcap/WritePCAPHandler.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public final class WritePCAPHandler extends ChannelDuplexHandler {\n+\n+    private final Protocol protocol;\n+    private final PCapFileWriter pCapFileWriter;\n+\n+    public WritePCAPHandler(Protocol protocol, String destinationFile) throws IOException {\n+        this(protocol, new File(destinationFile));\n+    }\n+\n+    public WritePCAPHandler(Protocol protocol, File destinationFile) throws IOException {\n+        this.protocol = protocol;\n+        this.pCapFileWriter = new PCapFileWriter(destinationFile);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        writePacket(ctx, msg, false);\n+        super.channelRead(ctx, msg);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        writePacket(ctx, msg, true);\n+        super.write(ctx, msg, promise);\n+    }\n+\n+    private void writePacket(ChannelHandlerContext ctx, Object msg, boolean isWrite) throws IOException {\n+        if (msg instanceof ByteBuf) {\n+            // Duplicate the ByteBuf\n+            ByteBuf packet = ((ByteBuf) msg).duplicate();\n+\n+            InetSocketAddress srcAddr;\n+            InetSocketAddress dstAddr;\n+            /*\n+             * When `isWrite` it true, it means we're sending data from Netty to somewhere else.\n+             * In this case, source address will be `localAddress` and destination address will\n+             * be `remoteAddress`.\n+             *\n+             * When `isWrite` is false, it means we're reading data from somewhere else in Netty.\n+             * In this case, source address will be `remoteAddress` and destination address will\n+             * be `localAddress`.\n+             */\n+            if (isWrite) {\n+                srcAddr = (InetSocketAddress) ctx.channel().localAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+            } else {\n+                srcAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().localAddress();\n+            }\n+\n+            if (protocol == Protocol.TCP) {\n+                handleTCP(ctx, srcAddr, dstAddr, packet);\n+            } else {\n+                handleUDP(ctx, srcAddr, dstAddr, packet);\n+            }\n+        }\n+    }\n+\n+    private void handleTCP(ChannelHandlerContext ctx, InetSocketAddress srcAddr, InetSocketAddress dstAddr,\n+                           ByteBuf packet) throws IOException {\n+        ByteBuf tcpBuf = ctx.alloc().buffer();\n+        TCPPacket.createPacket(tcpBuf, packet, dstAddr.getPort(), srcAddr.getPort());\n+\n+        ByteBuf ipBuf = ctx.alloc().buffer();\n+        if (dstAddr.getAddress() instanceof Inet4Address) {\n+            IPPacket.createTCPv4(ipBuf,\n+                    tcpBuf,\n+                    ipv4ToInt(srcAddr.getAddress()),\n+                    ipv4ToInt(dstAddr.getAddress()));\n+\n+            ByteBuf ethernetBuf = ctx.alloc().buffer();\n+            EthernetPacket.createIPv4(ethernetBuf, ipBuf);\n+            pCapFileWriter.writePacket(ctx.alloc().buffer(), ethernetBuf);\n+        } else {\n+            IPPacket.createTCPv6(ipBuf,\n+                    tcpBuf,\n+                    srcAddr.getAddress().getAddress(),\n+                    dstAddr.getAddress().getAddress());\n+\n+            ByteBuf ethernetBuf = ctx.alloc().buffer();\n+            EthernetPacket.createIPv6(ethernetBuf, ipBuf);\n+            pCapFileWriter.writePacket(ctx.alloc().buffer(), ethernetBuf);\n+        }\n+    }\n+\n+    private void handleUDP(ChannelHandlerContext ctx, InetSocketAddress srcAddr, InetSocketAddress dstAddr,\n+                           ByteBuf packet) throws IOException {\n+        ByteBuf udpBuf = ctx.alloc().buffer();\n+        UDPPacket.createPacket(udpBuf,\n+                packet,\n+                dstAddr.getPort(),\n+                srcAddr.getPort());\n+\n+        ByteBuf ipBuf = ctx.alloc().buffer();\n+        if (dstAddr.getAddress() instanceof Inet4Address) {\n+            IPPacket.createUDPv4(ipBuf,\n+                    udpBuf,\n+                    ipv4ToInt(srcAddr.getAddress()),\n+                    ipv4ToInt(dstAddr.getAddress()));\n+\n+            ByteBuf ethernetBuf = ctx.alloc().buffer();\n+            EthernetPacket.createIPv4(ethernetBuf, ipBuf);\n+            pCapFileWriter.writePacket(ctx.alloc().buffer(), ethernetBuf);\n+        } else {\n+            IPPacket.createUDPv6(ipBuf,\n+                    udpBuf,\n+                    srcAddr.getAddress().getAddress(),\n+                    dstAddr.getAddress().getAddress());\n+\n+            ByteBuf ethernetBuf = ctx.alloc().buffer();\n+            EthernetPacket.createIPv6(ethernetBuf, ipBuf);\n+            pCapFileWriter.writePacket(ctx.alloc().buffer(), ethernetBuf);\n+        }\n+    }\n+\n+    @Override\n+    public void close(ChannelHandlerContext ctx, ChannelPromise promise) throws Exception {\n+        this.pCapFileWriter.close();", "originalCommit": "d97371572828fe435d2f796feebef161de8be9a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d6d078e9c9aa70aad009d645cde80e43e3cf3e1e", "url": "https://github.com/netty/netty/commit/d6d078e9c9aa70aad009d645cde80e43e3cf3e1e", "message": "some more fixes and added UDPv4 test case", "committedDate": "2020-08-24T17:36:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ2MDk5MQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r477460991", "bodyText": "wouldn't it be better to use byteBuf.readableBytes() ?", "author": "normanmaurer", "createdAt": "2020-08-26T17:16:20Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCapWriter.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+final class PCapWriter implements Closeable {\n+    private final long myStartTime = System.nanoTime();\n+    private final OutputStream outputStream;\n+\n+    /**\n+     * This uses {@link OutputStream} for writing Pcap.\n+     * Pcap Global Header is also written on construction.\n+     *\n+     * @throws IOException If {@link OutputStream#write(byte[])} throws an exception\n+     */\n+    PCapWriter(OutputStream outputStream) throws IOException {\n+        this.outputStream = outputStream;\n+\n+        ByteBuf byteBuf = Unpooled.buffer();\n+        io.netty.handler.codec.pcap.PcapHeaders.writeGlobalHeader(byteBuf);\n+        byteBuf.readBytes(outputStream, 24); // Pcap Global Header size is of 24 Bytes", "originalCommit": "d6d078e9c9aa70aad009d645cde80e43e3cf3e1e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ2MTQyOA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r477461428", "bodyText": "so either the comment is wrong or 16 is wrong ... Also wouldn't it make more sense to use packetHeaderBuf.readableBytes() ?", "author": "normanmaurer", "createdAt": "2020-08-26T17:17:03Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCapWriter.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.Unpooled;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+final class PCapWriter implements Closeable {\n+    private final long myStartTime = System.nanoTime();\n+    private final OutputStream outputStream;\n+\n+    /**\n+     * This uses {@link OutputStream} for writing Pcap.\n+     * Pcap Global Header is also written on construction.\n+     *\n+     * @throws IOException If {@link OutputStream#write(byte[])} throws an exception\n+     */\n+    PCapWriter(OutputStream outputStream) throws IOException {\n+        this.outputStream = outputStream;\n+\n+        ByteBuf byteBuf = Unpooled.buffer();\n+        io.netty.handler.codec.pcap.PcapHeaders.writeGlobalHeader(byteBuf);\n+        byteBuf.readBytes(outputStream, 24); // Pcap Global Header size is of 24 Bytes\n+        byteBuf.release();\n+    }\n+\n+    /**\n+     * Write Packet in Pcap OutputStream.\n+     *\n+     * @param packetHeaderBuf Packer Header {@link ByteBuf}\n+     * @param packet Packet\n+     * @throws IOException If {@link OutputStream#write(byte[])} throws an exception\n+     */\n+    void writePacket(ByteBuf packetHeaderBuf, ByteBuf packet) throws IOException {\n+        long difference = System.nanoTime() - myStartTime;\n+\n+        io.netty.handler.codec.pcap.PcapHeaders.writePacketHeader(\n+                packetHeaderBuf,\n+                (int) difference / 1000000000,\n+                (int) difference / 1000000,\n+                packet.readableBytes(),\n+                packet.readableBytes()\n+        );\n+\n+        packetHeaderBuf.readBytes(outputStream, 16); // Pcap Packet Header size is of 24 Bytes", "originalCommit": "d6d078e9c9aa70aad009d645cde80e43e3cf3e1e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ3NjE3OQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r477476179", "bodyText": "Fixed :)", "author": "hyperxpro", "createdAt": "2020-08-26T17:41:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ2MTQyOA=="}], "type": "inlineReview"}, {"oid": "ede3e5bca3a6e3740a44c4a72fddb30614b804bc", "url": "https://github.com/netty/netty/commit/ede3e5bca3a6e3740a44c4a72fddb30614b804bc", "message": "use ByteBuf#readBytes and use TimeUnit for time conversion", "committedDate": "2020-08-26T17:41:14Z", "type": "commit"}, {"oid": "b01a3ab1abc268d285361364dea0bebe5cc46aca", "url": "https://github.com/netty/netty/commit/b01a3ab1abc268d285361364dea0bebe5cc46aca", "message": "Simulate real TCP flows", "committedDate": "2020-08-28T20:58:38Z", "type": "commit"}, {"oid": "b31c6a6543d73a9b79f3ca5c6fcfe4d916b8dac1", "url": "https://github.com/netty/netty/commit/b31c6a6543d73a9b79f3ca5c6fcfe4d916b8dac1", "message": "proper implementation of Pcap for TCP and UDP in both client and server mode", "committedDate": "2020-08-29T11:01:27Z", "type": "commit"}, {"oid": "afbd30c9d9b7eb65751431a1c3b03d822469096d", "url": "https://github.com/netty/netty/commit/afbd30c9d9b7eb65751431a1c3b03d822469096d", "message": "PCAPWriteHandler name is better", "committedDate": "2020-08-29T11:07:03Z", "type": "commit"}, {"oid": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "url": "https://github.com/netty/netty/commit/d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "message": "add PCAPWriteHandler(OutputStream) constructor", "committedDate": "2020-08-29T20:29:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk4MTQ4Ng==", "url": "https://github.com/netty/netty/pull/10498#discussion_r479981486", "bodyText": "couldn't we detect  these in the methods itself ?\nboolean isTcp = channel instanceof SocketChannel;\nboolean isServer = channel instanceof ServerChannel;", "author": "normanmaurer", "createdAt": "2020-08-31T08:37:44Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCAPWriteHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public final class PCAPWriteHandler extends ChannelDuplexHandler {\n+\n+    private final InternalLogger logger = InternalLoggerFactory.getInstance(PCAPWriteHandler.class);\n+\n+    /**\n+     * TCP Sender Segment Number.\n+     */\n+    private int sendSegmentNumber = 1;\n+\n+    /**\n+     * TCP Receiver Segment Number\n+     */\n+    private int receiveSegmentNumber = 1;\n+\n+    /**\n+     * Source Address [TCP ONLY]\n+     */\n+    private InetSocketAddress srcAddr;\n+\n+    /**\n+     * Destination Address [TCP ONLY]\n+     */\n+    private InetSocketAddress dstAddr;\n+\n+    private final OutputStream outputStream;\n+    private PCapWriter pCapWriter;\n+    private final boolean isTCP;\n+    private final boolean isServer;\n+    private final boolean captureZeroByte;\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code isTCP}, {@code isServer} and {@code captureZeroByte} are set to {@code false}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream) {\n+        this(outputStream, false, false, false);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code captureZeroByte} is set to {@code false}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     * @param isTCP        {@code true} to capture TCP packets\n+     * @param isServer     {@code true} if we'll capture packet as server\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean isTCP, boolean isServer) {", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk4MTg3Nw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r479981877", "bodyText": "better do this in a finally block", "author": "normanmaurer", "createdAt": "2020-08-31T08:38:29Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCAPWriteHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public final class PCAPWriteHandler extends ChannelDuplexHandler {\n+\n+    private final InternalLogger logger = InternalLoggerFactory.getInstance(PCAPWriteHandler.class);\n+\n+    /**\n+     * TCP Sender Segment Number.\n+     */\n+    private int sendSegmentNumber = 1;\n+\n+    /**\n+     * TCP Receiver Segment Number\n+     */\n+    private int receiveSegmentNumber = 1;\n+\n+    /**\n+     * Source Address [TCP ONLY]\n+     */\n+    private InetSocketAddress srcAddr;\n+\n+    /**\n+     * Destination Address [TCP ONLY]\n+     */\n+    private InetSocketAddress dstAddr;\n+\n+    private final OutputStream outputStream;\n+    private PCapWriter pCapWriter;\n+    private final boolean isTCP;\n+    private final boolean isServer;\n+    private final boolean captureZeroByte;\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code isTCP}, {@code isServer} and {@code captureZeroByte} are set to {@code false}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream) {\n+        this(outputStream, false, false, false);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code captureZeroByte} is set to {@code false}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     * @param isTCP        {@code true} to capture TCP packets\n+     * @param isServer     {@code true} if we'll capture packet as server\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean isTCP, boolean isServer) {\n+        this(outputStream, isTCP, isServer, false);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance\n+     *\n+     * @param outputStream    OutputStream where Pcap data will be written\n+     * @param isTCP           {@code true} to capture TCP packets\n+     * @param isServer        {@code true} if we'll capture packet as server\n+     * @param captureZeroByte {@code true} if we'll capture packets with 0 bytes\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean isTCP, boolean isServer, boolean captureZeroByte) {\n+        this.outputStream = outputStream;\n+        this.isTCP = isTCP;\n+        this.isServer = isServer;\n+        this.captureZeroByte = captureZeroByte;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        this.pCapWriter = new PCapWriter(this.outputStream, ctx.alloc().buffer());\n+\n+        /*\n+         * If `isServer` is set to true, it means we'll be receiving data from client.\n+         * In this case, Source Address will be `remoteAddress` and Destination Address\n+         * will be `localAddress`.\n+         *\n+         * If `isServer` is set to false, it means we'll be sending data to server.\n+         * In this case, Source Address will be `localAddress` and Destination Address\n+         * will be `remoteAddress`.\n+         */\n+        if (isTCP) {\n+            if (isServer) {\n+                srcAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().localAddress();\n+            } else {\n+                srcAddr = (InetSocketAddress) ctx.channel().localAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+            }\n+        }\n+\n+        // If `isTCP` is true, then we'll simulate a fake handshake.\n+        if (isTCP) {\n+            logger.debug(\"Starting Fake TCP 3-Way Handshake\");\n+\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            // Write SYN with Normal Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, 0, 0, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.Flag.SYN);\n+            completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+            // Write SYN+ACK with Reversed Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, 0, 1, dstAddr.getPort(), srcAddr.getPort(), TCPPacket.Flag.SYN,\n+                    TCPPacket.Flag.ACK);\n+            completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+\n+            // Write ACK with Normal Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, 1, 1, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.Flag.ACK);\n+            completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+            tcpBuf.release();\n+\n+            logger.debug(\"Finished Fake TCP 3-Way Handshake\");\n+        }\n+\n+        super.channelActive(ctx);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        writePacket(ctx, msg, false);\n+        super.channelRead(ctx, msg);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        writePacket(ctx, msg, true);\n+        super.write(ctx, msg, promise);\n+    }\n+\n+    private void writePacket(ChannelHandlerContext ctx, Object msg, boolean isWriteOperation) throws Exception {\n+        if (msg instanceof ByteBuf) {\n+\n+            // If bytes are 0 and `captureZeroByte` is false, we won't capture this.\n+            if (((ByteBuf) msg).readableBytes() == 0 && !captureZeroByte) {\n+                logger.debug(\"Discarding Zero Byte TCP Packet. isWriteOperation {}\", isWriteOperation);\n+                return;\n+            }\n+\n+            ByteBuf packet = ((ByteBuf) msg).duplicate();\n+            int bytes = packet.readableBytes();\n+\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            if (isWriteOperation) {\n+                TCPPacket.writePacket(tcpBuf, packet, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                        dstAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+                logTCP(true, bytes, sendSegmentNumber, receiveSegmentNumber, srcAddr, dstAddr, false);\n+\n+                sendSegmentNumber += bytes;\n+\n+                TCPPacket.writePacket(tcpBuf, null, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                        srcAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+                logTCP(true, bytes, sendSegmentNumber, receiveSegmentNumber, dstAddr, srcAddr, true);\n+            } else {\n+                TCPPacket.writePacket(tcpBuf, packet, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                        srcAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+                logTCP(false, bytes, receiveSegmentNumber, sendSegmentNumber, dstAddr, srcAddr, false);\n+\n+                receiveSegmentNumber += bytes;\n+\n+                TCPPacket.writePacket(tcpBuf, null, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                        dstAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+                logTCP(false, bytes, sendSegmentNumber, receiveSegmentNumber, srcAddr, dstAddr, true);\n+            }\n+\n+            tcpBuf.release();", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk4MjQ0Mg==", "url": "https://github.com/netty/netty/pull/10498#discussion_r479982442", "bodyText": "I would not do the release here but let the caller handle this.", "author": "normanmaurer", "createdAt": "2020-08-31T08:39:36Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCAPWriteHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public final class PCAPWriteHandler extends ChannelDuplexHandler {\n+\n+    private final InternalLogger logger = InternalLoggerFactory.getInstance(PCAPWriteHandler.class);\n+\n+    /**\n+     * TCP Sender Segment Number.\n+     */\n+    private int sendSegmentNumber = 1;\n+\n+    /**\n+     * TCP Receiver Segment Number\n+     */\n+    private int receiveSegmentNumber = 1;\n+\n+    /**\n+     * Source Address [TCP ONLY]\n+     */\n+    private InetSocketAddress srcAddr;\n+\n+    /**\n+     * Destination Address [TCP ONLY]\n+     */\n+    private InetSocketAddress dstAddr;\n+\n+    private final OutputStream outputStream;\n+    private PCapWriter pCapWriter;\n+    private final boolean isTCP;\n+    private final boolean isServer;\n+    private final boolean captureZeroByte;\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code isTCP}, {@code isServer} and {@code captureZeroByte} are set to {@code false}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream) {\n+        this(outputStream, false, false, false);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code captureZeroByte} is set to {@code false}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     * @param isTCP        {@code true} to capture TCP packets\n+     * @param isServer     {@code true} if we'll capture packet as server\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean isTCP, boolean isServer) {\n+        this(outputStream, isTCP, isServer, false);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance\n+     *\n+     * @param outputStream    OutputStream where Pcap data will be written\n+     * @param isTCP           {@code true} to capture TCP packets\n+     * @param isServer        {@code true} if we'll capture packet as server\n+     * @param captureZeroByte {@code true} if we'll capture packets with 0 bytes\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean isTCP, boolean isServer, boolean captureZeroByte) {\n+        this.outputStream = outputStream;\n+        this.isTCP = isTCP;\n+        this.isServer = isServer;\n+        this.captureZeroByte = captureZeroByte;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        this.pCapWriter = new PCapWriter(this.outputStream, ctx.alloc().buffer());\n+\n+        /*\n+         * If `isServer` is set to true, it means we'll be receiving data from client.\n+         * In this case, Source Address will be `remoteAddress` and Destination Address\n+         * will be `localAddress`.\n+         *\n+         * If `isServer` is set to false, it means we'll be sending data to server.\n+         * In this case, Source Address will be `localAddress` and Destination Address\n+         * will be `remoteAddress`.\n+         */\n+        if (isTCP) {\n+            if (isServer) {\n+                srcAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().localAddress();\n+            } else {\n+                srcAddr = (InetSocketAddress) ctx.channel().localAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+            }\n+        }\n+\n+        // If `isTCP` is true, then we'll simulate a fake handshake.\n+        if (isTCP) {\n+            logger.debug(\"Starting Fake TCP 3-Way Handshake\");\n+\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            // Write SYN with Normal Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, 0, 0, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.Flag.SYN);\n+            completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+            // Write SYN+ACK with Reversed Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, 0, 1, dstAddr.getPort(), srcAddr.getPort(), TCPPacket.Flag.SYN,\n+                    TCPPacket.Flag.ACK);\n+            completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+\n+            // Write ACK with Normal Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, 1, 1, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.Flag.ACK);\n+            completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+            tcpBuf.release();\n+\n+            logger.debug(\"Finished Fake TCP 3-Way Handshake\");\n+        }\n+\n+        super.channelActive(ctx);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        writePacket(ctx, msg, false);\n+        super.channelRead(ctx, msg);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        writePacket(ctx, msg, true);\n+        super.write(ctx, msg, promise);\n+    }\n+\n+    private void writePacket(ChannelHandlerContext ctx, Object msg, boolean isWriteOperation) throws Exception {\n+        if (msg instanceof ByteBuf) {\n+\n+            // If bytes are 0 and `captureZeroByte` is false, we won't capture this.\n+            if (((ByteBuf) msg).readableBytes() == 0 && !captureZeroByte) {\n+                logger.debug(\"Discarding Zero Byte TCP Packet. isWriteOperation {}\", isWriteOperation);\n+                return;\n+            }\n+\n+            ByteBuf packet = ((ByteBuf) msg).duplicate();\n+            int bytes = packet.readableBytes();\n+\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            if (isWriteOperation) {\n+                TCPPacket.writePacket(tcpBuf, packet, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                        dstAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+                logTCP(true, bytes, sendSegmentNumber, receiveSegmentNumber, srcAddr, dstAddr, false);\n+\n+                sendSegmentNumber += bytes;\n+\n+                TCPPacket.writePacket(tcpBuf, null, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                        srcAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+                logTCP(true, bytes, sendSegmentNumber, receiveSegmentNumber, dstAddr, srcAddr, true);\n+            } else {\n+                TCPPacket.writePacket(tcpBuf, packet, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                        srcAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+                logTCP(false, bytes, receiveSegmentNumber, sendSegmentNumber, dstAddr, srcAddr, false);\n+\n+                receiveSegmentNumber += bytes;\n+\n+                TCPPacket.writePacket(tcpBuf, null, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                        dstAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+                logTCP(false, bytes, sendSegmentNumber, receiveSegmentNumber, srcAddr, dstAddr, true);\n+            }\n+\n+            tcpBuf.release();\n+        } else if (msg instanceof DatagramPacket) {\n+            handleUDP(ctx, ((DatagramPacket) msg).duplicate());\n+        } else {\n+            logger.error(\"Discarding Pcap Write for Object {}\", msg);\n+        }\n+    }\n+\n+    private void logTCP(boolean isWriteOperation, int bytes, int sendSegmentNumber, int receiveSegmentNumber,\n+                        InetSocketAddress srcAddr, InetSocketAddress dstAddr, boolean AckOnly) {\n+        if (AckOnly) {\n+            logger.debug(\"Writing TCP ACK, isWriteOperation {}, Segment Number {}, Ack Number {}, Src Addr {}, \"\n+                    + \"Dst Addr {}\", isWriteOperation, sendSegmentNumber, receiveSegmentNumber, dstAddr, srcAddr);\n+        } else {\n+            logger.debug(\"Writing TCP Data of {} Bytes, isWriteOperation {}, Segment Number {}, Ack Number {}, \" +\n+                            \"Src Addr {}, Dst Addr {}\", bytes, isWriteOperation, sendSegmentNumber,\n+                    receiveSegmentNumber, srcAddr, dstAddr);\n+        }\n+    }\n+\n+    private void handleUDP(ChannelHandlerContext ctx, DatagramPacket datagramPacket) throws IOException {\n+        ByteBuf udpBuf = ctx.alloc().buffer();\n+\n+        InetSocketAddress srcAddr = datagramPacket.sender();\n+        InetSocketAddress dstAddr = datagramPacket.recipient();\n+\n+        logger.debug(\"Writing UDP Data of {} Bytes, Src Addr {}, Dst Addr {}\", datagramPacket.content().readableBytes()\n+                , srcAddr, dstAddr);\n+\n+        UDPPacket.writePacket(udpBuf,\n+                datagramPacket.content(),\n+                srcAddr.getPort(),\n+                dstAddr.getPort());\n+\n+        completeUDPWrite(srcAddr, dstAddr, udpBuf, ctx.alloc());\n+\n+        udpBuf.release();\n+    }\n+\n+    private void completeTCPWrite(InetSocketAddress srcAddr, InetSocketAddress dstAddr, ByteBuf tcpBuf,\n+                                  ByteBufAllocator byteBufAllocator) throws IOException {\n+\n+        ByteBuf ipBuf = byteBufAllocator.buffer();\n+        ByteBuf ethernetBuf = byteBufAllocator.buffer();\n+\n+        try {\n+\n+            if (srcAddr.getAddress() instanceof Inet4Address) {\n+                IPPacket.writeTCPv4(ipBuf,\n+                        tcpBuf,\n+                        ipv4ToInt(srcAddr.getAddress()),\n+                        ipv4ToInt(dstAddr.getAddress()));\n+\n+                EthernetPacket.writeIPv4(ethernetBuf, ipBuf);\n+            } else {\n+                IPPacket.writeTCPv6(ipBuf,\n+                        tcpBuf,\n+                        srcAddr.getAddress().getAddress(),\n+                        dstAddr.getAddress().getAddress());\n+\n+                EthernetPacket.writeIPv6(ethernetBuf, ipBuf);\n+            }\n+\n+            pCapWriter.writePacket(byteBufAllocator.buffer(), ethernetBuf);\n+        } catch (IOException ex) {\n+            tcpBuf.release();", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk4MjY0OA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r479982648", "bodyText": "I would not do this here but let the caller do this as the caller is the one that allocated this buffer", "author": "normanmaurer", "createdAt": "2020-08-31T08:39:58Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCAPWriteHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public final class PCAPWriteHandler extends ChannelDuplexHandler {\n+\n+    private final InternalLogger logger = InternalLoggerFactory.getInstance(PCAPWriteHandler.class);\n+\n+    /**\n+     * TCP Sender Segment Number.\n+     */\n+    private int sendSegmentNumber = 1;\n+\n+    /**\n+     * TCP Receiver Segment Number\n+     */\n+    private int receiveSegmentNumber = 1;\n+\n+    /**\n+     * Source Address [TCP ONLY]\n+     */\n+    private InetSocketAddress srcAddr;\n+\n+    /**\n+     * Destination Address [TCP ONLY]\n+     */\n+    private InetSocketAddress dstAddr;\n+\n+    private final OutputStream outputStream;\n+    private PCapWriter pCapWriter;\n+    private final boolean isTCP;\n+    private final boolean isServer;\n+    private final boolean captureZeroByte;\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code isTCP}, {@code isServer} and {@code captureZeroByte} are set to {@code false}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream) {\n+        this(outputStream, false, false, false);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code captureZeroByte} is set to {@code false}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     * @param isTCP        {@code true} to capture TCP packets\n+     * @param isServer     {@code true} if we'll capture packet as server\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean isTCP, boolean isServer) {\n+        this(outputStream, isTCP, isServer, false);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance\n+     *\n+     * @param outputStream    OutputStream where Pcap data will be written\n+     * @param isTCP           {@code true} to capture TCP packets\n+     * @param isServer        {@code true} if we'll capture packet as server\n+     * @param captureZeroByte {@code true} if we'll capture packets with 0 bytes\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean isTCP, boolean isServer, boolean captureZeroByte) {\n+        this.outputStream = outputStream;\n+        this.isTCP = isTCP;\n+        this.isServer = isServer;\n+        this.captureZeroByte = captureZeroByte;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        this.pCapWriter = new PCapWriter(this.outputStream, ctx.alloc().buffer());\n+\n+        /*\n+         * If `isServer` is set to true, it means we'll be receiving data from client.\n+         * In this case, Source Address will be `remoteAddress` and Destination Address\n+         * will be `localAddress`.\n+         *\n+         * If `isServer` is set to false, it means we'll be sending data to server.\n+         * In this case, Source Address will be `localAddress` and Destination Address\n+         * will be `remoteAddress`.\n+         */\n+        if (isTCP) {\n+            if (isServer) {\n+                srcAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().localAddress();\n+            } else {\n+                srcAddr = (InetSocketAddress) ctx.channel().localAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+            }\n+        }\n+\n+        // If `isTCP` is true, then we'll simulate a fake handshake.\n+        if (isTCP) {\n+            logger.debug(\"Starting Fake TCP 3-Way Handshake\");\n+\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            // Write SYN with Normal Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, 0, 0, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.Flag.SYN);\n+            completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+            // Write SYN+ACK with Reversed Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, 0, 1, dstAddr.getPort(), srcAddr.getPort(), TCPPacket.Flag.SYN,\n+                    TCPPacket.Flag.ACK);\n+            completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+\n+            // Write ACK with Normal Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, 1, 1, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.Flag.ACK);\n+            completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+            tcpBuf.release();\n+\n+            logger.debug(\"Finished Fake TCP 3-Way Handshake\");\n+        }\n+\n+        super.channelActive(ctx);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        writePacket(ctx, msg, false);\n+        super.channelRead(ctx, msg);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        writePacket(ctx, msg, true);\n+        super.write(ctx, msg, promise);\n+    }\n+\n+    private void writePacket(ChannelHandlerContext ctx, Object msg, boolean isWriteOperation) throws Exception {\n+        if (msg instanceof ByteBuf) {\n+\n+            // If bytes are 0 and `captureZeroByte` is false, we won't capture this.\n+            if (((ByteBuf) msg).readableBytes() == 0 && !captureZeroByte) {\n+                logger.debug(\"Discarding Zero Byte TCP Packet. isWriteOperation {}\", isWriteOperation);\n+                return;\n+            }\n+\n+            ByteBuf packet = ((ByteBuf) msg).duplicate();\n+            int bytes = packet.readableBytes();\n+\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            if (isWriteOperation) {\n+                TCPPacket.writePacket(tcpBuf, packet, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                        dstAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+                logTCP(true, bytes, sendSegmentNumber, receiveSegmentNumber, srcAddr, dstAddr, false);\n+\n+                sendSegmentNumber += bytes;\n+\n+                TCPPacket.writePacket(tcpBuf, null, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                        srcAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+                logTCP(true, bytes, sendSegmentNumber, receiveSegmentNumber, dstAddr, srcAddr, true);\n+            } else {\n+                TCPPacket.writePacket(tcpBuf, packet, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                        srcAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+                logTCP(false, bytes, receiveSegmentNumber, sendSegmentNumber, dstAddr, srcAddr, false);\n+\n+                receiveSegmentNumber += bytes;\n+\n+                TCPPacket.writePacket(tcpBuf, null, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                        dstAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+                logTCP(false, bytes, sendSegmentNumber, receiveSegmentNumber, srcAddr, dstAddr, true);\n+            }\n+\n+            tcpBuf.release();\n+        } else if (msg instanceof DatagramPacket) {\n+            handleUDP(ctx, ((DatagramPacket) msg).duplicate());\n+        } else {\n+            logger.error(\"Discarding Pcap Write for Object {}\", msg);\n+        }\n+    }\n+\n+    private void logTCP(boolean isWriteOperation, int bytes, int sendSegmentNumber, int receiveSegmentNumber,\n+                        InetSocketAddress srcAddr, InetSocketAddress dstAddr, boolean AckOnly) {\n+        if (AckOnly) {\n+            logger.debug(\"Writing TCP ACK, isWriteOperation {}, Segment Number {}, Ack Number {}, Src Addr {}, \"\n+                    + \"Dst Addr {}\", isWriteOperation, sendSegmentNumber, receiveSegmentNumber, dstAddr, srcAddr);\n+        } else {\n+            logger.debug(\"Writing TCP Data of {} Bytes, isWriteOperation {}, Segment Number {}, Ack Number {}, \" +\n+                            \"Src Addr {}, Dst Addr {}\", bytes, isWriteOperation, sendSegmentNumber,\n+                    receiveSegmentNumber, srcAddr, dstAddr);\n+        }\n+    }\n+\n+    private void handleUDP(ChannelHandlerContext ctx, DatagramPacket datagramPacket) throws IOException {\n+        ByteBuf udpBuf = ctx.alloc().buffer();\n+\n+        InetSocketAddress srcAddr = datagramPacket.sender();\n+        InetSocketAddress dstAddr = datagramPacket.recipient();\n+\n+        logger.debug(\"Writing UDP Data of {} Bytes, Src Addr {}, Dst Addr {}\", datagramPacket.content().readableBytes()\n+                , srcAddr, dstAddr);\n+\n+        UDPPacket.writePacket(udpBuf,\n+                datagramPacket.content(),\n+                srcAddr.getPort(),\n+                dstAddr.getPort());\n+\n+        completeUDPWrite(srcAddr, dstAddr, udpBuf, ctx.alloc());\n+\n+        udpBuf.release();\n+    }\n+\n+    private void completeTCPWrite(InetSocketAddress srcAddr, InetSocketAddress dstAddr, ByteBuf tcpBuf,\n+                                  ByteBufAllocator byteBufAllocator) throws IOException {\n+\n+        ByteBuf ipBuf = byteBufAllocator.buffer();\n+        ByteBuf ethernetBuf = byteBufAllocator.buffer();\n+\n+        try {\n+\n+            if (srcAddr.getAddress() instanceof Inet4Address) {\n+                IPPacket.writeTCPv4(ipBuf,\n+                        tcpBuf,\n+                        ipv4ToInt(srcAddr.getAddress()),\n+                        ipv4ToInt(dstAddr.getAddress()));\n+\n+                EthernetPacket.writeIPv4(ethernetBuf, ipBuf);\n+            } else {\n+                IPPacket.writeTCPv6(ipBuf,\n+                        tcpBuf,\n+                        srcAddr.getAddress().getAddress(),\n+                        dstAddr.getAddress().getAddress());\n+\n+                EthernetPacket.writeIPv6(ethernetBuf, ipBuf);\n+            }\n+\n+            pCapWriter.writePacket(byteBufAllocator.buffer(), ethernetBuf);\n+        } catch (IOException ex) {\n+            tcpBuf.release();\n+            throw ex;\n+        } finally {\n+            ipBuf.release();\n+            ethernetBuf.release();\n+        }\n+    }\n+\n+    private void completeUDPWrite(InetSocketAddress srcAddr, InetSocketAddress dstAddr, ByteBuf udpBuf,\n+                                  ByteBufAllocator byteBufAllocator) throws IOException {\n+\n+        ByteBuf ipBuf = byteBufAllocator.buffer();\n+        ByteBuf ethernetBuf = byteBufAllocator.buffer();\n+\n+        try {\n+\n+            if (srcAddr.getAddress() instanceof Inet4Address) {\n+                IPPacket.writeUDPv4(ipBuf,\n+                        udpBuf,\n+                        ipv4ToInt(srcAddr.getAddress()),\n+                        ipv4ToInt(dstAddr.getAddress()));\n+\n+                EthernetPacket.writeIPv4(ethernetBuf, ipBuf);\n+            } else {\n+                IPPacket.writeUDPv6(ipBuf,\n+                        udpBuf,\n+                        srcAddr.getAddress().getAddress(),\n+                        dstAddr.getAddress().getAddress());\n+\n+                EthernetPacket.writeIPv6(ethernetBuf, ipBuf);\n+            }\n+\n+            pCapWriter.writePacket(byteBufAllocator.buffer(), ethernetBuf);\n+        } catch (IOException ex) {\n+            udpBuf.release();", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk4Mjg0NA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r479982844", "bodyText": "This can use the \"NetUtils.\" method now", "author": "normanmaurer", "createdAt": "2020-08-31T08:40:20Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCAPWriteHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public final class PCAPWriteHandler extends ChannelDuplexHandler {\n+\n+    private final InternalLogger logger = InternalLoggerFactory.getInstance(PCAPWriteHandler.class);\n+\n+    /**\n+     * TCP Sender Segment Number.\n+     */\n+    private int sendSegmentNumber = 1;\n+\n+    /**\n+     * TCP Receiver Segment Number\n+     */\n+    private int receiveSegmentNumber = 1;\n+\n+    /**\n+     * Source Address [TCP ONLY]\n+     */\n+    private InetSocketAddress srcAddr;\n+\n+    /**\n+     * Destination Address [TCP ONLY]\n+     */\n+    private InetSocketAddress dstAddr;\n+\n+    private final OutputStream outputStream;\n+    private PCapWriter pCapWriter;\n+    private final boolean isTCP;\n+    private final boolean isServer;\n+    private final boolean captureZeroByte;\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code isTCP}, {@code isServer} and {@code captureZeroByte} are set to {@code false}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream) {\n+        this(outputStream, false, false, false);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code captureZeroByte} is set to {@code false}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     * @param isTCP        {@code true} to capture TCP packets\n+     * @param isServer     {@code true} if we'll capture packet as server\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean isTCP, boolean isServer) {\n+        this(outputStream, isTCP, isServer, false);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance\n+     *\n+     * @param outputStream    OutputStream where Pcap data will be written\n+     * @param isTCP           {@code true} to capture TCP packets\n+     * @param isServer        {@code true} if we'll capture packet as server\n+     * @param captureZeroByte {@code true} if we'll capture packets with 0 bytes\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean isTCP, boolean isServer, boolean captureZeroByte) {\n+        this.outputStream = outputStream;\n+        this.isTCP = isTCP;\n+        this.isServer = isServer;\n+        this.captureZeroByte = captureZeroByte;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        this.pCapWriter = new PCapWriter(this.outputStream, ctx.alloc().buffer());\n+\n+        /*\n+         * If `isServer` is set to true, it means we'll be receiving data from client.\n+         * In this case, Source Address will be `remoteAddress` and Destination Address\n+         * will be `localAddress`.\n+         *\n+         * If `isServer` is set to false, it means we'll be sending data to server.\n+         * In this case, Source Address will be `localAddress` and Destination Address\n+         * will be `remoteAddress`.\n+         */\n+        if (isTCP) {\n+            if (isServer) {\n+                srcAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().localAddress();\n+            } else {\n+                srcAddr = (InetSocketAddress) ctx.channel().localAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+            }\n+        }\n+\n+        // If `isTCP` is true, then we'll simulate a fake handshake.\n+        if (isTCP) {\n+            logger.debug(\"Starting Fake TCP 3-Way Handshake\");\n+\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            // Write SYN with Normal Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, 0, 0, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.Flag.SYN);\n+            completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+            // Write SYN+ACK with Reversed Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, 0, 1, dstAddr.getPort(), srcAddr.getPort(), TCPPacket.Flag.SYN,\n+                    TCPPacket.Flag.ACK);\n+            completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+\n+            // Write ACK with Normal Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, 1, 1, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.Flag.ACK);\n+            completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+            tcpBuf.release();\n+\n+            logger.debug(\"Finished Fake TCP 3-Way Handshake\");\n+        }\n+\n+        super.channelActive(ctx);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        writePacket(ctx, msg, false);\n+        super.channelRead(ctx, msg);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        writePacket(ctx, msg, true);\n+        super.write(ctx, msg, promise);\n+    }\n+\n+    private void writePacket(ChannelHandlerContext ctx, Object msg, boolean isWriteOperation) throws Exception {\n+        if (msg instanceof ByteBuf) {\n+\n+            // If bytes are 0 and `captureZeroByte` is false, we won't capture this.\n+            if (((ByteBuf) msg).readableBytes() == 0 && !captureZeroByte) {\n+                logger.debug(\"Discarding Zero Byte TCP Packet. isWriteOperation {}\", isWriteOperation);\n+                return;\n+            }\n+\n+            ByteBuf packet = ((ByteBuf) msg).duplicate();\n+            int bytes = packet.readableBytes();\n+\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            if (isWriteOperation) {\n+                TCPPacket.writePacket(tcpBuf, packet, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                        dstAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+                logTCP(true, bytes, sendSegmentNumber, receiveSegmentNumber, srcAddr, dstAddr, false);\n+\n+                sendSegmentNumber += bytes;\n+\n+                TCPPacket.writePacket(tcpBuf, null, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                        srcAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+                logTCP(true, bytes, sendSegmentNumber, receiveSegmentNumber, dstAddr, srcAddr, true);\n+            } else {\n+                TCPPacket.writePacket(tcpBuf, packet, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                        srcAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+                logTCP(false, bytes, receiveSegmentNumber, sendSegmentNumber, dstAddr, srcAddr, false);\n+\n+                receiveSegmentNumber += bytes;\n+\n+                TCPPacket.writePacket(tcpBuf, null, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                        dstAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+                logTCP(false, bytes, sendSegmentNumber, receiveSegmentNumber, srcAddr, dstAddr, true);\n+            }\n+\n+            tcpBuf.release();\n+        } else if (msg instanceof DatagramPacket) {\n+            handleUDP(ctx, ((DatagramPacket) msg).duplicate());\n+        } else {\n+            logger.error(\"Discarding Pcap Write for Object {}\", msg);\n+        }\n+    }\n+\n+    private void logTCP(boolean isWriteOperation, int bytes, int sendSegmentNumber, int receiveSegmentNumber,\n+                        InetSocketAddress srcAddr, InetSocketAddress dstAddr, boolean AckOnly) {\n+        if (AckOnly) {\n+            logger.debug(\"Writing TCP ACK, isWriteOperation {}, Segment Number {}, Ack Number {}, Src Addr {}, \"\n+                    + \"Dst Addr {}\", isWriteOperation, sendSegmentNumber, receiveSegmentNumber, dstAddr, srcAddr);\n+        } else {\n+            logger.debug(\"Writing TCP Data of {} Bytes, isWriteOperation {}, Segment Number {}, Ack Number {}, \" +\n+                            \"Src Addr {}, Dst Addr {}\", bytes, isWriteOperation, sendSegmentNumber,\n+                    receiveSegmentNumber, srcAddr, dstAddr);\n+        }\n+    }\n+\n+    private void handleUDP(ChannelHandlerContext ctx, DatagramPacket datagramPacket) throws IOException {\n+        ByteBuf udpBuf = ctx.alloc().buffer();\n+\n+        InetSocketAddress srcAddr = datagramPacket.sender();\n+        InetSocketAddress dstAddr = datagramPacket.recipient();\n+\n+        logger.debug(\"Writing UDP Data of {} Bytes, Src Addr {}, Dst Addr {}\", datagramPacket.content().readableBytes()\n+                , srcAddr, dstAddr);\n+\n+        UDPPacket.writePacket(udpBuf,\n+                datagramPacket.content(),\n+                srcAddr.getPort(),\n+                dstAddr.getPort());\n+\n+        completeUDPWrite(srcAddr, dstAddr, udpBuf, ctx.alloc());\n+\n+        udpBuf.release();\n+    }\n+\n+    private void completeTCPWrite(InetSocketAddress srcAddr, InetSocketAddress dstAddr, ByteBuf tcpBuf,\n+                                  ByteBufAllocator byteBufAllocator) throws IOException {\n+\n+        ByteBuf ipBuf = byteBufAllocator.buffer();\n+        ByteBuf ethernetBuf = byteBufAllocator.buffer();\n+\n+        try {\n+\n+            if (srcAddr.getAddress() instanceof Inet4Address) {\n+                IPPacket.writeTCPv4(ipBuf,\n+                        tcpBuf,\n+                        ipv4ToInt(srcAddr.getAddress()),\n+                        ipv4ToInt(dstAddr.getAddress()));\n+\n+                EthernetPacket.writeIPv4(ethernetBuf, ipBuf);\n+            } else {\n+                IPPacket.writeTCPv6(ipBuf,\n+                        tcpBuf,\n+                        srcAddr.getAddress().getAddress(),\n+                        dstAddr.getAddress().getAddress());\n+\n+                EthernetPacket.writeIPv6(ethernetBuf, ipBuf);\n+            }\n+\n+            pCapWriter.writePacket(byteBufAllocator.buffer(), ethernetBuf);\n+        } catch (IOException ex) {\n+            tcpBuf.release();\n+            throw ex;\n+        } finally {\n+            ipBuf.release();\n+            ethernetBuf.release();\n+        }\n+    }\n+\n+    private void completeUDPWrite(InetSocketAddress srcAddr, InetSocketAddress dstAddr, ByteBuf udpBuf,\n+                                  ByteBufAllocator byteBufAllocator) throws IOException {\n+\n+        ByteBuf ipBuf = byteBufAllocator.buffer();\n+        ByteBuf ethernetBuf = byteBufAllocator.buffer();\n+\n+        try {\n+\n+            if (srcAddr.getAddress() instanceof Inet4Address) {\n+                IPPacket.writeUDPv4(ipBuf,\n+                        udpBuf,\n+                        ipv4ToInt(srcAddr.getAddress()),\n+                        ipv4ToInt(dstAddr.getAddress()));\n+\n+                EthernetPacket.writeIPv4(ethernetBuf, ipBuf);\n+            } else {\n+                IPPacket.writeUDPv6(ipBuf,\n+                        udpBuf,\n+                        srcAddr.getAddress().getAddress(),\n+                        dstAddr.getAddress().getAddress());\n+\n+                EthernetPacket.writeIPv6(ethernetBuf, ipBuf);\n+            }\n+\n+            pCapWriter.writePacket(byteBufAllocator.buffer(), ethernetBuf);\n+        } catch (IOException ex) {\n+            udpBuf.release();\n+            throw ex;\n+        } finally {\n+            ipBuf.release();\n+            ethernetBuf.release();\n+        }\n+    }\n+\n+    @Override\n+    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {\n+\n+        // If `isTCP` is true, then we'll simulate a `FIN` flow.\n+        if (isTCP) {\n+            logger.debug(\"Starting Fake TCP FIN+ACK Flow to close connection\");\n+\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            // Write FIN+ACK with Normal Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                    dstAddr.getPort(), TCPPacket.Flag.FIN, TCPPacket.Flag.ACK);\n+            completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+            // Write FIN+ACK with Reversed Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                    srcAddr.getPort(), TCPPacket.Flag.FIN, TCPPacket.Flag.ACK);\n+            completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+\n+            // Write ACK with Normal Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, sendSegmentNumber + 1, receiveSegmentNumber + 1,\n+                    srcAddr.getPort(), dstAddr.getPort(), TCPPacket.Flag.ACK);\n+            completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+            tcpBuf.release();\n+\n+            logger.debug(\"Finished Fake TCP FIN+ACK Flow to close connection\");\n+        }\n+\n+        this.pCapWriter.close();\n+        super.handlerRemoved(ctx);\n+    }\n+\n+    private int ipv4ToInt(InetAddress inetAddress) {", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk4MzA3MA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r479983070", "bodyText": "Replace with ctx.fireExceptionCause(...)", "author": "normanmaurer", "createdAt": "2020-08-31T08:40:48Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCAPWriteHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public final class PCAPWriteHandler extends ChannelDuplexHandler {\n+\n+    private final InternalLogger logger = InternalLoggerFactory.getInstance(PCAPWriteHandler.class);\n+\n+    /**\n+     * TCP Sender Segment Number.\n+     */\n+    private int sendSegmentNumber = 1;\n+\n+    /**\n+     * TCP Receiver Segment Number\n+     */\n+    private int receiveSegmentNumber = 1;\n+\n+    /**\n+     * Source Address [TCP ONLY]\n+     */\n+    private InetSocketAddress srcAddr;\n+\n+    /**\n+     * Destination Address [TCP ONLY]\n+     */\n+    private InetSocketAddress dstAddr;\n+\n+    private final OutputStream outputStream;\n+    private PCapWriter pCapWriter;\n+    private final boolean isTCP;\n+    private final boolean isServer;\n+    private final boolean captureZeroByte;\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code isTCP}, {@code isServer} and {@code captureZeroByte} are set to {@code false}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream) {\n+        this(outputStream, false, false, false);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code captureZeroByte} is set to {@code false}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     * @param isTCP        {@code true} to capture TCP packets\n+     * @param isServer     {@code true} if we'll capture packet as server\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean isTCP, boolean isServer) {\n+        this(outputStream, isTCP, isServer, false);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance\n+     *\n+     * @param outputStream    OutputStream where Pcap data will be written\n+     * @param isTCP           {@code true} to capture TCP packets\n+     * @param isServer        {@code true} if we'll capture packet as server\n+     * @param captureZeroByte {@code true} if we'll capture packets with 0 bytes\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean isTCP, boolean isServer, boolean captureZeroByte) {\n+        this.outputStream = outputStream;\n+        this.isTCP = isTCP;\n+        this.isServer = isServer;\n+        this.captureZeroByte = captureZeroByte;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        this.pCapWriter = new PCapWriter(this.outputStream, ctx.alloc().buffer());\n+\n+        /*\n+         * If `isServer` is set to true, it means we'll be receiving data from client.\n+         * In this case, Source Address will be `remoteAddress` and Destination Address\n+         * will be `localAddress`.\n+         *\n+         * If `isServer` is set to false, it means we'll be sending data to server.\n+         * In this case, Source Address will be `localAddress` and Destination Address\n+         * will be `remoteAddress`.\n+         */\n+        if (isTCP) {\n+            if (isServer) {\n+                srcAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().localAddress();\n+            } else {\n+                srcAddr = (InetSocketAddress) ctx.channel().localAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+            }\n+        }\n+\n+        // If `isTCP` is true, then we'll simulate a fake handshake.\n+        if (isTCP) {\n+            logger.debug(\"Starting Fake TCP 3-Way Handshake\");\n+\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            // Write SYN with Normal Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, 0, 0, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.Flag.SYN);\n+            completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+            // Write SYN+ACK with Reversed Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, 0, 1, dstAddr.getPort(), srcAddr.getPort(), TCPPacket.Flag.SYN,\n+                    TCPPacket.Flag.ACK);\n+            completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+\n+            // Write ACK with Normal Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, 1, 1, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.Flag.ACK);\n+            completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+            tcpBuf.release();\n+\n+            logger.debug(\"Finished Fake TCP 3-Way Handshake\");\n+        }\n+\n+        super.channelActive(ctx);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        writePacket(ctx, msg, false);\n+        super.channelRead(ctx, msg);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        writePacket(ctx, msg, true);\n+        super.write(ctx, msg, promise);\n+    }\n+\n+    private void writePacket(ChannelHandlerContext ctx, Object msg, boolean isWriteOperation) throws Exception {\n+        if (msg instanceof ByteBuf) {\n+\n+            // If bytes are 0 and `captureZeroByte` is false, we won't capture this.\n+            if (((ByteBuf) msg).readableBytes() == 0 && !captureZeroByte) {\n+                logger.debug(\"Discarding Zero Byte TCP Packet. isWriteOperation {}\", isWriteOperation);\n+                return;\n+            }\n+\n+            ByteBuf packet = ((ByteBuf) msg).duplicate();\n+            int bytes = packet.readableBytes();\n+\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            if (isWriteOperation) {\n+                TCPPacket.writePacket(tcpBuf, packet, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                        dstAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+                logTCP(true, bytes, sendSegmentNumber, receiveSegmentNumber, srcAddr, dstAddr, false);\n+\n+                sendSegmentNumber += bytes;\n+\n+                TCPPacket.writePacket(tcpBuf, null, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                        srcAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+                logTCP(true, bytes, sendSegmentNumber, receiveSegmentNumber, dstAddr, srcAddr, true);\n+            } else {\n+                TCPPacket.writePacket(tcpBuf, packet, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                        srcAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+                logTCP(false, bytes, receiveSegmentNumber, sendSegmentNumber, dstAddr, srcAddr, false);\n+\n+                receiveSegmentNumber += bytes;\n+\n+                TCPPacket.writePacket(tcpBuf, null, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                        dstAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+                logTCP(false, bytes, sendSegmentNumber, receiveSegmentNumber, srcAddr, dstAddr, true);\n+            }\n+\n+            tcpBuf.release();\n+        } else if (msg instanceof DatagramPacket) {\n+            handleUDP(ctx, ((DatagramPacket) msg).duplicate());\n+        } else {\n+            logger.error(\"Discarding Pcap Write for Object {}\", msg);\n+        }\n+    }\n+\n+    private void logTCP(boolean isWriteOperation, int bytes, int sendSegmentNumber, int receiveSegmentNumber,\n+                        InetSocketAddress srcAddr, InetSocketAddress dstAddr, boolean AckOnly) {\n+        if (AckOnly) {\n+            logger.debug(\"Writing TCP ACK, isWriteOperation {}, Segment Number {}, Ack Number {}, Src Addr {}, \"\n+                    + \"Dst Addr {}\", isWriteOperation, sendSegmentNumber, receiveSegmentNumber, dstAddr, srcAddr);\n+        } else {\n+            logger.debug(\"Writing TCP Data of {} Bytes, isWriteOperation {}, Segment Number {}, Ack Number {}, \" +\n+                            \"Src Addr {}, Dst Addr {}\", bytes, isWriteOperation, sendSegmentNumber,\n+                    receiveSegmentNumber, srcAddr, dstAddr);\n+        }\n+    }\n+\n+    private void handleUDP(ChannelHandlerContext ctx, DatagramPacket datagramPacket) throws IOException {\n+        ByteBuf udpBuf = ctx.alloc().buffer();\n+\n+        InetSocketAddress srcAddr = datagramPacket.sender();\n+        InetSocketAddress dstAddr = datagramPacket.recipient();\n+\n+        logger.debug(\"Writing UDP Data of {} Bytes, Src Addr {}, Dst Addr {}\", datagramPacket.content().readableBytes()\n+                , srcAddr, dstAddr);\n+\n+        UDPPacket.writePacket(udpBuf,\n+                datagramPacket.content(),\n+                srcAddr.getPort(),\n+                dstAddr.getPort());\n+\n+        completeUDPWrite(srcAddr, dstAddr, udpBuf, ctx.alloc());\n+\n+        udpBuf.release();\n+    }\n+\n+    private void completeTCPWrite(InetSocketAddress srcAddr, InetSocketAddress dstAddr, ByteBuf tcpBuf,\n+                                  ByteBufAllocator byteBufAllocator) throws IOException {\n+\n+        ByteBuf ipBuf = byteBufAllocator.buffer();\n+        ByteBuf ethernetBuf = byteBufAllocator.buffer();\n+\n+        try {\n+\n+            if (srcAddr.getAddress() instanceof Inet4Address) {\n+                IPPacket.writeTCPv4(ipBuf,\n+                        tcpBuf,\n+                        ipv4ToInt(srcAddr.getAddress()),\n+                        ipv4ToInt(dstAddr.getAddress()));\n+\n+                EthernetPacket.writeIPv4(ethernetBuf, ipBuf);\n+            } else {\n+                IPPacket.writeTCPv6(ipBuf,\n+                        tcpBuf,\n+                        srcAddr.getAddress().getAddress(),\n+                        dstAddr.getAddress().getAddress());\n+\n+                EthernetPacket.writeIPv6(ethernetBuf, ipBuf);\n+            }\n+\n+            pCapWriter.writePacket(byteBufAllocator.buffer(), ethernetBuf);\n+        } catch (IOException ex) {\n+            tcpBuf.release();\n+            throw ex;\n+        } finally {\n+            ipBuf.release();\n+            ethernetBuf.release();\n+        }\n+    }\n+\n+    private void completeUDPWrite(InetSocketAddress srcAddr, InetSocketAddress dstAddr, ByteBuf udpBuf,\n+                                  ByteBufAllocator byteBufAllocator) throws IOException {\n+\n+        ByteBuf ipBuf = byteBufAllocator.buffer();\n+        ByteBuf ethernetBuf = byteBufAllocator.buffer();\n+\n+        try {\n+\n+            if (srcAddr.getAddress() instanceof Inet4Address) {\n+                IPPacket.writeUDPv4(ipBuf,\n+                        udpBuf,\n+                        ipv4ToInt(srcAddr.getAddress()),\n+                        ipv4ToInt(dstAddr.getAddress()));\n+\n+                EthernetPacket.writeIPv4(ethernetBuf, ipBuf);\n+            } else {\n+                IPPacket.writeUDPv6(ipBuf,\n+                        udpBuf,\n+                        srcAddr.getAddress().getAddress(),\n+                        dstAddr.getAddress().getAddress());\n+\n+                EthernetPacket.writeIPv6(ethernetBuf, ipBuf);\n+            }\n+\n+            pCapWriter.writePacket(byteBufAllocator.buffer(), ethernetBuf);\n+        } catch (IOException ex) {\n+            udpBuf.release();\n+            throw ex;\n+        } finally {\n+            ipBuf.release();\n+            ethernetBuf.release();\n+        }\n+    }\n+\n+    @Override\n+    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {\n+\n+        // If `isTCP` is true, then we'll simulate a `FIN` flow.\n+        if (isTCP) {\n+            logger.debug(\"Starting Fake TCP FIN+ACK Flow to close connection\");\n+\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            // Write FIN+ACK with Normal Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                    dstAddr.getPort(), TCPPacket.Flag.FIN, TCPPacket.Flag.ACK);\n+            completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+            // Write FIN+ACK with Reversed Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                    srcAddr.getPort(), TCPPacket.Flag.FIN, TCPPacket.Flag.ACK);\n+            completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+\n+            // Write ACK with Normal Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, sendSegmentNumber + 1, receiveSegmentNumber + 1,\n+                    srcAddr.getPort(), dstAddr.getPort(), TCPPacket.Flag.ACK);\n+            completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+            tcpBuf.release();\n+\n+            logger.debug(\"Finished Fake TCP FIN+ACK Flow to close connection\");\n+        }\n+\n+        this.pCapWriter.close();\n+        super.handlerRemoved(ctx);\n+    }\n+\n+    private int ipv4ToInt(InetAddress inetAddress) {\n+        byte[] octets = inetAddress.getAddress();\n+        assert octets.length == 4;\n+\n+        return (octets[0] & 0xff) << 24 |\n+                (octets[1] & 0xff) << 16 |\n+                (octets[2] & 0xff) << 8 |\n+                (octets[3] & 0xff);\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+\n+        // If `isTCP` is true, then we'll simulate a `RST` flow.\n+        if (isTCP) {\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            // Write RST+ACK with Normal Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                    dstAddr.getPort(), TCPPacket.Flag.RST, TCPPacket.Flag.ACK);\n+            completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+            tcpBuf.release();\n+\n+            logger.debug(\"Sent Fake TCP RST to close connection\");\n+        }\n+\n+        this.pCapWriter.close();\n+        cause.printStackTrace();", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk4MzE1Mg==", "url": "https://github.com/netty/netty/pull/10498#discussion_r479983152", "bodyText": "do in a finally block", "author": "normanmaurer", "createdAt": "2020-08-31T08:40:59Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCAPWriteHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public final class PCAPWriteHandler extends ChannelDuplexHandler {\n+\n+    private final InternalLogger logger = InternalLoggerFactory.getInstance(PCAPWriteHandler.class);\n+\n+    /**\n+     * TCP Sender Segment Number.\n+     */\n+    private int sendSegmentNumber = 1;\n+\n+    /**\n+     * TCP Receiver Segment Number\n+     */\n+    private int receiveSegmentNumber = 1;\n+\n+    /**\n+     * Source Address [TCP ONLY]\n+     */\n+    private InetSocketAddress srcAddr;\n+\n+    /**\n+     * Destination Address [TCP ONLY]\n+     */\n+    private InetSocketAddress dstAddr;\n+\n+    private final OutputStream outputStream;\n+    private PCapWriter pCapWriter;\n+    private final boolean isTCP;\n+    private final boolean isServer;\n+    private final boolean captureZeroByte;\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code isTCP}, {@code isServer} and {@code captureZeroByte} are set to {@code false}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream) {\n+        this(outputStream, false, false, false);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code captureZeroByte} is set to {@code false}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     * @param isTCP        {@code true} to capture TCP packets\n+     * @param isServer     {@code true} if we'll capture packet as server\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean isTCP, boolean isServer) {\n+        this(outputStream, isTCP, isServer, false);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance\n+     *\n+     * @param outputStream    OutputStream where Pcap data will be written\n+     * @param isTCP           {@code true} to capture TCP packets\n+     * @param isServer        {@code true} if we'll capture packet as server\n+     * @param captureZeroByte {@code true} if we'll capture packets with 0 bytes\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean isTCP, boolean isServer, boolean captureZeroByte) {\n+        this.outputStream = outputStream;\n+        this.isTCP = isTCP;\n+        this.isServer = isServer;\n+        this.captureZeroByte = captureZeroByte;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        this.pCapWriter = new PCapWriter(this.outputStream, ctx.alloc().buffer());\n+\n+        /*\n+         * If `isServer` is set to true, it means we'll be receiving data from client.\n+         * In this case, Source Address will be `remoteAddress` and Destination Address\n+         * will be `localAddress`.\n+         *\n+         * If `isServer` is set to false, it means we'll be sending data to server.\n+         * In this case, Source Address will be `localAddress` and Destination Address\n+         * will be `remoteAddress`.\n+         */\n+        if (isTCP) {\n+            if (isServer) {\n+                srcAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().localAddress();\n+            } else {\n+                srcAddr = (InetSocketAddress) ctx.channel().localAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+            }\n+        }\n+\n+        // If `isTCP` is true, then we'll simulate a fake handshake.\n+        if (isTCP) {\n+            logger.debug(\"Starting Fake TCP 3-Way Handshake\");\n+\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            // Write SYN with Normal Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, 0, 0, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.Flag.SYN);\n+            completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+            // Write SYN+ACK with Reversed Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, 0, 1, dstAddr.getPort(), srcAddr.getPort(), TCPPacket.Flag.SYN,\n+                    TCPPacket.Flag.ACK);\n+            completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+\n+            // Write ACK with Normal Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, 1, 1, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.Flag.ACK);\n+            completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+            tcpBuf.release();\n+\n+            logger.debug(\"Finished Fake TCP 3-Way Handshake\");\n+        }\n+\n+        super.channelActive(ctx);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        writePacket(ctx, msg, false);\n+        super.channelRead(ctx, msg);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        writePacket(ctx, msg, true);\n+        super.write(ctx, msg, promise);\n+    }\n+\n+    private void writePacket(ChannelHandlerContext ctx, Object msg, boolean isWriteOperation) throws Exception {\n+        if (msg instanceof ByteBuf) {\n+\n+            // If bytes are 0 and `captureZeroByte` is false, we won't capture this.\n+            if (((ByteBuf) msg).readableBytes() == 0 && !captureZeroByte) {\n+                logger.debug(\"Discarding Zero Byte TCP Packet. isWriteOperation {}\", isWriteOperation);\n+                return;\n+            }\n+\n+            ByteBuf packet = ((ByteBuf) msg).duplicate();\n+            int bytes = packet.readableBytes();\n+\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            if (isWriteOperation) {\n+                TCPPacket.writePacket(tcpBuf, packet, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                        dstAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+                logTCP(true, bytes, sendSegmentNumber, receiveSegmentNumber, srcAddr, dstAddr, false);\n+\n+                sendSegmentNumber += bytes;\n+\n+                TCPPacket.writePacket(tcpBuf, null, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                        srcAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+                logTCP(true, bytes, sendSegmentNumber, receiveSegmentNumber, dstAddr, srcAddr, true);\n+            } else {\n+                TCPPacket.writePacket(tcpBuf, packet, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                        srcAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+                logTCP(false, bytes, receiveSegmentNumber, sendSegmentNumber, dstAddr, srcAddr, false);\n+\n+                receiveSegmentNumber += bytes;\n+\n+                TCPPacket.writePacket(tcpBuf, null, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                        dstAddr.getPort(), TCPPacket.Flag.ACK);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+                logTCP(false, bytes, sendSegmentNumber, receiveSegmentNumber, srcAddr, dstAddr, true);\n+            }\n+\n+            tcpBuf.release();\n+        } else if (msg instanceof DatagramPacket) {\n+            handleUDP(ctx, ((DatagramPacket) msg).duplicate());\n+        } else {\n+            logger.error(\"Discarding Pcap Write for Object {}\", msg);\n+        }\n+    }\n+\n+    private void logTCP(boolean isWriteOperation, int bytes, int sendSegmentNumber, int receiveSegmentNumber,\n+                        InetSocketAddress srcAddr, InetSocketAddress dstAddr, boolean AckOnly) {\n+        if (AckOnly) {\n+            logger.debug(\"Writing TCP ACK, isWriteOperation {}, Segment Number {}, Ack Number {}, Src Addr {}, \"\n+                    + \"Dst Addr {}\", isWriteOperation, sendSegmentNumber, receiveSegmentNumber, dstAddr, srcAddr);\n+        } else {\n+            logger.debug(\"Writing TCP Data of {} Bytes, isWriteOperation {}, Segment Number {}, Ack Number {}, \" +\n+                            \"Src Addr {}, Dst Addr {}\", bytes, isWriteOperation, sendSegmentNumber,\n+                    receiveSegmentNumber, srcAddr, dstAddr);\n+        }\n+    }\n+\n+    private void handleUDP(ChannelHandlerContext ctx, DatagramPacket datagramPacket) throws IOException {\n+        ByteBuf udpBuf = ctx.alloc().buffer();\n+\n+        InetSocketAddress srcAddr = datagramPacket.sender();\n+        InetSocketAddress dstAddr = datagramPacket.recipient();\n+\n+        logger.debug(\"Writing UDP Data of {} Bytes, Src Addr {}, Dst Addr {}\", datagramPacket.content().readableBytes()\n+                , srcAddr, dstAddr);\n+\n+        UDPPacket.writePacket(udpBuf,\n+                datagramPacket.content(),\n+                srcAddr.getPort(),\n+                dstAddr.getPort());\n+\n+        completeUDPWrite(srcAddr, dstAddr, udpBuf, ctx.alloc());\n+\n+        udpBuf.release();\n+    }\n+\n+    private void completeTCPWrite(InetSocketAddress srcAddr, InetSocketAddress dstAddr, ByteBuf tcpBuf,\n+                                  ByteBufAllocator byteBufAllocator) throws IOException {\n+\n+        ByteBuf ipBuf = byteBufAllocator.buffer();\n+        ByteBuf ethernetBuf = byteBufAllocator.buffer();\n+\n+        try {\n+\n+            if (srcAddr.getAddress() instanceof Inet4Address) {\n+                IPPacket.writeTCPv4(ipBuf,\n+                        tcpBuf,\n+                        ipv4ToInt(srcAddr.getAddress()),\n+                        ipv4ToInt(dstAddr.getAddress()));\n+\n+                EthernetPacket.writeIPv4(ethernetBuf, ipBuf);\n+            } else {\n+                IPPacket.writeTCPv6(ipBuf,\n+                        tcpBuf,\n+                        srcAddr.getAddress().getAddress(),\n+                        dstAddr.getAddress().getAddress());\n+\n+                EthernetPacket.writeIPv6(ethernetBuf, ipBuf);\n+            }\n+\n+            pCapWriter.writePacket(byteBufAllocator.buffer(), ethernetBuf);\n+        } catch (IOException ex) {\n+            tcpBuf.release();\n+            throw ex;\n+        } finally {\n+            ipBuf.release();\n+            ethernetBuf.release();\n+        }\n+    }\n+\n+    private void completeUDPWrite(InetSocketAddress srcAddr, InetSocketAddress dstAddr, ByteBuf udpBuf,\n+                                  ByteBufAllocator byteBufAllocator) throws IOException {\n+\n+        ByteBuf ipBuf = byteBufAllocator.buffer();\n+        ByteBuf ethernetBuf = byteBufAllocator.buffer();\n+\n+        try {\n+\n+            if (srcAddr.getAddress() instanceof Inet4Address) {\n+                IPPacket.writeUDPv4(ipBuf,\n+                        udpBuf,\n+                        ipv4ToInt(srcAddr.getAddress()),\n+                        ipv4ToInt(dstAddr.getAddress()));\n+\n+                EthernetPacket.writeIPv4(ethernetBuf, ipBuf);\n+            } else {\n+                IPPacket.writeUDPv6(ipBuf,\n+                        udpBuf,\n+                        srcAddr.getAddress().getAddress(),\n+                        dstAddr.getAddress().getAddress());\n+\n+                EthernetPacket.writeIPv6(ethernetBuf, ipBuf);\n+            }\n+\n+            pCapWriter.writePacket(byteBufAllocator.buffer(), ethernetBuf);\n+        } catch (IOException ex) {\n+            udpBuf.release();\n+            throw ex;\n+        } finally {\n+            ipBuf.release();\n+            ethernetBuf.release();\n+        }\n+    }\n+\n+    @Override\n+    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {\n+\n+        // If `isTCP` is true, then we'll simulate a `FIN` flow.\n+        if (isTCP) {\n+            logger.debug(\"Starting Fake TCP FIN+ACK Flow to close connection\");\n+\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            // Write FIN+ACK with Normal Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                    dstAddr.getPort(), TCPPacket.Flag.FIN, TCPPacket.Flag.ACK);\n+            completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+            // Write FIN+ACK with Reversed Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                    srcAddr.getPort(), TCPPacket.Flag.FIN, TCPPacket.Flag.ACK);\n+            completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+\n+            // Write ACK with Normal Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, sendSegmentNumber + 1, receiveSegmentNumber + 1,\n+                    srcAddr.getPort(), dstAddr.getPort(), TCPPacket.Flag.ACK);\n+            completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+            tcpBuf.release();\n+\n+            logger.debug(\"Finished Fake TCP FIN+ACK Flow to close connection\");\n+        }\n+\n+        this.pCapWriter.close();\n+        super.handlerRemoved(ctx);\n+    }\n+\n+    private int ipv4ToInt(InetAddress inetAddress) {\n+        byte[] octets = inetAddress.getAddress();\n+        assert octets.length == 4;\n+\n+        return (octets[0] & 0xff) << 24 |\n+                (octets[1] & 0xff) << 16 |\n+                (octets[2] & 0xff) << 8 |\n+                (octets[3] & 0xff);\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+\n+        // If `isTCP` is true, then we'll simulate a `RST` flow.\n+        if (isTCP) {\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            // Write RST+ACK with Normal Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                    dstAddr.getPort(), TCPPacket.Flag.RST, TCPPacket.Flag.ACK);\n+            completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+            tcpBuf.release();", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk4MzczOQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r479983739", "bodyText": "I would remove this and let the caller handle this. This is also more consistent as you also don't release the packet here", "author": "normanmaurer", "createdAt": "2020-08-31T08:42:14Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCapWriter.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+\n+final class PCapWriter implements Closeable {\n+    private final SimpleDateFormat sdf = new SimpleDateFormat(\"SSSSSSSSS\");\n+    private final OutputStream outputStream;\n+\n+    /**\n+     * This uses {@link OutputStream} for writing Pcap.\n+     * Pcap Global Header is also written on construction.\n+     *\n+     * @throws IOException If {@link OutputStream#write(byte[])} throws an exception\n+     */\n+    PCapWriter(OutputStream outputStream, ByteBuf byteBuf) throws IOException {\n+        this.outputStream = outputStream;\n+\n+        PcapHeaders.writeGlobalHeader(byteBuf);\n+        byteBuf.readBytes(outputStream, byteBuf.readableBytes());\n+        byteBuf.release();\n+    }\n+\n+    /**\n+     * Write Packet in Pcap OutputStream.\n+     *\n+     * @param packetHeaderBuf Packer Header {@link ByteBuf}\n+     * @param packet          Packet\n+     * @throws IOException If {@link OutputStream#write(byte[])} throws an exception\n+     */\n+    void writePacket(ByteBuf packetHeaderBuf, ByteBuf packet) throws IOException {\n+        long currentTime = System.currentTimeMillis();\n+\n+        String microsecond = sdf.format(new Date(currentTime));\n+        microsecond = microsecond.substring(microsecond.indexOf(\".\") + 1);\n+\n+        PcapHeaders.writePacketHeader(\n+                packetHeaderBuf,\n+                currentTime,\n+                Integer.parseInt(microsecond),\n+                packet.readableBytes(),\n+                packet.readableBytes()\n+        );\n+\n+        packetHeaderBuf.readBytes(outputStream, packetHeaderBuf.readableBytes());\n+        packet.readBytes(outputStream, packet.readableBytes());\n+        packetHeaderBuf.release();", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk4NDA3OQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r479984079", "bodyText": "I think we should better have the caller handle this...", "author": "normanmaurer", "createdAt": "2020-08-31T08:42:53Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCapWriter.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+\n+final class PCapWriter implements Closeable {\n+    private final SimpleDateFormat sdf = new SimpleDateFormat(\"SSSSSSSSS\");\n+    private final OutputStream outputStream;\n+\n+    /**\n+     * This uses {@link OutputStream} for writing Pcap.\n+     * Pcap Global Header is also written on construction.\n+     *\n+     * @throws IOException If {@link OutputStream#write(byte[])} throws an exception\n+     */\n+    PCapWriter(OutputStream outputStream, ByteBuf byteBuf) throws IOException {\n+        this.outputStream = outputStream;\n+\n+        PcapHeaders.writeGlobalHeader(byteBuf);\n+        byteBuf.readBytes(outputStream, byteBuf.readableBytes());\n+        byteBuf.release();", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk4NDI4NA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r479984284", "bodyText": "nit: add default:", "author": "normanmaurer", "createdAt": "2020-08-31T08:43:17Z", "path": "handler/src/main/java/io/netty/handler/pcap/TCPPacket.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class TCPPacket {\n+\n+    private TCPPacket() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Write TCP Packet\n+     *\n+     * @param byteBuf ByteBuf where Packet data will be set\n+     * @param payload Payload of this Packet\n+     * @param srcPort Source Port\n+     * @param dstPort Destination Port\n+     */\n+    static void writePacket(ByteBuf byteBuf, ByteBuf payload, int segmentNumber, int ackNumber, int srcPort, int dstPort, Flag... flags) {\n+        int fin = 0;\n+        int syn = 0;\n+        int rst = 0;\n+        int psh = 0;\n+        int ack = 0;\n+        int urg = 0;\n+        int ece = 0;\n+        int cwr = 0;\n+\n+        for (Flag flag : flags) {\n+            switch (flag) {\n+                case FIN:\n+                    fin = 1;\n+                case SYN:\n+                    syn = 1;\n+                case RST:\n+                    rst = 1;\n+                case PSH:\n+                    psh = 1;\n+                case ACK:\n+                    ack = 1;\n+                case URG:\n+                    urg = 1;\n+                case ECE:\n+                    ece = 1;\n+                case CWR:\n+                    cwr = 1;", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk4NDk0MA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r479984940", "bodyText": "release() is missing", "author": "normanmaurer", "createdAt": "2020-08-31T08:44:27Z", "path": "handler/src/test/java/io/netty/handler/pcap/PCAPWriteHandlerTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.channel.socket.DatagramPacket;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public class PCAPWriteHandlerTest {\n+\n+    @Test\n+    public void udpV4() throws IOException {\n+\n+        ByteBuf byteBuf = Unpooled.buffer();\n+        EmbeddedChannel embeddedChannel = new EmbeddedChannel(new PCAPWriteHandler(\n+                new ByteBufOutputStream(byteBuf), true, false, false\n+        ));\n+\n+        InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.1\", 1000);\n+        InetSocketAddress dstAddr = new InetSocketAddress(\"192.168.1.1\", 50000);\n+\n+        embeddedChannel.writeInbound(new DatagramPacket(Unpooled.wrappedBuffer(\"Meow\".getBytes()), dstAddr, srcAddr));\n+        embeddedChannel.flushInbound();\n+\n+        // Verify Pcap Global Headers\n+        Assert.assertEquals(0xa1b2c3d4, byteBuf.readInt()); // magic_number\n+        Assert.assertEquals(2, byteBuf.readShort());        // version_major\n+        Assert.assertEquals(4, byteBuf.readShort());        // version_minor\n+        Assert.assertEquals(0, byteBuf.readInt());          // thiszone\n+        Assert.assertEquals(0, byteBuf.readInt());          // sigfigs\n+        Assert.assertEquals(0xffff, byteBuf.readInt());     // snaplen\n+        Assert.assertEquals(1, byteBuf.readInt());          // network\n+\n+        // Verify Pcap Packet Header\n+        byteBuf.readInt(); // Just read, we don't care about timestamps for now\n+        byteBuf.readInt(); // Just read, we don't care about timestamps for now\n+        Assert.assertEquals(46, byteBuf.readInt()); // Length of Packet Saved In Pcap\n+        Assert.assertEquals(46, byteBuf.readInt()); // Actual Length of Packet\n+\n+        // -------------------------------------------- Verify Packet --------------------------------------------\n+        // Verify Ethernet Packet\n+        ByteBuf ethernetPacket = byteBuf.readBytes(46);\n+        Assert.assertArrayEquals(new byte[]{-86, -69, -52, -35, -18, -1},\n+                ByteBufUtil.getBytes(ethernetPacket.readBytes(6)));\n+        Assert.assertArrayEquals(new byte[]{-86, -69, -52, -35, -18, -1},\n+                ByteBufUtil.getBytes(ethernetPacket.readBytes(6)));\n+        Assert.assertEquals(0x0800, ethernetPacket.readShort());\n+\n+        // Verify IPv4 Packet\n+        ByteBuf ipv4Packet = ethernetPacket.readBytes(32);\n+        Assert.assertEquals(0x45, ipv4Packet.readByte());    // Version + IHL\n+        Assert.assertEquals(0x00, ipv4Packet.readByte());    // DSCP\n+        Assert.assertEquals(32, ipv4Packet.readShort());     // Length\n+        Assert.assertEquals(0x0000, ipv4Packet.readShort()); // Identification\n+        Assert.assertEquals(0x0000, ipv4Packet.readShort()); // Fragment\n+        Assert.assertEquals((byte) 0xff, ipv4Packet.readByte());      // TTL\n+        Assert.assertEquals((byte) 17, ipv4Packet.readByte());        // Protocol\n+        Assert.assertEquals(0, ipv4Packet.readShort());      // Checksum\n+        Assert.assertEquals(ipv4ToInt(srcAddr.getAddress()), ipv4Packet.readInt()); // Source IPv4 Address\n+        Assert.assertEquals(ipv4ToInt(dstAddr.getAddress()), ipv4Packet.readInt()); // Destination IPv4 Address\n+\n+        // Verify UDP Packet\n+        ByteBuf udpPacket = ipv4Packet.readBytes(12);", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk4NDk4NQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r479984985", "bodyText": "release() is missing", "author": "normanmaurer", "createdAt": "2020-08-31T08:44:31Z", "path": "handler/src/test/java/io/netty/handler/pcap/PCAPWriteHandlerTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.channel.socket.DatagramPacket;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public class PCAPWriteHandlerTest {\n+\n+    @Test\n+    public void udpV4() throws IOException {\n+\n+        ByteBuf byteBuf = Unpooled.buffer();\n+        EmbeddedChannel embeddedChannel = new EmbeddedChannel(new PCAPWriteHandler(\n+                new ByteBufOutputStream(byteBuf), true, false, false\n+        ));\n+\n+        InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.1\", 1000);\n+        InetSocketAddress dstAddr = new InetSocketAddress(\"192.168.1.1\", 50000);\n+\n+        embeddedChannel.writeInbound(new DatagramPacket(Unpooled.wrappedBuffer(\"Meow\".getBytes()), dstAddr, srcAddr));\n+        embeddedChannel.flushInbound();\n+\n+        // Verify Pcap Global Headers\n+        Assert.assertEquals(0xa1b2c3d4, byteBuf.readInt()); // magic_number\n+        Assert.assertEquals(2, byteBuf.readShort());        // version_major\n+        Assert.assertEquals(4, byteBuf.readShort());        // version_minor\n+        Assert.assertEquals(0, byteBuf.readInt());          // thiszone\n+        Assert.assertEquals(0, byteBuf.readInt());          // sigfigs\n+        Assert.assertEquals(0xffff, byteBuf.readInt());     // snaplen\n+        Assert.assertEquals(1, byteBuf.readInt());          // network\n+\n+        // Verify Pcap Packet Header\n+        byteBuf.readInt(); // Just read, we don't care about timestamps for now\n+        byteBuf.readInt(); // Just read, we don't care about timestamps for now\n+        Assert.assertEquals(46, byteBuf.readInt()); // Length of Packet Saved In Pcap\n+        Assert.assertEquals(46, byteBuf.readInt()); // Actual Length of Packet\n+\n+        // -------------------------------------------- Verify Packet --------------------------------------------\n+        // Verify Ethernet Packet\n+        ByteBuf ethernetPacket = byteBuf.readBytes(46);\n+        Assert.assertArrayEquals(new byte[]{-86, -69, -52, -35, -18, -1},\n+                ByteBufUtil.getBytes(ethernetPacket.readBytes(6)));\n+        Assert.assertArrayEquals(new byte[]{-86, -69, -52, -35, -18, -1},\n+                ByteBufUtil.getBytes(ethernetPacket.readBytes(6)));\n+        Assert.assertEquals(0x0800, ethernetPacket.readShort());\n+\n+        // Verify IPv4 Packet\n+        ByteBuf ipv4Packet = ethernetPacket.readBytes(32);", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk4NTAyNg==", "url": "https://github.com/netty/netty/pull/10498#discussion_r479985026", "bodyText": "release() is missing", "author": "normanmaurer", "createdAt": "2020-08-31T08:44:36Z", "path": "handler/src/test/java/io/netty/handler/pcap/PCAPWriteHandlerTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.channel.socket.DatagramPacket;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public class PCAPWriteHandlerTest {\n+\n+    @Test\n+    public void udpV4() throws IOException {\n+\n+        ByteBuf byteBuf = Unpooled.buffer();\n+        EmbeddedChannel embeddedChannel = new EmbeddedChannel(new PCAPWriteHandler(\n+                new ByteBufOutputStream(byteBuf), true, false, false\n+        ));\n+\n+        InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.1\", 1000);\n+        InetSocketAddress dstAddr = new InetSocketAddress(\"192.168.1.1\", 50000);\n+\n+        embeddedChannel.writeInbound(new DatagramPacket(Unpooled.wrappedBuffer(\"Meow\".getBytes()), dstAddr, srcAddr));\n+        embeddedChannel.flushInbound();\n+\n+        // Verify Pcap Global Headers\n+        Assert.assertEquals(0xa1b2c3d4, byteBuf.readInt()); // magic_number\n+        Assert.assertEquals(2, byteBuf.readShort());        // version_major\n+        Assert.assertEquals(4, byteBuf.readShort());        // version_minor\n+        Assert.assertEquals(0, byteBuf.readInt());          // thiszone\n+        Assert.assertEquals(0, byteBuf.readInt());          // sigfigs\n+        Assert.assertEquals(0xffff, byteBuf.readInt());     // snaplen\n+        Assert.assertEquals(1, byteBuf.readInt());          // network\n+\n+        // Verify Pcap Packet Header\n+        byteBuf.readInt(); // Just read, we don't care about timestamps for now\n+        byteBuf.readInt(); // Just read, we don't care about timestamps for now\n+        Assert.assertEquals(46, byteBuf.readInt()); // Length of Packet Saved In Pcap\n+        Assert.assertEquals(46, byteBuf.readInt()); // Actual Length of Packet\n+\n+        // -------------------------------------------- Verify Packet --------------------------------------------\n+        // Verify Ethernet Packet\n+        ByteBuf ethernetPacket = byteBuf.readBytes(46);", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk4NTA4Mw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r479985083", "bodyText": "assert return value", "author": "normanmaurer", "createdAt": "2020-08-31T08:44:43Z", "path": "handler/src/test/java/io/netty/handler/pcap/PCAPWriteHandlerTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.channel.socket.DatagramPacket;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public class PCAPWriteHandlerTest {\n+\n+    @Test\n+    public void udpV4() throws IOException {\n+\n+        ByteBuf byteBuf = Unpooled.buffer();\n+        EmbeddedChannel embeddedChannel = new EmbeddedChannel(new PCAPWriteHandler(\n+                new ByteBufOutputStream(byteBuf), true, false, false\n+        ));\n+\n+        InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.1\", 1000);\n+        InetSocketAddress dstAddr = new InetSocketAddress(\"192.168.1.1\", 50000);\n+\n+        embeddedChannel.writeInbound(new DatagramPacket(Unpooled.wrappedBuffer(\"Meow\".getBytes()), dstAddr, srcAddr));", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk4NTIyNQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r479985225", "bodyText": "use method of NetUtils.", "author": "normanmaurer", "createdAt": "2020-08-31T08:44:56Z", "path": "handler/src/test/java/io/netty/handler/pcap/PCAPWriteHandlerTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.channel.socket.DatagramPacket;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public class PCAPWriteHandlerTest {\n+\n+    @Test\n+    public void udpV4() throws IOException {\n+\n+        ByteBuf byteBuf = Unpooled.buffer();\n+        EmbeddedChannel embeddedChannel = new EmbeddedChannel(new PCAPWriteHandler(\n+                new ByteBufOutputStream(byteBuf), true, false, false\n+        ));\n+\n+        InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.1\", 1000);\n+        InetSocketAddress dstAddr = new InetSocketAddress(\"192.168.1.1\", 50000);\n+\n+        embeddedChannel.writeInbound(new DatagramPacket(Unpooled.wrappedBuffer(\"Meow\".getBytes()), dstAddr, srcAddr));\n+        embeddedChannel.flushInbound();\n+\n+        // Verify Pcap Global Headers\n+        Assert.assertEquals(0xa1b2c3d4, byteBuf.readInt()); // magic_number\n+        Assert.assertEquals(2, byteBuf.readShort());        // version_major\n+        Assert.assertEquals(4, byteBuf.readShort());        // version_minor\n+        Assert.assertEquals(0, byteBuf.readInt());          // thiszone\n+        Assert.assertEquals(0, byteBuf.readInt());          // sigfigs\n+        Assert.assertEquals(0xffff, byteBuf.readInt());     // snaplen\n+        Assert.assertEquals(1, byteBuf.readInt());          // network\n+\n+        // Verify Pcap Packet Header\n+        byteBuf.readInt(); // Just read, we don't care about timestamps for now\n+        byteBuf.readInt(); // Just read, we don't care about timestamps for now\n+        Assert.assertEquals(46, byteBuf.readInt()); // Length of Packet Saved In Pcap\n+        Assert.assertEquals(46, byteBuf.readInt()); // Actual Length of Packet\n+\n+        // -------------------------------------------- Verify Packet --------------------------------------------\n+        // Verify Ethernet Packet\n+        ByteBuf ethernetPacket = byteBuf.readBytes(46);\n+        Assert.assertArrayEquals(new byte[]{-86, -69, -52, -35, -18, -1},\n+                ByteBufUtil.getBytes(ethernetPacket.readBytes(6)));\n+        Assert.assertArrayEquals(new byte[]{-86, -69, -52, -35, -18, -1},\n+                ByteBufUtil.getBytes(ethernetPacket.readBytes(6)));\n+        Assert.assertEquals(0x0800, ethernetPacket.readShort());\n+\n+        // Verify IPv4 Packet\n+        ByteBuf ipv4Packet = ethernetPacket.readBytes(32);\n+        Assert.assertEquals(0x45, ipv4Packet.readByte());    // Version + IHL\n+        Assert.assertEquals(0x00, ipv4Packet.readByte());    // DSCP\n+        Assert.assertEquals(32, ipv4Packet.readShort());     // Length\n+        Assert.assertEquals(0x0000, ipv4Packet.readShort()); // Identification\n+        Assert.assertEquals(0x0000, ipv4Packet.readShort()); // Fragment\n+        Assert.assertEquals((byte) 0xff, ipv4Packet.readByte());      // TTL\n+        Assert.assertEquals((byte) 17, ipv4Packet.readByte());        // Protocol\n+        Assert.assertEquals(0, ipv4Packet.readShort());      // Checksum\n+        Assert.assertEquals(ipv4ToInt(srcAddr.getAddress()), ipv4Packet.readInt()); // Source IPv4 Address\n+        Assert.assertEquals(ipv4ToInt(dstAddr.getAddress()), ipv4Packet.readInt()); // Destination IPv4 Address\n+\n+        // Verify UDP Packet\n+        ByteBuf udpPacket = ipv4Packet.readBytes(12);\n+        Assert.assertEquals(1000, udpPacket.readShort());                  // Source Port\n+        Assert.assertEquals(50000, udpPacket.readShort() & 0xffff); // Destination Port\n+        Assert.assertEquals(12, udpPacket.readShort());                    // Length\n+        Assert.assertEquals(0x0001, udpPacket.readShort());                // Checksum\n+        Assert.assertArrayEquals(\"Meow\".getBytes(), ByteBufUtil.getBytes(udpPacket.readBytes(4))); // Payload\n+\n+        Assert.assertTrue(embeddedChannel.close().isSuccess());\n+    }\n+\n+    private int ipv4ToInt(InetAddress inetAddress) {", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk4NjI5NQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r479986295", "bodyText": "release() is missing for the buffer created by readBytes(5).", "author": "normanmaurer", "createdAt": "2020-08-31T08:46:58Z", "path": "handler/src/test/java/io/netty/handler/pcap/PCAPWriteHandlerTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.channel.socket.DatagramPacket;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public class PCAPWriteHandlerTest {\n+\n+    @Test\n+    public void udpV4() throws IOException {\n+\n+        ByteBuf byteBuf = Unpooled.buffer();\n+        EmbeddedChannel embeddedChannel = new EmbeddedChannel(new PCAPWriteHandler(\n+                new ByteBufOutputStream(byteBuf), true, false, false\n+        ));\n+\n+        InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.1\", 1000);\n+        InetSocketAddress dstAddr = new InetSocketAddress(\"192.168.1.1\", 50000);\n+\n+        embeddedChannel.writeInbound(new DatagramPacket(Unpooled.wrappedBuffer(\"Meow\".getBytes()), dstAddr, srcAddr));\n+        embeddedChannel.flushInbound();\n+\n+        // Verify Pcap Global Headers\n+        Assert.assertEquals(0xa1b2c3d4, byteBuf.readInt()); // magic_number\n+        Assert.assertEquals(2, byteBuf.readShort());        // version_major\n+        Assert.assertEquals(4, byteBuf.readShort());        // version_minor\n+        Assert.assertEquals(0, byteBuf.readInt());          // thiszone\n+        Assert.assertEquals(0, byteBuf.readInt());          // sigfigs\n+        Assert.assertEquals(0xffff, byteBuf.readInt());     // snaplen\n+        Assert.assertEquals(1, byteBuf.readInt());          // network\n+\n+        // Verify Pcap Packet Header\n+        byteBuf.readInt(); // Just read, we don't care about timestamps for now\n+        byteBuf.readInt(); // Just read, we don't care about timestamps for now\n+        Assert.assertEquals(46, byteBuf.readInt()); // Length of Packet Saved In Pcap\n+        Assert.assertEquals(46, byteBuf.readInt()); // Actual Length of Packet\n+\n+        // -------------------------------------------- Verify Packet --------------------------------------------\n+        // Verify Ethernet Packet\n+        ByteBuf ethernetPacket = byteBuf.readBytes(46);\n+        Assert.assertArrayEquals(new byte[]{-86, -69, -52, -35, -18, -1},\n+                ByteBufUtil.getBytes(ethernetPacket.readBytes(6)));\n+        Assert.assertArrayEquals(new byte[]{-86, -69, -52, -35, -18, -1},\n+                ByteBufUtil.getBytes(ethernetPacket.readBytes(6)));\n+        Assert.assertEquals(0x0800, ethernetPacket.readShort());\n+\n+        // Verify IPv4 Packet\n+        ByteBuf ipv4Packet = ethernetPacket.readBytes(32);\n+        Assert.assertEquals(0x45, ipv4Packet.readByte());    // Version + IHL\n+        Assert.assertEquals(0x00, ipv4Packet.readByte());    // DSCP\n+        Assert.assertEquals(32, ipv4Packet.readShort());     // Length\n+        Assert.assertEquals(0x0000, ipv4Packet.readShort()); // Identification\n+        Assert.assertEquals(0x0000, ipv4Packet.readShort()); // Fragment\n+        Assert.assertEquals((byte) 0xff, ipv4Packet.readByte());      // TTL\n+        Assert.assertEquals((byte) 17, ipv4Packet.readByte());        // Protocol\n+        Assert.assertEquals(0, ipv4Packet.readShort());      // Checksum\n+        Assert.assertEquals(ipv4ToInt(srcAddr.getAddress()), ipv4Packet.readInt()); // Source IPv4 Address\n+        Assert.assertEquals(ipv4ToInt(dstAddr.getAddress()), ipv4Packet.readInt()); // Destination IPv4 Address\n+\n+        // Verify UDP Packet\n+        ByteBuf udpPacket = ipv4Packet.readBytes(12);\n+        Assert.assertEquals(1000, udpPacket.readShort());                  // Source Port\n+        Assert.assertEquals(50000, udpPacket.readShort() & 0xffff); // Destination Port\n+        Assert.assertEquals(12, udpPacket.readShort());                    // Length\n+        Assert.assertEquals(0x0001, udpPacket.readShort());                // Checksum\n+        Assert.assertArrayEquals(\"Meow\".getBytes(), ByteBufUtil.getBytes(udpPacket.readBytes(4))); // Payload", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDEzNDQyMA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480134420", "bodyText": "You mean ByteBuf udpPacket = ipv4Packet.readBytes(12); ?", "author": "hyperxpro", "createdAt": "2020-08-31T13:34:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk4NjI5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk4NjM2MA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r479986360", "bodyText": "getBytes(Charset)", "author": "normanmaurer", "createdAt": "2020-08-31T08:47:06Z", "path": "handler/src/test/java/io/netty/handler/pcap/PCAPWriteHandlerTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.channel.socket.DatagramPacket;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public class PCAPWriteHandlerTest {\n+\n+    @Test\n+    public void udpV4() throws IOException {\n+\n+        ByteBuf byteBuf = Unpooled.buffer();\n+        EmbeddedChannel embeddedChannel = new EmbeddedChannel(new PCAPWriteHandler(\n+                new ByteBufOutputStream(byteBuf), true, false, false\n+        ));\n+\n+        InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.1\", 1000);\n+        InetSocketAddress dstAddr = new InetSocketAddress(\"192.168.1.1\", 50000);\n+\n+        embeddedChannel.writeInbound(new DatagramPacket(Unpooled.wrappedBuffer(\"Meow\".getBytes()), dstAddr, srcAddr));\n+        embeddedChannel.flushInbound();\n+\n+        // Verify Pcap Global Headers\n+        Assert.assertEquals(0xa1b2c3d4, byteBuf.readInt()); // magic_number\n+        Assert.assertEquals(2, byteBuf.readShort());        // version_major\n+        Assert.assertEquals(4, byteBuf.readShort());        // version_minor\n+        Assert.assertEquals(0, byteBuf.readInt());          // thiszone\n+        Assert.assertEquals(0, byteBuf.readInt());          // sigfigs\n+        Assert.assertEquals(0xffff, byteBuf.readInt());     // snaplen\n+        Assert.assertEquals(1, byteBuf.readInt());          // network\n+\n+        // Verify Pcap Packet Header\n+        byteBuf.readInt(); // Just read, we don't care about timestamps for now\n+        byteBuf.readInt(); // Just read, we don't care about timestamps for now\n+        Assert.assertEquals(46, byteBuf.readInt()); // Length of Packet Saved In Pcap\n+        Assert.assertEquals(46, byteBuf.readInt()); // Actual Length of Packet\n+\n+        // -------------------------------------------- Verify Packet --------------------------------------------\n+        // Verify Ethernet Packet\n+        ByteBuf ethernetPacket = byteBuf.readBytes(46);\n+        Assert.assertArrayEquals(new byte[]{-86, -69, -52, -35, -18, -1},\n+                ByteBufUtil.getBytes(ethernetPacket.readBytes(6)));\n+        Assert.assertArrayEquals(new byte[]{-86, -69, -52, -35, -18, -1},\n+                ByteBufUtil.getBytes(ethernetPacket.readBytes(6)));\n+        Assert.assertEquals(0x0800, ethernetPacket.readShort());\n+\n+        // Verify IPv4 Packet\n+        ByteBuf ipv4Packet = ethernetPacket.readBytes(32);\n+        Assert.assertEquals(0x45, ipv4Packet.readByte());    // Version + IHL\n+        Assert.assertEquals(0x00, ipv4Packet.readByte());    // DSCP\n+        Assert.assertEquals(32, ipv4Packet.readShort());     // Length\n+        Assert.assertEquals(0x0000, ipv4Packet.readShort()); // Identification\n+        Assert.assertEquals(0x0000, ipv4Packet.readShort()); // Fragment\n+        Assert.assertEquals((byte) 0xff, ipv4Packet.readByte());      // TTL\n+        Assert.assertEquals((byte) 17, ipv4Packet.readByte());        // Protocol\n+        Assert.assertEquals(0, ipv4Packet.readShort());      // Checksum\n+        Assert.assertEquals(ipv4ToInt(srcAddr.getAddress()), ipv4Packet.readInt()); // Source IPv4 Address\n+        Assert.assertEquals(ipv4ToInt(dstAddr.getAddress()), ipv4Packet.readInt()); // Destination IPv4 Address\n+\n+        // Verify UDP Packet\n+        ByteBuf udpPacket = ipv4Packet.readBytes(12);\n+        Assert.assertEquals(1000, udpPacket.readShort());                  // Source Port\n+        Assert.assertEquals(50000, udpPacket.readShort() & 0xffff); // Destination Port\n+        Assert.assertEquals(12, udpPacket.readShort());                    // Length\n+        Assert.assertEquals(0x0001, udpPacket.readShort());                // Checksum\n+        Assert.assertArrayEquals(\"Meow\".getBytes(), ByteBufUtil.getBytes(udpPacket.readBytes(4))); // Payload", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk4NjYyMQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r479986621", "bodyText": "Please make it clear in the name that this is a MAC address.\nAlso, please use an address in the range reserved for documentation and examples: 00-00-5E-00-53-00 through 00-00-5E-00-53-FF. See RFC7042.", "author": "chrisvest", "createdAt": "2020-08-31T08:47:41Z", "path": "handler/src/main/java/io/netty/handler/pcap/EthernetPacket.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class EthernetPacket {\n+\n+    /**\n+     * AA:BB:CC:DD:EE:FF\n+     */\n+    private static final byte[] DUMMY_ADDRESS = new byte[]{-86, -69, -52, -35, -18, -1};", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA4NTk0MA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480085940", "bodyText": "It would also be a good idea to have different source and destination addresses, so they can be verified in tests independently.", "author": "chrisvest", "createdAt": "2020-08-31T12:07:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk4NjYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk5NjY1Ng==", "url": "https://github.com/netty/netty/pull/10498#discussion_r479996656", "bodyText": "Layer 2 ethernet frames end with a CRC-32 checksum.", "author": "chrisvest", "createdAt": "2020-08-31T09:06:47Z", "path": "handler/src/main/java/io/netty/handler/pcap/EthernetPacket.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class EthernetPacket {\n+\n+    /**\n+     * AA:BB:CC:DD:EE:FF\n+     */\n+    private static final byte[] DUMMY_ADDRESS = new byte[]{-86, -69, -52, -35, -18, -1};\n+\n+    private EthernetPacket() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Write IPv4 Ethernet Packet. It uses a dummy MAC address for both source and destination.\n+     *\n+     * @param byteBuf    ByteBuf where Ethernet Packet data will be set\n+     * @param payload    Payload of IPv4\n+     */\n+    static void writeIPv4(ByteBuf byteBuf, ByteBuf payload) {\n+        EthernetPacket.writePacket(byteBuf, payload, DUMMY_ADDRESS, DUMMY_ADDRESS, 0x0800);\n+    }\n+\n+    /**\n+     * Write IPv6 Ethernet Packet. It uses a dummy MAC address for both source and destination.\n+     *\n+     * @param byteBuf    ByteBuf where Ethernet Packet data will be set\n+     * @param payload    Payload of IPv6\n+     */\n+    static void writeIPv6(ByteBuf byteBuf, ByteBuf payload) {\n+        EthernetPacket.writePacket(byteBuf, payload, DUMMY_ADDRESS, DUMMY_ADDRESS, 0x86dd);\n+    }\n+\n+    /**\n+     * Write IPv6 Ethernet Packet\n+     *\n+     * @param byteBuf    ByteBuf where Ethernet Packet data will be set\n+     * @param payload    Payload of IPv6\n+     * @param srcAddress Source MAC Address\n+     * @param dstAddress Destination MAC Address\n+     * @param type Type of Frame\n+     */\n+    private static void writePacket(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress,\n+                                    int type) {\n+        byteBuf.writeBytes(dstAddress); // Destination MAC Address\n+        byteBuf.writeBytes(srcAddress); // Source MAC Address\n+        byteBuf.writeShort(type);       // Frame Type (IPv4 or IPv6)\n+        byteBuf.writeBytes(payload);    // Payload of L3\n+    }", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDIwMzAxMA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480203010", "bodyText": "Captured real traffic with Wireshark. Didn't find CRC-32 in Ethernet Packet. :-| If I add CRC-32, It doesn't display in Ethernet Tab but marks it as VSS Monitoring Ethernet trailer in UDP packet,", "author": "hyperxpro", "createdAt": "2020-08-31T15:22:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk5NjY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAyODQxMA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r481028410", "bodyText": "Ok, weird. Maybe the docs I read are wrong. \ud83e\udd37", "author": "chrisvest", "createdAt": "2020-09-01T10:11:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk5NjY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM2MDk4OA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r481360988", "bodyText": "I read the same. But adding CRC-32, at last, is giving weird results. Through the entire development, I'm focused on Wireshark usability. Wireshark didn't give any errors so hope it's correct. :p", "author": "hyperxpro", "createdAt": "2020-09-01T18:54:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTk5NjY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDAwMTYyMA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480001620", "bodyText": "Create a constant for 0x0800.", "author": "chrisvest", "createdAt": "2020-08-31T09:16:47Z", "path": "handler/src/main/java/io/netty/handler/pcap/EthernetPacket.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class EthernetPacket {\n+\n+    /**\n+     * AA:BB:CC:DD:EE:FF\n+     */\n+    private static final byte[] DUMMY_ADDRESS = new byte[]{-86, -69, -52, -35, -18, -1};\n+\n+    private EthernetPacket() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Write IPv4 Ethernet Packet. It uses a dummy MAC address for both source and destination.\n+     *\n+     * @param byteBuf    ByteBuf where Ethernet Packet data will be set\n+     * @param payload    Payload of IPv4\n+     */\n+    static void writeIPv4(ByteBuf byteBuf, ByteBuf payload) {\n+        EthernetPacket.writePacket(byteBuf, payload, DUMMY_ADDRESS, DUMMY_ADDRESS, 0x0800);", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDAwMTc3NA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480001774", "bodyText": "Create a constant for 0x86dd.", "author": "chrisvest", "createdAt": "2020-08-31T09:17:01Z", "path": "handler/src/main/java/io/netty/handler/pcap/EthernetPacket.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class EthernetPacket {\n+\n+    /**\n+     * AA:BB:CC:DD:EE:FF\n+     */\n+    private static final byte[] DUMMY_ADDRESS = new byte[]{-86, -69, -52, -35, -18, -1};\n+\n+    private EthernetPacket() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Write IPv4 Ethernet Packet. It uses a dummy MAC address for both source and destination.\n+     *\n+     * @param byteBuf    ByteBuf where Ethernet Packet data will be set\n+     * @param payload    Payload of IPv4\n+     */\n+    static void writeIPv4(ByteBuf byteBuf, ByteBuf payload) {\n+        EthernetPacket.writePacket(byteBuf, payload, DUMMY_ADDRESS, DUMMY_ADDRESS, 0x0800);\n+    }\n+\n+    /**\n+     * Write IPv6 Ethernet Packet. It uses a dummy MAC address for both source and destination.\n+     *\n+     * @param byteBuf    ByteBuf where Ethernet Packet data will be set\n+     * @param payload    Payload of IPv6\n+     */\n+    static void writeIPv6(ByteBuf byteBuf, ByteBuf payload) {\n+        EthernetPacket.writePacket(byteBuf, payload, DUMMY_ADDRESS, DUMMY_ADDRESS, 0x86dd);", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDAwNTAxNw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480005017", "bodyText": "Please move the constants into the Flag enum, and combine them into the tcpFlags variable with bit-wise OR. That'll be much shorter.", "author": "chrisvest", "createdAt": "2020-08-31T09:23:29Z", "path": "handler/src/main/java/io/netty/handler/pcap/TCPPacket.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class TCPPacket {\n+\n+    private TCPPacket() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Write TCP Packet\n+     *\n+     * @param byteBuf ByteBuf where Packet data will be set\n+     * @param payload Payload of this Packet\n+     * @param srcPort Source Port\n+     * @param dstPort Destination Port\n+     */\n+    static void writePacket(ByteBuf byteBuf, ByteBuf payload, int segmentNumber, int ackNumber, int srcPort, int dstPort, Flag... flags) {\n+        int fin = 0;\n+        int syn = 0;\n+        int rst = 0;\n+        int psh = 0;\n+        int ack = 0;\n+        int urg = 0;\n+        int ece = 0;\n+        int cwr = 0;\n+\n+        for (Flag flag : flags) {\n+            switch (flag) {\n+                case FIN:\n+                    fin = 1;\n+                case SYN:\n+                    syn = 1;\n+                case RST:\n+                    rst = 1;\n+                case PSH:\n+                    psh = 1;\n+                case ACK:\n+                    ack = 1;\n+                case URG:\n+                    urg = 1;\n+                case ECE:\n+                    ece = 1;\n+                case CWR:\n+                    cwr = 1;\n+            }\n+        }\n+\n+        int tcpFlags = fin << 0 |\n+                syn << 1 |\n+                rst << 2 |\n+                psh << 3 |\n+                ack << 4 |\n+                urg << 5 |\n+                ece << 6 |\n+                cwr << 7;", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM1NTQ0NQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480355445", "bodyText": "Tried. Makes code more complex.", "author": "hyperxpro", "createdAt": "2020-08-31T19:36:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDAwNTAxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTAyOTMxNw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r481029317", "bodyText": "Not sure what you tried. It doesn't seem more complex to me:\nIndex: handler/src/main/java/io/netty/handler/pcap/TCPPacket.java\nIDEA additional info:\nSubsystem: com.intellij.openapi.diff.impl.patch.CharsetEP\n<+>UTF-8\n===================================================================\n--- handler/src/main/java/io/netty/handler/pcap/TCPPacket.java\t(revision 41c98e5e93537a0ff66f85490c616337e3e6ec53)\n+++ handler/src/main/java/io/netty/handler/pcap/TCPPacket.java\t(date 1598953668767)\n@@ -56,53 +56,27 @@\n     }\n \n     enum TCPFlag {\n-        FIN,\n-        SYN,\n-        RST,\n-        PSH,\n-        ACK,\n-        URG,\n-        ECE,\n-        CWR;\n+        FIN(1),\n+        SYN(1 << 1),\n+        RST(1 << 2),\n+        PSH(1 << 3),\n+        ACK(1 << 4),\n+        URG(1 << 5),\n+        ECE(1 << 6),\n+        CWR(1 << 7);\n+        \n+        final int value;\n+        \n+        TCPFlag(int value) {\n+            this.value = value;\n+        }\n \n         static int getFlag(TCPFlag... tcpFlags) {\n-            int fin = 0;\n-            int syn = 0;\n-            int rst = 0;\n-            int psh = 0;\n-            int ack = 0;\n-            int urg = 0;\n-            int ece = 0;\n-            int cwr = 0;\n-\n+            int flags = 0;\n             for (TCPFlag tcpFlag : tcpFlags) {\n-                if (tcpFlag == TCPFlag.FIN) {\n-                    fin = 1;\n-                } else if (tcpFlag == TCPFlag.SYN) {\n-                    syn = 1;\n-                } else if (tcpFlag == TCPFlag.RST) {\n-                    rst = 1;\n-                } else if (tcpFlag == TCPFlag.PSH) {\n-                    psh = 1;\n-                } else if (tcpFlag == TCPFlag.ACK) {\n-                    ack = 1;\n-                } else if (tcpFlag == TCPFlag.URG) {\n-                    urg = 1;\n-                } else if (tcpFlag == TCPFlag.ECE) {\n-                    ece = 1;\n-                } else if (tcpFlag == TCPFlag.CWR) {\n-                    cwr = 1;\n-                }\n+                flags |= tcpFlag.value;\n             }\n-\n-            return  fin << 0 |\n-                    syn << 1 |\n-                    rst << 2 |\n-                    psh << 3 |\n-                    ack << 4 |\n-                    urg << 5 |\n-                    ece << 6 |\n-                    cwr << 7;\n+            return  flags;\n         }\n     }\n }", "author": "chrisvest", "createdAt": "2020-09-01T10:12:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDAwNTAxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTIwMDAzOA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r481200038", "bodyText": "Alright. Get it.", "author": "hyperxpro", "createdAt": "2020-09-01T14:54:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDAwNTAxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDAwNTQwMA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480005400", "bodyText": "Call this TcpFlag or something, so the context is clear.", "author": "chrisvest", "createdAt": "2020-08-31T09:24:16Z", "path": "handler/src/main/java/io/netty/handler/pcap/TCPPacket.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class TCPPacket {\n+\n+    private TCPPacket() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Write TCP Packet\n+     *\n+     * @param byteBuf ByteBuf where Packet data will be set\n+     * @param payload Payload of this Packet\n+     * @param srcPort Source Port\n+     * @param dstPort Destination Port\n+     */\n+    static void writePacket(ByteBuf byteBuf, ByteBuf payload, int segmentNumber, int ackNumber, int srcPort, int dstPort, Flag... flags) {\n+        int fin = 0;\n+        int syn = 0;\n+        int rst = 0;\n+        int psh = 0;\n+        int ack = 0;\n+        int urg = 0;\n+        int ece = 0;\n+        int cwr = 0;\n+\n+        for (Flag flag : flags) {\n+            switch (flag) {\n+                case FIN:\n+                    fin = 1;\n+                case SYN:\n+                    syn = 1;\n+                case RST:\n+                    rst = 1;\n+                case PSH:\n+                    psh = 1;\n+                case ACK:\n+                    ack = 1;\n+                case URG:\n+                    urg = 1;\n+                case ECE:\n+                    ece = 1;\n+                case CWR:\n+                    cwr = 1;\n+            }\n+        }\n+\n+        int tcpFlags = fin << 0 |\n+                syn << 1 |\n+                rst << 2 |\n+                psh << 3 |\n+                ack << 4 |\n+                urg << 5 |\n+                ece << 6 |\n+                cwr << 7;\n+\n+        byteBuf.writeShort(srcPort);     // Source Port\n+        byteBuf.writeShort(dstPort);     // Destination Port\n+        byteBuf.writeInt(segmentNumber); // Segment Number\n+        byteBuf.writeInt(ackNumber);     // Acknowledgment Number\n+        byteBuf.writeShort(5 << 12 | tcpFlags); // Flags\n+        byteBuf.writeShort(65535);       // Window Size\n+        byteBuf.writeShort(0x0001);      // Checksum\n+        byteBuf.writeShort(0);           // Urgent Pointer\n+\n+        if (payload != null) {\n+            byteBuf.writeBytes(payload); //  Payload of Data\n+        }\n+    }\n+\n+    enum Flag {", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDAxNTA2OA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480015068", "bodyText": "Please also specify what it means when these parameters are false.", "author": "chrisvest", "createdAt": "2020-08-31T09:43:32Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCAPWriteHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public final class PCAPWriteHandler extends ChannelDuplexHandler {\n+\n+    private final InternalLogger logger = InternalLoggerFactory.getInstance(PCAPWriteHandler.class);\n+\n+    /**\n+     * TCP Sender Segment Number.\n+     */\n+    private int sendSegmentNumber = 1;\n+\n+    /**\n+     * TCP Receiver Segment Number\n+     */\n+    private int receiveSegmentNumber = 1;\n+\n+    /**\n+     * Source Address [TCP ONLY]\n+     */\n+    private InetSocketAddress srcAddr;\n+\n+    /**\n+     * Destination Address [TCP ONLY]\n+     */\n+    private InetSocketAddress dstAddr;\n+\n+    private final OutputStream outputStream;\n+    private PCapWriter pCapWriter;\n+    private final boolean isTCP;\n+    private final boolean isServer;\n+    private final boolean captureZeroByte;\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code isTCP}, {@code isServer} and {@code captureZeroByte} are set to {@code false}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream) {\n+        this(outputStream, false, false, false);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code captureZeroByte} is set to {@code false}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     * @param isTCP        {@code true} to capture TCP packets\n+     * @param isServer     {@code true} if we'll capture packet as server\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean isTCP, boolean isServer) {\n+        this(outputStream, isTCP, isServer, false);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance\n+     *\n+     * @param outputStream    OutputStream where Pcap data will be written\n+     * @param isTCP           {@code true} to capture TCP packets\n+     * @param isServer        {@code true} if we'll capture packet as server\n+     * @param captureZeroByte {@code true} if we'll capture packets with 0 bytes", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDAyMzgyMg==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480023822", "bodyText": "Maybe you don't need the isTCP field if you test if ctx.channel() is an instance of DatagramChannel.", "author": "chrisvest", "createdAt": "2020-08-31T10:01:40Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCAPWriteHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public final class PCAPWriteHandler extends ChannelDuplexHandler {\n+\n+    private final InternalLogger logger = InternalLoggerFactory.getInstance(PCAPWriteHandler.class);\n+\n+    /**\n+     * TCP Sender Segment Number.\n+     */\n+    private int sendSegmentNumber = 1;\n+\n+    /**\n+     * TCP Receiver Segment Number\n+     */\n+    private int receiveSegmentNumber = 1;\n+\n+    /**\n+     * Source Address [TCP ONLY]\n+     */\n+    private InetSocketAddress srcAddr;\n+\n+    /**\n+     * Destination Address [TCP ONLY]\n+     */\n+    private InetSocketAddress dstAddr;\n+\n+    private final OutputStream outputStream;\n+    private PCapWriter pCapWriter;\n+    private final boolean isTCP;", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDAyNTg4Mw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480025883", "bodyText": "Can we request a pre-sized buffer?", "author": "chrisvest", "createdAt": "2020-08-31T10:06:09Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCAPWriteHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public final class PCAPWriteHandler extends ChannelDuplexHandler {\n+\n+    private final InternalLogger logger = InternalLoggerFactory.getInstance(PCAPWriteHandler.class);\n+\n+    /**\n+     * TCP Sender Segment Number.\n+     */\n+    private int sendSegmentNumber = 1;\n+\n+    /**\n+     * TCP Receiver Segment Number\n+     */\n+    private int receiveSegmentNumber = 1;\n+\n+    /**\n+     * Source Address [TCP ONLY]\n+     */\n+    private InetSocketAddress srcAddr;\n+\n+    /**\n+     * Destination Address [TCP ONLY]\n+     */\n+    private InetSocketAddress dstAddr;\n+\n+    private final OutputStream outputStream;\n+    private PCapWriter pCapWriter;\n+    private final boolean isTCP;\n+    private final boolean isServer;\n+    private final boolean captureZeroByte;\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code isTCP}, {@code isServer} and {@code captureZeroByte} are set to {@code false}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream) {\n+        this(outputStream, false, false, false);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code captureZeroByte} is set to {@code false}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     * @param isTCP        {@code true} to capture TCP packets\n+     * @param isServer     {@code true} if we'll capture packet as server\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean isTCP, boolean isServer) {\n+        this(outputStream, isTCP, isServer, false);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance\n+     *\n+     * @param outputStream    OutputStream where Pcap data will be written\n+     * @param isTCP           {@code true} to capture TCP packets\n+     * @param isServer        {@code true} if we'll capture packet as server\n+     * @param captureZeroByte {@code true} if we'll capture packets with 0 bytes\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean isTCP, boolean isServer, boolean captureZeroByte) {\n+        this.outputStream = outputStream;\n+        this.isTCP = isTCP;\n+        this.isServer = isServer;\n+        this.captureZeroByte = captureZeroByte;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        this.pCapWriter = new PCapWriter(this.outputStream, ctx.alloc().buffer());\n+\n+        /*\n+         * If `isServer` is set to true, it means we'll be receiving data from client.\n+         * In this case, Source Address will be `remoteAddress` and Destination Address\n+         * will be `localAddress`.\n+         *\n+         * If `isServer` is set to false, it means we'll be sending data to server.\n+         * In this case, Source Address will be `localAddress` and Destination Address\n+         * will be `remoteAddress`.\n+         */\n+        if (isTCP) {\n+            if (isServer) {\n+                srcAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().localAddress();\n+            } else {\n+                srcAddr = (InetSocketAddress) ctx.channel().localAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+            }\n+        }\n+\n+        // If `isTCP` is true, then we'll simulate a fake handshake.\n+        if (isTCP) {\n+            logger.debug(\"Starting Fake TCP 3-Way Handshake\");\n+\n+            ByteBuf tcpBuf = ctx.alloc().buffer();", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE4MzY5MQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480183691", "bodyText": "We can but not really useful since we know what already know we'll be doing exactly.", "author": "hyperxpro", "createdAt": "2020-08-31T14:51:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDAyNTg4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDAyNTk4MQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480025981", "bodyText": "Release in finally block.", "author": "chrisvest", "createdAt": "2020-08-31T10:06:24Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCAPWriteHandler.java", "diffHunk": "@@ -0,0 +1,372 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public final class PCAPWriteHandler extends ChannelDuplexHandler {\n+\n+    private final InternalLogger logger = InternalLoggerFactory.getInstance(PCAPWriteHandler.class);\n+\n+    /**\n+     * TCP Sender Segment Number.\n+     */\n+    private int sendSegmentNumber = 1;\n+\n+    /**\n+     * TCP Receiver Segment Number\n+     */\n+    private int receiveSegmentNumber = 1;\n+\n+    /**\n+     * Source Address [TCP ONLY]\n+     */\n+    private InetSocketAddress srcAddr;\n+\n+    /**\n+     * Destination Address [TCP ONLY]\n+     */\n+    private InetSocketAddress dstAddr;\n+\n+    private final OutputStream outputStream;\n+    private PCapWriter pCapWriter;\n+    private final boolean isTCP;\n+    private final boolean isServer;\n+    private final boolean captureZeroByte;\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code isTCP}, {@code isServer} and {@code captureZeroByte} are set to {@code false}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream) {\n+        this(outputStream, false, false, false);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code captureZeroByte} is set to {@code false}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     * @param isTCP        {@code true} to capture TCP packets\n+     * @param isServer     {@code true} if we'll capture packet as server\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean isTCP, boolean isServer) {\n+        this(outputStream, isTCP, isServer, false);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance\n+     *\n+     * @param outputStream    OutputStream where Pcap data will be written\n+     * @param isTCP           {@code true} to capture TCP packets\n+     * @param isServer        {@code true} if we'll capture packet as server\n+     * @param captureZeroByte {@code true} if we'll capture packets with 0 bytes\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean isTCP, boolean isServer, boolean captureZeroByte) {\n+        this.outputStream = outputStream;\n+        this.isTCP = isTCP;\n+        this.isServer = isServer;\n+        this.captureZeroByte = captureZeroByte;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        this.pCapWriter = new PCapWriter(this.outputStream, ctx.alloc().buffer());\n+\n+        /*\n+         * If `isServer` is set to true, it means we'll be receiving data from client.\n+         * In this case, Source Address will be `remoteAddress` and Destination Address\n+         * will be `localAddress`.\n+         *\n+         * If `isServer` is set to false, it means we'll be sending data to server.\n+         * In this case, Source Address will be `localAddress` and Destination Address\n+         * will be `remoteAddress`.\n+         */\n+        if (isTCP) {\n+            if (isServer) {\n+                srcAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().localAddress();\n+            } else {\n+                srcAddr = (InetSocketAddress) ctx.channel().localAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+            }\n+        }\n+\n+        // If `isTCP` is true, then we'll simulate a fake handshake.\n+        if (isTCP) {\n+            logger.debug(\"Starting Fake TCP 3-Way Handshake\");\n+\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            // Write SYN with Normal Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, 0, 0, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.Flag.SYN);\n+            completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+            // Write SYN+ACK with Reversed Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, 0, 1, dstAddr.getPort(), srcAddr.getPort(), TCPPacket.Flag.SYN,\n+                    TCPPacket.Flag.ACK);\n+            completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+\n+            // Write ACK with Normal Source and Destination Address\n+            TCPPacket.writePacket(tcpBuf, null, 1, 1, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.Flag.ACK);\n+            completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+            tcpBuf.release();", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDAyNzczMg==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480027732", "bodyText": "Please define a constant for 17.", "author": "chrisvest", "createdAt": "2020-08-31T10:10:09Z", "path": "handler/src/main/java/io/netty/handler/pcap/IPPacket.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class IPPacket {\n+\n+    private IPPacket() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Write IPv4 Packet for UDP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of UDP\n+     * @param srcAddress Source IPv4 Address\n+     * @param dstAddress Destination IPv4 Address\n+     */\n+    static void writeUDPv4(ByteBuf byteBuf, ByteBuf payload, int srcAddress, int dstAddress) {\n+        writePacketv4(byteBuf, payload, 17, srcAddress, dstAddress);", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDAyNzg5NQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480027895", "bodyText": "Please define a constant for 6.", "author": "chrisvest", "createdAt": "2020-08-31T10:10:29Z", "path": "handler/src/main/java/io/netty/handler/pcap/IPPacket.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class IPPacket {\n+\n+    private IPPacket() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Write IPv4 Packet for UDP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of UDP\n+     * @param srcAddress Source IPv4 Address\n+     * @param dstAddress Destination IPv4 Address\n+     */\n+    static void writeUDPv4(ByteBuf byteBuf, ByteBuf payload, int srcAddress, int dstAddress) {\n+        writePacketv4(byteBuf, payload, 17, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Write IPv6 Packet for UDP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of UDP\n+     * @param srcAddress Source IPv6 Address\n+     * @param dstAddress Destination IPv6 Address\n+     */\n+    static void writeUDPv6(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress) {\n+        writePacketv6(byteBuf, payload, 17, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Write IPv4 Packet for TCP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of TCP\n+     * @param srcAddress Source IPv4 Address\n+     * @param dstAddress Destination IPv4 Address\n+     */\n+    static void writeTCPv4(ByteBuf byteBuf, ByteBuf payload, int srcAddress, int dstAddress) {\n+        writePacketv4(byteBuf, payload, 6, srcAddress, dstAddress);", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDAyOTIwNA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480029204", "bodyText": "Please define a TCP_HEADER_SIZE constant for 20.", "author": "chrisvest", "createdAt": "2020-08-31T10:13:17Z", "path": "handler/src/main/java/io/netty/handler/pcap/IPPacket.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class IPPacket {\n+\n+    private IPPacket() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Write IPv4 Packet for UDP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of UDP\n+     * @param srcAddress Source IPv4 Address\n+     * @param dstAddress Destination IPv4 Address\n+     */\n+    static void writeUDPv4(ByteBuf byteBuf, ByteBuf payload, int srcAddress, int dstAddress) {\n+        writePacketv4(byteBuf, payload, 17, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Write IPv6 Packet for UDP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of UDP\n+     * @param srcAddress Source IPv6 Address\n+     * @param dstAddress Destination IPv6 Address\n+     */\n+    static void writeUDPv6(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress) {\n+        writePacketv6(byteBuf, payload, 17, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Write IPv4 Packet for TCP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of TCP\n+     * @param srcAddress Source IPv4 Address\n+     * @param dstAddress Destination IPv4 Address\n+     */\n+    static void writeTCPv4(ByteBuf byteBuf, ByteBuf payload, int srcAddress, int dstAddress) {\n+        writePacketv4(byteBuf, payload, 6, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Write IPv6 Packet for TCP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of TCP\n+     * @param srcAddress Source IPv6 Address\n+     * @param dstAddress Destination IPv6 Address\n+     */\n+    static void writeTCPv6(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress) {\n+        writePacketv6(byteBuf, payload, 6, srcAddress, dstAddress);\n+    }\n+\n+    private static void writePacketv4(ByteBuf byteBuf, ByteBuf payload, int protocol, int srcAddress,\n+                                      int dstAddress) {\n+        byteBuf.writeByte(0x45);      //  Version + IHL\n+        byteBuf.writeByte(0x00);      //  DSCP\n+        byteBuf.writeShort(payload.readableBytes() + 20); // Length", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDAyOTQ5NA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480029494", "bodyText": "Please define a MAX_TTL or something like that, for 0xFF.", "author": "chrisvest", "createdAt": "2020-08-31T10:13:56Z", "path": "handler/src/main/java/io/netty/handler/pcap/IPPacket.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class IPPacket {\n+\n+    private IPPacket() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Write IPv4 Packet for UDP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of UDP\n+     * @param srcAddress Source IPv4 Address\n+     * @param dstAddress Destination IPv4 Address\n+     */\n+    static void writeUDPv4(ByteBuf byteBuf, ByteBuf payload, int srcAddress, int dstAddress) {\n+        writePacketv4(byteBuf, payload, 17, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Write IPv6 Packet for UDP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of UDP\n+     * @param srcAddress Source IPv6 Address\n+     * @param dstAddress Destination IPv6 Address\n+     */\n+    static void writeUDPv6(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress) {\n+        writePacketv6(byteBuf, payload, 17, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Write IPv4 Packet for TCP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of TCP\n+     * @param srcAddress Source IPv4 Address\n+     * @param dstAddress Destination IPv4 Address\n+     */\n+    static void writeTCPv4(ByteBuf byteBuf, ByteBuf payload, int srcAddress, int dstAddress) {\n+        writePacketv4(byteBuf, payload, 6, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Write IPv6 Packet for TCP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of TCP\n+     * @param srcAddress Source IPv6 Address\n+     * @param dstAddress Destination IPv6 Address\n+     */\n+    static void writeTCPv6(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress) {\n+        writePacketv6(byteBuf, payload, 6, srcAddress, dstAddress);\n+    }\n+\n+    private static void writePacketv4(ByteBuf byteBuf, ByteBuf payload, int protocol, int srcAddress,\n+                                      int dstAddress) {\n+        byteBuf.writeByte(0x45);      //  Version + IHL\n+        byteBuf.writeByte(0x00);      //  DSCP\n+        byteBuf.writeShort(payload.readableBytes() + 20); // Length\n+        byteBuf.writeShort(0x0000);   // Identification\n+        byteBuf.writeShort(0x0000);   // Fragment\n+        byteBuf.writeByte(0xff);      // TTL", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDAzNjMxMQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480036311", "bodyText": "This would be easier to read when written in hexadecimal format.", "author": "chrisvest", "createdAt": "2020-08-31T10:29:19Z", "path": "handler/src/main/java/io/netty/handler/pcap/IPPacket.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class IPPacket {\n+\n+    private IPPacket() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Write IPv4 Packet for UDP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of UDP\n+     * @param srcAddress Source IPv4 Address\n+     * @param dstAddress Destination IPv4 Address\n+     */\n+    static void writeUDPv4(ByteBuf byteBuf, ByteBuf payload, int srcAddress, int dstAddress) {\n+        writePacketv4(byteBuf, payload, 17, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Write IPv6 Packet for UDP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of UDP\n+     * @param srcAddress Source IPv6 Address\n+     * @param dstAddress Destination IPv6 Address\n+     */\n+    static void writeUDPv6(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress) {\n+        writePacketv6(byteBuf, payload, 17, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Write IPv4 Packet for TCP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of TCP\n+     * @param srcAddress Source IPv4 Address\n+     * @param dstAddress Destination IPv4 Address\n+     */\n+    static void writeTCPv4(ByteBuf byteBuf, ByteBuf payload, int srcAddress, int dstAddress) {\n+        writePacketv4(byteBuf, payload, 6, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Write IPv6 Packet for TCP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of TCP\n+     * @param srcAddress Source IPv6 Address\n+     * @param dstAddress Destination IPv6 Address\n+     */\n+    static void writeTCPv6(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress) {\n+        writePacketv6(byteBuf, payload, 6, srcAddress, dstAddress);\n+    }\n+\n+    private static void writePacketv4(ByteBuf byteBuf, ByteBuf payload, int protocol, int srcAddress,\n+                                      int dstAddress) {\n+        byteBuf.writeByte(0x45);      //  Version + IHL\n+        byteBuf.writeByte(0x00);      //  DSCP\n+        byteBuf.writeShort(payload.readableBytes() + 20); // Length\n+        byteBuf.writeShort(0x0000);   // Identification\n+        byteBuf.writeShort(0x0000);   // Fragment\n+        byteBuf.writeByte(0xff);      // TTL\n+        byteBuf.writeByte(protocol);  // Protocol\n+        byteBuf.writeShort(0);        // Checksum\n+        byteBuf.writeInt(srcAddress); // Source IPv4 Address\n+        byteBuf.writeInt(dstAddress); // Destination IPv4 Address\n+        byteBuf.writeBytes(payload);  // Payload of L4\n+    }\n+\n+    private static void writePacketv6(ByteBuf byteBuf, ByteBuf payload, int protocol, byte[] srcAddress,\n+                                      byte[] dstAddress) {\n+        byteBuf.writeInt(6 << 28);          // Version  + Traffic class + Flow label", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDAzNjkwMg==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480036902", "bodyText": "Please make a constant for the hop limit.", "author": "chrisvest", "createdAt": "2020-08-31T10:30:39Z", "path": "handler/src/main/java/io/netty/handler/pcap/IPPacket.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class IPPacket {\n+\n+    private IPPacket() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Write IPv4 Packet for UDP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of UDP\n+     * @param srcAddress Source IPv4 Address\n+     * @param dstAddress Destination IPv4 Address\n+     */\n+    static void writeUDPv4(ByteBuf byteBuf, ByteBuf payload, int srcAddress, int dstAddress) {\n+        writePacketv4(byteBuf, payload, 17, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Write IPv6 Packet for UDP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of UDP\n+     * @param srcAddress Source IPv6 Address\n+     * @param dstAddress Destination IPv6 Address\n+     */\n+    static void writeUDPv6(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress) {\n+        writePacketv6(byteBuf, payload, 17, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Write IPv4 Packet for TCP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of TCP\n+     * @param srcAddress Source IPv4 Address\n+     * @param dstAddress Destination IPv4 Address\n+     */\n+    static void writeTCPv4(ByteBuf byteBuf, ByteBuf payload, int srcAddress, int dstAddress) {\n+        writePacketv4(byteBuf, payload, 6, srcAddress, dstAddress);\n+    }\n+\n+    /**\n+     * Write IPv6 Packet for TCP Packet\n+     *\n+     * @param byteBuf    ByteBuf where IP Packet data will be set\n+     * @param payload    Payload of TCP\n+     * @param srcAddress Source IPv6 Address\n+     * @param dstAddress Destination IPv6 Address\n+     */\n+    static void writeTCPv6(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress) {\n+        writePacketv6(byteBuf, payload, 6, srcAddress, dstAddress);\n+    }\n+\n+    private static void writePacketv4(ByteBuf byteBuf, ByteBuf payload, int protocol, int srcAddress,\n+                                      int dstAddress) {\n+        byteBuf.writeByte(0x45);      //  Version + IHL\n+        byteBuf.writeByte(0x00);      //  DSCP\n+        byteBuf.writeShort(payload.readableBytes() + 20); // Length\n+        byteBuf.writeShort(0x0000);   // Identification\n+        byteBuf.writeShort(0x0000);   // Fragment\n+        byteBuf.writeByte(0xff);      // TTL\n+        byteBuf.writeByte(protocol);  // Protocol\n+        byteBuf.writeShort(0);        // Checksum\n+        byteBuf.writeInt(srcAddress); // Source IPv4 Address\n+        byteBuf.writeInt(dstAddress); // Destination IPv4 Address\n+        byteBuf.writeBytes(payload);  // Payload of L4\n+    }\n+\n+    private static void writePacketv6(ByteBuf byteBuf, ByteBuf payload, int protocol, byte[] srcAddress,\n+                                      byte[] dstAddress) {\n+        byteBuf.writeInt(6 << 28);          // Version  + Traffic class + Flow label\n+        byteBuf.writeShort(payload.readableBytes()); // Payload length\n+        byteBuf.writeByte(protocol & 0xff); // Next header\n+        byteBuf.writeByte(255);             // Hop limit", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA0MTExOA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480041118", "bodyText": "Do release in a finally block.", "author": "chrisvest", "createdAt": "2020-08-31T10:40:50Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCapWriter.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+\n+final class PCapWriter implements Closeable {\n+    private final SimpleDateFormat sdf = new SimpleDateFormat(\"SSSSSSSSS\");\n+    private final OutputStream outputStream;\n+\n+    /**\n+     * This uses {@link OutputStream} for writing Pcap.\n+     * Pcap Global Header is also written on construction.\n+     *\n+     * @throws IOException If {@link OutputStream#write(byte[])} throws an exception\n+     */\n+    PCapWriter(OutputStream outputStream, ByteBuf byteBuf) throws IOException {\n+        this.outputStream = outputStream;\n+\n+        PcapHeaders.writeGlobalHeader(byteBuf);\n+        byteBuf.readBytes(outputStream, byteBuf.readableBytes());\n+        byteBuf.release();", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA0MzQzNg==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480043436", "bodyText": "This header could be held in a constant on-heap buffer or byte array. Then we'd have one less allocate/release dance.", "author": "chrisvest", "createdAt": "2020-08-31T10:44:16Z", "path": "handler/src/main/java/io/netty/handler/pcap/PcapHeaders.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+final class PcapHeaders {\n+\n+    private PcapHeaders() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Write Pcap Global Header\n+     * @param byteBuf byteBuf ByteBuf where we'll write header data\n+     */\n+    static void writeGlobalHeader(ByteBuf byteBuf) {\n+        byteBuf.writeInt(0xa1b2c3d4); // magic_number\n+        byteBuf.writeShort(2);        // version_major\n+        byteBuf.writeShort(4);        // version_minor\n+        byteBuf.writeInt(0);          // thiszone\n+        byteBuf.writeInt(0);          // sigfigs\n+        byteBuf.writeInt(0xffff);     // snaplen\n+        byteBuf.writeInt(1);          // network", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA1ODc2Nw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480058767", "bodyText": "I think writing the data offset part in hexadecimal would be easier to read.", "author": "chrisvest", "createdAt": "2020-08-31T11:08:43Z", "path": "handler/src/main/java/io/netty/handler/pcap/TCPPacket.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class TCPPacket {\n+\n+    private TCPPacket() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Write TCP Packet\n+     *\n+     * @param byteBuf ByteBuf where Packet data will be set\n+     * @param payload Payload of this Packet\n+     * @param srcPort Source Port\n+     * @param dstPort Destination Port\n+     */\n+    static void writePacket(ByteBuf byteBuf, ByteBuf payload, int segmentNumber, int ackNumber, int srcPort, int dstPort, Flag... flags) {\n+        int fin = 0;\n+        int syn = 0;\n+        int rst = 0;\n+        int psh = 0;\n+        int ack = 0;\n+        int urg = 0;\n+        int ece = 0;\n+        int cwr = 0;\n+\n+        for (Flag flag : flags) {\n+            switch (flag) {\n+                case FIN:\n+                    fin = 1;\n+                case SYN:\n+                    syn = 1;\n+                case RST:\n+                    rst = 1;\n+                case PSH:\n+                    psh = 1;\n+                case ACK:\n+                    ack = 1;\n+                case URG:\n+                    urg = 1;\n+                case ECE:\n+                    ece = 1;\n+                case CWR:\n+                    cwr = 1;\n+            }\n+        }\n+\n+        int tcpFlags = fin << 0 |\n+                syn << 1 |\n+                rst << 2 |\n+                psh << 3 |\n+                ack << 4 |\n+                urg << 5 |\n+                ece << 6 |\n+                cwr << 7;\n+\n+        byteBuf.writeShort(srcPort);     // Source Port\n+        byteBuf.writeShort(dstPort);     // Destination Port\n+        byteBuf.writeInt(segmentNumber); // Segment Number\n+        byteBuf.writeInt(ackNumber);     // Acknowledgment Number\n+        byteBuf.writeShort(5 << 12 | tcpFlags); // Flags", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA1OTE2OQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480059169", "bodyText": "Why this particular checksum?", "author": "chrisvest", "createdAt": "2020-08-31T11:09:45Z", "path": "handler/src/main/java/io/netty/handler/pcap/TCPPacket.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class TCPPacket {\n+\n+    private TCPPacket() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Write TCP Packet\n+     *\n+     * @param byteBuf ByteBuf where Packet data will be set\n+     * @param payload Payload of this Packet\n+     * @param srcPort Source Port\n+     * @param dstPort Destination Port\n+     */\n+    static void writePacket(ByteBuf byteBuf, ByteBuf payload, int segmentNumber, int ackNumber, int srcPort, int dstPort, Flag... flags) {\n+        int fin = 0;\n+        int syn = 0;\n+        int rst = 0;\n+        int psh = 0;\n+        int ack = 0;\n+        int urg = 0;\n+        int ece = 0;\n+        int cwr = 0;\n+\n+        for (Flag flag : flags) {\n+            switch (flag) {\n+                case FIN:\n+                    fin = 1;\n+                case SYN:\n+                    syn = 1;\n+                case RST:\n+                    rst = 1;\n+                case PSH:\n+                    psh = 1;\n+                case ACK:\n+                    ack = 1;\n+                case URG:\n+                    urg = 1;\n+                case ECE:\n+                    ece = 1;\n+                case CWR:\n+                    cwr = 1;\n+            }\n+        }\n+\n+        int tcpFlags = fin << 0 |\n+                syn << 1 |\n+                rst << 2 |\n+                psh << 3 |\n+                ack << 4 |\n+                urg << 5 |\n+                ece << 6 |\n+                cwr << 7;\n+\n+        byteBuf.writeShort(srcPort);     // Source Port\n+        byteBuf.writeShort(dstPort);     // Destination Port\n+        byteBuf.writeInt(segmentNumber); // Segment Number\n+        byteBuf.writeInt(ackNumber);     // Acknowledgment Number\n+        byteBuf.writeShort(5 << 12 | tcpFlags); // Flags\n+        byteBuf.writeShort(65535);       // Window Size\n+        byteBuf.writeShort(0x0001);      // Checksum", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE4Nzc4NA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480187784", "bodyText": "Just a dummy checksum.", "author": "hyperxpro", "createdAt": "2020-08-31T14:58:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA1OTE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA1OTczNw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480059737", "bodyText": "This can just as well be 1, right?", "author": "chrisvest", "createdAt": "2020-08-31T11:11:11Z", "path": "handler/src/main/java/io/netty/handler/pcap/TCPPacket.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class TCPPacket {\n+\n+    private TCPPacket() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Write TCP Packet\n+     *\n+     * @param byteBuf ByteBuf where Packet data will be set\n+     * @param payload Payload of this Packet\n+     * @param srcPort Source Port\n+     * @param dstPort Destination Port\n+     */\n+    static void writePacket(ByteBuf byteBuf, ByteBuf payload, int segmentNumber, int ackNumber, int srcPort, int dstPort, Flag... flags) {\n+        int fin = 0;\n+        int syn = 0;\n+        int rst = 0;\n+        int psh = 0;\n+        int ack = 0;\n+        int urg = 0;\n+        int ece = 0;\n+        int cwr = 0;\n+\n+        for (Flag flag : flags) {\n+            switch (flag) {\n+                case FIN:\n+                    fin = 1;\n+                case SYN:\n+                    syn = 1;\n+                case RST:\n+                    rst = 1;\n+                case PSH:\n+                    psh = 1;\n+                case ACK:\n+                    ack = 1;\n+                case URG:\n+                    urg = 1;\n+                case ECE:\n+                    ece = 1;\n+                case CWR:\n+                    cwr = 1;\n+            }\n+        }\n+\n+        int tcpFlags = fin << 0 |\n+                syn << 1 |\n+                rst << 2 |\n+                psh << 3 |\n+                ack << 4 |\n+                urg << 5 |\n+                ece << 6 |\n+                cwr << 7;\n+\n+        byteBuf.writeShort(srcPort);     // Source Port\n+        byteBuf.writeShort(dstPort);     // Destination Port\n+        byteBuf.writeInt(segmentNumber); // Segment Number\n+        byteBuf.writeInt(ackNumber);     // Acknowledgment Number\n+        byteBuf.writeShort(5 << 12 | tcpFlags); // Flags\n+        byteBuf.writeShort(65535);       // Window Size", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDE4ODc3NQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480188775", "bodyText": "Yes, but we don't know how much a user is going to write into the TCP stream. On LAN, it can be up to 65535 so I set it to 65535.", "author": "hyperxpro", "createdAt": "2020-08-31T14:59:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA1OTczNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA4NDM1MQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480084351", "bodyText": "Checksum is allowed to be all-zeros (except in IPv6).", "author": "chrisvest", "createdAt": "2020-08-31T12:04:14Z", "path": "handler/src/main/java/io/netty/handler/pcap/UDPPacket.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class UDPPacket {\n+\n+    private UDPPacket() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Write UDP Packet\n+     *\n+     * @param byteBuf ByteBuf where Packet data will be set\n+     * @param payload Payload of this Packet\n+     * @param srcPort Source Port\n+     * @param dstPort Destination Port\n+     */\n+    static void writePacket(ByteBuf byteBuf, ByteBuf payload, int srcPort, int dstPort) {\n+        byteBuf.writeShort(srcPort); // Source Port\n+        byteBuf.writeShort(dstPort); // Destination Port\n+        byteBuf.writeShort(8 + payload.readableBytes()); // UDP Header Length + Payload Length\n+        byteBuf.writeShort(0x0001);  // Checksum", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDIxMTk1Ng==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480211956", "bodyText": "Then we need to perform a check for IPv6 and add checksum. Not worth the effort TBH.", "author": "hyperxpro", "createdAt": "2020-08-31T15:36:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA4NDM1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA4NDU3MQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480084571", "bodyText": "Let's have a constant for the UDP header length.", "author": "chrisvest", "createdAt": "2020-08-31T12:04:43Z", "path": "handler/src/main/java/io/netty/handler/pcap/UDPPacket.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class UDPPacket {\n+\n+    private UDPPacket() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Write UDP Packet\n+     *\n+     * @param byteBuf ByteBuf where Packet data will be set\n+     * @param payload Payload of this Packet\n+     * @param srcPort Source Port\n+     * @param dstPort Destination Port\n+     */\n+    static void writePacket(ByteBuf byteBuf, ByteBuf payload, int srcPort, int dstPort) {\n+        byteBuf.writeShort(srcPort); // Source Port\n+        byteBuf.writeShort(dstPort); // Destination Port\n+        byteBuf.writeShort(8 + payload.readableBytes()); // UDP Header Length + Payload Length", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDA4NTM5Nw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r480085397", "bodyText": "Please use static imports for the asset* methods.", "author": "chrisvest", "createdAt": "2020-08-31T12:06:32Z", "path": "handler/src/test/java/io/netty/handler/pcap/PCAPWriteHandlerTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.channel.socket.DatagramPacket;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.io.IOException;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public class PCAPWriteHandlerTest {\n+\n+    @Test\n+    public void udpV4() throws IOException {\n+\n+        ByteBuf byteBuf = Unpooled.buffer();\n+        EmbeddedChannel embeddedChannel = new EmbeddedChannel(new PCAPWriteHandler(\n+                new ByteBufOutputStream(byteBuf), true, false, false\n+        ));\n+\n+        InetSocketAddress srcAddr = new InetSocketAddress(\"127.0.0.1\", 1000);\n+        InetSocketAddress dstAddr = new InetSocketAddress(\"192.168.1.1\", 50000);\n+\n+        embeddedChannel.writeInbound(new DatagramPacket(Unpooled.wrappedBuffer(\"Meow\".getBytes()), dstAddr, srcAddr));\n+        embeddedChannel.flushInbound();\n+\n+        // Verify Pcap Global Headers\n+        Assert.assertEquals(0xa1b2c3d4, byteBuf.readInt()); // magic_number", "originalCommit": "d0c95ec9947fec8eb80460afa57b9d8e1962cc8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5cd1b7ee6d554b89f8235da0ed4cb486dff00c0e", "url": "https://github.com/netty/netty/commit/5cd1b7ee6d554b89f8235da0ed4cb486dff00c0e", "message": "address @normanmaurer changes suggestions", "committedDate": "2020-08-31T13:37:01Z", "type": "commit"}, {"oid": "41c98e5e93537a0ff66f85490c616337e3e6ec53", "url": "https://github.com/netty/netty/commit/41c98e5e93537a0ff66f85490c616337e3e6ec53", "message": "code improvement", "committedDate": "2020-08-31T19:57:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA3OTgwOQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r481079809", "bodyText": "Please fix the formatting so we don't start lines with a comma like that. Like, either extract datagramPacket.content().readableBytes() to a variable, or do the line break before it.", "author": "chrisvest", "createdAt": "2020-09-01T11:52:42Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCAPWriteHandler.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.ServerChannel;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.util.NetUtil;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public final class PCAPWriteHandler extends ChannelDuplexHandler {\n+\n+    private final InternalLogger logger = InternalLoggerFactory.getInstance(PCAPWriteHandler.class);\n+\n+    /**\n+     * TCP Sender Segment Number.\n+     */\n+    private int sendSegmentNumber = 1;\n+\n+    /**\n+     * TCP Receiver Segment Number\n+     */\n+    private int receiveSegmentNumber = 1;\n+\n+    /**\n+     * Source Address [TCP ONLY]\n+     */\n+    private InetSocketAddress srcAddr;\n+\n+    /**\n+     * Destination Address [TCP ONLY]\n+     */\n+    private InetSocketAddress dstAddr;\n+\n+    private final OutputStream outputStream;\n+    private PCapWriter pCapWriter;\n+    private final boolean captureZeroByte;\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code captureZeroByte} are set to {@code false}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream) {\n+        this(outputStream, false);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance\n+     *\n+     * @param outputStream    OutputStream where Pcap data will be written\n+     * @param captureZeroByte {@code true} If we'll capture packets with 0 bytes\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean captureZeroByte) {\n+        this.outputStream = outputStream;\n+        this.captureZeroByte = captureZeroByte;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        ByteBuf byteBuf  = ctx.alloc().buffer();\n+\n+        try {\n+            this.pCapWriter = new PCapWriter(this.outputStream, byteBuf);\n+        } catch (IOException ex) {\n+            ctx.fireExceptionCaught(ex);\n+        } finally {\n+            byteBuf.release();\n+        }\n+\n+        /*\n+         * If `isServer` is set to true, it means we'll be receiving data from client.\n+         * In this case, Source Address will be `remoteAddress` and Destination Address\n+         * will be `localAddress`.\n+         *\n+         * If `isServer` is set to false, it means we'll be sending data to server.\n+         * In this case, Source Address will be `localAddress` and Destination Address\n+         * will be `remoteAddress`.\n+         */\n+        if (ctx.channel() instanceof SocketChannel) {\n+            if (ctx.channel() instanceof ServerChannel) {\n+                srcAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().localAddress();\n+            } else {\n+                srcAddr = (InetSocketAddress) ctx.channel().localAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+            }\n+        }\n+\n+        // If `isTCP` is true, then we'll simulate a fake handshake.\n+        if (ctx.channel() instanceof SocketChannel) {\n+            logger.debug(\"Starting Fake TCP 3-Way Handshake\");\n+\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            try {\n+\n+                // Write SYN with Normal Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, 0, 0, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.TCPFlag.SYN);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+                // Write SYN+ACK with Reversed Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, 0, 1, dstAddr.getPort(), srcAddr.getPort(), TCPPacket.TCPFlag.SYN,\n+                        TCPPacket.TCPFlag.ACK);\n+                completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+\n+                // Write ACK with Normal Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, 1, 1, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+            } catch (IOException ex) {\n+                ctx.fireExceptionCaught(ex);\n+            } finally {\n+                tcpBuf.release();\n+            }\n+\n+            logger.debug(\"Finished Fake TCP 3-Way Handshake\");\n+        }\n+\n+        super.channelActive(ctx);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        writePacket(ctx, msg, false);\n+        super.channelRead(ctx, msg);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        writePacket(ctx, msg, true);\n+        super.write(ctx, msg, promise);\n+    }\n+\n+    private void writePacket(ChannelHandlerContext ctx, Object msg, boolean isWriteOperation) {\n+        if (msg instanceof ByteBuf) {\n+\n+            // If bytes are 0 and `captureZeroByte` is false, we won't capture this.\n+            if (((ByteBuf) msg).readableBytes() == 0 && !captureZeroByte) {\n+                logger.debug(\"Discarding Zero Byte TCP Packet. isWriteOperation {}\", isWriteOperation);\n+                return;\n+            }\n+\n+            ByteBuf packet = ((ByteBuf) msg).duplicate();\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+            int bytes = packet.readableBytes();\n+\n+            try {\n+                if (isWriteOperation) {\n+                    TCPPacket.writePacket(tcpBuf, packet, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                            dstAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                    completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+                    logTCP(true, bytes, sendSegmentNumber, receiveSegmentNumber, srcAddr, dstAddr, false);\n+\n+                    sendSegmentNumber += bytes;\n+\n+                    TCPPacket.writePacket(tcpBuf, null, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                            srcAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                    completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+                    logTCP(true, bytes, sendSegmentNumber, receiveSegmentNumber, dstAddr, srcAddr, true);\n+                } else {\n+                    TCPPacket.writePacket(tcpBuf, packet, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                            srcAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                    completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+                    logTCP(false, bytes, receiveSegmentNumber, sendSegmentNumber, dstAddr, srcAddr, false);\n+\n+                    receiveSegmentNumber += bytes;\n+\n+                    TCPPacket.writePacket(tcpBuf, null, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                            dstAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                    completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+                    logTCP(false, bytes, sendSegmentNumber, receiveSegmentNumber, srcAddr, dstAddr, true);\n+                }\n+            } catch (IOException ex) {\n+                ctx.fireExceptionCaught(ex);\n+            } finally {\n+                tcpBuf.release();\n+            }\n+\n+        } else if (msg instanceof DatagramPacket) {\n+            handleUDP(ctx, ((DatagramPacket) msg).duplicate());\n+        } else {\n+            logger.error(\"Discarding Pcap Write for Object {}\", msg);\n+        }\n+    }\n+\n+    private void logTCP(boolean isWriteOperation, int bytes, int sendSegmentNumber, int receiveSegmentNumber,\n+                        InetSocketAddress srcAddr, InetSocketAddress dstAddr, boolean ackOnly) {\n+        if (ackOnly) {\n+            logger.debug(\"Writing TCP ACK, isWriteOperation {}, Segment Number {}, Ack Number {}, Src Addr {}, \"\n+                    + \"Dst Addr {}\", isWriteOperation, sendSegmentNumber, receiveSegmentNumber, dstAddr, srcAddr);\n+        } else {\n+            logger.debug(\"Writing TCP Data of {} Bytes, isWriteOperation {}, Segment Number {}, Ack Number {}, \" +\n+                            \"Src Addr {}, Dst Addr {}\", bytes, isWriteOperation, sendSegmentNumber,\n+                    receiveSegmentNumber, srcAddr, dstAddr);\n+        }\n+    }\n+\n+    private void handleUDP(ChannelHandlerContext ctx, DatagramPacket datagramPacket) {\n+        ByteBuf udpBuf = ctx.alloc().buffer();\n+\n+        InetSocketAddress srcAddr = datagramPacket.sender();\n+        InetSocketAddress dstAddr = datagramPacket.recipient();\n+\n+        logger.debug(\"Writing UDP Data of {} Bytes, Src Addr {}, Dst Addr {}\", datagramPacket.content().readableBytes()\n+                , srcAddr, dstAddr);", "originalCommit": "41c98e5e93537a0ff66f85490c616337e3e6ec53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA4MDU5NA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r481080594", "bodyText": "You have a number of these empty lines after { in various places.", "author": "chrisvest", "createdAt": "2020-09-01T11:54:19Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCAPWriteHandler.java", "diffHunk": "@@ -0,0 +1,371 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.ServerChannel;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.util.NetUtil;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.InetAddress;\n+import java.net.InetSocketAddress;\n+\n+public final class PCAPWriteHandler extends ChannelDuplexHandler {\n+\n+    private final InternalLogger logger = InternalLoggerFactory.getInstance(PCAPWriteHandler.class);\n+\n+    /**\n+     * TCP Sender Segment Number.\n+     */\n+    private int sendSegmentNumber = 1;\n+\n+    /**\n+     * TCP Receiver Segment Number\n+     */\n+    private int receiveSegmentNumber = 1;\n+\n+    /**\n+     * Source Address [TCP ONLY]\n+     */\n+    private InetSocketAddress srcAddr;\n+\n+    /**\n+     * Destination Address [TCP ONLY]\n+     */\n+    private InetSocketAddress dstAddr;\n+\n+    private final OutputStream outputStream;\n+    private PCapWriter pCapWriter;\n+    private final boolean captureZeroByte;\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code captureZeroByte} are set to {@code false}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream) {\n+        this(outputStream, false);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance\n+     *\n+     * @param outputStream    OutputStream where Pcap data will be written\n+     * @param captureZeroByte {@code true} If we'll capture packets with 0 bytes\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean captureZeroByte) {\n+        this.outputStream = outputStream;\n+        this.captureZeroByte = captureZeroByte;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+        ByteBuf byteBuf  = ctx.alloc().buffer();\n+\n+        try {\n+            this.pCapWriter = new PCapWriter(this.outputStream, byteBuf);\n+        } catch (IOException ex) {\n+            ctx.fireExceptionCaught(ex);\n+        } finally {\n+            byteBuf.release();\n+        }\n+\n+        /*\n+         * If `isServer` is set to true, it means we'll be receiving data from client.\n+         * In this case, Source Address will be `remoteAddress` and Destination Address\n+         * will be `localAddress`.\n+         *\n+         * If `isServer` is set to false, it means we'll be sending data to server.\n+         * In this case, Source Address will be `localAddress` and Destination Address\n+         * will be `remoteAddress`.\n+         */\n+        if (ctx.channel() instanceof SocketChannel) {\n+            if (ctx.channel() instanceof ServerChannel) {\n+                srcAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().localAddress();\n+            } else {\n+                srcAddr = (InetSocketAddress) ctx.channel().localAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+            }\n+        }\n+\n+        // If `isTCP` is true, then we'll simulate a fake handshake.\n+        if (ctx.channel() instanceof SocketChannel) {\n+            logger.debug(\"Starting Fake TCP 3-Way Handshake\");\n+\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            try {\n+\n+                // Write SYN with Normal Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, 0, 0, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.TCPFlag.SYN);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+\n+                // Write SYN+ACK with Reversed Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, 0, 1, dstAddr.getPort(), srcAddr.getPort(), TCPPacket.TCPFlag.SYN,\n+                        TCPPacket.TCPFlag.ACK);\n+                completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+\n+                // Write ACK with Normal Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, 1, 1, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+            } catch (IOException ex) {\n+                ctx.fireExceptionCaught(ex);\n+            } finally {\n+                tcpBuf.release();\n+            }\n+\n+            logger.debug(\"Finished Fake TCP 3-Way Handshake\");\n+        }\n+\n+        super.channelActive(ctx);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        writePacket(ctx, msg, false);\n+        super.channelRead(ctx, msg);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        writePacket(ctx, msg, true);\n+        super.write(ctx, msg, promise);\n+    }\n+\n+    private void writePacket(ChannelHandlerContext ctx, Object msg, boolean isWriteOperation) {\n+        if (msg instanceof ByteBuf) {\n+\n+            // If bytes are 0 and `captureZeroByte` is false, we won't capture this.\n+            if (((ByteBuf) msg).readableBytes() == 0 && !captureZeroByte) {\n+                logger.debug(\"Discarding Zero Byte TCP Packet. isWriteOperation {}\", isWriteOperation);\n+                return;\n+            }\n+\n+            ByteBuf packet = ((ByteBuf) msg).duplicate();\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+            int bytes = packet.readableBytes();\n+\n+            try {\n+                if (isWriteOperation) {\n+                    TCPPacket.writePacket(tcpBuf, packet, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                            dstAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                    completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+                    logTCP(true, bytes, sendSegmentNumber, receiveSegmentNumber, srcAddr, dstAddr, false);\n+\n+                    sendSegmentNumber += bytes;\n+\n+                    TCPPacket.writePacket(tcpBuf, null, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                            srcAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                    completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+                    logTCP(true, bytes, sendSegmentNumber, receiveSegmentNumber, dstAddr, srcAddr, true);\n+                } else {\n+                    TCPPacket.writePacket(tcpBuf, packet, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                            srcAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                    completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc());\n+                    logTCP(false, bytes, receiveSegmentNumber, sendSegmentNumber, dstAddr, srcAddr, false);\n+\n+                    receiveSegmentNumber += bytes;\n+\n+                    TCPPacket.writePacket(tcpBuf, null, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                            dstAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                    completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc());\n+                    logTCP(false, bytes, sendSegmentNumber, receiveSegmentNumber, srcAddr, dstAddr, true);\n+                }\n+            } catch (IOException ex) {\n+                ctx.fireExceptionCaught(ex);\n+            } finally {\n+                tcpBuf.release();\n+            }\n+\n+        } else if (msg instanceof DatagramPacket) {\n+            handleUDP(ctx, ((DatagramPacket) msg).duplicate());\n+        } else {\n+            logger.error(\"Discarding Pcap Write for Object {}\", msg);\n+        }\n+    }\n+\n+    private void logTCP(boolean isWriteOperation, int bytes, int sendSegmentNumber, int receiveSegmentNumber,\n+                        InetSocketAddress srcAddr, InetSocketAddress dstAddr, boolean ackOnly) {\n+        if (ackOnly) {\n+            logger.debug(\"Writing TCP ACK, isWriteOperation {}, Segment Number {}, Ack Number {}, Src Addr {}, \"\n+                    + \"Dst Addr {}\", isWriteOperation, sendSegmentNumber, receiveSegmentNumber, dstAddr, srcAddr);\n+        } else {\n+            logger.debug(\"Writing TCP Data of {} Bytes, isWriteOperation {}, Segment Number {}, Ack Number {}, \" +\n+                            \"Src Addr {}, Dst Addr {}\", bytes, isWriteOperation, sendSegmentNumber,\n+                    receiveSegmentNumber, srcAddr, dstAddr);\n+        }\n+    }\n+\n+    private void handleUDP(ChannelHandlerContext ctx, DatagramPacket datagramPacket) {\n+        ByteBuf udpBuf = ctx.alloc().buffer();\n+\n+        InetSocketAddress srcAddr = datagramPacket.sender();\n+        InetSocketAddress dstAddr = datagramPacket.recipient();\n+\n+        logger.debug(\"Writing UDP Data of {} Bytes, Src Addr {}, Dst Addr {}\", datagramPacket.content().readableBytes()\n+                , srcAddr, dstAddr);\n+\n+        try {\n+", "originalCommit": "41c98e5e93537a0ff66f85490c616337e3e6ec53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTIxMDcyNw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r481210727", "bodyText": "Just my code style. :p", "author": "hyperxpro", "createdAt": "2020-09-01T15:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA4MDU5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA4NDQ0Mg==", "url": "https://github.com/netty/netty/pull/10498#discussion_r481084442", "bodyText": "You need two time components here; seconds and the remainder in microseconds. You can do that with arithmetic instead of these shenanigans with date-time formatting, string slicing and number parsing.\nTo get seconds, you divide by 1000, or use the time unit conversion. And to get microseconds, you first take the modulo of 1000, and then multiply or convert.", "author": "chrisvest", "createdAt": "2020-09-01T12:01:06Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCapWriter.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+\n+final class PCapWriter implements Closeable {\n+    private final SimpleDateFormat sdf = new SimpleDateFormat(\"SSSSSSSSS\");\n+    private final OutputStream outputStream;\n+\n+    /**\n+     * This uses {@link OutputStream} for writing Pcap.\n+     * Pcap Global Header is also written on construction.\n+     *\n+     * @throws IOException If {@link OutputStream#write(byte[])} throws an exception\n+     */\n+    PCapWriter(OutputStream outputStream, ByteBuf byteBuf) throws IOException {\n+        this.outputStream = outputStream;\n+\n+        PcapHeaders.writeGlobalHeader(byteBuf);\n+        byteBuf.readBytes(outputStream, byteBuf.readableBytes());\n+    }\n+\n+    /**\n+     * Write Packet in Pcap OutputStream.\n+     *\n+     * @param packetHeaderBuf Packer Header {@link ByteBuf}\n+     * @param packet          Packet\n+     * @throws IOException If {@link OutputStream#write(byte[])} throws an exception\n+     */\n+    void writePacket(ByteBuf packetHeaderBuf, ByteBuf packet) throws IOException {\n+        long currentTime = System.currentTimeMillis();\n+\n+        String microsecond = sdf.format(new Date(currentTime));\n+        microsecond = microsecond.substring(microsecond.indexOf(\".\") + 1);\n+\n+        PcapHeaders.writePacketHeader(\n+                packetHeaderBuf,\n+                currentTime,\n+                Integer.parseInt(microsecond),", "originalCommit": "41c98e5e93537a0ff66f85490c616337e3e6ec53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA4NTU3Nw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r481085577", "bodyText": "this is unnecessary.", "author": "chrisvest", "createdAt": "2020-09-01T12:03:08Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCapWriter.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+\n+final class PCapWriter implements Closeable {\n+    private final SimpleDateFormat sdf = new SimpleDateFormat(\"SSSSSSSSS\");\n+    private final OutputStream outputStream;\n+\n+    /**\n+     * This uses {@link OutputStream} for writing Pcap.\n+     * Pcap Global Header is also written on construction.\n+     *\n+     * @throws IOException If {@link OutputStream#write(byte[])} throws an exception\n+     */\n+    PCapWriter(OutputStream outputStream, ByteBuf byteBuf) throws IOException {\n+        this.outputStream = outputStream;\n+\n+        PcapHeaders.writeGlobalHeader(byteBuf);\n+        byteBuf.readBytes(outputStream, byteBuf.readableBytes());\n+    }\n+\n+    /**\n+     * Write Packet in Pcap OutputStream.\n+     *\n+     * @param packetHeaderBuf Packer Header {@link ByteBuf}\n+     * @param packet          Packet\n+     * @throws IOException If {@link OutputStream#write(byte[])} throws an exception\n+     */\n+    void writePacket(ByteBuf packetHeaderBuf, ByteBuf packet) throws IOException {\n+        long currentTime = System.currentTimeMillis();\n+\n+        String microsecond = sdf.format(new Date(currentTime));\n+        microsecond = microsecond.substring(microsecond.indexOf(\".\") + 1);\n+\n+        PcapHeaders.writePacketHeader(\n+                packetHeaderBuf,\n+                currentTime,\n+                Integer.parseInt(microsecond),\n+                packet.readableBytes(),\n+                packet.readableBytes()\n+        );\n+\n+        packetHeaderBuf.readBytes(outputStream, packetHeaderBuf.readableBytes());\n+        packet.readBytes(outputStream, packet.readableBytes());\n+    }\n+\n+    @Override\n+    public void close() throws IOException {\n+        this.outputStream.close();", "originalCommit": "41c98e5e93537a0ff66f85490c616337e3e6ec53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA4ODM5OQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r481088399", "bodyText": "This is the wrong place to do toSeconds.", "author": "chrisvest", "createdAt": "2020-09-01T12:08:26Z", "path": "handler/src/main/java/io/netty/handler/pcap/PcapHeaders.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+public final class PcapHeaders {\n+\n+    /**\n+     * Pcap Global Header built from:\n+     * <ol>\n+     *      <li> magic_number </li>\n+     *      <li> version_major </li>\n+     *      <li> version_minor </li>\n+     *      <li> thiszone </li>\n+     *      <li> sigfigs </li>\n+     *      <li> snaplen </li>\n+     *      <li> network </li>\n+     * </ol>\n+     */\n+    private static final byte[] GLOBAL_HEADER = new byte[]{-95, -78, -61, -44, 0, 2, 0, 4, 0, 0,\n+            0, 0, 0, 0, 0, 0, 0, 0, -1, -1, 0, 0, 0, 1};\n+\n+    private PcapHeaders() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Write Pcap Global Header\n+     *\n+     * @param byteBuf byteBuf ByteBuf where we'll write header data\n+     */\n+    public static void writeGlobalHeader(ByteBuf byteBuf) {\n+        byteBuf.writeBytes(GLOBAL_HEADER);\n+    }\n+\n+    /**\n+     * Write Pcap Packet Header\n+     *\n+     * @param byteBuf  ByteBuf where we'll write header data\n+     * @param ts_sec   timestamp seconds\n+     * @param ts_usec  timestamp microseconds\n+     * @param incl_len number of octets of packet saved in file\n+     * @param orig_len actual length of packet\n+     */\n+    static void writePacketHeader(ByteBuf byteBuf, long ts_sec, int ts_usec, int incl_len, int orig_len) {\n+        byteBuf.writeInt((int) TimeUnit.MILLISECONDS.toSeconds(ts_sec));", "originalCommit": "41c98e5e93537a0ff66f85490c616337e3e6ec53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTA4OTA3MQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r481089071", "bodyText": "Or 0x5000.", "author": "chrisvest", "createdAt": "2020-09-01T12:09:46Z", "path": "handler/src/main/java/io/netty/handler/pcap/TCPPacket.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class TCPPacket {\n+\n+    /**\n+     * <p> Data Offset + Reserved Bits. </p>\n+     *\n+     * Equivalent to: {@code 5 << 12}\n+     */\n+    private static final short OFFSET = 20480;", "originalCommit": "41c98e5e93537a0ff66f85490c616337e3e6ec53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ac9d5736766cc880194db9bab0c5153110b1e946", "url": "https://github.com/netty/netty/commit/ac9d5736766cc880194db9bab0c5153110b1e946", "message": "code improvement", "committedDate": "2020-09-01T18:44:22Z", "type": "commit"}, {"oid": "df33424080764b588319c734935f3377f5be66e5", "url": "https://github.com/netty/netty/commit/df33424080764b588319c734935f3377f5be66e5", "message": "release bytebuf in test", "committedDate": "2020-09-01T18:48:26Z", "type": "commit"}, {"oid": "49963edff2fb6d7167f6cda85c953421d7681c26", "url": "https://github.com/netty/netty/commit/49963edff2fb6d7167f6cda85c953421d7681c26", "message": "swap Bytebuf#readableBytes and V4_HEADER_SIZE position.", "committedDate": "2020-09-01T18:56:46Z", "type": "commit"}, {"oid": "bc640dd8b929af3195624749c9a91c3b79e41ffd", "url": "https://github.com/netty/netty/commit/bc640dd8b929af3195624749c9a91c3b79e41ffd", "message": "update documentations", "committedDate": "2020-09-01T19:06:03Z", "type": "commit"}, {"oid": "42f01bc649d20d8ad52a3894329821d6471ffe77", "url": "https://github.com/netty/netty/commit/42f01bc649d20d8ad52a3894329821d6471ffe77", "message": "code style fix", "committedDate": "2020-09-01T19:07:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3OTY0OA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r481379648", "bodyText": "This value is still in milliseconds, but looks like pcap wants microseconds. It could cause confusion to people using this, if we're off by a factor 1.000.", "author": "chrisvest", "createdAt": "2020-09-01T19:26:04Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCapWriter.java", "diffHunk": "@@ -50,13 +48,10 @@\n     void writePacket(ByteBuf packetHeaderBuf, ByteBuf packet) throws IOException {\n         long currentTime = System.currentTimeMillis();\n \n-        String microsecond = sdf.format(new Date(currentTime));\n-        microsecond = microsecond.substring(microsecond.indexOf(\".\") + 1);\n-\n         PcapHeaders.writePacketHeader(\n                 packetHeaderBuf,\n-                currentTime,\n-                Integer.parseInt(microsecond),\n+                (int) TimeUnit.MILLISECONDS.toSeconds(currentTime),\n+                (int) currentTime % 1000,", "originalCommit": "ac9d5736766cc880194db9bab0c5153110b1e946", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM4MjAzNg==", "url": "https://github.com/netty/netty/pull/10498#discussion_r481382036", "bodyText": "Lol, need spoon feeding again. Haha. I tried but value went into negative. Help :p", "author": "hyperxpro", "createdAt": "2020-09-01T19:30:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3OTY0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTc4ODY5Nw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r481788697", "bodyText": "Finally, after lots of tries. Figured it out.", "author": "hyperxpro", "createdAt": "2020-09-02T06:35:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTM3OTY0OA=="}], "type": "inlineReview"}, {"oid": "ea3b40691bf4c41b2a28e39819a3a4f544d329a0", "url": "https://github.com/netty/netty/commit/ea3b40691bf4c41b2a28e39819a3a4f544d329a0", "message": "Fix timestamp", "committedDate": "2020-09-02T06:34:00Z", "type": "commit"}, {"oid": "e77cf5ea937087b0c7198f5651385b289873bd68", "url": "https://github.com/netty/netty/commit/e77cf5ea937087b0c7198f5651385b289873bd68", "message": "add option to override Pcap Global Header write", "committedDate": "2020-09-02T08:44:02Z", "type": "commit"}, {"oid": "ed0f0f5367c25f211805ff810e68562e64456c14", "url": "https://github.com/netty/netty/commit/ed0f0f5367c25f211805ff810e68562e64456c14", "message": "No need to allocate ByteBuf if `writePcapGlobalHeader` is `false`", "committedDate": "2020-09-02T08:46:12Z", "type": "commit"}, {"oid": "f2f671271df7ada45d91be4b217ed1df2b075627", "url": "https://github.com/netty/netty/commit/f2f671271df7ada45d91be4b217ed1df2b075627", "message": "Flush the `OutputStream` when closing `PcapWriter`", "committedDate": "2020-09-02T08:50:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk0NTcwNw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r481945707", "bodyText": "The way these parameter docs are written makes the boolean parameters sound like a field that client code is reading, but the boolean values are more like commands that direct behaviour.\nHere's an example of what it looks like when written in that style:\n@param captureZeroByte Set to {@code true} to enable capturing packets with empty (0 bytes) payload. Otherwise, if {@code false}, empty packets will be filtered out.", "author": "chrisvest", "createdAt": "2020-09-02T09:51:03Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCAPWriteHandler.java", "diffHunk": "@@ -99,31 +104,39 @@\n \n     /**\n      * Create new {@link PCAPWriteHandler} Instance.\n-     * {@code captureZeroByte} are set to {@code false}.\n+     * {@code captureZeroByte} is set to {@code false} and\n+     * {@code writePcapGlobalHeader} is set to {@code true}.\n      *\n      * @param outputStream OutputStream where Pcap data will be written\n      */\n     public PCAPWriteHandler(OutputStream outputStream) {\n-        this(outputStream, false);\n+        this(outputStream, false, true);\n     }\n \n     /**\n      * Create new {@link PCAPWriteHandler} Instance\n      *\n-     * @param outputStream    OutputStream where Pcap data will be written\n-     * @param captureZeroByte {@code true} If we'll capture packets with 0 bytes\n+     * @param outputStream          OutputStream where Pcap data will be written\n+     * @param captureZeroByte       {@code true} If we'll capture packets with 0 bytes else {@code false}\n+     * @param writePcapGlobalHeader {@code true} if we want to write Pcap Global Header on initialization\n+     *                              of {@link PCapWriter} else {@code false}.", "originalCommit": "e77cf5ea937087b0c7198f5651385b289873bd68", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e71483e69b07a4ee06720412f9d73c80753d9c4b", "url": "https://github.com/netty/netty/commit/e71483e69b07a4ee06720412f9d73c80753d9c4b", "message": "improve JavaDoc", "committedDate": "2020-09-02T19:46:26Z", "type": "commit"}, {"oid": "d15aa5313747d13db50d804e3b181f8d67307817", "url": "https://github.com/netty/netty/commit/d15aa5313747d13db50d804e3b181f8d67307817", "message": "improve JavaDoc of PCapWriter", "committedDate": "2020-09-02T19:47:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjczOTcxNQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r482739715", "bodyText": "nit: remove ?", "author": "normanmaurer", "createdAt": "2020-09-03T06:43:19Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCAPWriteHandler.java", "diffHunk": "@@ -0,0 +1,410 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.ServerChannel;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.util.NetUtil;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.InetSocketAddress;\n+\n+/**\n+ * <p> {@link PCAPWriteHandler} captures {@link ByteBuf} from {@link SocketChannel} / {@link ServerChannel}\n+ * or {@link DatagramPacket} and writes it into Pcap {@link OutputStream}. </p>\n+ * <p></p>", "originalCommit": "d15aa5313747d13db50d804e3b181f8d67307817", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MDc1MQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r482740751", "bodyText": "I think this is not correct... Shouldn't this be ctx.channel().parent() ?", "author": "normanmaurer", "createdAt": "2020-09-03T06:45:30Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCAPWriteHandler.java", "diffHunk": "@@ -0,0 +1,410 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.ServerChannel;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.util.NetUtil;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.InetSocketAddress;\n+\n+/**\n+ * <p> {@link PCAPWriteHandler} captures {@link ByteBuf} from {@link SocketChannel} / {@link ServerChannel}\n+ * or {@link DatagramPacket} and writes it into Pcap {@link OutputStream}. </p>\n+ * <p></p>\n+ *\n+ * <p>\n+ * Things to keep in mind when using {@link PCAPWriteHandler} with TCP:\n+ *\n+ *    <ul>\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#channelActive(ChannelHandlerContext)} is called,\n+ *        a fake TCP 3-way handshake (SYN, SYN+ACK, ACK) is simulated as new connection in Pcap. </li>\n+ *\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#handlerRemoved(ChannelHandlerContext)} is called,\n+ *        a fake TCP 3-way handshake (FIN+ACK, FIN+ACK, ACK) is simulated as connection shutdown in Pcap.  </li>\n+ *\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#exceptionCaught(ChannelHandlerContext, Throwable)}\n+ *        is called, a fake TCP RST is sent to simulate connection Reset in Pcap. </li>\n+ *\n+ *        <li> ACK is sent each time data is send / received. </li>\n+ *\n+ *        <li> Zero Length Data Packets can cause TCP Double ACK error in Wireshark. To tackle this,\n+ *        set {@code captureZeroByte} to {@code false}. </li>\n+ *    </ul>\n+ * </p>\n+ */\n+public final class PCAPWriteHandler extends ChannelDuplexHandler {\n+\n+    private final InternalLogger logger = InternalLoggerFactory.getInstance(PCAPWriteHandler.class);\n+\n+    /**\n+     * {@link PCapWriter} Instance\n+     */\n+    private PCapWriter pCapWriter;\n+\n+    /**\n+     * {@link OutputStream} where we'll write Pcap data.\n+     */\n+    private final OutputStream outputStream;\n+\n+    /**\n+     * {@code true} if we want to capture packets with zero bytes else {@code false}.\n+     */\n+    private final boolean captureZeroByte;\n+\n+    /**\n+     * {@code true} if we want to write Pcap Global Header on initialization of\n+     * {@link PCapWriter} else {@code false}.\n+     */\n+    private final boolean writePcapGlobalHeader;\n+\n+    /**\n+     * TCP Sender Segment Number.\n+     */\n+    private int sendSegmentNumber = 1;\n+\n+    /**\n+     * TCP Receiver Segment Number\n+     */\n+    private int receiveSegmentNumber = 1;\n+\n+    /**\n+     * Source Address [TCP ONLY]\n+     */\n+    private InetSocketAddress srcAddr;\n+\n+    /**\n+     * Destination Address [TCP ONLY]\n+     */\n+    private InetSocketAddress dstAddr;\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code captureZeroByte} is set to {@code false} and\n+     * {@code writePcapGlobalHeader} is set to {@code true}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream) {\n+        this(outputStream, false, true);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance\n+     *\n+     * @param outputStream          OutputStream where Pcap data will be written\n+     * @param captureZeroByte       Set to {@code true} to enable capturing packets with empty (0 bytes) payload.\n+     *                              Otherwise, if set to {@code false}, empty packets will be filtered out.\n+     * @param writePcapGlobalHeader Set to {@code true} to write Pcap Global Header on initialization.\n+     *                              Otherwise, if set to {@code false}, Pcap Global Header will not be written\n+     *                              on initialization. This could when writing Pcap data on a existing file where\n+     *                              Pcap Global Header is already present.\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean captureZeroByte, boolean writePcapGlobalHeader) {\n+        this.outputStream = outputStream;\n+        this.captureZeroByte = captureZeroByte;\n+        this.writePcapGlobalHeader = writePcapGlobalHeader;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+\n+        /*\n+         * If `writePcapGlobalHeader` is `true`, we'll write Pcap Global Header.\n+         */\n+        if (writePcapGlobalHeader) {\n+\n+            ByteBuf byteBuf = ctx.alloc().buffer();\n+            try {\n+                this.pCapWriter = new PCapWriter(this.outputStream, byteBuf);\n+            } catch (IOException ex) {\n+                ctx.fireExceptionCaught(ex);\n+            } finally {\n+                byteBuf.release();\n+            }\n+\n+        } else {\n+            this.pCapWriter = new PCapWriter(this.outputStream);\n+        }\n+\n+        if (ctx.channel() instanceof SocketChannel) {\n+            if (ctx.channel() instanceof ServerChannel) {", "originalCommit": "d15aa5313747d13db50d804e3b181f8d67307817", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc4MzA0OA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r482783048", "bodyText": "Alright. Still learning the internals of Netty so didn't know. Fixed :D", "author": "hyperxpro", "createdAt": "2020-09-03T07:58:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MDc1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MDg3NQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r482740875", "bodyText": "nit: you can merge this in the above if block", "author": "normanmaurer", "createdAt": "2020-09-03T06:45:46Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCAPWriteHandler.java", "diffHunk": "@@ -0,0 +1,410 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.ServerChannel;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.util.NetUtil;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.InetSocketAddress;\n+\n+/**\n+ * <p> {@link PCAPWriteHandler} captures {@link ByteBuf} from {@link SocketChannel} / {@link ServerChannel}\n+ * or {@link DatagramPacket} and writes it into Pcap {@link OutputStream}. </p>\n+ * <p></p>\n+ *\n+ * <p>\n+ * Things to keep in mind when using {@link PCAPWriteHandler} with TCP:\n+ *\n+ *    <ul>\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#channelActive(ChannelHandlerContext)} is called,\n+ *        a fake TCP 3-way handshake (SYN, SYN+ACK, ACK) is simulated as new connection in Pcap. </li>\n+ *\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#handlerRemoved(ChannelHandlerContext)} is called,\n+ *        a fake TCP 3-way handshake (FIN+ACK, FIN+ACK, ACK) is simulated as connection shutdown in Pcap.  </li>\n+ *\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#exceptionCaught(ChannelHandlerContext, Throwable)}\n+ *        is called, a fake TCP RST is sent to simulate connection Reset in Pcap. </li>\n+ *\n+ *        <li> ACK is sent each time data is send / received. </li>\n+ *\n+ *        <li> Zero Length Data Packets can cause TCP Double ACK error in Wireshark. To tackle this,\n+ *        set {@code captureZeroByte} to {@code false}. </li>\n+ *    </ul>\n+ * </p>\n+ */\n+public final class PCAPWriteHandler extends ChannelDuplexHandler {\n+\n+    private final InternalLogger logger = InternalLoggerFactory.getInstance(PCAPWriteHandler.class);\n+\n+    /**\n+     * {@link PCapWriter} Instance\n+     */\n+    private PCapWriter pCapWriter;\n+\n+    /**\n+     * {@link OutputStream} where we'll write Pcap data.\n+     */\n+    private final OutputStream outputStream;\n+\n+    /**\n+     * {@code true} if we want to capture packets with zero bytes else {@code false}.\n+     */\n+    private final boolean captureZeroByte;\n+\n+    /**\n+     * {@code true} if we want to write Pcap Global Header on initialization of\n+     * {@link PCapWriter} else {@code false}.\n+     */\n+    private final boolean writePcapGlobalHeader;\n+\n+    /**\n+     * TCP Sender Segment Number.\n+     */\n+    private int sendSegmentNumber = 1;\n+\n+    /**\n+     * TCP Receiver Segment Number\n+     */\n+    private int receiveSegmentNumber = 1;\n+\n+    /**\n+     * Source Address [TCP ONLY]\n+     */\n+    private InetSocketAddress srcAddr;\n+\n+    /**\n+     * Destination Address [TCP ONLY]\n+     */\n+    private InetSocketAddress dstAddr;\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code captureZeroByte} is set to {@code false} and\n+     * {@code writePcapGlobalHeader} is set to {@code true}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream) {\n+        this(outputStream, false, true);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance\n+     *\n+     * @param outputStream          OutputStream where Pcap data will be written\n+     * @param captureZeroByte       Set to {@code true} to enable capturing packets with empty (0 bytes) payload.\n+     *                              Otherwise, if set to {@code false}, empty packets will be filtered out.\n+     * @param writePcapGlobalHeader Set to {@code true} to write Pcap Global Header on initialization.\n+     *                              Otherwise, if set to {@code false}, Pcap Global Header will not be written\n+     *                              on initialization. This could when writing Pcap data on a existing file where\n+     *                              Pcap Global Header is already present.\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean captureZeroByte, boolean writePcapGlobalHeader) {\n+        this.outputStream = outputStream;\n+        this.captureZeroByte = captureZeroByte;\n+        this.writePcapGlobalHeader = writePcapGlobalHeader;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+\n+        /*\n+         * If `writePcapGlobalHeader` is `true`, we'll write Pcap Global Header.\n+         */\n+        if (writePcapGlobalHeader) {\n+\n+            ByteBuf byteBuf = ctx.alloc().buffer();\n+            try {\n+                this.pCapWriter = new PCapWriter(this.outputStream, byteBuf);\n+            } catch (IOException ex) {\n+                ctx.fireExceptionCaught(ex);\n+            } finally {\n+                byteBuf.release();\n+            }\n+\n+        } else {\n+            this.pCapWriter = new PCapWriter(this.outputStream);\n+        }\n+\n+        if (ctx.channel() instanceof SocketChannel) {\n+            if (ctx.channel() instanceof ServerChannel) {\n+                srcAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().localAddress();\n+            } else {\n+                srcAddr = (InetSocketAddress) ctx.channel().localAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+            }\n+        }\n+\n+        if (ctx.channel() instanceof SocketChannel) {", "originalCommit": "d15aa5313747d13db50d804e3b181f8d67307817", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MjI5OA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r482742298", "bodyText": "this is not really correct... Even with UDP we may see ByteBuf messages if the channel is connected. I think you should use ctx.channel() instanceof DatagramChannel to decide if its UDP or not", "author": "normanmaurer", "createdAt": "2020-09-03T06:49:12Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCAPWriteHandler.java", "diffHunk": "@@ -0,0 +1,410 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.ServerChannel;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.util.NetUtil;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.InetSocketAddress;\n+\n+/**\n+ * <p> {@link PCAPWriteHandler} captures {@link ByteBuf} from {@link SocketChannel} / {@link ServerChannel}\n+ * or {@link DatagramPacket} and writes it into Pcap {@link OutputStream}. </p>\n+ * <p></p>\n+ *\n+ * <p>\n+ * Things to keep in mind when using {@link PCAPWriteHandler} with TCP:\n+ *\n+ *    <ul>\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#channelActive(ChannelHandlerContext)} is called,\n+ *        a fake TCP 3-way handshake (SYN, SYN+ACK, ACK) is simulated as new connection in Pcap. </li>\n+ *\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#handlerRemoved(ChannelHandlerContext)} is called,\n+ *        a fake TCP 3-way handshake (FIN+ACK, FIN+ACK, ACK) is simulated as connection shutdown in Pcap.  </li>\n+ *\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#exceptionCaught(ChannelHandlerContext, Throwable)}\n+ *        is called, a fake TCP RST is sent to simulate connection Reset in Pcap. </li>\n+ *\n+ *        <li> ACK is sent each time data is send / received. </li>\n+ *\n+ *        <li> Zero Length Data Packets can cause TCP Double ACK error in Wireshark. To tackle this,\n+ *        set {@code captureZeroByte} to {@code false}. </li>\n+ *    </ul>\n+ * </p>\n+ */\n+public final class PCAPWriteHandler extends ChannelDuplexHandler {\n+\n+    private final InternalLogger logger = InternalLoggerFactory.getInstance(PCAPWriteHandler.class);\n+\n+    /**\n+     * {@link PCapWriter} Instance\n+     */\n+    private PCapWriter pCapWriter;\n+\n+    /**\n+     * {@link OutputStream} where we'll write Pcap data.\n+     */\n+    private final OutputStream outputStream;\n+\n+    /**\n+     * {@code true} if we want to capture packets with zero bytes else {@code false}.\n+     */\n+    private final boolean captureZeroByte;\n+\n+    /**\n+     * {@code true} if we want to write Pcap Global Header on initialization of\n+     * {@link PCapWriter} else {@code false}.\n+     */\n+    private final boolean writePcapGlobalHeader;\n+\n+    /**\n+     * TCP Sender Segment Number.\n+     */\n+    private int sendSegmentNumber = 1;\n+\n+    /**\n+     * TCP Receiver Segment Number\n+     */\n+    private int receiveSegmentNumber = 1;\n+\n+    /**\n+     * Source Address [TCP ONLY]\n+     */\n+    private InetSocketAddress srcAddr;\n+\n+    /**\n+     * Destination Address [TCP ONLY]\n+     */\n+    private InetSocketAddress dstAddr;\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code captureZeroByte} is set to {@code false} and\n+     * {@code writePcapGlobalHeader} is set to {@code true}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream) {\n+        this(outputStream, false, true);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance\n+     *\n+     * @param outputStream          OutputStream where Pcap data will be written\n+     * @param captureZeroByte       Set to {@code true} to enable capturing packets with empty (0 bytes) payload.\n+     *                              Otherwise, if set to {@code false}, empty packets will be filtered out.\n+     * @param writePcapGlobalHeader Set to {@code true} to write Pcap Global Header on initialization.\n+     *                              Otherwise, if set to {@code false}, Pcap Global Header will not be written\n+     *                              on initialization. This could when writing Pcap data on a existing file where\n+     *                              Pcap Global Header is already present.\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean captureZeroByte, boolean writePcapGlobalHeader) {\n+        this.outputStream = outputStream;\n+        this.captureZeroByte = captureZeroByte;\n+        this.writePcapGlobalHeader = writePcapGlobalHeader;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+\n+        /*\n+         * If `writePcapGlobalHeader` is `true`, we'll write Pcap Global Header.\n+         */\n+        if (writePcapGlobalHeader) {\n+\n+            ByteBuf byteBuf = ctx.alloc().buffer();\n+            try {\n+                this.pCapWriter = new PCapWriter(this.outputStream, byteBuf);\n+            } catch (IOException ex) {\n+                ctx.fireExceptionCaught(ex);\n+            } finally {\n+                byteBuf.release();\n+            }\n+\n+        } else {\n+            this.pCapWriter = new PCapWriter(this.outputStream);\n+        }\n+\n+        if (ctx.channel() instanceof SocketChannel) {\n+            if (ctx.channel() instanceof ServerChannel) {\n+                srcAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().localAddress();\n+            } else {\n+                srcAddr = (InetSocketAddress) ctx.channel().localAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+            }\n+        }\n+\n+        if (ctx.channel() instanceof SocketChannel) {\n+            logger.debug(\"Starting Fake TCP 3-Way Handshake\");\n+\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            try {\n+                // Write SYN with Normal Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, 0, 0, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.TCPFlag.SYN);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc(), ctx);\n+\n+                // Write SYN+ACK with Reversed Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, 0, 1, dstAddr.getPort(), srcAddr.getPort(), TCPPacket.TCPFlag.SYN,\n+                        TCPPacket.TCPFlag.ACK);\n+                completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc(), ctx);\n+\n+                // Write ACK with Normal Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, 1, 1, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc(), ctx);\n+            } finally {\n+                tcpBuf.release();\n+            }\n+\n+            logger.debug(\"Finished Fake TCP 3-Way Handshake\");\n+        }\n+\n+        super.channelActive(ctx);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        writePacket(ctx, msg, false);\n+        super.channelRead(ctx, msg);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        writePacket(ctx, msg, true);\n+        super.write(ctx, msg, promise);\n+    }\n+\n+    private void writePacket(ChannelHandlerContext ctx, Object msg, boolean isWriteOperation) {\n+        if (msg instanceof ByteBuf) {\n+\n+            // If bytes are 0 and `captureZeroByte` is false, we won't capture this.\n+            if (((ByteBuf) msg).readableBytes() == 0 && !captureZeroByte) {\n+                logger.debug(\"Discarding Zero Byte TCP Packet. isWriteOperation {}\", isWriteOperation);\n+                return;\n+            }\n+\n+            ByteBuf packet = ((ByteBuf) msg).duplicate();\n+            ByteBuf tcpBuf = ctx.alloc().buffer();", "originalCommit": "d15aa5313747d13db50d804e3b181f8d67307817", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc2NjQwNw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r482766407", "bodyText": "Handling the EmbeddedChannel with this approach will be an issue then for Unit Tests. I'm replacing the EmbeddedChannel with Bootstrap client in Test Case.", "author": "hyperxpro", "createdAt": "2020-09-03T07:31:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MjI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MjQ2Nw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r482742467", "bodyText": "See comment above... ByteBuf is valid for DatagramChannel as well", "author": "normanmaurer", "createdAt": "2020-09-03T06:49:33Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCAPWriteHandler.java", "diffHunk": "@@ -0,0 +1,410 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.ServerChannel;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.util.NetUtil;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.InetSocketAddress;\n+\n+/**\n+ * <p> {@link PCAPWriteHandler} captures {@link ByteBuf} from {@link SocketChannel} / {@link ServerChannel}\n+ * or {@link DatagramPacket} and writes it into Pcap {@link OutputStream}. </p>\n+ * <p></p>\n+ *\n+ * <p>\n+ * Things to keep in mind when using {@link PCAPWriteHandler} with TCP:\n+ *\n+ *    <ul>\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#channelActive(ChannelHandlerContext)} is called,\n+ *        a fake TCP 3-way handshake (SYN, SYN+ACK, ACK) is simulated as new connection in Pcap. </li>\n+ *\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#handlerRemoved(ChannelHandlerContext)} is called,\n+ *        a fake TCP 3-way handshake (FIN+ACK, FIN+ACK, ACK) is simulated as connection shutdown in Pcap.  </li>\n+ *\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#exceptionCaught(ChannelHandlerContext, Throwable)}\n+ *        is called, a fake TCP RST is sent to simulate connection Reset in Pcap. </li>\n+ *\n+ *        <li> ACK is sent each time data is send / received. </li>\n+ *\n+ *        <li> Zero Length Data Packets can cause TCP Double ACK error in Wireshark. To tackle this,\n+ *        set {@code captureZeroByte} to {@code false}. </li>\n+ *    </ul>\n+ * </p>\n+ */\n+public final class PCAPWriteHandler extends ChannelDuplexHandler {\n+\n+    private final InternalLogger logger = InternalLoggerFactory.getInstance(PCAPWriteHandler.class);\n+\n+    /**\n+     * {@link PCapWriter} Instance\n+     */\n+    private PCapWriter pCapWriter;\n+\n+    /**\n+     * {@link OutputStream} where we'll write Pcap data.\n+     */\n+    private final OutputStream outputStream;\n+\n+    /**\n+     * {@code true} if we want to capture packets with zero bytes else {@code false}.\n+     */\n+    private final boolean captureZeroByte;\n+\n+    /**\n+     * {@code true} if we want to write Pcap Global Header on initialization of\n+     * {@link PCapWriter} else {@code false}.\n+     */\n+    private final boolean writePcapGlobalHeader;\n+\n+    /**\n+     * TCP Sender Segment Number.\n+     */\n+    private int sendSegmentNumber = 1;\n+\n+    /**\n+     * TCP Receiver Segment Number\n+     */\n+    private int receiveSegmentNumber = 1;\n+\n+    /**\n+     * Source Address [TCP ONLY]\n+     */\n+    private InetSocketAddress srcAddr;\n+\n+    /**\n+     * Destination Address [TCP ONLY]\n+     */\n+    private InetSocketAddress dstAddr;\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code captureZeroByte} is set to {@code false} and\n+     * {@code writePcapGlobalHeader} is set to {@code true}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream) {\n+        this(outputStream, false, true);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance\n+     *\n+     * @param outputStream          OutputStream where Pcap data will be written\n+     * @param captureZeroByte       Set to {@code true} to enable capturing packets with empty (0 bytes) payload.\n+     *                              Otherwise, if set to {@code false}, empty packets will be filtered out.\n+     * @param writePcapGlobalHeader Set to {@code true} to write Pcap Global Header on initialization.\n+     *                              Otherwise, if set to {@code false}, Pcap Global Header will not be written\n+     *                              on initialization. This could when writing Pcap data on a existing file where\n+     *                              Pcap Global Header is already present.\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean captureZeroByte, boolean writePcapGlobalHeader) {\n+        this.outputStream = outputStream;\n+        this.captureZeroByte = captureZeroByte;\n+        this.writePcapGlobalHeader = writePcapGlobalHeader;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+\n+        /*\n+         * If `writePcapGlobalHeader` is `true`, we'll write Pcap Global Header.\n+         */\n+        if (writePcapGlobalHeader) {\n+\n+            ByteBuf byteBuf = ctx.alloc().buffer();\n+            try {\n+                this.pCapWriter = new PCapWriter(this.outputStream, byteBuf);\n+            } catch (IOException ex) {\n+                ctx.fireExceptionCaught(ex);\n+            } finally {\n+                byteBuf.release();\n+            }\n+\n+        } else {\n+            this.pCapWriter = new PCapWriter(this.outputStream);\n+        }\n+\n+        if (ctx.channel() instanceof SocketChannel) {\n+            if (ctx.channel() instanceof ServerChannel) {\n+                srcAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().localAddress();\n+            } else {\n+                srcAddr = (InetSocketAddress) ctx.channel().localAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+            }\n+        }\n+\n+        if (ctx.channel() instanceof SocketChannel) {\n+            logger.debug(\"Starting Fake TCP 3-Way Handshake\");\n+\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            try {\n+                // Write SYN with Normal Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, 0, 0, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.TCPFlag.SYN);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc(), ctx);\n+\n+                // Write SYN+ACK with Reversed Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, 0, 1, dstAddr.getPort(), srcAddr.getPort(), TCPPacket.TCPFlag.SYN,\n+                        TCPPacket.TCPFlag.ACK);\n+                completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc(), ctx);\n+\n+                // Write ACK with Normal Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, 1, 1, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc(), ctx);\n+            } finally {\n+                tcpBuf.release();\n+            }\n+\n+            logger.debug(\"Finished Fake TCP 3-Way Handshake\");\n+        }\n+\n+        super.channelActive(ctx);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        writePacket(ctx, msg, false);\n+        super.channelRead(ctx, msg);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        writePacket(ctx, msg, true);\n+        super.write(ctx, msg, promise);\n+    }\n+\n+    private void writePacket(ChannelHandlerContext ctx, Object msg, boolean isWriteOperation) {\n+        if (msg instanceof ByteBuf) {\n+\n+            // If bytes are 0 and `captureZeroByte` is false, we won't capture this.\n+            if (((ByteBuf) msg).readableBytes() == 0 && !captureZeroByte) {\n+                logger.debug(\"Discarding Zero Byte TCP Packet. isWriteOperation {}\", isWriteOperation);\n+                return;\n+            }\n+\n+            ByteBuf packet = ((ByteBuf) msg).duplicate();\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+            int bytes = packet.readableBytes();\n+\n+            try {\n+                if (isWriteOperation) {\n+                    TCPPacket.writePacket(tcpBuf, packet, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                            dstAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                    completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc(), ctx);\n+                    logTCP(true, bytes, sendSegmentNumber, receiveSegmentNumber, srcAddr, dstAddr, false);\n+\n+                    sendSegmentNumber += bytes;\n+\n+                    TCPPacket.writePacket(tcpBuf, null, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                            srcAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                    completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc(), ctx);\n+                    logTCP(true, bytes, sendSegmentNumber, receiveSegmentNumber, dstAddr, srcAddr, true);\n+                } else {\n+                    TCPPacket.writePacket(tcpBuf, packet, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                            srcAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                    completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc(), ctx);\n+                    logTCP(false, bytes, receiveSegmentNumber, sendSegmentNumber, dstAddr, srcAddr, false);\n+\n+                    receiveSegmentNumber += bytes;\n+\n+                    TCPPacket.writePacket(tcpBuf, null, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                            dstAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                    completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc(), ctx);\n+                    logTCP(false, bytes, sendSegmentNumber, receiveSegmentNumber, srcAddr, dstAddr, true);\n+                }\n+            } finally {\n+                tcpBuf.release();\n+            }\n+\n+        } else if (msg instanceof DatagramPacket) {\n+            handleUDP(ctx, ((DatagramPacket) msg).duplicate());", "originalCommit": "d15aa5313747d13db50d804e3b181f8d67307817", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MzA0Nw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r482743047", "bodyText": "use handleUDP(ChannelHandlerContext ctx, ByteBuf content, InetSocketAddress src, InetSocketAddress dst) as signature so it also can be used with \"connected datagram channel\" (See above)", "author": "normanmaurer", "createdAt": "2020-09-03T06:50:47Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCAPWriteHandler.java", "diffHunk": "@@ -0,0 +1,410 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.ServerChannel;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.util.NetUtil;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.InetSocketAddress;\n+\n+/**\n+ * <p> {@link PCAPWriteHandler} captures {@link ByteBuf} from {@link SocketChannel} / {@link ServerChannel}\n+ * or {@link DatagramPacket} and writes it into Pcap {@link OutputStream}. </p>\n+ * <p></p>\n+ *\n+ * <p>\n+ * Things to keep in mind when using {@link PCAPWriteHandler} with TCP:\n+ *\n+ *    <ul>\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#channelActive(ChannelHandlerContext)} is called,\n+ *        a fake TCP 3-way handshake (SYN, SYN+ACK, ACK) is simulated as new connection in Pcap. </li>\n+ *\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#handlerRemoved(ChannelHandlerContext)} is called,\n+ *        a fake TCP 3-way handshake (FIN+ACK, FIN+ACK, ACK) is simulated as connection shutdown in Pcap.  </li>\n+ *\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#exceptionCaught(ChannelHandlerContext, Throwable)}\n+ *        is called, a fake TCP RST is sent to simulate connection Reset in Pcap. </li>\n+ *\n+ *        <li> ACK is sent each time data is send / received. </li>\n+ *\n+ *        <li> Zero Length Data Packets can cause TCP Double ACK error in Wireshark. To tackle this,\n+ *        set {@code captureZeroByte} to {@code false}. </li>\n+ *    </ul>\n+ * </p>\n+ */\n+public final class PCAPWriteHandler extends ChannelDuplexHandler {\n+\n+    private final InternalLogger logger = InternalLoggerFactory.getInstance(PCAPWriteHandler.class);\n+\n+    /**\n+     * {@link PCapWriter} Instance\n+     */\n+    private PCapWriter pCapWriter;\n+\n+    /**\n+     * {@link OutputStream} where we'll write Pcap data.\n+     */\n+    private final OutputStream outputStream;\n+\n+    /**\n+     * {@code true} if we want to capture packets with zero bytes else {@code false}.\n+     */\n+    private final boolean captureZeroByte;\n+\n+    /**\n+     * {@code true} if we want to write Pcap Global Header on initialization of\n+     * {@link PCapWriter} else {@code false}.\n+     */\n+    private final boolean writePcapGlobalHeader;\n+\n+    /**\n+     * TCP Sender Segment Number.\n+     */\n+    private int sendSegmentNumber = 1;\n+\n+    /**\n+     * TCP Receiver Segment Number\n+     */\n+    private int receiveSegmentNumber = 1;\n+\n+    /**\n+     * Source Address [TCP ONLY]\n+     */\n+    private InetSocketAddress srcAddr;\n+\n+    /**\n+     * Destination Address [TCP ONLY]\n+     */\n+    private InetSocketAddress dstAddr;\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance.\n+     * {@code captureZeroByte} is set to {@code false} and\n+     * {@code writePcapGlobalHeader} is set to {@code true}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream) {\n+        this(outputStream, false, true);\n+    }\n+\n+    /**\n+     * Create new {@link PCAPWriteHandler} Instance\n+     *\n+     * @param outputStream          OutputStream where Pcap data will be written\n+     * @param captureZeroByte       Set to {@code true} to enable capturing packets with empty (0 bytes) payload.\n+     *                              Otherwise, if set to {@code false}, empty packets will be filtered out.\n+     * @param writePcapGlobalHeader Set to {@code true} to write Pcap Global Header on initialization.\n+     *                              Otherwise, if set to {@code false}, Pcap Global Header will not be written\n+     *                              on initialization. This could when writing Pcap data on a existing file where\n+     *                              Pcap Global Header is already present.\n+     */\n+    public PCAPWriteHandler(OutputStream outputStream, boolean captureZeroByte, boolean writePcapGlobalHeader) {\n+        this.outputStream = outputStream;\n+        this.captureZeroByte = captureZeroByte;\n+        this.writePcapGlobalHeader = writePcapGlobalHeader;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+\n+        /*\n+         * If `writePcapGlobalHeader` is `true`, we'll write Pcap Global Header.\n+         */\n+        if (writePcapGlobalHeader) {\n+\n+            ByteBuf byteBuf = ctx.alloc().buffer();\n+            try {\n+                this.pCapWriter = new PCapWriter(this.outputStream, byteBuf);\n+            } catch (IOException ex) {\n+                ctx.fireExceptionCaught(ex);\n+            } finally {\n+                byteBuf.release();\n+            }\n+\n+        } else {\n+            this.pCapWriter = new PCapWriter(this.outputStream);\n+        }\n+\n+        if (ctx.channel() instanceof SocketChannel) {\n+            if (ctx.channel() instanceof ServerChannel) {\n+                srcAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().localAddress();\n+            } else {\n+                srcAddr = (InetSocketAddress) ctx.channel().localAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+            }\n+        }\n+\n+        if (ctx.channel() instanceof SocketChannel) {\n+            logger.debug(\"Starting Fake TCP 3-Way Handshake\");\n+\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            try {\n+                // Write SYN with Normal Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, 0, 0, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.TCPFlag.SYN);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc(), ctx);\n+\n+                // Write SYN+ACK with Reversed Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, 0, 1, dstAddr.getPort(), srcAddr.getPort(), TCPPacket.TCPFlag.SYN,\n+                        TCPPacket.TCPFlag.ACK);\n+                completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc(), ctx);\n+\n+                // Write ACK with Normal Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, 1, 1, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc(), ctx);\n+            } finally {\n+                tcpBuf.release();\n+            }\n+\n+            logger.debug(\"Finished Fake TCP 3-Way Handshake\");\n+        }\n+\n+        super.channelActive(ctx);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        writePacket(ctx, msg, false);\n+        super.channelRead(ctx, msg);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        writePacket(ctx, msg, true);\n+        super.write(ctx, msg, promise);\n+    }\n+\n+    private void writePacket(ChannelHandlerContext ctx, Object msg, boolean isWriteOperation) {\n+        if (msg instanceof ByteBuf) {\n+\n+            // If bytes are 0 and `captureZeroByte` is false, we won't capture this.\n+            if (((ByteBuf) msg).readableBytes() == 0 && !captureZeroByte) {\n+                logger.debug(\"Discarding Zero Byte TCP Packet. isWriteOperation {}\", isWriteOperation);\n+                return;\n+            }\n+\n+            ByteBuf packet = ((ByteBuf) msg).duplicate();\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+            int bytes = packet.readableBytes();\n+\n+            try {\n+                if (isWriteOperation) {\n+                    TCPPacket.writePacket(tcpBuf, packet, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                            dstAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                    completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc(), ctx);\n+                    logTCP(true, bytes, sendSegmentNumber, receiveSegmentNumber, srcAddr, dstAddr, false);\n+\n+                    sendSegmentNumber += bytes;\n+\n+                    TCPPacket.writePacket(tcpBuf, null, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                            srcAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                    completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc(), ctx);\n+                    logTCP(true, bytes, sendSegmentNumber, receiveSegmentNumber, dstAddr, srcAddr, true);\n+                } else {\n+                    TCPPacket.writePacket(tcpBuf, packet, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                            srcAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                    completeTCPWrite(dstAddr, srcAddr, tcpBuf, ctx.alloc(), ctx);\n+                    logTCP(false, bytes, receiveSegmentNumber, sendSegmentNumber, dstAddr, srcAddr, false);\n+\n+                    receiveSegmentNumber += bytes;\n+\n+                    TCPPacket.writePacket(tcpBuf, null, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                            dstAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                    completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc(), ctx);\n+                    logTCP(false, bytes, sendSegmentNumber, receiveSegmentNumber, srcAddr, dstAddr, true);\n+                }\n+            } finally {\n+                tcpBuf.release();\n+            }\n+\n+        } else if (msg instanceof DatagramPacket) {\n+            handleUDP(ctx, ((DatagramPacket) msg).duplicate());\n+        } else {\n+            logger.error(\"Discarding Pcap Write for Object {}\", msg);\n+        }\n+    }\n+\n+    private void logTCP(boolean isWriteOperation, int bytes, int sendSegmentNumber, int receiveSegmentNumber,\n+                        InetSocketAddress srcAddr, InetSocketAddress dstAddr, boolean ackOnly) {\n+        if (ackOnly) {\n+            logger.debug(\"Writing TCP ACK, isWriteOperation {}, Segment Number {}, Ack Number {}, Src Addr {}, \"\n+                    + \"Dst Addr {}\", isWriteOperation, sendSegmentNumber, receiveSegmentNumber, dstAddr, srcAddr);\n+        } else {\n+            logger.debug(\"Writing TCP Data of {} Bytes, isWriteOperation {}, Segment Number {}, Ack Number {}, \" +\n+                            \"Src Addr {}, Dst Addr {}\", bytes, isWriteOperation, sendSegmentNumber,\n+                    receiveSegmentNumber, srcAddr, dstAddr);\n+        }\n+    }\n+\n+    private void handleUDP(ChannelHandlerContext ctx, DatagramPacket datagramPacket) {", "originalCommit": "d15aa5313747d13db50d804e3b181f8d67307817", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc4NDE5Mw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r482784193", "bodyText": "1 doubt, DatagramChannel will be sending DatagramPacket and each DatagramPacket has it's own Source and Destination IP. Am I right? So we don't have to depend on ctx.channel().localAddress() or ctx.channel().remoteAddress().", "author": "hyperxpro", "createdAt": "2020-09-03T08:00:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MzA0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc4Njg2MQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r482786861", "bodyText": "@hyperxpro yes when \"not connected\" that's true... but when a DatagramChannel is connected you can send ByteBuf and in this case the local / remote address is the one of the Channel", "author": "normanmaurer", "createdAt": "2020-09-03T08:04:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MzA0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgyODk2Mw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r482828963", "bodyText": "Handled the signature part in a different fashion.", "author": "hyperxpro", "createdAt": "2020-09-03T09:11:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjc0MzA0Nw=="}], "type": "inlineReview"}, {"oid": "89628fc0d487dd64f04aeaa6a754cffed7189dfa", "url": "https://github.com/netty/netty/commit/89628fc0d487dd64f04aeaa6a754cffed7189dfa", "message": "Add DatagramChannel support and use Bootstrap in Test case", "committedDate": "2020-09-03T09:09:33Z", "type": "commit"}, {"oid": "dd149e87be060f1a5822a9ae64dd4797b6190eb1", "url": "https://github.com/netty/netty/commit/dd149e87be060f1a5822a9ae64dd4797b6190eb1", "message": "fix code style", "committedDate": "2020-09-03T09:29:29Z", "type": "commit"}, {"oid": "ef9dd8f0b8710b79e0e114a74bcd9668aef0e12b", "url": "https://github.com/netty/netty/commit/ef9dd8f0b8710b79e0e114a74bcd9668aef0e12b", "message": "Use Channel localAddress if DatagramPacket sender address is null", "committedDate": "2020-09-03T19:06:04Z", "type": "commit"}, {"oid": "20489f671a367b30f17e3aa819bf58cb62c83cc9", "url": "https://github.com/netty/netty/commit/20489f671a367b30f17e3aa819bf58cb62c83cc9", "message": "Revert test case", "committedDate": "2020-09-03T19:07:08Z", "type": "commit"}, {"oid": "ef7960504ae9c4e7537dd7721d36075a0bf84703", "url": "https://github.com/netty/netty/commit/ef7960504ae9c4e7537dd7721d36075a0bf84703", "message": "fix memory leaks", "committedDate": "2020-09-04T07:05:35Z", "type": "commit"}, {"oid": "e46c674e1f248125c36ce954d07d872474c8c216", "url": "https://github.com/netty/netty/commit/e46c674e1f248125c36ce954d07d872474c8c216", "message": "Documentation and Code Improvements", "committedDate": "2020-09-04T16:30:35Z", "type": "commit"}, {"oid": "fe82a72575e14b79430cf72abb90d1f46c2ce297", "url": "https://github.com/netty/netty/commit/fe82a72575e14b79430cf72abb90d1f46c2ce297", "message": "Change PCAPWriteHandler to PcapWriteHandler for consistency with PcapHeaders and PCapWriter", "committedDate": "2020-09-04T16:36:23Z", "type": "commit"}, {"oid": "643d2d6f2ca577155506864f8d3cc4c197077aeb", "url": "https://github.com/netty/netty/commit/643d2d6f2ca577155506864f8d3cc4c197077aeb", "message": "Change PCapWriter to PcapWriter for consistency with other Pcap source files", "committedDate": "2020-09-04T16:38:36Z", "type": "commit"}, {"oid": "684c8f71d94dee7e00c45eff8c2e213e7b92725c", "url": "https://github.com/netty/netty/commit/684c8f71d94dee7e00c45eff8c2e213e7b92725c", "message": "little bit of code beautification", "committedDate": "2020-09-05T19:51:08Z", "type": "commit"}, {"oid": "d6150a4452f764b236f5e038b1a3659ff9497018", "url": "https://github.com/netty/netty/commit/d6150a4452f764b236f5e038b1a3659ff9497018", "message": "use ByteBufAllocator variable to reduce ctx.alloc() and make code more readable", "committedDate": "2020-09-06T06:26:41Z", "type": "commit"}, {"oid": "b733c947c7bc31a9d951e015bc5039a4be50fcae", "url": "https://github.com/netty/netty/commit/b733c947c7bc31a9d951e015bc5039a4be50fcae", "message": "fix logger", "committedDate": "2020-09-06T06:34:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ3OTg4Ng==", "url": "https://github.com/netty/netty/pull/10498#discussion_r485479886", "bodyText": "this doesn't look right... if we see an IOException here pCapWriter will be null and so we will fail with an NPE later on. I think what you should do is just release the ByteBuf, close the channel and let the exception bubble up.", "author": "normanmaurer", "createdAt": "2020-09-09T09:41:01Z", "path": "handler/src/main/java/io/netty/handler/pcap/PcapWriteHandler.java", "diffHunk": "@@ -0,0 +1,522 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.ServerChannel;\n+import io.netty.channel.socket.DatagramChannel;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.channel.socket.ServerSocketChannel;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.util.NetUtil;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetSocketAddress;\n+\n+/**\n+ * <p> {@link PcapWriteHandler} captures {@link ByteBuf} from {@link SocketChannel} / {@link ServerChannel}\n+ * or {@link DatagramPacket} and writes it into Pcap {@link OutputStream}. </p>\n+ *\n+ * <p>\n+ * Things to keep in mind when using {@link PcapWriteHandler} with TCP:\n+ *\n+ *    <ul>\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#channelActive(ChannelHandlerContext)} is called,\n+ *        a fake TCP 3-way handshake (SYN, SYN+ACK, ACK) is simulated as new connection in Pcap. </li>\n+ *\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#handlerRemoved(ChannelHandlerContext)} is called,\n+ *        a fake TCP 3-way handshake (FIN+ACK, FIN+ACK, ACK) is simulated as connection shutdown in Pcap.  </li>\n+ *\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#exceptionCaught(ChannelHandlerContext, Throwable)}\n+ *        is called, a fake TCP RST is sent to simulate connection Reset in Pcap. </li>\n+ *\n+ *        <li> ACK is sent each time data is send / received. </li>\n+ *\n+ *        <li> Zero Length Data Packets can cause TCP Double ACK error in Wireshark. To tackle this,\n+ *        set {@code captureZeroByte} to {@code false}. </li>\n+ *    </ul>\n+ * </p>\n+ */\n+public final class PcapWriteHandler extends ChannelDuplexHandler {\n+\n+    private final InternalLogger logger = InternalLoggerFactory.getInstance(PcapWriteHandler.class);\n+\n+    /**\n+     * {@link PcapWriter} Instance\n+     */\n+    private PcapWriter pCapWriter;\n+\n+    /**\n+     * {@link OutputStream} where we'll write Pcap data.\n+     */\n+    private final OutputStream outputStream;\n+\n+    /**\n+     * {@code true} if we want to capture packets with zero bytes else {@code false}.\n+     */\n+    private final boolean captureZeroByte;\n+\n+    /**\n+     * {@code true} if we want to write Pcap Global Header on initialization of\n+     * {@link PcapWriter} else {@code false}.\n+     */\n+    private final boolean writePcapGlobalHeader;\n+\n+    /**\n+     * TCP Sender Segment Number.\n+     * It'll start with 1 and keep incrementing with number of bytes read/sent.\n+     */\n+    private int sendSegmentNumber = 1;\n+\n+    /**\n+     * TCP Receiver Segment Number.\n+     * It'll start with 1 and keep incrementing with number of bytes read/sent.\n+     */\n+    private int receiveSegmentNumber = 1;\n+\n+    /**\n+     * Source Address\n+     */\n+    private InetSocketAddress srcAddr;\n+\n+    /**\n+     * Destination Address\n+     */\n+    private InetSocketAddress dstAddr;\n+\n+    /**\n+     * Create new {@link PcapWriteHandler} Instance.\n+     * {@code captureZeroByte} is set to {@code false} and\n+     * {@code writePcapGlobalHeader} is set to {@code true}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     */\n+    public PcapWriteHandler(OutputStream outputStream) {\n+        this(outputStream, false, true);\n+    }\n+\n+    /**\n+     * Create new {@link PcapWriteHandler} Instance\n+     *\n+     * @param outputStream          OutputStream where Pcap data will be written\n+     * @param captureZeroByte       Set to {@code true} to enable capturing packets with empty (0 bytes) payload.\n+     *                              Otherwise, if set to {@code false}, empty packets will be filtered out.\n+     * @param writePcapGlobalHeader Set to {@code true} to write Pcap Global Header on initialization.\n+     *                              Otherwise, if set to {@code false}, Pcap Global Header will not be written\n+     *                              on initialization. This could when writing Pcap data on a existing file where\n+     *                              Pcap Global Header is already present.\n+     */\n+    public PcapWriteHandler(OutputStream outputStream, boolean captureZeroByte, boolean writePcapGlobalHeader) {\n+        this.outputStream = outputStream;\n+        this.captureZeroByte = captureZeroByte;\n+        this.writePcapGlobalHeader = writePcapGlobalHeader;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+\n+        ByteBufAllocator byteBufAllocator = ctx.alloc();\n+\n+        /*\n+         * If `writePcapGlobalHeader` is `true`, we'll write Pcap Global Header.\n+         */\n+        if (writePcapGlobalHeader) {\n+\n+            ByteBuf byteBuf = byteBufAllocator.buffer();\n+            try {\n+                this.pCapWriter = new PcapWriter(this.outputStream, byteBuf);\n+            } catch (IOException ex) {\n+                ctx.fireExceptionCaught(ex);\n+            } finally {\n+                byteBuf.release();\n+            }", "originalCommit": "b733c947c7bc31a9d951e015bc5039a4be50fcae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ4MzM4MA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r485483380", "bodyText": "Should I close the channel every time I get an exception?", "author": "hyperxpro", "createdAt": "2020-09-09T09:46:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ3OTg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ4NDcxOQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r485484719", "bodyText": "not really... its more like if you not close it here we will be in an \"invalid\" state. Alternative you could also remove this handler and log.", "author": "normanmaurer", "createdAt": "2020-09-09T09:49:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ3OTg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ4NzQ2Ng==", "url": "https://github.com/netty/netty/pull/10498#discussion_r485487466", "bodyText": "Done, PTAL. :)", "author": "hyperxpro", "createdAt": "2020-09-09T09:53:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ3OTg4Ng=="}], "type": "inlineReview"}, {"oid": "48a3e522dc9127cec19bb12c772a7b23d53fdf4e", "url": "https://github.com/netty/netty/commit/48a3e522dc9127cec19bb12c772a7b23d53fdf4e", "message": "close channel if we catch exception in channelActive", "committedDate": "2020-09-09T09:52:41Z", "type": "commit"}, {"oid": "35d7e082249d08770f5695a34ccc3fbb9d59e402", "url": "https://github.com/netty/netty/commit/35d7e082249d08770f5695a34ccc3fbb9d59e402", "message": "fix line length exceeding 120", "committedDate": "2020-09-09T09:59:08Z", "type": "commit"}, {"oid": "467ca1852573aa0802f47d63d99d8aec6e1b42c0", "url": "https://github.com/netty/netty/commit/467ca1852573aa0802f47d63d99d8aec6e1b42c0", "message": "add null check in 1st constructor", "committedDate": "2020-09-09T10:00:25Z", "type": "commit"}, {"oid": "467ca1852573aa0802f47d63d99d8aec6e1b42c0", "url": "https://github.com/netty/netty/commit/467ca1852573aa0802f47d63d99d8aec6e1b42c0", "message": "add null check in 1st constructor", "committedDate": "2020-09-09T10:00:25Z", "type": "forcePushed"}, {"oid": "782d8e09200bde3e42e32f13dd87c259b457df96", "url": "https://github.com/netty/netty/commit/782d8e09200bde3e42e32f13dd87c259b457df96", "message": "add logger for IOException", "committedDate": "2020-09-09T10:04:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ4NjU0Ng==", "url": "https://github.com/netty/netty/pull/10498#discussion_r485486546", "bodyText": "I think these \"Discarding\u2026\" messages, here and in TCP and UDP, should be logged as info, since error might lead someone to be paged at night. I'm not sure how Netty normally uses log levels, though. What do you think, @normanmaurer.", "author": "chrisvest", "createdAt": "2020-09-09T09:51:59Z", "path": "handler/src/main/java/io/netty/handler/pcap/PCAPWriteHandler.java", "diffHunk": "@@ -185,24 +187,42 @@ public void channelActive(ChannelHandlerContext ctx) throws Exception {\n             }\n \n             logger.debug(\"Finished Fake TCP 3-Way Handshake\");\n+        } else if (ctx.channel() instanceof DatagramChannel) {\n+            DatagramChannel datagramChannel = (DatagramChannel) ctx.channel();\n+            if (datagramChannel.isConnected()) {\n+                srcAddr = (InetSocketAddress) ctx.channel().localAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+            }\n         }\n \n         super.channelActive(ctx);\n     }\n \n     @Override\n     public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n-        writePacket(ctx, msg, false);\n+        if (ctx.channel() instanceof SocketChannel) {\n+            handleTCP(ctx, msg, false);\n+        } else if (ctx.channel() instanceof DatagramChannel) {\n+            handleUDP(ctx, msg);\n+        } else {\n+            logger.error(\"Discarding Pcap Write for Unknown Channel: {}\", ctx.channel());\n+        }\n         super.channelRead(ctx, msg);\n     }\n \n     @Override\n     public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n-        writePacket(ctx, msg, true);\n+        if (ctx.channel() instanceof SocketChannel) {\n+            handleTCP(ctx, msg, true);\n+        } else if (ctx.channel() instanceof DatagramChannel) {\n+            handleUDP(ctx, msg);\n+        } else {\n+            logger.error(\"Discarding Pcap Write for Unknown Channel: {}\", ctx.channel());", "originalCommit": "89628fc0d487dd64f04aeaa6a754cffed7189dfa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5MzE4NA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r485493184", "bodyText": "Harmless, but no need to declare NPE on the signature; just declaring in the javadoc is good enough.", "author": "chrisvest", "createdAt": "2020-09-09T10:03:13Z", "path": "handler/src/main/java/io/netty/handler/pcap/PcapWriteHandler.java", "diffHunk": "@@ -114,8 +114,10 @@\n      * {@code writePcapGlobalHeader} is set to {@code true}.\n      *\n      * @param outputStream OutputStream where Pcap data will be written\n+     * @throws NullPointerException If {@link OutputStream} is {@code null} then we'll throw an\n+     *                              {@link NullPointerException}\n      */\n-    public PcapWriteHandler(OutputStream outputStream) {\n+    public PcapWriteHandler(OutputStream outputStream) throws NullPointerException {", "originalCommit": "467ca1852573aa0802f47d63d99d8aec6e1b42c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5NzUxNQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r485497515", "bodyText": "I think these \"Discarding\u2026\" messages, here and in TCP and UDP, should be logged as info I think, since error might lead someone to be paged at night. I'm not sure how Netty normally uses log levels, though. What do you think, @normanmaurer.", "author": "chrisvest", "createdAt": "2020-09-09T10:10:26Z", "path": "handler/src/main/java/io/netty/handler/pcap/PcapWriteHandler.java", "diffHunk": "@@ -0,0 +1,532 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.ServerChannel;\n+import io.netty.channel.socket.DatagramChannel;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.channel.socket.ServerSocketChannel;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.util.NetUtil;\n+import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetSocketAddress;\n+\n+/**\n+ * <p> {@link PcapWriteHandler} captures {@link ByteBuf} from {@link SocketChannel} / {@link ServerChannel}\n+ * or {@link DatagramPacket} and writes it into Pcap {@link OutputStream}. </p>\n+ *\n+ * <p>\n+ * Things to keep in mind when using {@link PcapWriteHandler} with TCP:\n+ *\n+ *    <ul>\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#channelActive(ChannelHandlerContext)} is called,\n+ *        a fake TCP 3-way handshake (SYN, SYN+ACK, ACK) is simulated as new connection in Pcap. </li>\n+ *\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#handlerRemoved(ChannelHandlerContext)} is called,\n+ *        a fake TCP 3-way handshake (FIN+ACK, FIN+ACK, ACK) is simulated as connection shutdown in Pcap.  </li>\n+ *\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#exceptionCaught(ChannelHandlerContext, Throwable)}\n+ *        is called, a fake TCP RST is sent to simulate connection Reset in Pcap. </li>\n+ *\n+ *        <li> ACK is sent each time data is send / received. </li>\n+ *\n+ *        <li> Zero Length Data Packets can cause TCP Double ACK error in Wireshark. To tackle this,\n+ *        set {@code captureZeroByte} to {@code false}. </li>\n+ *    </ul>\n+ * </p>\n+ */\n+public final class PcapWriteHandler extends ChannelDuplexHandler {\n+\n+    private final InternalLogger logger = InternalLoggerFactory.getInstance(PcapWriteHandler.class);\n+\n+    /**\n+     * {@link PcapWriter} Instance\n+     */\n+    private PcapWriter pCapWriter;\n+\n+    /**\n+     * {@link OutputStream} where we'll write Pcap data.\n+     */\n+    private final OutputStream outputStream;\n+\n+    /**\n+     * {@code true} if we want to capture packets with zero bytes else {@code false}.\n+     */\n+    private final boolean captureZeroByte;\n+\n+    /**\n+     * {@code true} if we want to write Pcap Global Header on initialization of\n+     * {@link PcapWriter} else {@code false}.\n+     */\n+    private final boolean writePcapGlobalHeader;\n+\n+    /**\n+     * TCP Sender Segment Number.\n+     * It'll start with 1 and keep incrementing with number of bytes read/sent.\n+     */\n+    private int sendSegmentNumber = 1;\n+\n+    /**\n+     * TCP Receiver Segment Number.\n+     * It'll start with 1 and keep incrementing with number of bytes read/sent.\n+     */\n+    private int receiveSegmentNumber = 1;\n+\n+    /**\n+     * Source Address\n+     */\n+    private InetSocketAddress srcAddr;\n+\n+    /**\n+     * Destination Address\n+     */\n+    private InetSocketAddress dstAddr;\n+\n+    /**\n+     * Create new {@link PcapWriteHandler} Instance.\n+     * {@code captureZeroByte} is set to {@code false} and\n+     * {@code writePcapGlobalHeader} is set to {@code true}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     * @throws NullPointerException If {@link OutputStream} is {@code null} then we'll throw an\n+     *                              {@link NullPointerException}\n+     */\n+    public PcapWriteHandler(OutputStream outputStream) throws NullPointerException {\n+        this(outputStream, false, true);\n+    }\n+\n+    /**\n+     * Create new {@link PcapWriteHandler} Instance\n+     *\n+     * @param outputStream          OutputStream where Pcap data will be written\n+     * @param captureZeroByte       Set to {@code true} to enable capturing packets with empty (0 bytes) payload.\n+     *                              Otherwise, if set to {@code false}, empty packets will be filtered out.\n+     * @param writePcapGlobalHeader Set to {@code true} to write Pcap Global Header on initialization.\n+     *                              Otherwise, if set to {@code false}, Pcap Global Header will not be written\n+     *                              on initialization. This could when writing Pcap data on a existing file where\n+     *                              Pcap Global Header is already present.\n+     * @throws NullPointerException If {@link OutputStream} is {@code null} then we'll throw an\n+     *                              {@link NullPointerException}\n+     */\n+    public PcapWriteHandler(OutputStream outputStream, boolean captureZeroByte, boolean writePcapGlobalHeader)\n+            throws NullPointerException {\n+        this.outputStream = ObjectUtil.checkNotNull(outputStream, \"OutputStream\");\n+        this.captureZeroByte = captureZeroByte;\n+        this.writePcapGlobalHeader = writePcapGlobalHeader;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+\n+        ByteBufAllocator byteBufAllocator = ctx.alloc();\n+\n+        /*\n+         * If `writePcapGlobalHeader` is `true`, we'll write Pcap Global Header.\n+         */\n+        if (writePcapGlobalHeader) {\n+\n+            ByteBuf byteBuf = byteBufAllocator.buffer();\n+            try {\n+                this.pCapWriter = new PcapWriter(this.outputStream, byteBuf);\n+            } catch (IOException ex) {\n+                ctx.channel().close();\n+                ctx.fireExceptionCaught(ex);\n+                logger.error(\"Caught Exception While Initializing PcapWriter, Closing Channel.\", ex);\n+            } finally {\n+                byteBuf.release();\n+            }\n+        } else {\n+            this.pCapWriter = new PcapWriter(this.outputStream);\n+        }\n+\n+        // If Channel belongs to `SocketChannel` then we're handling TCP.\n+        if (ctx.channel() instanceof SocketChannel) {\n+\n+            // Capture correct `localAddress` and `remoteAddress`\n+            if (ctx.channel().parent() instanceof ServerSocketChannel) {\n+                srcAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().localAddress();\n+            } else {\n+                srcAddr = (InetSocketAddress) ctx.channel().localAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+            }\n+\n+            logger.debug(\"Initiating Fake TCP 3-Way Handshake\");\n+\n+            ByteBuf tcpBuf = byteBufAllocator.buffer();\n+\n+            try {\n+                // Write SYN with Normal Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, 0, 0, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.TCPFlag.SYN);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, byteBufAllocator, ctx);\n+\n+                // Write SYN+ACK with Reversed Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, 0, 1, dstAddr.getPort(), srcAddr.getPort(), TCPPacket.TCPFlag.SYN,\n+                        TCPPacket.TCPFlag.ACK);\n+                completeTCPWrite(dstAddr, srcAddr, tcpBuf, byteBufAllocator, ctx);\n+\n+                // Write ACK with Normal Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, 1, 1, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, byteBufAllocator, ctx);\n+            } finally {\n+                tcpBuf.release();\n+            }\n+\n+            logger.debug(\"Finished Fake TCP 3-Way Handshake\");\n+        } else if (ctx.channel() instanceof DatagramChannel) {\n+            DatagramChannel datagramChannel = (DatagramChannel) ctx.channel();\n+\n+            // If `DatagramChannel` is connected then we can get\n+            // `localAddress` and `remoteAddress` from Channel.\n+            if (datagramChannel.isConnected()) {\n+                srcAddr = (InetSocketAddress) ctx.channel().localAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+            }\n+        }\n+\n+        super.channelActive(ctx);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        if (ctx.channel() instanceof SocketChannel) {\n+            handleTCP(ctx, msg, false);\n+        } else if (ctx.channel() instanceof DatagramChannel) {\n+            handleUDP(ctx, msg);\n+        } else {\n+            logger.error(\"Discarding Pcap Write for Unknown Channel Type: {}\", ctx.channel());", "originalCommit": "782d8e09200bde3e42e32f13dd87c259b457df96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5ODU2MA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r485498560", "bodyText": "yeah or even debug...", "author": "normanmaurer", "createdAt": "2020-09-09T10:12:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5NzUxNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5OTczNw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r485499737", "bodyText": "Done!", "author": "hyperxpro", "createdAt": "2020-09-09T10:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTQ5NzUxNQ=="}], "type": "inlineReview"}, {"oid": "782d8e09200bde3e42e32f13dd87c259b457df96", "url": "https://github.com/netty/netty/commit/782d8e09200bde3e42e32f13dd87c259b457df96", "message": "add logger for IOException", "committedDate": "2020-09-09T10:04:51Z", "type": "forcePushed"}, {"oid": "12dd4415164d8b3fcf629a53a27fa7c38943fde0", "url": "https://github.com/netty/netty/commit/12dd4415164d8b3fcf629a53a27fa7c38943fde0", "message": "address @chrisvest comments", "committedDate": "2020-09-09T10:15:39Z", "type": "commit"}, {"oid": "4a313affb01402aa5cffa51c22e9ed62c9c44ea1", "url": "https://github.com/netty/netty/commit/4a313affb01402aa5cffa51c22e9ed62c9c44ea1", "message": "little bit of code beautification", "committedDate": "2020-09-09T10:26:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUxNzE1MQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r485517151", "bodyText": "Sorry maybe I miss something but I think for V6 we will have overflow here", "author": "amizurov", "createdAt": "2020-09-09T10:48:02Z", "path": "handler/src/main/java/io/netty/handler/pcap/EthernetPacket.java", "diffHunk": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class EthernetPacket {\n+\n+    /**\n+     * MAC Address: 00:00:5E:00:53:00\n+     */\n+    private static final byte[] DUMMY_SOURCE_MAC_ADDRESS = new byte[]{0, 0, 94, 0, 83, 0};\n+\n+    /**\n+     * MAC Address: 00:00:5E:00:53:FF\n+     */\n+    private static final byte[] DUMMY_DESTINATION_MAC_ADDRESS = new byte[]{0, 0, 94, 0, 83, -1};\n+\n+    /**\n+     * IPv4\n+     */\n+    private static final int V4 = 0x0800;\n+\n+    /**\n+     * IPv6\n+     */\n+    private static final int V6 = 0x86dd;\n+\n+    private EthernetPacket() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Write IPv4 Ethernet Packet. It uses a dummy MAC address for both source and destination.\n+     *\n+     * @param byteBuf ByteBuf where Ethernet Packet data will be set\n+     * @param payload Payload of IPv4\n+     */\n+    static void writeIPv4(ByteBuf byteBuf, ByteBuf payload) {\n+        EthernetPacket.writePacket(byteBuf, payload, DUMMY_SOURCE_MAC_ADDRESS, DUMMY_DESTINATION_MAC_ADDRESS, V4);\n+    }\n+\n+    /**\n+     * Write IPv6 Ethernet Packet. It uses a dummy MAC address for both source and destination.\n+     *\n+     * @param byteBuf ByteBuf where Ethernet Packet data will be set\n+     * @param payload Payload of IPv6\n+     */\n+    static void writeIPv6(ByteBuf byteBuf, ByteBuf payload) {\n+        EthernetPacket.writePacket(byteBuf, payload, DUMMY_SOURCE_MAC_ADDRESS, DUMMY_DESTINATION_MAC_ADDRESS, V6);\n+    }\n+\n+    /**\n+     * Write IPv6 Ethernet Packet\n+     *\n+     * @param byteBuf    ByteBuf where Ethernet Packet data will be set\n+     * @param payload    Payload of IPv6\n+     * @param srcAddress Source MAC Address\n+     * @param dstAddress Destination MAC Address\n+     * @param type       Type of Frame\n+     */\n+    private static void writePacket(ByteBuf byteBuf, ByteBuf payload, byte[] srcAddress, byte[] dstAddress, int type) {\n+        byteBuf.writeBytes(dstAddress); // Destination MAC Address\n+        byteBuf.writeBytes(srcAddress); // Source MAC Address\n+        byteBuf.writeShort(type);       // Frame Type (IPv4 or IPv6)", "originalCommit": "4a313affb01402aa5cffa51c22e9ed62c9c44ea1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUxODM3Ng==", "url": "https://github.com/netty/netty/pull/10498#discussion_r485518376", "bodyText": "No. it won't. This is IPv4 0x0800 and this is IPv6 0x86dd.", "author": "hyperxpro", "createdAt": "2020-09-09T10:50:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUxNzE1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU1NDUxOQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r485554519", "bodyText": "Got it, I thought we were going to read sign short further in test.", "author": "amizurov", "createdAt": "2020-09-09T11:59:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUxNzE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYwODIxNw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r485608217", "bodyText": "@normanmaurer Do I need to catch this IOException and fire 1 more ctx.fireExceptionCaught(ex)?", "author": "hyperxpro", "createdAt": "2020-09-09T13:24:51Z", "path": "handler/src/main/java/io/netty/handler/pcap/PcapWriteHandler.java", "diffHunk": "@@ -0,0 +1,523 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.ServerChannel;\n+import io.netty.channel.socket.DatagramChannel;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.channel.socket.ServerSocketChannel;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.util.NetUtil;\n+import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetSocketAddress;\n+\n+/**\n+ * <p> {@link PcapWriteHandler} captures {@link ByteBuf} from {@link SocketChannel} / {@link ServerChannel}\n+ * or {@link DatagramPacket} and writes it into Pcap {@link OutputStream}. </p>\n+ *\n+ * <p>\n+ * Things to keep in mind when using {@link PcapWriteHandler} with TCP:\n+ *\n+ *    <ul>\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#channelActive(ChannelHandlerContext)} is called,\n+ *        a fake TCP 3-way handshake (SYN, SYN+ACK, ACK) is simulated as new connection in Pcap. </li>\n+ *\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#handlerRemoved(ChannelHandlerContext)} is called,\n+ *        a fake TCP 3-way handshake (FIN+ACK, FIN+ACK, ACK) is simulated as connection shutdown in Pcap.  </li>\n+ *\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#exceptionCaught(ChannelHandlerContext, Throwable)}\n+ *        is called, a fake TCP RST is sent to simulate connection Reset in Pcap. </li>\n+ *\n+ *        <li> ACK is sent each time data is send / received. </li>\n+ *\n+ *        <li> Zero Length Data Packets can cause TCP Double ACK error in Wireshark. To tackle this,\n+ *        set {@code captureZeroByte} to {@code false}. </li>\n+ *    </ul>\n+ * </p>\n+ */\n+public final class PcapWriteHandler extends ChannelDuplexHandler {\n+\n+    private final InternalLogger logger = InternalLoggerFactory.getInstance(PcapWriteHandler.class);\n+\n+    /**\n+     * {@link PcapWriter} Instance\n+     */\n+    private PcapWriter pCapWriter;\n+\n+    /**\n+     * {@link OutputStream} where we'll write Pcap data.\n+     */\n+    private final OutputStream outputStream;\n+\n+    /**\n+     * {@code true} if we want to capture packets with zero bytes else {@code false}.\n+     */\n+    private final boolean captureZeroByte;\n+\n+    /**\n+     * {@code true} if we want to write Pcap Global Header on initialization of\n+     * {@link PcapWriter} else {@code false}.\n+     */\n+    private final boolean writePcapGlobalHeader;\n+\n+    /**\n+     * TCP Sender Segment Number.\n+     * It'll start with 1 and keep incrementing with number of bytes read/sent.\n+     */\n+    private int sendSegmentNumber = 1;\n+\n+    /**\n+     * TCP Receiver Segment Number.\n+     * It'll start with 1 and keep incrementing with number of bytes read/sent.\n+     */\n+    private int receiveSegmentNumber = 1;\n+\n+    /**\n+     * Source Address\n+     */\n+    private InetSocketAddress srcAddr;\n+\n+    /**\n+     * Destination Address\n+     */\n+    private InetSocketAddress dstAddr;\n+\n+    /**\n+     * Create new {@link PcapWriteHandler} Instance.\n+     * {@code captureZeroByte} is set to {@code false} and\n+     * {@code writePcapGlobalHeader} is set to {@code true}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     * @throws NullPointerException If {@link OutputStream} is {@code null} then we'll throw an\n+     *                              {@link NullPointerException}\n+     */\n+    public PcapWriteHandler(OutputStream outputStream) {\n+        this(outputStream, false, true);\n+    }\n+\n+    /**\n+     * Create new {@link PcapWriteHandler} Instance\n+     *\n+     * @param outputStream          OutputStream where Pcap data will be written\n+     * @param captureZeroByte       Set to {@code true} to enable capturing packets with empty (0 bytes) payload.\n+     *                              Otherwise, if set to {@code false}, empty packets will be filtered out.\n+     * @param writePcapGlobalHeader Set to {@code true} to write Pcap Global Header on initialization.\n+     *                              Otherwise, if set to {@code false}, Pcap Global Header will not be written\n+     *                              on initialization. This could when writing Pcap data on a existing file where\n+     *                              Pcap Global Header is already present.\n+     * @throws NullPointerException If {@link OutputStream} is {@code null} then we'll throw an\n+     *                              {@link NullPointerException}\n+     */\n+    public PcapWriteHandler(OutputStream outputStream, boolean captureZeroByte, boolean writePcapGlobalHeader) {\n+        this.outputStream = ObjectUtil.checkNotNull(outputStream, \"OutputStream\");\n+        this.captureZeroByte = captureZeroByte;\n+        this.writePcapGlobalHeader = writePcapGlobalHeader;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+\n+        ByteBufAllocator byteBufAllocator = ctx.alloc();\n+\n+        /*\n+         * If `writePcapGlobalHeader` is `true`, we'll write Pcap Global Header.\n+         */\n+        if (writePcapGlobalHeader) {\n+\n+            ByteBuf byteBuf = byteBufAllocator.buffer();\n+            try {\n+                this.pCapWriter = new PcapWriter(this.outputStream, byteBuf);\n+            } catch (IOException ex) {\n+                ctx.channel().close();\n+                ctx.fireExceptionCaught(ex);\n+                logger.error(\"Caught Exception While Initializing PcapWriter, Closing Channel.\", ex);\n+            } finally {\n+                byteBuf.release();\n+            }\n+        } else {\n+            this.pCapWriter = new PcapWriter(this.outputStream);\n+        }\n+\n+        // If Channel belongs to `SocketChannel` then we're handling TCP.\n+        if (ctx.channel() instanceof SocketChannel) {\n+\n+            // Capture correct `localAddress` and `remoteAddress`\n+            if (ctx.channel().parent() instanceof ServerSocketChannel) {\n+                srcAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().localAddress();\n+            } else {\n+                srcAddr = (InetSocketAddress) ctx.channel().localAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+            }\n+\n+            logger.debug(\"Initiating Fake TCP 3-Way Handshake\");\n+\n+            ByteBuf tcpBuf = byteBufAllocator.buffer();\n+\n+            try {\n+                // Write SYN with Normal Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, 0, 0, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.TCPFlag.SYN);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, byteBufAllocator, ctx);\n+\n+                // Write SYN+ACK with Reversed Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, 0, 1, dstAddr.getPort(), srcAddr.getPort(), TCPPacket.TCPFlag.SYN,\n+                        TCPPacket.TCPFlag.ACK);\n+                completeTCPWrite(dstAddr, srcAddr, tcpBuf, byteBufAllocator, ctx);\n+\n+                // Write ACK with Normal Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, 1, 1, srcAddr.getPort(), dstAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, byteBufAllocator, ctx);\n+            } finally {\n+                tcpBuf.release();\n+            }\n+\n+            logger.debug(\"Finished Fake TCP 3-Way Handshake\");\n+        } else if (ctx.channel() instanceof DatagramChannel) {\n+            DatagramChannel datagramChannel = (DatagramChannel) ctx.channel();\n+\n+            // If `DatagramChannel` is connected then we can get\n+            // `localAddress` and `remoteAddress` from Channel.\n+            if (datagramChannel.isConnected()) {\n+                srcAddr = (InetSocketAddress) ctx.channel().localAddress();\n+                dstAddr = (InetSocketAddress) ctx.channel().remoteAddress();\n+            }\n+        }\n+\n+        super.channelActive(ctx);\n+    }\n+\n+    @Override\n+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {\n+        if (ctx.channel() instanceof SocketChannel) {\n+            handleTCP(ctx, msg, false);\n+        } else if (ctx.channel() instanceof DatagramChannel) {\n+            handleUDP(ctx, msg);\n+        } else {\n+            logger.debug(\"Discarding Pcap Write for Unknown Channel Type: {}\", ctx.channel());\n+        }\n+        super.channelRead(ctx, msg);\n+    }\n+\n+    @Override\n+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        if (ctx.channel() instanceof SocketChannel) {\n+            handleTCP(ctx, msg, true);\n+        } else if (ctx.channel() instanceof DatagramChannel) {\n+            handleUDP(ctx, msg);\n+        } else {\n+            logger.debug(\"Discarding Pcap Write for Unknown Channel Type: {}\", ctx.channel());\n+        }\n+        super.write(ctx, msg, promise);\n+    }\n+\n+    /**\n+     * Handle TCP L4\n+     *\n+     * @param ctx              {@link ChannelHandlerContext} for {@link ByteBuf} allocation and\n+     *                         {@code fireExceptionCaught}\n+     * @param msg              {@link Object} must be {@link ByteBuf} else it'll be discarded\n+     * @param isWriteOperation Set {@code true} if we have to process packet when packets are being sent out\n+     *                         else set {@code false}\n+     */\n+    private void handleTCP(ChannelHandlerContext ctx, Object msg, boolean isWriteOperation) {\n+        if (msg instanceof ByteBuf) {\n+\n+            // If bytes are 0 and `captureZeroByte` is false, we won't capture this.\n+            if (((ByteBuf) msg).readableBytes() == 0 && !captureZeroByte) {\n+                logger.debug(\"Discarding Zero Byte TCP Packet. isWriteOperation {}\", isWriteOperation);\n+                return;\n+            }\n+\n+            ByteBufAllocator byteBufAllocator = ctx.alloc();\n+            ByteBuf packet = ((ByteBuf) msg).duplicate();\n+            ByteBuf tcpBuf = byteBufAllocator.buffer();\n+            int bytes = packet.readableBytes();\n+\n+            try {\n+                if (isWriteOperation) {\n+                    TCPPacket.writePacket(tcpBuf, packet, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                            dstAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                    completeTCPWrite(srcAddr, dstAddr, tcpBuf, byteBufAllocator, ctx);\n+                    logTCP(true, bytes, sendSegmentNumber, receiveSegmentNumber, srcAddr, dstAddr, false);\n+\n+                    sendSegmentNumber += bytes;\n+\n+                    TCPPacket.writePacket(tcpBuf, null, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                            srcAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                    completeTCPWrite(dstAddr, srcAddr, tcpBuf, byteBufAllocator, ctx);\n+                    logTCP(true, bytes, sendSegmentNumber, receiveSegmentNumber, dstAddr, srcAddr, true);\n+                } else {\n+                    TCPPacket.writePacket(tcpBuf, packet, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                            srcAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                    completeTCPWrite(dstAddr, srcAddr, tcpBuf, byteBufAllocator, ctx);\n+                    logTCP(false, bytes, receiveSegmentNumber, sendSegmentNumber, dstAddr, srcAddr, false);\n+\n+                    receiveSegmentNumber += bytes;\n+\n+                    TCPPacket.writePacket(tcpBuf, null, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                            dstAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                    completeTCPWrite(srcAddr, dstAddr, tcpBuf, byteBufAllocator, ctx);\n+                    logTCP(false, bytes, sendSegmentNumber, receiveSegmentNumber, srcAddr, dstAddr, true);\n+                }\n+            } finally {\n+                tcpBuf.release();\n+            }\n+        } else {\n+            logger.debug(\"Discarding Pcap Write for TCP Object: {}\", msg);\n+        }\n+    }\n+\n+    /**\n+     * Write TCP/IP L3 and L2 here.\n+     *\n+     * @param srcAddr          {@link InetSocketAddress} Source Address of this Packet\n+     * @param dstAddr          {@link InetSocketAddress} Destination Address of this Packet\n+     * @param tcpBuf           {@link ByteBuf} containing TCP L4 Data\n+     * @param byteBufAllocator {@link ByteBufAllocator} for allocating bytes for TCP/IP L3 and L2 data.\n+     * @param ctx              {@link ChannelHandlerContext} for {@code fireExceptionCaught}\n+     */\n+    private void completeTCPWrite(InetSocketAddress srcAddr, InetSocketAddress dstAddr, ByteBuf tcpBuf,\n+                                  ByteBufAllocator byteBufAllocator, ChannelHandlerContext ctx) {\n+\n+        ByteBuf ipBuf = byteBufAllocator.buffer();\n+        ByteBuf ethernetBuf = byteBufAllocator.buffer();\n+        ByteBuf pcap = byteBufAllocator.buffer();\n+\n+        try {\n+            if (srcAddr.getAddress() instanceof Inet4Address && dstAddr.getAddress() instanceof Inet4Address) {\n+                IPPacket.writeTCPv4(ipBuf, tcpBuf,\n+                        NetUtil.ipv4AddressToInt((Inet4Address) srcAddr.getAddress()),\n+                        NetUtil.ipv4AddressToInt((Inet4Address) dstAddr.getAddress()));\n+\n+                EthernetPacket.writeIPv4(ethernetBuf, ipBuf);\n+            } else if (srcAddr.getAddress() instanceof Inet6Address && dstAddr.getAddress() instanceof Inet6Address) {\n+                IPPacket.writeTCPv6(ipBuf, tcpBuf,\n+                        srcAddr.getAddress().getAddress(),\n+                        dstAddr.getAddress().getAddress());\n+\n+                EthernetPacket.writeIPv6(ethernetBuf, ipBuf);\n+            } else {\n+                logger.error(\"Source and Destination IP Address versions are not same. Source Address: {}, \" +\n+                        \"Destination Address: {}\", srcAddr.getAddress(), dstAddr.getAddress());\n+                return;\n+            }\n+\n+            // Write Packet into Pcap\n+            pCapWriter.writePacket(pcap, ethernetBuf);\n+        } catch (IOException ex) {\n+            logger.error(\"Caught Exception While Writing Packet into Pcap\", ex);\n+            ctx.fireExceptionCaught(ex);\n+        } finally {\n+            ipBuf.release();\n+            ethernetBuf.release();\n+            pcap.release();\n+        }\n+    }\n+\n+    /**\n+     * Logger for TCP\n+     */\n+    private void logTCP(boolean isWriteOperation, int bytes, int sendSegmentNumber, int receiveSegmentNumber,\n+                        InetSocketAddress srcAddr, InetSocketAddress dstAddr, boolean ackOnly) {\n+        // If `ackOnly` is `true` when we don't need to write any data so we'll not\n+        // log number of bytes being written and mark the operation as \"TCP ACK\".\n+        if (logger.isDebugEnabled()) {\n+            if (ackOnly) {\n+                logger.debug(\"Writing TCP ACK, isWriteOperation {}, Segment Number {}, Ack Number {}, Src Addr {}, \"\n+                        + \"Dst Addr {}\", isWriteOperation, sendSegmentNumber, receiveSegmentNumber, dstAddr, srcAddr);\n+            } else {\n+                logger.debug(\"Writing TCP Data of {} Bytes, isWriteOperation {}, Segment Number {}, Ack Number {}, \" +\n+                                \"Src Addr {}, Dst Addr {}\", bytes, isWriteOperation, sendSegmentNumber,\n+                        receiveSegmentNumber, srcAddr, dstAddr);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Handle UDP l4\n+     *\n+     * @param ctx {@link ChannelHandlerContext} for {@code localAddress} / {@code remoteAddress},\n+     *            {@link ByteBuf} allocation and {@code fireExceptionCaught}\n+     * @param msg {@link DatagramPacket} or {@link DatagramChannel}\n+     */\n+    private void handleUDP(ChannelHandlerContext ctx, Object msg) {\n+        ByteBuf udpBuf = ctx.alloc().buffer();\n+\n+        try {\n+            if (msg instanceof DatagramPacket) {\n+\n+                // If bytes are 0 and `captureZeroByte` is false, we won't capture this.\n+                if (((DatagramPacket) msg).content().readableBytes() == 0 && !captureZeroByte) {\n+                    logger.debug(\"Discarding Zero Byte UDP Packet\");\n+                    return;\n+                }\n+\n+                DatagramPacket datagramPacket = ((DatagramPacket) msg).duplicate();\n+                InetSocketAddress srcAddr = datagramPacket.sender();\n+                InetSocketAddress dstAddr = datagramPacket.recipient();\n+\n+                // If `datagramPacket.sender()` is `null` then DatagramPacket is initialized\n+                // `sender` (local) address. In this case, we'll get source address from Channel.\n+                if (srcAddr == null) {\n+                    srcAddr = (InetSocketAddress) ctx.channel().localAddress();\n+                }\n+\n+                logger.debug(\"Writing UDP Data of {} Bytes, Src Addr {}, Dst Addr {}\",\n+                        datagramPacket.content().readableBytes(), srcAddr, dstAddr);\n+\n+                UDPPacket.writePacket(udpBuf, datagramPacket.content(), srcAddr.getPort(), dstAddr.getPort());\n+                completeUDPWrite(srcAddr, dstAddr, udpBuf, ctx.alloc(), ctx);\n+            } else if (msg instanceof ByteBuf && ((DatagramChannel) ctx.channel()).isConnected()) {\n+\n+                // If bytes are 0 and `captureZeroByte` is false, we won't capture this.\n+                if (((ByteBuf) msg).readableBytes() == 0 && !captureZeroByte) {\n+                    logger.debug(\"Discarding Zero Byte UDP Packet\");\n+                    return;\n+                }\n+\n+                ByteBuf byteBuf = ((ByteBuf) msg).duplicate();\n+\n+                logger.debug(\"Writing UDP Data of {} Bytes, Src Addr {}, Dst Addr {}\",\n+                        byteBuf.readableBytes(), srcAddr, dstAddr);\n+\n+                UDPPacket.writePacket(udpBuf, byteBuf, srcAddr.getPort(), dstAddr.getPort());\n+                completeUDPWrite(srcAddr, dstAddr, udpBuf, ctx.alloc(), ctx);\n+            } else {\n+                logger.debug(\"Discarding Pcap Write for UDP Object: {}\", msg);\n+            }\n+        } finally {\n+            udpBuf.release();\n+        }\n+    }\n+\n+    /**\n+     * Write UDP/IP L3 and L2 here.\n+     *\n+     * @param srcAddr          {@link InetSocketAddress} Source Address of this Packet\n+     * @param dstAddr          {@link InetSocketAddress} Destination Address of this Packet\n+     * @param udpBuf           {@link ByteBuf} containing UDP L4 Data\n+     * @param byteBufAllocator {@link ByteBufAllocator} for allocating bytes for UDP/IP L3 and L2 data.\n+     * @param ctx              {@link ChannelHandlerContext} for {@code fireExceptionCaught}\n+     */\n+    private void completeUDPWrite(InetSocketAddress srcAddr, InetSocketAddress dstAddr, ByteBuf udpBuf,\n+                                  ByteBufAllocator byteBufAllocator, ChannelHandlerContext ctx) {\n+\n+        ByteBuf ipBuf = byteBufAllocator.buffer();\n+        ByteBuf ethernetBuf = byteBufAllocator.buffer();\n+        ByteBuf pcap = byteBufAllocator.buffer();\n+\n+        try {\n+            if (srcAddr.getAddress() instanceof Inet4Address && dstAddr.getAddress() instanceof Inet4Address) {\n+                IPPacket.writeUDPv4(ipBuf, udpBuf,\n+                        NetUtil.ipv4AddressToInt((Inet4Address) srcAddr.getAddress()),\n+                        NetUtil.ipv4AddressToInt((Inet4Address) dstAddr.getAddress()));\n+\n+                EthernetPacket.writeIPv4(ethernetBuf, ipBuf);\n+            } else if (srcAddr.getAddress() instanceof Inet6Address && dstAddr.getAddress() instanceof Inet6Address) {\n+                IPPacket.writeUDPv6(ipBuf, udpBuf,\n+                        srcAddr.getAddress().getAddress(),\n+                        dstAddr.getAddress().getAddress());\n+\n+                EthernetPacket.writeIPv6(ethernetBuf, ipBuf);\n+            } else {\n+                logger.error(\"Source and Destination IP Address versions are not same. Source Address: {}, \" +\n+                        \"Destination Address: {}\", srcAddr.getAddress(), dstAddr.getAddress());\n+                return;\n+            }\n+\n+            // Write Packet into Pcap\n+            pCapWriter.writePacket(pcap, ethernetBuf);\n+        } catch (IOException ex) {\n+            logger.error(\"Caught Exception While Writing Packet into Pcap\", ex);\n+            ctx.fireExceptionCaught(ex);\n+        } finally {\n+            ipBuf.release();\n+            ethernetBuf.release();\n+            pcap.release();\n+        }\n+    }\n+\n+    @Override\n+    public void handlerRemoved(ChannelHandlerContext ctx) throws Exception {\n+\n+        // If `isTCP` is true, then we'll simulate a `FIN` flow.\n+        if (ctx.channel() instanceof SocketChannel) {\n+            logger.debug(\"Starting Fake TCP FIN+ACK Flow to close connection\");\n+\n+            ByteBufAllocator byteBufAllocator = ctx.alloc();\n+            ByteBuf tcpBuf = byteBufAllocator.buffer();\n+\n+            try {\n+                // Write FIN+ACK with Normal Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                        dstAddr.getPort(), TCPPacket.TCPFlag.FIN, TCPPacket.TCPFlag.ACK);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, byteBufAllocator, ctx);\n+\n+                // Write FIN+ACK with Reversed Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, receiveSegmentNumber, sendSegmentNumber, dstAddr.getPort(),\n+                        srcAddr.getPort(), TCPPacket.TCPFlag.FIN, TCPPacket.TCPFlag.ACK);\n+                completeTCPWrite(dstAddr, srcAddr, tcpBuf, byteBufAllocator, ctx);\n+\n+                // Write ACK with Normal Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, sendSegmentNumber + 1, receiveSegmentNumber + 1,\n+                        srcAddr.getPort(), dstAddr.getPort(), TCPPacket.TCPFlag.ACK);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, byteBufAllocator, ctx);\n+            } finally {\n+                tcpBuf.release();\n+            }\n+\n+            logger.debug(\"Finished Fake TCP FIN+ACK Flow to close connection\");\n+        }\n+\n+        this.pCapWriter.close();\n+        super.handlerRemoved(ctx);\n+    }\n+\n+    @Override\n+    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) throws Exception {\n+\n+        if (ctx.channel() instanceof SocketChannel) {\n+            ByteBuf tcpBuf = ctx.alloc().buffer();\n+\n+            try {\n+                // Write RST with Normal Source and Destination Address\n+                TCPPacket.writePacket(tcpBuf, null, sendSegmentNumber, receiveSegmentNumber, srcAddr.getPort(),\n+                        dstAddr.getPort(), TCPPacket.TCPFlag.RST, TCPPacket.TCPFlag.ACK);\n+                completeTCPWrite(srcAddr, dstAddr, tcpBuf, ctx.alloc(), ctx);\n+            } finally {\n+                tcpBuf.release();\n+            }\n+\n+            logger.debug(\"Sent Fake TCP RST to close connection\");\n+        }\n+\n+        this.pCapWriter.close();", "originalCommit": "4a313affb01402aa5cffa51c22e9ed62c9c44ea1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjExNzc5NA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r486117794", "bodyText": "Is it possible null varargs ?", "author": "amizurov", "createdAt": "2020-09-10T07:17:44Z", "path": "handler/src/main/java/io/netty/handler/pcap/TCPPacket.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class TCPPacket {\n+\n+    /**\n+     * Data Offset + Reserved Bits.\n+     */\n+    private static final short OFFSET = 0x5000;\n+\n+    private TCPPacket() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Write TCP Packet\n+     *\n+     * @param byteBuf ByteBuf where Packet data will be set\n+     * @param payload Payload of this Packet\n+     * @param srcPort Source Port\n+     * @param dstPort Destination Port\n+     */\n+    static void writePacket(ByteBuf byteBuf, ByteBuf payload, int segmentNumber, int ackNumber, int srcPort,\n+                            int dstPort, TCPFlag... tcpFlags) {\n+\n+        byteBuf.writeShort(srcPort);     // Source Port\n+        byteBuf.writeShort(dstPort);     // Destination Port\n+        byteBuf.writeInt(segmentNumber); // Segment Number\n+        byteBuf.writeInt(ackNumber);     // Acknowledgment Number\n+        byteBuf.writeShort(OFFSET | TCPFlag.getFlag(tcpFlags)); // Flags\n+        byteBuf.writeShort(65535);       // Window Size\n+        byteBuf.writeShort(0x0001);      // Checksum\n+        byteBuf.writeShort(0);           // Urgent Pointer\n+\n+        if (payload != null) {\n+            byteBuf.writeBytes(payload); //  Payload of Data\n+        }\n+    }\n+\n+    enum TCPFlag {\n+        FIN(1),\n+        SYN(1 << 1),\n+        RST(1 << 2),\n+        PSH(1 << 3),\n+        ACK(1 << 4),\n+        URG(1 << 5),\n+        ECE(1 << 6),\n+        CWR(1 << 7);\n+\n+        private final int value;\n+\n+        TCPFlag(int value) {\n+            this.value = value;\n+        }\n+\n+        static int getFlag(TCPFlag... tcpFlags) {", "originalCommit": "4a313affb01402aa5cffa51c22e9ed62c9c44ea1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjEzNDUzOA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r486134538", "bodyText": "Nope, it's completely under our control.", "author": "hyperxpro", "createdAt": "2020-09-10T07:47:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjExNzc5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjEzNDcyMQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r486134721", "bodyText": "We won't pass null.", "author": "hyperxpro", "createdAt": "2020-09-10T07:47:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjExNzc5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjExOTY5MA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r486119690", "bodyText": "Payload here can be only in range 0... 65527  (short - 8),  is it right ?", "author": "amizurov", "createdAt": "2020-09-10T07:21:16Z", "path": "handler/src/main/java/io/netty/handler/pcap/UDPPacket.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+\n+final class UDPPacket {\n+\n+    private static final short UDP_HEADER_SIZE = 8;\n+\n+    private UDPPacket() {\n+        // Prevent outside initialization\n+    }\n+\n+    /**\n+     * Write UDP Packet\n+     *\n+     * @param byteBuf ByteBuf where Packet data will be set\n+     * @param payload Payload of this Packet\n+     * @param srcPort Source Port\n+     * @param dstPort Destination Port\n+     */\n+    static void writePacket(ByteBuf byteBuf, ByteBuf payload, int srcPort, int dstPort) {\n+        byteBuf.writeShort(srcPort); // Source Port\n+        byteBuf.writeShort(dstPort); // Destination Port\n+        byteBuf.writeShort(UDP_HEADER_SIZE + payload.readableBytes()); // UDP Header Length + Payload Length", "originalCommit": "4a313affb01402aa5cffa51c22e9ed62c9c44ea1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE0NjAwNg==", "url": "https://github.com/netty/netty/pull/10498#discussion_r486146006", "bodyText": "The Packet Length includes UDP Header Size of 8 bytes and data payload of n bytes,", "author": "hyperxpro", "createdAt": "2020-09-10T08:07:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjExOTY5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjEyNTAwMw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r486125003", "bodyText": "Maybe instance of udpPacket.readShort() & 0xffff  we can use buf.readUnsignedShort() ?", "author": "amizurov", "createdAt": "2020-09-10T07:31:01Z", "path": "handler/src/test/java/io/netty/handler/pcap/PcapWriteHandlerTest.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufOutputStream;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.channel.socket.nio.NioDatagramChannel;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+import org.junit.Test;\n+\n+import java.net.Inet4Address;\n+import java.net.InetSocketAddress;\n+\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+public class PcapWriteHandlerTest {\n+\n+    @Test\n+    public void udpV4() throws InterruptedException {\n+\n+        ByteBuf byteBuf = Unpooled.buffer();\n+\n+        InetSocketAddress srvAddr = new InetSocketAddress(\"127.0.0.1\", 62001);\n+        InetSocketAddress cltAddr = new InetSocketAddress(\"127.0.0.1\", 62002);\n+\n+        NioEventLoopGroup eventLoopGroup = new NioEventLoopGroup(2);\n+\n+        // We'll bootstrap a UDP Server to avoid \"Network Unreachable errors\" when sending UDP Packet.\n+        Bootstrap server = new Bootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioDatagramChannel.class)\n+                .handler(new SimpleChannelInboundHandler<DatagramPacket>() {\n+                    @Override\n+                    protected void channelRead0(ChannelHandlerContext ctx, DatagramPacket msg) {\n+                        // Discard\n+                    }\n+                });\n+\n+        ChannelFuture channelFutureServer = server.bind(srvAddr).sync();\n+        assertTrue(channelFutureServer.isSuccess());\n+\n+        // We'll bootstrap a UDP Client for sending UDP Packets to UDP Server.\n+        Bootstrap client = new Bootstrap()\n+                .group(eventLoopGroup)\n+                .channel(NioDatagramChannel.class)\n+                .handler(new PcapWriteHandler(new ByteBufOutputStream(byteBuf)));\n+\n+        ChannelFuture channelFutureClient = client.connect(srvAddr, cltAddr).sync();\n+        assertTrue(channelFutureClient.isSuccess());\n+        assertTrue(channelFutureClient.channel().writeAndFlush(Unpooled.wrappedBuffer(\"Meow\".getBytes()))\n+                .sync().isSuccess());\n+        assertTrue(eventLoopGroup.shutdownGracefully().sync().isSuccess());\n+\n+        // Verify Pcap Global Headers\n+        assertEquals(0xa1b2c3d4, byteBuf.readInt()); // magic_number\n+        assertEquals(2, byteBuf.readShort());        // version_major\n+        assertEquals(4, byteBuf.readShort());        // version_minor\n+        assertEquals(0, byteBuf.readInt());          // thiszone\n+        assertEquals(0, byteBuf.readInt());          // sigfigs\n+        assertEquals(0xffff, byteBuf.readInt());     // snaplen\n+        assertEquals(1, byteBuf.readInt());          // network\n+\n+        // Verify Pcap Packet Header\n+        byteBuf.readInt(); // Just read, we don't care about timestamps for now\n+        byteBuf.readInt(); // Just read, we don't care about timestamps for now\n+        assertEquals(46, byteBuf.readInt()); // Length of Packet Saved In Pcap\n+        assertEquals(46, byteBuf.readInt()); // Actual Length of Packet\n+\n+        // -------------------------------------------- Verify Packet --------------------------------------------\n+        // Verify Ethernet Packet\n+        ByteBuf ethernetPacket = byteBuf.readBytes(46);\n+        ByteBuf dstMac = ethernetPacket.readBytes(6);\n+        ByteBuf srcMac = ethernetPacket.readBytes(6);\n+        assertArrayEquals(new byte[]{0, 0, 94, 0, 83, -1}, ByteBufUtil.getBytes(dstMac));\n+        assertArrayEquals(new byte[]{0, 0, 94, 0, 83, 0}, ByteBufUtil.getBytes(srcMac));\n+        assertEquals(0x0800, ethernetPacket.readShort());\n+\n+        // Verify IPv4 Packet\n+        ByteBuf ipv4Packet = ethernetPacket.readBytes(32);\n+        assertEquals(0x45, ipv4Packet.readByte());    // Version + IHL\n+        assertEquals(0x00, ipv4Packet.readByte());    // DSCP\n+        assertEquals(32, ipv4Packet.readShort());     // Length\n+        assertEquals(0x0000, ipv4Packet.readShort()); // Identification\n+        assertEquals(0x0000, ipv4Packet.readShort()); // Fragment\n+        assertEquals((byte) 0xff, ipv4Packet.readByte());      // TTL\n+        assertEquals((byte) 17, ipv4Packet.readByte());        // Protocol\n+        assertEquals(0, ipv4Packet.readShort());      // Checksum\n+        // Source IPv4 Address\n+        assertEquals(NetUtil.ipv4AddressToInt((Inet4Address) srvAddr.getAddress()), ipv4Packet.readInt());\n+        // Destination IPv4 Address\n+        assertEquals(NetUtil.ipv4AddressToInt((Inet4Address) cltAddr.getAddress()), ipv4Packet.readInt());\n+\n+        // Verify UDP Packet\n+        ByteBuf udpPacket = ipv4Packet.readBytes(12);\n+        assertEquals(cltAddr.getPort() & 0xffff, udpPacket.readShort() & 0xffff); // Source Port", "originalCommit": "4a313affb01402aa5cffa51c22e9ed62c9c44ea1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE0ODM1OQ==", "url": "https://github.com/netty/netty/pull/10498#discussion_r486148359", "bodyText": "Yeah, Fixed.", "author": "hyperxpro", "createdAt": "2020-09-10T08:10:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjEyNTAwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjEyODc3Mw==", "url": "https://github.com/netty/netty/pull/10498#discussion_r486128773", "bodyText": "Is it make sense to send ctx.fireExceptionCaught(ex) after we close channel ? I think it reach only TailContext", "author": "amizurov", "createdAt": "2020-09-10T07:37:39Z", "path": "handler/src/main/java/io/netty/handler/pcap/PcapWriteHandler.java", "diffHunk": "@@ -0,0 +1,523 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.pcap;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufAllocator;\n+import io.netty.channel.ChannelDuplexHandler;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.channel.ServerChannel;\n+import io.netty.channel.socket.DatagramChannel;\n+import io.netty.channel.socket.DatagramPacket;\n+import io.netty.channel.socket.ServerSocketChannel;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.util.NetUtil;\n+import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.logging.InternalLogger;\n+import io.netty.util.internal.logging.InternalLoggerFactory;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.net.Inet4Address;\n+import java.net.Inet6Address;\n+import java.net.InetSocketAddress;\n+\n+/**\n+ * <p> {@link PcapWriteHandler} captures {@link ByteBuf} from {@link SocketChannel} / {@link ServerChannel}\n+ * or {@link DatagramPacket} and writes it into Pcap {@link OutputStream}. </p>\n+ *\n+ * <p>\n+ * Things to keep in mind when using {@link PcapWriteHandler} with TCP:\n+ *\n+ *    <ul>\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#channelActive(ChannelHandlerContext)} is called,\n+ *        a fake TCP 3-way handshake (SYN, SYN+ACK, ACK) is simulated as new connection in Pcap. </li>\n+ *\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#handlerRemoved(ChannelHandlerContext)} is called,\n+ *        a fake TCP 3-way handshake (FIN+ACK, FIN+ACK, ACK) is simulated as connection shutdown in Pcap.  </li>\n+ *\n+ *        <li> Whenever {@link ChannelInboundHandlerAdapter#exceptionCaught(ChannelHandlerContext, Throwable)}\n+ *        is called, a fake TCP RST is sent to simulate connection Reset in Pcap. </li>\n+ *\n+ *        <li> ACK is sent each time data is send / received. </li>\n+ *\n+ *        <li> Zero Length Data Packets can cause TCP Double ACK error in Wireshark. To tackle this,\n+ *        set {@code captureZeroByte} to {@code false}. </li>\n+ *    </ul>\n+ * </p>\n+ */\n+public final class PcapWriteHandler extends ChannelDuplexHandler {\n+\n+    private final InternalLogger logger = InternalLoggerFactory.getInstance(PcapWriteHandler.class);\n+\n+    /**\n+     * {@link PcapWriter} Instance\n+     */\n+    private PcapWriter pCapWriter;\n+\n+    /**\n+     * {@link OutputStream} where we'll write Pcap data.\n+     */\n+    private final OutputStream outputStream;\n+\n+    /**\n+     * {@code true} if we want to capture packets with zero bytes else {@code false}.\n+     */\n+    private final boolean captureZeroByte;\n+\n+    /**\n+     * {@code true} if we want to write Pcap Global Header on initialization of\n+     * {@link PcapWriter} else {@code false}.\n+     */\n+    private final boolean writePcapGlobalHeader;\n+\n+    /**\n+     * TCP Sender Segment Number.\n+     * It'll start with 1 and keep incrementing with number of bytes read/sent.\n+     */\n+    private int sendSegmentNumber = 1;\n+\n+    /**\n+     * TCP Receiver Segment Number.\n+     * It'll start with 1 and keep incrementing with number of bytes read/sent.\n+     */\n+    private int receiveSegmentNumber = 1;\n+\n+    /**\n+     * Source Address\n+     */\n+    private InetSocketAddress srcAddr;\n+\n+    /**\n+     * Destination Address\n+     */\n+    private InetSocketAddress dstAddr;\n+\n+    /**\n+     * Create new {@link PcapWriteHandler} Instance.\n+     * {@code captureZeroByte} is set to {@code false} and\n+     * {@code writePcapGlobalHeader} is set to {@code true}.\n+     *\n+     * @param outputStream OutputStream where Pcap data will be written\n+     * @throws NullPointerException If {@link OutputStream} is {@code null} then we'll throw an\n+     *                              {@link NullPointerException}\n+     */\n+    public PcapWriteHandler(OutputStream outputStream) {\n+        this(outputStream, false, true);\n+    }\n+\n+    /**\n+     * Create new {@link PcapWriteHandler} Instance\n+     *\n+     * @param outputStream          OutputStream where Pcap data will be written\n+     * @param captureZeroByte       Set to {@code true} to enable capturing packets with empty (0 bytes) payload.\n+     *                              Otherwise, if set to {@code false}, empty packets will be filtered out.\n+     * @param writePcapGlobalHeader Set to {@code true} to write Pcap Global Header on initialization.\n+     *                              Otherwise, if set to {@code false}, Pcap Global Header will not be written\n+     *                              on initialization. This could when writing Pcap data on a existing file where\n+     *                              Pcap Global Header is already present.\n+     * @throws NullPointerException If {@link OutputStream} is {@code null} then we'll throw an\n+     *                              {@link NullPointerException}\n+     */\n+    public PcapWriteHandler(OutputStream outputStream, boolean captureZeroByte, boolean writePcapGlobalHeader) {\n+        this.outputStream = ObjectUtil.checkNotNull(outputStream, \"OutputStream\");\n+        this.captureZeroByte = captureZeroByte;\n+        this.writePcapGlobalHeader = writePcapGlobalHeader;\n+    }\n+\n+    @Override\n+    public void channelActive(ChannelHandlerContext ctx) throws Exception {\n+\n+        ByteBufAllocator byteBufAllocator = ctx.alloc();\n+\n+        /*\n+         * If `writePcapGlobalHeader` is `true`, we'll write Pcap Global Header.\n+         */\n+        if (writePcapGlobalHeader) {\n+\n+            ByteBuf byteBuf = byteBufAllocator.buffer();\n+            try {\n+                this.pCapWriter = new PcapWriter(this.outputStream, byteBuf);\n+            } catch (IOException ex) {\n+                ctx.channel().close();\n+                ctx.fireExceptionCaught(ex);", "originalCommit": "4a313affb01402aa5cffa51c22e9ed62c9c44ea1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE0OTM5NA==", "url": "https://github.com/netty/netty/pull/10498#discussion_r486149394", "bodyText": "We need to call ctx.fireExceptionCaught(ex) because an IOException is caught due to OutputStream. So we'll close the channel since OutputStream has errors and writing packets won't work.", "author": "hyperxpro", "createdAt": "2020-09-10T08:12:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjEyODc3Mw=="}], "type": "inlineReview"}, {"oid": "1eab6f3002e9113c92a4e9bb948fe692016cc5d6", "url": "https://github.com/netty/netty/commit/1eab6f3002e9113c92a4e9bb948fe692016cc5d6", "message": "use Bytebuf#readUnsignedShort", "committedDate": "2020-09-10T08:12:41Z", "type": "commit"}]}