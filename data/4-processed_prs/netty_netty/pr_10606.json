{"pr_number": 10606, "pr_title": "Implement batching of reading and writing when using datagram with io\u2026", "pr_createdAt": "2020-09-24T12:58:16Z", "pr_url": "https://github.com/netty/netty/pull/10606", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk1NTcyNg==", "url": "https://github.com/netty/netty/pull/10606#discussion_r494955726", "bodyText": "Or scheduleWrite* since this is writeComplete0?", "author": "chrisvest", "createdAt": "2020-09-25T12:33:03Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringDatagramChannel.java", "diffHunk": "@@ -451,43 +474,109 @@ protected void readComplete0(int res) {\n         }\n \n         @Override\n-        protected void scheduleRead0() {\n+        protected int scheduleRead0() {\n             final IOUringRecvByteAllocatorHandle allocHandle = recvBufAllocHandle();\n             ByteBuf byteBuf = allocHandle.allocate(alloc());\n-            IOUringSubmissionQueue submissionQueue = submissionQueue();\n-\n             assert readBuffer == null;\n             readBuffer = byteBuf;\n \n-            recvMsg = !isConnected();\n-            long bufferAddress = byteBuf.memoryAddress();\n-            allocHandle.attemptedBytesRead(byteBuf.writableBytes());\n+            int writable = byteBuf.writableBytes();\n+            allocHandle.attemptedBytesRead(writable);\n+            int datagramSize = config().getMaxDatagramPayloadSize();\n \n-            if (!recvMsg) {\n-                submissionQueue.addRead(socket.intValue(), bufferAddress,\n+            int numDatagram = datagramSize == 0 ? 1 : Math.max(1, byteBuf.writableBytes() / datagramSize);\n+\n+            if (isConnected() && numDatagram <= 1) {\n+                submissionQueue().addRead(socket.intValue(), byteBuf.memoryAddress(),\n                         byteBuf.writerIndex(), byteBuf.capacity());\n+                return 1;\n             } else {\n-                int addrLen = addrLen();\n-                long recvmsgBufferAddr = recvmsgBufferAddr();\n-                long sockaddrAddress = recvmsgBufferAddr + Native.SIZEOF_MSGHDR;\n-                long iovecAddress = sockaddrAddress + addrLen;\n-\n-                Iov.write(iovecAddress, bufferAddress + byteBuf.writerIndex(), byteBuf.writableBytes());\n-                MsgHdr.write(recvmsgBufferAddr, sockaddrAddress, addrLen, iovecAddress, 1);\n-                submissionQueue.addRecvmsg(socket.intValue(), recvmsgBufferAddr);\n+                int scheduled = scheduleRcvmsg(byteBuf, numDatagram, datagramSize);\n+                if (scheduled == 0) {\n+                    // We could not schedule any recvmmsg so we need to release the buffer as there will be no\n+                    // completion event.\n+                    readBuffer = null;\n+                    byteBuf.release();\n+                }\n+                return scheduled;\n             }\n         }\n \n-        private int addrLen() {\n-            return socket.isIpv6() ? Native.SIZEOF_SOCKADDR_IN6 :\n-                    Native.SIZEOF_SOCKADDR_IN;\n+        private int scheduleRcvmsg(ByteBuf byteBuf, int numDatagram, int datagramSize) {\n+            int writable = byteBuf.writableBytes();\n+            IOUringSubmissionQueue submissionQueue = submissionQueue();\n+            long bufferAddress = byteBuf.memoryAddress() + byteBuf.writerIndex();\n+            if (numDatagram <= 1) {\n+                MsgHdrMemory msgHdrMemory = recvmsgHdrs.nextHdr();\n+                if (msgHdrMemory == null) {\n+                    // We can not continue reading before we did not submit the recvmsg(s) and received the results.\n+                    return 0;\n+                }\n+                msgHdrMemory.write(socket, null, bufferAddress, writable);\n+                // We always use idx + 1 here so we can detect if no idx was used by checking if data == 0 in\n+                // readComplete0(...)\n+                submissionQueue.addRecvmsg(socket.intValue(), msgHdrMemory.address(), msgHdrMemory.idx() + 1);\n+                return 1;\n+            } else {\n+                int i = 0;\n+                // Add multiple IORING_OP_RECVMSG to the submission queue. This basically emulates recvmmsg(...)\n+                for (; i < numDatagram && writable >= datagramSize; i++) {\n+                    MsgHdrMemory msgHdrMemory = recvmsgHdrs.nextHdr();\n+                    if (msgHdrMemory == null) {\n+                        // We can not continue reading before we did not submit the recvmsg(s) and received the results.\n+                        break;\n+                    }\n+                    msgHdrMemory.write(socket, null, bufferAddress, datagramSize);\n+                    // We always use idx + 1 here so we can detect if no idx was used by checking if data == 0 in\n+                    // readComplete0(...)\n+                    submissionQueue.addRecvmsg(socket.intValue(), msgHdrMemory.address(), msgHdrMemory.idx() + 1);\n+                    bufferAddress += datagramSize;\n+                    writable -= datagramSize;\n+                }\n+                return i;\n+            }\n         }\n \n         @Override\n-        protected void removeFromOutboundBuffer(ChannelOutboundBuffer outboundBuffer, int bytes) {\n-            // When using Datagram we should consider the message written as long as there were any bytes written.\n-            boolean removed = outboundBuffer.remove();\n-            assert removed;\n+        boolean writeComplete0(int res, int data, int outstanding) {\n+            ChannelOutboundBuffer outboundBuffer = outboundBuffer();\n+            // We need to use idx -1 here to match up the logic in scheduleRead0()", "originalCommit": "d59f30b6b566d770dd1abe6777c3dad32b78da4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk1Nzg3MQ==", "url": "https://github.com/netty/netty/pull/10606#discussion_r494957871", "bodyText": "Integer division floors. Won't this miss out on a tail message if writableBytes is, say, 1.5 times datagramSize?", "author": "chrisvest", "createdAt": "2020-09-25T12:37:19Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringDatagramChannel.java", "diffHunk": "@@ -451,43 +474,109 @@ protected void readComplete0(int res) {\n         }\n \n         @Override\n-        protected void scheduleRead0() {\n+        protected int scheduleRead0() {\n             final IOUringRecvByteAllocatorHandle allocHandle = recvBufAllocHandle();\n             ByteBuf byteBuf = allocHandle.allocate(alloc());\n-            IOUringSubmissionQueue submissionQueue = submissionQueue();\n-\n             assert readBuffer == null;\n             readBuffer = byteBuf;\n \n-            recvMsg = !isConnected();\n-            long bufferAddress = byteBuf.memoryAddress();\n-            allocHandle.attemptedBytesRead(byteBuf.writableBytes());\n+            int writable = byteBuf.writableBytes();\n+            allocHandle.attemptedBytesRead(writable);\n+            int datagramSize = config().getMaxDatagramPayloadSize();\n \n-            if (!recvMsg) {\n-                submissionQueue.addRead(socket.intValue(), bufferAddress,\n+            int numDatagram = datagramSize == 0 ? 1 : Math.max(1, byteBuf.writableBytes() / datagramSize);", "originalCommit": "d59f30b6b566d770dd1abe6777c3dad32b78da4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU3OTM1Ng==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495579356", "bodyText": "thats by \"design\" as I want to ensure the message is datagramSize... Otherwise we may receive truncated messages which may not be expected by the user.", "author": "normanmaurer", "createdAt": "2020-09-27T14:35:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk1Nzg3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk2NjI4Mg==", "url": "https://github.com/netty/netty/pull/10606#discussion_r494966282", "bodyText": "\u2026 because IOUringSubmissionQueue.addRead is currently hard-coded to use 0 for data. Not a super obvious connection. Can we encode this explicitly, rather than relying on correctly placed + 1 and - 1?", "author": "chrisvest", "createdAt": "2020-09-25T12:52:45Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringDatagramChannel.java", "diffHunk": "@@ -326,75 +323,80 @@ protected void doClose() throws Exception {\n     }\n \n     final class IOUringDatagramChannelUnsafe extends AbstractUringUnsafe {\n-        private ByteBuf readBuffer;\n-        private boolean recvMsg;\n-\n         // These buffers are used for msghdr, iov, sockaddr_in / sockaddr_in6 when doing recvmsg / sendmsg\n         //\n         // TODO: Alternative we could also allocate these everytime from the ByteBufAllocator or we could use\n         //       some sort of other pool. Let's keep it simple for now.\n-        private ByteBuffer recvmsgBuffer;\n-        private long recvmsgBufferAddr = -1;\n-        private ByteBuffer sendmsgBuffer;\n-        private long sendmsgBufferAddr = -1;\n-\n-        private long sendmsgBufferAddr() {\n-            long address = this.sendmsgBufferAddr;\n-            if (address == -1) {\n-                assert sendmsgBuffer == null;\n-                int length = Native.SIZEOF_MSGHDR + Native.SIZEOF_SOCKADDR_STORAGE + Native.SIZEOF_IOVEC;\n-                sendmsgBuffer = Buffer.allocateDirectWithNativeOrder(length);\n-                sendmsgBufferAddr = address = Buffer.memoryAddress(sendmsgBuffer);\n-\n-                // memset once\n-                PlatformDependent.setMemory(address, length, (byte) 0);\n-            }\n-            return address;\n-        }\n+        //\n+        // Consider exposing some configuration for that.\n+        private final MsgHdrMemoryArray recvmsgHdrs = new MsgHdrMemoryArray(256);\n+        private final MsgHdrMemoryArray sendmsgHdrs = new MsgHdrMemoryArray(256);\n+        private final int[] sendmsgResArray = new int[sendmsgHdrs.capacity()];\n+        private final WriteProcessor writeProcessor = new WriteProcessor();\n \n-        private long recvmsgBufferAddr() {\n-            long address = this.recvmsgBufferAddr;\n-            if (address == -1) {\n-                assert recvmsgBuffer == null;\n-                int length = Native.SIZEOF_MSGHDR + Native.SIZEOF_SOCKADDR_STORAGE + Native.SIZEOF_IOVEC;\n-                recvmsgBuffer = Buffer.allocateDirectWithNativeOrder(length);\n-                recvmsgBufferAddr = address = Buffer.memoryAddress(recvmsgBuffer);\n+        private ByteBuf readBuffer;\n \n-                // memset once\n-                PlatformDependent.setMemory(address, length, (byte) 0);\n-            }\n-            return address;\n-        }\n+        private final class WriteProcessor implements ChannelOutboundBuffer.MessageProcessor {\n+            private int written;\n \n-        void releaseBuffers() {\n-            if (sendmsgBuffer != null) {\n-                Buffer.free(sendmsgBuffer);\n-                sendmsgBuffer = null;\n-                sendmsgBufferAddr = -1;\n+            @Override\n+            public boolean processMessage(Object msg) {\n+                if (scheduleWrite(msg, true)) {\n+                    written++;\n+                    return true;\n+                }\n+                return false;\n             }\n \n-            if (recvmsgBuffer != null) {\n-                Buffer.free(recvmsgBuffer);\n-                recvmsgBuffer = null;\n-                recvmsgBufferAddr = -1;\n+            int write(ChannelOutboundBuffer in) {\n+                written = 0;\n+                try {\n+                    in.forEachFlushedMessage(this);\n+                } catch (Exception e) {\n+                    // This should never happen as our processMessage(...) never throws.\n+                    throw new IllegalStateException(e);\n+                }\n+                return written;\n             }\n         }\n \n+        void releaseBuffers() {\n+            sendmsgHdrs.release();\n+            recvmsgHdrs.release();\n+        }\n+\n         @Override\n-        protected void readComplete0(int res) {\n+        protected void readComplete0(int res, int data, int outstanding) {\n             final IOUringRecvByteAllocatorHandle allocHandle = recvBufAllocHandle();\n             final ChannelPipeline pipeline = pipeline();\n             ByteBuf byteBuf = this.readBuffer;\n-            this.readBuffer = null;\n             assert byteBuf != null;\n-            boolean recvmsg = this.recvMsg;\n-            this.recvMsg = false;\n+            // We need to use idx - 1 here to match up the logic in scheduleRead0()\n+            int idx = data - 1;\n+            try {\n+                if (idx == -1) {\n+                    assert outstanding == 0;\n+                    // idx == -1 means that we did a read(...) and not a recvmmsg(...)", "originalCommit": "d59f30b6b566d770dd1abe6777c3dad32b78da4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU3MzE4MA==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495573180", "bodyText": "+1 :)", "author": "njhill", "createdAt": "2020-09-27T13:29:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk2NjI4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk3MTg1MA==", "url": "https://github.com/netty/netty/pull/10606#discussion_r494971850", "bodyText": "Our finally-clause only releases the buffer if ioResult throws? Maybe this can be structured better?", "author": "chrisvest", "createdAt": "2020-09-25T13:02:53Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringDatagramChannel.java", "diffHunk": "@@ -438,11 +426,46 @@ protected void readComplete0(int res) {\n                     allocHandle.readComplete();\n                     pipeline.fireChannelReadComplete();\n                 }\n-            } catch (Throwable t) {\n-                if (connected && t instanceof NativeIoException) {\n-                    t = translateForConnected((NativeIoException) t);\n+            } finally {\n+                if (byteBuf != null) {\n+                    byteBuf.release();\n+                }\n+            }\n+        }\n+\n+        private void recvmsgComplete(ChannelPipeline pipeline, IOUringRecvByteAllocatorHandle allocHandle,\n+                                      ByteBuf byteBuf, int res, int idx, int outstanding) throws IOException {\n+            try {\n+                MsgHdrMemory hdr = recvmsgHdrs.hdr(idx);\n+\n+                if (res < 0) {\n+                    // If res is negative we should pass it to ioResult(...) which will either throw\n+                    // or convert it to 0 if we could not read because the socket was not readable.\n+                    allocHandle.lastBytesRead(ioResult(\"io_uring recvmsg\", res));\n+                } else if (res > 0) {\n+                    allocHandle.lastBytesRead(res);\n+                    allocHandle.incMessagesRead(1);\n+                    DatagramPacket packet = hdr.read(IOUringDatagramChannel.this, byteBuf, res);\n+                    pipeline.fireChannelRead(packet);\n+                } else {\n+                    allocHandle.lastBytesRead(0);\n+                }\n+                byteBuf = null;", "originalCommit": "d59f30b6b566d770dd1abe6777c3dad32b78da4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTUxMzM4OA==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495513388", "bodyText": "I think at minimum this should be moved inside the else if block?", "author": "njhill", "createdAt": "2020-09-27T01:23:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk3MTg1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU4MDk2NA==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495580964", "bodyText": "I think @njhill is right here...", "author": "normanmaurer", "createdAt": "2020-09-27T14:52:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDk3MTg1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQwOTAyNw==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495409027", "bodyText": "Any particular reason for having this in a separate method?", "author": "njhill", "createdAt": "2020-09-26T03:32:10Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -578,32 +595,39 @@ final void pollOut(int res) {\n         /**\n          * Called once a write was completed.\n          */\n-        final void writeComplete(int res) {\n-            ChannelOutboundBuffer channelOutboundBuffer = unsafe().outboundBuffer();\n-            if (res >= 0) {\n-                removeFromOutboundBuffer(channelOutboundBuffer, res);\n-                // We only reset this once we are done with calling removeBytes(...) as otherwise we may trigger a write\n-                // while still removing messages internally in removeBytes(...) which then may corrupt state.\n-                ioState &= ~WRITE_SCHEDULED;\n-                doWrite(channelOutboundBuffer);\n-            } else {\n+        final void writeComplete(int res, int data) {\n+            assert numOutstandingWrites > 0;\n+            --numOutstandingWrites;\n+\n+            boolean writtenAll = writeComplete0(res, data, numOutstandingWrites);\n+            if (!writtenAll && (ioState & POLL_OUT_SCHEDULED) == 0) {\n+                // We were not able to write everything, let's register for POLLOUT\n+                schedulePollOut();\n+            }\n+\n+            // We only reset this once we are done with calling removeBytes(...) as otherwise we may trigger a write\n+            // while still removing messages internally in removeBytes(...) which then may corrupt state.\n+            if (numOutstandingWrites == 0) {\n                 ioState &= ~WRITE_SCHEDULED;\n-                try {\n-                    if (ioResult(\"io_uring write\", res) == 0) {\n-                        // We were not able to write everything, let's register for POLLOUT\n-                        schedulePollOut();\n-                    }\n-                } catch (Throwable cause) {\n-                    handleWriteError(cause);\n+\n+                // If we could write all and we did not schedule a pollout yet let us try to write again\n+                if (writtenAll && (ioState & POLL_OUT_SCHEDULED) == 0) {\n+                    doWrite(unsafe().outboundBuffer());\n                 }\n             }\n         }\n \n         /**\n-         * Called once a write completed and we should remove message(s) from the {@link ChannelOutboundBuffer}\n+         * Called once a write was completed.\n          */\n-        protected void removeFromOutboundBuffer(ChannelOutboundBuffer outboundBuffer, int bytes) {\n-            outboundBuffer.removeBytes(bytes);\n+        abstract boolean writeComplete0(int res, int data, int outstanding);\n+\n+        private int clearReadScheduledIfNeeded() {", "originalCommit": "d59f30b6b566d770dd1abe6777c3dad32b78da4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU3OTk1OQ==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495579959", "bodyText": "not anymore... I did call it from various places at some point but thats not true anymore.", "author": "normanmaurer", "createdAt": "2020-09-27T14:41:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQwOTAyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxMDk2OQ==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495410969", "bodyText": "Move above 9 lines into separate private method to dedup the logic in if/else blocks?", "author": "njhill", "createdAt": "2020-09-26T03:58:12Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringDatagramChannel.java", "diffHunk": "@@ -451,43 +474,109 @@ protected void readComplete0(int res) {\n         }\n \n         @Override\n-        protected void scheduleRead0() {\n+        protected int scheduleRead0() {\n             final IOUringRecvByteAllocatorHandle allocHandle = recvBufAllocHandle();\n             ByteBuf byteBuf = allocHandle.allocate(alloc());\n-            IOUringSubmissionQueue submissionQueue = submissionQueue();\n-\n             assert readBuffer == null;\n             readBuffer = byteBuf;\n \n-            recvMsg = !isConnected();\n-            long bufferAddress = byteBuf.memoryAddress();\n-            allocHandle.attemptedBytesRead(byteBuf.writableBytes());\n+            int writable = byteBuf.writableBytes();\n+            allocHandle.attemptedBytesRead(writable);\n+            int datagramSize = config().getMaxDatagramPayloadSize();\n \n-            if (!recvMsg) {\n-                submissionQueue.addRead(socket.intValue(), bufferAddress,\n+            int numDatagram = datagramSize == 0 ? 1 : Math.max(1, byteBuf.writableBytes() / datagramSize);\n+\n+            if (isConnected() && numDatagram <= 1) {\n+                submissionQueue().addRead(socket.intValue(), byteBuf.memoryAddress(),\n                         byteBuf.writerIndex(), byteBuf.capacity());\n+                return 1;\n             } else {\n-                int addrLen = addrLen();\n-                long recvmsgBufferAddr = recvmsgBufferAddr();\n-                long sockaddrAddress = recvmsgBufferAddr + Native.SIZEOF_MSGHDR;\n-                long iovecAddress = sockaddrAddress + addrLen;\n-\n-                Iov.write(iovecAddress, bufferAddress + byteBuf.writerIndex(), byteBuf.writableBytes());\n-                MsgHdr.write(recvmsgBufferAddr, sockaddrAddress, addrLen, iovecAddress, 1);\n-                submissionQueue.addRecvmsg(socket.intValue(), recvmsgBufferAddr);\n+                int scheduled = scheduleRcvmsg(byteBuf, numDatagram, datagramSize);\n+                if (scheduled == 0) {\n+                    // We could not schedule any recvmmsg so we need to release the buffer as there will be no\n+                    // completion event.\n+                    readBuffer = null;\n+                    byteBuf.release();\n+                }\n+                return scheduled;\n             }\n         }\n \n-        private int addrLen() {\n-            return socket.isIpv6() ? Native.SIZEOF_SOCKADDR_IN6 :\n-                    Native.SIZEOF_SOCKADDR_IN;\n+        private int scheduleRcvmsg(ByteBuf byteBuf, int numDatagram, int datagramSize) {\n+            int writable = byteBuf.writableBytes();\n+            IOUringSubmissionQueue submissionQueue = submissionQueue();\n+            long bufferAddress = byteBuf.memoryAddress() + byteBuf.writerIndex();\n+            if (numDatagram <= 1) {\n+                MsgHdrMemory msgHdrMemory = recvmsgHdrs.nextHdr();\n+                if (msgHdrMemory == null) {\n+                    // We can not continue reading before we did not submit the recvmsg(s) and received the results.\n+                    return 0;\n+                }\n+                msgHdrMemory.write(socket, null, bufferAddress, writable);\n+                // We always use idx + 1 here so we can detect if no idx was used by checking if data == 0 in\n+                // readComplete0(...)\n+                submissionQueue.addRecvmsg(socket.intValue(), msgHdrMemory.address(), msgHdrMemory.idx() + 1);", "originalCommit": "d59f30b6b566d770dd1abe6777c3dad32b78da4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxMTA2OA==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495411068", "bodyText": "nit: no need for this var, could just return directly", "author": "njhill", "createdAt": "2020-09-26T03:59:37Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringDatagramChannel.java", "diffHunk": "@@ -451,43 +474,109 @@ protected void readComplete0(int res) {\n         }\n \n         @Override\n-        protected void scheduleRead0() {\n+        protected int scheduleRead0() {\n             final IOUringRecvByteAllocatorHandle allocHandle = recvBufAllocHandle();\n             ByteBuf byteBuf = allocHandle.allocate(alloc());\n-            IOUringSubmissionQueue submissionQueue = submissionQueue();\n-\n             assert readBuffer == null;\n             readBuffer = byteBuf;\n \n-            recvMsg = !isConnected();\n-            long bufferAddress = byteBuf.memoryAddress();\n-            allocHandle.attemptedBytesRead(byteBuf.writableBytes());\n+            int writable = byteBuf.writableBytes();\n+            allocHandle.attemptedBytesRead(writable);\n+            int datagramSize = config().getMaxDatagramPayloadSize();\n \n-            if (!recvMsg) {\n-                submissionQueue.addRead(socket.intValue(), bufferAddress,\n+            int numDatagram = datagramSize == 0 ? 1 : Math.max(1, byteBuf.writableBytes() / datagramSize);\n+\n+            if (isConnected() && numDatagram <= 1) {\n+                submissionQueue().addRead(socket.intValue(), byteBuf.memoryAddress(),\n                         byteBuf.writerIndex(), byteBuf.capacity());\n+                return 1;\n             } else {\n-                int addrLen = addrLen();\n-                long recvmsgBufferAddr = recvmsgBufferAddr();\n-                long sockaddrAddress = recvmsgBufferAddr + Native.SIZEOF_MSGHDR;\n-                long iovecAddress = sockaddrAddress + addrLen;\n-\n-                Iov.write(iovecAddress, bufferAddress + byteBuf.writerIndex(), byteBuf.writableBytes());\n-                MsgHdr.write(recvmsgBufferAddr, sockaddrAddress, addrLen, iovecAddress, 1);\n-                submissionQueue.addRecvmsg(socket.intValue(), recvmsgBufferAddr);\n+                int scheduled = scheduleRcvmsg(byteBuf, numDatagram, datagramSize);\n+                if (scheduled == 0) {\n+                    // We could not schedule any recvmmsg so we need to release the buffer as there will be no\n+                    // completion event.\n+                    readBuffer = null;\n+                    byteBuf.release();\n+                }\n+                return scheduled;\n             }\n         }\n \n-        private int addrLen() {\n-            return socket.isIpv6() ? Native.SIZEOF_SOCKADDR_IN6 :\n-                    Native.SIZEOF_SOCKADDR_IN;\n+        private int scheduleRcvmsg(ByteBuf byteBuf, int numDatagram, int datagramSize) {\n+            int writable = byteBuf.writableBytes();\n+            IOUringSubmissionQueue submissionQueue = submissionQueue();\n+            long bufferAddress = byteBuf.memoryAddress() + byteBuf.writerIndex();\n+            if (numDatagram <= 1) {\n+                MsgHdrMemory msgHdrMemory = recvmsgHdrs.nextHdr();\n+                if (msgHdrMemory == null) {\n+                    // We can not continue reading before we did not submit the recvmsg(s) and received the results.\n+                    return 0;\n+                }\n+                msgHdrMemory.write(socket, null, bufferAddress, writable);\n+                // We always use idx + 1 here so we can detect if no idx was used by checking if data == 0 in\n+                // readComplete0(...)\n+                submissionQueue.addRecvmsg(socket.intValue(), msgHdrMemory.address(), msgHdrMemory.idx() + 1);\n+                return 1;\n+            } else {\n+                int i = 0;\n+                // Add multiple IORING_OP_RECVMSG to the submission queue. This basically emulates recvmmsg(...)\n+                for (; i < numDatagram && writable >= datagramSize; i++) {\n+                    MsgHdrMemory msgHdrMemory = recvmsgHdrs.nextHdr();\n+                    if (msgHdrMemory == null) {\n+                        // We can not continue reading before we did not submit the recvmsg(s) and received the results.\n+                        break;\n+                    }\n+                    msgHdrMemory.write(socket, null, bufferAddress, datagramSize);\n+                    // We always use idx + 1 here so we can detect if no idx was used by checking if data == 0 in\n+                    // readComplete0(...)\n+                    submissionQueue.addRecvmsg(socket.intValue(), msgHdrMemory.address(), msgHdrMemory.idx() + 1);\n+                    bufferAddress += datagramSize;\n+                    writable -= datagramSize;\n+                }\n+                return i;\n+            }\n         }\n \n         @Override\n-        protected void removeFromOutboundBuffer(ChannelOutboundBuffer outboundBuffer, int bytes) {\n-            // When using Datagram we should consider the message written as long as there were any bytes written.\n-            boolean removed = outboundBuffer.remove();\n-            assert removed;\n+        boolean writeComplete0(int res, int data, int outstanding) {\n+            ChannelOutboundBuffer outboundBuffer = outboundBuffer();\n+            // We need to use idx -1 here to match up the logic in scheduleRead0()\n+            int idx = data - 1;\n+            if (idx == -1) {\n+                assert outstanding == 0;\n+                // idx == -1 means that we did a write(...) and not a sendmsg(...) operation\n+                return removeFromOutboundBuffer(outboundBuffer, res, \"io_uring write\");\n+            } else {\n+                // Store the result so we can handle it as soon as we have no outstanding writes anymore.\n+                sendmsgResArray[idx] = res;\n+                if (outstanding == 0) {\n+                    // All writes are done as part of a batch. Let's remove these from the ChannelOutboundBuffer\n+                    boolean writtenSomething = false;\n+                    int numWritten = sendmsgHdrs.length();\n+                    sendmsgHdrs.clear();\n+                    for (int i = 0; i < numWritten; i++) {\n+                        writtenSomething |= removeFromOutboundBuffer(\n+                                outboundBuffer, sendmsgResArray[i], \"io_uring sendmsg\");\n+                    }\n+                    return writtenSomething;\n+                }\n+                return true;\n+            }\n+        }\n+\n+        private boolean removeFromOutboundBuffer(ChannelOutboundBuffer outboundBuffer, int res, String errormsg) {\n+            final boolean removed;", "originalCommit": "d59f30b6b566d770dd1abe6777c3dad32b78da4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxMTE2NA==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495411164", "bodyText": "nit: conditional operator?", "author": "njhill", "createdAt": "2020-09-26T04:00:33Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringDatagramChannel.java", "diffHunk": "@@ -499,15 +588,21 @@ void connectComplete(int res) {\n         }\n \n         @Override\n-        protected void scheduleWriteMultiple(ChannelOutboundBuffer in) {\n-            // We always just use scheduleWriteSingle for now.\n-            scheduleWriteSingle(in.current());\n+        protected int scheduleWriteMultiple(ChannelOutboundBuffer in) {\n+            return writeProcessor.write(in);\n         }\n \n         @Override\n-        protected void scheduleWriteSingle(Object msg) {\n+        protected int scheduleWriteSingle(Object msg) {\n+            if (scheduleWrite(msg, false)) {\n+                return 1;\n+            }\n+            return 0;", "originalCommit": "d59f30b6b566d770dd1abe6777c3dad32b78da4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxMTIwMg==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495411202", "bodyText": "nit: don't need the else", "author": "njhill", "createdAt": "2020-09-26T04:01:16Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringDatagramChannel.java", "diffHunk": "@@ -522,23 +617,33 @@ protected void scheduleWriteSingle(Object msg) {\n             long bufferAddress = data.memoryAddress();\n             IOUringSubmissionQueue submissionQueue = submissionQueue();\n             if (remoteAddress == null) {\n-                submissionQueue.addWrite(socket.intValue(), bufferAddress, data.readerIndex(),\n-                        data.writerIndex());\n+                if (forceSendmsg) {\n+                    return scheduleSendmsg(\n+                            IOUringDatagramChannel.this.remoteAddress(), bufferAddress, data.readableBytes());\n+                } else {", "originalCommit": "d59f30b6b566d770dd1abe6777c3dad32b78da4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTQxMTIyMg==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495411222", "bodyText": "nit: don't need else", "author": "njhill", "createdAt": "2020-09-26T04:01:34Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringDatagramChannel.java", "diffHunk": "@@ -522,23 +617,33 @@ protected void scheduleWriteSingle(Object msg) {\n             long bufferAddress = data.memoryAddress();\n             IOUringSubmissionQueue submissionQueue = submissionQueue();\n             if (remoteAddress == null) {\n-                submissionQueue.addWrite(socket.intValue(), bufferAddress, data.readerIndex(),\n-                        data.writerIndex());\n+                if (forceSendmsg) {\n+                    return scheduleSendmsg(\n+                            IOUringDatagramChannel.this.remoteAddress(), bufferAddress, data.readableBytes());\n+                } else {\n+                    submissionQueue.addWrite(socket.intValue(), bufferAddress, data.readerIndex(),\n+                            data.writerIndex());\n+                    return true;\n+                }\n             } else {", "originalCommit": "d59f30b6b566d770dd1abe6777c3dad32b78da4a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU3MzU0Nw==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495573547", "bodyText": "Apart from possibly being more complicated (I don't think it would be too bad), do you envisage any other downside from using existing pooled bytebufs for this (and iovecs generally)?", "author": "njhill", "createdAt": "2020-09-27T13:33:19Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringDatagramChannel.java", "diffHunk": "@@ -326,75 +323,80 @@ protected void doClose() throws Exception {\n     }\n \n     final class IOUringDatagramChannelUnsafe extends AbstractUringUnsafe {\n-        private ByteBuf readBuffer;\n-        private boolean recvMsg;\n-\n         // These buffers are used for msghdr, iov, sockaddr_in / sockaddr_in6 when doing recvmsg / sendmsg\n         //\n         // TODO: Alternative we could also allocate these everytime from the ByteBufAllocator or we could use\n         //       some sort of other pool. Let's keep it simple for now.", "originalCommit": "d59f30b6b566d770dd1abe6777c3dad32b78da4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU4MDU2MA==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495580560", "bodyText": "I will need to do some experiments. But also the \"housekeeping\" will be a bit more complicated + sometimes people not use pooling", "author": "normanmaurer", "createdAt": "2020-09-27T14:48:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU3MzU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU3Mzk2OA==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495573968", "bodyText": "nit: could combine first 2 clauses?", "author": "njhill", "createdAt": "2020-09-27T13:37:41Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -263,34 +270,37 @@ protected void doWrite(ChannelOutboundBuffer in) {\n         if ((ioState & WRITE_SCHEDULED) != 0) {\n             return;\n         }\n-        scheduleWrite(in);\n+        if (scheduleWrite(in) > 0) {\n+            ioState |= WRITE_SCHEDULED;\n+        }\n     }\n \n-    private void scheduleWrite(ChannelOutboundBuffer in) {\n-        if (delayedClose != null) {\n-            return;\n+    private int scheduleWrite(ChannelOutboundBuffer in) {\n+        if (delayedClose != null || numOutstandingWrites == Short.MAX_VALUE) {\n+            return 0;\n         }\n         if (in == null) {\n-            return;\n+            return 0;\n         }\n \n         int msgCount = in.size();\n         if (msgCount == 0) {\n-            return;\n+            return 0;\n         }\n         Object msg = in.current();\n \n-        assert (ioState & WRITE_SCHEDULED) == 0;\n         if (msgCount > 1) {\n-            ioUringUnsafe().scheduleWriteMultiple(in);\n+            numOutstandingWrites = (short) ioUringUnsafe().scheduleWriteMultiple(in);\n         } else if ((msg instanceof ByteBuf) && ((ByteBuf) msg).nioBufferCount() > 1 ||\n                     ((msg instanceof ByteBufHolder) && ((ByteBufHolder) msg).content().nioBufferCount() > 1)) {", "originalCommit": "d59f30b6b566d770dd1abe6777c3dad32b78da4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU4MDYxMg==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495580612", "bodyText": "I found it more readable this way.", "author": "normanmaurer", "createdAt": "2020-09-27T14:48:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU3Mzk2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU3NDEwMQ==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495574101", "bodyText": "nit: combine above ifs?", "author": "njhill", "createdAt": "2020-09-27T13:39:16Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/AbstractIOUringChannel.java", "diffHunk": "@@ -263,34 +270,37 @@ protected void doWrite(ChannelOutboundBuffer in) {\n         if ((ioState & WRITE_SCHEDULED) != 0) {\n             return;\n         }\n-        scheduleWrite(in);\n+        if (scheduleWrite(in) > 0) {\n+            ioState |= WRITE_SCHEDULED;\n+        }\n     }\n \n-    private void scheduleWrite(ChannelOutboundBuffer in) {\n-        if (delayedClose != null) {\n-            return;\n+    private int scheduleWrite(ChannelOutboundBuffer in) {\n+        if (delayedClose != null || numOutstandingWrites == Short.MAX_VALUE) {\n+            return 0;\n         }\n         if (in == null) {\n-            return;\n+            return 0;\n         }\n \n         int msgCount = in.size();\n         if (msgCount == 0) {\n-            return;\n+            return 0;\n         }", "originalCommit": "d59f30b6b566d770dd1abe6777c3dad32b78da4a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU4MDU5Nw==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495580597", "bodyText": "I found it more readable this way.", "author": "normanmaurer", "createdAt": "2020-09-27T14:48:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU3NDEwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU5Njc5Mw==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495596793", "bodyText": "if the connection is true, a read event will be submitted and here a recvmsg event, why is that?", "author": "1Jo1", "createdAt": "2020-09-27T17:41:59Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringDatagramChannel.java", "diffHunk": "@@ -451,43 +472,103 @@ protected void readComplete0(int res) {\n         }\n \n         @Override\n-        protected void scheduleRead0() {\n+        protected int scheduleRead0() {\n             final IOUringRecvByteAllocatorHandle allocHandle = recvBufAllocHandle();\n             ByteBuf byteBuf = allocHandle.allocate(alloc());\n-            IOUringSubmissionQueue submissionQueue = submissionQueue();\n-\n             assert readBuffer == null;\n             readBuffer = byteBuf;\n \n-            recvMsg = !isConnected();\n-            long bufferAddress = byteBuf.memoryAddress();\n-            allocHandle.attemptedBytesRead(byteBuf.writableBytes());\n+            int writable = byteBuf.writableBytes();\n+            allocHandle.attemptedBytesRead(writable);\n+            int datagramSize = config().getMaxDatagramPayloadSize();\n+\n+            int numDatagram = datagramSize == 0 ? 1 : Math.max(1, byteBuf.writableBytes() / datagramSize);\n+\n+            if (isConnected() && numDatagram <= 1) {", "originalCommit": "58e09ecbe3a946465516fef05452154b9802219c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYwMTc0OA==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495601748", "bodyText": "sorry I can't follow... can you elaborate ?", "author": "normanmaurer", "createdAt": "2020-09-27T18:37:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU5Njc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMjA1OQ==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495902059", "bodyText": "scheduleRecvmsg0 will be executed when isConnected is false, why is a read event submitted when isConnected is true?", "author": "1Jo1", "createdAt": "2020-09-28T12:31:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU5Njc5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkwMzg3NA==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495903874", "bodyText": "because generally speaking read is cheaper then recvmsg.", "author": "normanmaurer", "createdAt": "2020-09-28T12:35:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTU5Njc5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYwMTk2OA==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495601968", "bodyText": "I can also do this as an extra PR if you prefer... @njhill @chrisvest", "author": "normanmaurer", "createdAt": "2020-09-27T18:40:11Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringSubmissionQueue.java", "diffHunk": "@@ -245,8 +245,8 @@ private void setTimeout(long timeoutNanoSeconds) {\n     private static long convertToUserData(int fd, int op, int data) {\n         assert op <= Short.MAX_VALUE;\n         assert data <= Short.MAX_VALUE;\n-        int opMask = op << 16 | (data & 0xFFFF);\n-        return (long) fd << 32 | opMask & 0xFFFFFFFFL;\n+        int opMask = (op << 16) | (((short) data) & 0xFFFF);\n+        return (((long) fd) << 32) | (opMask & 0xFFFFFFFFL);", "originalCommit": "58e09ecbe3a946465516fef05452154b9802219c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYwMjAxNg==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495602016", "bodyText": "I can also do this as an extra PR if you prefer... @njhill @chrisvest", "author": "normanmaurer", "createdAt": "2020-09-27T18:40:26Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringCompletionQueue.java", "diffHunk": "@@ -90,9 +90,9 @@ int process(IOUringCompletionQueueCallback callback) {\n             PlatformDependent.putIntOrdered(kHeadAddress, ringHead);\n \n             int fd = (int) (udata >>> 32);\n-            int opMask = (int) (udata & 0xFFFFFFFFL);\n-            int op = opMask >>> 16;\n-            int data = opMask & 0xffff;\n+            int opMask = (int) udata;\n+            int op = (short) (opMask >> 16);\n+            int data = (short) opMask;", "originalCommit": "58e09ecbe3a946465516fef05452154b9802219c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYwNzYzNg==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495607636", "bodyText": "Maybe you could you explain this one.. I may just not understand but thought here we basically want to slice up 64 bits in an unsigned manner? I'm not sure casting long to int / int to short is the best way to do that... in particular if the MSB is 1 then it will get mangled. It already looked right to me before (apart from the f/F inconsistency!).", "author": "njhill", "createdAt": "2020-09-27T19:39:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYwMjAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTcyMTY4Mw==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495721683", "bodyText": "the problem was that we did not handle negative values correctly. Like if we did use -1 as data. Let me do a separate PR with a test case to make it more clear", "author": "normanmaurer", "createdAt": "2020-09-28T06:48:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYwMjAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTczNzk5NQ==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495737995", "bodyText": "@njhill #10617", "author": "normanmaurer", "createdAt": "2020-09-28T07:25:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTYwMjAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTc4MjQ2OA==", "url": "https://github.com/netty/netty/pull/10606#discussion_r495782468", "bodyText": "Nice \ud83d\udc4d", "author": "chrisvest", "createdAt": "2020-09-28T08:47:53Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringDatagramChannel.java", "diffHunk": "@@ -488,10 +486,10 @@ protected int scheduleRead0() {\n \n             if (isConnected() && numDatagram <= 1) {\n                 submissionQueue().addRead(socket.intValue(), byteBuf.memoryAddress(),\n-                        byteBuf.writerIndex(), byteBuf.capacity());\n+                        byteBuf.writerIndex(), byteBuf.capacity(), -1);", "originalCommit": "58e09ecbe3a946465516fef05452154b9802219c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA1MjQ1OQ==", "url": "https://github.com/netty/netty/pull/10606#discussion_r496052459", "bodyText": "nit: else not needed", "author": "njhill", "createdAt": "2020-09-28T15:45:25Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringDatagramChannel.java", "diffHunk": "@@ -451,43 +472,103 @@ protected void readComplete0(int res) {\n         }\n \n         @Override\n-        protected void scheduleRead0() {\n+        protected int scheduleRead0() {\n             final IOUringRecvByteAllocatorHandle allocHandle = recvBufAllocHandle();\n             ByteBuf byteBuf = allocHandle.allocate(alloc());\n-            IOUringSubmissionQueue submissionQueue = submissionQueue();\n-\n             assert readBuffer == null;\n             readBuffer = byteBuf;\n \n-            recvMsg = !isConnected();\n-            long bufferAddress = byteBuf.memoryAddress();\n-            allocHandle.attemptedBytesRead(byteBuf.writableBytes());\n+            int writable = byteBuf.writableBytes();\n+            allocHandle.attemptedBytesRead(writable);\n+            int datagramSize = config().getMaxDatagramPayloadSize();\n+\n+            int numDatagram = datagramSize == 0 ? 1 : Math.max(1, byteBuf.writableBytes() / datagramSize);\n+\n+            if (isConnected() && numDatagram <= 1) {\n+                submissionQueue().addRead(socket.intValue(), byteBuf.memoryAddress(),\n+                        byteBuf.writerIndex(), byteBuf.capacity(), -1);\n+                return 1;\n+            } else {\n+                int scheduled = scheduleRecvmsg(byteBuf, numDatagram, datagramSize);\n+                if (scheduled == 0) {\n+                    // We could not schedule any recvmmsg so we need to release the buffer as there will be no\n+                    // completion event.\n+                    readBuffer = null;\n+                    byteBuf.release();\n+                }\n+                return scheduled;\n+            }\n+        }\n \n-            if (!recvMsg) {\n-                submissionQueue.addRead(socket.intValue(), bufferAddress,\n-                        byteBuf.writerIndex(), byteBuf.capacity());\n+        private int scheduleRecvmsg(ByteBuf byteBuf, int numDatagram, int datagramSize) {\n+            int writable = byteBuf.writableBytes();\n+            IOUringSubmissionQueue submissionQueue = submissionQueue();\n+            long bufferAddress = byteBuf.memoryAddress() + byteBuf.writerIndex();\n+            if (numDatagram <= 1) {\n+                return scheduleRecvmsg0(submissionQueue, bufferAddress, writable) ? 1 : 0;\n             } else {", "originalCommit": "58e09ecbe3a946465516fef05452154b9802219c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA1Mjg2NA==", "url": "https://github.com/netty/netty/pull/10606#discussion_r496052864", "bodyText": "nit: else not needed", "author": "njhill", "createdAt": "2020-09-28T15:45:59Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringDatagramChannel.java", "diffHunk": "@@ -451,43 +472,103 @@ protected void readComplete0(int res) {\n         }\n \n         @Override\n-        protected void scheduleRead0() {\n+        protected int scheduleRead0() {\n             final IOUringRecvByteAllocatorHandle allocHandle = recvBufAllocHandle();\n             ByteBuf byteBuf = allocHandle.allocate(alloc());\n-            IOUringSubmissionQueue submissionQueue = submissionQueue();\n-\n             assert readBuffer == null;\n             readBuffer = byteBuf;\n \n-            recvMsg = !isConnected();\n-            long bufferAddress = byteBuf.memoryAddress();\n-            allocHandle.attemptedBytesRead(byteBuf.writableBytes());\n+            int writable = byteBuf.writableBytes();\n+            allocHandle.attemptedBytesRead(writable);\n+            int datagramSize = config().getMaxDatagramPayloadSize();\n+\n+            int numDatagram = datagramSize == 0 ? 1 : Math.max(1, byteBuf.writableBytes() / datagramSize);\n+\n+            if (isConnected() && numDatagram <= 1) {\n+                submissionQueue().addRead(socket.intValue(), byteBuf.memoryAddress(),\n+                        byteBuf.writerIndex(), byteBuf.capacity(), -1);\n+                return 1;\n+            } else {\n+                int scheduled = scheduleRecvmsg(byteBuf, numDatagram, datagramSize);\n+                if (scheduled == 0) {\n+                    // We could not schedule any recvmmsg so we need to release the buffer as there will be no\n+                    // completion event.\n+                    readBuffer = null;\n+                    byteBuf.release();\n+                }\n+                return scheduled;\n+            }\n+        }\n \n-            if (!recvMsg) {\n-                submissionQueue.addRead(socket.intValue(), bufferAddress,\n-                        byteBuf.writerIndex(), byteBuf.capacity());\n+        private int scheduleRecvmsg(ByteBuf byteBuf, int numDatagram, int datagramSize) {\n+            int writable = byteBuf.writableBytes();\n+            IOUringSubmissionQueue submissionQueue = submissionQueue();\n+            long bufferAddress = byteBuf.memoryAddress() + byteBuf.writerIndex();\n+            if (numDatagram <= 1) {\n+                return scheduleRecvmsg0(submissionQueue, bufferAddress, writable) ? 1 : 0;\n             } else {\n-                int addrLen = addrLen();\n-                long recvmsgBufferAddr = recvmsgBufferAddr();\n-                long sockaddrAddress = recvmsgBufferAddr + Native.SIZEOF_MSGHDR;\n-                long iovecAddress = sockaddrAddress + addrLen;\n-\n-                Iov.write(iovecAddress, bufferAddress + byteBuf.writerIndex(), byteBuf.writableBytes());\n-                MsgHdr.write(recvmsgBufferAddr, sockaddrAddress, addrLen, iovecAddress, 1);\n-                submissionQueue.addRecvmsg(socket.intValue(), recvmsgBufferAddr);\n+                int i = 0;\n+                // Add multiple IORING_OP_RECVMSG to the submission queue. This basically emulates recvmmsg(...)\n+                for (; i < numDatagram && writable >= datagramSize; i++) {\n+                    if (!scheduleRecvmsg0(submissionQueue, bufferAddress, datagramSize)) {\n+                        break;\n+                    }\n+                    bufferAddress += datagramSize;\n+                    writable -= datagramSize;\n+                }\n+                return i;\n             }\n         }\n \n-        private int addrLen() {\n-            return socket.isIpv6() ? Native.SIZEOF_SOCKADDR_IN6 :\n-                    Native.SIZEOF_SOCKADDR_IN;\n+        private boolean scheduleRecvmsg0(IOUringSubmissionQueue submissionQueue, long bufferAddress, int bufferLength) {\n+            MsgHdrMemory msgHdrMemory = recvmsgHdrs.nextHdr();\n+            if (msgHdrMemory == null) {\n+                // We can not continue reading before we did not submit the recvmsg(s) and received the results.\n+                return false;\n+            }\n+            msgHdrMemory.write(socket, null, bufferAddress, bufferLength);\n+            // We always use idx here so we can detect if no idx was used by checking if data < 0 in\n+            // readComplete0(...)\n+            submissionQueue.addRecvmsg(socket.intValue(), msgHdrMemory.address(), msgHdrMemory.idx());\n+            return true;\n         }\n \n         @Override\n-        protected void removeFromOutboundBuffer(ChannelOutboundBuffer outboundBuffer, int bytes) {\n-            // When using Datagram we should consider the message written as long as there were any bytes written.\n-            boolean removed = outboundBuffer.remove();\n-            assert removed;\n+        boolean writeComplete0(int res, int data, int outstanding) {\n+            ChannelOutboundBuffer outboundBuffer = outboundBuffer();\n+            if (data == -1) {\n+                assert outstanding == 0;\n+                // idx == -1 means that we did a write(...) and not a sendmsg(...) operation\n+                return removeFromOutboundBuffer(outboundBuffer, res, \"io_uring write\");\n+            } else {", "originalCommit": "58e09ecbe3a946465516fef05452154b9802219c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA1MzA5MA==", "url": "https://github.com/netty/netty/pull/10606#discussion_r496053090", "bodyText": "nit: else not needed", "author": "njhill", "createdAt": "2020-09-28T15:46:18Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/IOUringDatagramChannel.java", "diffHunk": "@@ -451,43 +472,103 @@ protected void readComplete0(int res) {\n         }\n \n         @Override\n-        protected void scheduleRead0() {\n+        protected int scheduleRead0() {\n             final IOUringRecvByteAllocatorHandle allocHandle = recvBufAllocHandle();\n             ByteBuf byteBuf = allocHandle.allocate(alloc());\n-            IOUringSubmissionQueue submissionQueue = submissionQueue();\n-\n             assert readBuffer == null;\n             readBuffer = byteBuf;\n \n-            recvMsg = !isConnected();\n-            long bufferAddress = byteBuf.memoryAddress();\n-            allocHandle.attemptedBytesRead(byteBuf.writableBytes());\n+            int writable = byteBuf.writableBytes();\n+            allocHandle.attemptedBytesRead(writable);\n+            int datagramSize = config().getMaxDatagramPayloadSize();\n+\n+            int numDatagram = datagramSize == 0 ? 1 : Math.max(1, byteBuf.writableBytes() / datagramSize);\n+\n+            if (isConnected() && numDatagram <= 1) {\n+                submissionQueue().addRead(socket.intValue(), byteBuf.memoryAddress(),\n+                        byteBuf.writerIndex(), byteBuf.capacity(), -1);\n+                return 1;\n+            } else {\n+                int scheduled = scheduleRecvmsg(byteBuf, numDatagram, datagramSize);\n+                if (scheduled == 0) {\n+                    // We could not schedule any recvmmsg so we need to release the buffer as there will be no\n+                    // completion event.\n+                    readBuffer = null;\n+                    byteBuf.release();\n+                }\n+                return scheduled;\n+            }\n+        }\n \n-            if (!recvMsg) {\n-                submissionQueue.addRead(socket.intValue(), bufferAddress,\n-                        byteBuf.writerIndex(), byteBuf.capacity());\n+        private int scheduleRecvmsg(ByteBuf byteBuf, int numDatagram, int datagramSize) {\n+            int writable = byteBuf.writableBytes();\n+            IOUringSubmissionQueue submissionQueue = submissionQueue();\n+            long bufferAddress = byteBuf.memoryAddress() + byteBuf.writerIndex();\n+            if (numDatagram <= 1) {\n+                return scheduleRecvmsg0(submissionQueue, bufferAddress, writable) ? 1 : 0;\n             } else {\n-                int addrLen = addrLen();\n-                long recvmsgBufferAddr = recvmsgBufferAddr();\n-                long sockaddrAddress = recvmsgBufferAddr + Native.SIZEOF_MSGHDR;\n-                long iovecAddress = sockaddrAddress + addrLen;\n-\n-                Iov.write(iovecAddress, bufferAddress + byteBuf.writerIndex(), byteBuf.writableBytes());\n-                MsgHdr.write(recvmsgBufferAddr, sockaddrAddress, addrLen, iovecAddress, 1);\n-                submissionQueue.addRecvmsg(socket.intValue(), recvmsgBufferAddr);\n+                int i = 0;\n+                // Add multiple IORING_OP_RECVMSG to the submission queue. This basically emulates recvmmsg(...)\n+                for (; i < numDatagram && writable >= datagramSize; i++) {\n+                    if (!scheduleRecvmsg0(submissionQueue, bufferAddress, datagramSize)) {\n+                        break;\n+                    }\n+                    bufferAddress += datagramSize;\n+                    writable -= datagramSize;\n+                }\n+                return i;\n             }\n         }\n \n-        private int addrLen() {\n-            return socket.isIpv6() ? Native.SIZEOF_SOCKADDR_IN6 :\n-                    Native.SIZEOF_SOCKADDR_IN;\n+        private boolean scheduleRecvmsg0(IOUringSubmissionQueue submissionQueue, long bufferAddress, int bufferLength) {\n+            MsgHdrMemory msgHdrMemory = recvmsgHdrs.nextHdr();\n+            if (msgHdrMemory == null) {\n+                // We can not continue reading before we did not submit the recvmsg(s) and received the results.\n+                return false;\n+            }\n+            msgHdrMemory.write(socket, null, bufferAddress, bufferLength);\n+            // We always use idx here so we can detect if no idx was used by checking if data < 0 in\n+            // readComplete0(...)\n+            submissionQueue.addRecvmsg(socket.intValue(), msgHdrMemory.address(), msgHdrMemory.idx());\n+            return true;\n         }\n \n         @Override\n-        protected void removeFromOutboundBuffer(ChannelOutboundBuffer outboundBuffer, int bytes) {\n-            // When using Datagram we should consider the message written as long as there were any bytes written.\n-            boolean removed = outboundBuffer.remove();\n-            assert removed;\n+        boolean writeComplete0(int res, int data, int outstanding) {\n+            ChannelOutboundBuffer outboundBuffer = outboundBuffer();\n+            if (data == -1) {\n+                assert outstanding == 0;\n+                // idx == -1 means that we did a write(...) and not a sendmsg(...) operation\n+                return removeFromOutboundBuffer(outboundBuffer, res, \"io_uring write\");\n+            } else {\n+                // Store the result so we can handle it as soon as we have no outstanding writes anymore.\n+                sendmsgResArray[data] = res;\n+                if (outstanding == 0) {\n+                    // All writes are done as part of a batch. Let's remove these from the ChannelOutboundBuffer\n+                    boolean writtenSomething = false;\n+                    int numWritten = sendmsgHdrs.length();\n+                    sendmsgHdrs.clear();\n+                    for (int i = 0; i < numWritten; i++) {\n+                        writtenSomething |= removeFromOutboundBuffer(\n+                                outboundBuffer, sendmsgResArray[i], \"io_uring sendmsg\");\n+                    }\n+                    return writtenSomething;\n+                }\n+                return true;\n+            }\n+        }\n+\n+        private boolean removeFromOutboundBuffer(ChannelOutboundBuffer outboundBuffer, int res, String errormsg) {\n+            if (res >= 0) {\n+                // When using Datagram we should consider the message written as long as res is not negative.\n+                return outboundBuffer.remove();\n+            } else {", "originalCommit": "58e09ecbe3a946465516fef05452154b9802219c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA1MzQ4OA==", "url": "https://github.com/netty/netty/pull/10606#discussion_r496053488", "bodyText": "nit: else not needed", "author": "njhill", "createdAt": "2020-09-28T15:46:57Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/Iov.java", "diffHunk": "@@ -37,4 +37,22 @@ static void write(long iovAddress, long bufferAddress, int length) {\n             PlatformDependent.putLong(iovAddress + Native.IOVEC_OFFSETOF_IOV_LEN, length);\n         }\n     }\n+\n+    static long readBufferAddress(long iovAddress) {\n+        if (Native.SIZEOF_SIZE_T == 4) {\n+            return PlatformDependent.getInt(iovAddress + Native.IOVEC_OFFSETOF_IOV_BASE);\n+        } else {", "originalCommit": "58e09ecbe3a946465516fef05452154b9802219c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA1MzUzMA==", "url": "https://github.com/netty/netty/pull/10606#discussion_r496053530", "bodyText": "nit: else not needed", "author": "njhill", "createdAt": "2020-09-28T15:47:02Z", "path": "transport-native-io_uring/src/main/java/io/netty/channel/uring/Iov.java", "diffHunk": "@@ -37,4 +37,22 @@ static void write(long iovAddress, long bufferAddress, int length) {\n             PlatformDependent.putLong(iovAddress + Native.IOVEC_OFFSETOF_IOV_LEN, length);\n         }\n     }\n+\n+    static long readBufferAddress(long iovAddress) {\n+        if (Native.SIZEOF_SIZE_T == 4) {\n+            return PlatformDependent.getInt(iovAddress + Native.IOVEC_OFFSETOF_IOV_BASE);\n+        } else {\n+            assert Native.SIZEOF_SIZE_T == 8;\n+            return PlatformDependent.getLong(iovAddress + Native.IOVEC_OFFSETOF_IOV_BASE);\n+        }\n+    }\n+\n+    static int readBufferLength(long iovAddress) {\n+        if (Native.SIZEOF_SIZE_T == 4) {\n+            return PlatformDependent.getInt(iovAddress + Native.IOVEC_OFFSETOF_IOV_LEN);\n+        } else {", "originalCommit": "58e09ecbe3a946465516fef05452154b9802219c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "152949e761f82f1bea203a748affb9a7cb6e3c2c", "url": "https://github.com/netty/netty/commit/152949e761f82f1bea203a748affb9a7cb6e3c2c", "message": "Implement batching of reading and writing when using datagram with io_uring.\n\nMotivation:\n\nio_uring does not support recvmmsg / sendmmsg directly and so we need to\n\"emulate\" it by submitting multiple IORING_IO_RECVMSG /\nIORING_IO_SENDMSG calls.\n\nModifications:\n\n- Allow to issue multiple write / read calls at once no matter what\n  concrete AbstractIOUringChannel subclass it is\n- Add support for batching recvmsg / sendmsg when using\nIOUringDatagramChannel\n\nResult:\n\nBetter performance", "committedDate": "2020-09-29T11:52:37Z", "type": "forcePushed"}, {"oid": "d06a0e25d2654997f42156fc408df83bd2db58d3", "url": "https://github.com/netty/netty/commit/d06a0e25d2654997f42156fc408df83bd2db58d3", "message": "Implement batching of reading and writing when using datagram with io_uring.\n\nMotivation:\n\nio_uring does not support recvmmsg / sendmmsg directly and so we need to\n\"emulate\" it by submitting multiple IORING_IO_RECVMSG /\nIORING_IO_SENDMSG calls.\n\nModifications:\n\n- Allow to issue multiple write / read calls at once no matter what\n  concrete AbstractIOUringChannel subclass it is\n- Add support for batching recvmsg / sendmsg when using\nIOUringDatagramChannel\n\nResult:\n\nBetter performance", "committedDate": "2020-09-29T12:26:42Z", "type": "commit"}, {"oid": "d06a0e25d2654997f42156fc408df83bd2db58d3", "url": "https://github.com/netty/netty/commit/d06a0e25d2654997f42156fc408df83bd2db58d3", "message": "Implement batching of reading and writing when using datagram with io_uring.\n\nMotivation:\n\nio_uring does not support recvmmsg / sendmmsg directly and so we need to\n\"emulate\" it by submitting multiple IORING_IO_RECVMSG /\nIORING_IO_SENDMSG calls.\n\nModifications:\n\n- Allow to issue multiple write / read calls at once no matter what\n  concrete AbstractIOUringChannel subclass it is\n- Add support for batching recvmsg / sendmsg when using\nIOUringDatagramChannel\n\nResult:\n\nBetter performance", "committedDate": "2020-09-29T12:26:42Z", "type": "forcePushed"}]}