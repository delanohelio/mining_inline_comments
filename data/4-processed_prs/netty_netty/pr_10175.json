{"pr_number": 10175, "pr_title": "Add support for HAProxyMessageEncoder", "pr_createdAt": "2020-04-08T14:08:31Z", "pr_url": "https://github.com/netty/netty/pull/10175", "timeline": [{"oid": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "url": "https://github.com/netty/netty/commit/790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "message": "add basic support for haproxy encoder", "committedDate": "2020-04-08T13:54:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1NTE4OA==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405555188", "bodyText": "shouldn't address.length() > 108 be good enough ?", "author": "normanmaurer", "createdAt": "2020-04-08T14:10:52Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java", "diffHunk": "@@ -395,18 +416,21 @@ private static int portStringToInt(String value) {\n      *\n      * @param address                    human-readable address\n      * @param addrFamily                 the {@link AddressFamily} to check the address against\n-     * @throws HAProxyProtocolException  if the address is invalid\n+     * @throws IllegalArgumentException  if the address is invalid\n      */\n     private static void checkAddress(String address, AddressFamily addrFamily) {\n         ObjectUtil.checkNotNull(addrFamily, \"addrFamily\");\n \n         switch (addrFamily) {\n             case AF_UNSPEC:\n                 if (address != null) {\n-                    throw new HAProxyProtocolException(\"unable to validate an AF_UNSPEC address: \" + address);\n+                    throw new IllegalArgumentException(\"unable to validate an AF_UNSPEC address: \" + address);\n                 }\n                 return;\n             case AF_UNIX:\n+                if (address == null || address.getBytes(CharsetUtil.US_ASCII).length > 108) {", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYxODAwNQ==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405618005", "bodyText": "I've added an ObjectUtil.checkNotNull check to make my intention clear\n(unless you meant we should allow null addresses...   let me know if this was your intention \ud83d\ude4f )", "author": "jrhee17", "createdAt": "2020-04-08T15:35:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1NTE4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1NjM0Mw==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405556343", "bodyText": "As this one is @Sharable should we add a private constructor, mark it final and expose a static instance that the user can use ?", "author": "normanmaurer", "createdAt": "2020-04-08T14:12:31Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.AddressFamily;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1Njk3OA==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405556978", "bodyText": "why we dont write stuff directly to the ByteBuf ? We can use out.writeCharSequence(...)", "author": "normanmaurer", "createdAt": "2020-04-08T14:13:21Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.AddressFamily;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        final String protocol = msg.proxiedProtocol().name();\n+        StringBuilder sb = new StringBuilder(108)\n+                .append(\"PROXY \").append(protocol).append(' ')\n+                .append(msg.sourceAddress()).append(' ')\n+                .append(msg.destinationAddress()).append(' ')\n+                .append(msg.sourcePort()).append(' ').append(msg.destinationPort()).append(\"\\r\\n\");\n+        out.writeBytes(sb.toString().getBytes(CharsetUtil.US_ASCII));", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1NzY2MA==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405557660", "bodyText": "consider using a switch as replacement for all the if ... else if ... else.", "author": "normanmaurer", "createdAt": "2020-04-08T14:14:11Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.AddressFamily;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        final String protocol = msg.proxiedProtocol().name();\n+        StringBuilder sb = new StringBuilder(108)\n+                .append(\"PROXY \").append(protocol).append(' ')\n+                .append(msg.sourceAddress()).append(' ')\n+                .append(msg.destinationAddress()).append(' ')\n+                .append(msg.sourcePort()).append(' ').append(msg.destinationPort()).append(\"\\r\\n\");\n+        out.writeBytes(sb.toString().getBytes(CharsetUtil.US_ASCII));\n+    }\n+\n+    private static void encodeV2(HAProxyMessage msg, ByteBuf out) {\n+        out.writeBytes(BINARY_PREFIX);\n+        out.writeByte(V2_VERSION_BITMASK | msg.command().byteValue());\n+        out.writeByte(msg.proxiedProtocol().byteValue());\n+\n+        if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv4 ||\n+            msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv6) {", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1ODEyMw==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405558123", "bodyText": "Can we make this 216 an static field and add comments on what this is about ?", "author": "normanmaurer", "createdAt": "2020-04-08T14:14:49Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.AddressFamily;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        final String protocol = msg.proxiedProtocol().name();\n+        StringBuilder sb = new StringBuilder(108)\n+                .append(\"PROXY \").append(protocol).append(' ')\n+                .append(msg.sourceAddress()).append(' ')\n+                .append(msg.destinationAddress()).append(' ')\n+                .append(msg.sourcePort()).append(' ').append(msg.destinationPort()).append(\"\\r\\n\");\n+        out.writeBytes(sb.toString().getBytes(CharsetUtil.US_ASCII));\n+    }\n+\n+    private static void encodeV2(HAProxyMessage msg, ByteBuf out) {\n+        out.writeBytes(BINARY_PREFIX);\n+        out.writeByte(V2_VERSION_BITMASK | msg.command().byteValue());\n+        out.writeByte(msg.proxiedProtocol().byteValue());\n+\n+        if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv4 ||\n+            msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv6) {\n+            byte[] sourceAddress = NetUtil.createByteArrayFromIpAddressString(msg.sourceAddress());\n+            byte[] destinationAddress = NetUtil.createByteArrayFromIpAddressString(msg.destinationAddress());\n+            out.writeShort(sourceAddress.length + destinationAddress.length + 4 + msg.tlvNumBytes());\n+            out.writeBytes(sourceAddress);\n+            out.writeBytes(destinationAddress);\n+            out.writeShort(msg.sourcePort());\n+            out.writeShort(msg.destinationPort());\n+            encodeTlvs(msg.tlvs(), out);\n+        } else if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_UNIX) {\n+            out.writeShort(216 + msg.tlvNumBytes());", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1ODM5MQ==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405558391", "bodyText": "again consider using out.writeCharSequence(...)", "author": "normanmaurer", "createdAt": "2020-04-08T14:15:11Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.AddressFamily;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        final String protocol = msg.proxiedProtocol().name();\n+        StringBuilder sb = new StringBuilder(108)\n+                .append(\"PROXY \").append(protocol).append(' ')\n+                .append(msg.sourceAddress()).append(' ')\n+                .append(msg.destinationAddress()).append(' ')\n+                .append(msg.sourcePort()).append(' ').append(msg.destinationPort()).append(\"\\r\\n\");\n+        out.writeBytes(sb.toString().getBytes(CharsetUtil.US_ASCII));\n+    }\n+\n+    private static void encodeV2(HAProxyMessage msg, ByteBuf out) {\n+        out.writeBytes(BINARY_PREFIX);\n+        out.writeByte(V2_VERSION_BITMASK | msg.command().byteValue());\n+        out.writeByte(msg.proxiedProtocol().byteValue());\n+\n+        if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv4 ||\n+            msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv6) {\n+            byte[] sourceAddress = NetUtil.createByteArrayFromIpAddressString(msg.sourceAddress());\n+            byte[] destinationAddress = NetUtil.createByteArrayFromIpAddressString(msg.destinationAddress());\n+            out.writeShort(sourceAddress.length + destinationAddress.length + 4 + msg.tlvNumBytes());\n+            out.writeBytes(sourceAddress);\n+            out.writeBytes(destinationAddress);\n+            out.writeShort(msg.sourcePort());\n+            out.writeShort(msg.destinationPort());\n+            encodeTlvs(msg.tlvs(), out);\n+        } else if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_UNIX) {\n+            out.writeShort(216 + msg.tlvNumBytes());\n+            byte[] srcAddressBytes = msg.sourceAddress().getBytes(CharsetUtil.US_ASCII);\n+            out.writeBytes(srcAddressBytes);", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYxNTIwNA==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405615204", "bodyText": "I think we have a couple of options:\n\nPad the string to 108 length, and use writeCharSequence \n-> I'm not sure the extra string allocation will be worth it. I don't think readability will improve either, since we still need to 1) get the size of the address in bytes 2) allocate a new 108 byte length string 3) and write to ByteBuffer.\nRestrict user input to accept only 108 byte addresses\n-> usability \ud83d\ude22\nKeep AS-IS\n\nI prefer 3, but might be willing to change to 1) if you wish", "author": "jrhee17", "createdAt": "2020-04-08T15:31:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1ODM5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1ODUyMg==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405558522", "bodyText": "same comment as above.", "author": "normanmaurer", "createdAt": "2020-04-08T14:15:23Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.AddressFamily;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        final String protocol = msg.proxiedProtocol().name();\n+        StringBuilder sb = new StringBuilder(108)\n+                .append(\"PROXY \").append(protocol).append(' ')\n+                .append(msg.sourceAddress()).append(' ')\n+                .append(msg.destinationAddress()).append(' ')\n+                .append(msg.sourcePort()).append(' ').append(msg.destinationPort()).append(\"\\r\\n\");\n+        out.writeBytes(sb.toString().getBytes(CharsetUtil.US_ASCII));\n+    }\n+\n+    private static void encodeV2(HAProxyMessage msg, ByteBuf out) {\n+        out.writeBytes(BINARY_PREFIX);\n+        out.writeByte(V2_VERSION_BITMASK | msg.command().byteValue());\n+        out.writeByte(msg.proxiedProtocol().byteValue());\n+\n+        if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv4 ||\n+            msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv6) {\n+            byte[] sourceAddress = NetUtil.createByteArrayFromIpAddressString(msg.sourceAddress());\n+            byte[] destinationAddress = NetUtil.createByteArrayFromIpAddressString(msg.destinationAddress());\n+            out.writeShort(sourceAddress.length + destinationAddress.length + 4 + msg.tlvNumBytes());\n+            out.writeBytes(sourceAddress);\n+            out.writeBytes(destinationAddress);\n+            out.writeShort(msg.sourcePort());\n+            out.writeShort(msg.destinationPort());\n+            encodeTlvs(msg.tlvs(), out);\n+        } else if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_UNIX) {\n+            out.writeShort(216 + msg.tlvNumBytes());\n+            byte[] srcAddressBytes = msg.sourceAddress().getBytes(CharsetUtil.US_ASCII);\n+            out.writeBytes(srcAddressBytes);\n+            out.writeBytes(new byte[108 - srcAddressBytes.length]);\n+            byte[] dstAddressBytes = msg.destinationAddress().getBytes(CharsetUtil.US_ASCII);\n+            out.writeBytes(dstAddressBytes);", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTYxNTI3MA==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405615270", "bodyText": "ditto", "author": "jrhee17", "createdAt": "2020-04-08T15:32:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1ODUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1ODc1Mw==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405558753", "bodyText": "please make this 108 an static field and add comments what this is about.", "author": "normanmaurer", "createdAt": "2020-04-08T14:15:41Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.AddressFamily;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        final String protocol = msg.proxiedProtocol().name();\n+        StringBuilder sb = new StringBuilder(108)\n+                .append(\"PROXY \").append(protocol).append(' ')\n+                .append(msg.sourceAddress()).append(' ')\n+                .append(msg.destinationAddress()).append(' ')\n+                .append(msg.sourcePort()).append(' ').append(msg.destinationPort()).append(\"\\r\\n\");\n+        out.writeBytes(sb.toString().getBytes(CharsetUtil.US_ASCII));\n+    }\n+\n+    private static void encodeV2(HAProxyMessage msg, ByteBuf out) {\n+        out.writeBytes(BINARY_PREFIX);\n+        out.writeByte(V2_VERSION_BITMASK | msg.command().byteValue());\n+        out.writeByte(msg.proxiedProtocol().byteValue());\n+\n+        if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv4 ||\n+            msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv6) {\n+            byte[] sourceAddress = NetUtil.createByteArrayFromIpAddressString(msg.sourceAddress());\n+            byte[] destinationAddress = NetUtil.createByteArrayFromIpAddressString(msg.destinationAddress());\n+            out.writeShort(sourceAddress.length + destinationAddress.length + 4 + msg.tlvNumBytes());\n+            out.writeBytes(sourceAddress);\n+            out.writeBytes(destinationAddress);\n+            out.writeShort(msg.sourcePort());\n+            out.writeShort(msg.destinationPort());\n+            encodeTlvs(msg.tlvs(), out);\n+        } else if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_UNIX) {\n+            out.writeShort(216 + msg.tlvNumBytes());\n+            byte[] srcAddressBytes = msg.sourceAddress().getBytes(CharsetUtil.US_ASCII);\n+            out.writeBytes(srcAddressBytes);\n+            out.writeBytes(new byte[108 - srcAddressBytes.length]);", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1OTIyMA==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405559220", "bodyText": "closing using index based for loop to eliminate GC pressure", "author": "normanmaurer", "createdAt": "2020-04-08T14:16:19Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProxiedProtocol.AddressFamily;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        final String protocol = msg.proxiedProtocol().name();\n+        StringBuilder sb = new StringBuilder(108)\n+                .append(\"PROXY \").append(protocol).append(' ')\n+                .append(msg.sourceAddress()).append(' ')\n+                .append(msg.destinationAddress()).append(' ')\n+                .append(msg.sourcePort()).append(' ').append(msg.destinationPort()).append(\"\\r\\n\");\n+        out.writeBytes(sb.toString().getBytes(CharsetUtil.US_ASCII));\n+    }\n+\n+    private static void encodeV2(HAProxyMessage msg, ByteBuf out) {\n+        out.writeBytes(BINARY_PREFIX);\n+        out.writeByte(V2_VERSION_BITMASK | msg.command().byteValue());\n+        out.writeByte(msg.proxiedProtocol().byteValue());\n+\n+        if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv4 ||\n+            msg.proxiedProtocol().addressFamily() == AddressFamily.AF_IPv6) {\n+            byte[] sourceAddress = NetUtil.createByteArrayFromIpAddressString(msg.sourceAddress());\n+            byte[] destinationAddress = NetUtil.createByteArrayFromIpAddressString(msg.destinationAddress());\n+            out.writeShort(sourceAddress.length + destinationAddress.length + 4 + msg.tlvNumBytes());\n+            out.writeBytes(sourceAddress);\n+            out.writeBytes(destinationAddress);\n+            out.writeShort(msg.sourcePort());\n+            out.writeShort(msg.destinationPort());\n+            encodeTlvs(msg.tlvs(), out);\n+        } else if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_UNIX) {\n+            out.writeShort(216 + msg.tlvNumBytes());\n+            byte[] srcAddressBytes = msg.sourceAddress().getBytes(CharsetUtil.US_ASCII);\n+            out.writeBytes(srcAddressBytes);\n+            out.writeBytes(new byte[108 - srcAddressBytes.length]);\n+            byte[] dstAddressBytes = msg.destinationAddress().getBytes(CharsetUtil.US_ASCII);\n+            out.writeBytes(dstAddressBytes);\n+            out.writeBytes(new byte[108 - dstAddressBytes.length]);\n+            encodeTlvs(msg.tlvs(), out);\n+        } else if (msg.proxiedProtocol().addressFamily() == AddressFamily.AF_UNSPEC) {\n+            out.writeShort(0);\n+        }\n+    }\n+\n+    private static void encodeTlv(HAProxyTLV haProxyTLV, ByteBuf out) {\n+        if (haProxyTLV instanceof HAProxySSLTLV) {\n+            HAProxySSLTLV ssltlv = (HAProxySSLTLV) haProxyTLV;\n+            out.writeByte(haProxyTLV.typeByteValue());\n+            out.writeShort(ssltlv.contentNumBytes());\n+            out.writeByte(ssltlv.client());\n+            out.writeInt(ssltlv.verify());\n+            encodeTlvs(ssltlv.encapsulatedTLVs(), out);\n+        } else {\n+            out.writeByte(haProxyTLV.typeByteValue());\n+            ByteBuf value = haProxyTLV.content();\n+            int readableBytes = value.readableBytes();\n+            out.writeShort(readableBytes);\n+            out.writeBytes(value.readSlice(readableBytes));\n+        }\n+    }\n+\n+    private static void encodeTlvs(List<HAProxyTLV> haProxyTLVs, ByteBuf out) {\n+        for (HAProxyTLV tlv: haProxyTLVs) {", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1OTM5OQ==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405559399", "bodyText": "please add javadocs", "author": "normanmaurer", "createdAt": "2020-04-08T14:16:36Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxySSLTLV.java", "diffHunk": "@@ -69,6 +83,9 @@ public boolean isPP2ClientCertSess() {\n         return (clientBitField & 0x4) != 0;\n     }\n \n+    public byte client() {", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1OTUxNw==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405559517", "bodyText": "add empty line above", "author": "normanmaurer", "createdAt": "2020-04-08T14:16:45Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxySSLTLV.java", "diffHunk": "@@ -69,6 +83,9 @@ public boolean isPP2ClientCertSess() {\n         return (clientBitField & 0x4) != 0;\n     }\n \n+    public byte client() {\n+        return clientBitField;\n+    }\n     /**", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU1OTc2Mg==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405559762", "bodyText": "Just use normal string concats...", "author": "normanmaurer", "createdAt": "2020-04-08T14:17:06Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxySSLTLV.java", "diffHunk": "@@ -83,4 +100,24 @@ public int verify() {\n         return tlvs;\n     }\n \n+    @Override\n+    int contentNumBytes() {\n+        int tlvNumBytes = 0;\n+        for (int i = 0; i < tlvs.size(); i++) {\n+            tlvNumBytes += tlvs.get(i).totalNumBytes();\n+        }\n+        return 5 + tlvNumBytes; // clientBit(1) + verify(4) + tlvs\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return new StringBuilder(128)", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MDE3Nw==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405560177", "bodyText": "please add javadocs and consider removing final to be more consistent", "author": "normanmaurer", "createdAt": "2020-04-08T14:17:36Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyTLV.java", "diffHunk": "@@ -74,6 +87,45 @@ public static Type typeForByteValue(final byte byteValue) {\n                 return OTHER;\n             }\n         }\n+\n+        public static byte byteValueForType(final Type type) {", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MDUzOA==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405560538", "bodyText": "same comment as above... consider just using normal string concat", "author": "normanmaurer", "createdAt": "2020-04-08T14:18:01Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyTLV.java", "diffHunk": "@@ -146,4 +198,15 @@ public HAProxyTLV touch(Object hint) {\n         super.touch(hint);\n         return this;\n     }\n+\n+    @Override\n+    public String toString() {\n+        return new StringBuilder(256)", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MTIzNA==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405561234", "bodyText": "you should call msg.retain() as SimpleChannelInboundHandler will release the msg after channelRead0 returns", "author": "normanmaurer", "createdAt": "2020-04-08T14:19:00Z", "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HAProxyIntegrationTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.DefaultEventLoopGroup;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.channel.local.LocalAddress;\n+import io.netty.channel.local.LocalChannel;\n+import io.netty.channel.local.LocalServerChannel;\n+import org.junit.Test;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.junit.Assert.*;\n+\n+public class HAProxyIntegrationTest {\n+\n+    @Test\n+    public void testBasicCase() throws Exception {\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        final AtomicReference<HAProxyMessage> msgHolder = new AtomicReference<HAProxyMessage>();\n+\n+        EventLoopGroup group = new DefaultEventLoopGroup();\n+        ServerBootstrap sb = new ServerBootstrap();\n+        sb.channel(LocalServerChannel.class)\n+          .group(group)\n+          .childHandler(new ChannelInitializer() {\n+              @Override\n+              protected void initChannel(Channel ch) throws Exception {\n+                  ch.pipeline().addLast(new HAProxyMessageDecoder());\n+                  ch.pipeline().addLast(new SimpleChannelInboundHandler<HAProxyMessage>() {\n+                      @Override\n+                      protected void channelRead0(ChannelHandlerContext ctx, HAProxyMessage msg) throws Exception {\n+                          msgHolder.set(msg);", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MTQ2Mw==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405561463", "bodyText": "call readMessage.release() in a finally block", "author": "normanmaurer", "createdAt": "2020-04-08T14:19:18Z", "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HAProxyIntegrationTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.DefaultEventLoopGroup;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.channel.local.LocalAddress;\n+import io.netty.channel.local.LocalChannel;\n+import io.netty.channel.local.LocalServerChannel;\n+import org.junit.Test;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.junit.Assert.*;\n+\n+public class HAProxyIntegrationTest {\n+\n+    @Test\n+    public void testBasicCase() throws Exception {\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        final AtomicReference<HAProxyMessage> msgHolder = new AtomicReference<HAProxyMessage>();\n+\n+        EventLoopGroup group = new DefaultEventLoopGroup();\n+        ServerBootstrap sb = new ServerBootstrap();\n+        sb.channel(LocalServerChannel.class)\n+          .group(group)\n+          .childHandler(new ChannelInitializer() {\n+              @Override\n+              protected void initChannel(Channel ch) throws Exception {\n+                  ch.pipeline().addLast(new HAProxyMessageDecoder());\n+                  ch.pipeline().addLast(new SimpleChannelInboundHandler<HAProxyMessage>() {\n+                      @Override\n+                      protected void channelRead0(ChannelHandlerContext ctx, HAProxyMessage msg) throws Exception {\n+                          msgHolder.set(msg);\n+                          latch.countDown();\n+                      }\n+                  });\n+              }\n+          });\n+\n+        LocalAddress localAddress = new LocalAddress(\"HAProxyIntegrationTest\");\n+        sb.bind(localAddress).sync().channel();\n+\n+        Bootstrap b = new Bootstrap();\n+        Channel clientChannel = b.channel(LocalChannel.class)\n+                                 .handler(new HAProxyMessageEncoder())\n+                                 .group(group)\n+                                 .connect(localAddress).sync().channel();\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        clientChannel.writeAndFlush(message);\n+\n+        assertTrue(latch.await(5, TimeUnit.SECONDS));\n+        HAProxyMessage readMessage = msgHolder.get();\n+\n+        assertEquals(message.protocolVersion(), readMessage.protocolVersion());\n+        assertEquals(message.command(), readMessage.command());\n+        assertEquals(message.proxiedProtocol(), readMessage.proxiedProtocol());\n+        assertEquals(message.sourceAddress(), readMessage.sourceAddress());\n+        assertEquals(message.destinationAddress(), readMessage.destinationAddress());\n+        assertEquals(message.sourcePort(), readMessage.sourcePort());\n+        assertEquals(message.destinationPort(), readMessage.destinationPort());", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MTU4MA==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405561580", "bodyText": "add sync()", "author": "normanmaurer", "createdAt": "2020-04-08T14:19:27Z", "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HAProxyIntegrationTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.DefaultEventLoopGroup;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.channel.local.LocalAddress;\n+import io.netty.channel.local.LocalChannel;\n+import io.netty.channel.local.LocalServerChannel;\n+import org.junit.Test;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.junit.Assert.*;\n+\n+public class HAProxyIntegrationTest {\n+\n+    @Test\n+    public void testBasicCase() throws Exception {\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        final AtomicReference<HAProxyMessage> msgHolder = new AtomicReference<HAProxyMessage>();\n+\n+        EventLoopGroup group = new DefaultEventLoopGroup();\n+        ServerBootstrap sb = new ServerBootstrap();\n+        sb.channel(LocalServerChannel.class)\n+          .group(group)\n+          .childHandler(new ChannelInitializer() {\n+              @Override\n+              protected void initChannel(Channel ch) throws Exception {\n+                  ch.pipeline().addLast(new HAProxyMessageDecoder());\n+                  ch.pipeline().addLast(new SimpleChannelInboundHandler<HAProxyMessage>() {\n+                      @Override\n+                      protected void channelRead0(ChannelHandlerContext ctx, HAProxyMessage msg) throws Exception {\n+                          msgHolder.set(msg);\n+                          latch.countDown();\n+                      }\n+                  });\n+              }\n+          });\n+\n+        LocalAddress localAddress = new LocalAddress(\"HAProxyIntegrationTest\");\n+        sb.bind(localAddress).sync().channel();\n+\n+        Bootstrap b = new Bootstrap();\n+        Channel clientChannel = b.channel(LocalChannel.class)\n+                                 .handler(new HAProxyMessageEncoder())\n+                                 .group(group)\n+                                 .connect(localAddress).sync().channel();\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        clientChannel.writeAndFlush(message);", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MjA1OQ==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405562059", "bodyText": "also close the channels and shutdown the group in a finally block", "author": "normanmaurer", "createdAt": "2020-04-08T14:20:05Z", "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HAProxyIntegrationTest.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.bootstrap.Bootstrap;\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.channel.Channel;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.DefaultEventLoopGroup;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.SimpleChannelInboundHandler;\n+import io.netty.channel.local.LocalAddress;\n+import io.netty.channel.local.LocalChannel;\n+import io.netty.channel.local.LocalServerChannel;\n+import org.junit.Test;\n+\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicReference;\n+\n+import static org.junit.Assert.*;\n+\n+public class HAProxyIntegrationTest {\n+\n+    @Test\n+    public void testBasicCase() throws Exception {\n+        final CountDownLatch latch = new CountDownLatch(1);\n+        final AtomicReference<HAProxyMessage> msgHolder = new AtomicReference<HAProxyMessage>();\n+\n+        EventLoopGroup group = new DefaultEventLoopGroup();\n+        ServerBootstrap sb = new ServerBootstrap();\n+        sb.channel(LocalServerChannel.class)\n+          .group(group)\n+          .childHandler(new ChannelInitializer() {\n+              @Override\n+              protected void initChannel(Channel ch) throws Exception {\n+                  ch.pipeline().addLast(new HAProxyMessageDecoder());\n+                  ch.pipeline().addLast(new SimpleChannelInboundHandler<HAProxyMessage>() {\n+                      @Override\n+                      protected void channelRead0(ChannelHandlerContext ctx, HAProxyMessage msg) throws Exception {\n+                          msgHolder.set(msg);\n+                          latch.countDown();\n+                      }\n+                  });\n+              }\n+          });\n+\n+        LocalAddress localAddress = new LocalAddress(\"HAProxyIntegrationTest\");\n+        sb.bind(localAddress).sync().channel();\n+\n+        Bootstrap b = new Bootstrap();\n+        Channel clientChannel = b.channel(LocalChannel.class)\n+                                 .handler(new HAProxyMessageEncoder())\n+                                 .group(group)\n+                                 .connect(localAddress).sync().channel();\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        clientChannel.writeAndFlush(message);\n+\n+        assertTrue(latch.await(5, TimeUnit.SECONDS));\n+        HAProxyMessage readMessage = msgHolder.get();\n+\n+        assertEquals(message.protocolVersion(), readMessage.protocolVersion());\n+        assertEquals(message.command(), readMessage.command());\n+        assertEquals(message.proxiedProtocol(), readMessage.proxiedProtocol());\n+        assertEquals(message.sourceAddress(), readMessage.sourceAddress());\n+        assertEquals(message.destinationAddress(), readMessage.destinationAddress());\n+        assertEquals(message.sourcePort(), readMessage.sourcePort());\n+        assertEquals(message.destinationPort(), readMessage.destinationPort());\n+    }", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MjU4Ng==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405562586", "bodyText": "call byteBuf.release(); and also add assertFalse(ch.finish());", "author": "normanmaurer", "createdAt": "2020-04-08T14:20:51Z", "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HaProxyMessageEncoderTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.haproxy.HAProxyTLV.Type;\n+import io.netty.util.ByteProcessor;\n+import io.netty.util.CharsetUtil;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+import static org.junit.Assert.*;\n+\n+public class HaProxyMessageEncoderTest {\n+\n+    private static final int V2_HEADER_BYTES_LENGTH = 16;\n+    private static final int IPv4_ADDRESS_BYTES_LENGTH = 12;\n+    private static final int IPv6_ADDRESS_BYTES_LENGTH = 36;\n+    private static final int UNIX_ADDRESS_BYTES_LENGTH = 216;\n+\n+    @Test\n+    public void testIPV4EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP4 192.168.0.1 192.168.0.11 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MjcwMg==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405562702", "bodyText": "call byteBuf.release(); and also add assertFalse(ch.finish());", "author": "normanmaurer", "createdAt": "2020-04-08T14:21:01Z", "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HaProxyMessageEncoderTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.haproxy.HAProxyTLV.Type;\n+import io.netty.util.ByteProcessor;\n+import io.netty.util.CharsetUtil;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+import static org.junit.Assert.*;\n+\n+public class HaProxyMessageEncoderTest {\n+\n+    private static final int V2_HEADER_BYTES_LENGTH = 16;\n+    private static final int IPv4_ADDRESS_BYTES_LENGTH = 12;\n+    private static final int IPv6_ADDRESS_BYTES_LENGTH = 36;\n+    private static final int UNIX_ADDRESS_BYTES_LENGTH = 216;\n+\n+    @Test\n+    public void testIPV4EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP4 192.168.0.1 192.168.0.11 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPV6EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP6 2001:0db8:85a3:0000:0000:8a2e:0370:7334 1050:0:0:0:5:600:300c:326b 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MjgyNA==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405562824", "bodyText": "call byteBuf.release() and also add assertFalse(ch.finish());", "author": "normanmaurer", "createdAt": "2020-04-08T14:21:12Z", "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HaProxyMessageEncoderTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.haproxy.HAProxyTLV.Type;\n+import io.netty.util.ByteProcessor;\n+import io.netty.util.CharsetUtil;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+import static org.junit.Assert.*;\n+\n+public class HaProxyMessageEncoderTest {\n+\n+    private static final int V2_HEADER_BYTES_LENGTH = 16;\n+    private static final int IPv4_ADDRESS_BYTES_LENGTH = 12;\n+    private static final int IPv6_ADDRESS_BYTES_LENGTH = 36;\n+    private static final int UNIX_ADDRESS_BYTES_LENGTH = 216;\n+\n+    @Test\n+    public void testIPV4EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP4 192.168.0.1 192.168.0.11 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPV6EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP6 2001:0db8:85a3:0000:0000:8a2e:0370:7334 1050:0:0:0:5:600:300c:326b 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPv4EncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x01, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(12, sourceAddrLength);\n+\n+        // source address\n+        byte[] sourceAddr = ByteBufUtil.getBytes(byteBuf, 16, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x01}, sourceAddr);\n+\n+        // destination address\n+        byte[] destAddr = ByteBufUtil.getBytes(byteBuf, 20, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x0b}, destAddr);\n+\n+        // source port\n+        int sourcePort = byteBuf.getUnsignedShort(24);\n+        assertEquals(56324, sourcePort);\n+\n+        // destination port\n+        int destPort = byteBuf.getUnsignedShort(26);\n+        assertEquals(443, destPort);", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MjkxMQ==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405562911", "bodyText": "call byteBuf.release() and also add assertFalse(ch.finish());", "author": "normanmaurer", "createdAt": "2020-04-08T14:21:19Z", "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HaProxyMessageEncoderTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.haproxy.HAProxyTLV.Type;\n+import io.netty.util.ByteProcessor;\n+import io.netty.util.CharsetUtil;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+import static org.junit.Assert.*;\n+\n+public class HaProxyMessageEncoderTest {\n+\n+    private static final int V2_HEADER_BYTES_LENGTH = 16;\n+    private static final int IPv4_ADDRESS_BYTES_LENGTH = 12;\n+    private static final int IPv6_ADDRESS_BYTES_LENGTH = 36;\n+    private static final int UNIX_ADDRESS_BYTES_LENGTH = 216;\n+\n+    @Test\n+    public void testIPV4EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP4 192.168.0.1 192.168.0.11 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPV6EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP6 2001:0db8:85a3:0000:0000:8a2e:0370:7334 1050:0:0:0:5:600:300c:326b 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPv4EncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x01, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(12, sourceAddrLength);\n+\n+        // source address\n+        byte[] sourceAddr = ByteBufUtil.getBytes(byteBuf, 16, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x01}, sourceAddr);\n+\n+        // destination address\n+        byte[] destAddr = ByteBufUtil.getBytes(byteBuf, 20, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x0b}, destAddr);\n+\n+        // source port\n+        int sourcePort = byteBuf.getUnsignedShort(24);\n+        assertEquals(56324, sourcePort);\n+\n+        // destination port\n+        int destPort = byteBuf.getUnsignedShort(26);\n+        assertEquals(443, destPort);\n+    }\n+\n+    @Test\n+    public void testIPv6EncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x02, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(IPv6_ADDRESS_BYTES_LENGTH, sourceAddrLength);\n+\n+        // source address\n+        byte[] sourceAddr = ByteBufUtil.getBytes(byteBuf, 16, 16);\n+        assertArrayEquals(new byte[] { (byte) 0x20, (byte) 0x01, 0x0d, (byte) 0xb8,\n+                (byte) 0x85, (byte) 0xa3, 0x00, 0x00, 0x00, 0x00, (byte) 0x8a, 0x2e,\n+                0x03, 0x70, 0x73, 0x34}, sourceAddr);\n+\n+        // destination address\n+        byte[] destAddr = ByteBufUtil.getBytes(byteBuf, 32, 16);\n+        assertArrayEquals(new byte[] { (byte) 0x10, (byte) 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+                0x00, 0x05, 0x06, 0x00, 0x30, 0x0c, 0x32, 0x6b}, destAddr);\n+\n+        // source port\n+        int sourcePort = byteBuf.getUnsignedShort(48);\n+        assertEquals(56324, sourcePort);\n+\n+        // destination port\n+        int destPort = byteBuf.getUnsignedShort(50);\n+        assertEquals(443, destPort);", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2Mjk5Ng==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405562996", "bodyText": "call byteBuf.release() and also add assertFalse(ch.finish());", "author": "normanmaurer", "createdAt": "2020-04-08T14:21:27Z", "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HaProxyMessageEncoderTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.haproxy.HAProxyTLV.Type;\n+import io.netty.util.ByteProcessor;\n+import io.netty.util.CharsetUtil;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+import static org.junit.Assert.*;\n+\n+public class HaProxyMessageEncoderTest {\n+\n+    private static final int V2_HEADER_BYTES_LENGTH = 16;\n+    private static final int IPv4_ADDRESS_BYTES_LENGTH = 12;\n+    private static final int IPv6_ADDRESS_BYTES_LENGTH = 36;\n+    private static final int UNIX_ADDRESS_BYTES_LENGTH = 216;\n+\n+    @Test\n+    public void testIPV4EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP4 192.168.0.1 192.168.0.11 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPV6EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP6 2001:0db8:85a3:0000:0000:8a2e:0370:7334 1050:0:0:0:5:600:300c:326b 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPv4EncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x01, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(12, sourceAddrLength);\n+\n+        // source address\n+        byte[] sourceAddr = ByteBufUtil.getBytes(byteBuf, 16, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x01}, sourceAddr);\n+\n+        // destination address\n+        byte[] destAddr = ByteBufUtil.getBytes(byteBuf, 20, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x0b}, destAddr);\n+\n+        // source port\n+        int sourcePort = byteBuf.getUnsignedShort(24);\n+        assertEquals(56324, sourcePort);\n+\n+        // destination port\n+        int destPort = byteBuf.getUnsignedShort(26);\n+        assertEquals(443, destPort);\n+    }\n+\n+    @Test\n+    public void testIPv6EncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x02, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(IPv6_ADDRESS_BYTES_LENGTH, sourceAddrLength);\n+\n+        // source address\n+        byte[] sourceAddr = ByteBufUtil.getBytes(byteBuf, 16, 16);\n+        assertArrayEquals(new byte[] { (byte) 0x20, (byte) 0x01, 0x0d, (byte) 0xb8,\n+                (byte) 0x85, (byte) 0xa3, 0x00, 0x00, 0x00, 0x00, (byte) 0x8a, 0x2e,\n+                0x03, 0x70, 0x73, 0x34}, sourceAddr);\n+\n+        // destination address\n+        byte[] destAddr = ByteBufUtil.getBytes(byteBuf, 32, 16);\n+        assertArrayEquals(new byte[] { (byte) 0x10, (byte) 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+                0x00, 0x05, 0x06, 0x00, 0x30, 0x0c, 0x32, 0x6b}, destAddr);\n+\n+        // source port\n+        int sourcePort = byteBuf.getUnsignedShort(48);\n+        assertEquals(56324, sourcePort);\n+\n+        // destination port\n+        int destPort = byteBuf.getUnsignedShort(50);\n+        assertEquals(443, destPort);\n+    }\n+\n+    @Test\n+    public void testUnixEncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.UNIX_STREAM,\n+                \"/var/run/src.sock\", \"/var/run/dst.sock\", 0, 0);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x03, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(216, sourceAddrLength);\n+\n+        // source address\n+        int srcAddrEnd = byteBuf.forEachByte(16, 108, ByteProcessor.FIND_NUL);\n+        assertEquals(\"/var/run/src.sock\",\n+                     byteBuf.slice(16, srcAddrEnd - 16).toString(CharsetUtil.US_ASCII));\n+\n+        // destination address\n+        int dstAddrEnd = byteBuf.forEachByte(124, 108, ByteProcessor.FIND_NUL);\n+        assertEquals(\"/var/run/dst.sock\",\n+                     byteBuf.slice(124, dstAddrEnd - 124).toString(CharsetUtil.US_ASCII));", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MzEyMw==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405563123", "bodyText": "call byteBuf.release() and also add assertFalse(ch.finish());", "author": "normanmaurer", "createdAt": "2020-04-08T14:21:39Z", "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HaProxyMessageEncoderTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.haproxy.HAProxyTLV.Type;\n+import io.netty.util.ByteProcessor;\n+import io.netty.util.CharsetUtil;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+import static org.junit.Assert.*;\n+\n+public class HaProxyMessageEncoderTest {\n+\n+    private static final int V2_HEADER_BYTES_LENGTH = 16;\n+    private static final int IPv4_ADDRESS_BYTES_LENGTH = 12;\n+    private static final int IPv6_ADDRESS_BYTES_LENGTH = 36;\n+    private static final int UNIX_ADDRESS_BYTES_LENGTH = 216;\n+\n+    @Test\n+    public void testIPV4EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP4 192.168.0.1 192.168.0.11 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPV6EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP6 2001:0db8:85a3:0000:0000:8a2e:0370:7334 1050:0:0:0:5:600:300c:326b 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPv4EncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x01, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(12, sourceAddrLength);\n+\n+        // source address\n+        byte[] sourceAddr = ByteBufUtil.getBytes(byteBuf, 16, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x01}, sourceAddr);\n+\n+        // destination address\n+        byte[] destAddr = ByteBufUtil.getBytes(byteBuf, 20, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x0b}, destAddr);\n+\n+        // source port\n+        int sourcePort = byteBuf.getUnsignedShort(24);\n+        assertEquals(56324, sourcePort);\n+\n+        // destination port\n+        int destPort = byteBuf.getUnsignedShort(26);\n+        assertEquals(443, destPort);\n+    }\n+\n+    @Test\n+    public void testIPv6EncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x02, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(IPv6_ADDRESS_BYTES_LENGTH, sourceAddrLength);\n+\n+        // source address\n+        byte[] sourceAddr = ByteBufUtil.getBytes(byteBuf, 16, 16);\n+        assertArrayEquals(new byte[] { (byte) 0x20, (byte) 0x01, 0x0d, (byte) 0xb8,\n+                (byte) 0x85, (byte) 0xa3, 0x00, 0x00, 0x00, 0x00, (byte) 0x8a, 0x2e,\n+                0x03, 0x70, 0x73, 0x34}, sourceAddr);\n+\n+        // destination address\n+        byte[] destAddr = ByteBufUtil.getBytes(byteBuf, 32, 16);\n+        assertArrayEquals(new byte[] { (byte) 0x10, (byte) 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+                0x00, 0x05, 0x06, 0x00, 0x30, 0x0c, 0x32, 0x6b}, destAddr);\n+\n+        // source port\n+        int sourcePort = byteBuf.getUnsignedShort(48);\n+        assertEquals(56324, sourcePort);\n+\n+        // destination port\n+        int destPort = byteBuf.getUnsignedShort(50);\n+        assertEquals(443, destPort);\n+    }\n+\n+    @Test\n+    public void testUnixEncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.UNIX_STREAM,\n+                \"/var/run/src.sock\", \"/var/run/dst.sock\", 0, 0);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x03, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(216, sourceAddrLength);\n+\n+        // source address\n+        int srcAddrEnd = byteBuf.forEachByte(16, 108, ByteProcessor.FIND_NUL);\n+        assertEquals(\"/var/run/src.sock\",\n+                     byteBuf.slice(16, srcAddrEnd - 16).toString(CharsetUtil.US_ASCII));\n+\n+        // destination address\n+        int dstAddrEnd = byteBuf.forEachByte(124, 108, ByteProcessor.FIND_NUL);\n+        assertEquals(\"/var/run/dst.sock\",\n+                     byteBuf.slice(124, dstAddrEnd - 124).toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testTLVEncodeProxy() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        List<HAProxyTLV> tlvs = new ArrayList<HAProxyTLV>();\n+\n+        ByteBuf helloWorld = Unpooled.copiedBuffer(\"hello world\", CharsetUtil.US_ASCII);\n+        HAProxyTLV alpnTlv = new HAProxyTLV(Type.PP2_TYPE_ALPN, (byte) 0x01, helloWorld.copy());\n+        tlvs.add(alpnTlv);\n+\n+        ByteBuf arbitrary = Unpooled.copiedBuffer(\"an arbitrary string\", CharsetUtil.US_ASCII);\n+        HAProxyTLV authorityTlv = new HAProxyTLV(Type.PP2_TYPE_AUTHORITY, (byte) 0x01, arbitrary.copy());\n+        tlvs.add(authorityTlv);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443, tlvs);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // length\n+        assertEquals(byteBuf.getUnsignedShort(14), byteBuf.readableBytes() - V2_HEADER_BYTES_LENGTH);\n+\n+        // skip to tlv section\n+        ByteBuf tlv = byteBuf.skipBytes(V2_HEADER_BYTES_LENGTH + IPv4_ADDRESS_BYTES_LENGTH);\n+\n+        // alpn tlv\n+        assertEquals(alpnTlv.typeByteValue(), tlv.readByte());\n+        short bufLength = tlv.readShort();\n+        assertEquals(helloWorld.array().length, bufLength);\n+        assertEquals(helloWorld, tlv.readBytes(bufLength));\n+\n+        // authority tlv\n+        assertEquals(authorityTlv.typeByteValue(), tlv.readByte());\n+        bufLength = tlv.readShort();\n+        assertEquals(arbitrary.array().length, bufLength);\n+        assertEquals(arbitrary, tlv.readBytes(bufLength));", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MzI1OQ==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405563259", "bodyText": "call byteBuf.release() and also add assertFalse(ch.finish());", "author": "normanmaurer", "createdAt": "2020-04-08T14:21:48Z", "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HaProxyMessageEncoderTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.haproxy.HAProxyTLV.Type;\n+import io.netty.util.ByteProcessor;\n+import io.netty.util.CharsetUtil;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+import static org.junit.Assert.*;\n+\n+public class HaProxyMessageEncoderTest {\n+\n+    private static final int V2_HEADER_BYTES_LENGTH = 16;\n+    private static final int IPv4_ADDRESS_BYTES_LENGTH = 12;\n+    private static final int IPv6_ADDRESS_BYTES_LENGTH = 36;\n+    private static final int UNIX_ADDRESS_BYTES_LENGTH = 216;\n+\n+    @Test\n+    public void testIPV4EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP4 192.168.0.1 192.168.0.11 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPV6EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP6 2001:0db8:85a3:0000:0000:8a2e:0370:7334 1050:0:0:0:5:600:300c:326b 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPv4EncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x01, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(12, sourceAddrLength);\n+\n+        // source address\n+        byte[] sourceAddr = ByteBufUtil.getBytes(byteBuf, 16, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x01}, sourceAddr);\n+\n+        // destination address\n+        byte[] destAddr = ByteBufUtil.getBytes(byteBuf, 20, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x0b}, destAddr);\n+\n+        // source port\n+        int sourcePort = byteBuf.getUnsignedShort(24);\n+        assertEquals(56324, sourcePort);\n+\n+        // destination port\n+        int destPort = byteBuf.getUnsignedShort(26);\n+        assertEquals(443, destPort);\n+    }\n+\n+    @Test\n+    public void testIPv6EncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x02, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(IPv6_ADDRESS_BYTES_LENGTH, sourceAddrLength);\n+\n+        // source address\n+        byte[] sourceAddr = ByteBufUtil.getBytes(byteBuf, 16, 16);\n+        assertArrayEquals(new byte[] { (byte) 0x20, (byte) 0x01, 0x0d, (byte) 0xb8,\n+                (byte) 0x85, (byte) 0xa3, 0x00, 0x00, 0x00, 0x00, (byte) 0x8a, 0x2e,\n+                0x03, 0x70, 0x73, 0x34}, sourceAddr);\n+\n+        // destination address\n+        byte[] destAddr = ByteBufUtil.getBytes(byteBuf, 32, 16);\n+        assertArrayEquals(new byte[] { (byte) 0x10, (byte) 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+                0x00, 0x05, 0x06, 0x00, 0x30, 0x0c, 0x32, 0x6b}, destAddr);\n+\n+        // source port\n+        int sourcePort = byteBuf.getUnsignedShort(48);\n+        assertEquals(56324, sourcePort);\n+\n+        // destination port\n+        int destPort = byteBuf.getUnsignedShort(50);\n+        assertEquals(443, destPort);\n+    }\n+\n+    @Test\n+    public void testUnixEncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.UNIX_STREAM,\n+                \"/var/run/src.sock\", \"/var/run/dst.sock\", 0, 0);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x03, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(216, sourceAddrLength);\n+\n+        // source address\n+        int srcAddrEnd = byteBuf.forEachByte(16, 108, ByteProcessor.FIND_NUL);\n+        assertEquals(\"/var/run/src.sock\",\n+                     byteBuf.slice(16, srcAddrEnd - 16).toString(CharsetUtil.US_ASCII));\n+\n+        // destination address\n+        int dstAddrEnd = byteBuf.forEachByte(124, 108, ByteProcessor.FIND_NUL);\n+        assertEquals(\"/var/run/dst.sock\",\n+                     byteBuf.slice(124, dstAddrEnd - 124).toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testTLVEncodeProxy() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        List<HAProxyTLV> tlvs = new ArrayList<HAProxyTLV>();\n+\n+        ByteBuf helloWorld = Unpooled.copiedBuffer(\"hello world\", CharsetUtil.US_ASCII);\n+        HAProxyTLV alpnTlv = new HAProxyTLV(Type.PP2_TYPE_ALPN, (byte) 0x01, helloWorld.copy());\n+        tlvs.add(alpnTlv);\n+\n+        ByteBuf arbitrary = Unpooled.copiedBuffer(\"an arbitrary string\", CharsetUtil.US_ASCII);\n+        HAProxyTLV authorityTlv = new HAProxyTLV(Type.PP2_TYPE_AUTHORITY, (byte) 0x01, arbitrary.copy());\n+        tlvs.add(authorityTlv);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443, tlvs);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // length\n+        assertEquals(byteBuf.getUnsignedShort(14), byteBuf.readableBytes() - V2_HEADER_BYTES_LENGTH);\n+\n+        // skip to tlv section\n+        ByteBuf tlv = byteBuf.skipBytes(V2_HEADER_BYTES_LENGTH + IPv4_ADDRESS_BYTES_LENGTH);\n+\n+        // alpn tlv\n+        assertEquals(alpnTlv.typeByteValue(), tlv.readByte());\n+        short bufLength = tlv.readShort();\n+        assertEquals(helloWorld.array().length, bufLength);\n+        assertEquals(helloWorld, tlv.readBytes(bufLength));\n+\n+        // authority tlv\n+        assertEquals(authorityTlv.typeByteValue(), tlv.readByte());\n+        bufLength = tlv.readShort();\n+        assertEquals(arbitrary.array().length, bufLength);\n+        assertEquals(arbitrary, tlv.readBytes(bufLength));\n+    }\n+\n+    @Test\n+    public void testSslTLVEncodeProxy() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        List<HAProxyTLV> tlvs = new ArrayList<HAProxyTLV>();\n+\n+        ByteBuf helloWorld = Unpooled.copiedBuffer(\"hello world\", CharsetUtil.US_ASCII);\n+        HAProxyTLV alpnTlv = new HAProxyTLV(Type.PP2_TYPE_ALPN, (byte) 0x01, helloWorld.copy());\n+        tlvs.add(alpnTlv);\n+\n+        ByteBuf arbitrary = Unpooled.copiedBuffer(\"an arbitrary string\", CharsetUtil.US_ASCII);\n+        HAProxyTLV authorityTlv = new HAProxyTLV(Type.PP2_TYPE_AUTHORITY, (byte) 0x01, arbitrary.copy());\n+        tlvs.add(authorityTlv);\n+\n+        ByteBuf sslContent = Unpooled.copiedBuffer(\"some ssl content\", CharsetUtil.US_ASCII);\n+        HAProxySSLTLV haProxySSLTLV = new HAProxySSLTLV(1, (byte) 0x01, tlvs, sslContent.copy());\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443,\n+                Collections.<HAProxyTLV>singletonList(haProxySSLTLV));\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(byteBuf.getUnsignedShort(14), byteBuf.readableBytes() - V2_HEADER_BYTES_LENGTH);\n+        ByteBuf tlv = byteBuf.skipBytes(V2_HEADER_BYTES_LENGTH + IPv4_ADDRESS_BYTES_LENGTH);\n+\n+        // ssl tlv type\n+        assertEquals(haProxySSLTLV.typeByteValue(), tlv.readByte());\n+\n+        // length\n+        int bufLength = tlv.readUnsignedShort();\n+        assertEquals(bufLength, tlv.readableBytes());\n+\n+        // client, verify\n+        assertEquals(0x01, byteBuf.readByte());\n+        assertEquals(1, byteBuf.readInt());\n+\n+        // alpn tlv\n+        assertEquals(alpnTlv.typeByteValue(), tlv.readByte());\n+        bufLength = tlv.readShort();\n+        assertEquals(helloWorld.array().length, bufLength);\n+        assertEquals(helloWorld, tlv.readBytes(bufLength));\n+\n+        // authority tlv\n+        assertEquals(authorityTlv.typeByteValue(), tlv.readByte());\n+        bufLength = tlv.readShort();\n+        assertEquals(arbitrary.array().length, bufLength);\n+        assertEquals(arbitrary, tlv.readBytes(bufLength));", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTU2MzM0OA==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405563348", "bodyText": "call byteBuf.release() and also add assertFalse(ch.finish());", "author": "normanmaurer", "createdAt": "2020-04-08T14:21:57Z", "path": "codec-haproxy/src/test/java/io/netty/handler/codec/haproxy/HaProxyMessageEncoderTest.java", "diffHunk": "@@ -0,0 +1,384 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.buffer.Unpooled;\n+import io.netty.channel.embedded.EmbeddedChannel;\n+import io.netty.handler.codec.haproxy.HAProxyTLV.Type;\n+import io.netty.util.ByteProcessor;\n+import io.netty.util.CharsetUtil;\n+import org.junit.Test;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+import static org.junit.Assert.*;\n+\n+public class HaProxyMessageEncoderTest {\n+\n+    private static final int V2_HEADER_BYTES_LENGTH = 16;\n+    private static final int IPv4_ADDRESS_BYTES_LENGTH = 12;\n+    private static final int IPv6_ADDRESS_BYTES_LENGTH = 36;\n+    private static final int UNIX_ADDRESS_BYTES_LENGTH = 216;\n+\n+    @Test\n+    public void testIPV4EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP4 192.168.0.1 192.168.0.11 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPV6EncodeProxyV1() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(\"PROXY TCP6 2001:0db8:85a3:0000:0000:8a2e:0370:7334 1050:0:0:0:5:600:300c:326b 56324 443\\r\\n\",\n+                     byteBuf.toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testIPv4EncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x01, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(12, sourceAddrLength);\n+\n+        // source address\n+        byte[] sourceAddr = ByteBufUtil.getBytes(byteBuf, 16, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x01}, sourceAddr);\n+\n+        // destination address\n+        byte[] destAddr = ByteBufUtil.getBytes(byteBuf, 20, 4);\n+        assertArrayEquals(new byte[] { (byte) 0xc0, (byte) 0xa8, 0x00, 0x0b}, destAddr);\n+\n+        // source port\n+        int sourcePort = byteBuf.getUnsignedShort(24);\n+        assertEquals(56324, sourcePort);\n+\n+        // destination port\n+        int destPort = byteBuf.getUnsignedShort(26);\n+        assertEquals(443, destPort);\n+    }\n+\n+    @Test\n+    public void testIPv6EncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP6,\n+                \"2001:0db8:85a3:0000:0000:8a2e:0370:7334\", \"1050:0:0:0:5:600:300c:326b\", 56324, 443);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x02, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(IPv6_ADDRESS_BYTES_LENGTH, sourceAddrLength);\n+\n+        // source address\n+        byte[] sourceAddr = ByteBufUtil.getBytes(byteBuf, 16, 16);\n+        assertArrayEquals(new byte[] { (byte) 0x20, (byte) 0x01, 0x0d, (byte) 0xb8,\n+                (byte) 0x85, (byte) 0xa3, 0x00, 0x00, 0x00, 0x00, (byte) 0x8a, 0x2e,\n+                0x03, 0x70, 0x73, 0x34}, sourceAddr);\n+\n+        // destination address\n+        byte[] destAddr = ByteBufUtil.getBytes(byteBuf, 32, 16);\n+        assertArrayEquals(new byte[] { (byte) 0x10, (byte) 0x50, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+                0x00, 0x05, 0x06, 0x00, 0x30, 0x0c, 0x32, 0x6b}, destAddr);\n+\n+        // source port\n+        int sourcePort = byteBuf.getUnsignedShort(48);\n+        assertEquals(56324, sourcePort);\n+\n+        // destination port\n+        int destPort = byteBuf.getUnsignedShort(50);\n+        assertEquals(443, destPort);\n+    }\n+\n+    @Test\n+    public void testUnixEncodeProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.UNIX_STREAM,\n+                \"/var/run/src.sock\", \"/var/run/dst.sock\", 0, 0);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = ByteBufUtil.getBytes(byteBuf, 0, 12);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.getByte(12);\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x01, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.getByte(13);\n+        assertEquals(0x03, (transportByte & 0xf0) >> 4);\n+        assertEquals(0x01, transportByte & 0x0f);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.getUnsignedShort(14);\n+        assertEquals(216, sourceAddrLength);\n+\n+        // source address\n+        int srcAddrEnd = byteBuf.forEachByte(16, 108, ByteProcessor.FIND_NUL);\n+        assertEquals(\"/var/run/src.sock\",\n+                     byteBuf.slice(16, srcAddrEnd - 16).toString(CharsetUtil.US_ASCII));\n+\n+        // destination address\n+        int dstAddrEnd = byteBuf.forEachByte(124, 108, ByteProcessor.FIND_NUL);\n+        assertEquals(\"/var/run/dst.sock\",\n+                     byteBuf.slice(124, dstAddrEnd - 124).toString(CharsetUtil.US_ASCII));\n+    }\n+\n+    @Test\n+    public void testTLVEncodeProxy() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        List<HAProxyTLV> tlvs = new ArrayList<HAProxyTLV>();\n+\n+        ByteBuf helloWorld = Unpooled.copiedBuffer(\"hello world\", CharsetUtil.US_ASCII);\n+        HAProxyTLV alpnTlv = new HAProxyTLV(Type.PP2_TYPE_ALPN, (byte) 0x01, helloWorld.copy());\n+        tlvs.add(alpnTlv);\n+\n+        ByteBuf arbitrary = Unpooled.copiedBuffer(\"an arbitrary string\", CharsetUtil.US_ASCII);\n+        HAProxyTLV authorityTlv = new HAProxyTLV(Type.PP2_TYPE_AUTHORITY, (byte) 0x01, arbitrary.copy());\n+        tlvs.add(authorityTlv);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443, tlvs);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // length\n+        assertEquals(byteBuf.getUnsignedShort(14), byteBuf.readableBytes() - V2_HEADER_BYTES_LENGTH);\n+\n+        // skip to tlv section\n+        ByteBuf tlv = byteBuf.skipBytes(V2_HEADER_BYTES_LENGTH + IPv4_ADDRESS_BYTES_LENGTH);\n+\n+        // alpn tlv\n+        assertEquals(alpnTlv.typeByteValue(), tlv.readByte());\n+        short bufLength = tlv.readShort();\n+        assertEquals(helloWorld.array().length, bufLength);\n+        assertEquals(helloWorld, tlv.readBytes(bufLength));\n+\n+        // authority tlv\n+        assertEquals(authorityTlv.typeByteValue(), tlv.readByte());\n+        bufLength = tlv.readShort();\n+        assertEquals(arbitrary.array().length, bufLength);\n+        assertEquals(arbitrary, tlv.readBytes(bufLength));\n+    }\n+\n+    @Test\n+    public void testSslTLVEncodeProxy() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        List<HAProxyTLV> tlvs = new ArrayList<HAProxyTLV>();\n+\n+        ByteBuf helloWorld = Unpooled.copiedBuffer(\"hello world\", CharsetUtil.US_ASCII);\n+        HAProxyTLV alpnTlv = new HAProxyTLV(Type.PP2_TYPE_ALPN, (byte) 0x01, helloWorld.copy());\n+        tlvs.add(alpnTlv);\n+\n+        ByteBuf arbitrary = Unpooled.copiedBuffer(\"an arbitrary string\", CharsetUtil.US_ASCII);\n+        HAProxyTLV authorityTlv = new HAProxyTLV(Type.PP2_TYPE_AUTHORITY, (byte) 0x01, arbitrary.copy());\n+        tlvs.add(authorityTlv);\n+\n+        ByteBuf sslContent = Unpooled.copiedBuffer(\"some ssl content\", CharsetUtil.US_ASCII);\n+        HAProxySSLTLV haProxySSLTLV = new HAProxySSLTLV(1, (byte) 0x01, tlvs, sslContent.copy());\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.PROXY, HAProxyProxiedProtocol.TCP4,\n+                \"192.168.0.1\", \"192.168.0.11\", 56324, 443,\n+                Collections.<HAProxyTLV>singletonList(haProxySSLTLV));\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        assertEquals(byteBuf.getUnsignedShort(14), byteBuf.readableBytes() - V2_HEADER_BYTES_LENGTH);\n+        ByteBuf tlv = byteBuf.skipBytes(V2_HEADER_BYTES_LENGTH + IPv4_ADDRESS_BYTES_LENGTH);\n+\n+        // ssl tlv type\n+        assertEquals(haProxySSLTLV.typeByteValue(), tlv.readByte());\n+\n+        // length\n+        int bufLength = tlv.readUnsignedShort();\n+        assertEquals(bufLength, tlv.readableBytes());\n+\n+        // client, verify\n+        assertEquals(0x01, byteBuf.readByte());\n+        assertEquals(1, byteBuf.readInt());\n+\n+        // alpn tlv\n+        assertEquals(alpnTlv.typeByteValue(), tlv.readByte());\n+        bufLength = tlv.readShort();\n+        assertEquals(helloWorld.array().length, bufLength);\n+        assertEquals(helloWorld, tlv.readBytes(bufLength));\n+\n+        // authority tlv\n+        assertEquals(authorityTlv.typeByteValue(), tlv.readByte());\n+        bufLength = tlv.readShort();\n+        assertEquals(arbitrary.array().length, bufLength);\n+        assertEquals(arbitrary, tlv.readBytes(bufLength));\n+    }\n+\n+    @Test\n+    public void testEncodeLocalProxyV2() {\n+        HAProxyMessageEncoder encoder = new HAProxyMessageEncoder();\n+        EmbeddedChannel ch = new EmbeddedChannel(encoder);\n+\n+        HAProxyMessage message = new HAProxyMessage(\n+                HAProxyProtocolVersion.V2, HAProxyCommand.LOCAL, HAProxyProxiedProtocol.UNKNOWN,\n+                null, null, 0, 0);\n+        assertTrue(ch.writeOutbound(message));\n+\n+        ByteBuf byteBuf = ch.readOutbound();\n+\n+        // header\n+        byte[] headerBytes = new byte[12];\n+        byteBuf.readBytes(headerBytes);\n+        assertArrayEquals(BINARY_PREFIX, headerBytes);\n+\n+        // command\n+        byte commandByte = byteBuf.readByte();\n+        assertEquals(0x02, (commandByte & 0xf0) >> 4);\n+        assertEquals(0x00, commandByte & 0x0f);\n+\n+        // transport protocol, address family\n+        byte transportByte = byteBuf.readByte();\n+        assertEquals(0x00, transportByte);\n+\n+        // source address length\n+        int sourceAddrLength = byteBuf.readUnsignedShort();\n+        assertEquals(0, sourceAddrLength);\n+\n+        assertFalse(byteBuf.isReadable());", "originalCommit": "790e71fa362d4d9b644f2cfcf3cb65f41e01f1b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b86a6c2e49c37b4872f075debddc06a9adcc4670", "url": "https://github.com/netty/netty/commit/b86a6c2e49c37b4872f075debddc06a9adcc4670", "message": "add missing javadocs, ensure tests are cleaned up, etc.", "committedDate": "2020-04-08T15:21:50Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0NzgxNw==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405747817", "bodyText": "I wonder why even need the StringBuilder at all. Cant you just directly write all of this to the ByteBuf step-by-step ?...", "author": "normanmaurer", "createdAt": "2020-04-08T19:02:13Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public final class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    // Length for source/destination addresses for the UNIX family must be 108 bytes each.\n+    static final int UNIX_ADDRESS_BYTES_LENGTH = 108;\n+    static final int TOTAL_UNIX_ADDRESS_BYTES_LENGTH = UNIX_ADDRESS_BYTES_LENGTH * 2;\n+\n+    public static final HAProxyMessageEncoder INSTANCE = new HAProxyMessageEncoder();\n+\n+    private HAProxyMessageEncoder() {\n+    }\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        final String protocol = msg.proxiedProtocol().name();\n+        StringBuilder sb = new StringBuilder(108)\n+                .append(\"PROXY \").append(protocol).append(' ')\n+                .append(msg.sourceAddress()).append(' ')\n+                .append(msg.destinationAddress()).append(' ')\n+                .append(msg.sourcePort()).append(' ').append(msg.destinationPort()).append(\"\\r\\n\");\n+        out.writeCharSequence(sb.toString(), CharsetUtil.US_ASCII);", "originalCommit": "b86a6c2e49c37b4872f075debddc06a9adcc4670", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0OTA0MQ==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405749041", "bodyText": "why you can't just use writeCharSequence(...) here ? It seems there is no need to convert to byte[] first. Same comment is true for other places.", "author": "normanmaurer", "createdAt": "2020-04-08T19:04:16Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public final class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    // Length for source/destination addresses for the UNIX family must be 108 bytes each.\n+    static final int UNIX_ADDRESS_BYTES_LENGTH = 108;\n+    static final int TOTAL_UNIX_ADDRESS_BYTES_LENGTH = UNIX_ADDRESS_BYTES_LENGTH * 2;\n+\n+    public static final HAProxyMessageEncoder INSTANCE = new HAProxyMessageEncoder();\n+\n+    private HAProxyMessageEncoder() {\n+    }\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        final String protocol = msg.proxiedProtocol().name();\n+        StringBuilder sb = new StringBuilder(108)\n+                .append(\"PROXY \").append(protocol).append(' ')\n+                .append(msg.sourceAddress()).append(' ')\n+                .append(msg.destinationAddress()).append(' ')\n+                .append(msg.sourcePort()).append(' ').append(msg.destinationPort()).append(\"\\r\\n\");\n+        out.writeCharSequence(sb.toString(), CharsetUtil.US_ASCII);\n+    }\n+\n+    private static void encodeV2(HAProxyMessage msg, ByteBuf out) {\n+        out.writeBytes(BINARY_PREFIX);\n+        out.writeByte(V2_VERSION_BITMASK | msg.command().byteValue());\n+        out.writeByte(msg.proxiedProtocol().byteValue());\n+\n+        switch (msg.proxiedProtocol().addressFamily()) {\n+            case AF_IPv4:\n+            case AF_IPv6:\n+                byte[] sourceAddress = NetUtil.createByteArrayFromIpAddressString(msg.sourceAddress());\n+                byte[] destinationAddress = NetUtil.createByteArrayFromIpAddressString(msg.destinationAddress());\n+                out.writeShort(sourceAddress.length + destinationAddress.length + 4 + msg.tlvNumBytes());\n+                out.writeBytes(sourceAddress);\n+                out.writeBytes(destinationAddress);\n+                out.writeShort(msg.sourcePort());\n+                out.writeShort(msg.destinationPort());\n+                encodeTlvs(msg.tlvs(), out);\n+                break;\n+            case AF_UNIX:\n+                out.writeShort(TOTAL_UNIX_ADDRESS_BYTES_LENGTH + msg.tlvNumBytes());\n+                byte[] srcAddressBytes = msg.sourceAddress().getBytes(CharsetUtil.US_ASCII);\n+                out.writeBytes(srcAddressBytes);\n+                out.writeBytes(new byte[UNIX_ADDRESS_BYTES_LENGTH - srcAddressBytes.length]);\n+                byte[] dstAddressBytes = msg.destinationAddress().getBytes(CharsetUtil.US_ASCII);\n+                out.writeBytes(dstAddressBytes);", "originalCommit": "b86a6c2e49c37b4872f075debddc06a9adcc4670", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIwNDk4NA==", "url": "https://github.com/netty/netty/pull/10175#discussion_r406204984", "bodyText": "I'm still looking for a more efficient way to do this.\nThe reason I can't just switch to writeCharSequence because I need to know the number of bytes to pad to length 108.\n\n  \n    \n      netty/codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java\n    \n    \n         Line 93\n      in\n      b86a6c2\n    \n    \n    \n    \n\n        \n          \n           out.writeBytes(new byte[UNIX_ADDRESS_BYTES_LENGTH - dstAddressBytes.length]); \n        \n    \n  \n\n\nAny ideas are welcome", "author": "jrhee17", "createdAt": "2020-04-09T13:30:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0OTA0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIyMzU0MQ==", "url": "https://github.com/netty/netty/pull/10175#discussion_r406223541", "bodyText": "writeCharSequence will return the number of bytes written. So You can use this, or I am missing something ?", "author": "normanmaurer", "createdAt": "2020-04-09T13:57:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0OTA0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIzMTUxMw==", "url": "https://github.com/netty/netty/pull/10175#discussion_r406231513", "bodyText": "yea...   I don't read javadocs carefully \ud83e\udd26", "author": "jrhee17", "createdAt": "2020-04-09T14:08:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0OTA0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc0OTI4Nw==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405749287", "bodyText": "also wouldn't it be better to use out.writeZero(...) ? There is no need for this extra allocation.", "author": "normanmaurer", "createdAt": "2020-04-08T19:04:43Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public final class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    // Length for source/destination addresses for the UNIX family must be 108 bytes each.\n+    static final int UNIX_ADDRESS_BYTES_LENGTH = 108;\n+    static final int TOTAL_UNIX_ADDRESS_BYTES_LENGTH = UNIX_ADDRESS_BYTES_LENGTH * 2;\n+\n+    public static final HAProxyMessageEncoder INSTANCE = new HAProxyMessageEncoder();\n+\n+    private HAProxyMessageEncoder() {\n+    }\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        final String protocol = msg.proxiedProtocol().name();\n+        StringBuilder sb = new StringBuilder(108)\n+                .append(\"PROXY \").append(protocol).append(' ')\n+                .append(msg.sourceAddress()).append(' ')\n+                .append(msg.destinationAddress()).append(' ')\n+                .append(msg.sourcePort()).append(' ').append(msg.destinationPort()).append(\"\\r\\n\");\n+        out.writeCharSequence(sb.toString(), CharsetUtil.US_ASCII);\n+    }\n+\n+    private static void encodeV2(HAProxyMessage msg, ByteBuf out) {\n+        out.writeBytes(BINARY_PREFIX);\n+        out.writeByte(V2_VERSION_BITMASK | msg.command().byteValue());\n+        out.writeByte(msg.proxiedProtocol().byteValue());\n+\n+        switch (msg.proxiedProtocol().addressFamily()) {\n+            case AF_IPv4:\n+            case AF_IPv6:\n+                byte[] sourceAddress = NetUtil.createByteArrayFromIpAddressString(msg.sourceAddress());\n+                byte[] destinationAddress = NetUtil.createByteArrayFromIpAddressString(msg.destinationAddress());\n+                out.writeShort(sourceAddress.length + destinationAddress.length + 4 + msg.tlvNumBytes());\n+                out.writeBytes(sourceAddress);\n+                out.writeBytes(destinationAddress);\n+                out.writeShort(msg.sourcePort());\n+                out.writeShort(msg.destinationPort());\n+                encodeTlvs(msg.tlvs(), out);\n+                break;\n+            case AF_UNIX:\n+                out.writeShort(TOTAL_UNIX_ADDRESS_BYTES_LENGTH + msg.tlvNumBytes());\n+                byte[] srcAddressBytes = msg.sourceAddress().getBytes(CharsetUtil.US_ASCII);\n+                out.writeBytes(srcAddressBytes);\n+                out.writeBytes(new byte[UNIX_ADDRESS_BYTES_LENGTH - srcAddressBytes.length]);\n+                byte[] dstAddressBytes = msg.destinationAddress().getBytes(CharsetUtil.US_ASCII);\n+                out.writeBytes(dstAddressBytes);\n+                out.writeBytes(new byte[UNIX_ADDRESS_BYTES_LENGTH - dstAddressBytes.length]);", "originalCommit": "b86a6c2e49c37b4872f075debddc06a9adcc4670", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc1MDI0Nw==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405750247", "bodyText": "consider using SimpleChannelInboundHandler and just consume the message in channelRead0. This way it is correctly released without hitting the tail of the pipeline", "author": "normanmaurer", "createdAt": "2020-04-08T19:06:36Z", "path": "example/src/main/java/io/netty/example/haproxy/HAProxyServer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.example.haproxy;\n+\n+import io.netty.bootstrap.ServerBootstrap;\n+import io.netty.buffer.ByteBuf;\n+import io.netty.buffer.ByteBufUtil;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelInboundHandlerAdapter;\n+import io.netty.channel.ChannelInitializer;\n+import io.netty.channel.EventLoopGroup;\n+import io.netty.channel.nio.NioEventLoopGroup;\n+import io.netty.channel.socket.SocketChannel;\n+import io.netty.channel.socket.nio.NioServerSocketChannel;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageDecoder;\n+import io.netty.handler.logging.LogLevel;\n+import io.netty.handler.logging.LoggingHandler;\n+\n+public final class HAProxyServer {\n+\n+    static final int PORT = Integer.parseInt(System.getProperty(\"port\", \"8080\"));\n+\n+    public static void main(String[] args) throws Exception {\n+        EventLoopGroup bossGroup = new NioEventLoopGroup(1);\n+        EventLoopGroup workerGroup = new NioEventLoopGroup();\n+        try {\n+            ServerBootstrap b = new ServerBootstrap();\n+            b.group(bossGroup, workerGroup)\n+             .channel(NioServerSocketChannel.class)\n+             .handler(new LoggingHandler(LogLevel.INFO))\n+             .childHandler(new HAProxyServerInitializer());\n+            b.bind(PORT).sync().channel().closeFuture().sync();\n+        } finally {\n+            bossGroup.shutdownGracefully();\n+            workerGroup.shutdownGracefully();\n+        }\n+    }\n+\n+    static class HAProxyServerInitializer extends ChannelInitializer<SocketChannel> {\n+        @Override\n+        public void initChannel(SocketChannel ch) throws Exception {\n+            ch.pipeline().addLast(\n+                    new LoggingHandler(LogLevel.DEBUG),\n+                    new HAProxyMessageDecoder(),\n+                    new ChannelInboundHandlerAdapter() {", "originalCommit": "b86a6c2e49c37b4872f075debddc06a9adcc4670", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc1MDYyNg==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405750626", "bodyText": "imho it should just be write(...)....", "author": "normanmaurer", "createdAt": "2020-04-08T19:07:21Z", "path": "example/src/main/java/io/netty/example/haproxy/HAProxyHandler.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.example.haproxy;\n+\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProtocolException;\n+\n+public class HAProxyHandler extends ChannelOutboundHandlerAdapter {\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        ctx.pipeline().addBefore(ctx.name(), null, HAProxyMessageEncoder.INSTANCE);\n+        super.handlerAdded(ctx);\n+    }\n+\n+    @Override\n+    public void write(final ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        if (!(msg instanceof HAProxyMessage)) {\n+            super.write(ctx, msg, promise);\n+            return;\n+        }\n+\n+        ctx.writeAndFlush(msg, promise).addListener(new ChannelFutureListener() {", "originalCommit": "b86a6c2e49c37b4872f075debddc06a9adcc4670", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTc1MDgzNg==", "url": "https://github.com/netty/netty/pull/10175#discussion_r405750836", "bodyText": "this throw makes no sense as it will be not propagated at all.", "author": "normanmaurer", "createdAt": "2020-04-08T19:07:45Z", "path": "example/src/main/java/io/netty/example/haproxy/HAProxyHandler.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.example.haproxy;\n+\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProtocolException;\n+\n+public class HAProxyHandler extends ChannelOutboundHandlerAdapter {\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        ctx.pipeline().addBefore(ctx.name(), null, HAProxyMessageEncoder.INSTANCE);\n+        super.handlerAdded(ctx);\n+    }\n+\n+    @Override\n+    public void write(final ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        if (!(msg instanceof HAProxyMessage)) {\n+            super.write(ctx, msg, promise);\n+            return;\n+        }\n+\n+        ctx.writeAndFlush(msg, promise).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) throws Exception {\n+                if (future.isSuccess()) {\n+                    ctx.pipeline().remove(HAProxyMessageEncoder.INSTANCE);\n+                    ctx.pipeline().remove(HAProxyHandler.this);\n+                } else {\n+                    throw new HAProxyProtocolException(\"failed to write HAProxy message\");", "originalCommit": "b86a6c2e49c37b4872f075debddc06a9adcc4670", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6c51b8179281ed3b6eef2f81d5f3cd7567a97643", "url": "https://github.com/netty/netty/commit/6c51b8179281ed3b6eef2f81d5f3cd7567a97643", "message": "prefer writeCharSequence, handle message/exception properly for test", "committedDate": "2020-04-09T13:00:00Z", "type": "commit"}, {"oid": "42440498ffe755701aa883009d6916f6ee01dc97", "url": "https://github.com/netty/netty/commit/42440498ffe755701aa883009d6916f6ee01dc97", "message": "prefer writeCharSequence for writing addresses", "committedDate": "2020-04-09T14:07:51Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIzMzIwNQ==", "url": "https://github.com/netty/netty/pull/10175#discussion_r406233205", "bodyText": "you would be better of to write bytes for the know things as this will be cheaper then doing a conversation:\nout.writeByte((byte) ' ');\n\nSame comment for others.", "author": "normanmaurer", "createdAt": "2020-04-09T14:11:17Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public final class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    // Length for source/destination addresses for the UNIX family must be 108 bytes each.\n+    static final int UNIX_ADDRESS_BYTES_LENGTH = 108;\n+    static final int TOTAL_UNIX_ADDRESS_BYTES_LENGTH = UNIX_ADDRESS_BYTES_LENGTH * 2;\n+\n+    public static final HAProxyMessageEncoder INSTANCE = new HAProxyMessageEncoder();\n+\n+    private HAProxyMessageEncoder() {\n+    }\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        out.writeCharSequence(\"PROXY \", CharsetUtil.US_ASCII);\n+        out.writeCharSequence(msg.proxiedProtocol().name(), CharsetUtil.US_ASCII);\n+        out.writeCharSequence(\" \", CharsetUtil.US_ASCII);", "originalCommit": "42440498ffe755701aa883009d6916f6ee01dc97", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjIzMzkwNQ==", "url": "https://github.com/netty/netty/pull/10175#discussion_r406233905", "bodyText": "can you add a comment what the 4 is about ?", "author": "normanmaurer", "createdAt": "2020-04-09T14:12:15Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public final class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    // Length for source/destination addresses for the UNIX family must be 108 bytes each.\n+    static final int UNIX_ADDRESS_BYTES_LENGTH = 108;\n+    static final int TOTAL_UNIX_ADDRESS_BYTES_LENGTH = UNIX_ADDRESS_BYTES_LENGTH * 2;\n+\n+    public static final HAProxyMessageEncoder INSTANCE = new HAProxyMessageEncoder();\n+\n+    private HAProxyMessageEncoder() {\n+    }\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {\n+            encodeV1(msg, out);\n+        } else if (msg.protocolVersion() == HAProxyProtocolVersion.V2) {\n+            encodeV2(msg, out);\n+        } else {\n+            throw new HAProxyProtocolException(\"Unsupported version: \" + msg.protocolVersion());\n+        }\n+    }\n+\n+    private static void encodeV1(HAProxyMessage msg, ByteBuf out) {\n+        out.writeCharSequence(\"PROXY \", CharsetUtil.US_ASCII);\n+        out.writeCharSequence(msg.proxiedProtocol().name(), CharsetUtil.US_ASCII);\n+        out.writeCharSequence(\" \", CharsetUtil.US_ASCII);\n+        out.writeCharSequence(msg.sourceAddress(), CharsetUtil.US_ASCII);\n+        out.writeCharSequence(\" \", CharsetUtil.US_ASCII);\n+        out.writeCharSequence(msg.destinationAddress(), CharsetUtil.US_ASCII);\n+        out.writeCharSequence(\" \", CharsetUtil.US_ASCII);\n+        out.writeCharSequence(String.valueOf(msg.sourcePort()), CharsetUtil.US_ASCII);\n+        out.writeCharSequence(\" \", CharsetUtil.US_ASCII);\n+        out.writeCharSequence(String.valueOf(msg.destinationPort()), CharsetUtil.US_ASCII);\n+        out.writeCharSequence(\"\\r\\n\", CharsetUtil.US_ASCII);\n+    }\n+\n+    private static void encodeV2(HAProxyMessage msg, ByteBuf out) {\n+        out.writeBytes(BINARY_PREFIX);\n+        out.writeByte(V2_VERSION_BITMASK | msg.command().byteValue());\n+        out.writeByte(msg.proxiedProtocol().byteValue());\n+\n+        switch (msg.proxiedProtocol().addressFamily()) {\n+            case AF_IPv4:\n+            case AF_IPv6:\n+                byte[] sourceAddress = NetUtil.createByteArrayFromIpAddressString(msg.sourceAddress());\n+                byte[] destinationAddress = NetUtil.createByteArrayFromIpAddressString(msg.destinationAddress());\n+                out.writeShort(sourceAddress.length + destinationAddress.length + 4 + msg.tlvNumBytes());", "originalCommit": "42440498ffe755701aa883009d6916f6ee01dc97", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2699088dbba8bd30bb907056f70feaec0f064b31", "url": "https://github.com/netty/netty/commit/2699088dbba8bd30bb907056f70feaec0f064b31", "message": "add comment for port length, prefer bytes for known constants", "committedDate": "2020-04-09T14:17:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3NDU0Mw==", "url": "https://github.com/netty/netty/pull/10175#discussion_r407974543", "bodyText": "nit: not really your PRs fault but either the if statement is incorrect or the exception message in terms of allowed port range.", "author": "normanmaurer", "createdAt": "2020-04-14T08:55:59Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java", "diffHunk": "@@ -415,28 +441,41 @@ private static void checkAddress(String address, AddressFamily addrFamily) {\n         switch (addrFamily) {\n             case AF_IPv4:\n                 if (!NetUtil.isValidIpV4Address(address)) {\n-                    throw new HAProxyProtocolException(\"invalid IPv4 address: \" + address);\n+                    throw new IllegalArgumentException(\"invalid IPv4 address: \" + address);\n                 }\n                 break;\n             case AF_IPv6:\n                 if (!NetUtil.isValidIpV6Address(address)) {\n-                    throw new HAProxyProtocolException(\"invalid IPv6 address: \" + address);\n+                    throw new IllegalArgumentException(\"invalid IPv6 address: \" + address);\n                 }\n                 break;\n             default:\n-                throw new Error();\n+                throw new IllegalArgumentException(\"unexpected addrFamily: \" + addrFamily);\n         }\n     }\n \n     /**\n-     * Validate a UDP/TCP port\n+     * Validate the port depending on the addrFamily.\n      *\n      * @param port                       the UDP/TCP port\n-     * @throws HAProxyProtocolException  if the port is out of range (0-65535 inclusive)\n+     * @throws IllegalArgumentException  if the port is out of range (0-65535 inclusive)\n      */\n-    private static void checkPort(int port) {\n-        if (port < 0 || port > 65535) {\n-            throw new HAProxyProtocolException(\"invalid port: \" + port + \" (expected: 1 ~ 65535)\");\n+    private static void checkPort(int port, AddressFamily addrFamily) {\n+        switch (addrFamily) {\n+        case AF_IPv6:\n+        case AF_IPv4:\n+            if (port < 0 || port > 65535) {\n+                throw new IllegalArgumentException(\"invalid port: \" + port + \" (expected: 1 ~ 65535)\");", "originalCommit": "2699088dbba8bd30bb907056f70feaec0f064b31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3NTEyNw==", "url": "https://github.com/netty/netty/pull/10175#discussion_r407975127", "bodyText": "nit: you could move the for loop into this block as there is no need to do the loop when its empty anyway", "author": "normanmaurer", "createdAt": "2020-04-14T08:56:53Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java", "diffHunk": "@@ -556,4 +603,26 @@ protected void deallocate() {\n             }\n         }\n     }\n+\n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder(256)\n+                .append(StringUtil.simpleClassName(this))\n+                .append(\"(protocolVersion: \").append(protocolVersion)\n+                .append(\", command: \").append(command)\n+                .append(\", proxiedProtocol: \").append(proxiedProtocol)\n+                .append(\", sourceAddress: \").append(sourceAddress)\n+                .append(\", destinationAddress: \").append(destinationAddress)\n+                .append(\", sourcePort: \").append(sourcePort)\n+                .append(\", destinationPort: \").append(destinationPort)\n+                .append(\", tlvs: [\");\n+        for (HAProxyTLV tlv: tlvs) {\n+            sb.append(tlv).append(\", \");\n+        }\n+        if (!tlvs.isEmpty()) {", "originalCommit": "2699088dbba8bd30bb907056f70feaec0f064b31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3NTYyNQ==", "url": "https://github.com/netty/netty/pull/10175#discussion_r407975625", "bodyText": "nit: consider replacing by a switch statement.", "author": "normanmaurer", "createdAt": "2020-04-14T08:57:42Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessageEncoder.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.haproxy;\n+\n+import io.netty.buffer.ByteBuf;\n+import io.netty.channel.ChannelHandler.Sharable;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.handler.codec.MessageToByteEncoder;\n+import io.netty.util.CharsetUtil;\n+import io.netty.util.NetUtil;\n+\n+import java.util.List;\n+\n+import static io.netty.handler.codec.haproxy.HAProxyConstants.*;\n+\n+/**\n+ * Encodes an HAProxy proxy protocol message\n+ *\n+ * @see <a href=\"http://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\">Proxy Protocol Specification</a>\n+ */\n+@Sharable\n+public final class HAProxyMessageEncoder extends MessageToByteEncoder<HAProxyMessage> {\n+\n+    private static final int V2_VERSION_BITMASK = 0x02 << 4;\n+\n+    // Length for source/destination addresses for the UNIX family must be 108 bytes each.\n+    static final int UNIX_ADDRESS_BYTES_LENGTH = 108;\n+    static final int TOTAL_UNIX_ADDRESS_BYTES_LENGTH = UNIX_ADDRESS_BYTES_LENGTH * 2;\n+\n+    public static final HAProxyMessageEncoder INSTANCE = new HAProxyMessageEncoder();\n+\n+    private HAProxyMessageEncoder() {\n+    }\n+\n+    @Override\n+    protected void encode(ChannelHandlerContext ctx, HAProxyMessage msg, ByteBuf out) throws Exception {\n+        if (msg.protocolVersion() == HAProxyProtocolVersion.V1) {", "originalCommit": "2699088dbba8bd30bb907056f70feaec0f064b31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3ODI5NQ==", "url": "https://github.com/netty/netty/pull/10175#discussion_r407978295", "bodyText": "nit: remove final as we usually not it for params", "author": "normanmaurer", "createdAt": "2020-04-14T09:01:40Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyTLV.java", "diffHunk": "@@ -74,6 +87,52 @@ public static Type typeForByteValue(final byte byteValue) {\n                 return OTHER;\n             }\n         }\n+\n+        /**\n+         * Returns the byte value for the {@link Type} as defined in the PROXY protocol 1.5 spec.\n+         *\n+         * @param type the {@link Type}\n+         *\n+         * @return the byte value of the {@link Type}.\n+         */\n+        public static byte byteValueForType(Type type) {\n+            switch (type) {\n+            case PP2_TYPE_ALPN:\n+                return 0x01;\n+            case PP2_TYPE_AUTHORITY:\n+                return 0x02;\n+            case PP2_TYPE_SSL:\n+                return 0x20;\n+            case PP2_TYPE_SSL_VERSION:\n+                return 0x21;\n+            case PP2_TYPE_SSL_CN:\n+                return 0x22;\n+            case PP2_TYPE_NETNS:\n+                return 0x30;\n+            default:\n+                throw new IllegalArgumentException(\"unknown type: \" + type);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a new HAProxyTLV\n+     *\n+     * @param typeByteValue the byteValue of the TLV. This is especially important if non-standard TLVs are used\n+     * @param content the raw content of the TLV\n+     */\n+    public HAProxyTLV(final byte typeByteValue, final ByteBuf content) {", "originalCommit": "2699088dbba8bd30bb907056f70feaec0f064b31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3ODM4MA==", "url": "https://github.com/netty/netty/pull/10175#discussion_r407978380", "bodyText": "nit: remove final as we usually not it for params", "author": "normanmaurer", "createdAt": "2020-04-14T09:01:46Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyTLV.java", "diffHunk": "@@ -74,6 +87,52 @@ public static Type typeForByteValue(final byte byteValue) {\n                 return OTHER;\n             }\n         }\n+\n+        /**\n+         * Returns the byte value for the {@link Type} as defined in the PROXY protocol 1.5 spec.\n+         *\n+         * @param type the {@link Type}\n+         *\n+         * @return the byte value of the {@link Type}.\n+         */\n+        public static byte byteValueForType(Type type) {\n+            switch (type) {\n+            case PP2_TYPE_ALPN:\n+                return 0x01;\n+            case PP2_TYPE_AUTHORITY:\n+                return 0x02;\n+            case PP2_TYPE_SSL:\n+                return 0x20;\n+            case PP2_TYPE_SSL_VERSION:\n+                return 0x21;\n+            case PP2_TYPE_SSL_CN:\n+                return 0x22;\n+            case PP2_TYPE_NETNS:\n+                return 0x30;\n+            default:\n+                throw new IllegalArgumentException(\"unknown type: \" + type);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a new HAProxyTLV\n+     *\n+     * @param typeByteValue the byteValue of the TLV. This is especially important if non-standard TLVs are used\n+     * @param content the raw content of the TLV\n+     */\n+    public HAProxyTLV(final byte typeByteValue, final ByteBuf content) {\n+        this(Type.typeForByteValue(typeByteValue), typeByteValue, content);\n+    }\n+\n+    /**\n+     * Creates a new HAProxyTLV\n+     *\n+     * @param type the {@link Type} of the TLV\n+     * @param content the raw content of the TLV\n+     */\n+    public HAProxyTLV(Type type, final ByteBuf content) {", "originalCommit": "2699088dbba8bd30bb907056f70feaec0f064b31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk3OTcyOA==", "url": "https://github.com/netty/netty/pull/10175#discussion_r407979728", "bodyText": "nit you could also simplify this as:\npublic void write(final ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n    ChannelFuture future = ctx.write(msg, promise);\n    if (msg instanceof HAProxyMessage) {\n        future.addListener(...)\n    }\n}", "author": "normanmaurer", "createdAt": "2020-04-14T09:03:58Z", "path": "example/src/main/java/io/netty/example/haproxy/HAProxyHandler.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.example.haproxy;\n+\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProtocolException;\n+\n+public class HAProxyHandler extends ChannelOutboundHandlerAdapter {\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        ctx.pipeline().addBefore(ctx.name(), null, HAProxyMessageEncoder.INSTANCE);\n+        super.handlerAdded(ctx);\n+    }\n+\n+    @Override\n+    public void write(final ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        if (!(msg instanceof HAProxyMessage)) {\n+            super.write(ctx, msg, promise);\n+            return;\n+        }\n+\n+        ctx.write(msg, promise).addListener(new ChannelFutureListener() {", "originalCommit": "2699088dbba8bd30bb907056f70feaec0f064b31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzk4MDY1NA==", "url": "https://github.com/netty/netty/pull/10175#discussion_r407980654", "bodyText": "I would remove this... the user will know that it failed because we fail the promise", "author": "normanmaurer", "createdAt": "2020-04-14T09:05:31Z", "path": "example/src/main/java/io/netty/example/haproxy/HAProxyHandler.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.example.haproxy;\n+\n+import io.netty.channel.ChannelFuture;\n+import io.netty.channel.ChannelFutureListener;\n+import io.netty.channel.ChannelHandlerContext;\n+import io.netty.channel.ChannelOutboundHandlerAdapter;\n+import io.netty.channel.ChannelPromise;\n+import io.netty.handler.codec.haproxy.HAProxyMessage;\n+import io.netty.handler.codec.haproxy.HAProxyMessageEncoder;\n+import io.netty.handler.codec.haproxy.HAProxyProtocolException;\n+\n+public class HAProxyHandler extends ChannelOutboundHandlerAdapter {\n+\n+    @Override\n+    public void handlerAdded(ChannelHandlerContext ctx) throws Exception {\n+        ctx.pipeline().addBefore(ctx.name(), null, HAProxyMessageEncoder.INSTANCE);\n+        super.handlerAdded(ctx);\n+    }\n+\n+    @Override\n+    public void write(final ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {\n+        if (!(msg instanceof HAProxyMessage)) {\n+            super.write(ctx, msg, promise);\n+            return;\n+        }\n+\n+        ctx.write(msg, promise).addListener(new ChannelFutureListener() {\n+            @Override\n+            public void operationComplete(ChannelFuture future) throws Exception {\n+                if (future.isSuccess()) {\n+                    ctx.pipeline().remove(HAProxyMessageEncoder.INSTANCE);\n+                    ctx.pipeline().remove(HAProxyHandler.this);\n+                } else {\n+                    ctx.fireExceptionCaught(new HAProxyProtocolException(\"failed to write HAProxy message\",", "originalCommit": "2699088dbba8bd30bb907056f70feaec0f064b31", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9eab0e7e668cb1db1b396f88741c0b2076410bad", "url": "https://github.com/netty/netty/commit/9eab0e7e668cb1db1b396f88741c0b2076410bad", "message": "no final in public params, prefer switch case", "committedDate": "2020-04-14T13:17:05Z", "type": "forcePushed"}, {"oid": "7ae4b8236b5ab7d68d711a90562794436801e709", "url": "https://github.com/netty/netty/commit/7ae4b8236b5ab7d68d711a90562794436801e709", "message": "prefer no final in public params, prefer switch case", "committedDate": "2020-04-14T13:24:52Z", "type": "commit"}, {"oid": "7ae4b8236b5ab7d68d711a90562794436801e709", "url": "https://github.com/netty/netty/commit/7ae4b8236b5ab7d68d711a90562794436801e709", "message": "prefer no final in public params, prefer switch case", "committedDate": "2020-04-14T13:24:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2ODgyMg==", "url": "https://github.com/netty/netty/pull/10175#discussion_r408268822", "bodyText": "@jrhee17 one question... isn't TEXT_PREFIX a better name ?", "author": "normanmaurer", "createdAt": "2020-04-14T16:23:42Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyConstants.java", "diffHunk": "@@ -56,5 +56,31 @@\n     static final byte TPAF_UNIX_STREAM_BYTE = 0x31;\n     static final byte TPAF_UNIX_DGRAM_BYTE = 0x32;\n \n+    /**\n+     * V2 protocol binary header prefix\n+     */\n+    static final byte[] BINARY_PREFIX = {\n+            (byte) 0x0D,\n+            (byte) 0x0A,\n+            (byte) 0x0D,\n+            (byte) 0x0A,\n+            (byte) 0x00,\n+            (byte) 0x0D,\n+            (byte) 0x0A,\n+            (byte) 0x51,\n+            (byte) 0x55,\n+            (byte) 0x49,\n+            (byte) 0x54,\n+            (byte) 0x0A\n+    };\n+\n+    static final byte[] PROXY_PREFIX = {", "originalCommit": "7ae4b8236b5ab7d68d711a90562794436801e709", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI3MTAwMw==", "url": "https://github.com/netty/netty/pull/10175#discussion_r408271003", "bodyText": "huh... binary <-> text.     updated.", "author": "jrhee17", "createdAt": "2020-04-14T16:26:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI2ODgyMg=="}], "type": "inlineReview"}, {"oid": "fccf4bf86f90f5af1180155b43edb7ea4f0185d4", "url": "https://github.com/netty/netty/commit/fccf4bf86f90f5af1180155b43edb7ea4f0185d4", "message": "rename proxy prefix to test prefix", "committedDate": "2020-04-14T16:25:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk4MTI1Mg==", "url": "https://github.com/netty/netty/pull/10175#discussion_r408981252", "bodyText": "Should this catch RuntimeException?", "author": "carl-mastrangelo", "createdAt": "2020-04-15T16:38:42Z", "path": "codec-haproxy/src/main/java/io/netty/handler/codec/haproxy/HAProxyMessage.java", "diffHunk": "@@ -329,9 +347,13 @@ static HAProxyMessage decodeHeader(String header) {\n             throw new HAProxyProtocolException(\"invalid TCP4/6 header: \" + header + \" (expected: 6 parts)\");\n         }\n \n-        return new HAProxyMessage(\n-                HAProxyProtocolVersion.V1, HAProxyCommand.PROXY,\n-                protAndFam, parts[2], parts[3], parts[4], parts[5]);\n+        try {\n+            return new HAProxyMessage(\n+                    HAProxyProtocolVersion.V1, HAProxyCommand.PROXY,\n+                    protAndFam, parts[2], parts[3], parts[4], parts[5]);\n+        } catch (Exception e) {", "originalCommit": "fccf4bf86f90f5af1180155b43edb7ea4f0185d4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTAyNTE4Nw==", "url": "https://github.com/netty/netty/pull/10175#discussion_r409025187", "bodyText": "I think at least we should also catch IndexOutOfBoundsException", "author": "normanmaurer", "createdAt": "2020-04-15T17:50:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODk4MTI1Mg=="}], "type": "inlineReview"}, {"oid": "0d81140490986b8bab1dd816c1938bfe6be9e135", "url": "https://github.com/netty/netty/commit/0d81140490986b8bab1dd816c1938bfe6be9e135", "message": "catch runtime exception on message creation", "committedDate": "2020-04-15T22:42:17Z", "type": "commit"}]}