{"pr_number": 10483, "pr_title": "MQTT5 support for netty-codec-mqtt", "pr_createdAt": "2020-08-14T14:32:35Z", "pr_url": "https://github.com/netty/netty/pull/10483", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg0Mzk5Mg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r470843992", "bodyText": "I believe it should be 0x81, 0x82 etc \ud83d\ude00", "author": "kachayev", "createdAt": "2020-08-14T20:11:27Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectReturnCode.java", "diffHunk": "@@ -25,11 +25,34 @@\n  */\n public enum MqttConnectReturnCode {\n     CONNECTION_ACCEPTED((byte) 0x00),\n+    //MQTT 3 codes\n     CONNECTION_REFUSED_UNACCEPTABLE_PROTOCOL_VERSION((byte) 0X01),\n     CONNECTION_REFUSED_IDENTIFIER_REJECTED((byte) 0x02),\n     CONNECTION_REFUSED_SERVER_UNAVAILABLE((byte) 0x03),\n     CONNECTION_REFUSED_BAD_USER_NAME_OR_PASSWORD((byte) 0x04),\n-    CONNECTION_REFUSED_NOT_AUTHORIZED((byte) 0x05);\n+    CONNECTION_REFUSED_NOT_AUTHORIZED((byte) 0x05),\n+    //MQTT 5 codes\n+    CONNECTION_REFUSED_UNSPECIFIED_ERROR((byte) 0x80),\n+    CONNECTION_REFUSED_MALFORMED_PACKET((byte) 0x80),", "originalCommit": "675d0ee3ef75bb4c6a204cc7a7cfe7d2f172f596", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkzNzQ5MQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r470937491", "bodyText": "Nice catch. Fixed that.", "author": "paul-lysak", "createdAt": "2020-08-15T04:45:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDg0Mzk5Mg=="}], "type": "inlineReview"}, {"oid": "fc5dd1b3c9a8b35bd1b6c3945210d90c52fd985c", "url": "https://github.com/netty/netty/commit/fc5dd1b3c9a8b35bd1b6c3945210d90c52fd985c", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  updated examples in `netty-example`.\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-15T04:44:09Z", "type": "forcePushed"}, {"oid": "714d09e2c80834289418d19cb97e658fc4477401", "url": "https://github.com/netty/netty/commit/714d09e2c80834289418d19cb97e658fc4477401", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  updated examples in `netty-example`.\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-15T07:03:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjMyMg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471066322", "bodyText": "Did you check for API breakage?", "author": "hyperxpro", "createdAt": "2020-08-16T05:08:15Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java", "diffHunk": "@@ -43,22 +43,28 @@ static boolean isValidClientId(MqttVersion mqttVersion, String clientId) {\n             return clientId != null && clientId.length() >= MIN_CLIENT_ID_LENGTH &&\n                 clientId.length() <= MAX_CLIENT_ID_LENGTH;\n         }\n-        if (mqttVersion == MqttVersion.MQTT_3_1_1) {\n+        if (mqttVersion == MqttVersion.MQTT_3_1_1 || mqttVersion == MqttVersion.MQTT_5) {\n             // In 3.1.3.1 Client Identifier of MQTT 3.1.1 specification, The Server MAY allow ClientId\u2019s\n             // that contain more than 23 encoded bytes. And, The Server MAY allow zero-length ClientId.\n             return clientId != null;\n         }\n         throw new IllegalArgumentException(mqttVersion + \" is unknown mqtt version\");\n     }\n \n-    static MqttFixedHeader validateFixedHeader(MqttFixedHeader mqttFixedHeader) {\n+    static MqttFixedHeader validateFixedHeader(MqttFixedHeader mqttFixedHeader, MqttVersion mqttVersion) {", "originalCommit": "714d09e2c80834289418d19cb97e658fc4477401", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzMjYwMw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471232603", "bodyText": "This method has package visibility and not intended to be called by classes outside of MQTT coded. MqttDecoder.decodeFixedHeader is the only place where it's called. Therefore, changing the API shouldn't be an issue here.", "author": "paul-lysak", "createdAt": "2020-08-17T05:02:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjMyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI1OTg2OQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471259869", "bodyText": "AS @paul-lysak noted... this is fine", "author": "normanmaurer", "createdAt": "2020-08-17T06:39:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjMyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjQxOA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471066418", "bodyText": "Should be 2020", "author": "hyperxpro", "createdAt": "2020-08-16T05:09:17Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttMessageIdAndPropertiesVariableHeader.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2014 The Netty Project", "originalCommit": "714d09e2c80834289418d19cb97e658fc4477401", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzMjYzOQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471232639", "bodyText": "done", "author": "paul-lysak", "createdAt": "2020-08-17T05:02:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjQ2Nw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471066467", "bodyText": "Can be final", "author": "hyperxpro", "createdAt": "2020-08-16T05:10:00Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright 2014 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.mqtt;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+/**\n+ * MQTT Properties container\n+ * */\n+public class MqttProperties {", "originalCommit": "714d09e2c80834289418d19cb97e658fc4477401", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjQ3NQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471066475", "bodyText": "Should be 2020", "author": "hyperxpro", "createdAt": "2020-08-16T05:10:14Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPubReplyMessageVariableHeader.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2014 The Netty Project", "originalCommit": "714d09e2c80834289418d19cb97e658fc4477401", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjQ5OA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471066498", "bodyText": "Should be 2020", "author": "hyperxpro", "createdAt": "2020-08-16T05:10:26Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttReasonCodeAndPropertiesVariableHeader.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2014 The Netty Project", "originalCommit": "714d09e2c80834289418d19cb97e658fc4477401", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjU0MA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471066540", "bodyText": "Should be 2020", "author": "hyperxpro", "createdAt": "2020-08-16T05:10:40Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscriptionOption.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2014 The Netty Project", "originalCommit": "714d09e2c80834289418d19cb97e658fc4477401", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjU2MA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471066560", "bodyText": "Can be final.", "author": "hyperxpro", "createdAt": "2020-08-16T05:11:04Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscriptionOption.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2014 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.mqtt;\n+\n+/**\n+ * Model the SubscriptionOption used in Subscribe MQTT v5 packet\n+ */\n+public class MqttSubscriptionOption {", "originalCommit": "714d09e2c80834289418d19cb97e658fc4477401", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjYyMA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471066620", "bodyText": "Should be 2020", "author": "hyperxpro", "createdAt": "2020-08-16T05:11:39Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2014 The Netty Project", "originalCommit": "714d09e2c80834289418d19cb97e658fc4477401", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzMjcwNw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471232707", "bodyText": "done", "author": "paul-lysak", "createdAt": "2020-08-17T05:02:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjYyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjY1Mw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471066653", "bodyText": "Can be final.", "author": "hyperxpro", "createdAt": "2020-08-16T05:11:58Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2014 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.mqtt;\n+\n+import io.netty.util.internal.StringUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Payload for MQTT unsuback message as in V5.\n+ */\n+public class MqttUnsubAckPayload {", "originalCommit": "714d09e2c80834289418d19cb97e658fc4477401", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjY3OQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471066679", "bodyText": "Wildcard * not allowed. Use FQCN.", "author": "hyperxpro", "createdAt": "2020-08-16T05:12:29Z", "path": "example/src/main/java/io/netty/example/mqtt/heartBeat/MqttHeartBeatClientHandler.java", "diffHunk": "@@ -17,13 +17,7 @@\n \n import io.netty.channel.ChannelHandlerContext;\n import io.netty.channel.ChannelInboundHandlerAdapter;\n-import io.netty.handler.codec.mqtt.MqttConnectMessage;\n-import io.netty.handler.codec.mqtt.MqttConnectPayload;\n-import io.netty.handler.codec.mqtt.MqttConnectVariableHeader;\n-import io.netty.handler.codec.mqtt.MqttFixedHeader;\n-import io.netty.handler.codec.mqtt.MqttMessage;\n-import io.netty.handler.codec.mqtt.MqttMessageType;\n-import io.netty.handler.codec.mqtt.MqttQoS;\n+import io.netty.handler.codec.mqtt.*;", "originalCommit": "714d09e2c80834289418d19cb97e658fc4477401", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTIzMjc1MQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471232751", "bodyText": "done", "author": "paul-lysak", "createdAt": "2020-08-17T05:02:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTA2NjY3OQ=="}], "type": "inlineReview"}, {"oid": "70fd242a06c005a1143442b4c8e258baef94c2a9", "url": "https://github.com/netty/netty/commit/70fd242a06c005a1143442b4c8e258baef94c2a9", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  updated examples in `netty-example`.\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-17T04:59:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MDExMw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471260113", "bodyText": "So we only use this for the decoder and not the encoder right ? If we also use it for he Encoder we may want to use CodecException", "author": "normanmaurer", "createdAt": "2020-08-17T06:40:06Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java", "diffHunk": "@@ -43,22 +43,28 @@ static boolean isValidClientId(MqttVersion mqttVersion, String clientId) {\n             return clientId != null && clientId.length() >= MIN_CLIENT_ID_LENGTH &&\n                 clientId.length() <= MAX_CLIENT_ID_LENGTH;\n         }\n-        if (mqttVersion == MqttVersion.MQTT_3_1_1) {\n+        if (mqttVersion == MqttVersion.MQTT_3_1_1 || mqttVersion == MqttVersion.MQTT_5) {\n             // In 3.1.3.1 Client Identifier of MQTT 3.1.1 specification, The Server MAY allow ClientId\u2019s\n             // that contain more than 23 encoded bytes. And, The Server MAY allow zero-length ClientId.\n             return clientId != null;\n         }\n         throw new IllegalArgumentException(mqttVersion + \" is unknown mqtt version\");\n     }\n \n-    static MqttFixedHeader validateFixedHeader(MqttFixedHeader mqttFixedHeader) {\n+    static MqttFixedHeader validateFixedHeader(MqttFixedHeader mqttFixedHeader, MqttVersion mqttVersion) {\n         switch (mqttFixedHeader.messageType()) {\n             case PUBREL:\n             case SUBSCRIBE:\n             case UNSUBSCRIBE:\n                 if (mqttFixedHeader.qosLevel() != MqttQoS.AT_LEAST_ONCE) {\n                     throw new DecoderException(mqttFixedHeader.messageType().name() + \" message must have QoS 1\");\n                 }\n+                return mqttFixedHeader;\n+            case AUTH:\n+                if (mqttVersion != MqttVersion.MQTT_5) {\n+                    throw new DecoderException(\"AUTH message requires at least MQTT 5\");", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4MTEyOQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471981129", "bodyText": "Right, the only place where this method is used is MqttDecoder.decodeFixedHeader.", "author": "paul-lysak", "createdAt": "2020-08-18T07:44:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MDExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MDIyNA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471260224", "bodyText": "final", "author": "normanmaurer", "createdAt": "2020-08-17T06:40:25Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java", "diffHunk": "@@ -27,9 +27,17 @@\n \n     private final boolean sessionPresent;\n \n+    private MqttProperties properties;", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEwNDYxMQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472104611", "bodyText": "done", "author": "paul-lysak", "createdAt": "2020-08-18T11:23:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MDIyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MDI5Ng==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471260296", "bodyText": "final", "author": "normanmaurer", "createdAt": "2020-08-17T06:40:37Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java", "diffHunk": "@@ -27,13 +27,15 @@\n public final class MqttConnectPayload {\n \n     private final String clientIdentifier;\n+    private MqttProperties willProperties;", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MDM2Mw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471260363", "bodyText": "final", "author": "normanmaurer", "createdAt": "2020-08-17T06:40:49Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectVariableHeader.java", "diffHunk": "@@ -32,6 +32,7 @@\n     private final boolean isWillFlag;\n     private final boolean isCleanSession;\n     private final int keepAliveTimeSeconds;\n+    private MqttProperties properties;", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MDY1Ng==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471260656", "bodyText": "can you please explain why we need an AtomicReference here ?", "author": "normanmaurer", "createdAt": "2020-08-17T06:41:40Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -57,68 +59,90 @@\n     private Object variableHeader;\n     private int bytesRemainingInVariablePart;\n \n+    private AtomicReference<MqttVersion> mqttVersionRef;", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4MzY2Mg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471983662", "bodyText": "Encoder and decoder take protocol version from the CONNECT message and this message goes only through one of them -i.e. for the client it goes through Encoder, but not though Decoder. For the server - vice versa: it goes through Decoder, but not though Encoder. All subsequent messages should follow the protocol version as there are some subtle differences in MQTT 5 which require encoding/decoding in a different way to stay compatible.\nTherefore, there should be some way for Encoder and Decoder to share information about the MQTT version. AtomicReference seemed the simplest solution for that, without reinventing the wheel. Do you have better suggestions for that?", "author": "paul-lysak", "createdAt": "2020-08-18T07:49:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MDY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4NjAwMg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471986002", "bodyText": "I think a better way would be to use AttributeKey with Channel.attr(...)", "author": "normanmaurer", "createdAt": "2020-08-18T07:53:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MDY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEwNDk3OQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472104979", "bodyText": "Changed to use AttributeKey", "author": "paul-lysak", "createdAt": "2020-08-18T11:24:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI2MDY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk2OTcyMw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471969723", "bodyText": "It would be nice if you could revert the formatting changes to make this easier to review", "author": "normanmaurer", "createdAt": "2020-08-18T07:26:22Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -57,68 +59,90 @@\n     private Object variableHeader;\n     private int bytesRemainingInVariablePart;\n \n+    private AtomicReference<MqttVersion> mqttVersionRef;\n+\n+    private MqttVersion mqttVersion() {\n+        if (mqttVersionRef == null) {\n+            return MqttVersion.MQTT_3_1_1;\n+        } else {\n+            return mqttVersionRef.get();\n+        }\n+    }\n+\n     private final int maxBytesInMessage;\n \n     public MqttDecoder() {\n-      this(DEFAULT_MAX_BYTES_IN_MESSAGE);\n+        this(DEFAULT_MAX_BYTES_IN_MESSAGE);\n     }\n \n     public MqttDecoder(int maxBytesInMessage) {\n+        this(maxBytesInMessage, null);\n+    }\n+\n+    public MqttDecoder(AtomicReference<MqttVersion> mqttVersionRef) {\n+        this(DEFAULT_MAX_BYTES_IN_MESSAGE, mqttVersionRef);\n+    }\n+\n+    public MqttDecoder(int maxBytesInMessage, AtomicReference<MqttVersion> mqttVersionRef) {\n         super(DecoderState.READ_FIXED_HEADER);\n         this.maxBytesInMessage = maxBytesInMessage;\n+        this.mqttVersionRef = mqttVersionRef;\n     }\n \n     @Override\n     protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {\n         switch (state()) {\n-            case READ_FIXED_HEADER: try {", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEwNTM5MA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472105390", "bodyText": "done wherever possible", "author": "paul-lysak", "createdAt": "2020-08-18T11:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk2OTcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk2OTk4Mg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471969982", "bodyText": "Use TooLongFrameException", "author": "normanmaurer", "createdAt": "2020-08-18T07:26:47Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -57,68 +59,90 @@\n     private Object variableHeader;\n     private int bytesRemainingInVariablePart;\n \n+    private AtomicReference<MqttVersion> mqttVersionRef;\n+\n+    private MqttVersion mqttVersion() {\n+        if (mqttVersionRef == null) {\n+            return MqttVersion.MQTT_3_1_1;\n+        } else {\n+            return mqttVersionRef.get();\n+        }\n+    }\n+\n     private final int maxBytesInMessage;\n \n     public MqttDecoder() {\n-      this(DEFAULT_MAX_BYTES_IN_MESSAGE);\n+        this(DEFAULT_MAX_BYTES_IN_MESSAGE);\n     }\n \n     public MqttDecoder(int maxBytesInMessage) {\n+        this(maxBytesInMessage, null);\n+    }\n+\n+    public MqttDecoder(AtomicReference<MqttVersion> mqttVersionRef) {\n+        this(DEFAULT_MAX_BYTES_IN_MESSAGE, mqttVersionRef);\n+    }\n+\n+    public MqttDecoder(int maxBytesInMessage, AtomicReference<MqttVersion> mqttVersionRef) {\n         super(DecoderState.READ_FIXED_HEADER);\n         this.maxBytesInMessage = maxBytesInMessage;\n+        this.mqttVersionRef = mqttVersionRef;\n     }\n \n     @Override\n     protected void decode(ChannelHandlerContext ctx, ByteBuf buffer, List<Object> out) throws Exception {\n         switch (state()) {\n-            case READ_FIXED_HEADER: try {\n-                mqttFixedHeader = decodeFixedHeader(buffer);\n-                bytesRemainingInVariablePart = mqttFixedHeader.remainingLength();\n-                checkpoint(DecoderState.READ_VARIABLE_HEADER);\n-                // fall through\n-            } catch (Exception cause) {\n-                out.add(invalidMessage(cause));\n-                return;\n-            }\n+            case READ_FIXED_HEADER:\n+                try {\n+                    mqttFixedHeader = decodeFixedHeader(buffer);\n+                    bytesRemainingInVariablePart = mqttFixedHeader.remainingLength();\n+                    checkpoint(DecoderState.READ_VARIABLE_HEADER);\n+                    // fall through\n+                } catch (Exception cause) {\n+                    out.add(invalidMessage(cause));\n+                    return;\n+                }\n \n-            case READ_VARIABLE_HEADER:  try {\n-                final Result<?> decodedVariableHeader = decodeVariableHeader(buffer, mqttFixedHeader);\n-                variableHeader = decodedVariableHeader.value;\n-                if (bytesRemainingInVariablePart > maxBytesInMessage) {\n-                    throw new DecoderException(\"too large message: \" + bytesRemainingInVariablePart + \" bytes\");\n+            case READ_VARIABLE_HEADER:\n+                try {\n+                    final Result<?> decodedVariableHeader = decodeVariableHeader(buffer, mqttFixedHeader);\n+                    variableHeader = decodedVariableHeader.value;\n+                    if (bytesRemainingInVariablePart > maxBytesInMessage) {\n+                        throw new DecoderException(\"too large message: \" + bytesRemainingInVariablePart + \" bytes\");", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MjA2MQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471972061", "bodyText": "This will not work as MqttEncoder is marked as @Sharable and so may be shared between different Channel\ufffd instances.", "author": "normanmaurer", "createdAt": "2020-08-18T07:30:01Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -36,9 +39,24 @@\n @ChannelHandler.Sharable\n public final class MqttEncoder extends MessageToMessageEncoder<MqttMessage> {\n \n-    public static final MqttEncoder INSTANCE = new MqttEncoder();\n+    public static final MqttEncoder INSTANCE = new MqttEncoder(null);\n \n-    private MqttEncoder() { }\n+    private AtomicReference<MqttVersion> mqttVersionRef;", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEwNTcxOQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472105719", "bodyText": "Changed version handling approach, removed atomic references.", "author": "paul-lysak", "createdAt": "2020-08-18T11:25:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MjA2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MjQ2OA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471972468", "bodyText": "nit: you can merge the above two lines", "author": "normanmaurer", "createdAt": "2020-08-18T07:30:39Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -234,23 +276,35 @@ private static ByteBuf encodeSubscribeMessage(\n         // Variable Header\n         int messageId = variableHeader.messageId();\n         buf.writeShort(messageId);\n+        buf.writeBytes(propertiesBuf);\n \n         // Payload\n         for (MqttTopicSubscription topic : payload.topicSubscriptions()) {\n-            String topicName = topic.topicName();\n-            byte[] topicNameBytes = encodeStringUtf8(topicName);\n-            buf.writeShort(topicNameBytes.length);\n-            buf.writeBytes(topicNameBytes, 0, topicNameBytes.length);\n-            buf.writeByte(topic.qualityOfService().value());\n+            writeUTF8String(buf, topic.topicName());\n+            final MqttSubscriptionOption option = topic.option();\n+\n+            int optionEncoded = 0;\n+            optionEncoded |= option.retainHandling().value() << 4;", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzEwOA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471973108", "bodyText": "We can't do this as it would be API breakage", "author": "normanmaurer", "createdAt": "2020-08-18T07:31:41Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribeMessage.java", "diffHunk": "@@ -18,20 +18,27 @@\n \n /**\n  * See <a href=\"http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#unsubscribe\">\n- *     MQTTV3.1/unsubscribe</a>\n+ * MQTTV3.1/unsubscribe</a>\n  */\n public final class MqttUnsubscribeMessage extends MqttMessage {\n \n     public MqttUnsubscribeMessage(\n             MqttFixedHeader mqttFixedHeader,\n-            MqttMessageIdVariableHeader variableHeader,\n+            MqttMessageIdAndPropertiesVariableHeader variableHeader,\n             MqttUnsubscribePayload payload) {\n         super(mqttFixedHeader, variableHeader, payload);\n     }\n \n+    public MqttUnsubscribeMessage(\n+            MqttFixedHeader mqttFixedHeader,\n+            MqttMessageIdVariableHeader variableHeader,\n+            MqttUnsubscribePayload payload) {\n+        this(mqttFixedHeader, variableHeader.withEmptyProperties(), payload);\n+    }\n+\n     @Override\n-    public MqttMessageIdVariableHeader variableHeader() {\n-        return (MqttMessageIdVariableHeader) super.variableHeader();\n+    public MqttMessageIdAndPropertiesVariableHeader variableHeader() {", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzIxMw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471973213", "bodyText": "We can't do this as it would be API breakage", "author": "normanmaurer", "createdAt": "2020-08-18T07:31:49Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubscribeMessage.java", "diffHunk": "@@ -18,20 +18,27 @@\n \n /**\n  * See <a href=\"http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#unsubscribe\">\n- *     MQTTV3.1/unsubscribe</a>\n+ * MQTTV3.1/unsubscribe</a>\n  */\n public final class MqttUnsubscribeMessage extends MqttMessage {\n \n     public MqttUnsubscribeMessage(\n             MqttFixedHeader mqttFixedHeader,\n-            MqttMessageIdVariableHeader variableHeader,\n+            MqttMessageIdAndPropertiesVariableHeader variableHeader,", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzM0NQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471973345", "bodyText": "We can't do this as it would be API breakage", "author": "normanmaurer", "createdAt": "2020-08-18T07:32:02Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java", "diffHunk": "@@ -21,12 +21,35 @@\n  */\n public final class MqttUnsubAckMessage extends MqttMessage {\n \n-    public MqttUnsubAckMessage(MqttFixedHeader mqttFixedHeader, MqttMessageIdVariableHeader variableHeader) {\n-        super(mqttFixedHeader, variableHeader, null);\n+    public MqttUnsubAckMessage(MqttFixedHeader mqttFixedHeader,\n+                               MqttMessageIdAndPropertiesVariableHeader variableHeader,\n+                               MqttUnsubAckPayload payload) {\n+        super(mqttFixedHeader, variableHeader, payload);\n+    }\n+\n+    public MqttUnsubAckMessage(MqttFixedHeader mqttFixedHeader,\n+                               MqttMessageIdVariableHeader variableHeader,\n+                               MqttUnsubAckPayload payload) {\n+        this(mqttFixedHeader, fallbackVariableHeader(variableHeader), payload);\n+    }\n+\n+    private static MqttMessageIdAndPropertiesVariableHeader fallbackVariableHeader(\n+            MqttMessageIdVariableHeader variableHeader) {\n+        if (variableHeader instanceof MqttMessageIdAndPropertiesVariableHeader) {\n+            return (MqttMessageIdAndPropertiesVariableHeader) variableHeader;\n+        } else {\n+            return new MqttMessageIdAndPropertiesVariableHeader(variableHeader.messageId(),\n+                    MqttProperties.NO_PROPERTIES);\n+        }\n+    }\n+\n+    @Override\n+    public MqttMessageIdAndPropertiesVariableHeader variableHeader() {\n+        return (MqttMessageIdAndPropertiesVariableHeader) super.variableHeader();\n     }\n \n     @Override\n-    public MqttMessageIdVariableHeader variableHeader() {\n-        return (MqttMessageIdVariableHeader) super.variableHeader();\n+    public MqttUnsubAckPayload payload() {", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzQ0MA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471973440", "bodyText": "We can't do this as it would be API breakage", "author": "normanmaurer", "createdAt": "2020-08-18T07:32:11Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java", "diffHunk": "@@ -21,12 +21,35 @@\n  */\n public final class MqttUnsubAckMessage extends MqttMessage {\n \n-    public MqttUnsubAckMessage(MqttFixedHeader mqttFixedHeader, MqttMessageIdVariableHeader variableHeader) {", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzYxOA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471973618", "bodyText": "We can't do this as it would be API breakage", "author": "normanmaurer", "createdAt": "2020-08-18T07:32:25Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscribeMessage.java", "diffHunk": "@@ -18,20 +18,27 @@\n \n /**\n  * See <a href=\"http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#subscribe\">\n- *     MQTTV3.1/subscribe</a>\n+ * MQTTV3.1/subscribe</a>\n  */\n public final class MqttSubscribeMessage extends MqttMessage {\n \n     public MqttSubscribeMessage(\n             MqttFixedHeader mqttFixedHeader,\n-            MqttMessageIdVariableHeader variableHeader,\n+            MqttMessageIdAndPropertiesVariableHeader variableHeader,\n             MqttSubscribePayload payload) {\n         super(mqttFixedHeader, variableHeader, payload);\n     }\n \n+    public MqttSubscribeMessage(\n+            MqttFixedHeader mqttFixedHeader,\n+            MqttMessageIdVariableHeader variableHeader,\n+            MqttSubscribePayload payload) {\n+        this(mqttFixedHeader, variableHeader.withEmptyProperties(), payload);\n+    }\n+\n     @Override\n-    public MqttMessageIdVariableHeader variableHeader() {\n-        return (MqttMessageIdVariableHeader) super.variableHeader();\n+    public MqttMessageIdAndPropertiesVariableHeader variableHeader() {", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzY1MA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471973650", "bodyText": "We can't do this as it would be API breakage", "author": "normanmaurer", "createdAt": "2020-08-18T07:32:29Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscribeMessage.java", "diffHunk": "@@ -18,20 +18,27 @@\n \n /**\n  * See <a href=\"http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#subscribe\">\n- *     MQTTV3.1/subscribe</a>\n+ * MQTTV3.1/subscribe</a>\n  */\n public final class MqttSubscribeMessage extends MqttMessage {\n \n     public MqttSubscribeMessage(\n             MqttFixedHeader mqttFixedHeader,\n-            MqttMessageIdVariableHeader variableHeader,\n+            MqttMessageIdAndPropertiesVariableHeader variableHeader,", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzcwMw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471973703", "bodyText": "We can't do this as it would be API breakage", "author": "normanmaurer", "createdAt": "2020-08-18T07:32:33Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubAckMessage.java", "diffHunk": "@@ -23,14 +23,21 @@\n \n     public MqttSubAckMessage(\n             MqttFixedHeader mqttFixedHeader,\n-            MqttMessageIdVariableHeader variableHeader,\n+            MqttMessageIdAndPropertiesVariableHeader variableHeader,\n             MqttSubAckPayload payload) {\n         super(mqttFixedHeader, variableHeader, payload);\n     }\n \n+    public MqttSubAckMessage(\n+            MqttFixedHeader mqttFixedHeader,\n+            MqttMessageIdVariableHeader variableHeader,\n+            MqttSubAckPayload payload) {\n+        this(mqttFixedHeader, variableHeader.withEmptyProperties(), payload);\n+    }\n+\n     @Override\n-    public MqttMessageIdVariableHeader variableHeader() {\n-        return (MqttMessageIdVariableHeader) super.variableHeader();\n+    public MqttMessageIdAndPropertiesVariableHeader variableHeader() {", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4ODgzMQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471988831", "bodyText": "MqttMessageIdAndPropertiesVariableHeader is a subclass of MqttMessageIdVariableHeader - the value returned from variableHeader here will match the expectations of the users of the coded.", "author": "paul-lysak", "createdAt": "2020-08-18T07:57:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4OTU2NA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471989564", "bodyText": "Unfortunally this will still not work as it will break binary compat as far as I know", "author": "normanmaurer", "createdAt": "2020-08-18T07:59:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk5MDY5NA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471990694", "bodyText": "if you run mvn clean package it should check for these kind of things and fail the build", "author": "normanmaurer", "createdAt": "2020-08-18T08:01:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjI4NzE4OA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472287188", "bodyText": "Unfortunately, wasn't able to run this check today due to #10114 - the full build of the fresh Netty code from branch 4.1 (without my changes) didn't complete. Tomorrow I'll try to skip epoll transport build and see if it goes forward.", "author": "paul-lysak", "createdAt": "2020-08-18T15:31:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzcwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc0MDQ3Mg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472740472", "bodyText": "Verified in coded-mqtt folder with mvn clean verify. You were right about the return types: https://docs.oracle.com/javase/specs/jls/se7/html/jls-13.html#jls-13.4.15.\nFixed this and other compatibility issues detected by japicmp.", "author": "paul-lysak", "createdAt": "2020-08-19T06:07:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzcwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3Mzc0OA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471973748", "bodyText": "We can't do this as it would be API breakage", "author": "normanmaurer", "createdAt": "2020-08-18T07:32:38Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubAckMessage.java", "diffHunk": "@@ -23,14 +23,21 @@\n \n     public MqttSubAckMessage(\n             MqttFixedHeader mqttFixedHeader,\n-            MqttMessageIdVariableHeader variableHeader,\n+            MqttMessageIdAndPropertiesVariableHeader variableHeader,", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk4OTcxMQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471989711", "bodyText": "There's a constructor with the old signature besides this one - the code that uses the old API will use the old version, while the code that uses MQTT 5 features will use the new one.", "author": "paul-lysak", "createdAt": "2020-08-18T07:59:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3Mzc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3MzkyMA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471973920", "bodyText": "missing null checks", "author": "normanmaurer", "createdAt": "2020-08-18T07:32:54Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttReasonCodeAndPropertiesVariableHeader.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.mqtt;\n+\n+import io.netty.util.internal.StringUtil;\n+\n+/**\n+ * Variable Header for AUTH and DISCONNECT messages represented by {@link MqttMessage}\n+ */\n+public final class MqttReasonCodeAndPropertiesVariableHeader {\n+\n+    private final byte reasonCode;\n+    private final MqttProperties properties;\n+\n+    public static final byte REASON_CODE_OK = 0;\n+\n+    public MqttReasonCodeAndPropertiesVariableHeader(byte reasonCode,\n+                                                     MqttProperties properties) {\n+        this.reasonCode = reasonCode;\n+        this.properties = properties;", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3Mzk4MQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471973981", "bodyText": "We can't do this as it would be API breakage", "author": "normanmaurer", "createdAt": "2020-08-18T07:33:00Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishVariableHeader.java", "diffHunk": "@@ -25,10 +25,12 @@\n \n     private final String topicName;\n     private final int packetId;\n+    private final MqttProperties mqttProperties;\n \n-    public MqttPublishVariableHeader(String topicName, int packetId) {\n+    public MqttPublishVariableHeader(String topicName, int packetId, MqttProperties mqttProperties) {", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3NDA4Ng==", "url": "https://github.com/netty/netty/pull/10483#discussion_r471974086", "bodyText": "We can't do this as it would be API breakage", "author": "normanmaurer", "createdAt": "2020-08-18T07:33:13Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPubAckMessage.java", "diffHunk": "@@ -1,32 +0,0 @@\n-/*\n- * Copyright 2014 The Netty Project\n- *\n- * The Netty Project licenses this file to you under the Apache License,\n- * version 2.0 (the \"License\"); you may not use this file except in compliance\n- * with the License. You may obtain a copy of the License at:\n- *\n- *   http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n- * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n- * License for the specific language governing permissions and limitations\n- * under the License.\n- */\n-\n-package io.netty.handler.codec.mqtt;\n-\n-/**\n- * See <a href=\"http://public.dhe.ibm.com/software/dw/webservices/ws-mqtt/mqtt-v3r1.html#puback\">MQTTV3.1/puback</a>\n- */\n-public final class MqttPubAckMessage extends MqttMessage {", "originalCommit": "70fd242a06c005a1143442b4c8e258baef94c2a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjEwODkyMw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472108923", "bodyText": "Restored MqttPubAckMessage and its encoding/decoding. It makes little sense, however - PUBACK, PUBREC, PUBREL and PUBCOMP can be handled as MqttMessage (which is superclass of MqttPubAckMessage), just with a custom variable header class. Does it make sense to mark MqttPubAckMessage as deprecated?", "author": "paul-lysak", "createdAt": "2020-08-18T11:31:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTk3NDA4Ng=="}], "type": "inlineReview"}, {"oid": "9786339412a2f1b31d2a8dbfc6c07f9120842091", "url": "https://github.com/netty/netty/commit/9786339412a2f1b31d2a8dbfc6c07f9120842091", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  updated examples in `netty-example`.\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-18T11:16:27Z", "type": "forcePushed"}, {"oid": "a59e65c1dc5b3af7821846e0c7d0150c261a9b8a", "url": "https://github.com/netty/netty/commit/a59e65c1dc5b3af7821846e0c7d0150c261a9b8a", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  updated examples in `netty-example`.\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-19T06:04:02Z", "type": "forcePushed"}, {"oid": "95eb759b41c870c90d0165d2d6b323d2457ed143", "url": "https://github.com/netty/netty/commit/95eb759b41c870c90d0165d2d6b323d2457ed143", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  updated examples in `netty-example`.\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-19T06:10:13Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3NTUwNQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472875505", "bodyText": "nit: you can remove the else as you return in the if anyway", "author": "normanmaurer", "createdAt": "2020-08-19T09:00:40Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java", "diffHunk": "@@ -16,14 +16,34 @@\n \n package io.netty.handler.codec.mqtt;\n \n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.DecoderException;\n+import io.netty.util.Attribute;\n+import io.netty.util.AttributeKey;\n \n final class MqttCodecUtil {\n \n     private static final char[] TOPIC_WILDCARDS = {'#', '+'};\n     private static final int MIN_CLIENT_ID_LENGTH = 1;\n     private static final int MAX_CLIENT_ID_LENGTH = 23;\n \n+    static final AttributeKey<MqttVersion> MQTT_VERSION_KEY = AttributeKey.valueOf(\"MQTT_VERSION\");\n+\n+    static MqttVersion getMqttVersion(ChannelHandlerContext ctx) {\n+        Attribute<MqttVersion> attr = ctx.channel().attr(MQTT_VERSION_KEY);\n+        MqttVersion version = attr.get();\n+        if (version == null) {\n+            return MqttVersion.MQTT_3_1_1;\n+        } else {", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3NTk1MQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472875951", "bodyText": "I would use a \"more unique\" name so we not clash with something the user may have defined already", "author": "normanmaurer", "createdAt": "2020-08-19T09:01:19Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java", "diffHunk": "@@ -16,14 +16,34 @@\n \n package io.netty.handler.codec.mqtt;\n \n+import io.netty.channel.ChannelHandlerContext;\n import io.netty.handler.codec.DecoderException;\n+import io.netty.util.Attribute;\n+import io.netty.util.AttributeKey;\n \n final class MqttCodecUtil {\n \n     private static final char[] TOPIC_WILDCARDS = {'#', '+'};\n     private static final int MIN_CLIENT_ID_LENGTH = 1;\n     private static final int MAX_CLIENT_ID_LENGTH = 23;\n \n+    static final AttributeKey<MqttVersion> MQTT_VERSION_KEY = AttributeKey.valueOf(\"MQTT_VERSION\");", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3NjI5MA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472876290", "bodyText": "nit: update comment to reflect that this is also true for version 5 ?", "author": "normanmaurer", "createdAt": "2020-08-19T09:01:52Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttCodecUtil.java", "diffHunk": "@@ -43,22 +63,28 @@ static boolean isValidClientId(MqttVersion mqttVersion, String clientId) {\n             return clientId != null && clientId.length() >= MIN_CLIENT_ID_LENGTH &&\n                 clientId.length() <= MAX_CLIENT_ID_LENGTH;\n         }\n-        if (mqttVersion == MqttVersion.MQTT_3_1_1) {\n+        if (mqttVersion == MqttVersion.MQTT_3_1_1 || mqttVersion == MqttVersion.MQTT_5) {\n             // In 3.1.3.1 Client Identifier of MQTT 3.1.1 specification, The Server MAY allow ClientId\u2019s", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3NzMzNA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472877334", "bodyText": "do we need a null check via ObjectUtils.checkNotNull(...) ?", "author": "normanmaurer", "createdAt": "2020-08-19T09:03:40Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectVariableHeader.java", "diffHunk": "@@ -52,6 +76,7 @@ public MqttConnectVariableHeader(\n         this.isWillFlag = isWillFlag;\n         this.isCleanSession = isCleanSession;\n         this.keepAliveTimeSeconds = keepAliveTimeSeconds;\n+        this.properties = properties;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3NzQxMw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472877413", "bodyText": "do we need a null check via ObjectUtils.checkNotNull(...) ?", "author": "normanmaurer", "createdAt": "2020-08-19T09:03:50Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java", "diffHunk": "@@ -56,7 +59,23 @@ public MqttConnectPayload(\n             byte[] willMessage,\n             String userName,\n             byte[] password) {\n+        this(clientIdentifier,\n+                MqttProperties.NO_PROPERTIES,\n+                willTopic,\n+                willMessage,\n+                userName,\n+                password);\n+    }\n+\n+    public MqttConnectPayload(\n+            String clientIdentifier,\n+            MqttProperties willProperties,\n+            String willTopic,\n+            byte[] willMessage,\n+            String userName,\n+            byte[] password) {\n         this.clientIdentifier = clientIdentifier;\n+        this.willProperties = willProperties;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3NzQ2Nw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472877467", "bodyText": "do we need a null check via ObjectUtils.checkNotNull(...) ?", "author": "normanmaurer", "createdAt": "2020-08-19T09:03:58Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnAckVariableHeader.java", "diffHunk": "@@ -27,9 +27,17 @@\n \n     private final boolean sessionPresent;\n \n+    private final MqttProperties properties;\n+\n     public MqttConnAckVariableHeader(MqttConnectReturnCode connectReturnCode, boolean sessionPresent) {\n+        this(connectReturnCode, sessionPresent, MqttProperties.NO_PROPERTIES);\n+    }\n+\n+    public MqttConnAckVariableHeader(MqttConnectReturnCode connectReturnCode, boolean sessionPresent,\n+                                     MqttProperties properties) {\n         this.connectReturnCode = connectReturnCode;\n         this.sessionPresent = sessionPresent;\n+        this.properties = properties;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3ODAzMg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472878032", "bodyText": "can't this be static now ?", "author": "normanmaurer", "createdAt": "2020-08-19T09:04:58Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -176,44 +179,52 @@ private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {\n      * @param mqttFixedHeader MqttFixedHeader of the same message\n      * @return the variable header\n      */\n-    private static Result<?> decodeVariableHeader(ByteBuf buffer, MqttFixedHeader mqttFixedHeader) {\n+    private Result<?> decodeVariableHeader(ChannelHandlerContext ctx, ByteBuf buffer, MqttFixedHeader mqttFixedHeader) {", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjkyMDg0OQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472920849", "bodyText": "Unfortunately no - decodePubReplyMessage, decodePublishVariableHeader and decodeReasonCodeAndPropertiesVariableHeader rely on bytesRemainingInVariablePart, because reason code and properties may be skipped in case of successful message.", "author": "paul-lysak", "createdAt": "2020-08-19T10:17:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3ODAzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3OTU5Mw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472879593", "bodyText": "Isn't that the same as calling buffer.readInt(...) ?", "author": "normanmaurer", "createdAt": "2020-08-19T09:07:37Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -464,6 +634,36 @@ private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {\n         return new Result<Integer>(result, numberOfBytesConsumed);\n     }\n \n+    private static Result<Integer> decodeVariableByteInteger(ByteBuf buffer) {\n+        int remainingLength = 0;\n+        int multiplier = 1;\n+        short digit;\n+        int loops = 0;\n+        do {\n+            digit = buffer.readUnsignedByte();\n+            remainingLength += (digit & 127) * multiplier;\n+            multiplier *= 128;\n+            loops++;\n+        } while ((digit & 128) != 0 && loops < 4);\n+\n+        // MQTT protocol limits Remaining Length to 4 bytes\n+        if (loops == 4 && (digit & 128) != 0) {\n+            return null;\n+        }\n+        return new Result<Integer>(remainingLength, loops);\n+    }\n+\n+    private static Result<Integer> decode4bytesInteger(ByteBuf buffer) {\n+        short msb = buffer.readUnsignedByte();\n+        short secondByte = buffer.readUnsignedByte();\n+        short thirdByte = buffer.readUnsignedByte();\n+        short lsbSize = buffer.readUnsignedByte();\n+        final int numberOfBytesConsumed = 4;\n+        int result = msb << 24 | secondByte << 16 | thirdByte << 8 | lsbSize;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjk2MzIyNg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472963226", "bodyText": "Right, removed the duplicate code", "author": "paul-lysak", "createdAt": "2020-08-19T11:38:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg3OTU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4MDM0NA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472880344", "bodyText": "would be nice if you can link to the spec so its clearer what you are doing here in terms of masking etc", "author": "normanmaurer", "createdAt": "2020-08-19T09:08:53Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -379,9 +519,20 @@ private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {\n         while (numberOfBytesConsumed < bytesRemainingInVariablePart) {\n             final Result<String> decodedTopicName = decodeString(buffer);\n             numberOfBytesConsumed += decodedTopicName.numberOfBytesConsumed;\n-            int qos = buffer.readUnsignedByte() & 0x03;\n+            final short optionByte = buffer.readUnsignedByte();\n+\n+            MqttQoS qos = MqttQoS.valueOf(optionByte & 0x03);", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4MDcwOA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472880708", "bodyText": "please add a default: as well", "author": "normanmaurer", "createdAt": "2020-08-19T09:09:28Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -474,4 +674,78 @@ private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {\n             this.numberOfBytesConsumed = numberOfBytesConsumed;\n         }\n     }\n+\n+    private static Result<MqttProperties> decodeProperties(ByteBuf buffer) {\n+        final Result<Integer> propertiesLength = decodeVariableByteInteger(buffer);\n+        int totalPropertiesLength = propertiesLength.value;\n+        int numberOfBytesConsumed = propertiesLength.numberOfBytesConsumed;\n+\n+        MqttProperties decodedProperties = new MqttProperties();\n+        while (numberOfBytesConsumed < totalPropertiesLength) {\n+            Result<Integer> propertyId = decodeVariableByteInteger(buffer);\n+            numberOfBytesConsumed += propertyId.numberOfBytesConsumed;\n+\n+            switch (MqttProperties.MqttPropertyType.valueOf(propertyId.value)) {\n+                case PAYLOAD_FORMAT_INDICATOR:\n+                case REQUEST_PROBLEM_INFORMATION:\n+                case REQUEST_RESPONSE_INFORMATION:\n+                case MAXIMUM_QOS:\n+                case RETAIN_AVAILABLE:\n+                case WILDCARD_SUBSCRIPTION_AVAILABLE:\n+                case SUBSCRIPTION_IDENTIFIER_AVAILABLE:\n+                case SHARED_SUBSCRIPTION_AVAILABLE:\n+                    final int b1 = buffer.readUnsignedByte();\n+                    numberOfBytesConsumed++;\n+                    decodedProperties.add(new MqttProperties.IntegerProperty(propertyId.value, b1));\n+                    break;\n+                case SERVER_KEEP_ALIVE:\n+                case RECEIVE_MAXIMUM:\n+                case TOPIC_ALIAS_MAXIMUM:\n+                case TOPIC_ALIAS:\n+                    final Result<Integer> int2BytesResult = decodeMsbLsb(buffer);\n+                    numberOfBytesConsumed += int2BytesResult.numberOfBytesConsumed;\n+                    decodedProperties.add(new MqttProperties.IntegerProperty(propertyId.value, int2BytesResult.value));\n+                    break;\n+                case PUBLICATION_EXPIRY_INTERVAL:\n+                case SESSION_EXPIRY_INTERVAL:\n+                case WILL_DELAY_INTERVAL:\n+                case MAXIMUM_PACKET_SIZE:\n+                    final Result<Integer> int4BytesResult = decode4bytesInteger(buffer);\n+                    numberOfBytesConsumed += int4BytesResult.numberOfBytesConsumed;\n+                    decodedProperties.add(new MqttProperties.IntegerProperty(propertyId.value, int4BytesResult.value));\n+                    break;\n+                case SUBSCRIPTION_IDENTIFIER:\n+                    Result<Integer> vbIntegerResult = decodeVariableByteInteger(buffer);\n+                    numberOfBytesConsumed += vbIntegerResult.numberOfBytesConsumed;\n+                    decodedProperties.add(new MqttProperties.IntegerProperty(propertyId.value, vbIntegerResult.value));\n+                    break;\n+                case CONTENT_TYPE:\n+                case RESPONSE_TOPIC:\n+                case ASSIGNED_CLIENT_IDENTIFIER:\n+                case AUTHENTICATION_METHOD:\n+                case RESPONSE_INFORMATION:\n+                case SERVER_REFERENCE:\n+                case REASON_STRING:\n+                    final Result<String> stringResult = decodeString(buffer);\n+                    numberOfBytesConsumed += stringResult.numberOfBytesConsumed;\n+                    decodedProperties.add(new MqttProperties.StringProperty(propertyId.value, stringResult.value));\n+                    break;\n+                case USER_PROPERTY:\n+                    final Result<String> keyResult = decodeString(buffer);\n+                    final Result<String> valueResult = decodeString(buffer);\n+                    numberOfBytesConsumed += keyResult.numberOfBytesConsumed;\n+                    numberOfBytesConsumed += valueResult.numberOfBytesConsumed;\n+                    decodedProperties.add(new MqttProperties.UserProperty(keyResult.value, valueResult.value));\n+                    break;\n+                case CORRELATION_DATA:\n+                case AUTHENTICATION_DATA:\n+                    final Result<byte[]> binaryDataResult = decodeByteArray(buffer);\n+                    numberOfBytesConsumed += binaryDataResult.numberOfBytesConsumed;\n+                    decodedProperties.add(new MqttProperties.BinaryProperty(propertyId.value, binaryDataResult.value));\n+                    break;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4MTA1OA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472881058", "bodyText": "nit: I know this is pre-existing but can you add a default: ?", "author": "normanmaurer", "createdAt": "2020-08-19T09:10:05Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -176,44 +179,52 @@ private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {\n      * @param mqttFixedHeader MqttFixedHeader of the same message\n      * @return the variable header\n      */\n-    private static Result<?> decodeVariableHeader(ByteBuf buffer, MqttFixedHeader mqttFixedHeader) {\n+    private Result<?> decodeVariableHeader(ChannelHandlerContext ctx, ByteBuf buffer, MqttFixedHeader mqttFixedHeader) {\n         switch (mqttFixedHeader.messageType()) {\n             case CONNECT:\n-                return decodeConnectionVariableHeader(buffer);\n+                return decodeConnectionVariableHeader(ctx, buffer);\n \n             case CONNACK:\n-                return decodeConnAckVariableHeader(buffer);\n+                return decodeConnAckVariableHeader(ctx, buffer);\n \n-            case SUBSCRIBE:\n             case UNSUBSCRIBE:\n+            case SUBSCRIBE:\n             case SUBACK:\n             case UNSUBACK:\n+                return decodeMessageIdAndPropertiesVariableHeader(ctx, buffer);\n+\n             case PUBACK:\n             case PUBREC:\n             case PUBCOMP:\n             case PUBREL:\n-                return decodeMessageIdVariableHeader(buffer);\n+                return decodePubReplyMessage(buffer);\n \n             case PUBLISH:\n-                return decodePublishVariableHeader(buffer, mqttFixedHeader);\n+                return decodePublishVariableHeader(ctx, buffer, mqttFixedHeader);\n+\n+            case DISCONNECT:\n+            case AUTH:\n+                return decodeReasonCodeAndPropertiesVariableHeader(buffer);\n \n             case PINGREQ:\n             case PINGRESP:\n-            case DISCONNECT:\n                 // Empty variable header\n                 return new Result<Object>(null, 0);", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4MTQzOQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472881439", "bodyText": "can you link to the spec ?", "author": "normanmaurer", "createdAt": "2020-08-19T09:10:43Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -464,6 +634,36 @@ private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {\n         return new Result<Integer>(result, numberOfBytesConsumed);\n     }\n \n+    private static Result<Integer> decodeVariableByteInteger(ByteBuf buffer) {\n+        int remainingLength = 0;\n+        int multiplier = 1;\n+        short digit;\n+        int loops = 0;\n+        do {\n+            digit = buffer.readUnsignedByte();\n+            remainingLength += (digit & 127) * multiplier;\n+            multiplier *= 128;\n+            loops++;\n+        } while ((digit & 128) != 0 && loops < 4);\n+\n+        // MQTT protocol limits Remaining Length to 4 bytes", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4MTk4NA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472881984", "bodyText": "don't use this one directly but use Unpooled.EMPTY_BUFFER", "author": "normanmaurer", "createdAt": "2020-08-19T09:11:36Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -18,9 +18,10 @@\n \n import io.netty.buffer.ByteBuf;\n import io.netty.buffer.ByteBufAllocator;\n+import io.netty.buffer.EmptyByteBuf;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4MjI3MA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472882270", "bodyText": "consider removing this argument as you can get the instance from ctx.alloc()", "author": "normanmaurer", "createdAt": "2020-08-19T09:12:06Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -53,37 +54,48 @@ protected void encode(ChannelHandlerContext ctx, MqttMessage msg, List<Object> o\n      * @param message MQTT message to encode\n      * @return ByteBuf with encoded bytes\n      */\n-    static ByteBuf doEncode(ByteBufAllocator byteBufAllocator, MqttMessage message) {\n+    static ByteBuf doEncode(ChannelHandlerContext ctx,\n+                     ByteBufAllocator byteBufAllocator,", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4MjQwMw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472882403", "bodyText": "nit: you can remove the else", "author": "normanmaurer", "createdAt": "2020-08-19T09:12:20Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -53,37 +54,48 @@ protected void encode(ChannelHandlerContext ctx, MqttMessage msg, List<Object> o\n      * @param message MQTT message to encode\n      * @return ByteBuf with encoded bytes\n      */\n-    static ByteBuf doEncode(ByteBufAllocator byteBufAllocator, MqttMessage message) {\n+    static ByteBuf doEncode(ChannelHandlerContext ctx,\n+                     ByteBufAllocator byteBufAllocator,\n+                     MqttMessage message) {\n \n         switch (message.fixedHeader().messageType()) {\n             case CONNECT:\n-                return encodeConnectMessage(byteBufAllocator, (MqttConnectMessage) message);\n+                return encodeConnectMessage(ctx, byteBufAllocator, (MqttConnectMessage) message);\n \n             case CONNACK:\n-                return encodeConnAckMessage(byteBufAllocator, (MqttConnAckMessage) message);\n+                return encodeConnAckMessage(ctx, byteBufAllocator, (MqttConnAckMessage) message);\n \n             case PUBLISH:\n-                return encodePublishMessage(byteBufAllocator, (MqttPublishMessage) message);\n+                return encodePublishMessage(ctx, byteBufAllocator, (MqttPublishMessage) message);\n \n             case SUBSCRIBE:\n-                return encodeSubscribeMessage(byteBufAllocator, (MqttSubscribeMessage) message);\n+                return encodeSubscribeMessage(ctx, byteBufAllocator, (MqttSubscribeMessage) message);\n \n             case UNSUBSCRIBE:\n-                return encodeUnsubscribeMessage(byteBufAllocator, (MqttUnsubscribeMessage) message);\n+                return encodeUnsubscribeMessage(ctx, byteBufAllocator, (MqttUnsubscribeMessage) message);\n \n             case SUBACK:\n-                return encodeSubAckMessage(byteBufAllocator, (MqttSubAckMessage) message);\n+                return encodeSubAckMessage(ctx, byteBufAllocator, (MqttSubAckMessage) message);\n \n             case UNSUBACK:\n+                if (message instanceof MqttUnsubAckMessage) {\n+                    return encodeUnsubAckMessage(ctx, byteBufAllocator, (MqttUnsubAckMessage) message);\n+                } else {", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjk0NjYwMQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472946601", "bodyText": "Prior version calls encodeMessageWithOnlySingleByteFixedHeaderAndMessageId here and doesn't assume the type of message to be MqttUnsubAckMessage, therefore some client code may fail if we don't do the check here - the same way as MqttCodecTest.testUnsubAckMessage fails if I remove this conditional", "author": "paul-lysak", "createdAt": "2020-08-19T11:05:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4MjQwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5MjYzMQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r473092631", "bodyText": "Thats not what I meant... I was basically saying you can refactor it to be:\nif (....) {\n    return ...\n}\nreturn ...", "author": "normanmaurer", "createdAt": "2020-08-19T14:54:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4MjQwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4MjY1NA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472882654", "bodyText": "nit consider removing  the allocator as you can get it via ctx.alloc()", "author": "normanmaurer", "createdAt": "2020-08-19T09:12:48Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -93,6 +105,7 @@ static ByteBuf doEncode(ByteBufAllocator byteBufAllocator, MqttMessage message)\n     }\n \n     private static ByteBuf encodeConnectMessage(\n+            ChannelHandlerContext ctx,\n             ByteBufAllocator byteBufAllocator,", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg4Mjc4Mg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472882782", "bodyText": "good catch!", "author": "normanmaurer", "createdAt": "2020-08-19T09:13:02Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -102,10 +115,11 @@ private static ByteBuf encodeConnectMessage(\n         MqttConnectPayload payload = message.payload();\n         MqttVersion mqttVersion = MqttVersion.fromProtocolNameAndLevel(variableHeader.name(),\n                 (byte) variableHeader.version());\n+        MqttCodecUtil.setMqttVersion(ctx, mqttVersion);\n \n         // as MQTT 3.1 & 3.1.1 spec, If the User Name Flag is set to 0, the Password Flag MUST be set to 0\n         if (!variableHeader.hasUserName() && variableHeader.hasPassword()) {\n-            throw new DecoderException(\"Without a username, the password MUST be not set\");\n+            throw new EncoderException(\"Without a username, the password MUST be not set\");", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NDU3Ng==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472894576", "bodyText": "you will need to call propertiesBuf.release() later as you not transfer ownership", "author": "normanmaurer", "createdAt": "2020-08-19T09:31:05Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -138,9 +152,20 @@ private static ByteBuf encodeConnectMessage(\n             payloadBufferSize += 2 + passwordBytes.length;\n         }\n \n-        // Fixed header\n+        // Fixed and variable header\n         byte[] protocolNameBytes = mqttVersion.protocolNameBytes();\n-        int variableHeaderBufferSize = 2 + protocolNameBytes.length + 4;\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NDg5Nw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472894897", "bodyText": "you will need to call willPropertiesBuf.release() later as you not transfer ownership", "author": "normanmaurer", "createdAt": "2020-08-19T09:31:32Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -138,9 +152,20 @@ private static ByteBuf encodeConnectMessage(\n             payloadBufferSize += 2 + passwordBytes.length;\n         }\n \n-        // Fixed header\n+        // Fixed and variable header\n         byte[] protocolNameBytes = mqttVersion.protocolNameBytes();\n-        int variableHeaderBufferSize = 2 + protocolNameBytes.length + 4;\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(\n+                mqttVersion,\n+                byteBufAllocator,\n+                message.variableHeader().properties());\n+        int variableHeaderBufferSize = 2 + protocolNameBytes.length + 4 + propertiesBuf.readableBytes();\n+        final ByteBuf willPropertiesBuf;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NTEyOA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472895128", "bodyText": "you will need to call propertiesBuf.release() later as you not transfer ownership", "author": "normanmaurer", "createdAt": "2020-08-19T09:31:54Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -196,21 +223,34 @@ private static int getConnVariableHeaderFlag(MqttConnectVariableHeader variableH\n     }\n \n     private static ByteBuf encodeConnAckMessage(\n+            ChannelHandlerContext ctx,\n             ByteBufAllocator byteBufAllocator,\n             MqttConnAckMessage message) {\n-        ByteBuf buf = byteBufAllocator.buffer(4);\n+        final MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NTIxNg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472895216", "bodyText": "you will need to call propertiesBuf.release() later as you not transfer ownership", "author": "normanmaurer", "createdAt": "2020-08-19T09:32:04Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -196,21 +223,34 @@ private static int getConnVariableHeaderFlag(MqttConnectVariableHeader variableH\n     }\n \n     private static ByteBuf encodeConnAckMessage(\n+            ChannelHandlerContext ctx,\n             ByteBufAllocator byteBufAllocator,\n             MqttConnAckMessage message) {\n-        ByteBuf buf = byteBufAllocator.buffer(4);\n+        final MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                byteBufAllocator,\n+                message.variableHeader().properties());\n+\n+        ByteBuf buf = byteBufAllocator.buffer(4 + propertiesBuf.readableBytes());\n         buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n-        buf.writeByte(2);\n+        writeVariableLengthInt(buf, 2 + propertiesBuf.readableBytes());\n         buf.writeByte(message.variableHeader().isSessionPresent() ? 0x01 : 0x00);\n         buf.writeByte(message.variableHeader().connectReturnCode().byteValue());\n+        buf.writeBytes(propertiesBuf);\n \n         return buf;\n     }\n \n     private static ByteBuf encodeSubscribeMessage(\n+            ChannelHandlerContext ctx,\n             ByteBufAllocator byteBufAllocator,\n             MqttSubscribeMessage message) {\n-        int variableHeaderBufferSize = 2;\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NTM0Ng==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472895346", "bodyText": "you will need to call propertiesBuf.release() later as you not transfer ownership", "author": "normanmaurer", "createdAt": "2020-08-19T09:32:17Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -234,23 +274,38 @@ private static ByteBuf encodeSubscribeMessage(\n         // Variable Header\n         int messageId = variableHeader.messageId();\n         buf.writeShort(messageId);\n+        buf.writeBytes(propertiesBuf);\n \n         // Payload\n         for (MqttTopicSubscription topic : payload.topicSubscriptions()) {\n-            String topicName = topic.topicName();\n-            byte[] topicNameBytes = encodeStringUtf8(topicName);\n-            buf.writeShort(topicNameBytes.length);\n-            buf.writeBytes(topicNameBytes, 0, topicNameBytes.length);\n-            buf.writeByte(topic.qualityOfService().value());\n+            writeUTF8String(buf, topic.topicName());\n+            final MqttSubscriptionOption option = topic.option();\n+\n+            int optionEncoded =  option.retainHandling().value() << 4;\n+            if (option.isRetainAsPublished()) {\n+                optionEncoded |= 0x08;\n+            }\n+            if (option.isNoLocal()) {\n+                optionEncoded |= 0x04;\n+            }\n+            optionEncoded |= option.qos().value();\n+\n+            buf.writeByte(optionEncoded);\n         }\n \n         return buf;\n     }\n \n     private static ByteBuf encodeUnsubscribeMessage(\n+            ChannelHandlerContext ctx,\n             ByteBufAllocator byteBufAllocator,\n             MqttUnsubscribeMessage message) {\n-        int variableHeaderBufferSize = 2;\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NTQ0Ng==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472895446", "bodyText": "you will need to call propertiesBuf.release() later as you not transfer ownership", "author": "normanmaurer", "createdAt": "2020-08-19T09:32:25Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -284,35 +340,72 @@ private static ByteBuf encodeUnsubscribeMessage(\n     }\n \n     private static ByteBuf encodeSubAckMessage(\n+            ChannelHandlerContext ctx,\n             ByteBufAllocator byteBufAllocator,\n             MqttSubAckMessage message) {\n-        int variableHeaderBufferSize = 2;\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NTU2Nw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472895567", "bodyText": "you will need to call propertiesBuf.release() later as you not transfer ownership", "author": "normanmaurer", "createdAt": "2020-08-19T09:32:36Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -284,35 +340,72 @@ private static ByteBuf encodeUnsubscribeMessage(\n     }\n \n     private static ByteBuf encodeSubAckMessage(\n+            ChannelHandlerContext ctx,\n             ByteBufAllocator byteBufAllocator,\n             MqttSubAckMessage message) {\n-        int variableHeaderBufferSize = 2;\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                byteBufAllocator,\n+                message.idAndPropertiesVariableHeader().properties());\n+        int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n         int payloadBufferSize = message.payload().grantedQoSLevels().size();\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n         ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n         writeVariableLengthInt(buf, variablePartSize);\n         buf.writeShort(message.variableHeader().messageId());\n+        buf.writeBytes(propertiesBuf);\n         for (int qos : message.payload().grantedQoSLevels()) {\n             buf.writeByte(qos);\n         }\n \n         return buf;\n     }\n \n+    private static ByteBuf encodeUnsubAckMessage(\n+            ChannelHandlerContext ctx,\n+            ByteBufAllocator byteBufAllocator,\n+            MqttUnsubAckMessage message) {\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                byteBufAllocator,\n+                message.idAndPropertiesVariableHeader().properties());\n+        int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n+        int payloadBufferSize = message.payload().unsubscribeReasonCodes().size();\n+        int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n+        int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n+        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n+        writeVariableLengthInt(buf, variablePartSize);\n+        buf.writeShort(message.variableHeader().messageId());\n+        buf.writeBytes(propertiesBuf);\n+\n+        for (Short reasonCode : message.payload().unsubscribeReasonCodes()) {\n+            buf.writeByte(reasonCode);\n+        }\n+\n+        return buf;\n+    }\n+\n     private static ByteBuf encodePublishMessage(\n+            ChannelHandlerContext ctx,\n             ByteBufAllocator byteBufAllocator,\n             MqttPublishMessage message) {\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n         MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n         MqttPublishVariableHeader variableHeader = message.variableHeader();\n         ByteBuf payload = message.payload().duplicate();\n \n         String topicName = variableHeader.topicName();\n         byte[] topicNameBytes = encodeStringUtf8(topicName);\n \n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NTgwOA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472895808", "bodyText": "you will need to call propertiesBuf.release() later as you not transfer ownership", "author": "normanmaurer", "createdAt": "2020-08-19T09:33:00Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -325,11 +418,53 @@ private static ByteBuf encodePublishMessage(\n         if (mqttFixedHeader.qosLevel().value() > 0) {\n             buf.writeShort(variableHeader.packetId());\n         }\n+        buf.writeBytes(propertiesBuf);\n         buf.writeBytes(payload);\n \n         return buf;\n     }\n \n+    private static ByteBuf encodePubReplyMessage(ChannelHandlerContext ctx,\n+                                          ByteBufAllocator byteBufAllocator,\n+                                          MqttMessage message) {\n+        if (message.variableHeader() instanceof MqttPubReplyMessageVariableHeader) {\n+            MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n+            MqttPubReplyMessageVariableHeader variableHeader =\n+                    (MqttPubReplyMessageVariableHeader) message.variableHeader();\n+            int msgId = variableHeader.messageId();\n+\n+            final ByteBuf propertiesBuf;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NTg5MQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472895891", "bodyText": "you will need to call propertiesBuf.release() later as you not transfer ownership", "author": "normanmaurer", "createdAt": "2020-08-19T09:33:08Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -347,6 +482,46 @@ private static ByteBuf encodeMessageWithOnlySingleByteFixedHeaderAndMessageId(\n         return buf;\n     }\n \n+    private static ByteBuf encodeReasonCodePlusPropertiesMessage(\n+            ChannelHandlerContext ctx,\n+            ByteBufAllocator byteBufAllocator,\n+            MqttMessage message) {\n+        if (message.variableHeader() instanceof MqttReasonCodeAndPropertiesVariableHeader) {\n+            MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+            MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n+            MqttReasonCodeAndPropertiesVariableHeader variableHeader =\n+                    (MqttReasonCodeAndPropertiesVariableHeader) message.variableHeader();\n+\n+            final ByteBuf propertiesBuf;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NjExNg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472896116", "bodyText": "please add default:", "author": "normanmaurer", "createdAt": "2020-08-19T09:33:30Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -358,6 +533,89 @@ private static ByteBuf encodeMessageWithOnlySingleByteFixedHeader(\n         return buf;\n     }\n \n+    private static ByteBuf encodePropertiesIfNeeded(MqttVersion mqttVersion,\n+                                             ByteBufAllocator byteBufAllocator,\n+                                             MqttProperties mqttProperties) {\n+        if (mqttVersion == MqttVersion.MQTT_5) {\n+            return encodeProperties(byteBufAllocator, mqttProperties);\n+        } else {\n+            return new EmptyByteBuf(byteBufAllocator);\n+        }\n+    }\n+\n+    private static ByteBuf encodeProperties(ByteBufAllocator byteBufAllocator,\n+                                            MqttProperties mqttProperties) {\n+        ByteBuf propertiesHeaderBuf = byteBufAllocator.buffer();\n+        // encode also the Properties part\n+        ByteBuf propertiesBuf = byteBufAllocator.buffer();\n+        for (MqttProperties.MqttProperty property : mqttProperties.listAll()) {\n+            switch (MqttProperties.MqttPropertyType.valueOf(property.propertyId)) {\n+                case PAYLOAD_FORMAT_INDICATOR:\n+                case REQUEST_PROBLEM_INFORMATION:\n+                case REQUEST_RESPONSE_INFORMATION:\n+                case MAXIMUM_QOS:\n+                case RETAIN_AVAILABLE:\n+                case WILDCARD_SUBSCRIPTION_AVAILABLE:\n+                case SUBSCRIPTION_IDENTIFIER_AVAILABLE:\n+                case SHARED_SUBSCRIPTION_AVAILABLE:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    final byte bytePropValue = ((MqttProperties.IntegerProperty) property).value.byteValue();\n+                    propertiesBuf.writeByte(bytePropValue);\n+                    break;\n+                case SERVER_KEEP_ALIVE:\n+                case RECEIVE_MAXIMUM:\n+                case TOPIC_ALIAS_MAXIMUM:\n+                case TOPIC_ALIAS:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    final short twoBytesInPropValue = ((MqttProperties.IntegerProperty) property).value.shortValue();\n+                    propertiesBuf.writeShort(twoBytesInPropValue);\n+                    break;\n+                case PUBLICATION_EXPIRY_INTERVAL:\n+                case SESSION_EXPIRY_INTERVAL:\n+                case WILL_DELAY_INTERVAL:\n+                case MAXIMUM_PACKET_SIZE:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    final int fourBytesIntPropValue = ((MqttProperties.IntegerProperty) property).value;\n+                    propertiesBuf.writeInt(fourBytesIntPropValue);\n+                    break;\n+                case SUBSCRIPTION_IDENTIFIER:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    final int vbi = ((MqttProperties.IntegerProperty) property).value;\n+                    writeVariableLengthInt(propertiesBuf, vbi);\n+                    break;\n+                case CONTENT_TYPE:\n+                case RESPONSE_TOPIC:\n+                case ASSIGNED_CLIENT_IDENTIFIER:\n+                case AUTHENTICATION_METHOD:\n+                case RESPONSE_INFORMATION:\n+                case SERVER_REFERENCE:\n+                case REASON_STRING:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    writeUTF8String(propertiesBuf, ((MqttProperties.StringProperty) property).value);\n+                    break;\n+                case USER_PROPERTY:\n+                    final List<MqttProperties.StringPair> pairs = ((MqttProperties.UserProperties) property).value;\n+                    for (MqttProperties.StringPair pair: pairs) {\n+                        writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                        writeUTF8String(propertiesBuf, pair.key);\n+                        writeUTF8String(propertiesBuf, pair.value);\n+                    }\n+                    break;\n+                case CORRELATION_DATA:\n+                case AUTHENTICATION_DATA:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    final byte[] binaryPropValue = ((MqttProperties.BinaryProperty) property).value;\n+                    propertiesBuf.writeShort(binaryPropValue.length);\n+                    propertiesBuf.writeBytes(binaryPropValue, 0, binaryPropValue.length);\n+                    break;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NzA2MA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472897060", "bodyText": "protected as the class is abstract", "author": "normanmaurer", "createdAt": "2020-08-19T09:35:00Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.mqtt;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+/**\n+ * MQTT Properties container\n+ * */\n+public final class MqttProperties {\n+\n+    public enum MqttPropertyType {\n+        // single byte properties\n+        PAYLOAD_FORMAT_INDICATOR(0x01),\n+        REQUEST_PROBLEM_INFORMATION(0x17),\n+        REQUEST_RESPONSE_INFORMATION(0x19),\n+        MAXIMUM_QOS(0x24),\n+        RETAIN_AVAILABLE(0x25),\n+        WILDCARD_SUBSCRIPTION_AVAILABLE(0x28),\n+        SUBSCRIPTION_IDENTIFIER_AVAILABLE(0x29),\n+        SHARED_SUBSCRIPTION_AVAILABLE(0x2A),\n+\n+        // two bytes properties\n+        SERVER_KEEP_ALIVE(0x13),\n+        RECEIVE_MAXIMUM(0x21),\n+        TOPIC_ALIAS_MAXIMUM(0x22),\n+        TOPIC_ALIAS(0x23),\n+\n+        // four bytes properties\n+        PUBLICATION_EXPIRY_INTERVAL(0x02),\n+        SESSION_EXPIRY_INTERVAL(0x11),\n+        WILL_DELAY_INTERVAL(0x18),\n+        MAXIMUM_PACKET_SIZE(0x27),\n+\n+        // Variable Byte Integer\n+        SUBSCRIPTION_IDENTIFIER(0x0B),\n+\n+        // UTF-8 Encoded String properties\n+        CONTENT_TYPE(0x03),\n+        RESPONSE_TOPIC(0x08),\n+        ASSIGNED_CLIENT_IDENTIFIER(0x12),\n+        AUTHENTICATION_METHOD(0x15),\n+        RESPONSE_INFORMATION(0x1A),\n+        SERVER_REFERENCE(0x1C),\n+        REASON_STRING(0x1F),\n+        USER_PROPERTY(0x26),\n+\n+        // Binary Data\n+        CORRELATION_DATA(0x09),\n+        AUTHENTICATION_DATA(0x16);\n+\n+        private final int value;\n+\n+        MqttPropertyType(int value) {\n+            this.value = value;\n+        }\n+\n+        public int value() {\n+            return value;\n+        }\n+\n+        public static MqttPropertyType valueOf(int type) {\n+            for (MqttPropertyType t : values()) {\n+                if (t.value == type) {\n+                    return t;\n+                }\n+            }\n+            throw new IllegalArgumentException(\"unknown property type: \" + type);\n+        }\n+    }\n+\n+    public static final MqttProperties NO_PROPERTIES = new MqttProperties();\n+\n+    public abstract static class MqttProperty<T> {\n+        final T value;\n+        final int propertyId;\n+\n+        public MqttProperty(int propertyId, T value) {", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NzM4Nw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472897387", "bodyText": "not need to call this()", "author": "normanmaurer", "createdAt": "2020-08-19T09:35:33Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.mqtt;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+/**\n+ * MQTT Properties container\n+ * */\n+public final class MqttProperties {\n+\n+    public enum MqttPropertyType {\n+        // single byte properties\n+        PAYLOAD_FORMAT_INDICATOR(0x01),\n+        REQUEST_PROBLEM_INFORMATION(0x17),\n+        REQUEST_RESPONSE_INFORMATION(0x19),\n+        MAXIMUM_QOS(0x24),\n+        RETAIN_AVAILABLE(0x25),\n+        WILDCARD_SUBSCRIPTION_AVAILABLE(0x28),\n+        SUBSCRIPTION_IDENTIFIER_AVAILABLE(0x29),\n+        SHARED_SUBSCRIPTION_AVAILABLE(0x2A),\n+\n+        // two bytes properties\n+        SERVER_KEEP_ALIVE(0x13),\n+        RECEIVE_MAXIMUM(0x21),\n+        TOPIC_ALIAS_MAXIMUM(0x22),\n+        TOPIC_ALIAS(0x23),\n+\n+        // four bytes properties\n+        PUBLICATION_EXPIRY_INTERVAL(0x02),\n+        SESSION_EXPIRY_INTERVAL(0x11),\n+        WILL_DELAY_INTERVAL(0x18),\n+        MAXIMUM_PACKET_SIZE(0x27),\n+\n+        // Variable Byte Integer\n+        SUBSCRIPTION_IDENTIFIER(0x0B),\n+\n+        // UTF-8 Encoded String properties\n+        CONTENT_TYPE(0x03),\n+        RESPONSE_TOPIC(0x08),\n+        ASSIGNED_CLIENT_IDENTIFIER(0x12),\n+        AUTHENTICATION_METHOD(0x15),\n+        RESPONSE_INFORMATION(0x1A),\n+        SERVER_REFERENCE(0x1C),\n+        REASON_STRING(0x1F),\n+        USER_PROPERTY(0x26),\n+\n+        // Binary Data\n+        CORRELATION_DATA(0x09),\n+        AUTHENTICATION_DATA(0x16);\n+\n+        private final int value;\n+\n+        MqttPropertyType(int value) {\n+            this.value = value;\n+        }\n+\n+        public int value() {\n+            return value;\n+        }\n+\n+        public static MqttPropertyType valueOf(int type) {\n+            for (MqttPropertyType t : values()) {\n+                if (t.value == type) {\n+                    return t;\n+                }\n+            }\n+            throw new IllegalArgumentException(\"unknown property type: \" + type);\n+        }\n+    }\n+\n+    public static final MqttProperties NO_PROPERTIES = new MqttProperties();\n+\n+    public abstract static class MqttProperty<T> {\n+        final T value;\n+        final int propertyId;\n+\n+        public MqttProperty(int propertyId, T value) {\n+            this.propertyId = propertyId;\n+            this.value = value;\n+        }\n+    }\n+\n+    public static final class IntegerProperty extends MqttProperty<Integer> {\n+\n+        public IntegerProperty(int propertyId, Integer value) {\n+            super(propertyId, value);\n+        }\n+    }\n+\n+    public static final class StringProperty extends MqttProperty<String> {\n+\n+        public StringProperty(int propertyId, String value) {\n+            super(propertyId, value);\n+        }\n+    }\n+\n+    public static final class StringPair {\n+        public final String key;\n+        public final String value;\n+\n+        public StringPair(String key, String value) {\n+            this.key = key;\n+            this.value = value;\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return key.hashCode() + 31 * value.hashCode();\n+        }\n+\n+        @Override\n+        public boolean equals(Object obj) {\n+            if (this == obj) {\n+                return true;\n+            }\n+            if (obj == null || getClass() != obj.getClass()) {\n+                return false;\n+            }\n+            StringPair that = (StringPair) obj;\n+\n+            return that.key.equals(this.key) && that.value.equals(this.value);\n+        }\n+    }\n+\n+    //User properties are the only properties that may be included multiple times and\n+    //are the only properties where ordering is required. Therefore, they need a special handling\n+    public static final class UserProperties extends MqttProperty<List<StringPair>> {\n+        public UserProperties() {\n+            super(MqttPropertyType.USER_PROPERTY.value, new ArrayList<StringPair>());\n+        }\n+\n+        public UserProperties(List<StringPair> values) {\n+            this();", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjk1NjY2NQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472956665", "bodyText": "If I remove this() then it tries to call superclass default construction which doesn't exist, so compilation fails.", "author": "paul-lysak", "createdAt": "2020-08-19T11:26:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NzM4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MjMyMw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475362323", "bodyText": "ah I see...  Plese also make it clear via java docs that the given values are copied and so the List reference is not stored. You may even use Collection<StringPair> or Iterable<StringPair>", "author": "normanmaurer", "createdAt": "2020-08-24T06:09:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NzM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5NzYzOA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472897638", "bodyText": "null check ?", "author": "normanmaurer", "createdAt": "2020-08-19T09:35:57Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPubReplyMessageVariableHeader.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package io.netty.handler.codec.mqtt;\n+\n+import io.netty.util.internal.StringUtil;\n+\n+/**\n+ * Variable Header containing Packet Id, reason code and Properties as in MQTT v5 spec.\n+ */\n+public final class MqttPubReplyMessageVariableHeader extends MqttMessageIdVariableHeader {\n+\n+    private final byte reasonCode;\n+    private final MqttProperties properties;\n+\n+    public static final byte REASON_CODE_OK = 0;\n+\n+    public MqttPubReplyMessageVariableHeader(int messageId, byte reasonCode, MqttProperties properties) {\n+        super(messageId);\n+        if (messageId < 1 || messageId > 0xffff) {\n+            throw new IllegalArgumentException(\"messageId: \" + messageId + \" (expected: 1 ~ 65535)\");\n+        }\n+        this.reasonCode = reasonCode;\n+        this.properties = properties;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjg5Nzc2NQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r472897765", "bodyText": "null check ?", "author": "normanmaurer", "createdAt": "2020-08-19T09:36:08Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttPublishVariableHeader.java", "diffHunk": "@@ -25,10 +25,16 @@\n \n     private final String topicName;\n     private final int packetId;\n+    private final MqttProperties mqttProperties;\n \n     public MqttPublishVariableHeader(String topicName, int packetId) {\n+        this(topicName, packetId, MqttProperties.NO_PROPERTIES);\n+    }\n+\n+    public MqttPublishVariableHeader(String topicName, int packetId, MqttProperties mqttProperties) {\n         this.topicName = topicName;\n         this.packetId = packetId;\n+        this.mqttProperties = mqttProperties;", "originalCommit": "95eb759b41c870c90d0165d2d6b323d2457ed143", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "url": "https://github.com/netty/netty/commit/7d90e00ccd0ae7aa2515dc5d5743826839bdb8e9", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  updated examples in `netty-example`.\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-19T11:34:15Z", "type": "forcePushed"}, {"oid": "4df4ec779ac51eca89b92a2305eeac0f410c29e2", "url": "https://github.com/netty/netty/commit/4df4ec779ac51eca89b92a2305eeac0f410c29e2", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  updated examples in `netty-example`.\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-19T11:41:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5MDI5MA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r473090290", "bodyText": "this pattern seems to be used a lot... consider extracting it to a static method and use it everywhere...", "author": "normanmaurer", "createdAt": "2020-08-19T14:51:33Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectVariableHeader.java", "diffHunk": "@@ -52,6 +76,11 @@ public MqttConnectVariableHeader(\n         this.isWillFlag = isWillFlag;\n         this.isCleanSession = isCleanSession;\n         this.keepAliveTimeSeconds = keepAliveTimeSeconds;\n+        if (properties == null) {\n+            this.properties = MqttProperties.NO_PROPERTIES;", "originalCommit": "4df4ec779ac51eca89b92a2305eeac0f410c29e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5MDYwMA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r473090600", "bodyText": "if this is the case we should throw ....", "author": "normanmaurer", "createdAt": "2020-08-19T14:51:57Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -176,44 +179,54 @@ private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {\n      * @param mqttFixedHeader MqttFixedHeader of the same message\n      * @return the variable header\n      */\n-    private static Result<?> decodeVariableHeader(ByteBuf buffer, MqttFixedHeader mqttFixedHeader) {\n+    private Result<?> decodeVariableHeader(ChannelHandlerContext ctx, ByteBuf buffer, MqttFixedHeader mqttFixedHeader) {\n         switch (mqttFixedHeader.messageType()) {\n             case CONNECT:\n-                return decodeConnectionVariableHeader(buffer);\n+                return decodeConnectionVariableHeader(ctx, buffer);\n \n             case CONNACK:\n-                return decodeConnAckVariableHeader(buffer);\n+                return decodeConnAckVariableHeader(ctx, buffer);\n \n-            case SUBSCRIBE:\n             case UNSUBSCRIBE:\n+            case SUBSCRIBE:\n             case SUBACK:\n             case UNSUBACK:\n+                return decodeMessageIdAndPropertiesVariableHeader(ctx, buffer);\n+\n             case PUBACK:\n             case PUBREC:\n             case PUBCOMP:\n             case PUBREL:\n-                return decodeMessageIdVariableHeader(buffer);\n+                return decodePubReplyMessage(buffer);\n \n             case PUBLISH:\n-                return decodePublishVariableHeader(buffer, mqttFixedHeader);\n+                return decodePublishVariableHeader(ctx, buffer, mqttFixedHeader);\n+\n+            case DISCONNECT:\n+            case AUTH:\n+                return decodeReasonCodeAndPropertiesVariableHeader(buffer);\n \n             case PINGREQ:\n             case PINGRESP:\n-            case DISCONNECT:\n                 // Empty variable header\n                 return new Result<Object>(null, 0);\n+            default:\n+                //shouldn't reach here\n+                return new Result<Object>(null, 0);", "originalCommit": "4df4ec779ac51eca89b92a2305eeac0f410c29e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzA5MTE3NA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r473091174", "bodyText": "either fill both or remove", "author": "normanmaurer", "createdAt": "2020-08-19T14:52:43Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -464,6 +637,31 @@ private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {\n         return new Result<Integer>(result, numberOfBytesConsumed);\n     }\n \n+    /**\n+     * See 1.5.5 Variable Byte Integer section of MQTT 5.0 specification for encoding/decoding rules\n+     *\n+     * @param buffer\n+     * @return", "originalCommit": "4df4ec779ac51eca89b92a2305eeac0f410c29e2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "url": "https://github.com/netty/netty/commit/60a7360c49f19dc60ba8e908ca1d5707cb78b918", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  added attribute `NETTY_CODEC_MQTT_VERSION` to track protocol version\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-20T07:12:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM1ODYxMw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475358613", "bodyText": "nit: use MqttProperties.notNull", "author": "normanmaurer", "createdAt": "2020-08-24T05:57:59Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttConnectPayload.java", "diffHunk": "@@ -56,7 +59,27 @@ public MqttConnectPayload(\n             byte[] willMessage,\n             String userName,\n             byte[] password) {\n+        this(clientIdentifier,\n+                MqttProperties.NO_PROPERTIES,\n+                willTopic,\n+                willMessage,\n+                userName,\n+                password);\n+    }\n+\n+    public MqttConnectPayload(\n+            String clientIdentifier,\n+            MqttProperties willProperties,\n+            String willTopic,\n+            byte[] willMessage,\n+            String userName,\n+            byte[] password) {\n         this.clientIdentifier = clientIdentifier;\n+        if (willProperties == null) {\n+            this.willProperties = MqttProperties.NO_PROPERTIES;\n+        } else {\n+            this.willProperties = willProperties;\n+        }", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM1OTI4Ng==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475359286", "bodyText": "nit: use new ArrayList<Short>(bytesRemainingInVariablePart); as we already know how many elements we will add.", "author": "normanmaurer", "createdAt": "2020-08-24T06:00:10Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -402,6 +556,25 @@ private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {\n         return new Result<MqttSubAckPayload>(new MqttSubAckPayload(grantedQos), numberOfBytesConsumed);\n     }\n \n+    private static Result<MqttUnsubAckPayload> decodeUnsubAckPayload(\n+            ChannelHandlerContext ctx,\n+            ByteBuf buffer,\n+            int bytesRemainingInVariablePart) {\n+        final MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        if (mqttVersion == MqttVersion.MQTT_5) {\n+            final List<Short> reasonCodes = new ArrayList<Short>();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM1OTk3OA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475359978", "bodyText": "I wonder if we should better do the release in a finally block. Just in case if something goes wrong... otherwise we will leak memory", "author": "normanmaurer", "createdAt": "2020-08-24T06:02:27Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -196,21 +221,33 @@ private static int getConnVariableHeaderFlag(MqttConnectVariableHeader variableH\n     }\n \n     private static ByteBuf encodeConnAckMessage(\n-            ByteBufAllocator byteBufAllocator,\n+            ChannelHandlerContext ctx,\n             MqttConnAckMessage message) {\n-        ByteBuf buf = byteBufAllocator.buffer(4);\n+        final MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                ctx.alloc(),\n+                message.variableHeader().properties());\n+\n+        ByteBuf buf = ctx.alloc().buffer(4 + propertiesBuf.readableBytes());\n         buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n-        buf.writeByte(2);\n+        writeVariableLengthInt(buf, 2 + propertiesBuf.readableBytes());\n         buf.writeByte(message.variableHeader().isSessionPresent() ? 0x01 : 0x00);\n         buf.writeByte(message.variableHeader().connectReturnCode().byteValue());\n+        buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDAyOQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475360029", "bodyText": "I wonder if we should better do the release in a finally block. Just in case if something goes wrong... otherwise we will leak memory", "author": "normanmaurer", "createdAt": "2020-08-24T06:02:38Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -153,11 +174,15 @@ private static ByteBuf encodeConnectMessage(\n         buf.writeByte(variableHeader.version());\n         buf.writeByte(getConnVariableHeaderFlag(variableHeader));\n         buf.writeShort(variableHeader.keepAliveTimeSeconds());\n+        buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDE0Mw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475360143", "bodyText": "I wonder if we should better do the release in a finally block. Just in case if something goes wrong... otherwise we will leak memory", "author": "normanmaurer", "createdAt": "2020-08-24T06:02:59Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -153,11 +174,15 @@ private static ByteBuf encodeConnectMessage(\n         buf.writeByte(variableHeader.version());\n         buf.writeByte(getConnVariableHeaderFlag(variableHeader));\n         buf.writeShort(variableHeader.keepAliveTimeSeconds());\n+        buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();\n \n         // Payload\n         buf.writeShort(clientIdentifierBytes.length);\n         buf.writeBytes(clientIdentifierBytes, 0, clientIdentifierBytes.length);\n         if (variableHeader.isWillFlag()) {\n+            buf.writeBytes(willPropertiesBuf);\n+            willPropertiesBuf.release();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDM4Mg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475360382", "bodyText": "Also I think we should always call release() ... so please do it outside of the if block. I know at the moment it not really matters as you use EMPTY_BUFFER but this is more of an implementation detail.", "author": "normanmaurer", "createdAt": "2020-08-24T06:03:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDE0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDQ0NA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475360444", "bodyText": "I wonder if we should better do the release in a finally block. Just in case if something goes wrong... otherwise we will leak memory", "author": "normanmaurer", "createdAt": "2020-08-24T06:04:03Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -227,30 +264,45 @@ private static ByteBuf encodeSubscribeMessage(\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n \n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n         writeVariableLengthInt(buf, variablePartSize);\n \n         // Variable Header\n         int messageId = variableHeader.messageId();\n         buf.writeShort(messageId);\n+        buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDU3MQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475360571", "bodyText": "I wonder if we should better do the release in a finally block. Just in case if something goes wrong... otherwise we will leak memory", "author": "normanmaurer", "createdAt": "2020-08-24T06:04:26Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -265,13 +317,15 @@ private static ByteBuf encodeUnsubscribeMessage(\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n \n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n         writeVariableLengthInt(buf, variablePartSize);\n \n         // Variable Header\n         int messageId = variableHeader.messageId();\n         buf.writeShort(messageId);\n+        buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDU5OA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475360598", "bodyText": "I wonder if we should better do the release in a finally block. Just in case if something goes wrong... otherwise we will leak memory", "author": "normanmaurer", "createdAt": "2020-08-24T06:04:32Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -284,52 +338,135 @@ private static ByteBuf encodeUnsubscribeMessage(\n     }\n \n     private static ByteBuf encodeSubAckMessage(\n-            ByteBufAllocator byteBufAllocator,\n+            ChannelHandlerContext ctx,\n             MqttSubAckMessage message) {\n-        int variableHeaderBufferSize = 2;\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                ctx.alloc(),\n+                message.idAndPropertiesVariableHeader().properties());\n+        int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n         int payloadBufferSize = message.payload().grantedQoSLevels().size();\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n         writeVariableLengthInt(buf, variablePartSize);\n         buf.writeShort(message.variableHeader().messageId());\n+        buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDY1Mg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475360652", "bodyText": "I wonder if we should better do the release in a finally block. Just in case if something goes wrong... otherwise we will leak memory", "author": "normanmaurer", "createdAt": "2020-08-24T06:04:41Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -284,52 +338,135 @@ private static ByteBuf encodeUnsubscribeMessage(\n     }\n \n     private static ByteBuf encodeSubAckMessage(\n-            ByteBufAllocator byteBufAllocator,\n+            ChannelHandlerContext ctx,\n             MqttSubAckMessage message) {\n-        int variableHeaderBufferSize = 2;\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                ctx.alloc(),\n+                message.idAndPropertiesVariableHeader().properties());\n+        int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n         int payloadBufferSize = message.payload().grantedQoSLevels().size();\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n         writeVariableLengthInt(buf, variablePartSize);\n         buf.writeShort(message.variableHeader().messageId());\n+        buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();\n         for (int qos : message.payload().grantedQoSLevels()) {\n             buf.writeByte(qos);\n         }\n \n         return buf;\n     }\n \n+    private static ByteBuf encodeUnsubAckMessage(\n+            ChannelHandlerContext ctx,\n+            MqttUnsubAckMessage message) {\n+        if (message.variableHeader() instanceof  MqttMessageIdAndPropertiesVariableHeader) {\n+            MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+            ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                    ctx.alloc(),\n+                    message.idAndPropertiesVariableHeader().properties());\n+            int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n+            int payloadBufferSize = message.payload().unsubscribeReasonCodes().size();\n+            int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n+            int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n+            ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n+            buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n+            writeVariableLengthInt(buf, variablePartSize);\n+            buf.writeShort(message.variableHeader().messageId());\n+            buf.writeBytes(propertiesBuf);\n+            propertiesBuf.release();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDczNw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475360737", "bodyText": "I wonder if we should better do the release in a finally block. Just in case if something goes wrong... otherwise we will leak memory", "author": "normanmaurer", "createdAt": "2020-08-24T06:04:55Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -284,52 +338,135 @@ private static ByteBuf encodeUnsubscribeMessage(\n     }\n \n     private static ByteBuf encodeSubAckMessage(\n-            ByteBufAllocator byteBufAllocator,\n+            ChannelHandlerContext ctx,\n             MqttSubAckMessage message) {\n-        int variableHeaderBufferSize = 2;\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                ctx.alloc(),\n+                message.idAndPropertiesVariableHeader().properties());\n+        int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n         int payloadBufferSize = message.payload().grantedQoSLevels().size();\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n         writeVariableLengthInt(buf, variablePartSize);\n         buf.writeShort(message.variableHeader().messageId());\n+        buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();\n         for (int qos : message.payload().grantedQoSLevels()) {\n             buf.writeByte(qos);\n         }\n \n         return buf;\n     }\n \n+    private static ByteBuf encodeUnsubAckMessage(\n+            ChannelHandlerContext ctx,\n+            MqttUnsubAckMessage message) {\n+        if (message.variableHeader() instanceof  MqttMessageIdAndPropertiesVariableHeader) {\n+            MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+            ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                    ctx.alloc(),\n+                    message.idAndPropertiesVariableHeader().properties());\n+            int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n+            int payloadBufferSize = message.payload().unsubscribeReasonCodes().size();\n+            int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n+            int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n+            ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n+            buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n+            writeVariableLengthInt(buf, variablePartSize);\n+            buf.writeShort(message.variableHeader().messageId());\n+            buf.writeBytes(propertiesBuf);\n+            propertiesBuf.release();\n+\n+            for (Short reasonCode : message.payload().unsubscribeReasonCodes()) {\n+                buf.writeByte(reasonCode);\n+            }\n+\n+            return buf;\n+        } else {\n+            return encodeMessageWithOnlySingleByteFixedHeaderAndMessageId(ctx.alloc(), message);\n+        }\n+    }\n+\n     private static ByteBuf encodePublishMessage(\n-            ByteBufAllocator byteBufAllocator,\n+            ChannelHandlerContext ctx,\n             MqttPublishMessage message) {\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n         MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n         MqttPublishVariableHeader variableHeader = message.variableHeader();\n         ByteBuf payload = message.payload().duplicate();\n \n         String topicName = variableHeader.topicName();\n         byte[] topicNameBytes = encodeStringUtf8(topicName);\n \n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                ctx.alloc(),\n+                message.variableHeader().properties());\n+\n         int variableHeaderBufferSize = 2 + topicNameBytes.length +\n-                (mqttFixedHeader.qosLevel().value() > 0 ? 2 : 0);\n+                (mqttFixedHeader.qosLevel().value() > 0 ? 2 : 0) + propertiesBuf.readableBytes();\n         int payloadBufferSize = payload.readableBytes();\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n \n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n         writeVariableLengthInt(buf, variablePartSize);\n         buf.writeShort(topicNameBytes.length);\n         buf.writeBytes(topicNameBytes);\n         if (mqttFixedHeader.qosLevel().value() > 0) {\n             buf.writeShort(variableHeader.packetId());\n         }\n+        buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDgxNg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475360816", "bodyText": "I wonder if we should better do the release in a finally block. Just in case if something goes wrong... otherwise we will leak memory", "author": "normanmaurer", "createdAt": "2020-08-24T06:05:08Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -284,52 +338,135 @@ private static ByteBuf encodeUnsubscribeMessage(\n     }\n \n     private static ByteBuf encodeSubAckMessage(\n-            ByteBufAllocator byteBufAllocator,\n+            ChannelHandlerContext ctx,\n             MqttSubAckMessage message) {\n-        int variableHeaderBufferSize = 2;\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                ctx.alloc(),\n+                message.idAndPropertiesVariableHeader().properties());\n+        int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n         int payloadBufferSize = message.payload().grantedQoSLevels().size();\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n         writeVariableLengthInt(buf, variablePartSize);\n         buf.writeShort(message.variableHeader().messageId());\n+        buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();\n         for (int qos : message.payload().grantedQoSLevels()) {\n             buf.writeByte(qos);\n         }\n \n         return buf;\n     }\n \n+    private static ByteBuf encodeUnsubAckMessage(\n+            ChannelHandlerContext ctx,\n+            MqttUnsubAckMessage message) {\n+        if (message.variableHeader() instanceof  MqttMessageIdAndPropertiesVariableHeader) {\n+            MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+            ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                    ctx.alloc(),\n+                    message.idAndPropertiesVariableHeader().properties());\n+            int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n+            int payloadBufferSize = message.payload().unsubscribeReasonCodes().size();\n+            int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n+            int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n+            ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n+            buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n+            writeVariableLengthInt(buf, variablePartSize);\n+            buf.writeShort(message.variableHeader().messageId());\n+            buf.writeBytes(propertiesBuf);\n+            propertiesBuf.release();\n+\n+            for (Short reasonCode : message.payload().unsubscribeReasonCodes()) {\n+                buf.writeByte(reasonCode);\n+            }\n+\n+            return buf;\n+        } else {\n+            return encodeMessageWithOnlySingleByteFixedHeaderAndMessageId(ctx.alloc(), message);\n+        }\n+    }\n+\n     private static ByteBuf encodePublishMessage(\n-            ByteBufAllocator byteBufAllocator,\n+            ChannelHandlerContext ctx,\n             MqttPublishMessage message) {\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n         MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n         MqttPublishVariableHeader variableHeader = message.variableHeader();\n         ByteBuf payload = message.payload().duplicate();\n \n         String topicName = variableHeader.topicName();\n         byte[] topicNameBytes = encodeStringUtf8(topicName);\n \n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                ctx.alloc(),\n+                message.variableHeader().properties());\n+\n         int variableHeaderBufferSize = 2 + topicNameBytes.length +\n-                (mqttFixedHeader.qosLevel().value() > 0 ? 2 : 0);\n+                (mqttFixedHeader.qosLevel().value() > 0 ? 2 : 0) + propertiesBuf.readableBytes();\n         int payloadBufferSize = payload.readableBytes();\n         int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n         int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n \n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n+        ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n         buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n         writeVariableLengthInt(buf, variablePartSize);\n         buf.writeShort(topicNameBytes.length);\n         buf.writeBytes(topicNameBytes);\n         if (mqttFixedHeader.qosLevel().value() > 0) {\n             buf.writeShort(variableHeader.packetId());\n         }\n+        buf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();\n         buf.writeBytes(payload);\n \n         return buf;\n     }\n \n+    private static ByteBuf encodePubReplyMessage(ChannelHandlerContext ctx,\n+                                          MqttMessage message) {\n+        if (message.variableHeader() instanceof MqttPubReplyMessageVariableHeader) {\n+            MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n+            MqttPubReplyMessageVariableHeader variableHeader =\n+                    (MqttPubReplyMessageVariableHeader) message.variableHeader();\n+            int msgId = variableHeader.messageId();\n+\n+            final ByteBuf propertiesBuf;\n+            final boolean includeReasonCode;\n+            final int variableHeaderBufferSize;\n+            final MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+            if (mqttVersion == MqttVersion.MQTT_5 &&\n+                    (variableHeader.reasonCode() != MqttPubReplyMessageVariableHeader.REASON_CODE_OK ||\n+                            !variableHeader.properties().isEmpty())) {\n+                propertiesBuf = encodeProperties(ctx.alloc(), variableHeader.properties());\n+                includeReasonCode = true;\n+                variableHeaderBufferSize = 3 + propertiesBuf.readableBytes();\n+            } else {\n+                propertiesBuf = Unpooled.EMPTY_BUFFER;\n+                includeReasonCode = false;\n+                variableHeaderBufferSize = 2;\n+            }\n+\n+            final int fixedHeaderBufferSize = 1 + getVariableLengthInt(variableHeaderBufferSize);\n+            ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variableHeaderBufferSize);\n+            buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n+            writeVariableLengthInt(buf, variableHeaderBufferSize);\n+            buf.writeShort(msgId);\n+            if (includeReasonCode) {\n+                buf.writeByte(variableHeader.reasonCode());\n+            }\n+            buf.writeBytes(propertiesBuf);\n+            propertiesBuf.release();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDg2MQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475360861", "bodyText": "I wonder if we should better do the release in a finally block. Just in case if something goes wrong... otherwise we will leak memory", "author": "normanmaurer", "createdAt": "2020-08-24T06:05:17Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -347,6 +484,46 @@ private static ByteBuf encodeMessageWithOnlySingleByteFixedHeaderAndMessageId(\n         return buf;\n     }\n \n+    private static ByteBuf encodeReasonCodePlusPropertiesMessage(\n+            ChannelHandlerContext ctx,\n+            MqttMessage message) {\n+        if (message.variableHeader() instanceof MqttReasonCodeAndPropertiesVariableHeader) {\n+            MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+            MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n+            MqttReasonCodeAndPropertiesVariableHeader variableHeader =\n+                    (MqttReasonCodeAndPropertiesVariableHeader) message.variableHeader();\n+\n+            final ByteBuf propertiesBuf;\n+            final boolean includeReasonCode;\n+            final int variableHeaderBufferSize;\n+            if (mqttVersion == MqttVersion.MQTT_5 &&\n+                    (variableHeader.reasonCode() != MqttReasonCodeAndPropertiesVariableHeader.REASON_CODE_OK ||\n+                            !variableHeader.properties().isEmpty())) {\n+                propertiesBuf = encodeProperties(ctx.alloc(), variableHeader.properties());\n+                includeReasonCode = true;\n+                variableHeaderBufferSize = 1 + propertiesBuf.readableBytes();\n+            } else {\n+                propertiesBuf = Unpooled.EMPTY_BUFFER;\n+                includeReasonCode = false;\n+                variableHeaderBufferSize = 0;\n+            }\n+\n+            final int fixedHeaderBufferSize = 1 + getVariableLengthInt(variableHeaderBufferSize);\n+            ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variableHeaderBufferSize);\n+            buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n+            writeVariableLengthInt(buf, variableHeaderBufferSize);\n+            if (includeReasonCode) {\n+                buf.writeByte(variableHeader.reasonCode());\n+            }\n+            buf.writeBytes(propertiesBuf);\n+            propertiesBuf.release();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MDk2Nw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475360967", "bodyText": "nit: you can remove the else", "author": "normanmaurer", "createdAt": "2020-08-24T06:05:34Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -358,6 +535,94 @@ private static ByteBuf encodeMessageWithOnlySingleByteFixedHeader(\n         return buf;\n     }\n \n+    private static ByteBuf encodePropertiesIfNeeded(MqttVersion mqttVersion,\n+                                             ByteBufAllocator byteBufAllocator,\n+                                             MqttProperties mqttProperties) {\n+        if (mqttVersion == MqttVersion.MQTT_5) {\n+            return encodeProperties(byteBufAllocator, mqttProperties);\n+        } else {", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MTIzOQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475361239", "bodyText": "I wonder if we should better do the release in a finally block. Just in case if something goes wrong... otherwise we will leak memory... This will also cover the default: case then", "author": "normanmaurer", "createdAt": "2020-08-24T06:06:23Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -358,6 +535,94 @@ private static ByteBuf encodeMessageWithOnlySingleByteFixedHeader(\n         return buf;\n     }\n \n+    private static ByteBuf encodePropertiesIfNeeded(MqttVersion mqttVersion,\n+                                             ByteBufAllocator byteBufAllocator,\n+                                             MqttProperties mqttProperties) {\n+        if (mqttVersion == MqttVersion.MQTT_5) {\n+            return encodeProperties(byteBufAllocator, mqttProperties);\n+        } else {\n+            return Unpooled.EMPTY_BUFFER;\n+        }\n+    }\n+\n+    private static ByteBuf encodeProperties(ByteBufAllocator byteBufAllocator,\n+                                            MqttProperties mqttProperties) {\n+        ByteBuf propertiesHeaderBuf = byteBufAllocator.buffer();\n+        // encode also the Properties part\n+        ByteBuf propertiesBuf = byteBufAllocator.buffer();\n+        for (MqttProperties.MqttProperty property : mqttProperties.listAll()) {\n+            MqttProperties.MqttPropertyType propertyType = MqttProperties.MqttPropertyType.valueOf(property.propertyId);\n+            switch (propertyType) {\n+                case PAYLOAD_FORMAT_INDICATOR:\n+                case REQUEST_PROBLEM_INFORMATION:\n+                case REQUEST_RESPONSE_INFORMATION:\n+                case MAXIMUM_QOS:\n+                case RETAIN_AVAILABLE:\n+                case WILDCARD_SUBSCRIPTION_AVAILABLE:\n+                case SUBSCRIPTION_IDENTIFIER_AVAILABLE:\n+                case SHARED_SUBSCRIPTION_AVAILABLE:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    final byte bytePropValue = ((MqttProperties.IntegerProperty) property).value.byteValue();\n+                    propertiesBuf.writeByte(bytePropValue);\n+                    break;\n+                case SERVER_KEEP_ALIVE:\n+                case RECEIVE_MAXIMUM:\n+                case TOPIC_ALIAS_MAXIMUM:\n+                case TOPIC_ALIAS:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    final short twoBytesInPropValue = ((MqttProperties.IntegerProperty) property).value.shortValue();\n+                    propertiesBuf.writeShort(twoBytesInPropValue);\n+                    break;\n+                case PUBLICATION_EXPIRY_INTERVAL:\n+                case SESSION_EXPIRY_INTERVAL:\n+                case WILL_DELAY_INTERVAL:\n+                case MAXIMUM_PACKET_SIZE:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    final int fourBytesIntPropValue = ((MqttProperties.IntegerProperty) property).value;\n+                    propertiesBuf.writeInt(fourBytesIntPropValue);\n+                    break;\n+                case SUBSCRIPTION_IDENTIFIER:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    final int vbi = ((MqttProperties.IntegerProperty) property).value;\n+                    writeVariableLengthInt(propertiesBuf, vbi);\n+                    break;\n+                case CONTENT_TYPE:\n+                case RESPONSE_TOPIC:\n+                case ASSIGNED_CLIENT_IDENTIFIER:\n+                case AUTHENTICATION_METHOD:\n+                case RESPONSE_INFORMATION:\n+                case SERVER_REFERENCE:\n+                case REASON_STRING:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    writeUTF8String(propertiesBuf, ((MqttProperties.StringProperty) property).value);\n+                    break;\n+                case USER_PROPERTY:\n+                    final List<MqttProperties.StringPair> pairs = ((MqttProperties.UserProperties) property).value;\n+                    for (MqttProperties.StringPair pair: pairs) {\n+                        writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                        writeUTF8String(propertiesBuf, pair.key);\n+                        writeUTF8String(propertiesBuf, pair.value);\n+                    }\n+                    break;\n+                case CORRELATION_DATA:\n+                case AUTHENTICATION_DATA:\n+                    writeVariableLengthInt(propertiesBuf, property.propertyId);\n+                    final byte[] binaryPropValue = ((MqttProperties.BinaryProperty) property).value;\n+                    propertiesBuf.writeShort(binaryPropValue.length);\n+                    propertiesBuf.writeBytes(binaryPropValue, 0, binaryPropValue.length);\n+                    break;\n+                default:\n+                    //shouldn't reach here\n+                    throw new EncoderException(\"Unknown property type: \" + propertyType);\n+            }\n+        }\n+        writeVariableLengthInt(propertiesHeaderBuf, propertiesBuf.readableBytes());\n+        propertiesHeaderBuf.writeBytes(propertiesBuf);\n+        propertiesBuf.release();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MTc2Ng==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475361766", "bodyText": "I am not in love with the method name...  Maybe just make it package-private for now so we can change it later on.", "author": "normanmaurer", "createdAt": "2020-08-24T06:08:17Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.mqtt;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+/**\n+ * MQTT Properties container\n+ * */\n+public final class MqttProperties {\n+\n+    public enum MqttPropertyType {\n+        // single byte properties\n+        PAYLOAD_FORMAT_INDICATOR(0x01),\n+        REQUEST_PROBLEM_INFORMATION(0x17),\n+        REQUEST_RESPONSE_INFORMATION(0x19),\n+        MAXIMUM_QOS(0x24),\n+        RETAIN_AVAILABLE(0x25),\n+        WILDCARD_SUBSCRIPTION_AVAILABLE(0x28),\n+        SUBSCRIPTION_IDENTIFIER_AVAILABLE(0x29),\n+        SHARED_SUBSCRIPTION_AVAILABLE(0x2A),\n+\n+        // two bytes properties\n+        SERVER_KEEP_ALIVE(0x13),\n+        RECEIVE_MAXIMUM(0x21),\n+        TOPIC_ALIAS_MAXIMUM(0x22),\n+        TOPIC_ALIAS(0x23),\n+\n+        // four bytes properties\n+        PUBLICATION_EXPIRY_INTERVAL(0x02),\n+        SESSION_EXPIRY_INTERVAL(0x11),\n+        WILL_DELAY_INTERVAL(0x18),\n+        MAXIMUM_PACKET_SIZE(0x27),\n+\n+        // Variable Byte Integer\n+        SUBSCRIPTION_IDENTIFIER(0x0B),\n+\n+        // UTF-8 Encoded String properties\n+        CONTENT_TYPE(0x03),\n+        RESPONSE_TOPIC(0x08),\n+        ASSIGNED_CLIENT_IDENTIFIER(0x12),\n+        AUTHENTICATION_METHOD(0x15),\n+        RESPONSE_INFORMATION(0x1A),\n+        SERVER_REFERENCE(0x1C),\n+        REASON_STRING(0x1F),\n+        USER_PROPERTY(0x26),\n+\n+        // Binary Data\n+        CORRELATION_DATA(0x09),\n+        AUTHENTICATION_DATA(0x16);\n+\n+        private final int value;\n+\n+        MqttPropertyType(int value) {\n+            this.value = value;\n+        }\n+\n+        public int value() {\n+            return value;\n+        }\n+\n+        public static MqttPropertyType valueOf(int type) {\n+            for (MqttPropertyType t : values()) {\n+                if (t.value == type) {\n+                    return t;\n+                }\n+            }\n+            throw new IllegalArgumentException(\"unknown property type: \" + type);\n+        }\n+    }\n+\n+    public static final MqttProperties NO_PROPERTIES = new MqttProperties();\n+\n+    public static MqttProperties notNull(MqttProperties properties) {", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI2NTkxMA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r476265910", "bodyText": "Made it package-private, also renamed to withEmptyDefaults. Is it a better name?", "author": "paul-lysak", "createdAt": "2020-08-25T08:19:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MTc2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MzMyNg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475363326", "bodyText": "So after inspecting the code it seems like this is problematic. The static field here is still mutable which means users can store stuff in there etc. We need to make this instance immutable as otherwise bad things can happen", "author": "normanmaurer", "createdAt": "2020-08-24T06:13:16Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttProperties.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.mqtt;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.List;\n+import java.util.ArrayList;\n+\n+/**\n+ * MQTT Properties container\n+ * */\n+public final class MqttProperties {\n+\n+    public enum MqttPropertyType {\n+        // single byte properties\n+        PAYLOAD_FORMAT_INDICATOR(0x01),\n+        REQUEST_PROBLEM_INFORMATION(0x17),\n+        REQUEST_RESPONSE_INFORMATION(0x19),\n+        MAXIMUM_QOS(0x24),\n+        RETAIN_AVAILABLE(0x25),\n+        WILDCARD_SUBSCRIPTION_AVAILABLE(0x28),\n+        SUBSCRIPTION_IDENTIFIER_AVAILABLE(0x29),\n+        SHARED_SUBSCRIPTION_AVAILABLE(0x2A),\n+\n+        // two bytes properties\n+        SERVER_KEEP_ALIVE(0x13),\n+        RECEIVE_MAXIMUM(0x21),\n+        TOPIC_ALIAS_MAXIMUM(0x22),\n+        TOPIC_ALIAS(0x23),\n+\n+        // four bytes properties\n+        PUBLICATION_EXPIRY_INTERVAL(0x02),\n+        SESSION_EXPIRY_INTERVAL(0x11),\n+        WILL_DELAY_INTERVAL(0x18),\n+        MAXIMUM_PACKET_SIZE(0x27),\n+\n+        // Variable Byte Integer\n+        SUBSCRIPTION_IDENTIFIER(0x0B),\n+\n+        // UTF-8 Encoded String properties\n+        CONTENT_TYPE(0x03),\n+        RESPONSE_TOPIC(0x08),\n+        ASSIGNED_CLIENT_IDENTIFIER(0x12),\n+        AUTHENTICATION_METHOD(0x15),\n+        RESPONSE_INFORMATION(0x1A),\n+        SERVER_REFERENCE(0x1C),\n+        REASON_STRING(0x1F),\n+        USER_PROPERTY(0x26),\n+\n+        // Binary Data\n+        CORRELATION_DATA(0x09),\n+        AUTHENTICATION_DATA(0x16);\n+\n+        private final int value;\n+\n+        MqttPropertyType(int value) {\n+            this.value = value;\n+        }\n+\n+        public int value() {\n+            return value;\n+        }\n+\n+        public static MqttPropertyType valueOf(int type) {\n+            for (MqttPropertyType t : values()) {\n+                if (t.value == type) {\n+                    return t;\n+                }\n+            }\n+            throw new IllegalArgumentException(\"unknown property type: \" + type);\n+        }\n+    }\n+\n+    public static final MqttProperties NO_PROPERTIES = new MqttProperties();", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI2NjQzNQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r476266435", "bodyText": "Changed it to be backed by an unmodifiable empty map.", "author": "paul-lysak", "createdAt": "2020-08-25T08:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MzMyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2MzgzOA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475363838", "bodyText": "nit: you can remove the else", "author": "normanmaurer", "createdAt": "2020-08-24T06:14:42Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckMessage.java", "diffHunk": "@@ -21,12 +21,43 @@\n  */\n public final class MqttUnsubAckMessage extends MqttMessage {\n \n-    public MqttUnsubAckMessage(MqttFixedHeader mqttFixedHeader, MqttMessageIdVariableHeader variableHeader) {\n-        super(mqttFixedHeader, variableHeader, null);\n+    public MqttUnsubAckMessage(MqttFixedHeader mqttFixedHeader,\n+                               MqttMessageIdAndPropertiesVariableHeader variableHeader,\n+                               MqttUnsubAckPayload payload) {\n+        super(mqttFixedHeader, variableHeader, payload);\n+    }\n+\n+    public MqttUnsubAckMessage(MqttFixedHeader mqttFixedHeader,\n+                               MqttMessageIdVariableHeader variableHeader,\n+                               MqttUnsubAckPayload payload) {\n+        this(mqttFixedHeader, fallbackVariableHeader(variableHeader), payload);\n+    }\n+    public MqttUnsubAckMessage(MqttFixedHeader mqttFixedHeader,\n+                               MqttMessageIdVariableHeader variableHeader) {\n+        this(mqttFixedHeader, variableHeader, null);\n+    }\n+\n+    private static MqttMessageIdAndPropertiesVariableHeader fallbackVariableHeader(\n+            MqttMessageIdVariableHeader variableHeader) {\n+        if (variableHeader instanceof MqttMessageIdAndPropertiesVariableHeader) {\n+            return (MqttMessageIdAndPropertiesVariableHeader) variableHeader;\n+        } else {", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2NDAyNQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475364025", "bodyText": "nit: you can use ObjectUtils.checkNotNull(...)", "author": "normanmaurer", "createdAt": "2020-08-24T06:15:08Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.mqtt;\n+\n+import io.netty.util.internal.StringUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Payload for MQTT unsuback message as in V5.\n+ */\n+public final class MqttUnsubAckPayload {\n+\n+    private final List<Short> unsubscribeReasonCodes;\n+\n+    public MqttUnsubAckPayload(short... unsubscribeReasonCodes) {\n+        if (unsubscribeReasonCodes == null) {\n+            throw new NullPointerException(\"unsubscribeReasonCodes\");", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTM2NDEyNg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475364126", "bodyText": "nit: you can use ObjectUtils.checkNotNull(...)", "author": "normanmaurer", "createdAt": "2020-08-24T06:15:25Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.mqtt;\n+\n+import io.netty.util.internal.StringUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Payload for MQTT unsuback message as in V5.\n+ */\n+public final class MqttUnsubAckPayload {\n+\n+    private final List<Short> unsubscribeReasonCodes;\n+\n+    public MqttUnsubAckPayload(short... unsubscribeReasonCodes) {\n+        if (unsubscribeReasonCodes == null) {\n+            throw new NullPointerException(\"unsubscribeReasonCodes\");\n+        }\n+\n+        List<Short> list = new ArrayList<Short>(unsubscribeReasonCodes.length);\n+        for (Short v: unsubscribeReasonCodes) {\n+            list.add(v);\n+        }\n+        this.unsubscribeReasonCodes = Collections.unmodifiableList(list);\n+    }\n+\n+    public MqttUnsubAckPayload(Iterable<Short> unsubscribeReasonCodes) {\n+        if (unsubscribeReasonCodes == null) {\n+            throw new NullPointerException(\"unsubscribeReasonCodes\");", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMjk0Mw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r474812943", "bodyText": "No need to call static methods in the instance. Just call them directly.", "author": "chrisvest", "createdAt": "2020-08-21T16:50:07Z", "path": "codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java", "diffHunk": "@@ -67,12 +80,14 @@\n     public void setup() {\n         MockitoAnnotations.initMocks(this);\n         when(ctx.channel()).thenReturn(channel);\n+        when(ctx.alloc()).thenReturn(ALLOCATOR);\n+        when(channel.attr(MqttCodecUtil.MQTT_VERSION_KEY)).thenReturn(versionAttrMock);\n     }\n \n     @Test\n     public void testConnectMessageForMqtt31() throws Exception {\n         final MqttConnectMessage message = createConnectMessage(MqttVersion.MQTT_3_1);\n-        ByteBuf byteBuf = MqttEncoder.doEncode(ALLOCATOR, message);\n+        ByteBuf byteBuf = MqttEncoder.INSTANCE.doEncode(ctx, message);", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI3OTcyMg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r476279722", "bodyText": "I see you fixed this particular one, but there are many instances of this throughout the file \ud83d\ude05", "author": "chrisvest", "createdAt": "2020-08-25T08:41:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMjk0Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI5MTc1NA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r476291754", "bodyText": "oh, right :)", "author": "paul-lysak", "createdAt": "2020-08-25T09:00:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxMjk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDgxNjc5OA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r474816798", "bodyText": "The new exception makes sense, but I wonder if it's an API change. I don't see a lot of docs around this, so maybe it's unspecified.", "author": "chrisvest", "createdAt": "2020-08-21T16:57:42Z", "path": "codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java", "diffHunk": "@@ -295,8 +316,8 @@ public void testUnknownMessageType() throws Exception {\n             final MqttMessage decodedMessage = (MqttMessage) out.get(0);\n             assertTrue(decodedMessage.decoderResult().isFailure());\n             Throwable cause = decodedMessage.decoderResult().cause();\n-            assertTrue(cause instanceof IllegalArgumentException);\n-            assertEquals(\"unknown message type: 15\", cause.getMessage());\n+            assertTrue(cause instanceof DecoderException);", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ1MzgzMA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475453830", "bodyText": "Is it safe to rely on \"default\" encoding for these tests?", "author": "chrisvest", "createdAt": "2020-08-24T09:17:31Z", "path": "codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java", "diffHunk": "@@ -500,36 +801,57 @@ private static MqttMessage createMessageWithFixedHeaderAndMessageIdVariableHeade\n     }\n \n     private static MqttConnectMessage createConnectMessage(MqttVersion mqttVersion) {\n-        return createConnectMessage(mqttVersion, USER_NAME, PASSWORD);\n+        return createConnectMessage(mqttVersion,\n+                USER_NAME,\n+                PASSWORD,\n+                MqttProperties.NO_PROPERTIES,\n+                MqttProperties.NO_PROPERTIES);\n     }\n \n-    private static MqttConnectMessage createConnectMessage(MqttVersion mqttVersion, String username, String password) {\n+    private static MqttConnectMessage createConnectMessage(MqttVersion mqttVersion,\n+                                                           String username,\n+                                                           String password,\n+                                                           MqttProperties properties,\n+                                                           MqttProperties willProperties) {\n         return MqttMessageBuilders.connect()\n                 .clientId(CLIENT_ID)\n                 .protocolVersion(mqttVersion)\n                 .username(username)\n-                .password(password)\n+                .password(password.getBytes())", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjI2ODk1Nw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r476268957", "bodyText": "Changed to password.getBytes(CharsetUtil.UTF_8)", "author": "paul-lysak", "createdAt": "2020-08-25T08:24:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ1MzgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ1NTg5OQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475455899", "bodyText": "Can we keep both asserts, to cover the API surface?", "author": "chrisvest", "createdAt": "2020-08-24T09:20:56Z", "path": "codec-mqtt/src/test/java/io/netty/handler/codec/mqtt/MqttCodecTest.java", "diffHunk": "@@ -664,9 +1002,9 @@ private static void validateTopicSubscription(\n             MqttTopicSubscription actual) {\n         assertEquals(\"MqttTopicSubscription TopicName mismatch \", expected.topicName(), actual.topicName());\n         assertEquals(\n-                \"MqttTopicSubscription Qos mismatch \",\n-                expected.qualityOfService(),\n-                actual.qualityOfService());\n+                \"MqttTopicSubscription options mismatch \",\n+                expected.option(),\n+                actual.option());", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ2MDEzOQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475460139", "bodyText": "Please update the class javadoc to indicate that we also decode MQTT 5.0.", "author": "chrisvest", "createdAt": "2020-08-24T09:25:38Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -227,7 +240,7 @@ private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {\n         final int willQos = (b1 & 0x18) >> 3;\n         final boolean willFlag = (b1 & 0x04) == 0x04;\n         final boolean cleanSession = (b1 & 0x02) == 0x02;\n-        if (mqttVersion == MqttVersion.MQTT_3_1_1) {\n+        if (version == MqttVersion.MQTT_3_1_1 || version == MqttVersion.MQTT_5) {", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTQ3NDcwNw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r475474707", "bodyText": "Please update the class javadoc to indicate that we can also encode messages using MQTT version 5.0.", "author": "chrisvest", "createdAt": "2020-08-24T09:40:10Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -102,10 +111,11 @@ private static ByteBuf encodeConnectMessage(\n         MqttConnectPayload payload = message.payload();\n         MqttVersion mqttVersion = MqttVersion.fromProtocolNameAndLevel(variableHeader.name(),\n                 (byte) variableHeader.version());\n+        MqttCodecUtil.setMqttVersion(ctx, mqttVersion);", "originalCommit": "60a7360c49f19dc60ba8e908ca1d5707cb78b918", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6908317339952efbb8397bd93359bff7ff597245", "url": "https://github.com/netty/netty/commit/6908317339952efbb8397bd93359bff7ff597245", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  added attribute `NETTY_CODEC_MQTT_VERSION` to track protocol version\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-25T07:28:03Z", "type": "forcePushed"}, {"oid": "6652e05cd5f625287ae1e2fea358ea4a03dfca02", "url": "https://github.com/netty/netty/commit/6652e05cd5f625287ae1e2fea358ea4a03dfca02", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  added attribute `NETTY_CODEC_MQTT_VERSION` to track protocol version\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-25T08:22:19Z", "type": "forcePushed"}, {"oid": "f577a8d28bd469a612635813d7b743680e6c3a08", "url": "https://github.com/netty/netty/commit/f577a8d28bd469a612635813d7b743680e6c3a08", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  added attribute `NETTY_CODEC_MQTT_VERSION` to track protocol version\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-25T08:59:25Z", "type": "forcePushed"}, {"oid": "42794df42a9cffcd5610e527213f7b610b087a47", "url": "https://github.com/netty/netty/commit/42794df42a9cffcd5610e527213f7b610b087a47", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  added attribute `NETTY_CODEC_MQTT_VERSION` to track protocol version\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-26T07:25:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE5MzAyNA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r477193024", "bodyText": "There's a lot of integers in this file, 1, 2, 4, 0x04, 0x08, 0x01, etc. Would be nice if they were named constants.", "author": "chrisvest", "createdAt": "2020-08-26T10:16:32Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttEncoder.java", "diffHunk": "@@ -196,138 +230,270 @@ private static int getConnVariableHeaderFlag(MqttConnectVariableHeader variableH\n     }\n \n     private static ByteBuf encodeConnAckMessage(\n-            ByteBufAllocator byteBufAllocator,\n+            ChannelHandlerContext ctx,\n             MqttConnAckMessage message) {\n-        ByteBuf buf = byteBufAllocator.buffer(4);\n-        buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n-        buf.writeByte(2);\n-        buf.writeByte(message.variableHeader().isSessionPresent() ? 0x01 : 0x00);\n-        buf.writeByte(message.variableHeader().connectReturnCode().byteValue());\n-\n-        return buf;\n+        final MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                ctx.alloc(),\n+                message.variableHeader().properties());\n+\n+        try {\n+            ByteBuf buf = ctx.alloc().buffer(4 + propertiesBuf.readableBytes());\n+            buf.writeByte(getFixedHeaderByte1(message.fixedHeader()));\n+            writeVariableLengthInt(buf, 2 + propertiesBuf.readableBytes());\n+            buf.writeByte(message.variableHeader().isSessionPresent() ? 0x01 : 0x00);\n+            buf.writeByte(message.variableHeader().connectReturnCode().byteValue());\n+            buf.writeBytes(propertiesBuf);\n+            return buf;\n+        } finally {\n+            propertiesBuf.release();\n+        }\n     }\n \n     private static ByteBuf encodeSubscribeMessage(\n-            ByteBufAllocator byteBufAllocator,\n+            ChannelHandlerContext ctx,\n             MqttSubscribeMessage message) {\n-        int variableHeaderBufferSize = 2;\n-        int payloadBufferSize = 0;\n-\n-        MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n-        MqttMessageIdVariableHeader variableHeader = message.variableHeader();\n-        MqttSubscribePayload payload = message.payload();\n-\n-        for (MqttTopicSubscription topic : payload.topicSubscriptions()) {\n-            String topicName = topic.topicName();\n-            byte[] topicNameBytes = encodeStringUtf8(topicName);\n-            payloadBufferSize += 2 + topicNameBytes.length;\n-            payloadBufferSize += 1;\n-        }\n-\n-        int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n-        int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n-\n-        ByteBuf buf = byteBufAllocator.buffer(fixedHeaderBufferSize + variablePartSize);\n-        buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n-        writeVariableLengthInt(buf, variablePartSize);\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                ctx.alloc(),\n+                message.idAndPropertiesVariableHeader().properties());\n+\n+        try {\n+            final int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();\n+            int payloadBufferSize = 0;\n+\n+            MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n+            MqttMessageIdVariableHeader variableHeader = message.variableHeader();\n+            MqttSubscribePayload payload = message.payload();\n+\n+            for (MqttTopicSubscription topic : payload.topicSubscriptions()) {\n+                String topicName = topic.topicName();\n+                byte[] topicNameBytes = encodeStringUtf8(topicName);\n+                payloadBufferSize += 2 + topicNameBytes.length;\n+                payloadBufferSize += 1;\n+            }\n \n-        // Variable Header\n-        int messageId = variableHeader.messageId();\n-        buf.writeShort(messageId);\n+            int variablePartSize = variableHeaderBufferSize + payloadBufferSize;\n+            int fixedHeaderBufferSize = 1 + getVariableLengthInt(variablePartSize);\n+\n+            ByteBuf buf = ctx.alloc().buffer(fixedHeaderBufferSize + variablePartSize);\n+            buf.writeByte(getFixedHeaderByte1(mqttFixedHeader));\n+            writeVariableLengthInt(buf, variablePartSize);\n+\n+            // Variable Header\n+            int messageId = variableHeader.messageId();\n+            buf.writeShort(messageId);\n+            buf.writeBytes(propertiesBuf);\n+\n+            // Payload\n+            for (MqttTopicSubscription topic : payload.topicSubscriptions()) {\n+                writeUTF8String(buf, topic.topicName());\n+                final MqttSubscriptionOption option = topic.option();\n+\n+                int optionEncoded = option.retainHandling().value() << 4;\n+                if (option.isRetainAsPublished()) {\n+                    optionEncoded |= 0x08;\n+                }\n+                if (option.isNoLocal()) {\n+                    optionEncoded |= 0x04;\n+                }\n+                optionEncoded |= option.qos().value();\n+\n+                buf.writeByte(optionEncoded);\n+            }\n \n-        // Payload\n-        for (MqttTopicSubscription topic : payload.topicSubscriptions()) {\n-            String topicName = topic.topicName();\n-            byte[] topicNameBytes = encodeStringUtf8(topicName);\n-            buf.writeShort(topicNameBytes.length);\n-            buf.writeBytes(topicNameBytes, 0, topicNameBytes.length);\n-            buf.writeByte(topic.qualityOfService().value());\n+            return buf;\n+        } finally {\n+            propertiesBuf.release();\n         }\n-\n-        return buf;\n     }\n \n     private static ByteBuf encodeUnsubscribeMessage(\n-            ByteBufAllocator byteBufAllocator,\n+            ChannelHandlerContext ctx,\n             MqttUnsubscribeMessage message) {\n-        int variableHeaderBufferSize = 2;\n-        int payloadBufferSize = 0;\n-\n-        MqttFixedHeader mqttFixedHeader = message.fixedHeader();\n-        MqttMessageIdVariableHeader variableHeader = message.variableHeader();\n-        MqttUnsubscribePayload payload = message.payload();\n+        MqttVersion mqttVersion = MqttCodecUtil.getMqttVersion(ctx);\n+        ByteBuf propertiesBuf = encodePropertiesIfNeeded(mqttVersion,\n+                ctx.alloc(),\n+                message.idAndPropertiesVariableHeader().properties());\n+\n+        try {\n+            final int variableHeaderBufferSize = 2 + propertiesBuf.readableBytes();", "originalCommit": "42794df42a9cffcd5610e527213f7b610b087a47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzM1Njg2Mw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r477356863", "bodyText": "Eventually, this may be a nice improvement. I think, better do it as a separate PR - refactoring can be done infinitely long :)", "author": "paul-lysak", "createdAt": "2020-08-26T14:43:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzE5MzAyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQyNzM0MQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r477427341", "bodyText": "Remove this getter?", "author": "johnou", "createdAt": "2020-08-26T16:22:11Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttSubscriptionOption.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.mqtt;\n+\n+/**\n+ * Model the SubscriptionOption used in Subscribe MQTT v5 packet\n+ */\n+public final class MqttSubscriptionOption {\n+\n+    enum RetainedHandlingPolicy {\n+        SEND_AT_SUBSCRIBE(0),\n+        SEND_AT_SUBSCRIBE_IF_NOT_YET_EXISTS(1),\n+        DONT_SEND_AT_SUBSCRIBE(2);\n+\n+        private final int value;\n+\n+        RetainedHandlingPolicy(int value) {\n+            this.value = value;\n+        }\n+\n+        public int value() {\n+            return value;\n+        }\n+\n+        public static RetainedHandlingPolicy valueOf(int value) {\n+            for (RetainedHandlingPolicy q: values()) {\n+                if (q.value == value) {\n+                    return q;\n+                }\n+            }\n+            throw new IllegalArgumentException(\"invalid RetainedHandlingPolicy: \" + value);\n+        }\n+    }\n+\n+    private final MqttQoS qos;\n+    private final boolean noLocal;\n+    private final boolean retainAsPublished;\n+    private final RetainedHandlingPolicy retainHandling;\n+\n+    public static MqttSubscriptionOption onlyFromQos(MqttQoS qos) {\n+        return new MqttSubscriptionOption(qos, false, false, RetainedHandlingPolicy.SEND_AT_SUBSCRIBE);\n+    }\n+\n+    public MqttSubscriptionOption(MqttQoS qos,\n+                                  boolean noLocal,\n+                                  boolean retainAsPublished,\n+                                  RetainedHandlingPolicy retainHandling) {\n+        this.qos = qos;\n+        this.noLocal = noLocal;\n+        this.retainAsPublished = retainAsPublished;\n+        this.retainHandling = retainHandling;\n+    }\n+\n+    public MqttQoS qos() {\n+        return qos;\n+    }\n+\n+    public MqttQoS getQos() {", "originalCommit": "42794df42a9cffcd5610e527213f7b610b087a47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE4ODE2Mg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r478188162", "bodyText": "@paul-lysak ^^", "author": "normanmaurer", "createdAt": "2020-08-27T06:41:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQyNzM0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQyNzg4Mg==", "url": "https://github.com/netty/netty/pull/10483#discussion_r477427882", "bodyText": "Break or continue?", "author": "johnou", "createdAt": "2020-08-26T16:23:07Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttUnsubAckPayload.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2020 The Netty Project\n+ *\n+ * The Netty Project licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package io.netty.handler.codec.mqtt;\n+\n+import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.StringUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+/**\n+ * Payload for MQTT unsuback message as in V5.\n+ */\n+public final class MqttUnsubAckPayload {\n+\n+    private final List<Short> unsubscribeReasonCodes;\n+\n+    public MqttUnsubAckPayload(short... unsubscribeReasonCodes) {\n+        ObjectUtil.checkNotNull(unsubscribeReasonCodes, \"unsubscribeReasonCodes\");\n+\n+        List<Short> list = new ArrayList<Short>(unsubscribeReasonCodes.length);\n+        for (Short v: unsubscribeReasonCodes) {\n+            list.add(v);\n+        }\n+        this.unsubscribeReasonCodes = Collections.unmodifiableList(list);\n+    }\n+\n+    public MqttUnsubAckPayload(Iterable<Short> unsubscribeReasonCodes) {\n+        ObjectUtil.checkNotNull(unsubscribeReasonCodes, \"unsubscribeReasonCodes\");\n+\n+        List<Short> list = new ArrayList<Short>();\n+        for (Short v: unsubscribeReasonCodes) {\n+            if (v == null) {\n+                break;", "originalCommit": "42794df42a9cffcd5610e527213f7b610b087a47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODE5NTc5Mw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r478195793", "bodyText": "imo makes sense to filter out nulls (continue), not stop on the first null value.", "author": "johnou", "createdAt": "2020-08-27T06:52:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQyNzg4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyMzE1Mw==", "url": "https://github.com/netty/netty/pull/10483#discussion_r478223153", "bodyText": "Going to change it to throw exceptions - nulls aren't actually valid here. And if you've sent UNSUBSCRIBE for N topics, you'd expect N reason codes in UNSUBACK in MQTT 5 - having some other number is a protocol violation.", "author": "paul-lysak", "createdAt": "2020-08-27T07:46:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQyNzg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxNzA3OQ==", "url": "https://github.com/netty/netty/pull/10483#discussion_r478217079", "bodyText": "Given nothing was parsed in the past for old mqtt protocol is this change compatible?", "author": "johnou", "createdAt": "2020-08-27T07:35:52Z", "path": "codec-mqtt/src/main/java/io/netty/handler/codec/mqtt/MqttDecoder.java", "diffHunk": "@@ -176,44 +182,54 @@ private static MqttFixedHeader decodeFixedHeader(ByteBuf buffer) {\n      * @param mqttFixedHeader MqttFixedHeader of the same message\n      * @return the variable header\n      */\n-    private static Result<?> decodeVariableHeader(ByteBuf buffer, MqttFixedHeader mqttFixedHeader) {\n+    private Result<?> decodeVariableHeader(ChannelHandlerContext ctx, ByteBuf buffer, MqttFixedHeader mqttFixedHeader) {\n         switch (mqttFixedHeader.messageType()) {\n             case CONNECT:\n-                return decodeConnectionVariableHeader(buffer);\n+                return decodeConnectionVariableHeader(ctx, buffer);\n \n             case CONNACK:\n-                return decodeConnAckVariableHeader(buffer);\n+                return decodeConnAckVariableHeader(ctx, buffer);\n \n-            case SUBSCRIBE:\n             case UNSUBSCRIBE:\n+            case SUBSCRIBE:\n             case SUBACK:\n             case UNSUBACK:\n+                return decodeMessageIdAndPropertiesVariableHeader(ctx, buffer);\n+\n             case PUBACK:\n             case PUBREC:\n             case PUBCOMP:\n             case PUBREL:\n-                return decodeMessageIdVariableHeader(buffer);\n+                return decodePubReplyMessage(buffer);\n \n             case PUBLISH:\n-                return decodePublishVariableHeader(buffer, mqttFixedHeader);\n+                return decodePublishVariableHeader(ctx, buffer, mqttFixedHeader);\n+\n+            case DISCONNECT:\n+            case AUTH:\n+                return decodeReasonCodeAndPropertiesVariableHeader(buffer);", "originalCommit": "42794df42a9cffcd5610e527213f7b610b087a47", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIyNjgxOA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r478226818", "bodyText": "decodeReasonCodeAndPropertiesVariableHeader checks for bytesRemainingInVariablePart. If there's no bytes remaining it will substitute default values in MqttReasonCodeAndPropertiesVariableHeader (reason code 0 and no properties).", "author": "paul-lysak", "createdAt": "2020-08-27T07:53:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxNzA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI3ODQ4NA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r478278484", "bodyText": "@johnou I think this should work... any concerns ?", "author": "normanmaurer", "createdAt": "2020-08-27T09:21:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxNzA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODg2NDk3Ng==", "url": "https://github.com/netty/netty/pull/10483#discussion_r478864976", "bodyText": "@johnou please resolve if you agree and if not leave another comment", "author": "normanmaurer", "createdAt": "2020-08-28T06:48:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxNzA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTYyMzQ2NA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r479623464", "bodyText": "Cannot resolve, change was force pushed.", "author": "johnou", "createdAt": "2020-08-29T08:02:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxNzA3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTYyMzY1OA==", "url": "https://github.com/netty/netty/pull/10483#discussion_r479623658", "bodyText": "But yes I agree, should be okay.", "author": "johnou", "createdAt": "2020-08-29T08:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIxNzA3OQ=="}], "type": "inlineReview"}, {"oid": "9af3e57fb557a3c32c83a2ecf84d5684a83b30cc", "url": "https://github.com/netty/netty/commit/9af3e57fb557a3c32c83a2ecf84d5684a83b30cc", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  added attribute `NETTY_CODEC_MQTT_VERSION` to track protocol version\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-27T07:55:37Z", "type": "commit"}, {"oid": "9af3e57fb557a3c32c83a2ecf84d5684a83b30cc", "url": "https://github.com/netty/netty/commit/9af3e57fb557a3c32c83a2ecf84d5684a83b30cc", "message": "MQTT5 support for netty-codec-mqtt\n\nMotivation:\n\n MQTT Specification version 5 was released over a year ago,\n netty-codec-mqtt should be changed to support it.\n\nModifications:\n\n  Added more message and header types in `io.netty.handler.codec.mqtt`\n  package in `netty-coded-mqtt` subproject,\n  changed `MqttEncoder` and `MqttDecoder` to handle them properly,\n  added attribute `NETTY_CODEC_MQTT_VERSION` to track protocol version\n\nResult:\n\n  `netty-coded-mqtt` supports both MQTT5 and MQTT3 now.", "committedDate": "2020-08-27T07:55:37Z", "type": "forcePushed"}]}