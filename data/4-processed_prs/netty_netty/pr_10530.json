{"pr_number": 10530, "pr_title": "Reduce DefaultAttributeMap cost", "pr_createdAt": "2020-09-03T17:46:55Z", "pr_url": "https://github.com/netty/netty/pull/10530", "timeline": [{"oid": "550fde8c43ea72486b764c9f64c1a03ad0871c80", "url": "https://github.com/netty/netty/commit/550fde8c43ea72486b764c9f64c1a03ad0871c80", "message": "Reduce DefaultAttributeMap cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour even on an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table with a locked intrusive linked list\nwith JCTools NonBlockingIdentityHashMap\n\nResult:\nNon blocking behaviour for the happy path, in case of hash collisions", "committedDate": "2020-09-03T17:53:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4MTc5OQ==", "url": "https://github.com/netty/netty/pull/10530#discussion_r483181799", "bodyText": "nit: ;;", "author": "normanmaurer", "createdAt": "2020-09-03T18:39:54Z", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -16,187 +16,176 @@\n package io.netty.util;\n \n import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.SystemPropertyUtil;\n+import org.jctools.maps.NonBlockingIdentityHashMap;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.SystemPropertyUtil.*;\n+import static java.lang.Math.*;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n-\n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final int INITIAL_CAPACITY = max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4));\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n+    // Initialize lazily to reduce memory consumption\n     @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n+    private volatile NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Attribute<T> attr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n+            synchronized (this) {\n                 attributes = this.attributes;\n+                if (attributes == null) {\n+                    attributes = new NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>>(INITIAL_CAPACITY);\n+                    this.attributes = attributes;\n+                }\n             }\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        DefaultAttribute<T> newAttribute = null;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        for (; ;) {", "originalCommit": "550fde8c43ea72486b764c9f64c1a03ad0871c80", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4MjAxNQ==", "url": "https://github.com/netty/netty/pull/10530#discussion_r483182015", "bodyText": "nit: you can remove the else", "author": "normanmaurer", "createdAt": "2020-09-03T18:40:19Z", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -16,187 +16,176 @@\n package io.netty.util;\n \n import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.SystemPropertyUtil;\n+import org.jctools.maps.NonBlockingIdentityHashMap;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.SystemPropertyUtil.*;\n+import static java.lang.Math.*;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n-\n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final int INITIAL_CAPACITY = max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4));\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n+    // Initialize lazily to reduce memory consumption\n     @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n+    private volatile NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Attribute<T> attr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n+            synchronized (this) {\n                 attributes = this.attributes;\n+                if (attributes == null) {\n+                    attributes = new NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>>(INITIAL_CAPACITY);\n+                    this.attributes = attributes;\n+                }\n             }\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        DefaultAttribute<T> newAttribute = null;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        for (; ;) {\n+            if (attribute != null && !attribute.removed()) {\n+                return (Attribute<T>) attribute;\n             }\n-        }\n-\n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n+            if (newAttribute == null) {\n+                newAttribute = new DefaultAttribute<T>(attributes, key);\n+            }\n+            if (attribute != null) {\n+                if (attributes.replace(key, attribute, newAttribute)) {\n+                    return newAttribute;\n+                } else {", "originalCommit": "550fde8c43ea72486b764c9f64c1a03ad0871c80", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4Mjk2NA==", "url": "https://github.com/netty/netty/pull/10530#discussion_r483182964", "bodyText": "nit: merge with above line", "author": "normanmaurer", "createdAt": "2020-09-03T18:42:07Z", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -16,187 +16,176 @@\n package io.netty.util;\n \n import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.SystemPropertyUtil;\n+import org.jctools.maps.NonBlockingIdentityHashMap;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.SystemPropertyUtil.*;\n+import static java.lang.Math.*;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n-\n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final int INITIAL_CAPACITY = max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4));\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n+    // Initialize lazily to reduce memory consumption\n     @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n+    private volatile NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Attribute<T> attr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n+            synchronized (this) {\n                 attributes = this.attributes;\n+                if (attributes == null) {\n+                    attributes = new NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>>(INITIAL_CAPACITY);\n+                    this.attributes = attributes;\n+                }\n             }\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        DefaultAttribute<T> newAttribute = null;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        for (; ;) {\n+            if (attribute != null && !attribute.removed()) {\n+                return (Attribute<T>) attribute;\n             }\n-        }\n-\n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n+            if (newAttribute == null) {\n+                newAttribute = new DefaultAttribute<T>(attributes, key);\n+            }\n+            if (attribute != null) {\n+                if (attributes.replace(key, attribute, newAttribute)) {\n+                    return newAttribute;\n+                } else {\n+                    attribute = attributes.get(key);\n                 }\n-\n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+            } else {\n+                attribute = attributes.putIfAbsent(key, newAttribute);\n+                if (attribute == null) {\n+                    return newAttribute;\n                 }\n-                curr = next;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        final NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n             // no attribute exists\n             return false;\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n-\n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n-            }\n-            return false;\n-        }\n-    }\n-\n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        return attribute != null & !attribute.removed();\n     }\n \n     @SuppressWarnings(\"serial\")\n-    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n+    private static final class DefaultAttribute<T> implements Attribute<T> {\n+\n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, Object> VALUE_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class, Object.class, \"value\");\n \n+        private static final Object REMOVED = new Object();\n         private static final long serialVersionUID = -2661411462200283011L;\n \n-        // The head of the linked-list this attribute belongs to\n-        private final DefaultAttribute<?> head;\n+        private final NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n         private final AttributeKey<T> key;\n+        private volatile Object value;\n \n-        // Double-linked list to prev and next node to allow fast removal\n-        private DefaultAttribute<?> prev;\n-        private DefaultAttribute<?> next;\n+        DefaultAttribute(NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes,\n+                         AttributeKey<T> key) {\n+            this.attributes = attributes;\n+            this.key = key;\n+        }\n \n-        // Will be set to true one the attribute is removed via getAndRemove() or remove()\n-        private volatile boolean removed;\n+        @Override\n+        public AttributeKey<T> key() {\n+            return key;\n+        }\n \n-        DefaultAttribute(DefaultAttribute<?> head, AttributeKey<T> key) {\n-            this.head = head;\n-            this.key = key;\n+        @Override\n+        public T get() {\n+            Object v = value;\n+            return v == REMOVED? null : (T) v;\n         }\n \n-        // Special constructor for the head of the linked-list.\n-        DefaultAttribute() {\n-            head = this;\n-            key = null;\n+        public boolean removed() {\n+            return value == REMOVED;\n         }\n \n         @Override\n-        public AttributeKey<T> key() {\n-            return key;\n+        public void set(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return;\n+                }\n+            }\n+            while (!VALUE_UPDATER.compareAndSet(this, old, value));", "originalCommit": "550fde8c43ea72486b764c9f64c1a03ad0871c80", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4MzEyNQ==", "url": "https://github.com/netty/netty/pull/10530#discussion_r483183125", "bodyText": "nit: merge with above line", "author": "normanmaurer", "createdAt": "2020-09-03T18:42:27Z", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -16,187 +16,176 @@\n package io.netty.util;\n \n import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.SystemPropertyUtil;\n+import org.jctools.maps.NonBlockingIdentityHashMap;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.SystemPropertyUtil.*;\n+import static java.lang.Math.*;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n-\n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final int INITIAL_CAPACITY = max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4));\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n+    // Initialize lazily to reduce memory consumption\n     @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n+    private volatile NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Attribute<T> attr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n+            synchronized (this) {\n                 attributes = this.attributes;\n+                if (attributes == null) {\n+                    attributes = new NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>>(INITIAL_CAPACITY);\n+                    this.attributes = attributes;\n+                }\n             }\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        DefaultAttribute<T> newAttribute = null;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        for (; ;) {\n+            if (attribute != null && !attribute.removed()) {\n+                return (Attribute<T>) attribute;\n             }\n-        }\n-\n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n+            if (newAttribute == null) {\n+                newAttribute = new DefaultAttribute<T>(attributes, key);\n+            }\n+            if (attribute != null) {\n+                if (attributes.replace(key, attribute, newAttribute)) {\n+                    return newAttribute;\n+                } else {\n+                    attribute = attributes.get(key);\n                 }\n-\n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+            } else {\n+                attribute = attributes.putIfAbsent(key, newAttribute);\n+                if (attribute == null) {\n+                    return newAttribute;\n                 }\n-                curr = next;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        final NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n             // no attribute exists\n             return false;\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n-\n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n-            }\n-            return false;\n-        }\n-    }\n-\n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        return attribute != null & !attribute.removed();\n     }\n \n     @SuppressWarnings(\"serial\")\n-    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n+    private static final class DefaultAttribute<T> implements Attribute<T> {\n+\n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, Object> VALUE_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class, Object.class, \"value\");\n \n+        private static final Object REMOVED = new Object();\n         private static final long serialVersionUID = -2661411462200283011L;\n \n-        // The head of the linked-list this attribute belongs to\n-        private final DefaultAttribute<?> head;\n+        private final NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n         private final AttributeKey<T> key;\n+        private volatile Object value;\n \n-        // Double-linked list to prev and next node to allow fast removal\n-        private DefaultAttribute<?> prev;\n-        private DefaultAttribute<?> next;\n+        DefaultAttribute(NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes,\n+                         AttributeKey<T> key) {\n+            this.attributes = attributes;\n+            this.key = key;\n+        }\n \n-        // Will be set to true one the attribute is removed via getAndRemove() or remove()\n-        private volatile boolean removed;\n+        @Override\n+        public AttributeKey<T> key() {\n+            return key;\n+        }\n \n-        DefaultAttribute(DefaultAttribute<?> head, AttributeKey<T> key) {\n-            this.head = head;\n-            this.key = key;\n+        @Override\n+        public T get() {\n+            Object v = value;\n+            return v == REMOVED? null : (T) v;\n         }\n \n-        // Special constructor for the head of the linked-list.\n-        DefaultAttribute() {\n-            head = this;\n-            key = null;\n+        public boolean removed() {\n+            return value == REMOVED;\n         }\n \n         @Override\n-        public AttributeKey<T> key() {\n-            return key;\n+        public void set(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return;\n+                }\n+            }\n+            while (!VALUE_UPDATER.compareAndSet(this, old, value));\n+        }\n+\n+        @Override\n+        public T getAndSet(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return null;\n+                }\n+            }\n+            while (!VALUE_UPDATER.compareAndSet(this, old, value));", "originalCommit": "550fde8c43ea72486b764c9f64c1a03ad0871c80", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzE4MzMwMA==", "url": "https://github.com/netty/netty/pull/10530#discussion_r483183300", "bodyText": "nit: merge with above line", "author": "normanmaurer", "createdAt": "2020-09-03T18:42:50Z", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -16,187 +16,176 @@\n package io.netty.util;\n \n import io.netty.util.internal.ObjectUtil;\n+import io.netty.util.internal.SystemPropertyUtil;\n+import org.jctools.maps.NonBlockingIdentityHashMap;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.SystemPropertyUtil.*;\n+import static java.lang.Math.*;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n-\n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final int INITIAL_CAPACITY = max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4));\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n+    // Initialize lazily to reduce memory consumption\n     @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n+    private volatile NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Attribute<T> attr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n+            synchronized (this) {\n                 attributes = this.attributes;\n+                if (attributes == null) {\n+                    attributes = new NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>>(INITIAL_CAPACITY);\n+                    this.attributes = attributes;\n+                }\n             }\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        DefaultAttribute<T> newAttribute = null;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        for (; ;) {\n+            if (attribute != null && !attribute.removed()) {\n+                return (Attribute<T>) attribute;\n             }\n-        }\n-\n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n+            if (newAttribute == null) {\n+                newAttribute = new DefaultAttribute<T>(attributes, key);\n+            }\n+            if (attribute != null) {\n+                if (attributes.replace(key, attribute, newAttribute)) {\n+                    return newAttribute;\n+                } else {\n+                    attribute = attributes.get(key);\n                 }\n-\n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+            } else {\n+                attribute = attributes.putIfAbsent(key, newAttribute);\n+                if (attribute == null) {\n+                    return newAttribute;\n                 }\n-                curr = next;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n+        final NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes = this.attributes;\n         if (attributes == null) {\n             // no attribute exists\n             return false;\n         }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n-\n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n-            }\n-            return false;\n-        }\n-    }\n-\n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n+        DefaultAttribute<?> attribute = attributes.get(key);\n+        return attribute != null & !attribute.removed();\n     }\n \n     @SuppressWarnings(\"serial\")\n-    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n+    private static final class DefaultAttribute<T> implements Attribute<T> {\n+\n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, Object> VALUE_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class, Object.class, \"value\");\n \n+        private static final Object REMOVED = new Object();\n         private static final long serialVersionUID = -2661411462200283011L;\n \n-        // The head of the linked-list this attribute belongs to\n-        private final DefaultAttribute<?> head;\n+        private final NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes;\n         private final AttributeKey<T> key;\n+        private volatile Object value;\n \n-        // Double-linked list to prev and next node to allow fast removal\n-        private DefaultAttribute<?> prev;\n-        private DefaultAttribute<?> next;\n+        DefaultAttribute(NonBlockingIdentityHashMap<AttributeKey<?>, DefaultAttribute<?>> attributes,\n+                         AttributeKey<T> key) {\n+            this.attributes = attributes;\n+            this.key = key;\n+        }\n \n-        // Will be set to true one the attribute is removed via getAndRemove() or remove()\n-        private volatile boolean removed;\n+        @Override\n+        public AttributeKey<T> key() {\n+            return key;\n+        }\n \n-        DefaultAttribute(DefaultAttribute<?> head, AttributeKey<T> key) {\n-            this.head = head;\n-            this.key = key;\n+        @Override\n+        public T get() {\n+            Object v = value;\n+            return v == REMOVED? null : (T) v;\n         }\n \n-        // Special constructor for the head of the linked-list.\n-        DefaultAttribute() {\n-            head = this;\n-            key = null;\n+        public boolean removed() {\n+            return value == REMOVED;\n         }\n \n         @Override\n-        public AttributeKey<T> key() {\n-            return key;\n+        public void set(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return;\n+                }\n+            }\n+            while (!VALUE_UPDATER.compareAndSet(this, old, value));\n+        }\n+\n+        @Override\n+        public T getAndSet(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return null;\n+                }\n+            }\n+            while (!VALUE_UPDATER.compareAndSet(this, old, value));\n+            return (T) old;\n         }\n \n         @Override\n         public T setIfAbsent(T value) {\n-            while (!compareAndSet(null, value)) {\n-                T old = get();\n+            do {\n+                final Object old = this.value;\n                 if (old != null) {\n-                    return old;\n+                    if (old == REMOVED) {\n+                        // a subsequent get should return null regardless the current value\n+                        // given that remove has been called\n+                        return null;\n+                    }\n+                    return (T) old;\n                 }\n             }\n+            while (!compareAndSet(null, value));", "originalCommit": "550fde8c43ea72486b764c9f64c1a03ad0871c80", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "014723678b39a2f17be393b60ce95642fdc8ec0b", "url": "https://github.com/netty/netty/commit/014723678b39a2f17be393b60ce95642fdc8ec0b", "message": "Reduce DefaultAttributeMap cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour even on an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith JCTools NonBlockingIdentityHashMap\n\nResult:\nNon blocking behaviour for the happy path, in case of hash collisions", "committedDate": "2020-09-03T19:09:13Z", "type": "forcePushed"}, {"oid": "54da1139e36598fecdfea30d4d866ff6fc38a350", "url": "https://github.com/netty/netty/commit/54da1139e36598fecdfea30d4d866ff6fc38a350", "message": "Reduce DefaultAttributeMap cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour even on an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith JCTools NonBlockingIdentityHashMap\n\nResult:\nNon blocking behaviour for the happy path, in case of hash collisions", "committedDate": "2020-09-03T19:34:15Z", "type": "forcePushed"}, {"oid": "dc4dc072b755efc9b0f4a6a6289c5543dce0df97", "url": "https://github.com/netty/netty/commit/dc4dc072b755efc9b0f4a6a6289c5543dce0df97", "message": "Reduce DefaultAttributeMap cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour even on an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write IdentityHashMap\n\nResult:\nNon blocking behaviour for the happy path, in case of hash collisions", "committedDate": "2020-09-04T07:41:19Z", "type": "forcePushed"}, {"oid": "b2d755fdde3f53e1cb9595bcd93fc642324f57cc", "url": "https://github.com/netty/netty/commit/b2d755fdde3f53e1cb9595bcd93fc642324f57cc", "message": "Reduce DefaultAttributeMap cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour even on an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered matrix\n\nResult:\nNon blocking behaviour for the happy path, in case of hash collisions", "committedDate": "2020-09-04T15:10:47Z", "type": "forcePushed"}, {"oid": "b6200e59d5efaf513aaabdba014c9764c0f08d6d", "url": "https://github.com/netty/netty/commit/b6200e59d5efaf513aaabdba014c9764c0f08d6d", "message": "Reduce DefaultAttributeMap cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour even on an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered matrix\n\nResult:\nNon blocking behaviour for the happy path, in case of hash collisions", "committedDate": "2020-09-04T16:06:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzczMjY0NA==", "url": "https://github.com/netty/netty/pull/10530#discussion_r483732644", "bodyText": "nit: could inline", "author": "njhill", "createdAt": "2020-09-04T16:32:25Z", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,265 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.Arrays;\n+import java.util.Comparator;\n import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.MathUtil.*;\n+import static io.netty.util.internal.SystemPropertyUtil.getInt;\n+import static java.lang.Math.max;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n+    private static final int INITIAL_CAPACITY = findNextPositivePowerOfTwo(\n+            max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4)));\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> ATTRIBUTES_UPDATER =\n             AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+    private static final Comparator<Object> ID_COMPARATOR = new Comparator<Object>() {\n+        @Override\n+        public int compare(Object o, Object t1) {\n+            DefaultAttribute attribute = (DefaultAttribute) o;\n+            final int attributeKeyId = attribute.key.id();\n+            final int keyId;\n+            if (t1 instanceof AttributeKey) {\n+                AttributeKey key = (AttributeKey) t1;\n+                keyId = key.id();", "originalCommit": "b6200e59d5efaf513aaabdba014c9764c0f08d6d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzczMjgxOA==", "url": "https://github.com/netty/netty/pull/10530#discussion_r483732818", "bodyText": "nit: inline", "author": "njhill", "createdAt": "2020-09-04T16:32:39Z", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,265 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.Arrays;\n+import java.util.Comparator;\n import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.MathUtil.*;\n+import static io.netty.util.internal.SystemPropertyUtil.getInt;\n+import static java.lang.Math.max;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n+    private static final int INITIAL_CAPACITY = findNextPositivePowerOfTwo(\n+            max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4)));\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> ATTRIBUTES_UPDATER =\n             AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+    private static final Comparator<Object> ID_COMPARATOR = new Comparator<Object>() {\n+        @Override\n+        public int compare(Object o, Object t1) {\n+            DefaultAttribute attribute = (DefaultAttribute) o;\n+            final int attributeKeyId = attribute.key.id();\n+            final int keyId;\n+            if (t1 instanceof AttributeKey) {\n+                AttributeKey key = (AttributeKey) t1;\n+                keyId = key.id();\n+            } else {\n+                DefaultAttribute attribute1 = (DefaultAttribute) t1;\n+                keyId = attribute1.key.id();", "originalCommit": "b6200e59d5efaf513aaabdba014c9764c0f08d6d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzczMzMzMQ==", "url": "https://github.com/netty/netty/pull/10530#discussion_r483733331", "bodyText": "nit: return Integer.compare(attributeKeyId, keyId);", "author": "njhill", "createdAt": "2020-09-04T16:33:22Z", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,265 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n+import java.util.Arrays;\n+import java.util.Comparator;\n import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n+import static io.netty.util.internal.MathUtil.*;\n+import static io.netty.util.internal.SystemPropertyUtil.getInt;\n+import static java.lang.Math.max;\n+\n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour if not on the first {@link\n+ * #attr(AttributeKey)} call.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n+    private static final int INITIAL_CAPACITY = findNextPositivePowerOfTwo(\n+            max(4, getInt(\"io.netty.defaultAttributeMapInitialCapacity\", 4)));\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> ATTRIBUTES_UPDATER =\n             AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+    private static final Comparator<Object> ID_COMPARATOR = new Comparator<Object>() {\n+        @Override\n+        public int compare(Object o, Object t1) {\n+            DefaultAttribute attribute = (DefaultAttribute) o;\n+            final int attributeKeyId = attribute.key.id();\n+            final int keyId;\n+            if (t1 instanceof AttributeKey) {\n+                AttributeKey key = (AttributeKey) t1;\n+                keyId = key.id();\n+            } else {\n+                DefaultAttribute attribute1 = (DefaultAttribute) t1;\n+                keyId = attribute1.key.id();\n+            }\n+            return attributeKeyId < keyId? -1 : (attributeKeyId == keyId? 0 : 1);", "originalCommit": "b6200e59d5efaf513aaabdba014c9764c0f08d6d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzczODMyMQ==", "url": "https://github.com/netty/netty/pull/10530#discussion_r483738321", "bodyText": "Netty 4 won't allow java 8 specific methods", "author": "franz1981", "createdAt": "2020-09-04T16:39:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzczMzMzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc0MDQxNA==", "url": "https://github.com/netty/netty/pull/10530#discussion_r483740414", "bodyText": "ah \ud83d\udc4d good point", "author": "njhill", "createdAt": "2020-09-04T16:42:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzczMzMzMQ=="}], "type": "inlineReview"}, {"oid": "51f3b65464fd2b04337f901dc3671990350d0b1b", "url": "https://github.com/netty/netty/commit/51f3b65464fd2b04337f901dc3671990350d0b1b", "message": "Reduce DefaultAttributeMap lookup cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour on lookup of an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered single array\n\nResult:\nNon blocking behaviour for the lookup happy path", "committedDate": "2020-09-14T09:53:26Z", "type": "forcePushed"}, {"oid": "f35156469aba90faf8a2271b0b8708187fc36cf8", "url": "https://github.com/netty/netty/commit/f35156469aba90faf8a2271b0b8708187fc36cf8", "message": "Reduce DefaultAttributeMap lookup cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour on lookup of an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered single array\n\nResult:\nNon blocking behaviour for the lookup happy path", "committedDate": "2020-09-14T11:17:23Z", "type": "forcePushed"}, {"oid": "9a33c7618ef949bf1ac9b3923ac79f9c54174780", "url": "https://github.com/netty/netty/commit/9a33c7618ef949bf1ac9b3923ac79f9c54174780", "message": "Reduce DefaultAttributeMap lookup cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour on lookup of an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered single array\n\nResult:\nNon blocking behaviour for the lookup happy path", "committedDate": "2020-09-14T14:58:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc2ODE5OQ==", "url": "https://github.com/netty/netty/pull/10530#discussion_r488768199", "bodyText": "Just curious, why change from extending AtomicReference?", "author": "njhill", "createdAt": "2020-09-15T15:39:54Z", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,240 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public <T> Attribute<T> attr(AttributeKey<T> key) {\n-        ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n             }\n         }\n \n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        return -(low + 1);\n+    }\n+\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n             }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n         }\n+    }\n \n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n-                }\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> Attribute<T> attr(AttributeKey<T> key) {\n+        ObjectUtil.checkNotNull(key, \"key\");\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.removed()) {\n+                    return attribute;\n+                }\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n                 }\n-                curr = next;\n+                newAttributes = new DefaultAttribute[count + 1];\n+                orderedCopyOnInsert(attributes, count, newAttributes, newAttribute);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return newAttribute;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // no attribute exists\n-            return false;\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n+        DefaultAttribute[] attributes = this.attributes;\n+        return searchAttributeByKey(attributes, 0, attributes.length, key) >= 0;\n+    }\n \n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n+    private <T> void removeAttributeIfMatch(AttributeKey<T> key, DefaultAttribute<T> value) {\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            if (index < 0) {\n+                return;\n+            }\n+            final DefaultAttribute attribute = attributes[index];\n+            assert attribute.key() == key;\n+            if (attribute != value) {\n+                return;\n+            }\n+            final int newCount = count - 1;\n+            final DefaultAttribute[] newAttributes =\n+                    newCount == 0? EMPTY_ATTRIBUTES : new DefaultAttribute[newCount];\n+            // perform 2 bulk copies\n+            System.arraycopy(attributes, 0, newAttributes, 0, index);\n+            final int remaining = count - index - 1;\n+            if (remaining > 0) {\n+                System.arraycopy(attributes, index + 1, newAttributes, index, remaining);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return;\n             }\n-            return false;\n         }\n     }\n \n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n-    }\n-\n     @SuppressWarnings(\"serial\")\n-    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n+    private static final class DefaultAttribute<T> implements Attribute<T> {\n+\n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, Object> VALUE_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class, Object.class, \"value\");", "originalCommit": "9a33c7618ef949bf1ac9b3923ac79f9c54174780", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc4NjcyNQ==", "url": "https://github.com/netty/netty/pull/10530#discussion_r488786725", "bodyText": "Because the old semantic wasn't documenting how to manage a removed state and now it doesn't match anymore the atomic reference one eg Attribute::get was === with AtomicReference::get. I have strengthened the new semantic to reduce the size of the default attribute instance ;)", "author": "franz1981", "createdAt": "2020-09-15T16:05:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc2ODE5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQzNjQxNw==", "url": "https://github.com/netty/netty/pull/10530#discussion_r490436417", "bodyText": "OK sure, though I think you could still have just overridden those and used super.get() etc? Only for a slight simplification i.e. avoid needing the ARFU. Fine to leave as-is too", "author": "njhill", "createdAt": "2020-09-17T17:30:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc2ODE5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTMxNjg5MA==", "url": "https://github.com/netty/netty/pull/10530#discussion_r491316890", "bodyText": "I have chosen to not do that because at the beginning I have already tried it and found that the whole thing was compiling fine but failing some tests because of the ARFU existing implementation: it tooks me a bit to fine the issue so I have thought was a kind of semantic code smell and fixing it was I have currently done :)", "author": "franz1981", "createdAt": "2020-09-19T07:45:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc2ODE5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc2ODgyMg==", "url": "https://github.com/netty/netty/pull/10530#discussion_r488768822", "bodyText": "nit: space before ?", "author": "njhill", "createdAt": "2020-09-15T15:40:45Z", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,240 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public <T> Attribute<T> attr(AttributeKey<T> key) {\n-        ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n             }\n         }\n \n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        return -(low + 1);\n+    }\n+\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n             }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n         }\n+    }\n \n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n-                }\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> Attribute<T> attr(AttributeKey<T> key) {\n+        ObjectUtil.checkNotNull(key, \"key\");\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.removed()) {\n+                    return attribute;\n+                }\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n                 }\n-                curr = next;\n+                newAttributes = new DefaultAttribute[count + 1];\n+                orderedCopyOnInsert(attributes, count, newAttributes, newAttribute);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return newAttribute;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // no attribute exists\n-            return false;\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n+        DefaultAttribute[] attributes = this.attributes;\n+        return searchAttributeByKey(attributes, 0, attributes.length, key) >= 0;\n+    }\n \n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n+    private <T> void removeAttributeIfMatch(AttributeKey<T> key, DefaultAttribute<T> value) {\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            if (index < 0) {\n+                return;\n+            }\n+            final DefaultAttribute attribute = attributes[index];\n+            assert attribute.key() == key;\n+            if (attribute != value) {\n+                return;\n+            }\n+            final int newCount = count - 1;\n+            final DefaultAttribute[] newAttributes =\n+                    newCount == 0? EMPTY_ATTRIBUTES : new DefaultAttribute[newCount];\n+            // perform 2 bulk copies\n+            System.arraycopy(attributes, 0, newAttributes, 0, index);\n+            final int remaining = count - index - 1;\n+            if (remaining > 0) {\n+                System.arraycopy(attributes, index + 1, newAttributes, index, remaining);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return;\n             }\n-            return false;\n         }\n     }\n \n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n-    }\n-\n     @SuppressWarnings(\"serial\")\n-    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n+    private static final class DefaultAttribute<T> implements Attribute<T> {\n+\n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, Object> VALUE_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class, Object.class, \"value\");\n \n+        private static final Object REMOVED = new Object();\n         private static final long serialVersionUID = -2661411462200283011L;\n \n-        // The head of the linked-list this attribute belongs to\n-        private final DefaultAttribute<?> head;\n+        private final DefaultAttributeMap attributeMap;\n         private final AttributeKey<T> key;\n+        private volatile Object value;\n \n-        // Double-linked list to prev and next node to allow fast removal\n-        private DefaultAttribute<?> prev;\n-        private DefaultAttribute<?> next;\n+        DefaultAttribute(DefaultAttributeMap attributeMap,\n+                         AttributeKey<T> key) {\n+            this.attributeMap = attributeMap;\n+            this.key = key;\n+        }\n \n-        // Will be set to true one the attribute is removed via getAndRemove() or remove()\n-        private volatile boolean removed;\n+        @Override\n+        public AttributeKey<T> key() {\n+            return key;\n+        }\n \n-        DefaultAttribute(DefaultAttribute<?> head, AttributeKey<T> key) {\n-            this.head = head;\n-            this.key = key;\n+        @Override\n+        public T get() {\n+            Object v = value;\n+            return v == REMOVED? null : (T) v;", "originalCommit": "9a33c7618ef949bf1ac9b3923ac79f9c54174780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc3NjAzOA==", "url": "https://github.com/netty/netty/pull/10530#discussion_r488776038", "bodyText": "Is this the same as the old behavior? i.e. if the attribute was already removed from the map would its value still be set", "author": "njhill", "createdAt": "2020-09-15T15:50:34Z", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,240 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public <T> Attribute<T> attr(AttributeKey<T> key) {\n-        ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n             }\n         }\n \n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        return -(low + 1);\n+    }\n+\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n             }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n         }\n+    }\n \n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n-                }\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> Attribute<T> attr(AttributeKey<T> key) {\n+        ObjectUtil.checkNotNull(key, \"key\");\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.removed()) {\n+                    return attribute;\n+                }\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n                 }\n-                curr = next;\n+                newAttributes = new DefaultAttribute[count + 1];\n+                orderedCopyOnInsert(attributes, count, newAttributes, newAttribute);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return newAttribute;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // no attribute exists\n-            return false;\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n+        DefaultAttribute[] attributes = this.attributes;\n+        return searchAttributeByKey(attributes, 0, attributes.length, key) >= 0;\n+    }\n \n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n+    private <T> void removeAttributeIfMatch(AttributeKey<T> key, DefaultAttribute<T> value) {\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            if (index < 0) {\n+                return;\n+            }\n+            final DefaultAttribute attribute = attributes[index];\n+            assert attribute.key() == key;\n+            if (attribute != value) {\n+                return;\n+            }\n+            final int newCount = count - 1;\n+            final DefaultAttribute[] newAttributes =\n+                    newCount == 0? EMPTY_ATTRIBUTES : new DefaultAttribute[newCount];\n+            // perform 2 bulk copies\n+            System.arraycopy(attributes, 0, newAttributes, 0, index);\n+            final int remaining = count - index - 1;\n+            if (remaining > 0) {\n+                System.arraycopy(attributes, index + 1, newAttributes, index, remaining);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return;\n             }\n-            return false;\n         }\n     }\n \n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n-    }\n-\n     @SuppressWarnings(\"serial\")\n-    private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n+    private static final class DefaultAttribute<T> implements Attribute<T> {\n+\n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, Object> VALUE_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class, Object.class, \"value\");\n \n+        private static final Object REMOVED = new Object();\n         private static final long serialVersionUID = -2661411462200283011L;\n \n-        // The head of the linked-list this attribute belongs to\n-        private final DefaultAttribute<?> head;\n+        private final DefaultAttributeMap attributeMap;\n         private final AttributeKey<T> key;\n+        private volatile Object value;\n \n-        // Double-linked list to prev and next node to allow fast removal\n-        private DefaultAttribute<?> prev;\n-        private DefaultAttribute<?> next;\n+        DefaultAttribute(DefaultAttributeMap attributeMap,\n+                         AttributeKey<T> key) {\n+            this.attributeMap = attributeMap;\n+            this.key = key;\n+        }\n \n-        // Will be set to true one the attribute is removed via getAndRemove() or remove()\n-        private volatile boolean removed;\n+        @Override\n+        public AttributeKey<T> key() {\n+            return key;\n+        }\n \n-        DefaultAttribute(DefaultAttribute<?> head, AttributeKey<T> key) {\n-            this.head = head;\n-            this.key = key;\n+        @Override\n+        public T get() {\n+            Object v = value;\n+            return v == REMOVED? null : (T) v;\n         }\n \n-        // Special constructor for the head of the linked-list.\n-        DefaultAttribute() {\n-            head = this;\n-            key = null;\n+        public boolean removed() {\n+            return value == REMOVED;\n         }\n \n         @Override\n-        public AttributeKey<T> key() {\n-            return key;\n+        public void set(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return;\n+                }\n+            } while (!VALUE_UPDATER.compareAndSet(this, old, value));\n+        }\n+\n+        @Override\n+        public T getAndSet(T value) {\n+            Object old;\n+            do {\n+                old = this.value;\n+                if (old == REMOVED) {\n+                    // a subsequent get should return null regardless the current value\n+                    // given that remove has been called\n+                    return null;", "originalCommit": "9a33c7618ef949bf1ac9b3923ac79f9c54174780", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc4OTI4OA==", "url": "https://github.com/netty/netty/pull/10530#discussion_r488789288", "bodyText": "Nope but there was no documentation about it so I have changed it into something that would reduce the memory footprint of the instance while keeping a consistent behaviour", "author": "franz1981", "createdAt": "2020-09-15T16:09:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc3NjAzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyOTU1Nw==", "url": "https://github.com/netty/netty/pull/10530#discussion_r490429557", "bodyText": "might be a nit, but did you consider binary searching to find the insertion point, and then use System.arraycopy to move the daat around for the slot?  I am curious if this more easily intrinsifies this for loop copy.", "author": "carl-mastrangelo", "createdAt": "2020-09-17T17:19:56Z", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,240 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public <T> Attribute<T> attr(AttributeKey<T> key) {\n-        ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n             }\n         }\n \n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        return -(low + 1);\n+    }\n+\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {", "originalCommit": "9a33c7618ef949bf1ac9b3923ac79f9c54174780", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQ2ODMxOQ==", "url": "https://github.com/netty/netty/pull/10530#discussion_r490468319", "bodyText": "As a general rule of thumb, yes, you're right, here I have taken advantage of the domain logic where latest addition of attributes tends to have higher IDs (due to the incremental logic on constants).", "author": "franz1981", "createdAt": "2020-09-17T18:26:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQyOTU1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDQzNjIwMw==", "url": "https://github.com/netty/netty/pull/10530#discussion_r490436203", "bodyText": "This doesn't seem to take advantage of the index which should be the insertion point.    I would suspect after a few attrs, avoiding the excess copies would become expensive.    It feels like the index should be passed into orderedCopyOnInsert", "author": "carl-mastrangelo", "createdAt": "2020-09-17T17:30:27Z", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,186 +17,240 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n-import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n-\n-    @SuppressWarnings(\"unchecked\")\n-    @Override\n-    public <T> Attribute<T> attr(AttributeKey<T> key) {\n-        ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n             }\n         }\n \n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n+        return -(low + 1);\n+    }\n+\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n             }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n         }\n+    }\n \n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n-                }\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public <T> Attribute<T> attr(AttributeKey<T> key) {\n+        ObjectUtil.checkNotNull(key, \"key\");\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.removed()) {\n+                    return attribute;\n+                }\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {", "originalCommit": "9a33c7618ef949bf1ac9b3923ac79f9c54174780", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "35fbf91263835189670822d4e03fe30f2615443d", "url": "https://github.com/netty/netty/commit/35fbf91263835189670822d4e03fe30f2615443d", "message": "Reduce DefaultAttributeMap lookup cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour on lookup of an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered single array\n\nResult:\nNon blocking behaviour for the lookup happy path", "committedDate": "2020-09-21T13:49:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYzODQ4OA==", "url": "https://github.com/netty/netty/pull/10530#discussion_r498638488", "bodyText": "remove public and rename to isRemoved() ?", "author": "normanmaurer", "createdAt": "2020-10-02T06:36:14Z", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,143 +17,170 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n+\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n+            }\n+        }\n+\n+        return -(low + 1);\n+    }\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n+            }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n+        }\n+    }\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Attribute<T> attr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n-            }\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n-            }\n-        }\n-\n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.removed()) {\n+                    return attribute;\n                 }\n-\n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n                 }\n-                curr = next;\n+                newAttributes = new DefaultAttribute[count + 1];\n+                orderedCopyOnInsert(attributes, count, newAttributes, newAttribute);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return newAttribute;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // no attribute exists\n-            return false;\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n+        DefaultAttribute[] attributes = this.attributes;\n+        return searchAttributeByKey(attributes, 0, attributes.length, key) >= 0;\n+    }\n \n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n+    private <T> void removeAttributeIfMatch(AttributeKey<T> key, DefaultAttribute<T> value) {\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            if (index < 0) {\n+                return;\n+            }\n+            final DefaultAttribute attribute = attributes[index];\n+            assert attribute.key() == key;\n+            if (attribute != value) {\n+                return;\n+            }\n+            final int newCount = count - 1;\n+            final DefaultAttribute[] newAttributes =\n+                    newCount == 0? EMPTY_ATTRIBUTES : new DefaultAttribute[newCount];\n+            // perform 2 bulk copies\n+            System.arraycopy(attributes, 0, newAttributes, 0, index);\n+            final int remaining = count - index - 1;\n+            if (remaining > 0) {\n+                System.arraycopy(attributes, index + 1, newAttributes, index, remaining);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return;\n             }\n-            return false;\n         }\n     }\n \n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n-    }\n-\n     @SuppressWarnings(\"serial\")\n     private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n \n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, DefaultAttributeMap> MAP_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class,\n+                                                       DefaultAttributeMap.class, \"attributeMap\");\n         private static final long serialVersionUID = -2661411462200283011L;\n \n+        private volatile DefaultAttributeMap attributeMap;\n         // The head of the linked-list this attribute belongs to\n-        private final DefaultAttribute<?> head;\n         private final AttributeKey<T> key;\n \n-        // Double-linked list to prev and next node to allow fast removal\n-        private DefaultAttribute<?> prev;\n-        private DefaultAttribute<?> next;\n-\n-        // Will be set to true one the attribute is removed via getAndRemove() or remove()\n-        private volatile boolean removed;\n-\n-        DefaultAttribute(DefaultAttribute<?> head, AttributeKey<T> key) {\n-            this.head = head;\n+        DefaultAttribute(DefaultAttributeMap attributeMap, AttributeKey<T> key) {\n+            this.attributeMap = attributeMap;\n             this.key = key;\n         }\n \n-        // Special constructor for the head of the linked-list.\n-        DefaultAttribute() {\n-            head = this;\n-            key = null;\n-        }\n-\n         @Override\n         public AttributeKey<T> key() {\n             return key;\n         }\n \n+        public boolean removed() {", "originalCommit": "35fbf91263835189670822d4e03fe30f2615443d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODY0NTEyMg==", "url": "https://github.com/netty/netty/pull/10530#discussion_r498645122", "bodyText": "done!", "author": "franz1981", "createdAt": "2020-10-02T06:57:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYzODQ4OA=="}], "type": "inlineReview"}, {"oid": "cd22863a4064cb5038857f630b96a89f75886ba1", "url": "https://github.com/netty/netty/commit/cd22863a4064cb5038857f630b96a89f75886ba1", "message": "Reduce DefaultAttributeMap lookup cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour on lookup of an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered single array\n\nResult:\nNon blocking behaviour for the lookup happy path", "committedDate": "2020-10-02T06:57:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcxMzIwOA==", "url": "https://github.com/netty/netty/pull/10530#discussion_r498713208", "bodyText": "If they're the same object, there's no way their id can be different.", "author": "chrisvest", "createdAt": "2020-10-02T09:25:58Z", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,143 +17,170 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n+\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();", "originalCommit": "cd22863a4064cb5038857f630b96a89f75886ba1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODc0NTEyNw==", "url": "https://github.com/netty/netty/pull/10530#discussion_r498745127", "bodyText": "ooops!", "author": "franz1981", "createdAt": "2020-10-02T10:36:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcxMzIwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODcxNDkxMw==", "url": "https://github.com/netty/netty/pull/10530#discussion_r498714913", "bodyText": "The fromIndex is always 0, and toIndex is always the length of the sortedAttributes, so there's no need to take them as parameters.", "author": "chrisvest", "createdAt": "2020-10-02T09:29:33Z", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,143 +17,170 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;", "originalCommit": "cd22863a4064cb5038857f630b96a89f75886ba1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODczMTQxNg==", "url": "https://github.com/netty/netty/pull/10530#discussion_r498731416", "bodyText": "This comment is now obsolete.", "author": "chrisvest", "createdAt": "2020-10-02T10:05:34Z", "path": "common/src/main/java/io/netty/util/DefaultAttributeMap.java", "diffHunk": "@@ -17,143 +17,170 @@\n \n import io.netty.util.internal.ObjectUtil;\n \n+import java.util.Arrays;\n import java.util.concurrent.atomic.AtomicReference;\n-import java.util.concurrent.atomic.AtomicReferenceArray;\n import java.util.concurrent.atomic.AtomicReferenceFieldUpdater;\n \n /**\n- * Default {@link AttributeMap} implementation which use simple synchronization per bucket to keep the memory overhead\n- * as low as possible.\n+ * Default {@link AttributeMap} implementation which not exibit any blocking behaviour on attribute lookup while using a\n+ * copy-on-write approach on the modify path.<br> Attributes lookup and remove exibit {@code O(logn)} time worst-case\n+ * complexity, hence {@code attribute::set(null)} is to be preferred to {@code remove}.\n  */\n public class DefaultAttributeMap implements AttributeMap {\n \n-    @SuppressWarnings(\"rawtypes\")\n-    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, AtomicReferenceArray> updater =\n-            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, AtomicReferenceArray.class, \"attributes\");\n+    private static final AtomicReferenceFieldUpdater<DefaultAttributeMap, DefaultAttribute[]> ATTRIBUTES_UPDATER =\n+            AtomicReferenceFieldUpdater.newUpdater(DefaultAttributeMap.class, DefaultAttribute[].class, \"attributes\");\n+    private static final DefaultAttribute[] EMPTY_ATTRIBUTES = new DefaultAttribute[0];\n+\n+    /**\n+     * Similarly to {@code Arrays::binarySearch} it perform a binary search optimized for this use case, in order to\n+     * save polymorphic calls (on comparator side) and unnecessary class checks.\n+     */\n+    private static int searchAttributeByKey(DefaultAttribute[] sortedAttributes, int fromIndex, int toIndex,\n+                                            AttributeKey<?> key) {\n+        int low = fromIndex;\n+        int high = toIndex - 1;\n+\n+        while (low <= high) {\n+            int mid = low + high >>> 1;\n+            DefaultAttribute midVal = sortedAttributes[mid];\n+            AttributeKey midValKey = midVal.key;\n+            if (midValKey == key) {\n+                assert midValKey.id() == key.id();\n+                return mid;\n+            }\n+            int midValKeyId = midValKey.id();\n+            int keyId = key.id();\n+            assert midValKeyId != keyId;\n+            boolean searchRight = midValKeyId < keyId;\n+            if (searchRight) {\n+                low = mid + 1;\n+            } else {\n+                high = mid - 1;\n+            }\n+        }\n+\n+        return -(low + 1);\n+    }\n \n-    private static final int BUCKET_SIZE = 4;\n-    private static final int MASK = BUCKET_SIZE  - 1;\n+    private static void orderedCopyOnInsert(DefaultAttribute[] sortedSrc, int srcLength, DefaultAttribute[] copy,\n+                                            DefaultAttribute toInsert) {\n+        // let's walk backward, because as a rule of thumb, toInsert.key.id() tends to be higher for new keys\n+        final int id = toInsert.key.id();\n+        int i;\n+        for (i = srcLength - 1; i >= 0; i--) {\n+            DefaultAttribute attribute = sortedSrc[i];\n+            assert attribute.key.id() != id;\n+            if (attribute.key.id() < id) {\n+                break;\n+            }\n+            copy[i + 1] = sortedSrc[i];\n+        }\n+        copy[i + 1] = toInsert;\n+        final int toCopy = i + 1;\n+        if (toCopy > 0) {\n+            System.arraycopy(sortedSrc, 0, copy, 0, toCopy);\n+        }\n+    }\n \n-    // Initialize lazily to reduce memory consumption; updated by AtomicReferenceFieldUpdater above.\n-    @SuppressWarnings(\"UnusedDeclaration\")\n-    private volatile AtomicReferenceArray<DefaultAttribute<?>> attributes;\n+    private volatile DefaultAttribute[] attributes = EMPTY_ATTRIBUTES;\n \n     @SuppressWarnings(\"unchecked\")\n     @Override\n     public <T> Attribute<T> attr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // Not using ConcurrentHashMap due to high memory consumption.\n-            attributes = new AtomicReferenceArray<DefaultAttribute<?>>(BUCKET_SIZE);\n-\n-            if (!updater.compareAndSet(this, null, attributes)) {\n-                attributes = this.attributes;\n-            }\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No head exists yet which means we may be able to add the attribute without synchronization and just\n-            // use compare and set. At worst we need to fallback to synchronization and waste two allocations.\n-            head = new DefaultAttribute();\n-            DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-            head.next = attr;\n-            attr.prev = head;\n-            if (attributes.compareAndSet(i, null, head)) {\n-                // we were able to add it so return the attr right away\n-                return attr;\n-            } else {\n-                head = attributes.get(i);\n-            }\n-        }\n-\n-        synchronized (head) {\n-            DefaultAttribute<?> curr = head;\n-            for (;;) {\n-                DefaultAttribute<?> next = curr.next;\n-                if (next == null) {\n-                    DefaultAttribute<T> attr = new DefaultAttribute<T>(head, key);\n-                    curr.next = attr;\n-                    attr.prev = curr;\n-                    return attr;\n+        DefaultAttribute newAttribute = null;\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            final DefaultAttribute[] newAttributes;\n+            if (index >= 0) {\n+                final DefaultAttribute attribute = attributes[index];\n+                assert attribute.key() == key;\n+                if (!attribute.isRemoved()) {\n+                    return attribute;\n                 }\n-\n-                if (next.key == key && !next.removed) {\n-                    return (Attribute<T>) next;\n+                // let's try replace the removed attribute with a new one\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n+                }\n+                newAttributes = Arrays.copyOf(attributes, count);\n+                newAttributes[index] = newAttribute;\n+            } else {\n+                if (newAttribute == null) {\n+                    newAttribute = new DefaultAttribute<T>(this, key);\n                 }\n-                curr = next;\n+                newAttributes = new DefaultAttribute[count + 1];\n+                orderedCopyOnInsert(attributes, count, newAttributes, newAttribute);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return newAttribute;\n             }\n         }\n     }\n \n     @Override\n     public <T> boolean hasAttr(AttributeKey<T> key) {\n         ObjectUtil.checkNotNull(key, \"key\");\n-        AtomicReferenceArray<DefaultAttribute<?>> attributes = this.attributes;\n-        if (attributes == null) {\n-            // no attribute exists\n-            return false;\n-        }\n-\n-        int i = index(key);\n-        DefaultAttribute<?> head = attributes.get(i);\n-        if (head == null) {\n-            // No attribute exists which point to the bucket in which the head should be located\n-            return false;\n-        }\n+        DefaultAttribute[] attributes = this.attributes;\n+        return searchAttributeByKey(attributes, 0, attributes.length, key) >= 0;\n+    }\n \n-        // We need to synchronize on the head.\n-        synchronized (head) {\n-            // Start with head.next as the head itself does not store an attribute.\n-            DefaultAttribute<?> curr = head.next;\n-            while (curr != null) {\n-                if (curr.key == key && !curr.removed) {\n-                    return true;\n-                }\n-                curr = curr.next;\n+    private <T> void removeAttributeIfMatch(AttributeKey<T> key, DefaultAttribute<T> value) {\n+        for (;;) {\n+            final DefaultAttribute[] attributes = this.attributes;\n+            final int count = attributes.length;\n+            final int index = searchAttributeByKey(attributes, 0, count, key);\n+            if (index < 0) {\n+                return;\n+            }\n+            final DefaultAttribute attribute = attributes[index];\n+            assert attribute.key() == key;\n+            if (attribute != value) {\n+                return;\n+            }\n+            final int newCount = count - 1;\n+            final DefaultAttribute[] newAttributes =\n+                    newCount == 0? EMPTY_ATTRIBUTES : new DefaultAttribute[newCount];\n+            // perform 2 bulk copies\n+            System.arraycopy(attributes, 0, newAttributes, 0, index);\n+            final int remaining = count - index - 1;\n+            if (remaining > 0) {\n+                System.arraycopy(attributes, index + 1, newAttributes, index, remaining);\n+            }\n+            if (ATTRIBUTES_UPDATER.compareAndSet(this, attributes, newAttributes)) {\n+                return;\n             }\n-            return false;\n         }\n     }\n \n-    private static int index(AttributeKey<?> key) {\n-        return key.id() & MASK;\n-    }\n-\n     @SuppressWarnings(\"serial\")\n     private static final class DefaultAttribute<T> extends AtomicReference<T> implements Attribute<T> {\n \n+        private static final AtomicReferenceFieldUpdater<DefaultAttribute, DefaultAttributeMap> MAP_UPDATER =\n+                AtomicReferenceFieldUpdater.newUpdater(DefaultAttribute.class,\n+                                                       DefaultAttributeMap.class, \"attributeMap\");\n         private static final long serialVersionUID = -2661411462200283011L;\n \n+        private volatile DefaultAttributeMap attributeMap;\n         // The head of the linked-list this attribute belongs to", "originalCommit": "cd22863a4064cb5038857f630b96a89f75886ba1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c0ebd302475bd4cb3b87f0cd0636293bb34f05fb", "url": "https://github.com/netty/netty/commit/c0ebd302475bd4cb3b87f0cd0636293bb34f05fb", "message": "Reduce DefaultAttributeMap lookup cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour on lookup of an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered single array\n\nResult:\nNon blocking behaviour for the lookup happy path", "committedDate": "2020-10-02T13:46:39Z", "type": "commit"}, {"oid": "c0ebd302475bd4cb3b87f0cd0636293bb34f05fb", "url": "https://github.com/netty/netty/commit/c0ebd302475bd4cb3b87f0cd0636293bb34f05fb", "message": "Reduce DefaultAttributeMap lookup cost\n\nMotivation:\n\nDefaultAttributeMap::attr has a blocking behaviour on lookup of an existing attribute:\nit can be made non-blocking.\n\nModification:\n\nReplace the existing fixed bucket table using a locked intrusive linked list\nwith an hand-rolled copy-on-write ordered single array\n\nResult:\nNon blocking behaviour for the lookup happy path", "committedDate": "2020-10-02T13:46:39Z", "type": "forcePushed"}]}