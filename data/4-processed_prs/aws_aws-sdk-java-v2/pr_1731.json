{"pr_number": 1731, "pr_title": "DDB Enhanced: updates README with bean examples", "pr_createdAt": "2020-03-20T21:17:06Z", "pr_url": "https://github.com/aws/aws-sdk-java-v2/pull/1731", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NTA5Mg==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1731#discussion_r396645092", "bodyText": "I think this is more interesting/relevant than flattening and extending. Can we make this section come first?", "author": "bmaizels", "createdAt": "2020-03-23T17:55:13Z", "path": "services-custom/dynamodb-enhanced/README.md", "diffHunk": "@@ -291,32 +296,205 @@ Using composition:\n public class Customer{\n   private String name;\n   private GenericRecord recordMetadata;\n+  //getters and setters for all attributes\n }\n \n @Data\n public class GenericRecord {\n   private String id;\n   private String createdDate;\n+  //getters and setters for all attributes\n }\n \n private static final StaticTableSchema<GenericRecord> GENERIC_RECORD_SCHEMA =\n   StaticTableSchema.builder(GenericRecord.class)\n-    .newItemSupplier(GenericRecord::new)\n-    .attributes(\n-      stringAttribute(\"id\", GenericRecord::getId, GenericRecord::setId).as(primaryPartitionKey()),\n-      stringAttribute(\"created_date\", GenericRecord::getCreatedDate, GenericRecord::setCreatedDate))\n-    .build();\n+      .addAttribute(String.class, a -> a.name(\"id\")\n+                                        .getter(GenericRecord::getId)\n+                                        .setter(GenericRecord::setId)\n+                                        .tags(primaryPartitionKey()))\n+      .addAttribute(String.class, a -> a.name(\"created_date\")\n+                                        .getter(GenericRecord::getCreatedDate)\n+                                        .setter(GenericRecord::setCreatedDate))\n+     .build();\n     \n private static final StaticTableSchema<Customer> CUSTOMER_TABLE_SCHEMA =\n   StaticTableSchema.builder(Customer.class)\n     .newItemSupplier(Customer::new)\n-    .attributes(stringAttribute(\"name\", Customer::getName, Customer::setName))\n+    .addAttribute(String.class, a -> a.name(\"name\")\n+                                      .getter(Customer::getName)\n+                                      .setter(Customer::setName))\n     // Because we are flattening a component object, we supply a getter and setter so the\n     // mapper knows how to access it\n-    .flatten(CUSTOMER_TABLE_SCHEMA, Customer::getRecordMetadata, Customer::setRecordMetadata)\n+    .flatten(GENERIC_RECORD_SCHEMA, Customer::getRecordMetadata, Customer::setRecordMetadata)\n     .build(); \n ```\n You can flatten as many different eligible classes as you like using the\n builder pattern. The only constraints are that attributes must not have\n the same name when they are being rolled together, and there must never\n-be more than one partition key, sort key or table name.\n\\ No newline at end of file\n+be more than one partition key, sort key or table name.\n+\n+### Control how attributes are converted", "originalCommit": "c7e31a08fe87f1399f9a4724111eea07489b9887", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1NDY1NQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1731#discussion_r396654655", "bodyText": "Yes", "author": "cenedhryn", "createdAt": "2020-03-23T18:09:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NTA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NTU4OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1731#discussion_r396645588", "bodyText": "I think we should give an example on how to do this.", "author": "bmaizels", "createdAt": "2020-03-23T17:55:52Z", "path": "services-custom/dynamodb-enhanced/README.md", "diffHunk": "@@ -291,32 +296,205 @@ Using composition:\n public class Customer{\n   private String name;\n   private GenericRecord recordMetadata;\n+  //getters and setters for all attributes\n }\n \n @Data\n public class GenericRecord {\n   private String id;\n   private String createdDate;\n+  //getters and setters for all attributes\n }\n \n private static final StaticTableSchema<GenericRecord> GENERIC_RECORD_SCHEMA =\n   StaticTableSchema.builder(GenericRecord.class)\n-    .newItemSupplier(GenericRecord::new)\n-    .attributes(\n-      stringAttribute(\"id\", GenericRecord::getId, GenericRecord::setId).as(primaryPartitionKey()),\n-      stringAttribute(\"created_date\", GenericRecord::getCreatedDate, GenericRecord::setCreatedDate))\n-    .build();\n+      .addAttribute(String.class, a -> a.name(\"id\")\n+                                        .getter(GenericRecord::getId)\n+                                        .setter(GenericRecord::setId)\n+                                        .tags(primaryPartitionKey()))\n+      .addAttribute(String.class, a -> a.name(\"created_date\")\n+                                        .getter(GenericRecord::getCreatedDate)\n+                                        .setter(GenericRecord::setCreatedDate))\n+     .build();\n     \n private static final StaticTableSchema<Customer> CUSTOMER_TABLE_SCHEMA =\n   StaticTableSchema.builder(Customer.class)\n     .newItemSupplier(Customer::new)\n-    .attributes(stringAttribute(\"name\", Customer::getName, Customer::setName))\n+    .addAttribute(String.class, a -> a.name(\"name\")\n+                                      .getter(Customer::getName)\n+                                      .setter(Customer::setName))\n     // Because we are flattening a component object, we supply a getter and setter so the\n     // mapper knows how to access it\n-    .flatten(CUSTOMER_TABLE_SCHEMA, Customer::getRecordMetadata, Customer::setRecordMetadata)\n+    .flatten(GENERIC_RECORD_SCHEMA, Customer::getRecordMetadata, Customer::setRecordMetadata)\n     .build(); \n ```\n You can flatten as many different eligible classes as you like using the\n builder pattern. The only constraints are that attributes must not have\n the same name when they are being rolled together, and there must never\n-be more than one partition key, sort key or table name.\n\\ No newline at end of file\n+be more than one partition key, sort key or table name.\n+\n+### Control how attributes are converted\n+By default, the table schema provides converters for all primitive and many common Java types\n+through a default implementation of the AttributeConverterProvider interface. This behavior\n+can be changed both at the attribute converter provider level as well as for a single attribute.\n+#### Provide custom attribute converter providers\n+You can provide a single AttributeConverterProvider or a chain of ordered AttributeConverterProviders\n+ to the StaticTableSchema:\n+```java\n+private static final StaticTableSchema<Customer> CUSTOMER_TABLE_SCHEMA =\n+  StaticTableSchema.builder(Customer.class)\n+    .newItemSupplier(Customer::new)\n+    .addAttribute(String.class, a -> a.name(\"name\")\n+                                     a.getter(Customer::getName)\n+                                     a.setter(Customer::setName))\n+    .attributeConverterProviders(converterProvider1, converterProvider2)\n+    .build();\n+```\n+Note that if you supply your own chain of attribute converter providers, you will override\n+the default converter provider and must therefore include it in the chain if you wish to\n+use its attribute converters.", "originalCommit": "c7e31a08fe87f1399f9a4724111eea07489b9887", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1NDg4Ng==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1731#discussion_r396654886", "bodyText": "Will add", "author": "cenedhryn", "createdAt": "2020-03-23T18:09:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NTU4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NjE3NQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1731#discussion_r396646175", "bodyText": "Let's add a note that makes it clear that overriding a single attribute will not apply the same converter to other attributes of that type unless they are also overridden or the provider supports it instead.", "author": "bmaizels", "createdAt": "2020-03-23T17:56:44Z", "path": "services-custom/dynamodb-enhanced/README.md", "diffHunk": "@@ -291,32 +296,205 @@ Using composition:\n public class Customer{\n   private String name;\n   private GenericRecord recordMetadata;\n+  //getters and setters for all attributes\n }\n \n @Data\n public class GenericRecord {\n   private String id;\n   private String createdDate;\n+  //getters and setters for all attributes\n }\n \n private static final StaticTableSchema<GenericRecord> GENERIC_RECORD_SCHEMA =\n   StaticTableSchema.builder(GenericRecord.class)\n-    .newItemSupplier(GenericRecord::new)\n-    .attributes(\n-      stringAttribute(\"id\", GenericRecord::getId, GenericRecord::setId).as(primaryPartitionKey()),\n-      stringAttribute(\"created_date\", GenericRecord::getCreatedDate, GenericRecord::setCreatedDate))\n-    .build();\n+      .addAttribute(String.class, a -> a.name(\"id\")\n+                                        .getter(GenericRecord::getId)\n+                                        .setter(GenericRecord::setId)\n+                                        .tags(primaryPartitionKey()))\n+      .addAttribute(String.class, a -> a.name(\"created_date\")\n+                                        .getter(GenericRecord::getCreatedDate)\n+                                        .setter(GenericRecord::setCreatedDate))\n+     .build();\n     \n private static final StaticTableSchema<Customer> CUSTOMER_TABLE_SCHEMA =\n   StaticTableSchema.builder(Customer.class)\n     .newItemSupplier(Customer::new)\n-    .attributes(stringAttribute(\"name\", Customer::getName, Customer::setName))\n+    .addAttribute(String.class, a -> a.name(\"name\")\n+                                      .getter(Customer::getName)\n+                                      .setter(Customer::setName))\n     // Because we are flattening a component object, we supply a getter and setter so the\n     // mapper knows how to access it\n-    .flatten(CUSTOMER_TABLE_SCHEMA, Customer::getRecordMetadata, Customer::setRecordMetadata)\n+    .flatten(GENERIC_RECORD_SCHEMA, Customer::getRecordMetadata, Customer::setRecordMetadata)\n     .build(); \n ```\n You can flatten as many different eligible classes as you like using the\n builder pattern. The only constraints are that attributes must not have\n the same name when they are being rolled together, and there must never\n-be more than one partition key, sort key or table name.\n\\ No newline at end of file\n+be more than one partition key, sort key or table name.\n+\n+### Control how attributes are converted\n+By default, the table schema provides converters for all primitive and many common Java types\n+through a default implementation of the AttributeConverterProvider interface. This behavior\n+can be changed both at the attribute converter provider level as well as for a single attribute.\n+#### Provide custom attribute converter providers\n+You can provide a single AttributeConverterProvider or a chain of ordered AttributeConverterProviders\n+ to the StaticTableSchema:\n+```java\n+private static final StaticTableSchema<Customer> CUSTOMER_TABLE_SCHEMA =\n+  StaticTableSchema.builder(Customer.class)\n+    .newItemSupplier(Customer::new)\n+    .addAttribute(String.class, a -> a.name(\"name\")\n+                                     a.getter(Customer::getName)\n+                                     a.setter(Customer::setName))\n+    .attributeConverterProviders(converterProvider1, converterProvider2)\n+    .build();\n+```\n+Note that if you supply your own chain of attribute converter providers, you will override\n+the default converter provider and must therefore include it in the chain if you wish to\n+use its attribute converters.\n+\n+#### Override the mapping of a single attribute\n+Supply an AttributeConverter when creating the attribute to directly override any\n+converters provided by the table schema AttributeConverterProviders:", "originalCommit": "c7e31a08fe87f1399f9a4724111eea07489b9887", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0NTI1NA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1731#discussion_r400545254", "bodyText": "ok", "author": "cenedhryn", "createdAt": "2020-03-30T23:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NjE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NzA1NQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1731#discussion_r396647055", "bodyText": "I think this description is a bit circumspect. Let's just pitch it as 'this is how to change the name used to store the attribute in the DynamoDb table' or something equivalent. I think the annotation javadoc might need changing too.", "author": "bmaizels", "createdAt": "2020-03-23T17:58:01Z", "path": "services-custom/dynamodb-enhanced/README.md", "diffHunk": "@@ -291,32 +296,205 @@ Using composition:\n public class Customer{\n   private String name;\n   private GenericRecord recordMetadata;\n+  //getters and setters for all attributes\n }\n \n @Data\n public class GenericRecord {\n   private String id;\n   private String createdDate;\n+  //getters and setters for all attributes\n }\n \n private static final StaticTableSchema<GenericRecord> GENERIC_RECORD_SCHEMA =\n   StaticTableSchema.builder(GenericRecord.class)\n-    .newItemSupplier(GenericRecord::new)\n-    .attributes(\n-      stringAttribute(\"id\", GenericRecord::getId, GenericRecord::setId).as(primaryPartitionKey()),\n-      stringAttribute(\"created_date\", GenericRecord::getCreatedDate, GenericRecord::setCreatedDate))\n-    .build();\n+      .addAttribute(String.class, a -> a.name(\"id\")\n+                                        .getter(GenericRecord::getId)\n+                                        .setter(GenericRecord::setId)\n+                                        .tags(primaryPartitionKey()))\n+      .addAttribute(String.class, a -> a.name(\"created_date\")\n+                                        .getter(GenericRecord::getCreatedDate)\n+                                        .setter(GenericRecord::setCreatedDate))\n+     .build();\n     \n private static final StaticTableSchema<Customer> CUSTOMER_TABLE_SCHEMA =\n   StaticTableSchema.builder(Customer.class)\n     .newItemSupplier(Customer::new)\n-    .attributes(stringAttribute(\"name\", Customer::getName, Customer::setName))\n+    .addAttribute(String.class, a -> a.name(\"name\")\n+                                      .getter(Customer::getName)\n+                                      .setter(Customer::setName))\n     // Because we are flattening a component object, we supply a getter and setter so the\n     // mapper knows how to access it\n-    .flatten(CUSTOMER_TABLE_SCHEMA, Customer::getRecordMetadata, Customer::setRecordMetadata)\n+    .flatten(GENERIC_RECORD_SCHEMA, Customer::getRecordMetadata, Customer::setRecordMetadata)\n     .build(); \n ```\n You can flatten as many different eligible classes as you like using the\n builder pattern. The only constraints are that attributes must not have\n the same name when they are being rolled together, and there must never\n-be more than one partition key, sort key or table name.\n\\ No newline at end of file\n+be more than one partition key, sort key or table name.\n+\n+### Control how attributes are converted\n+By default, the table schema provides converters for all primitive and many common Java types\n+through a default implementation of the AttributeConverterProvider interface. This behavior\n+can be changed both at the attribute converter provider level as well as for a single attribute.\n+#### Provide custom attribute converter providers\n+You can provide a single AttributeConverterProvider or a chain of ordered AttributeConverterProviders\n+ to the StaticTableSchema:\n+```java\n+private static final StaticTableSchema<Customer> CUSTOMER_TABLE_SCHEMA =\n+  StaticTableSchema.builder(Customer.class)\n+    .newItemSupplier(Customer::new)\n+    .addAttribute(String.class, a -> a.name(\"name\")\n+                                     a.getter(Customer::getName)\n+                                     a.setter(Customer::setName))\n+    .attributeConverterProviders(converterProvider1, converterProvider2)\n+    .build();\n+```\n+Note that if you supply your own chain of attribute converter providers, you will override\n+the default converter provider and must therefore include it in the chain if you wish to\n+use its attribute converters.\n+\n+#### Override the mapping of a single attribute\n+Supply an AttributeConverter when creating the attribute to directly override any\n+converters provided by the table schema AttributeConverterProviders:\n+```java\n+private static final StaticTableSchema<Customer> CUSTOMER_TABLE_SCHEMA =\n+  StaticTableSchema.builder(Customer.class)\n+    .newItemSupplier(Customer::new)\n+    .addAttribute(String.class, a -> a.name(\"name\")\n+                                     a.getter(Customer::getName)\n+                                     a.setter(Customer::setName)\n+                                     a.attributeConverter(customAttributeConverter))\n+    .build();\n+```\n+\n+## Advanced BeanTableSchema scenarios\n+### Ignore attributes that should not participate in mapping to DDB\n+Mark the attribute with the @DynamoDbIgnore annotation:\n+```java\n+private String internalKey;\n+\n+@DynamoDbIgnore\n+public String getInternalKey() { return this.internalKey; }\n+public void setInternalKey(String internalKey) { return this.internalKey = internalKey;}\n+```\n+\n+### Mark attributes that should participate in mapping to DDB\n+Any attribute in a class marked with @DynamoDbBean will be included in the mapping as long\n+as it has a getter and a setter, according to the Java Bean standard. It's also\n+possible to explicitly mark attributes to participate in the mapping to DDB, with a custom name,\n+using the @DynamoDbAttribute annotation:", "originalCommit": "c7e31a08fe87f1399f9a4724111eea07489b9887", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY1NTE1Nw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1731#discussion_r396655157", "bodyText": "Ok, I'll look into that.", "author": "cenedhryn", "createdAt": "2020-03-23T18:10:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0NzA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0ODM1NQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1731#discussion_r396648355", "bodyText": "I think we should organize the documentation by 'use-case scenario' then show how to do it in the different table schema implementations (I've been putting Bean first, then Static). So I think this should be joined with the equivalent section for the static table schema.", "author": "bmaizels", "createdAt": "2020-03-23T17:59:48Z", "path": "services-custom/dynamodb-enhanced/README.md", "diffHunk": "@@ -291,32 +296,205 @@ Using composition:\n public class Customer{\n   private String name;\n   private GenericRecord recordMetadata;\n+  //getters and setters for all attributes\n }\n \n @Data\n public class GenericRecord {\n   private String id;\n   private String createdDate;\n+  //getters and setters for all attributes\n }\n \n private static final StaticTableSchema<GenericRecord> GENERIC_RECORD_SCHEMA =\n   StaticTableSchema.builder(GenericRecord.class)\n-    .newItemSupplier(GenericRecord::new)\n-    .attributes(\n-      stringAttribute(\"id\", GenericRecord::getId, GenericRecord::setId).as(primaryPartitionKey()),\n-      stringAttribute(\"created_date\", GenericRecord::getCreatedDate, GenericRecord::setCreatedDate))\n-    .build();\n+      .addAttribute(String.class, a -> a.name(\"id\")\n+                                        .getter(GenericRecord::getId)\n+                                        .setter(GenericRecord::setId)\n+                                        .tags(primaryPartitionKey()))\n+      .addAttribute(String.class, a -> a.name(\"created_date\")\n+                                        .getter(GenericRecord::getCreatedDate)\n+                                        .setter(GenericRecord::setCreatedDate))\n+     .build();\n     \n private static final StaticTableSchema<Customer> CUSTOMER_TABLE_SCHEMA =\n   StaticTableSchema.builder(Customer.class)\n     .newItemSupplier(Customer::new)\n-    .attributes(stringAttribute(\"name\", Customer::getName, Customer::setName))\n+    .addAttribute(String.class, a -> a.name(\"name\")\n+                                      .getter(Customer::getName)\n+                                      .setter(Customer::setName))\n     // Because we are flattening a component object, we supply a getter and setter so the\n     // mapper knows how to access it\n-    .flatten(CUSTOMER_TABLE_SCHEMA, Customer::getRecordMetadata, Customer::setRecordMetadata)\n+    .flatten(GENERIC_RECORD_SCHEMA, Customer::getRecordMetadata, Customer::setRecordMetadata)\n     .build(); \n ```\n You can flatten as many different eligible classes as you like using the\n builder pattern. The only constraints are that attributes must not have\n the same name when they are being rolled together, and there must never\n-be more than one partition key, sort key or table name.\n\\ No newline at end of file\n+be more than one partition key, sort key or table name.\n+\n+### Control how attributes are converted\n+By default, the table schema provides converters for all primitive and many common Java types\n+through a default implementation of the AttributeConverterProvider interface. This behavior\n+can be changed both at the attribute converter provider level as well as for a single attribute.\n+#### Provide custom attribute converter providers\n+You can provide a single AttributeConverterProvider or a chain of ordered AttributeConverterProviders\n+ to the StaticTableSchema:\n+```java\n+private static final StaticTableSchema<Customer> CUSTOMER_TABLE_SCHEMA =\n+  StaticTableSchema.builder(Customer.class)\n+    .newItemSupplier(Customer::new)\n+    .addAttribute(String.class, a -> a.name(\"name\")\n+                                     a.getter(Customer::getName)\n+                                     a.setter(Customer::setName))\n+    .attributeConverterProviders(converterProvider1, converterProvider2)\n+    .build();\n+```\n+Note that if you supply your own chain of attribute converter providers, you will override\n+the default converter provider and must therefore include it in the chain if you wish to\n+use its attribute converters.\n+\n+#### Override the mapping of a single attribute\n+Supply an AttributeConverter when creating the attribute to directly override any\n+converters provided by the table schema AttributeConverterProviders:\n+```java\n+private static final StaticTableSchema<Customer> CUSTOMER_TABLE_SCHEMA =\n+  StaticTableSchema.builder(Customer.class)\n+    .newItemSupplier(Customer::new)\n+    .addAttribute(String.class, a -> a.name(\"name\")\n+                                     a.getter(Customer::getName)\n+                                     a.setter(Customer::setName)\n+                                     a.attributeConverter(customAttributeConverter))\n+    .build();\n+```\n+\n+## Advanced BeanTableSchema scenarios\n+### Ignore attributes that should not participate in mapping to DDB\n+Mark the attribute with the @DynamoDbIgnore annotation:\n+```java\n+private String internalKey;\n+\n+@DynamoDbIgnore\n+public String getInternalKey() { return this.internalKey; }\n+public void setInternalKey(String internalKey) { return this.internalKey = internalKey;}\n+```\n+\n+### Mark attributes that should participate in mapping to DDB\n+Any attribute in a class marked with @DynamoDbBean will be included in the mapping as long\n+as it has a getter and a setter, according to the Java Bean standard. It's also\n+possible to explicitly mark attributes to participate in the mapping to DDB, with a custom name,\n+using the @DynamoDbAttribute annotation:\n+```java\n+private String internalKey;\n+\n+@DynamoDbAttribute(\"renamedInternalKey\")\n+public String getInternalKey() { return this.internalKey; }\n+public void setInternalKey(String internalKey) { return this.internalKey = internalKey;}\n+```\n+\n+### Flat map attributes from another class", "originalCommit": "c7e31a08fe87f1399f9a4724111eea07489b9887", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0NjUzMA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1731#discussion_r400546530", "bodyText": "Yes, I rearranged it and its clearer, consistent and less repetitive.", "author": "cenedhryn", "createdAt": "2020-03-30T23:04:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0ODM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjY0OTIxNw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1731#discussion_r396649217", "bodyText": "Same comment as before, I think we should organize by use-case and then a description of how to do it in the BeanTableSchema and then the StaticTableSchema", "author": "bmaizels", "createdAt": "2020-03-23T18:01:09Z", "path": "services-custom/dynamodb-enhanced/README.md", "diffHunk": "@@ -291,32 +296,205 @@ Using composition:\n public class Customer{\n   private String name;\n   private GenericRecord recordMetadata;\n+  //getters and setters for all attributes\n }\n \n @Data\n public class GenericRecord {\n   private String id;\n   private String createdDate;\n+  //getters and setters for all attributes\n }\n \n private static final StaticTableSchema<GenericRecord> GENERIC_RECORD_SCHEMA =\n   StaticTableSchema.builder(GenericRecord.class)\n-    .newItemSupplier(GenericRecord::new)\n-    .attributes(\n-      stringAttribute(\"id\", GenericRecord::getId, GenericRecord::setId).as(primaryPartitionKey()),\n-      stringAttribute(\"created_date\", GenericRecord::getCreatedDate, GenericRecord::setCreatedDate))\n-    .build();\n+      .addAttribute(String.class, a -> a.name(\"id\")\n+                                        .getter(GenericRecord::getId)\n+                                        .setter(GenericRecord::setId)\n+                                        .tags(primaryPartitionKey()))\n+      .addAttribute(String.class, a -> a.name(\"created_date\")\n+                                        .getter(GenericRecord::getCreatedDate)\n+                                        .setter(GenericRecord::setCreatedDate))\n+     .build();\n     \n private static final StaticTableSchema<Customer> CUSTOMER_TABLE_SCHEMA =\n   StaticTableSchema.builder(Customer.class)\n     .newItemSupplier(Customer::new)\n-    .attributes(stringAttribute(\"name\", Customer::getName, Customer::setName))\n+    .addAttribute(String.class, a -> a.name(\"name\")\n+                                      .getter(Customer::getName)\n+                                      .setter(Customer::setName))\n     // Because we are flattening a component object, we supply a getter and setter so the\n     // mapper knows how to access it\n-    .flatten(CUSTOMER_TABLE_SCHEMA, Customer::getRecordMetadata, Customer::setRecordMetadata)\n+    .flatten(GENERIC_RECORD_SCHEMA, Customer::getRecordMetadata, Customer::setRecordMetadata)\n     .build(); \n ```\n You can flatten as many different eligible classes as you like using the\n builder pattern. The only constraints are that attributes must not have\n the same name when they are being rolled together, and there must never\n-be more than one partition key, sort key or table name.\n\\ No newline at end of file\n+be more than one partition key, sort key or table name.\n+\n+### Control how attributes are converted\n+By default, the table schema provides converters for all primitive and many common Java types\n+through a default implementation of the AttributeConverterProvider interface. This behavior\n+can be changed both at the attribute converter provider level as well as for a single attribute.\n+#### Provide custom attribute converter providers\n+You can provide a single AttributeConverterProvider or a chain of ordered AttributeConverterProviders\n+ to the StaticTableSchema:\n+```java\n+private static final StaticTableSchema<Customer> CUSTOMER_TABLE_SCHEMA =\n+  StaticTableSchema.builder(Customer.class)\n+    .newItemSupplier(Customer::new)\n+    .addAttribute(String.class, a -> a.name(\"name\")\n+                                     a.getter(Customer::getName)\n+                                     a.setter(Customer::setName))\n+    .attributeConverterProviders(converterProvider1, converterProvider2)\n+    .build();\n+```\n+Note that if you supply your own chain of attribute converter providers, you will override\n+the default converter provider and must therefore include it in the chain if you wish to\n+use its attribute converters.\n+\n+#### Override the mapping of a single attribute\n+Supply an AttributeConverter when creating the attribute to directly override any\n+converters provided by the table schema AttributeConverterProviders:\n+```java\n+private static final StaticTableSchema<Customer> CUSTOMER_TABLE_SCHEMA =\n+  StaticTableSchema.builder(Customer.class)\n+    .newItemSupplier(Customer::new)\n+    .addAttribute(String.class, a -> a.name(\"name\")\n+                                     a.getter(Customer::getName)\n+                                     a.setter(Customer::setName)\n+                                     a.attributeConverter(customAttributeConverter))\n+    .build();\n+```\n+\n+## Advanced BeanTableSchema scenarios\n+### Ignore attributes that should not participate in mapping to DDB\n+Mark the attribute with the @DynamoDbIgnore annotation:\n+```java\n+private String internalKey;\n+\n+@DynamoDbIgnore\n+public String getInternalKey() { return this.internalKey; }\n+public void setInternalKey(String internalKey) { return this.internalKey = internalKey;}\n+```\n+\n+### Mark attributes that should participate in mapping to DDB\n+Any attribute in a class marked with @DynamoDbBean will be included in the mapping as long\n+as it has a getter and a setter, according to the Java Bean standard. It's also\n+possible to explicitly mark attributes to participate in the mapping to DDB, with a custom name,\n+using the @DynamoDbAttribute annotation:\n+```java\n+private String internalKey;\n+\n+@DynamoDbAttribute(\"renamedInternalKey\")\n+public String getInternalKey() { return this.internalKey; }\n+public void setInternalKey(String internalKey) { return this.internalKey = internalKey;}\n+```\n+\n+### Flat map attributes from another class\n+If the attributes for your table record are spread across several\n+different Java objects, either through inheritance or composition, the\n+BeanTableSchema provides methods to flat map\n+those attributes and rolling them up into a single schema.\n+\n+To accomplish this using inheritance, the only requirement is that\n+both classes are annotated as a DynamoDb bean:-\n+```java\n+@DynamoDbBean\n+public class Customer extends GenericRecord {\n+    private String name;\n+    private GenericRecord record;\n+\n+    public String getName() { return this.name; }\n+    public void setName(String name) { this.name = name;}\n+\n+    public String getRecord() { return this.record; }\n+    public void setRecord(String record) { this.record = record;}\n+}\n+\n+@DynamoDbBean\n+public abstract class GenericRecord {\n+    private String id;\n+    private String createdDate;\n+\n+    public String getId() { return this.id; }\n+    public void setId(String id) { this.id = id;}\n+\n+    public String getCreatedDate() { return this.createdDate; }\n+    public void setCreatedDate(String createdDate) { this.createdDate = createdDate;}\n+}\n+\n+```\n+\n+Using composition, the @DynamoDbFlatten annotation flat maps the composite class:\n+```java\n+@DynamoDbBean\n+public class Customer {\n+    private String name;\n+    private GenericRecord record;\n+\n+    public String getName() { return this.name; }\n+    public void setName(String name) { this.name = name;}\n+\n+    @DynamoDbFlatten(dynamoDbBeanClass = GenericRecord.class)\n+    public String getRecord() { return this.record; }\n+    public void setRecord(String record) { this.record = record;}\n+}\n+\n+@DynamoDbBean\n+public class GenericRecord {\n+    private String id;\n+    private String createdDate;\n+\n+    public String getId() { return this.id; }\n+    public void setId(String id) { this.id = id;}\n+\n+    public String getCreatedDate() { return this.createdDate; }\n+    public void setCreatedDate(String createdDate) { this.createdDate = createdDate;}\n+}\n+```\n+You can flatten as many different eligible classes as you like using the flatten annotation.\n+The only constraints are that attributes must not have the same name when they are being rolled\n+together, and there must never be more than one partition key, sort key or table name.\n+\n+### Control how attributes are converted", "originalCommit": "c7e31a08fe87f1399f9a4724111eea07489b9887", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2MTUzNg==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1731#discussion_r400561536", "bodyText": "Capital C?", "author": "bmaizels", "createdAt": "2020-03-30T23:49:56Z", "path": "services-custom/dynamodb-enhanced/README.md", "diffHunk": "@@ -248,14 +246,143 @@ Or using a StaticTableSchema:\n                                        .tags(versionAttribute())                         \n ```\n \n-## Advanced StaticTableSchema scenarios\n+## Advanced table schema features\n+### Explicitly include/exclude attributes in DDB mapping\n+#### Excluding attributes\n+Ignore attributes that should not participate in mapping to DDB\n+Mark the attribute with the @DynamoDbIgnore annotation:\n+```java\n+private String internalKey;\n+\n+@DynamoDbIgnore\n+public String getInternalKey() { return this.internalKey; }\n+public void setInternalKey(String internalKey) { return this.internalKey = internalKey;}\n+```\n+#### Including attributes\n+Change the name used to store an attribute in DBB by explicitly marking it with the\n+ @DynamoDbAttribute annotation and supplying a different name:\n+```java\n+private String internalKey;\n+\n+@DynamoDbAttribute(\"renamedInternalKey\")\n+public String getInternalKey() { return this.internalKey; }\n+public void setInternalKey(String internalKey) { return this.internalKey = internalKey;}\n+```\n+\n+### Control attribute conversion\n+By default, the table schema provides converters for all primitive and many common Java types\n+through a default implementation of the AttributeConverterProvider interface. This behavior\n+can be changed both at the attribute converter provider level as well as for a single attribute.\n+\n+#### Provide custom attribute converter providers\n+You can provide a single AttributeConverterProvider or a chain of ordered AttributeConverterProviders\n+through the @DynamoDbBean annotation. Any custom AttributeConverterProvider must extend the AttributeConverterProvider \n+interface. \n+\n+Note that if you supply your own chain of attribute converter providers, you will override\n+the default converter provider (DefaultAttributeConverterProvider) and must therefore include it in the chain if you wish to\n+use its attribute converters. It's also possible to annotate the bean with an empty array `{}`, thus\n+disabling the usage of any attribute converter providers including the default, in which case\n+all attributes must have their own attribute converters (see below).\n+\n+Single converter provider:\n+```java\n+@DynamoDbBean(converterProviders = converterProvider1.class)\n+public class Customer {\n+\n+}\n+```\n+\n+Chain of converter providers ending with the default (least priority):\n+```java\n+@DynamoDbBean(converterProviders = {\n+   converterProvider1.class, \n+   converterProvider2.class,", "originalCommit": "0592f9d69da66e73f7efcbf41bbc067b51d7030f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2NDE1OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1731#discussion_r400564158", "bodyText": ":-)", "author": "cenedhryn", "createdAt": "2020-03-30T23:58:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2MTUzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU2MTYyOA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1731#discussion_r400561628", "bodyText": "I think we should move this text underneath the StaticTableSchema example.", "author": "bmaizels", "createdAt": "2020-03-30T23:50:16Z", "path": "services-custom/dynamodb-enhanced/README.md", "diffHunk": "@@ -270,53 +397,96 @@ public abstract class GenericRecord {\n \n private static final StaticTableSchema<GenericRecord> GENERIC_RECORD_SCHEMA =\n   StaticTableSchema.builder(GenericRecord.class)\n-    .attributes(\n-          // The partition key will be inherited by the top level mapper\n-      stringAttribute(\"id\", GenericRecord::getId, GenericRecord::setId).as(primaryPartitionKey()),\n-      stringAttribute(\"created_date\", GenericRecord::getCreatedDate, GenericRecord::setCreatedDate))\n-    .build();\n+       // The partition key will be inherited by the top level mapper\n+      .addAttribute(String.class, a -> a.name(\"id\")\n+                                        .getter(GenericRecord::getId)\n+                                        .setter(GenericRecord::setId)\n+                                        .tags(primaryPartitionKey()))\n+      .addAttribute(String.class, a -> a.name(\"created_date\")\n+                                        .getter(GenericRecord::getCreatedDate)\n+                                        .setter(GenericRecord::setCreatedDate))\n+     .build();\n     \n private static final StaticTableSchema<Customer> CUSTOMER_TABLE_SCHEMA =\n   StaticTableSchema.builder(Customer.class)\n     .newItemSupplier(Customer::new)\n-    .attributes(\n-      stringAttribute(\"name\", Customer::getName, Customer::setName))\n+    .addAttribute(String.class, a -> a.name(\"name\")\n+                                      .getter(Customer::getName)\n+                                      .setter(Customer::setName))\n     .extend(GENERIC_RECORD_SCHEMA)     // All the attributes of the GenericRecord schema are added to Customer\n     .build();\n ```\n+#### Using composition\n+\n+Using composition, the @DynamoDbFlatten annotation flat maps the composite class:\n+```java\n+@DynamoDbBean\n+public class Customer {\n+    private String name;\n+    private GenericRecord record;\n+\n+    public String getName() { return this.name; }\n+    public void setName(String name) { this.name = name;}\n+\n+    @DynamoDbFlatten(dynamoDbBeanClass = GenericRecord.class)\n+    public String getRecord() { return this.record; }\n+    public void setRecord(String record) { this.record = record;}\n+}\n+\n+@DynamoDbBean\n+public class GenericRecord {\n+    private String id;\n+    private String createdDate;\n+\n+    public String getId() { return this.id; }\n+    public void setId(String id) { this.id = id;}\n+\n+    public String getCreatedDate() { return this.createdDate; }\n+    public void setCreatedDate(String createdDate) { this.createdDate = createdDate;}\n+}\n+```\n+You can flatten as many different eligible classes as you like using the flatten annotation.\n+The only constraints are that attributes must not have the same name when they are being rolled\n+together, and there must never be more than one partition key, sort key or table name.", "originalCommit": "0592f9d69da66e73f7efcbf41bbc067b51d7030f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5eb3c7438930c6099134c99eab01ab7ee63c2390", "url": "https://github.com/aws/aws-sdk-java-v2/commit/5eb3c7438930c6099134c99eab01ab7ee63c2390", "message": "DDB Enhanced: updates README with bean examples", "committedDate": "2020-04-01T18:30:29Z", "type": "commit"}, {"oid": "5eb3c7438930c6099134c99eab01ab7ee63c2390", "url": "https://github.com/aws/aws-sdk-java-v2/commit/5eb3c7438930c6099134c99eab01ab7ee63c2390", "message": "DDB Enhanced: updates README with bean examples", "committedDate": "2020-04-01T18:30:29Z", "type": "forcePushed"}, {"oid": "98b7b771ed5d74528c1c9533dfec5f74128236cd", "url": "https://github.com/aws/aws-sdk-java-v2/commit/98b7b771ed5d74528c1c9533dfec5f74128236cd", "message": "Merge branch 'master' into salande/enhanced-ddb-annotation-readme", "committedDate": "2020-04-01T20:07:16Z", "type": "commit"}]}