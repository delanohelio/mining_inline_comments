{"pr_number": 1854, "pr_title": "Update docs based on latest discussions", "pr_createdAt": "2020-05-19T23:43:14Z", "pr_url": "https://github.com/aws/aws-sdk-java-v2/pull/1854", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE2MzkzOQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1854#discussion_r428163939", "bodyText": "collectd -> collected", "author": "cenedhryn", "createdAt": "2020-05-20T16:52:51Z", "path": "docs/design/core/metrics/Design.md", "diffHunk": "@@ -1,41 +1,62 @@\n+# SDK Metrics System\n ## Concepts\n ### Metric\n-* A representation of data collected\n-* Metric can be one of the following types: Counter, Gauge, Timer\n-* Metric can be associated to a category. Some of the metric categories are Default, HttpClient, Streaming etc\n+* A measure of some aspect of the SDK. Examples include request latency, number\n+  of pooled connections and retries executed.\n \n-### MetricRegistry\n+* A metric is associated to a category. Some of the metric categories are\n+  `Default`, `HttpClient` and `Streaming`. This enables customers to enable\n+  metrics only for categories they are interested in.\n \n-* A MetricRegistry represent an interface to store the collected metric data. It can hold different types of Metrics\n-  described above\n-* MetricRegistry is generic and not tied to specific category (ApiCall, HttpClient etc) of metrics.\n-* Each API call has it own instance of a MetricRegistry. All metrics collected in the ApiCall lifecycle are stored in\n-  that instance.\n-* A MetricRegistry can store other instances of same type. This can be used to store metrics for each Attempt in an Api\n-  Call.\n-* [Interface prototype](prototype/MetricRegistry.java)\n+Refer to the [Metrics List](./MetricsList.md) document for a complete list of\n+standard metrics collected by the SDK.\n+\n+### Metric Collector\n+\n+* `MetricCollector` is a typesafe aggregator of of metrics. This is the primary\n+  interface through which other SDK components report metrics they emit, using\n+  the `reportMetric(SdkMetric,Object)` method.\n+\n+* `MetricCollector` objects allow for nesting. This enables metrics to be\n+  collected in the context of other metric events. For example, for a single\n+  API call, there may be multiple request attempts if there are retries. Each\n+  attempt's associated metric events can be stored in their own\n+  `MetricCollector`, all of which are children of another collector that\n+  represents metrics for the entire API call.\n+\n+  A child of a collector is created by calling its `childCollector(String)`\n+  method.\n+\n+* The `collect()` method returns a `MetricCollection`. This class essentially\n+  returns an immutable version of the tree formed by the collector and its\n+  children, which are also represented by `MetricCollection` objects.\n+\n+  Note that calling `collect()` implies that child collectors are are also\n+  collectd.", "originalCommit": "c0bd459403fe16ac6c1b068ec1d65d49223db5bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE2NjU0Mg==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1854#discussion_r428166542", "bodyText": "tenet -> tenets", "author": "cenedhryn", "createdAt": "2020-05-20T16:56:58Z", "path": "docs/design/core/metrics/Design.md", "diffHunk": "@@ -155,126 +176,18 @@ New modules are created to support metrics feature.\n * Customers has to **explicitly add dependency** on these modules to use the sdk provided publishers\n \n \n-## Sequence Diagram\n-\n-<b>Metrics Collection</b>\n-\n-<div style=\"text-align: center;\">\n-\n-![Metrics Collection](images/MetricCollection.jpg)\n-\n-</div>\n-\n-<b>MetricPublisher</b>\n-\n-<div style=\"text-align: center;\">\n-\n-![MetricPublisher fig.align=\"left\"](images/MetricPublisher.jpg)\n-\n-</div>\n-\n-1. Client enables metrics feature through MetricConfigurationProvider and configure publishers through\n-   MetricPublisherConfiguration.\n-2. For each API call, a new MetricRegistry object is created and stored in the ExecutionAttributes. If metrics are not\n-   enabled, a NoOpMetricRegistry is used.\n-3. At each metric collection point, the metric is registered in the MetricRegistry object if its category is enabled in\n-   MetricConfigurationProvider.\n-4. The metrics that are collected once for a Api Call execution are stored in the METRIC_REGISTRY ExecutionAttribute.\n-5. The metrics that are collected per Api Call attempt are stored in new MetricRegistry instances which are part of the\n-   ApiCall MetricRegistry.  These MetricRegistry instance for the current attempt is also accessed through\n-   ATTEMPT_METRIC_REGISTRY ExecutionAttribute.\n-6. At end of API call, report the MetricRegistry object to MetricPublishers by calling registerMetrics(MetricRegistry)\n-   method. This is done in an ExecutionInterceptor.\n-7. Steps 2 to 6 are repeated for each API call\n-8. MetricPublisher calls publish() method to report metrics to external sources. The frequency of publish() method call\n-   is unique to Publisher implementation.\n-9. Client has access to all registered publishers and it can call publish() method explicitly if desired.\n-\n-\n-<b>CloudWatch MetricPublisher</b>\n-\n-<div style=\"text-align: center;\">\n-\n-![CloudWatch MetricPublisher](images/CWMetricPublisher.jpg)\n-\n-</div>\n-\n-## Implementation Details\n-Few important implementation details are discussed in this section.\n-\n-SDK modules can be organized as shown in this image.\n-\n-<div style=\"text-align: center;\">\n-\n-![Module Hierarchy](images/MetricsModulesHierarchy.png)\n-\n-</div>\n-\n-* Core modules - Modules in the core directory while have access to ExecutionContext and ExecutionAttributes\n-* Downstream modules - Modules where execution occurs after core modules. For example, http-clients is downstream module\n-  as the request is transferred from core to http client for further execution.\n-* Upstream modules - Modules that live in layers above core. Examples are High Level libraries (HLL) or Applications\n-  that use SDK. Execution goes from Upstream modules to core modules.\n-\n-### Core Modules\n-* SDK will use ExecutionAttributes to pass the MetricConfigurationProvider information through out the core module where\n-  core request-response metrics are collected.\n-* Instead of checking whether metrics is enabled at each metric collection point, SDK will use the instance of\n-  NoOpMetricRegistry (if metrics are disabled) and DefaultMetricRegistry (if metrics are enabled).\n-* The NoOpMetricRegistry class does not collect or store any metric data. Instead of creating a new NoOpMetricRegistry\n-  instance for each request, use the same instance for every request to avoid additional object creation.\n-* The DefaultMetricRegistry class will only collect metrics if they belong to the MetricCategory list provided in the\n-  MetricConfigurationProvider. To support this, DefaultMetricRegistry is decorated by another class to filter metric\n-  categories that are not set in MetricConfigurationProvider.\n-\n-### Downstream Modules\n-* The MetricRegistry object and other required metric configuration details will be passed to the classes in downstream\n-  modules.\n-* For example, HttpExecuteRequest for sync http client, AsyncExecuteRequest for async http client.\n-* Downstream modules record the metric data directly into the given MetricRegistry object.\n-* As we use same MetricRegistry object for core and downstream modules, both metrics will be reported to the Publisher\n-  together.\n-\n-### Upstream Modules\n-* As MetricRegistry object is created after the execution is passed from Upstream modules, these modules won't be able\n-  to modify/add to the core metrics.\n-* If upstream modules want to report additional metrics using the registered publishers, they would need to create\n-  MetricRegistry instances and explicitly call the methods on the Publishers.\n-* It would be useful to get the low-level API metrics in these modules, so SDK will expose APIs to get an immutable\n-  version of the MetricRegistry object so that upstream classes can use that information in  their metric calculation.\n-\n-### Reporting\n-* Collected metrics are reported to the configured publishers at the end of each Api Call by calling\n-  `registerMetrics(MetricRegistry)` method on MetricPublisher.\n-* The MetricRegistry argument in the registerMetrics method will have data on the entire Api Call including retries.\n-* This reporting is done in `MetricsExecutionInterceptor` via `afterExecution()` and `onExecutionFailure()` methods.\n-* `MetricsExecutionInterceptor` will always be the last configured ExecutionInterceptor in the interceptor chain\n-\n-\n ## Performance\n-One of the main tenet for metrics is \u201cEnabling default metrics should have minimal impact on the application\n-performance\". The following design choices are made to ensure enabling metrics does not effect performance\n-significantly.\n-* When collecting metrics, a NoOpRegistry is used if metrics are disabled. All methods in this registry are no-op and\n-  return immediately.  This also has the additional benefit of avoid metricsEnabled check at each metric collection\n-  point.\n-* Metric publisher implementations can involve network calls and impact latency if done in blocking way. So all SDK\n-  publisher implementation will process the metrics asynchronously and does not block the actual request.\n-\n-\n-## Testing\n-\n-To ensure performance is not impacted due to metrics, tests should be written with various scenarios and a baseline for\n-overhead should be created.  These tests should be run regularly to catch regressions.\n-\n-### Test Cases\n-\n-SDK will be tested under load for each of these test cases using the load testing framework we already have.  Each of\n-these test case results should be compared with metrics feature disabled & enabled, and then comparing the results.\n-\n-1. Enable each metrics publisher (CloudWatch, CSM) individually.\n-2. Enable all metrics publishers.\n-3. Individually enable each metric category to find overhead for each MetricCategory.\n+One of the main tenet for metrics is \u201cEnabling default metrics should have", "originalCommit": "c0bd459403fe16ac6c1b068ec1d65d49223db5bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE2NzcxOA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1854#discussion_r428167718", "bodyText": "Suggestion: Therefore, all SDK publisher implementations will process the\nmetrics asynchronously to not block the actual request.", "author": "cenedhryn", "createdAt": "2020-05-20T16:58:47Z", "path": "docs/design/core/metrics/Design.md", "diffHunk": "@@ -155,126 +176,18 @@ New modules are created to support metrics feature.\n * Customers has to **explicitly add dependency** on these modules to use the sdk provided publishers\n \n \n-## Sequence Diagram\n-\n-<b>Metrics Collection</b>\n-\n-<div style=\"text-align: center;\">\n-\n-![Metrics Collection](images/MetricCollection.jpg)\n-\n-</div>\n-\n-<b>MetricPublisher</b>\n-\n-<div style=\"text-align: center;\">\n-\n-![MetricPublisher fig.align=\"left\"](images/MetricPublisher.jpg)\n-\n-</div>\n-\n-1. Client enables metrics feature through MetricConfigurationProvider and configure publishers through\n-   MetricPublisherConfiguration.\n-2. For each API call, a new MetricRegistry object is created and stored in the ExecutionAttributes. If metrics are not\n-   enabled, a NoOpMetricRegistry is used.\n-3. At each metric collection point, the metric is registered in the MetricRegistry object if its category is enabled in\n-   MetricConfigurationProvider.\n-4. The metrics that are collected once for a Api Call execution are stored in the METRIC_REGISTRY ExecutionAttribute.\n-5. The metrics that are collected per Api Call attempt are stored in new MetricRegistry instances which are part of the\n-   ApiCall MetricRegistry.  These MetricRegistry instance for the current attempt is also accessed through\n-   ATTEMPT_METRIC_REGISTRY ExecutionAttribute.\n-6. At end of API call, report the MetricRegistry object to MetricPublishers by calling registerMetrics(MetricRegistry)\n-   method. This is done in an ExecutionInterceptor.\n-7. Steps 2 to 6 are repeated for each API call\n-8. MetricPublisher calls publish() method to report metrics to external sources. The frequency of publish() method call\n-   is unique to Publisher implementation.\n-9. Client has access to all registered publishers and it can call publish() method explicitly if desired.\n-\n-\n-<b>CloudWatch MetricPublisher</b>\n-\n-<div style=\"text-align: center;\">\n-\n-![CloudWatch MetricPublisher](images/CWMetricPublisher.jpg)\n-\n-</div>\n-\n-## Implementation Details\n-Few important implementation details are discussed in this section.\n-\n-SDK modules can be organized as shown in this image.\n-\n-<div style=\"text-align: center;\">\n-\n-![Module Hierarchy](images/MetricsModulesHierarchy.png)\n-\n-</div>\n-\n-* Core modules - Modules in the core directory while have access to ExecutionContext and ExecutionAttributes\n-* Downstream modules - Modules where execution occurs after core modules. For example, http-clients is downstream module\n-  as the request is transferred from core to http client for further execution.\n-* Upstream modules - Modules that live in layers above core. Examples are High Level libraries (HLL) or Applications\n-  that use SDK. Execution goes from Upstream modules to core modules.\n-\n-### Core Modules\n-* SDK will use ExecutionAttributes to pass the MetricConfigurationProvider information through out the core module where\n-  core request-response metrics are collected.\n-* Instead of checking whether metrics is enabled at each metric collection point, SDK will use the instance of\n-  NoOpMetricRegistry (if metrics are disabled) and DefaultMetricRegistry (if metrics are enabled).\n-* The NoOpMetricRegistry class does not collect or store any metric data. Instead of creating a new NoOpMetricRegistry\n-  instance for each request, use the same instance for every request to avoid additional object creation.\n-* The DefaultMetricRegistry class will only collect metrics if they belong to the MetricCategory list provided in the\n-  MetricConfigurationProvider. To support this, DefaultMetricRegistry is decorated by another class to filter metric\n-  categories that are not set in MetricConfigurationProvider.\n-\n-### Downstream Modules\n-* The MetricRegistry object and other required metric configuration details will be passed to the classes in downstream\n-  modules.\n-* For example, HttpExecuteRequest for sync http client, AsyncExecuteRequest for async http client.\n-* Downstream modules record the metric data directly into the given MetricRegistry object.\n-* As we use same MetricRegistry object for core and downstream modules, both metrics will be reported to the Publisher\n-  together.\n-\n-### Upstream Modules\n-* As MetricRegistry object is created after the execution is passed from Upstream modules, these modules won't be able\n-  to modify/add to the core metrics.\n-* If upstream modules want to report additional metrics using the registered publishers, they would need to create\n-  MetricRegistry instances and explicitly call the methods on the Publishers.\n-* It would be useful to get the low-level API metrics in these modules, so SDK will expose APIs to get an immutable\n-  version of the MetricRegistry object so that upstream classes can use that information in  their metric calculation.\n-\n-### Reporting\n-* Collected metrics are reported to the configured publishers at the end of each Api Call by calling\n-  `registerMetrics(MetricRegistry)` method on MetricPublisher.\n-* The MetricRegistry argument in the registerMetrics method will have data on the entire Api Call including retries.\n-* This reporting is done in `MetricsExecutionInterceptor` via `afterExecution()` and `onExecutionFailure()` methods.\n-* `MetricsExecutionInterceptor` will always be the last configured ExecutionInterceptor in the interceptor chain\n-\n-\n ## Performance\n-One of the main tenet for metrics is \u201cEnabling default metrics should have minimal impact on the application\n-performance\". The following design choices are made to ensure enabling metrics does not effect performance\n-significantly.\n-* When collecting metrics, a NoOpRegistry is used if metrics are disabled. All methods in this registry are no-op and\n-  return immediately.  This also has the additional benefit of avoid metricsEnabled check at each metric collection\n-  point.\n-* Metric publisher implementations can involve network calls and impact latency if done in blocking way. So all SDK\n-  publisher implementation will process the metrics asynchronously and does not block the actual request.\n-\n-\n-## Testing\n-\n-To ensure performance is not impacted due to metrics, tests should be written with various scenarios and a baseline for\n-overhead should be created.  These tests should be run regularly to catch regressions.\n-\n-### Test Cases\n-\n-SDK will be tested under load for each of these test cases using the load testing framework we already have.  Each of\n-these test case results should be compared with metrics feature disabled & enabled, and then comparing the results.\n-\n-1. Enable each metrics publisher (CloudWatch, CSM) individually.\n-2. Enable all metrics publishers.\n-3. Individually enable each metric category to find overhead for each MetricCategory.\n+One of the main tenet for metrics is \u201cEnabling default metrics should have\n+minimal impact on the application performance\". The following design choices are\n+made to ensure enabling metrics does not effect performance significantly.\n \n+* When collecting metrics, a No-op metric collector is used if metrics are\n+  disabled. All methods in this collector are no-op and return immediately.\n \n+* Metric publisher implementations can involve network calls and impact latency\n+  if done in blocking way. So all SDK publisher implementation will process the\n+  metrics asynchronously and does not block the actual request.", "originalCommit": "c0bd459403fe16ac6c1b068ec1d65d49223db5bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODE3MTI1Ng==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1854#discussion_r428171256", "bodyText": "Seems to be a repeat of the multithreading info", "author": "cenedhryn", "createdAt": "2020-05-20T17:04:37Z", "path": "docs/design/core/metrics/prototype/MetricPublisher.java", "diffHunk": "@@ -1,68 +1,48 @@\n-/*\n- * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n- *\n- * Licensed under the Apache License, Version 2.0 (the \"License\").\n- * You may not use this file except in compliance with the License.\n- * A copy of the License is located at\n- *\n- *  http://aws.amazon.com/apache2.0\n- *\n- * or in the \"license\" file accompanying this file. This file is distributed\n- * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n- * express or implied. See the License for the specific language governing\n- * permissions and limitations under the License.\n- */\n-\n-package software.amazon.awssdk.metrics.publisher;\n-\n-import java.util.concurrent.CompletableFuture;\n-import software.amazon.awssdk.annotations.SdkPublicApi;\n-import software.amazon.awssdk.metrics.registry.MetricRegistry;\n-\n /**\n- * Interface to report and publish the collected SDK metrics to external sources.\n- *\n- * Publisher implementations create and maintain resources (like clients, thread pool etc) that are used for publishing.\n- * They should be closed in the close() method to avoid resource leakage.\n- *\n+ * Interface to report and publish the collected SDK metric events to external\n+ * sources.\n  * <p>\n- *     As metrics are not part of the business logic, failures caused by metrics features should not fail the application.\n- *     So SDK publisher implementations suppress all errors during the metrics publishing and log them.\n- * </p>\n- *\n+ * Conceptually, a publisher receives a stream of {@link MetricCollection}\n+ * objects overs its lifetime through its {@link #publish(MetricCollection)} )}\n+ * method.  Implementations are then free further aggregate these events into\n+ * sets of metrics that are then published to some external system for further\n+ * use.  As long as a publisher is not closed, then it can receive {@code\n+ * MetricCollection} objects at any time. In addition, as the SDK makes use of\n+ * multithreading, it's possible that the publisher is shared concurrently by\n+ * multiple threads, and necessitates that all implementations are threadsafe.\n  * <p>\n- *     In certain situations (high throttling errors, metrics are reported faster than publishing etc), storing all the metrics\n- *     might take up lot of memory and can crash the application. In these cases, it is recommended to have a max limit on\n- *     number of metrics stored or memory used for metrics and drop the metrics when the limit is breached.\n- * </p>\n+ * The SDK may invoke methods on the interface from multiple threads", "originalCommit": "c0bd459403fe16ac6c1b068ec1d65d49223db5bd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5c2eef6127a3245c079682fc0fbc51d489dc89e2", "url": "https://github.com/aws/aws-sdk-java-v2/commit/5c2eef6127a3245c079682fc0fbc51d489dc89e2", "message": "Update docs based on latest discussions", "committedDate": "2020-05-19T23:38:56Z", "type": "forcePushed"}, {"oid": "6d110279e588a3731fd49d2d3e1e2cca9b183701", "url": "https://github.com/aws/aws-sdk-java-v2/commit/6d110279e588a3731fd49d2d3e1e2cca9b183701", "message": "Update docs based on latest discussions", "committedDate": "2020-05-20T17:41:32Z", "type": "commit"}, {"oid": "6d110279e588a3731fd49d2d3e1e2cca9b183701", "url": "https://github.com/aws/aws-sdk-java-v2/commit/6d110279e588a3731fd49d2d3e1e2cca9b183701", "message": "Update docs based on latest discussions", "committedDate": "2020-05-20T17:41:32Z", "type": "forcePushed"}]}