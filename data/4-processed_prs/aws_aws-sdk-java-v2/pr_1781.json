{"pr_number": 1781, "pr_title": "Replace InstantAsInteger with InstantAsString and test", "pr_createdAt": "2020-04-15T23:58:10Z", "pr_url": "https://github.com/aws/aws-sdk-java-v2/pull/1781", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5MTE1Nw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409691157", "bodyText": "Nit: Any reason we broke the alphabetical ordering here?", "author": "bmaizels", "createdAt": "2020-04-16T16:30:05Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/DefaultAttributeConverterProvider.java", "diffHunk": "@@ -211,8 +211,8 @@ private static Builder getDefaultBuilder() {\n                                                 .addConverter(DoubleAttributeConverter.create())\n                                                 .addConverter(DurationAttributeConverter.create())\n                                                 .addConverter(FloatAttributeConverter.create())\n-                                                .addConverter(InstantAsIntegerAttributeConverter.create())\n                                                 .addConverter(IntegerAttributeConverter.create())\n+                                                .addConverter(InstantAsStringAttributeConverter.create())", "originalCommit": "2b891359df3186f93baeb27722d92f16456502fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5MzEzMA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409693130", "bodyText": "Does this not break the data-loss rule?", "author": "bmaizels", "createdAt": "2020-04-16T16:33:13Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/InstantAsStringAttributeConverter.java", "diffHunk": "@@ -53,9 +52,9 @@\n  * </ul>\n  *\n  * <p>\n- * This converter can read any values written by itself, {@link InstantAsIntegerAttributeConverter},\n- * {@link OffsetDateTimeAsStringAttributeConverter} or {@link ZonedDateTimeAsStringAttributeConverter}. Offset and zoned times\n- * will be automatically converted to the equivalent {@code Instant} based on the time zone information in the record (e.g.\n+ * This converter can read any values written by itself, {@link OffsetDateTimeAsStringAttributeConverter}\n+ * or {@link ZonedDateTimeAsStringAttributeConverter}. Offset and zoned times will be automatically converted to\n+ * the equivalent {@code Instant} based on the time zone information in the record (e.g.", "originalCommit": "2b891359df3186f93baeb27722d92f16456502fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5NDM4OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409694388", "bodyText": "LocalDate should not store timezone information. Writing a valid ISO8601 output here risks it being read as an Instant and breaking the data-loss rule. I would propose having it write \"YYYY-MM-DD\" and allowing LocalDateTime to parse that format.", "author": "bmaizels", "createdAt": "2020-04-16T16:35:14Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateAttributeConverter.java", "diffHunk": "@@ -24,16 +24,17 @@\n import software.amazon.awssdk.enhanced.dynamodb.AttributeConverter;\n import software.amazon.awssdk.enhanced.dynamodb.AttributeValueType;\n import software.amazon.awssdk.enhanced.dynamodb.EnhancedType;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.converter.ConverterUtils;\n import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n \n /**\n  * A converter between {@link LocalDate} and {@link AttributeValue}.\n  *\n  * <p>\n- * This stores and reads values in DynamoDB as a number, so that they can be sorted numerically as part of a sort key.\n+ * This stores and reads values in DynamoDB as a String.\n  *\n  * <p>\n- * LocalDateTimes are stored in the format \"[-]YYYYMMDD000000\", where:\n+ * LocalDateTimes are stored in the format \"[-]YYYY-MM-DDT00:00:00Z\", where:", "originalCommit": "2b891359df3186f93baeb27722d92f16456502fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5NjcxNg==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409696716", "bodyText": "We should not store timezone information for LocalDateTime. The actual string format being proposed omits it, but this description implies it will be there (the 'Z')", "author": "bmaizels", "createdAt": "2020-04-16T16:38:46Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateTimeAttributeConverter.java", "diffHunk": "@@ -35,10 +35,13 @@\n  * A converter between {@link LocalDateTime} and {@link AttributeValue}.\n  *\n  * <p>\n- * This stores and reads values in DynamoDB as a number, so that they can be sorted numerically as part of a sort key.\n+ * This stores and reads values in DynamoDB as a string.\n  *\n  * <p>\n- * LocalDateTimes are stored in the format \"[-]YYYYMMDDHHIISS[.NNNNNNNNN]\", where:\n+ * Values are stored in ISO-8601 format, with nanosecond precision and a time zone of UTC.", "originalCommit": "2b891359df3186f93baeb27722d92f16456502fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5ODA3OQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409698079", "bodyText": "MonthDay?", "author": "bmaizels", "createdAt": "2020-04-16T16:40:50Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/MonthDayAttributeConverter.java", "diffHunk": "@@ -28,16 +28,15 @@\n import software.amazon.awssdk.enhanced.dynamodb.internal.converter.ConverterUtils;\n import software.amazon.awssdk.enhanced.dynamodb.internal.converter.TypeConvertingVisitor;\n import software.amazon.awssdk.services.dynamodb.model.AttributeValue;\n-import software.amazon.awssdk.utils.Validate;\n \n /**\n  * A converter between {@link MonthDay} and {@link AttributeValue}.\n  *\n  * <p>\n- * This stores and reads values in DynamoDB as a number, so that they can be sorted numerically as part of a sort key.\n+ * This stores and reads values in DynamoDB as a String.\n  *\n  * <p>\n- * LocalTimes are stored in the format \"MMDD\", where:\n+ * LocalTimes are stored in the format \"MM-DD\", where:", "originalCommit": "2b891359df3186f93baeb27722d92f16456502fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY5ODk0OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409698948", "bodyText": "What about if the ZonedDateTime uses a named Zone, does this not break the data-loss principle?", "author": "bmaizels", "createdAt": "2020-04-16T16:42:10Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/OffsetDateTimeAsStringAttributeConverter.java", "diffHunk": "@@ -58,9 +58,9 @@\n  * </ul>\n  *\n  * <p>\n- * This converter can read any values written by itself, {@link InstantAsIntegerAttributeConverter},\n- * {@link InstantAsStringAttributeConverter}, or {@link ZonedDateTimeAsStringAttributeConverter}. Values written by\n- * {@code Instant} converters are treated as if they are in the UTC time zone (and an offset of 0 seconds will be returned).\n+ * This converter can read any values written by itself, {@link InstantAsStringAttributeConverter},\n+ * or {@link ZonedDateTimeAsStringAttributeConverter}. Values written by {@code Instant} converters\n+ * are treated as if they are in the UTC time zone (and an offset of 0 seconds will be returned).", "originalCommit": "2b891359df3186f93baeb27722d92f16456502fb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "19ff01fc8b80925357267958330b451b551a786b", "url": "https://github.com/aws/aws-sdk-java-v2/commit/19ff01fc8b80925357267958330b451b551a786b", "message": "Updated code to resolve comments", "committedDate": "2020-04-16T23:35:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxMTE5OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409911198", "bodyText": "Please can we split these into individual tests.", "author": "bmaizels", "createdAt": "2020-04-16T23:44:08Z", "path": "services-custom/dynamodb-enhanced/src/test/java/software/amazon/awssdk/enhanced/dynamodb/converters/attribute/GlobalDateTimeAttributeConvertersTest.java", "diffHunk": "@@ -84,8 +48,18 @@ public void instantAsStringAttributeConverterBehaves() {\n         assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"X\")));\n         assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"+1000000001-01-01T00:00:00Z\")));\n \n-        // InstantAsIntegerAttributeConverter format\n-        assertThat(transformTo(converter, EnhancedAttributeValue.fromNumber(\"0\"))).isEqualTo(Instant.EPOCH);\n+        // Not accepted types tests\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1988-05-21T00:12:00.000000001\")\n+                                                                       .toAttributeValue()));\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1988-05-21\")\n+                                                                       .toAttributeValue()));\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"00:12:00.000000001\")\n+                                                                       .toAttributeValue()));\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1988-05-21T00:12:00+01:00\")\n+                                                                       .toAttributeValue()));\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1988-05-21T00:12:00+01:00[Europe/Paris]\")\n+                                                                       .toAttributeValue()));\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"05-21\").toAttributeValue()));", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxMjg0Ng==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409912846", "bodyText": "Please apply this comment everywhere as we discussed offline.", "author": "bmaizels", "createdAt": "2020-04-16T23:49:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxMTE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxNjQzMw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409916433", "bodyText": "Can we have little javadocs on these so it's easier for me to assert they are doing what they are supposed to be doing.", "author": "bmaizels", "createdAt": "2020-04-17T00:01:17Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java", "diffHunk": "@@ -128,55 +128,52 @@ private static int findTrimExclusiveEnd(String string, char characterToTrim, int\n         }\n     }\n \n-    public static String[] chunk(String valueToChunk, int... splitSizes) {\n-        String[] result = new String[splitSizes.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizes);\n+    public static String[] chunkDateTime(String valueToChunk) {", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxNjc1OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409916758", "bodyText": "This requires three iterations through the string, can we do it in a single pass?", "author": "bmaizels", "createdAt": "2020-04-17T00:02:34Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java", "diffHunk": "@@ -128,55 +128,52 @@ private static int findTrimExclusiveEnd(String string, char characterToTrim, int\n         }\n     }\n \n-    public static String[] chunk(String valueToChunk, int... splitSizes) {\n-        String[] result = new String[splitSizes.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizes);\n+    public static String[] chunkDateTime(String valueToChunk) {\n+        Validate.isTrue(valueToChunk.contains(\"T\") && !valueToChunk.contains(\"+\") && !valueToChunk.contains(\"Z\"),\n+                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxNzMxNQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409917315", "bodyText": "This code is difficult to read, can we split it up into more logical and readable statements.", "author": "bmaizels", "createdAt": "2020-04-17T00:04:30Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java", "diffHunk": "@@ -128,55 +128,52 @@ private static int findTrimExclusiveEnd(String string, char characterToTrim, int\n         }\n     }\n \n-    public static String[] chunk(String valueToChunk, int... splitSizes) {\n-        String[] result = new String[splitSizes.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizes);\n+    public static String[] chunkDateTime(String valueToChunk) {\n+        Validate.isTrue(valueToChunk.contains(\"T\") && !valueToChunk.contains(\"+\") && !valueToChunk.contains(\"Z\"),\n+                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        String negativeSig = \"\";\n+        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n+            negativeSig = \"-\";\n+            valueToChunk = valueToChunk.substring(1);\n+        }\n \n-        Validate.isTrue(splitStartInclusive == valueToChunk.length(), \"Value size does not match expected chunking scheme.\");\n+        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");\n+        chunkedDateTime[0] =  negativeSig + chunkedDateTime[0];\n \n-        return result;\n+        Validate.isTrue(3 * valueToChunk.length() - valueToChunk.replace(\"T\", \"\").length()\n+                        - valueToChunk.replace(\":\", \"\").length() - valueToChunk.replace(\"-\", \"\").length() == 5\n+                        && chunkedDateTime.length == 6,\n+                        \"Invalid DateTime (without nanoseconds) format, expected [-]YYYY-MM-DDTHH:MM:SS.\");", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxNzU1NQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409917555", "bodyText": "Can we have a javadoc so I can assert it's doing what it's supposed to do", "author": "bmaizels", "createdAt": "2020-04-17T00:05:21Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java", "diffHunk": "@@ -128,55 +128,52 @@ private static int findTrimExclusiveEnd(String string, char characterToTrim, int\n         }\n     }\n \n-    public static String[] chunk(String valueToChunk, int... splitSizes) {\n-        String[] result = new String[splitSizes.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizes);\n+    public static String[] chunkDateTime(String valueToChunk) {\n+        Validate.isTrue(valueToChunk.contains(\"T\") && !valueToChunk.contains(\"+\") && !valueToChunk.contains(\"Z\"),\n+                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        String negativeSig = \"\";\n+        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n+            negativeSig = \"-\";\n+            valueToChunk = valueToChunk.substring(1);\n+        }\n \n-        Validate.isTrue(splitStartInclusive == valueToChunk.length(), \"Value size does not match expected chunking scheme.\");\n+        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");\n+        chunkedDateTime[0] =  negativeSig + chunkedDateTime[0];\n \n-        return result;\n+        Validate.isTrue(3 * valueToChunk.length() - valueToChunk.replace(\"T\", \"\").length()\n+                        - valueToChunk.replace(\":\", \"\").length() - valueToChunk.replace(\"-\", \"\").length() == 5\n+                        && chunkedDateTime.length == 6,\n+                        \"Invalid DateTime (without nanoseconds) format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        return chunkedDateTime;\n     }\n \n-    public static String[] chunkWithRightOverflow(String valueToChunk, int... splitSizesFromLeft) {\n-        String[] result = new String[splitSizesFromLeft.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizesFromLeft);\n-\n-        result[splitSizesFromLeft.length] = valueToChunk.substring(splitStartInclusive);\n-\n-        return result;\n+    public static String[] chunkTime(String valueToChunk) {", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxNzcwNQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409917705", "bodyText": "This code is difficult to read, can we split it up into more logical and readable statements.", "author": "bmaizels", "createdAt": "2020-04-17T00:05:57Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java", "diffHunk": "@@ -128,55 +128,52 @@ private static int findTrimExclusiveEnd(String string, char characterToTrim, int\n         }\n     }\n \n-    public static String[] chunk(String valueToChunk, int... splitSizes) {\n-        String[] result = new String[splitSizes.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizes);\n+    public static String[] chunkDateTime(String valueToChunk) {\n+        Validate.isTrue(valueToChunk.contains(\"T\") && !valueToChunk.contains(\"+\") && !valueToChunk.contains(\"Z\"),\n+                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        String negativeSig = \"\";\n+        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n+            negativeSig = \"-\";\n+            valueToChunk = valueToChunk.substring(1);\n+        }\n \n-        Validate.isTrue(splitStartInclusive == valueToChunk.length(), \"Value size does not match expected chunking scheme.\");\n+        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");\n+        chunkedDateTime[0] =  negativeSig + chunkedDateTime[0];\n \n-        return result;\n+        Validate.isTrue(3 * valueToChunk.length() - valueToChunk.replace(\"T\", \"\").length()\n+                        - valueToChunk.replace(\":\", \"\").length() - valueToChunk.replace(\"-\", \"\").length() == 5\n+                        && chunkedDateTime.length == 6,\n+                        \"Invalid DateTime (without nanoseconds) format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        return chunkedDateTime;\n     }\n \n-    public static String[] chunkWithRightOverflow(String valueToChunk, int... splitSizesFromLeft) {\n-        String[] result = new String[splitSizesFromLeft.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizesFromLeft);\n-\n-        result[splitSizesFromLeft.length] = valueToChunk.substring(splitStartInclusive);\n-\n-        return result;\n+    public static String[] chunkTime(String valueToChunk) {\n+        String[] chunkedTime = valueToChunk.split(\":\");\n+        Validate.isTrue((valueToChunk.length() - valueToChunk.replace(\":\", \"\").length()) == 2\n+                         && chunkedTime.length == 3,\n+                        \"Invalid time format, expected HH:MM:SS.\");", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxNzg2Mw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409917863", "bodyText": "Can we have a javadoc so I can assert this is doing what it's supposed to do.", "author": "bmaizels", "createdAt": "2020-04-17T00:06:31Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java", "diffHunk": "@@ -128,55 +128,52 @@ private static int findTrimExclusiveEnd(String string, char characterToTrim, int\n         }\n     }\n \n-    public static String[] chunk(String valueToChunk, int... splitSizes) {\n-        String[] result = new String[splitSizes.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizes);\n+    public static String[] chunkDateTime(String valueToChunk) {\n+        Validate.isTrue(valueToChunk.contains(\"T\") && !valueToChunk.contains(\"+\") && !valueToChunk.contains(\"Z\"),\n+                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        String negativeSig = \"\";\n+        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n+            negativeSig = \"-\";\n+            valueToChunk = valueToChunk.substring(1);\n+        }\n \n-        Validate.isTrue(splitStartInclusive == valueToChunk.length(), \"Value size does not match expected chunking scheme.\");\n+        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");\n+        chunkedDateTime[0] =  negativeSig + chunkedDateTime[0];\n \n-        return result;\n+        Validate.isTrue(3 * valueToChunk.length() - valueToChunk.replace(\"T\", \"\").length()\n+                        - valueToChunk.replace(\":\", \"\").length() - valueToChunk.replace(\"-\", \"\").length() == 5\n+                        && chunkedDateTime.length == 6,\n+                        \"Invalid DateTime (without nanoseconds) format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        return chunkedDateTime;\n     }\n \n-    public static String[] chunkWithRightOverflow(String valueToChunk, int... splitSizesFromLeft) {\n-        String[] result = new String[splitSizesFromLeft.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizesFromLeft);\n-\n-        result[splitSizesFromLeft.length] = valueToChunk.substring(splitStartInclusive);\n-\n-        return result;\n+    public static String[] chunkTime(String valueToChunk) {\n+        String[] chunkedTime = valueToChunk.split(\":\");\n+        Validate.isTrue((valueToChunk.length() - valueToChunk.replace(\":\", \"\").length()) == 2\n+                         && chunkedTime.length == 3,\n+                        \"Invalid time format, expected HH:MM:SS.\");\n+        return chunkedTime;\n     }\n \n-    public static String[] chunkWithLeftOverflow(String valueToChunk, int... splitSizesFromRight) {\n-        try {\n-            String[] result = new String[splitSizesFromRight.length + 1];\n-            int splitEndExclusive = valueToChunk.length();\n-\n-            for (int i = splitSizesFromRight.length - 1; i >= 0; i--) {\n-                int splitStartInclusive = splitEndExclusive - splitSizesFromRight[i];\n-                result[i + 1] = valueToChunk.substring(splitStartInclusive, splitEndExclusive);\n-                splitEndExclusive = splitStartInclusive;\n-            }\n-\n-            result[0] = valueToChunk.substring(0, splitEndExclusive);\n-\n-            return result;\n-        } catch (StringIndexOutOfBoundsException e) {\n-            throw new IllegalArgumentException(\"Invalid format for value.\", e);\n+    public static String[] chunkDate(String valueToChunk) {", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxNzk5Mg==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409917992", "bodyText": "This code is difficult to read, can we split it up into more logical and readable statements.", "author": "bmaizels", "createdAt": "2020-04-17T00:06:56Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java", "diffHunk": "@@ -128,55 +128,52 @@ private static int findTrimExclusiveEnd(String string, char characterToTrim, int\n         }\n     }\n \n-    public static String[] chunk(String valueToChunk, int... splitSizes) {\n-        String[] result = new String[splitSizes.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizes);\n+    public static String[] chunkDateTime(String valueToChunk) {\n+        Validate.isTrue(valueToChunk.contains(\"T\") && !valueToChunk.contains(\"+\") && !valueToChunk.contains(\"Z\"),\n+                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        String negativeSig = \"\";\n+        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n+            negativeSig = \"-\";\n+            valueToChunk = valueToChunk.substring(1);\n+        }\n \n-        Validate.isTrue(splitStartInclusive == valueToChunk.length(), \"Value size does not match expected chunking scheme.\");\n+        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");\n+        chunkedDateTime[0] =  negativeSig + chunkedDateTime[0];\n \n-        return result;\n+        Validate.isTrue(3 * valueToChunk.length() - valueToChunk.replace(\"T\", \"\").length()\n+                        - valueToChunk.replace(\":\", \"\").length() - valueToChunk.replace(\"-\", \"\").length() == 5\n+                        && chunkedDateTime.length == 6,\n+                        \"Invalid DateTime (without nanoseconds) format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        return chunkedDateTime;\n     }\n \n-    public static String[] chunkWithRightOverflow(String valueToChunk, int... splitSizesFromLeft) {\n-        String[] result = new String[splitSizesFromLeft.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizesFromLeft);\n-\n-        result[splitSizesFromLeft.length] = valueToChunk.substring(splitStartInclusive);\n-\n-        return result;\n+    public static String[] chunkTime(String valueToChunk) {\n+        String[] chunkedTime = valueToChunk.split(\":\");\n+        Validate.isTrue((valueToChunk.length() - valueToChunk.replace(\":\", \"\").length()) == 2\n+                         && chunkedTime.length == 3,\n+                        \"Invalid time format, expected HH:MM:SS.\");\n+        return chunkedTime;\n     }\n \n-    public static String[] chunkWithLeftOverflow(String valueToChunk, int... splitSizesFromRight) {\n-        try {\n-            String[] result = new String[splitSizesFromRight.length + 1];\n-            int splitEndExclusive = valueToChunk.length();\n-\n-            for (int i = splitSizesFromRight.length - 1; i >= 0; i--) {\n-                int splitStartInclusive = splitEndExclusive - splitSizesFromRight[i];\n-                result[i + 1] = valueToChunk.substring(splitStartInclusive, splitEndExclusive);\n-                splitEndExclusive = splitStartInclusive;\n-            }\n-\n-            result[0] = valueToChunk.substring(0, splitEndExclusive);\n-\n-            return result;\n-        } catch (StringIndexOutOfBoundsException e) {\n-            throw new IllegalArgumentException(\"Invalid format for value.\", e);\n+    public static String[] chunkDate(String valueToChunk) {\n+        String negativeSig = \"\";\n+        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n+            negativeSig = \"-\";\n+            valueToChunk = valueToChunk.substring(1);\n         }\n+        String[] chunkedDate = valueToChunk.split(\"-\");\n+        chunkedDate[0] = negativeSig + chunkedDate[0];\n+        Validate.isTrue(valueToChunk.length() - valueToChunk.replace(\"-\", \"\").length() == 2\n+                         && chunkedDate.length == 3,\n+                        \"Invalid date format, expected [-]YYYY-MM-DD.\");", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxODA3Ng==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409918076", "bodyText": "Can we have a javadoc so I can assert this is doing what it's supposed to do.", "author": "bmaizels", "createdAt": "2020-04-17T00:07:13Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java", "diffHunk": "@@ -128,55 +128,52 @@ private static int findTrimExclusiveEnd(String string, char characterToTrim, int\n         }\n     }\n \n-    public static String[] chunk(String valueToChunk, int... splitSizes) {\n-        String[] result = new String[splitSizes.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizes);\n+    public static String[] chunkDateTime(String valueToChunk) {\n+        Validate.isTrue(valueToChunk.contains(\"T\") && !valueToChunk.contains(\"+\") && !valueToChunk.contains(\"Z\"),\n+                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        String negativeSig = \"\";\n+        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n+            negativeSig = \"-\";\n+            valueToChunk = valueToChunk.substring(1);\n+        }\n \n-        Validate.isTrue(splitStartInclusive == valueToChunk.length(), \"Value size does not match expected chunking scheme.\");\n+        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");\n+        chunkedDateTime[0] =  negativeSig + chunkedDateTime[0];\n \n-        return result;\n+        Validate.isTrue(3 * valueToChunk.length() - valueToChunk.replace(\"T\", \"\").length()\n+                        - valueToChunk.replace(\":\", \"\").length() - valueToChunk.replace(\"-\", \"\").length() == 5\n+                        && chunkedDateTime.length == 6,\n+                        \"Invalid DateTime (without nanoseconds) format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        return chunkedDateTime;\n     }\n \n-    public static String[] chunkWithRightOverflow(String valueToChunk, int... splitSizesFromLeft) {\n-        String[] result = new String[splitSizesFromLeft.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizesFromLeft);\n-\n-        result[splitSizesFromLeft.length] = valueToChunk.substring(splitStartInclusive);\n-\n-        return result;\n+    public static String[] chunkTime(String valueToChunk) {\n+        String[] chunkedTime = valueToChunk.split(\":\");\n+        Validate.isTrue((valueToChunk.length() - valueToChunk.replace(\":\", \"\").length()) == 2\n+                         && chunkedTime.length == 3,\n+                        \"Invalid time format, expected HH:MM:SS.\");\n+        return chunkedTime;\n     }\n \n-    public static String[] chunkWithLeftOverflow(String valueToChunk, int... splitSizesFromRight) {\n-        try {\n-            String[] result = new String[splitSizesFromRight.length + 1];\n-            int splitEndExclusive = valueToChunk.length();\n-\n-            for (int i = splitSizesFromRight.length - 1; i >= 0; i--) {\n-                int splitStartInclusive = splitEndExclusive - splitSizesFromRight[i];\n-                result[i + 1] = valueToChunk.substring(splitStartInclusive, splitEndExclusive);\n-                splitEndExclusive = splitStartInclusive;\n-            }\n-\n-            result[0] = valueToChunk.substring(0, splitEndExclusive);\n-\n-            return result;\n-        } catch (StringIndexOutOfBoundsException e) {\n-            throw new IllegalArgumentException(\"Invalid format for value.\", e);\n+    public static String[] chunkDate(String valueToChunk) {\n+        String negativeSig = \"\";\n+        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n+            negativeSig = \"-\";\n+            valueToChunk = valueToChunk.substring(1);\n         }\n+        String[] chunkedDate = valueToChunk.split(\"-\");\n+        chunkedDate[0] = negativeSig + chunkedDate[0];\n+        Validate.isTrue(valueToChunk.length() - valueToChunk.replace(\"-\", \"\").length() == 2\n+                         && chunkedDate.length == 3,\n+                        \"Invalid date format, expected [-]YYYY-MM-DD.\");\n+        return chunkedDate;\n     }\n \n-    private static int chunkLeft(String valueToChunk, String[] result, int[] splitSizes) {\n-        try {\n-            int splitStartInclusive = 0;\n-\n-            for (int i = 0; i < splitSizes.length; i++) {\n-                int splitEndExclusive = splitStartInclusive + splitSizes[i];\n-                result[i] = valueToChunk.substring(splitStartInclusive, splitEndExclusive);\n-                splitStartInclusive = splitEndExclusive;\n-            }\n-            return splitStartInclusive;\n-        } catch (StringIndexOutOfBoundsException e) {\n-            throw new IllegalArgumentException(\"Invalid format for value.\", e);\n-        }\n+    public static String[] chunkMonthDay(String valueToChunk) {", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxODk3MA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409918970", "bodyText": "Checking 'ends with' would be faster, and also more accurate.", "author": "bmaizels", "createdAt": "2020-04-17T00:10:19Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/InstantAsStringAttributeConverter.java", "diffHunk": "@@ -90,6 +86,7 @@ public AttributeValue transformFrom(Instant input) {\n \n     @Override\n     public Instant transformTo(AttributeValue input) {\n+        Validate.isTrue(input.s().contains(\"Z\"), \"Invalid Instant format, should contain 'Z' in it.\");", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkxOTI2MQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409919261", "bodyText": "Or OffsetDateTime/ZonedDateTime if offset is 0 (UTC), presumably?", "author": "bmaizels", "createdAt": "2020-04-17T00:11:17Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/InstantAsStringAttributeConverter.java", "diffHunk": "@@ -53,11 +53,7 @@\n  * </ul>\n  *\n  * <p>\n- * This converter can read any values written by itself, {@link InstantAsIntegerAttributeConverter},\n- * {@link OffsetDateTimeAsStringAttributeConverter} or {@link ZonedDateTimeAsStringAttributeConverter}. Offset and zoned times\n- * will be automatically converted to the equivalent {@code Instant} based on the time zone information in the record (e.g.\n- * {@code ItemAttributeValueMapper.fromString(\"1970-01-01T00:00:00+01:00\")} will be converted to\n- * {@code Instant.EPOCH.minus(1, ChronoUnit.HOURS)}).\n+ * This converter can only read any values written by itself.", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkyMDM2Mw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409920363", "bodyText": "We probably shouldn't mention 'ISO-8601' format since we're omitting the timezone.", "author": "bmaizels", "createdAt": "2020-04-17T00:14:48Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateTimeAttributeConverter.java", "diffHunk": "@@ -35,10 +35,13 @@\n  * A converter between {@link LocalDateTime} and {@link AttributeValue}.\n  *\n  * <p>\n- * This stores and reads values in DynamoDB as a number, so that they can be sorted numerically as part of a sort key.\n+ * This stores and reads values in DynamoDB as a string.\n  *\n  * <p>\n- * LocalDateTimes are stored in the format \"[-]YYYYMMDDHHIISS[.NNNNNNNNN]\", where:\n+ * Values are stored in ISO-8601 format, with nanosecond precision.", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkyMDg1Mg==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409920852", "bodyText": "What's this?", "author": "bmaizels", "createdAt": "2020-04-17T00:16:23Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalTimeAttributeConverter.java", "diffHunk": "@@ -49,8 +49,9 @@\n  * <p>\n  * Examples:\n  * <ul>\n- *     <li>{@code LocalTime.of(5, 30, 0)} is stored as {@code ItemAttributeValueMapper.fromNumber(\"053000\")}</li>\n- *     <li>{@code LocalDateTime.of(5, 30, 0, 1)} is stored as {@code ItemAttributeValueMapper.fromNumber(\"053000.000000001\")}</li>\n+ *     <li>{@code LocalTime.of(5, 30, 0)} is stored as {@code ItemAttributeValueMapper.fromString(\"05:30:00\")}</li>\n+ *     <li>{@code LocalDateTime.of(5, 30, 0, 1)} is stored as </li>\n+ *     <li>{@code ItemAttributeValueMapper.fromString(\"05:30:00.000000001\")}</li>", "originalCommit": "19ff01fc8b80925357267958330b451b551a786b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTk4MTU5NA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r409981594", "bodyText": "I was trying to let that line not exceed the length restriction. Fixed now", "author": "Quanzzzz", "createdAt": "2020-04-17T04:09:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTkyMDg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1ODAxNQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r410358015", "bodyText": "This doesn't need to be parameterized since you're not passing in the attribute converter thus it's strongly typed to the class under test. Either drop the parameter  or move this into a shared place where all the tests can use it and pass in the converter to make it fully generic.", "author": "bmaizels", "createdAt": "2020-04-17T17:11:43Z", "path": "services-custom/dynamodb-enhanced/src/test/java/software/amazon/awssdk/enhanced/dynamodb/converters/attribute/LocalTimeAttributeConverterTest.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package software.amazon.awssdk.enhanced.dynamodb.converters.attribute;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static software.amazon.awssdk.enhanced.dynamodb.converters.attribute.ConverterTestUtils.assertFails;\n+import static software.amazon.awssdk.enhanced.dynamodb.converters.attribute.ConverterTestUtils.transformFrom;\n+import static software.amazon.awssdk.enhanced.dynamodb.converters.attribute.ConverterTestUtils.transformTo;\n+\n+import java.time.LocalTime;\n+import org.junit.Test;\n+import software.amazon.awssdk.enhanced.dynamodb.AttributeConverter;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.converter.attribute.EnhancedAttributeValue;\n+import software.amazon.awssdk.enhanced.dynamodb.internal.converter.attribute.LocalTimeAttributeConverter;\n+\n+public class LocalTimeAttributeConverterTest {\n+\n+    private static AttributeConverter converter = LocalTimeAttributeConverter.create();\n+\n+    @Test\n+    public void LocalTimeAttributeConverterMinTest() {\n+        verifyTransform(LocalTime.MIN, \"00:00:00\");\n+    }\n+\n+    @Test\n+    public void LocalTimeAttributeConverterNormalTest() {\n+        verifyTransform(LocalTime.of(1, 2, 3, 4), \"01:02:03.000000004\");\n+    }\n+\n+    @Test\n+    public void LocalTimeAttributeConverterMaxTest() {\n+        verifyTransform(LocalTime.MAX, \"23:59:59.999999999\");\n+    }\n+\n+\n+    @Test\n+    public void LocalTimeAttributeConverterInvalidFormatTest() {\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"-1\")\n+                                                                       .toAttributeValue()));\n+    }\n+\n+    @Test\n+    public void LocalTimeAttributeConverterExceedHigherBoundTest() {\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"24:00:00\")\n+                                                                       .toAttributeValue()));\n+    }\n+\n+    @Test\n+    public void LocalTimeAttributeConverterInvalidNanoSecondsTest() {\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"00:00:00.9999999999\")\n+                                                                       .toAttributeValue()));\n+    }\n+\n+    @Test\n+    public void LocalTimeAttributeConverterNotAcceptLocalDateTimeTest() {\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1988-05-21T00:12:00.000000001\")\n+                                                                       .toAttributeValue()));\n+    }\n+\n+    @Test\n+    public void LocalTimeAttributeConverterNotAcceptInstantTest() {\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1988-05-21T00:12:00.000000001Z\")\n+                                                                       .toAttributeValue()));\n+    }\n+\n+    @Test\n+    public void LocalTimeAttributeConverterNotAcceptOffsetTimeTest() {\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1988-05-21T00:12:00+01:00\")\n+                                                                       .toAttributeValue()));\n+    }\n+\n+    @Test\n+    public void LocalTimeAttributeConverterNotAcceptZonedTimeTest() {\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1988-05-21T00:12:00+01:00[Europe/Paris]\")\n+                                                                       .toAttributeValue()));\n+    }\n+\n+    @Test\n+    public void LocalTimeAttributeConverterNotAcceptLocalDateTest() {\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"1988-05-21\")\n+                                                                       .toAttributeValue()));\n+    }\n+\n+    @Test\n+    public void LocalTimeAttributeConverterNotAcceptMonthDayTest() {\n+        assertFails(() -> transformTo(converter, EnhancedAttributeValue.fromString(\"05-21\")\n+                                                                       .toAttributeValue()));\n+    }\n+\n+    private <T> void verifyTransform(T objectToTransform, String attributeValueString) {\n+        assertThat(transformFrom(converter, objectToTransform))\n+            .isEqualTo(EnhancedAttributeValue.fromString(attributeValueString).toAttributeValue());\n+        assertThat(transformTo(converter, EnhancedAttributeValue.fromString(attributeValueString).toAttributeValue()))\n+            .isEqualTo(objectToTransform);\n+    }", "originalCommit": "21b9d10a4e38ff81c80e990b58cd40961b7727d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM1ODYyOQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r410358629", "bodyText": "As discussed let's start with using parse and work from there. Let's do this for all the transformTo implementations", "author": "bmaizels", "createdAt": "2020-04-17T17:13:01Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/attribute/LocalDateTimeAttributeConverter.java", "diffHunk": "@@ -92,49 +95,59 @@ public static LocalDateTimeAttributeConverter create() {\n \n     @Override\n     public AttributeValueType attributeValueType() {\n-        return AttributeValueType.N;\n+        return AttributeValueType.S;\n     }\n \n     @Override\n     public AttributeValue transformFrom(LocalDateTime input) {\n         String value = \"\" +\n-                       input.getYear() +\n-                       padLeft2(input.getMonthValue()) +\n-                       padLeft2(input.getDayOfMonth()) +\n-                       padLeft2(input.getHour()) +\n-                       padLeft2(input.getMinute()) +\n+                       input.getYear() + \"-\" +\n+                       padLeft2(input.getMonthValue()) + \"-\" +\n+                       padLeft2(input.getDayOfMonth()) + \"T\" +\n+                       padLeft2(input.getHour()) + \":\" +\n+                       padLeft2(input.getMinute()) + \":\" +\n                        padLeft2(input.getSecond()) +\n                        (input.getNano() == 0 ? \"\" : \".\" + padLeft(9, input.getNano()));\n-        return AttributeValue.builder().n(value).build();\n+\n+        return AttributeValue.builder().s(value).build();\n     }\n \n     @Override\n     public LocalDateTime transformTo(AttributeValue input) {\n-        if (input.n() != null) {\n-            return EnhancedAttributeValue.fromNumber(input.n()).convert(VISITOR);\n+        if (input.s() != null) {\n+            return EnhancedAttributeValue.fromString(input.s()).convert(VISITOR);\n         }\n \n         return EnhancedAttributeValue.fromAttributeValue(input).convert(VISITOR);\n     }\n \n     private static final class Visitor extends TypeConvertingVisitor<LocalDateTime> {\n         private Visitor() {\n-            super(LocalDateTime.class, InstantAsIntegerAttributeConverter.class);\n+            super(LocalDateTime.class, InstantAsStringAttributeConverter.class);\n         }\n \n         @Override\n-        public LocalDateTime convertNumber(String value) {\n-            String[] splitOnDecimal = ConverterUtils.splitNumberOnDecimal(value);\n-            String[] chunkedDateTime = ConverterUtils.chunkWithLeftOverflow(splitOnDecimal[0], 2, 2, 2, 2, 2);\n+        public LocalDateTime convertString(String value) {\n+            // AttributeValue.S in LocalDateTime format\n+            if (value.contains(\"T\")) {\n+                String[] splitOnDecimal = ConverterUtils.splitNumberOnDecimal(value);\n+                String[] chunkedDateTime = ConverterUtils.chunkDateTime(splitOnDecimal[0]);\n+\n+                return LocalDateTime.of(Integer.parseInt(chunkedDateTime[0]),\n+                                        Integer.parseInt(chunkedDateTime[1]),\n+                                        Integer.parseInt(chunkedDateTime[2]),\n+                                        Integer.parseInt(chunkedDateTime[3]),\n+                                        Integer.parseInt(chunkedDateTime[4]),\n+                                        Integer.parseInt(chunkedDateTime[5]),\n+                                        Integer.parseInt(splitOnDecimal[1]));", "originalCommit": "21b9d10a4e38ff81c80e990b58cd40961b7727d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MTQ3OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r410371478", "bodyText": "These uses of regular expressions in this function are very expensive.", "author": "millems", "createdAt": "2020-04-17T17:36:59Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java", "diffHunk": "@@ -128,55 +129,67 @@ private static int findTrimExclusiveEnd(String string, char characterToTrim, int\n         }\n     }\n \n-    public static String[] chunk(String valueToChunk, int... splitSizes) {\n-        String[] result = new String[splitSizes.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizes);\n+    /**\n+     * Chunk the String without nanoseconds into a String array, and validates the format of input string and output result.\n+     * The negative sign is stored in the first element with 'year', if applicable.\n+     * @param valueToChunk\n+     * @return String array storing chunked pieces of Date and Time\n+     */\n+    public static String[] chunkDateTime(String valueToChunk) {\n+        Validate.isTrue(Pattern.matches(\"(?im)^(?=.*?(T))(?!.*?([+Z])).*\", valueToChunk),\n+                        \"Invalid sign in this format, expected [-]YYYY-MM-DDTHH:MM:SS.\");\n+        String negativeSig = \"\";\n+        if (valueToChunk.substring(0, 1).equals(\"-\")) {\n+            negativeSig = \"-\";\n+            valueToChunk = valueToChunk.substring(1);\n+        }\n \n-        Validate.isTrue(splitStartInclusive == valueToChunk.length(), \"Value size does not match expected chunking scheme.\");\n+        String[] chunkedDateTime = valueToChunk.split(\"[-T:]\");", "originalCommit": "21b9d10a4e38ff81c80e990b58cd40961b7727d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDM3MjU4Mw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1781#discussion_r410372583", "bodyText": "Can we not write our own date time parsing? Can we not use DateTimeFormatter for this?", "author": "millems", "createdAt": "2020-04-17T17:39:08Z", "path": "services-custom/dynamodb-enhanced/src/main/java/software/amazon/awssdk/enhanced/dynamodb/internal/converter/ConverterUtils.java", "diffHunk": "@@ -128,55 +129,67 @@ private static int findTrimExclusiveEnd(String string, char characterToTrim, int\n         }\n     }\n \n-    public static String[] chunk(String valueToChunk, int... splitSizes) {\n-        String[] result = new String[splitSizes.length + 1];\n-        int splitStartInclusive = chunkLeft(valueToChunk, result, splitSizes);\n+    /**\n+     * Chunk the String without nanoseconds into a String array, and validates the format of input string and output result.\n+     * The negative sign is stored in the first element with 'year', if applicable.\n+     * @param valueToChunk\n+     * @return String array storing chunked pieces of Date and Time\n+     */\n+    public static String[] chunkDateTime(String valueToChunk) {", "originalCommit": "21b9d10a4e38ff81c80e990b58cd40961b7727d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f3109f5bb55f5e0feea26b54ad42d0937740e994", "url": "https://github.com/aws/aws-sdk-java-v2/commit/f3109f5bb55f5e0feea26b54ad42d0937740e994", "message": "Replace InstantAsInteger with InstantAsString and test if this works.", "committedDate": "2020-04-17T20:38:11Z", "type": "commit"}, {"oid": "f3109f5bb55f5e0feea26b54ad42d0937740e994", "url": "https://github.com/aws/aws-sdk-java-v2/commit/f3109f5bb55f5e0feea26b54ad42d0937740e994", "message": "Replace InstantAsInteger with InstantAsString and test if this works.", "committedDate": "2020-04-17T20:38:11Z", "type": "forcePushed"}, {"oid": "08c5042c2bf8308fe489a7e63db7028dcf8a6eb6", "url": "https://github.com/aws/aws-sdk-java-v2/commit/08c5042c2bf8308fe489a7e63db7028dcf8a6eb6", "message": "Merge branch 'master' into replace-instantAsInteger", "committedDate": "2020-04-17T20:38:56Z", "type": "commit"}]}