{"pr_number": 1957, "pr_title": "Implement generic Waiter functionality", "pr_createdAt": "2020-07-17T19:40:10Z", "pr_url": "https://github.com/aws/aws-sdk-java-v2/pull/1957", "timeline": [{"oid": "5f0077f885f3121f87af64539882e3533f17b62b", "url": "https://github.com/aws/aws-sdk-java-v2/commit/5f0077f885f3121f87af64539882e3533f17b62b", "message": "Implement generic Waiter functionality", "committedDate": "2020-07-17T21:40:21Z", "type": "forcePushed"}, {"oid": "fc6d8973f030436054ae63144bc336b824221a7c", "url": "https://github.com/aws/aws-sdk-java-v2/commit/fc6d8973f030436054ae63144bc336b824221a7c", "message": "Implement generic Waiter functionality", "committedDate": "2020-07-17T23:15:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI5MzM3Mw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458293373", "bodyText": "Can you add more here? Not sure what a 'handler' does other than 'handle', and I don't know what it means to 'handle' an async waiter operation.", "author": "millems", "createdAt": "2020-07-21T18:10:41Z", "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/internal/waiters/AsyncWaiterHandler.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.internal.waiters;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import software.amazon.awssdk.annotations.NotThreadSafe;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.waiters.PollingStrategy;\n+import software.amazon.awssdk.core.waiters.WaiterAcceptor;\n+import software.amazon.awssdk.core.waiters.WaiterResponse;\n+import software.amazon.awssdk.core.waiters.WaiterState;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Handler for async waiter operations\n+ * @param <T> the type of the response", "originalCommit": "fc6d8973f030436054ae63144bc336b824221a7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM3MjQ4NQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458372485", "bodyText": "Sure", "author": "zoewangg", "createdAt": "2020-07-21T20:36:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI5MzM3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI5NDE2MQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458294161", "bodyText": "Leftover logging?", "author": "millems", "createdAt": "2020-07-21T18:12:04Z", "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/internal/waiters/AsyncWaiterHandler.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.internal.waiters;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import software.amazon.awssdk.annotations.NotThreadSafe;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.waiters.PollingStrategy;\n+import software.amazon.awssdk.core.waiters.WaiterAcceptor;\n+import software.amazon.awssdk.core.waiters.WaiterResponse;\n+import software.amazon.awssdk.core.waiters.WaiterState;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Handler for async waiter operations\n+ * @param <T> the type of the response\n+ */\n+@SdkInternalApi\n+@NotThreadSafe\n+public final class AsyncWaiterHandler<T> {\n+    private static final Logger log = Logger.loggerFor(AsyncWaiterHandler.class);\n+    private final PollingStrategy pollingStrategy;\n+    private final ScheduledExecutorService executorService;\n+    private final WaiterHandlerHelper<T> handlerHelper;\n+    private int attemptNumber = 0;\n+\n+    public AsyncWaiterHandler(PollingStrategy pollingStrategy,\n+                              List<WaiterAcceptor<T>> waiterAcceptors,\n+                              ScheduledExecutorService executorService) {\n+        this.pollingStrategy = Validate.paramNotNull(pollingStrategy, \"pollingStrategy\");\n+        Validate.paramNotNull(waiterAcceptors, \"waiterAcceptors\");\n+        this.executorService = Validate.paramNotNull(executorService, \"executorService\");\n+        this.handlerHelper = new WaiterHandlerHelper<>(waiterAcceptors, pollingStrategy);\n+    }\n+\n+    /**\n+     * Execute the provided async polling function\n+     */\n+    CompletableFuture<WaiterResponse<T>> execute(Supplier<CompletableFuture<T>> asyncPollingFunction) {\n+        log.info(() -> \"starting to execute\");", "originalCommit": "fc6d8973f030436054ae63144bc336b824221a7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM1NTExNQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458355115", "bodyText": "Yup, will clean it up", "author": "zoewangg", "createdAt": "2020-07-21T20:03:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI5NDE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI5NTc1Mw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458295753", "bodyText": "Any way that we could let an acceptor can provide a failure reason to include in the exception?", "author": "millems", "createdAt": "2020-07-21T18:14:50Z", "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/internal/waiters/AsyncWaiterHandler.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.internal.waiters;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import software.amazon.awssdk.annotations.NotThreadSafe;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.waiters.PollingStrategy;\n+import software.amazon.awssdk.core.waiters.WaiterAcceptor;\n+import software.amazon.awssdk.core.waiters.WaiterResponse;\n+import software.amazon.awssdk.core.waiters.WaiterState;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Handler for async waiter operations\n+ * @param <T> the type of the response\n+ */\n+@SdkInternalApi\n+@NotThreadSafe\n+public final class AsyncWaiterHandler<T> {\n+    private static final Logger log = Logger.loggerFor(AsyncWaiterHandler.class);\n+    private final PollingStrategy pollingStrategy;\n+    private final ScheduledExecutorService executorService;\n+    private final WaiterHandlerHelper<T> handlerHelper;\n+    private int attemptNumber = 0;\n+\n+    public AsyncWaiterHandler(PollingStrategy pollingStrategy,\n+                              List<WaiterAcceptor<T>> waiterAcceptors,\n+                              ScheduledExecutorService executorService) {\n+        this.pollingStrategy = Validate.paramNotNull(pollingStrategy, \"pollingStrategy\");\n+        Validate.paramNotNull(waiterAcceptors, \"waiterAcceptors\");\n+        this.executorService = Validate.paramNotNull(executorService, \"executorService\");\n+        this.handlerHelper = new WaiterHandlerHelper<>(waiterAcceptors, pollingStrategy);\n+    }\n+\n+    /**\n+     * Execute the provided async polling function\n+     */\n+    CompletableFuture<WaiterResponse<T>> execute(Supplier<CompletableFuture<T>> asyncPollingFunction) {\n+        log.info(() -> \"starting to execute\");\n+        CompletableFuture<WaiterResponse<T>> future = new CompletableFuture<>();\n+        doExecute(asyncPollingFunction, future);\n+        return future;\n+    }\n+\n+    private void doExecute(Supplier<CompletableFuture<T>> asyncPollingFunction, CompletableFuture<WaiterResponse<T>> future) {\n+        ++attemptNumber;\n+        log.info(() -> \"runOnce\" + attemptNumber);\n+        runAsyncPollingFunction(asyncPollingFunction, future);\n+    }\n+\n+    private void runAsyncPollingFunction(Supplier<CompletableFuture<T>> asyncPollingFunction,\n+                                         CompletableFuture<WaiterResponse<T>> future) {\n+        asyncPollingFunction.get().whenComplete((response, exception) -> {\n+            Optional<WaiterState> waiterState = handlerHelper.nextWaiterStateIfMatched(response, exception);\n+\n+            if (waiterState.isPresent()) {\n+                log.info(() -> \"waiter state \" + waiterState.get());\n+                WaiterState state = waiterState.get();\n+                switch (state) {\n+                    case SUCCESS:\n+                        future.complete(handlerHelper.createWaiterResponse(response, exception, attemptNumber));\n+                        break;\n+                    case RETRY:\n+                        maybeRetry(asyncPollingFunction, future);\n+                        break;\n+                    case FAILURE:\n+                        future.completeExceptionally(SdkClientException.create(\"A waiter acceptor was matched and transitioned \"\n+                                                                               + \"the waiter to failure state\"));", "originalCommit": "fc6d8973f030436054ae63144bc336b824221a7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM5MzY2MQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458393661", "bodyText": "Yeah, let me try it", "author": "zoewangg", "createdAt": "2020-07-21T21:18:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI5NTc1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI5NjM5Nw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458296397", "bodyText": "Should we preserve \"exception\" as the cause?", "author": "millems", "createdAt": "2020-07-21T18:15:58Z", "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/internal/waiters/AsyncWaiterHandler.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.internal.waiters;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import software.amazon.awssdk.annotations.NotThreadSafe;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.waiters.PollingStrategy;\n+import software.amazon.awssdk.core.waiters.WaiterAcceptor;\n+import software.amazon.awssdk.core.waiters.WaiterResponse;\n+import software.amazon.awssdk.core.waiters.WaiterState;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Handler for async waiter operations\n+ * @param <T> the type of the response\n+ */\n+@SdkInternalApi\n+@NotThreadSafe\n+public final class AsyncWaiterHandler<T> {\n+    private static final Logger log = Logger.loggerFor(AsyncWaiterHandler.class);\n+    private final PollingStrategy pollingStrategy;\n+    private final ScheduledExecutorService executorService;\n+    private final WaiterHandlerHelper<T> handlerHelper;\n+    private int attemptNumber = 0;\n+\n+    public AsyncWaiterHandler(PollingStrategy pollingStrategy,\n+                              List<WaiterAcceptor<T>> waiterAcceptors,\n+                              ScheduledExecutorService executorService) {\n+        this.pollingStrategy = Validate.paramNotNull(pollingStrategy, \"pollingStrategy\");\n+        Validate.paramNotNull(waiterAcceptors, \"waiterAcceptors\");\n+        this.executorService = Validate.paramNotNull(executorService, \"executorService\");\n+        this.handlerHelper = new WaiterHandlerHelper<>(waiterAcceptors, pollingStrategy);\n+    }\n+\n+    /**\n+     * Execute the provided async polling function\n+     */\n+    CompletableFuture<WaiterResponse<T>> execute(Supplier<CompletableFuture<T>> asyncPollingFunction) {\n+        log.info(() -> \"starting to execute\");\n+        CompletableFuture<WaiterResponse<T>> future = new CompletableFuture<>();\n+        doExecute(asyncPollingFunction, future);\n+        return future;\n+    }\n+\n+    private void doExecute(Supplier<CompletableFuture<T>> asyncPollingFunction, CompletableFuture<WaiterResponse<T>> future) {\n+        ++attemptNumber;\n+        log.info(() -> \"runOnce\" + attemptNumber);\n+        runAsyncPollingFunction(asyncPollingFunction, future);\n+    }\n+\n+    private void runAsyncPollingFunction(Supplier<CompletableFuture<T>> asyncPollingFunction,\n+                                         CompletableFuture<WaiterResponse<T>> future) {\n+        asyncPollingFunction.get().whenComplete((response, exception) -> {\n+            Optional<WaiterState> waiterState = handlerHelper.nextWaiterStateIfMatched(response, exception);\n+\n+            if (waiterState.isPresent()) {\n+                log.info(() -> \"waiter state \" + waiterState.get());\n+                WaiterState state = waiterState.get();\n+                switch (state) {\n+                    case SUCCESS:\n+                        future.complete(handlerHelper.createWaiterResponse(response, exception, attemptNumber));\n+                        break;\n+                    case RETRY:\n+                        maybeRetry(asyncPollingFunction, future);\n+                        break;\n+                    case FAILURE:\n+                        future.completeExceptionally(SdkClientException.create(\"A waiter acceptor was matched and transitioned \"\n+                                                                               + \"the waiter to failure state\"));\n+                        break;\n+                    default:\n+                        future.completeExceptionally(new UnsupportedOperationException());\n+                }\n+            } else {\n+                if (exception != null) {\n+                    future.completeExceptionally(SdkClientException.create(\"An exception was thrown and did not match any \"\n+                                                                           + \"waiter acceptors\"));", "originalCommit": "fc6d8973f030436054ae63144bc336b824221a7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM1NjEzMw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458356133", "bodyText": "+1", "author": "zoewangg", "createdAt": "2020-07-21T20:05:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI5NjM5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI5NzMyNA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458297324", "bodyText": "Could we make this class thread-safe and reusable by just passing through the attemptNumber on each doExecute call? This seems like unnecessary mutability.", "author": "millems", "createdAt": "2020-07-21T18:17:34Z", "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/internal/waiters/AsyncWaiterHandler.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.internal.waiters;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import software.amazon.awssdk.annotations.NotThreadSafe;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.waiters.PollingStrategy;\n+import software.amazon.awssdk.core.waiters.WaiterAcceptor;\n+import software.amazon.awssdk.core.waiters.WaiterResponse;\n+import software.amazon.awssdk.core.waiters.WaiterState;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Handler for async waiter operations\n+ * @param <T> the type of the response\n+ */\n+@SdkInternalApi\n+@NotThreadSafe\n+public final class AsyncWaiterHandler<T> {\n+    private static final Logger log = Logger.loggerFor(AsyncWaiterHandler.class);\n+    private final PollingStrategy pollingStrategy;\n+    private final ScheduledExecutorService executorService;\n+    private final WaiterHandlerHelper<T> handlerHelper;\n+    private int attemptNumber = 0;\n+\n+    public AsyncWaiterHandler(PollingStrategy pollingStrategy,\n+                              List<WaiterAcceptor<T>> waiterAcceptors,\n+                              ScheduledExecutorService executorService) {\n+        this.pollingStrategy = Validate.paramNotNull(pollingStrategy, \"pollingStrategy\");\n+        Validate.paramNotNull(waiterAcceptors, \"waiterAcceptors\");\n+        this.executorService = Validate.paramNotNull(executorService, \"executorService\");\n+        this.handlerHelper = new WaiterHandlerHelper<>(waiterAcceptors, pollingStrategy);\n+    }\n+\n+    /**\n+     * Execute the provided async polling function\n+     */\n+    CompletableFuture<WaiterResponse<T>> execute(Supplier<CompletableFuture<T>> asyncPollingFunction) {\n+        log.info(() -> \"starting to execute\");\n+        CompletableFuture<WaiterResponse<T>> future = new CompletableFuture<>();\n+        doExecute(asyncPollingFunction, future);\n+        return future;\n+    }\n+\n+    private void doExecute(Supplier<CompletableFuture<T>> asyncPollingFunction, CompletableFuture<WaiterResponse<T>> future) {\n+        ++attemptNumber;\n+        log.info(() -> \"runOnce\" + attemptNumber);\n+        runAsyncPollingFunction(asyncPollingFunction, future);\n+    }\n+\n+    private void runAsyncPollingFunction(Supplier<CompletableFuture<T>> asyncPollingFunction,\n+                                         CompletableFuture<WaiterResponse<T>> future) {\n+        asyncPollingFunction.get().whenComplete((response, exception) -> {\n+            Optional<WaiterState> waiterState = handlerHelper.nextWaiterStateIfMatched(response, exception);\n+\n+            if (waiterState.isPresent()) {\n+                log.info(() -> \"waiter state \" + waiterState.get());\n+                WaiterState state = waiterState.get();\n+                switch (state) {\n+                    case SUCCESS:\n+                        future.complete(handlerHelper.createWaiterResponse(response, exception, attemptNumber));\n+                        break;\n+                    case RETRY:\n+                        maybeRetry(asyncPollingFunction, future);\n+                        break;\n+                    case FAILURE:\n+                        future.completeExceptionally(SdkClientException.create(\"A waiter acceptor was matched and transitioned \"\n+                                                                               + \"the waiter to failure state\"));\n+                        break;\n+                    default:\n+                        future.completeExceptionally(new UnsupportedOperationException());\n+                }\n+            } else {\n+                if (exception != null) {\n+                    future.completeExceptionally(SdkClientException.create(\"An exception was thrown and did not match any \"\n+                                                                           + \"waiter acceptors\"));\n+                } else {\n+                    // default to retry if there's no acceptor matched for the response\n+                    maybeRetry(asyncPollingFunction, future);\n+                }\n+            }\n+        });\n+    }\n+\n+    private void maybeRetry(Supplier<CompletableFuture<T>> asyncPollingFunction,\n+                            CompletableFuture<WaiterResponse<T>> future) {\n+        if (attemptNumber >= pollingStrategy.maxAttempts()) {\n+            future.completeExceptionally(SdkClientException.create(\"The waiter has exceeded max retry attempts: \" +\n+                                                                   pollingStrategy.maxAttempts()));\n+            return;\n+        }", "originalCommit": "fc6d8973f030436054ae63144bc336b824221a7c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI5OTQ2Mw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458299463", "bodyText": "Any reason we don't have the \"max attempts\" be an acceptor, instead of special-casing it within this handler?  I realize that means we have to pass something through to allow the acceptor to track \"execution context\" for a waiter invocation (so that it can keep count), but that seems like a useful feature that better separates the responsibilities of this 'handler'.", "author": "millems", "createdAt": "2020-07-21T18:21:05Z", "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/internal/waiters/AsyncWaiterHandler.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.internal.waiters;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Supplier;\n+import software.amazon.awssdk.annotations.NotThreadSafe;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.core.exception.SdkClientException;\n+import software.amazon.awssdk.core.waiters.PollingStrategy;\n+import software.amazon.awssdk.core.waiters.WaiterAcceptor;\n+import software.amazon.awssdk.core.waiters.WaiterResponse;\n+import software.amazon.awssdk.core.waiters.WaiterState;\n+import software.amazon.awssdk.utils.Logger;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Handler for async waiter operations\n+ * @param <T> the type of the response\n+ */\n+@SdkInternalApi\n+@NotThreadSafe\n+public final class AsyncWaiterHandler<T> {\n+    private static final Logger log = Logger.loggerFor(AsyncWaiterHandler.class);\n+    private final PollingStrategy pollingStrategy;\n+    private final ScheduledExecutorService executorService;\n+    private final WaiterHandlerHelper<T> handlerHelper;\n+    private int attemptNumber = 0;\n+\n+    public AsyncWaiterHandler(PollingStrategy pollingStrategy,\n+                              List<WaiterAcceptor<T>> waiterAcceptors,\n+                              ScheduledExecutorService executorService) {\n+        this.pollingStrategy = Validate.paramNotNull(pollingStrategy, \"pollingStrategy\");\n+        Validate.paramNotNull(waiterAcceptors, \"waiterAcceptors\");\n+        this.executorService = Validate.paramNotNull(executorService, \"executorService\");\n+        this.handlerHelper = new WaiterHandlerHelper<>(waiterAcceptors, pollingStrategy);\n+    }\n+\n+    /**\n+     * Execute the provided async polling function\n+     */\n+    CompletableFuture<WaiterResponse<T>> execute(Supplier<CompletableFuture<T>> asyncPollingFunction) {\n+        log.info(() -> \"starting to execute\");\n+        CompletableFuture<WaiterResponse<T>> future = new CompletableFuture<>();\n+        doExecute(asyncPollingFunction, future);\n+        return future;\n+    }\n+\n+    private void doExecute(Supplier<CompletableFuture<T>> asyncPollingFunction, CompletableFuture<WaiterResponse<T>> future) {\n+        ++attemptNumber;\n+        log.info(() -> \"runOnce\" + attemptNumber);\n+        runAsyncPollingFunction(asyncPollingFunction, future);\n+    }\n+\n+    private void runAsyncPollingFunction(Supplier<CompletableFuture<T>> asyncPollingFunction,\n+                                         CompletableFuture<WaiterResponse<T>> future) {\n+        asyncPollingFunction.get().whenComplete((response, exception) -> {\n+            Optional<WaiterState> waiterState = handlerHelper.nextWaiterStateIfMatched(response, exception);", "originalCommit": "fc6d8973f030436054ae63144bc336b824221a7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM5MzE1MQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458393151", "bodyText": "To me, a WatierAcceptor is really an inspector that checks the response or exception returned from an operation and it shouldn't really care about the execution context. IMO, It's the handler's responsibility to handle it, rather than the WaiterAcceptor.\nIt'd probably be something like the following. Not sure if I like the fact that WaiterExecutionContext  is added to be only used by this acceptor and it feels the acceptor is more like a WaiterIntercetor now.\n    static <T> WaiterAcceptor<T> retryAttempsAcceptor(int maxAttempts) {\n        return new WaiterAcceptor<T>() {\n            @Override\n            public WaiterState waiterState() {\n                return WaiterState.FAILURE;\n            }\n\n            @Override\n            public boolean matches(T response, WaiterExecutionContext context) {\n                if (context.attempts() > maxAttemtps) {\n                    return true;\n                }\n                return false;\n            }\n\n            @Override\n            public boolean matches(Throwable throwable, WaiterExecutionContext context) {\n                if (context.attempts() > maxAttemtps) {\n                    return true;\n                }\n                return false;\n            }\n        }\n    }", "author": "zoewangg", "createdAt": "2020-07-21T21:17:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI5OTQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk1MzE0NA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458953144", "bodyText": "I think I might be trying too hard. You're probably right that we should keep it simple, since I don't see us needing really fancy acceptors.\nMy original comment was thinking a little more generic, like:\n    static <T> WaiterAcceptor<T> retryAttempsAcceptor(int maxAttempts) {\n        return new WaiterAcceptor<T>() {\n            private static AttributeKey<Integer> ATTEMPTS = AttributeKey.create(\"Attempts\");\n\n            @Override\n            public WaiterState waiterState() {\n                return WaiterState.FAILURE;\n            }\n\n            @Override\n            public boolean matches(T response, WaiterExecutionContext context) {\n                incrementAttempt(context);\n                if (getAttempts(context) > maxAttempts) {\n                    return true;\n                }\n                return false;\n            }\n\n            @Override\n            public boolean matches(Throwable throwable, WaiterExecutionContext context) {\n                incrementAttempt(context);\n                if (getAttempts(context) > maxAttempts) {\n                    return true;\n                }\n                return false;\n            }\n            \n            private void incrementAttempt(WaiterExecutionContext context) {\n                context.setAttribute(ATTEMPTS, getAttempts(context) + 1);\n            }\n\n            private int getAttempts(WaiterExecutionContext context) {\n                Integer attempts = context.getAttribute(ATTEMPTS);\n                return attempts == null ? 1 : attempts;\n            }\n        }\n    }", "author": "millems", "createdAt": "2020-07-22T17:14:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODI5OTQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwMTU5MA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458301590", "bodyText": "Should we differentiate between a Waiter and an AsyncWaiter? It seems weird that someone that only wants the synchronous run(...) method can (should?) configure an executor service.", "author": "millems", "createdAt": "2020-07-21T18:24:54Z", "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/internal/waiters/DefaultWaiter.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.internal.waiters;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.function.Supplier;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.annotations.ThreadSafe;\n+import software.amazon.awssdk.core.waiters.PollingStrategy;\n+import software.amazon.awssdk.core.waiters.Waiter;\n+import software.amazon.awssdk.core.waiters.WaiterAcceptor;\n+import software.amazon.awssdk.core.waiters.WaiterResponse;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Default implementation of the generic {@link Waiter}.\n+ * @param <T> the type of the response expected to return from the polling function\n+ */\n+@SdkInternalApi\n+@ThreadSafe\n+public final class DefaultWaiter<T> implements Waiter<T> {", "originalCommit": "fc6d8973f030436054ae63144bc336b824221a7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM1ODcxOA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458358718", "bodyText": "I thought about separating them, but I figured that would require customers to create two Waiter classes with the same configurations if they want to use both sync and async waiter functionalities. I'm not sure how many customers are actually going to use both though.\nI do agree it might be confusing to customers who only care about sync.", "author": "zoewangg", "createdAt": "2020-07-21T20:10:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwMTU5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk2MDQ3Nw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458960477", "bodyText": "I prefer for preconditions to be encoded in the type/constructor. \"If you give me a waiter that was initialized, I'll work just fine\".\nIf preconditions are only validated when the Waiter is used, the user of the Waiter needs to handle the case that the waiter was not properly configured. E.g. If I have a WaiterUser that is injected with a Waiter when it's created, and it needs to use runAsync, I either need to call runAsync when a WaiterUser is created to make sure it doesn't throw an exception, or annotate every method that uses runAsync to document that it will throw an exception if the configured Waiter wasn't configured correctly. I also probably should (but probably won't remember to) write unit tests for that case, which doubles the number of tests I should write for WaiterUser.", "author": "millems", "createdAt": "2020-07-22T17:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwMTU5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwMTk4Ng==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458301986", "bodyText": "What handles the \"scheduleExecutorService is null\" case? When runAsync is invoked?", "author": "millems", "createdAt": "2020-07-21T18:25:35Z", "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/internal/waiters/DefaultWaiter.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.internal.waiters;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.function.Supplier;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.annotations.ThreadSafe;\n+import software.amazon.awssdk.core.waiters.PollingStrategy;\n+import software.amazon.awssdk.core.waiters.Waiter;\n+import software.amazon.awssdk.core.waiters.WaiterAcceptor;\n+import software.amazon.awssdk.core.waiters.WaiterResponse;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Default implementation of the generic {@link Waiter}.\n+ * @param <T> the type of the response expected to return from the polling function\n+ */\n+@SdkInternalApi\n+@ThreadSafe\n+public final class DefaultWaiter<T> implements Waiter<T> {\n+    private final PollingStrategy pollingStrategy;\n+    private final ScheduledExecutorService executorService;\n+    private final List<WaiterAcceptor<T>> waiterAcceptors;\n+\n+    private DefaultWaiter(DefaultBuilder<T> builder) {\n+        this.executorService = builder.scheduledExecutorService;", "originalCommit": "fc6d8973f030436054ae63144bc336b824221a7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM1NjY4NQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458356685", "bodyText": "Yes, scheduledExecutorService null check is done in runAsync method.", "author": "zoewangg", "createdAt": "2020-07-21T20:06:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwMTk4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwMjE3Mg==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458302172", "bodyText": "Copy?", "author": "millems", "createdAt": "2020-07-21T18:25:54Z", "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/internal/waiters/DefaultWaiter.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.internal.waiters;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.function.Supplier;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.annotations.ThreadSafe;\n+import software.amazon.awssdk.core.waiters.PollingStrategy;\n+import software.amazon.awssdk.core.waiters.Waiter;\n+import software.amazon.awssdk.core.waiters.WaiterAcceptor;\n+import software.amazon.awssdk.core.waiters.WaiterResponse;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Default implementation of the generic {@link Waiter}.\n+ * @param <T> the type of the response expected to return from the polling function\n+ */\n+@SdkInternalApi\n+@ThreadSafe\n+public final class DefaultWaiter<T> implements Waiter<T> {\n+    private final PollingStrategy pollingStrategy;\n+    private final ScheduledExecutorService executorService;\n+    private final List<WaiterAcceptor<T>> waiterAcceptors;\n+\n+    private DefaultWaiter(DefaultBuilder<T> builder) {\n+        this.executorService = builder.scheduledExecutorService;\n+        this.pollingStrategy = Validate.paramNotNull(builder.pollingStrategy, \"pollingStrategy\");\n+        this.waiterAcceptors = Collections.unmodifiableList(new ArrayList<>(builder.waiterAcceptors));\n+    }\n+\n+    @Override\n+    public CompletableFuture<WaiterResponse<T>> runAsync(Supplier<CompletableFuture<T>> asyncPollingFunction) {\n+        AsyncWaiterHandler<T> handler = new AsyncWaiterHandler<>(pollingStrategy, waiterAcceptors, executorService);\n+        return handler.execute(asyncPollingFunction);\n+    }\n+\n+    @Override\n+    public WaiterResponse<T> run(Supplier<T> pollingFunction) {\n+        WaiterHandler<T> handler = new WaiterHandler<>(pollingStrategy, waiterAcceptors);\n+        return handler.execute(pollingFunction);\n+    }\n+\n+    public static <T> Builder<T> builder() {\n+        return new DefaultBuilder<>();\n+    }\n+\n+    public static final class DefaultBuilder<T> implements Builder<T> {\n+        private List<WaiterAcceptor<T>> waiterAcceptors = new ArrayList<>();\n+        private ScheduledExecutorService scheduledExecutorService;\n+        private PollingStrategy pollingStrategy;\n+\n+        private DefaultBuilder() {\n+        }\n+\n+        @Override\n+        public Builder<T> scheduledExecutorService(ScheduledExecutorService scheduledExecutorService) {\n+            this.scheduledExecutorService = scheduledExecutorService;\n+            return this;\n+        }\n+\n+        @Override\n+        public Builder<T> acceptors(List<WaiterAcceptor<T>> waiterAcceptors) {\n+            this.waiterAcceptors = waiterAcceptors;", "originalCommit": "fc6d8973f030436054ae63144bc336b824221a7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM1OTE2Mw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458359163", "bodyText": "A new copy is created in the ctor.", "author": "zoewangg", "createdAt": "2020-07-21T20:11:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwMjE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk2MjY0OQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458962649", "bodyText": "That doesn't prevent the case of mutating the list when it's in the builder.\nList<WaiterAcceptor<T>> acceptors = new ArrayList<>();\nwaiterBuilder.acceptors(acceptors);\nacceptors.put(someAcceptor); // Mutates the acceptors within waiterBuilder.", "author": "millems", "createdAt": "2020-07-22T17:30:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwMjE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwNTkyOQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458305929", "bodyText": "\"handler helper\". Helps the handler? Seems very generic. Is this just for code sharing between the async and sync code paths?\nIf so, is there any way we could use a strategy pattern here, where this is a parent class that handles the core logic, but it delegates to the children to do it synchronously or asynchronously?", "author": "millems", "createdAt": "2020-07-21T18:32:28Z", "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/internal/waiters/WaiterHandlerHelper.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.internal.waiters;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.core.retry.RetryPolicyContext;\n+import software.amazon.awssdk.core.waiters.PollingStrategy;\n+import software.amazon.awssdk.core.waiters.WaiterAcceptor;\n+import software.amazon.awssdk.core.waiters.WaiterResponse;\n+import software.amazon.awssdk.core.waiters.WaiterState;\n+\n+/**\n+ * The waiter handler helper class\n+ */\n+@SdkInternalApi\n+public final class WaiterHandlerHelper<T> {", "originalCommit": "fc6d8973f030436054ae63144bc336b824221a7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM4NDI2OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458384268", "bodyText": "Yes, it's just code sharing between async and sync code paths. I thought about creating an abstract class to handle the common logic. In fact, I had similar discussion with @bmaizels before about code sharing between two classes and I was convinced to use the composition over inheritance approach.", "author": "zoewangg", "createdAt": "2020-07-21T20:59:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwNTkyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk2NDE3Mg==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458964172", "bodyText": "I'm not convinced. That's what the strategy pattern is for. I usually pick composition over inheritance as well, but there are exceptions to the rule. That said, if you've tested it out and it's messy, I believe you. I haven't done the deep-dive necessary to tell whether it's any better than this option.\nI notice a lot of duplicate code between the async and sync code paths, though. Can we move some of it to the WaiterHandlerHelper?", "author": "millems", "createdAt": "2020-07-22T17:32:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwNTkyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY0NDM4OQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r459644389", "bodyText": "Are you referring to the switch statement? It's not true duplication. For instance, for exceptional case, sync will throw exception and async will complete the future exceptionally. While it's possible to share more code, the code would be less readable, in my mind unless you have other ideas?\nsync:\n        if (waiterState.isPresent()) {\n            WaiterState state = waiterState.get();\n            switch (state) {\n                case SUCCESS:\n                    return handlerHelper.createWaiterResponse(response, exception, attemptNumber);\n                case RETRY:\n                    return maybeRetry(pollingFunction);\n                case FAILURE:\n                    throw SdkClientException.create(\"A waiter acceptor was matched and transitioned the waiter \"\n                                                    + \"to failure state.\");\n                default:\n                    throw new UnsupportedOperationException();\n            }\n        }\n\n        if (exception != null) {\n            throw SdkClientException.create(\"An exception was thrown and did not match with any waiter acceptor\", exception);\n        } else {\n            // default to retry if there's no acceptor matched for the response\n            return maybeRetry(pollingFunction);\n        }\n    }\nasync:\n            if (waiterState.isPresent()) {\n                log.info(() -> \"waiter state \" + waiterState.get());\n                WaiterState state = waiterState.get();\n                switch (state) {\n                    case SUCCESS:\n                        future.complete(handlerHelper.createWaiterResponse(response, exception, attemptNumber));\n                        break;\n                    case RETRY:\n                        maybeRetry(asyncPollingFunction, future);\n                        break;\n                    case FAILURE:\n                        future.completeExceptionally(SdkClientException.create(\"A waiter acceptor was matched and transitioned \"\n                                                                               + \"the waiter to failure state\"));\n                        break;\n                    default:\n                        future.completeExceptionally(new UnsupportedOperationException());\n                }\n            } else {\n                if (exception != null) {\n                    future.completeExceptionally(SdkClientException.create(\"An exception was thrown and did not match any \"\n                                                                           + \"waiter acceptors\"));\n                } else {\n                    // default to retry if there's no acceptor matched for the response\n                    maybeRetry(asyncPollingFunction, future);\n                }\n            }", "author": "zoewangg", "createdAt": "2020-07-23T18:25:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwNTkyOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1NTg4Nw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r459655887", "bodyText": "I think the sync (\"return the result\") and async (\"return a completed future\") behavior can be factored out of the logic itself. It's just a question of how hard it makes the code to read.", "author": "millems", "createdAt": "2020-07-23T18:45:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwNTkyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwNjc3MA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458306770", "bodyText": "ternary might read simpler.", "author": "millems", "createdAt": "2020-07-21T18:33:59Z", "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/internal/waiters/WaiterHandlerHelper.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.internal.waiters;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import software.amazon.awssdk.annotations.SdkInternalApi;\n+import software.amazon.awssdk.core.retry.RetryPolicyContext;\n+import software.amazon.awssdk.core.waiters.PollingStrategy;\n+import software.amazon.awssdk.core.waiters.WaiterAcceptor;\n+import software.amazon.awssdk.core.waiters.WaiterResponse;\n+import software.amazon.awssdk.core.waiters.WaiterState;\n+\n+/**\n+ * The waiter handler helper class\n+ */\n+@SdkInternalApi\n+public final class WaiterHandlerHelper<T> {\n+    private final List<WaiterAcceptor<T>> waiterAcceptors;\n+    private final PollingStrategy pollingStrategy;\n+\n+    public WaiterHandlerHelper(List<WaiterAcceptor<T>> waiterAcceptors, PollingStrategy pollingStrategy) {\n+        this.waiterAcceptors = waiterAcceptors;\n+        this.pollingStrategy = pollingStrategy;\n+    }\n+\n+    /**\n+     * A convenience method to create a {@link WaiterResponse} with either a response or an exception\n+     *\n+     * @param response nullable response\n+     * @param exception nullable exception\n+     * @return a {@link WaiterResponse}\n+     */\n+    public WaiterResponse<T> createWaiterResponse(T response, Throwable exception, int attempts) {\n+        WaiterResponse<T> waiterResponse;\n+        if (exception != null) {\n+            waiterResponse = DefaultWaiterResponse.<T>builder().exception(exception).attemptsExecuted(attempts).build();\n+        } else {\n+            waiterResponse = DefaultWaiterResponse.<T>builder().response(response).attemptsExecuted(attempts).build();\n+        }\n+        return waiterResponse;\n+    }\n+\n+    /**\n+     * Iterates over the acceptors list and returns the {@link WaiterState} of the the first acceptor to match the\n+     * result of the operation if present or empty otherwise.\n+     *\n+     * @param response nullable response to match\n+     * @param exception nullable exception to match\n+     * @return the optional {@link WaiterState}\n+     */\n+    public Optional<WaiterState> nextWaiterStateIfMatched(T response, Throwable exception) {\n+        Optional<WaiterState> waiterState;\n+        if (exception != null) {\n+            waiterState = exceptionMatches(exception);\n+        } else {\n+            waiterState = responseMatches(response);\n+        }\n+        return waiterState;", "originalCommit": "fc6d8973f030436054ae63144bc336b824221a7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM1OTI3MQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458359271", "bodyText": "+1", "author": "zoewangg", "createdAt": "2020-07-21T20:11:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwNjc3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwOTQ3MA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458309470", "bodyText": "I feel like a lot of customers would want \"maxWaitTime\" as a configuration more than maxAttempts. I realize the max wait time can be indirectly managed via the maxAttempts, backoffStrategy and client configuration, but it's not easy to do. It would be nice if we did it for them, and we can use the request-level max-execution-time and some checks before sleeping/delegating to the scheduled executor service to do so fairly easily.", "author": "millems", "createdAt": "2020-07-21T18:38:43Z", "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/waiters/PollingStrategy.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.waiters;\n+\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.core.retry.backoff.BackoffStrategy;\n+import software.amazon.awssdk.utils.Validate;\n+\n+/**\n+ * Define the polling strategy for a {@link Waiter} to poll the resource\n+ */\n+@SdkPublicApi\n+public final class PollingStrategy {\n+\n+    private final int maxAttempts;\n+    private final BackoffStrategy backoffStrategy;", "originalCommit": "fc6d8973f030436054ae63144bc336b824221a7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM2MTgxNg==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458361816", "bodyText": "I assume most of customers will use the default generated service waiters directly, which will only have maxAttempts configured. We can certainly add maxWaitTime in the future if people are asking for it, WDUT?", "author": "zoewangg", "createdAt": "2020-07-21T20:16:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwOTQ3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk2NjY3MQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458966671", "bodyText": "Is there any way to let the customer configure the maxWaitTime and maxAttempts on the generated service waiters, to override the behavior?\nI don't mind waiting on customers to ask, but I have recently seen a lot of people using the maxClientExecuteDuration duration lately to limit the amount of time that the SDK will be holding their threads. I feel like SAs are recommending it pretty strongly to their customers, and I am worried that customers might think of the feature as incomplete without it.", "author": "millems", "createdAt": "2020-07-22T17:36:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMwOTQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMxMDIxMw==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458310213", "bodyText": "Again, \"only required during creation, if you invoke this method during usage\" feels like a gross invariant. Wouldn't it be better to encode that into the type? (AsyncWaiter versus Waiter)", "author": "millems", "createdAt": "2020-07-21T18:39:56Z", "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/waiters/Waiter.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.waiters;\n+\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.function.Consumer;\n+import java.util.function.Supplier;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+import software.amazon.awssdk.core.internal.waiters.DefaultWaiter;\n+\n+/**\n+ * Waiter utility class that waits for a resource to transition to the desired state.\n+ *\n+ * @param <T> the type of the resource returned from the polling function\n+ */\n+@SdkPublicApi\n+public interface Waiter<T> {\n+\n+    /**\n+     * Runs the provided polling function. It completes when the resource enters into a desired state or\n+     * it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param asyncPollingFunction the polling function to trigger\n+     * @return A CompletableFuture containing the result of the DescribeTable operation returned by the service. It completes\n+     * successfully when the resource enters into a desired state or it completes exceptionally when it is determined that the\n+     * resource will never enter into the desired state.\n+     */\n+    CompletableFuture<WaiterResponse<T>> runAsync(Supplier<CompletableFuture<T>> asyncPollingFunction);\n+\n+    /**\n+     * It returns when the resource enters into a desired state or\n+     * it is determined that the resource will never enter into the desired state.\n+     *\n+     * @param pollingFunction Represents the input of a <code>DescribeTable</code> operation.\n+     * @return the response\n+     */\n+    WaiterResponse<T> run(Supplier<T> pollingFunction);\n+\n+    /**\n+     * Creates a newly initialized builder for the waiter object.\n+     *\n+     * @param responseClass the response class\n+     * @param <T> the type of the response\n+     * @return a Waiter builder\n+     */\n+    static <T> Builder<T> builder(Class<? extends T> responseClass) {\n+        return DefaultWaiter.builder();\n+    }\n+\n+    /**\n+     * The Waiter Builder\n+     * @param <T> the type of the resource\n+     */\n+    interface Builder<T> {\n+        /**\n+         * Defines a list of {@link WaiterAcceptor}s to check whether an expected state has met after executing an operation.\n+         *\n+         * <p>\n+         * The SDK will iterate over the acceptors list and the first acceptor to match the result of the operation transitions\n+         * the waiter to the state specified in the acceptor.\n+         *\n+         * <p>\n+         * This completely overrides any WaiterAcceptor currently configured in the builder via\n+         * {@link #addAcceptor(WaiterAcceptor)}\n+         *\n+         * @param waiterAcceptors the waiter acceptors\n+         * @return a reference to this object so that method calls can be chained together.\n+         */\n+        Builder<T> acceptors(List<WaiterAcceptor<T>> waiterAcceptors);\n+\n+        /**\n+         * Adds a {@link WaiterAcceptor} to the end of the ordered waiterAcceptors list.\n+         *\n+         * <p>\n+         * The SDK will iterate over the acceptors list and the first acceptor to match the result of the operation transitions\n+         * the waiter to the state specified in the acceptor.\n+         *\n+         * @param waiterAcceptors the waiter acceptors\n+         * @return a reference to this object so that method calls can be chained together.\n+         */\n+        Builder<T> addAcceptor(WaiterAcceptor<T> waiterAcceptors);\n+\n+        /**\n+         * Defines a {@link PollingStrategy} to use when polling a resource\n+         *\n+         * @param pollingStrategy the polling strategy to use\n+         * @return a reference to this object so that method calls can be chained together.\n+         */\n+        Builder<T> pollingStrategy(PollingStrategy pollingStrategy);\n+\n+        /**\n+         * Defines a {@link PollingStrategy} to use when polling a resource\n+         *\n+         * @param pollingStrategy the polling strategy to use\n+         * @return a reference to this object so that method calls can be chained together.\n+         */\n+        default Builder<T> pollingStrategy(Consumer<PollingStrategy.Builder> pollingStrategy) {\n+            PollingStrategy.Builder builder = PollingStrategy.builder();\n+            pollingStrategy.accept(builder);\n+            return pollingStrategy(builder.build());\n+        }\n+\n+        /**\n+         * Defines the {@link ScheduledExecutorService} used to schedule async polling attempts\n+         * Only required if you are calling {@link Waiter#runAsync(Supplier)}", "originalCommit": "fc6d8973f030436054ae63144bc336b824221a7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM2NzcxMg==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458367712", "bodyText": "In my defense, we do have http2 configuration in netty even though it only applies to H2 requests \ud83d\ude1b  But I agree, this is not ideal. Let me think about it a bit more.", "author": "zoewangg", "createdAt": "2020-07-21T20:27:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMxMDIxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMxMTAzNg==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458311036", "bodyText": "What about retryOnResponseAcceptor?", "author": "millems", "createdAt": "2020-07-21T18:41:22Z", "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/waiters/WaiterAcceptor.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.waiters;\n+\n+import java.util.function.Predicate;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+\n+/**\n+ * Inspects the response or errors returned from the operation and determines whether an expected state is met and returns the\n+ * next {@link WaiterState} that the waiter should be transitioned to.\n+ */\n+@SdkPublicApi\n+public interface WaiterAcceptor<T> {\n+\n+    /**\n+     * @return the next {@link WaiterState} that the waiter should be transitioned to\n+     */\n+    WaiterState waiterState();\n+\n+    /**\n+     * Check to see if the response matches with the expected state defined by this acceptor\n+     *\n+     * @param response the response to inspect\n+     * @return whether it accepts the response\n+     */\n+    default boolean matches(T response) {\n+        return false;\n+    }\n+\n+    /**\n+     * Check to see if the exception matches the expected state defined by this acceptor\n+     *\n+     * @param throwable the exception to inspect\n+     * @return whether it accepts the throwable\n+     */\n+    default boolean matches(Throwable throwable) {\n+        return false;\n+    }\n+\n+    /**\n+     * Creates a success waiter acceptor which determines if the exception should transition the waiter to success state\n+     *\n+     * @param responsePredicate the predicate of the response\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> successOnResponseAcceptor(Predicate<T> responsePredicate) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.SUCCESS;\n+            }\n+\n+            @Override\n+            public boolean matches(T response) {\n+                return responsePredicate.test(response);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates an error waiter acceptor which determines if the exception should transition the waiter to success state\n+     *\n+     * @param errorPredicate the {@link Throwable} predicate\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> successOnExceptionAcceptor(Predicate<Throwable> errorPredicate) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.SUCCESS;\n+            }\n+\n+            @Override\n+            public boolean matches(Throwable t) {\n+                return errorPredicate.test(t);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates an error waiter acceptor which determines if the exception should transition the waiter to failure state\n+     *\n+     * @param errorPredicate the {@link Throwable} predicate\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> errorOnExceptionAcceptor(Predicate<Throwable> errorPredicate) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.FAILURE;\n+            }\n+\n+            @Override\n+            public boolean matches(Throwable t) {\n+                return errorPredicate.test(t);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates a success waiter acceptor which determines if the exception should transition the waiter to success state\n+     *\n+     * @param responsePredicate the predicate of the response\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> errorOnResponseAcceptor(Predicate<T> responsePredicate) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.FAILURE;\n+            }\n+\n+            @Override\n+            public boolean matches(T response) {\n+                return responsePredicate.test(response);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates a retry on exception waiter acceptor which determines if the exception should transition the waiter to retry state\n+     *\n+     * @param errorPredicate the {@link Throwable} predicate\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> retryOnExceptionAcceptor(Predicate<Throwable> errorPredicate) {", "originalCommit": "fc6d8973f030436054ae63144bc336b824221a7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM3MDU4MQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458370581", "bodyText": "All non-matching successful responses will get retried implicitly per waiters SEP, otherwise we would need to define tons of retryOnResponseAcceptors for all sorts of successful responses.", "author": "zoewangg", "createdAt": "2020-07-21T20:33:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMxMTAzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk3MTI3NQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458971275", "bodyText": "That's fair, but it feels like a weird omission, even if people wouldn't use it very much. A retryOnResponseAcceptor would still be useful to allow someone to short-circuit a more broad acceptor later in the list:\nE.g.\nwaiterBuilder.addAcceptor(retryOnResponseAcceptor(r -> r.errorCode() == FieldValues.RETRYABLE_ERROR)\n             .addAcceptor(failOnResponseAcceptor(r -> r.errorCode() != null))\nI agree that it's not necessary if all we're using this for is the generated waiters, but we're writing it more generic for a reason.\nThat would also give us the option of changing the default behavior of the core Waiters to whatever we want (if we want to), and just have all of the generated waiters use addAcceptor(retryOnResponseAcceptor(r -> true)).", "author": "millems", "createdAt": "2020-07-22T17:44:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMxMTAzNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTY1MTI5OQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r459651299", "bodyText": "Yeah, makes sense. I'll add it.", "author": "zoewangg", "createdAt": "2020-07-23T18:38:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMxMTAzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMxMTcwNA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458311704", "bodyText": "Should we use an Either type here? Or something that is more explicitly a union type?", "author": "millems", "createdAt": "2020-07-21T18:42:33Z", "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/waiters/WaiterResponse.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.waiters;\n+\n+import java.util.Optional;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+\n+/**\n+ * The response returned from a waiter operation\n+ * @param <T> the type of the response\n+ */\n+@SdkPublicApi\n+public interface WaiterResponse<T> {\n+\n+    /**\n+     * @return the optional response received that has matched with the waiter success condition\n+     */\n+    Optional<T> response();\n+\n+    /**\n+     * @return the optional exception thrown from the waiter operation that has matched with the waiter success condition\n+     */\n+    Optional<Throwable> exception();", "originalCommit": "fc6d8973f030436054ae63144bc336b824221a7c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODM3MjM0OQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r458372349", "bodyText": "Good idea! Let me try it. I don't like two Optionals either, but couldn't think of other ways to do it.", "author": "zoewangg", "createdAt": "2020-07-21T20:36:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODMxMTcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ1NjI2Ng==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r477456266", "bodyText": "Validate the message is not-null so that it doesn't fail slow? Or use Optional.ofNullable.", "author": "millems", "createdAt": "2020-08-26T17:08:33Z", "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/waiters/WaiterAcceptor.java", "diffHunk": "@@ -0,0 +1,214 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.waiters;\n+\n+import java.util.Optional;\n+import java.util.function.Predicate;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+\n+/**\n+ * Inspects the response or errors returned from the operation and determines whether an expected state is met and returns the\n+ * next {@link WaiterState} that the waiter should be transitioned to.\n+ */\n+@SdkPublicApi\n+public interface WaiterAcceptor<T> {\n+\n+    /**\n+     * @return the next {@link WaiterState} that the waiter should be transitioned to\n+     */\n+    WaiterState waiterState();\n+\n+    /**\n+     * Check to see if the response matches with the expected state defined by this acceptor\n+     *\n+     * @param response the response to inspect\n+     * @return whether it accepts the response\n+     */\n+    default boolean matches(T response) {\n+        return false;\n+    }\n+\n+    /**\n+     * Check to see if the exception matches the expected state defined by this acceptor\n+     *\n+     * @param throwable the exception to inspect\n+     * @return whether it accepts the throwable\n+     */\n+    default boolean matches(Throwable throwable) {\n+        return false;\n+    }\n+\n+    /**\n+     * Optional message to provide pertaining to the next WaiterState\n+     *\n+     * @return the optional message\n+     */\n+    default Optional<String> message() {\n+        return Optional.empty();\n+    }\n+\n+    /**\n+     * Creates a success waiter acceptor which determines if the exception should transition the waiter to success state\n+     *\n+     * @param responsePredicate the predicate of the response\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> successOnResponseAcceptor(Predicate<T> responsePredicate) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.SUCCESS;\n+            }\n+\n+            @Override\n+            public boolean matches(T response) {\n+                return responsePredicate.test(response);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates an error waiter acceptor which determines if the exception should transition the waiter to success state\n+     *\n+     * @param errorPredicate the {@link Throwable} predicate\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> successOnExceptionAcceptor(Predicate<Throwable> errorPredicate) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.SUCCESS;\n+            }\n+\n+            @Override\n+            public boolean matches(Throwable t) {\n+                return errorPredicate.test(t);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates an error waiter acceptor which determines if the exception should transition the waiter to failure state\n+     *\n+     * @param errorPredicate the {@link Throwable} predicate\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> errorOnExceptionAcceptor(Predicate<Throwable> errorPredicate) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.FAILURE;\n+            }\n+\n+            @Override\n+            public boolean matches(Throwable t) {\n+                return errorPredicate.test(t);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates a success waiter acceptor which determines if the exception should transition the waiter to success state\n+     *\n+     * @param responsePredicate the predicate of the response\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> errorOnResponseAcceptor(Predicate<T> responsePredicate) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.FAILURE;\n+            }\n+\n+            @Override\n+            public boolean matches(T response) {\n+                return responsePredicate.test(response);\n+            }\n+        };\n+    }\n+\n+    /**\n+     * Creates a success waiter acceptor which determines if the exception should transition the waiter to success state\n+     *\n+     * @param responsePredicate the predicate of the response\n+     * @param <T> the response type\n+     * @return a {@link WaiterAcceptor}\n+     */\n+    static <T> WaiterAcceptor<T> errorOnResponseAcceptor(Predicate<T> responsePredicate, String message) {\n+        return new WaiterAcceptor<T>() {\n+            @Override\n+            public WaiterState waiterState() {\n+                return WaiterState.FAILURE;\n+            }\n+\n+            @Override\n+            public boolean matches(T response) {\n+                return responsePredicate.test(response);\n+            }\n+\n+            @Override\n+            public Optional<String> message() {\n+                return Optional.of(message);\n+            }\n+        };\n+    }", "originalCommit": "feb25a88ddd844f1de5007eeace9266ecc8914c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ5ODI1NA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r477498254", "bodyText": "Ah, good catch!", "author": "zoewangg", "createdAt": "2020-08-26T18:20:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ1NjI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ1OTg5OA==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r477459898", "bodyText": "Do we have a naming convention established that differentiates between a Strategy (e.g. PollingStrategy) or Policy (e.g. RetryPolicy)?", "author": "millems", "createdAt": "2020-08-26T17:14:32Z", "path": "core/sdk-core/src/main/java/software/amazon/awssdk/core/waiters/WaiterBuilder.java", "diffHunk": "@@ -0,0 +1,72 @@\n+/*\n+ * Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\").\n+ * You may not use this file except in compliance with the License.\n+ * A copy of the License is located at\n+ *\n+ *  http://aws.amazon.com/apache2.0\n+ *\n+ * or in the \"license\" file accompanying this file. This file is distributed\n+ * on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either\n+ * express or implied. See the License for the specific language governing\n+ * permissions and limitations under the License.\n+ */\n+\n+package software.amazon.awssdk.core.waiters;\n+\n+import java.util.List;\n+import java.util.function.Consumer;\n+import software.amazon.awssdk.annotations.SdkPublicApi;\n+\n+@SdkPublicApi\n+public interface WaiterBuilder<T, B> {\n+    /**\n+     * Defines a list of {@link WaiterAcceptor}s to check whether an expected state has met after executing an operation.\n+     *\n+     * <p>\n+     * The SDK will iterate over the acceptors list and the first acceptor to match the result of the operation transitions\n+     * the waiter to the state specified in the acceptor.\n+     *\n+     * <p>\n+     * This completely overrides any WaiterAcceptor currently configured in the builder via\n+     * {@link #addAcceptor(WaiterAcceptor)}\n+     *\n+     * @param waiterAcceptors the waiter acceptors\n+     * @return a reference to this object so that method calls can be chained together.\n+     */\n+    B acceptors(List<WaiterAcceptor<T>> waiterAcceptors);\n+\n+    /**\n+     * Adds a {@link WaiterAcceptor} to the end of the ordered waiterAcceptors list.\n+     *\n+     * <p>\n+     * The SDK will iterate over the acceptors list and the first acceptor to match the result of the operation transitions\n+     * the waiter to the state specified in the acceptor.\n+     *\n+     * @param waiterAcceptors the waiter acceptors\n+     * @return a reference to this object so that method calls can be chained together.\n+     */\n+    B addAcceptor(WaiterAcceptor<T> waiterAcceptors);\n+\n+    /**\n+     * Defines a {@link PollingStrategy} to use when polling a resource\n+     *\n+     * @param pollingStrategy the polling strategy to use\n+     * @return a reference to this object so that method calls can be chained together.\n+     */\n+    B pollingStrategy(PollingStrategy pollingStrategy);", "originalCommit": "feb25a88ddd844f1de5007eeace9266ecc8914c3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ5ODg3NQ==", "url": "https://github.com/aws/aws-sdk-java-v2/pull/1957#discussion_r477498875", "bodyText": "Nope, don't think so.PollingStrategy, BackoffStrategy, and RetryPolicy are all existing classes.", "author": "zoewangg", "createdAt": "2020-08-26T18:22:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzQ1OTg5OA=="}], "type": "inlineReview"}, {"oid": "e29ddcacb8cc19ba344f91cb997607de6ef416c9", "url": "https://github.com/aws/aws-sdk-java-v2/commit/e29ddcacb8cc19ba344f91cb997607de6ef416c9", "message": "Implement generic Waiter functionality", "committedDate": "2020-08-26T21:50:19Z", "type": "commit"}, {"oid": "e29ddcacb8cc19ba344f91cb997607de6ef416c9", "url": "https://github.com/aws/aws-sdk-java-v2/commit/e29ddcacb8cc19ba344f91cb997607de6ef416c9", "message": "Implement generic Waiter functionality", "committedDate": "2020-08-26T21:50:19Z", "type": "forcePushed"}]}