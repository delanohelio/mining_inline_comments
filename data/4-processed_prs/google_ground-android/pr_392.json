{"pr_number": 392, "pr_title": "Refactor Tile Download Worker to Download Pending Tiles in DB", "pr_createdAt": "2020-03-12T20:08:00Z", "pr_url": "https://github.com/google/ground-android/pull/392", "timeline": [{"oid": "2d32543023ab8e4bac05a1ba396a0b4e26fb4e39", "url": "https://github.com/google/ground-android/commit/2d32543023ab8e4bac05a1ba396a0b4e26fb4e39", "message": "Refactor Tile Download Worker to Poll DB\n\nThe Tile Download Worker originally accepted a tile id and the tile\ndownload work manager explicitly queued workers to conduct downloads\nof a list of tiles (given their ids). Now the tile download worker\ninstead checks the local data store for pending tiles and handles\ndownloading them independently -- the manager no longer passes any input\ndata to the worker.\n\nI've also made liberal use of completables, removed a method from the\nworker, and attempted to simplify the interface.\n\nThe findAll method in the TileDao now returns a single, as this behavior\nseems more appropriate (typically, we won't need to continue to\ncontinually react to the tile DB contents as a flowable allows, and this\nsimplifies the use of the stream in the worker, for situations that do\ncall for a flowable, the single may be converted).", "committedDate": "2020-03-12T20:04:39Z", "type": "commit"}, {"oid": "af686d84c9b4dee13d48702555d7246ce1de31ee", "url": "https://github.com/google/ground-android/commit/af686d84c9b4dee13d48702555d7246ce1de31ee", "message": "Merge branch 'master' of https://github.com/google/ground-android into tile-worker", "committedDate": "2020-03-12T20:04:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4NzIwOQ==", "url": "https://github.com/google/ground-android/pull/392#discussion_r391887209", "bodyText": "Rather than using findAll and filtering, can we define a method on the DAO that only returns tiles with state == PENDING?", "author": "gino-m", "createdAt": "2020-03-12T20:51:45Z", "path": "gnd/src/main/java/com/google/android/gnd/persistence/local/room/RoomLocalDataStore.java", "diffHunk": "@@ -436,4 +438,19 @@ public Completable insertOrUpdateTile(Tile tile) {\n   public Maybe<Tile> getTile(String tileId) {\n     return tileDao.findById(tileId).map(TileEntity::toTile).subscribeOn(schedulers.io());\n   }\n+\n+  @Override\n+  public Single<ImmutableList<Tile>> getPendingTiles() {\n+    // TODO: Only retrieve tiles for a given area.\n+    // This currently retrieves all pending tiles in the DB.\n+    return tileDao\n+        .findAll()", "originalCommit": "af686d84c9b4dee13d48702555d7246ce1de31ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDM5NjEwOA==", "url": "https://github.com/google/ground-android/pull/392#discussion_r394396108", "bodyText": "The DAO Query strings have to be constant, which unfortunately means we can't exactly add a Pending tiles method to the DAO directly without using an int literal, which is too brittle for my taste.\nHowever, I have switched to using a findByState method instead, which is simpler!", "author": "scolsen", "createdAt": "2020-03-18T14:38:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4NzIwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQxMzE2MQ==", "url": "https://github.com/google/ground-android/pull/392#discussion_r394413161", "bodyText": "see commit 2b867a8", "author": "scolsen", "createdAt": "2020-03-18T15:00:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4NzIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4Nzg5MA==", "url": "https://github.com/google/ground-android/pull/392#discussion_r391887890", "bodyText": "Does this need to be in a finally block?", "author": "gino-m", "createdAt": "2020-03-12T20:53:18Z", "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();", "originalCommit": "af686d84c9b4dee13d48702555d7246ce1de31ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQyNDM1MA==", "url": "https://github.com/google/ground-android/pull/392#discussion_r394424350", "bodyText": "Used a try-with-resources block instead (since android studio suggested it).", "author": "scolsen", "createdAt": "2020-03-18T15:15:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4Nzg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMDUzMA==", "url": "https://github.com/google/ground-android/pull/392#discussion_r394430530", "bodyText": "Done see 2b81c0b", "author": "scolsen", "createdAt": "2020-03-18T15:23:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4Nzg5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4OTA1MQ==", "url": "https://github.com/google/ground-android/pull/392#discussion_r391889051", "bodyText": "Do I understand correct that \"Tile\" actually refers to an entire pyramid of tiles, and not a single tile? If so, at some point we may want to rename it something more appropriate to avoid confusing others (and ourselves).", "author": "gino-m", "createdAt": "2020-03-12T20:55:54Z", "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();\n   }\n \n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+  /** Update a tile's state in the database and initiate a download of the tile source file. */\n+  private Completable downloadTile(Tile tile) {", "originalCommit": "af686d84c9b4dee13d48702555d7246ce1de31ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMDgwNg==", "url": "https://github.com/google/ground-android/pull/392#discussion_r394430806", "bodyText": "Have any ideas on what we should call it?", "author": "scolsen", "createdAt": "2020-03-18T15:23:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4OTA1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMDk4OQ==", "url": "https://github.com/google/ground-android/pull/392#discussion_r394430989", "bodyText": "Will probably hold off on this for a later PR", "author": "scolsen", "createdAt": "2020-03-18T15:23:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4OTA1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ0NjQ3Mw==", "url": "https://github.com/google/ground-android/pull/392#discussion_r394446473", "bodyText": "SGTM. Filed #400 to track!", "author": "gino-m", "createdAt": "2020-03-18T15:44:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg4OTA1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MDg3MQ==", "url": "https://github.com/google/ground-android/pull/392#discussion_r391890871", "bodyText": "If you use Completable.fromRunnable instead you don't need to return anything and can use an inline lambda instead of a block.", "author": "gino-m", "createdAt": "2020-03-12T20:59:57Z", "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();\n   }\n \n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+  /** Update a tile's state in the database and initiate a download of the tile source file. */\n+  private Completable downloadTile(Tile tile) {\n     HashMap<String, String> requestProperties = new HashMap<>();\n \n-    requestProperties.put(\"Range\", existingTileFile.length() + \"-\");\n+    if (tile.getState() == State.IN_PROGRESS) {\n+      File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+      requestProperties.put(\"Range\", existingTileFile.length() + \"-\");\n+    }\n \n-    return downloadTileFile(tile, Optional.of(requestProperties));\n+    return localDataStore\n+        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n+        .andThen(\n+            Completable.fromCallable(", "originalCommit": "af686d84c9b4dee13d48702555d7246ce1de31ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk0OTI3Mg==", "url": "https://github.com/google/ground-android/pull/392#discussion_r391949272", "bodyText": "I wanted to do this, but since the IO exception here is a checked exception, we'd have to explicitly handle the error in the runnable itself, losing the elegance of its automatic propagation upstream (though I suppose NBD since we're already losing elegance with this approach). see here for more info: https://stackoverflow.com/questions/44179444/how-to-create-observable-out-of-runnable\nOur options are what we currently have here, or:\nCompletable.fromRunnable(() -> {try {downloadTile(tile)} catch (IOException e) { Log.d(TAG, \"Failed to download tile: \" + tile, e);}})\nI opted for the Callable variant since it's shorter. Though I think it may be more confusing to someone unfamiliar with the checked exception restriction....but then again so would handling the exception in the runnable itself.\nI'm good with using whichever style you prefer.", "author": "scolsen", "createdAt": "2020-03-12T23:00:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MDg3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM0MDQ0Mg==", "url": "https://github.com/google/ground-android/pull/392#discussion_r392340442", "bodyText": "Perhaps downloadTileFile() should catch the error and rethrow an unchecked exception?\nWe need to try {} finally {} in downloadTileFile() to close the connection, so adding catch() should be easy. Wdyt?", "author": "gino-m", "createdAt": "2020-03-13T16:35:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MDg3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjM4MjkxMA==", "url": "https://github.com/google/ground-android/pull/392#discussion_r392382910", "bodyText": "Perhaps downloadTileFile() should catch the error and rethrow an unchecked exception?\nWe need to try {} finally {} in downloadTileFile() to close the connection, so adding catch() should be easy. Wdyt?\n\nThat's a great idea! Let's do that.", "author": "scolsen", "createdAt": "2020-03-13T17:52:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MDg3MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMDMzNw==", "url": "https://github.com/google/ground-android/pull/392#discussion_r394430337", "bodyText": "Done see 2b81c0b", "author": "scolsen", "createdAt": "2020-03-18T15:22:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MDg3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MTA4OQ==", "url": "https://github.com/google/ground-android/pull/392#discussion_r391891089", "bodyText": "Please add a comment explaining why we do this (to resume downloads)? Btw, have you seen this work in practice?", "author": "gino-m", "createdAt": "2020-03-12T21:00:30Z", "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();\n   }\n \n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+  /** Update a tile's state in the database and initiate a download of the tile source file. */\n+  private Completable downloadTile(Tile tile) {\n     HashMap<String, String> requestProperties = new HashMap<>();\n \n-    requestProperties.put(\"Range\", existingTileFile.length() + \"-\");\n+    if (tile.getState() == State.IN_PROGRESS) {", "originalCommit": "af686d84c9b4dee13d48702555d7246ce1de31ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTk1MDA3OQ==", "url": "https://github.com/google/ground-android/pull/392#discussion_r391950079", "bodyText": "The range request is supposed to let us resume the file download from where it stopped, but tbh I haven't confirmed it works in practice, and I don't really know much about HTTP range requests at all.\nIt might be safer to just start the entire file download again when we resume something in progress and overwrite anything that was already on disk. Even though we're technically doing extra work in that case.", "author": "scolsen", "createdAt": "2020-03-12T23:02:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MTA4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjMzODg1Mw==", "url": "https://github.com/google/ground-android/pull/392#discussion_r392338853", "bodyText": "Hmm.. perhaps.. we can leave it for now provided we test it out.", "author": "gino-m", "createdAt": "2020-03-13T16:33:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MTA4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQyNDYwOQ==", "url": "https://github.com/google/ground-android/pull/392#discussion_r394424609", "bodyText": "sg!", "author": "scolsen", "createdAt": "2020-03-18T15:15:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MTA4OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ2NjI2OQ==", "url": "https://github.com/google/ground-android/pull/392#discussion_r394466269", "bodyText": "Fixed some problems w/ this and added explanatory comments in 7582c4f", "author": "scolsen", "createdAt": "2020-03-18T16:09:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MTA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MTczOQ==", "url": "https://github.com/google/ground-android/pull/392#discussion_r391891739", "bodyText": "Please define variable as Map instead.", "author": "gino-m", "createdAt": "2020-03-12T21:01:57Z", "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -42,106 +45,106 @@\n public class TileDownloadWorker extends Worker {\n   private static final String TAG = TileDownloadWorker.class.getSimpleName();\n \n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n-    try {\n-      URL url = new URL(tile.getUrl());\n-      HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n-\n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n-          connection.setRequestProperty(property.getKey(), property.getValue());\n-        }\n-      }\n-\n-      connection.connect();\n-\n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n-\n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws IOException {\n+    URL url = new URL(tile.getUrl());\n+    HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n+\n+    if (!requestProperties.isEmpty()) {\n+      for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n+        connection.setRequestProperty(property.getKey(), property.getValue());\n       }\n+    }\n \n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n-\n-    } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n+    connection.connect();\n \n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n+    InputStream is = connection.getInputStream();\n+    FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n+    byte[] byteChunk = new byte[BUFFER_SIZE];\n+    int n;\n \n-      return Result.failure();\n+    while ((n = is.read(byteChunk)) > 0) {\n+      fos.write(byteChunk, 0, n);\n     }\n-  }\n-\n-  /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n \n-    return downloadTileFile(tile, Optional.empty());\n+    is.close();\n+    fos.close();\n   }\n \n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+  /** Update a tile's state in the database and initiate a download of the tile source file. */\n+  private Completable downloadTile(Tile tile) {\n     HashMap<String, String> requestProperties = new HashMap<>();", "originalCommit": "af686d84c9b4dee13d48702555d7246ce1de31ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMzg0NA==", "url": "https://github.com/google/ground-android/pull/392#discussion_r394433844", "bodyText": "c68a03b", "author": "scolsen", "createdAt": "2020-03-18T15:27:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MTczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MjU1OA==", "url": "https://github.com/google/ground-android/pull/392#discussion_r391892558", "bodyText": "We shouldn't care if there are no pending tiles; if so another instance of the worker may have completed the job for us, and we should just exit since everything is in the proper state.", "author": "gino-m", "createdAt": "2020-03-12T21:03:45Z", "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -150,27 +153,23 @@ private Result checkDownload(Tile tile) {\n   @NonNull\n   @Override\n   public Result doWork() {\n-    Tile tile = localDataStore.getTile(tileId).blockingGet();\n+    ImmutableList<Tile> pendingTiles = localDataStore.getPendingTiles().blockingGet();\n \n-    // When there is no tile in the db, the Maybe completes and returns null.\n+    // When there are no tiles in the db, the blockingGet returns null.\n     // We expect tiles to be added to the DB prior to downloading.\n     // If that isn't the case, we fail.\n-    if (tile == null) {\n+    if (pendingTiles == null) {", "originalCommit": "af686d84c9b4dee13d48702555d7246ce1de31ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzOTQ5MQ==", "url": "https://github.com/google/ground-android/pull/392#discussion_r394439491", "bodyText": "Gotcha, we'll just treat it as a success then eec1754", "author": "scolsen", "createdAt": "2020-03-18T15:35:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5MjU1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5Mjc2OA==", "url": "https://github.com/google/ground-android/pull/392#discussion_r391892768", "bodyText": "Fyi: After Shobhit's recent PR, you can now just Timber.d(\"Downloading tiles %s\", pendingTiles).", "author": "gino-m", "createdAt": "2020-03-12T21:04:15Z", "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -150,27 +153,23 @@ private Result checkDownload(Tile tile) {\n   @NonNull\n   @Override\n   public Result doWork() {\n-    Tile tile = localDataStore.getTile(tileId).blockingGet();\n+    ImmutableList<Tile> pendingTiles = localDataStore.getPendingTiles().blockingGet();\n \n-    // When there is no tile in the db, the Maybe completes and returns null.\n+    // When there are no tiles in the db, the blockingGet returns null.\n     // We expect tiles to be added to the DB prior to downloading.\n     // If that isn't the case, we fail.\n-    if (tile == null) {\n+    if (pendingTiles == null) {\n       return Result.failure();\n     }\n \n-    Log.d(TAG, \"Downloading tile: \" + tile.getPath());\n-\n-    switch (tile.getState()) {\n-      case DOWNLOADED:\n-        return checkDownload(tile);\n-      case PENDING:\n-      case FAILED:\n-        return downloadTile(tile);\n-      case IN_PROGRESS:\n-        return resumeTileDownload(tile);\n-      default:\n-        return Result.failure();\n+    Log.d(TAG, \"Downloading tiles: \" + pendingTiles);", "originalCommit": "af686d84c9b4dee13d48702555d7246ce1de31ee", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQyOTY3Nw==", "url": "https://github.com/google/ground-android/pull/392#discussion_r394429677", "bodyText": "Whoops not actually done, will be shortly", "author": "scolsen", "createdAt": "2020-03-18T15:22:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5Mjc2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQzMzczNw==", "url": "https://github.com/google/ground-android/pull/392#discussion_r394433737", "bodyText": "Now it's done :) c68a03b", "author": "scolsen", "createdAt": "2020-03-18T15:27:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTg5Mjc2OA=="}], "type": "inlineReview"}, {"oid": "5faf9d060e1e51928b8de643a0ce8cc1420b6318", "url": "https://github.com/google/ground-android/commit/5faf9d060e1e51928b8de643a0ce8cc1420b6318", "message": "Merge branch 'master' into tile-worker", "committedDate": "2020-03-16T20:04:24Z", "type": "commit"}, {"oid": "2b867a867411a78ce2c11e26b232a8abf6f02686", "url": "https://github.com/google/ground-android/commit/2b867a867411a78ce2c11e26b232a8abf6f02686", "message": "Add findByState method to TileDao\n\nInstead of finding all tiles and filtering based on tile state, we now\nuse a findByState method to retrieve tiles with a given state from the\nlocal data store. This removes the need for filtering downstream.", "committedDate": "2020-03-18T14:59:06Z", "type": "commit"}, {"oid": "4a1013bff0b901870d613bfc2688bf9038cc23ba", "url": "https://github.com/google/ground-android/commit/4a1013bff0b901870d613bfc2688bf9038cc23ba", "message": "Merge branch 'tile-worker' of https://github.com/google/ground-android into tile-worker", "committedDate": "2020-03-18T15:00:06Z", "type": "commit"}, {"oid": "2b81c0bd31e2974257992d6142834064c648c1a6", "url": "https://github.com/google/ground-android/commit/2b81c0bd31e2974257992d6142834064c648c1a6", "message": "Catch expections in downloadTileFile; make runnable\n\nCompletable.fromRunnable can't take methods that throw checked\nexpections, however its semantics are clearer than our previous approach\n(using fromCallable and returning null). So, we now catch checked\nexceptions in downloadTileFile and throw a runtime execption so that we\ncan use `fromRunnable`.\n\nThis change contains a couple improvements to our `downloadTileFile`\napproach:\n\n- Catch checked IO execptions in the `downloadTileFileException`\n- Use a try-with-resources block to ensure connections and streams are\n  closed\n- Use fromRunnable instead of fromCompleteable.\n- Use Timber for logging.", "committedDate": "2020-03-18T15:21:08Z", "type": "commit"}, {"oid": "c68a03b116adc994f12fe14715966e6023e1ee54", "url": "https://github.com/google/ground-android/commit/c68a03b116adc994f12fe14715966e6023e1ee54", "message": "Small quality of life fixes in TileDownloadWorker\n\n- Use Timber to log.\n- Use `Map` instead of `HashMap` in type declarations.\n- Minor formatting corrections.", "committedDate": "2020-03-18T15:26:42Z", "type": "commit"}, {"oid": "eec1754ef6db6a242593b747c2a6c905b6ba95ff", "url": "https://github.com/google/ground-android/commit/eec1754ef6db6a242593b747c2a6c905b6ba95ff", "message": "TileDownloadWorker: Return success on null pending tiles\n\nSince a null set of pending tiles may indicate that work has already\nbeen performed by another worker, we return success and stop the worker\nimmediately.", "committedDate": "2020-03-18T15:34:09Z", "type": "commit"}, {"oid": "29983a609b54ede8bdf6adacc3cfd5a0f0a0f2ba", "url": "https://github.com/google/ground-android/commit/29983a609b54ede8bdf6adacc3cfd5a0f0a0f2ba", "message": "Merge branch 'master' into tile-worker", "committedDate": "2020-03-18T15:52:56Z", "type": "commit"}, {"oid": "7582c4faacdf0fd4baad51936a85c7a89769c096", "url": "https://github.com/google/ground-android/commit/7582c4faacdf0fd4baad51936a85c7a89769c096", "message": "Specify an appropriate file mode based on Tile state\n\nPreviously, our download code was erroneous\u2014in cases in which we attempt\nto resume a partially downloaded tile, we were using MODE_PRIVATE, which\noverwrites, instead of appending, the contents of the tile file,\nresulting in partial file contents.\n\nWe now set the correct mode (Append or Create) based on the state of the\ntile.\n\nI've also fixed the value of the range property, which must specify the\nunit used (bytes in our case).\n\nI've also added clarificatory comments on our approach to resuming tile\ndownloads and fixed some formatting errors.\n\nAlso fixed a small PMD error.", "committedDate": "2020-03-18T16:08:11Z", "type": "commit"}, {"oid": "de5953f827699ffb70383cb6557d9a04904851cf", "url": "https://github.com/google/ground-android/commit/de5953f827699ffb70383cb6557d9a04904851cf", "message": "Merge branch 'tile-worker' of https://github.com/google/ground-android into tile-worker", "committedDate": "2020-03-18T16:08:36Z", "type": "commit"}, {"oid": "096707a799c7efe3cea8755e4cedb2ec445b2be2", "url": "https://github.com/google/ground-android/commit/096707a799c7efe3cea8755e4cedb2ec445b2be2", "message": "Remove TODO related to local ds `getPendingTiles` method\n\nWe decided not to do this, as it would result in extra work.\n\nThe current approach is fine.", "committedDate": "2020-03-18T16:11:27Z", "type": "commit"}, {"oid": "b8ebd4c739d297fa8883672bb51198040887b1b0", "url": "https://github.com/google/ground-android/commit/b8ebd4c739d297fa8883672bb51198040887b1b0", "message": "Fix formatting in RoomLocalDataStore", "committedDate": "2020-03-18T16:14:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4MTUyMQ==", "url": "https://github.com/google/ground-android/pull/392#discussion_r394481521", "bodyText": "Naming nit: Since this both checking and downloads, maybe downloadIfNotFound? This can be done in a follow up though.", "author": "gino-m", "createdAt": "2020-03-18T16:30:56Z", "path": "gnd/src/main/java/com/google/android/gnd/workers/TileDownloadWorker.java", "diffHunk": "@@ -32,116 +35,140 @@\n import java.net.URL;\n import java.util.HashMap;\n import java.util.Map;\n-import java8.util.Optional;\n+import timber.log.Timber;\n \n /**\n  * A worker that downloads files to the device in the background. The target URL and file name are\n  * provided in a {@link Data} object. This worker should only run when the device has a network\n  * connection.\n  */\n public class TileDownloadWorker extends Worker {\n-  private static final String TAG = TileDownloadWorker.class.getSimpleName();\n-\n-  private static final String TILE_ID = \"tile_id\";\n   private static final int BUFFER_SIZE = 4096;\n \n   private final Context context;\n   private final LocalDataStore localDataStore;\n-  private final String tileId;\n+\n+  class TileDownloadException extends RuntimeException {\n+\n+    TileDownloadException(String msg, Throwable e) {\n+      super(msg, e);\n+    }\n+  }\n \n   public TileDownloadWorker(\n       @NonNull Context context, @NonNull WorkerParameters params, LocalDataStore localDataStore) {\n     super(context, params);\n     this.context = context;\n     this.localDataStore = localDataStore;\n-    this.tileId = params.getInputData().getString(TILE_ID);\n-  }\n-\n-  /** Creates input data for the TileDownloadWorker. */\n-  public static Data createInputData(String tilePrimaryKey) {\n-    return new Data.Builder().putString(TILE_ID, tilePrimaryKey).build();\n   }\n \n   /**\n    * Given a tile, downloads the given {@param tile}'s source file and saves it to the device's app\n    * storage. Optional HTTP request header {@param requestProperties} may be provided.\n    */\n-  private Result downloadTileFile(Tile tile, Optional<HashMap<String, String>> requestProperties) {\n+  private void downloadTileFile(Tile tile, Map<String, String> requestProperties)\n+      throws TileDownloadException {\n+\n+    int mode = Context.MODE_PRIVATE;\n+\n     try {\n       URL url = new URL(tile.getUrl());\n       HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n \n-      if (requestProperties.isPresent()) {\n-        for (Map.Entry<String, String> property : requestProperties.get().entrySet()) {\n+      if (!requestProperties.isEmpty()) {\n+        for (Map.Entry<String, String> property : requestProperties.entrySet()) {\n           connection.setRequestProperty(property.getKey(), property.getValue());\n         }\n+        mode = Context.MODE_APPEND;\n       }\n \n       connection.connect();\n \n-      InputStream is = connection.getInputStream();\n-      FileOutputStream fos = context.openFileOutput(tile.getPath(), Context.MODE_PRIVATE);\n-      byte[] byteChunk = new byte[BUFFER_SIZE];\n-      int n;\n+      try (InputStream is = connection.getInputStream();\n+          FileOutputStream fos = context.openFileOutput(tile.getPath(), mode)) {\n \n-      while ((n = is.read(byteChunk)) > 0) {\n-        fos.write(byteChunk, 0, n);\n-      }\n-\n-      is.close();\n-      fos.close();\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.DOWNLOADED).build())\n-          .blockingAwait();\n-\n-      return Result.success();\n+        byte[] byteChunk = new byte[BUFFER_SIZE];\n+        int n;\n \n+        while ((n = is.read(byteChunk)) > 0) {\n+          fos.write(byteChunk, 0, n);\n+        }\n+      }\n     } catch (IOException e) {\n-      Log.d(TAG, \"Failed to download and write file.\", e);\n-\n-      localDataStore\n-          .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.FAILED).build())\n-          .blockingAwait();\n-\n-      return Result.failure();\n+      throw new TileDownloadException(\"Failed to download tile\", e);\n     }\n   }\n \n   /** Update a tile's state in the database and initiate a download of the tile source file. */\n-  private Result downloadTile(Tile tile) {\n-    localDataStore\n-        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n-        .blockingAwait();\n-\n-    return downloadTileFile(tile, Optional.empty());\n-  }\n-\n-  /** Resumes downloading the source for {@param tile} marked as {@code Tile.State.IN_PROGRESS}. */\n-  private Result resumeTileDownload(Tile tile) {\n-    File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n-    HashMap<String, String> requestProperties = new HashMap<>();\n-\n-    requestProperties.put(\"Range\", existingTileFile.length() + \"-\");\n+  private Completable downloadTile(Tile tile) {\n+    Map<String, String> requestProperties = new HashMap<>();\n+\n+    // To resume a download for an in progress tile, we use the HTTP Range request property.\n+    // The range property takes a range of bytes, the server returns the content of the resource\n+    // that corresponds to the given byte range.\n+    //\n+    // To resume a download, we get the current length, in bytes, of the file on disk.\n+    // appending '-' to the byte value tells the server to return the range of bytes from the given\n+    // byte value to the end of the file, e.g. '500-' returns contents starting at byte 500 to EOF.\n+    //\n+    // Note that length returns 0 when the file does not exist, so this correctly handles an edge\n+    // case whereby the local DB has a tile state of IN_PROGRESS but none of the file has been\n+    // downloaded yet (since then we'll fetch the range '0-', the entire file).\n+    //\n+    // For more info see: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Range\n+    if (tile.getState() == State.IN_PROGRESS) {\n+      File existingTileFile = new File(context.getFilesDir(), tile.getPath());\n+      requestProperties.put(\"Range\", \"bytes=\" + existingTileFile.length() + \"-\");\n+    }\n \n-    return downloadTileFile(tile, Optional.of(requestProperties));\n+    return localDataStore\n+        .insertOrUpdateTile(tile.toBuilder().setState(Tile.State.IN_PROGRESS).build())\n+        .andThen(\n+            Completable.fromRunnable(\n+                () -> {\n+                  downloadTileFile(tile, requestProperties);\n+                }))\n+        .onErrorResumeNext(\n+            e -> {\n+              Timber.d(e, \"Failed to download tile: %s\", tile);\n+              return localDataStore.insertOrUpdateTile(\n+                  tile.toBuilder().setState(State.FAILED).build());\n+            })\n+        .andThen(\n+            localDataStore.insertOrUpdateTile(tile.toBuilder().setState(State.DOWNLOADED).build()));\n   }\n \n   /**\n    * Verifies that {@param tile} marked as {@code Tile.State.DOWNLOADED} in the local database still\n    * exists in the app's storage. If the tile's source file isn't present, initiates a download of\n    * source file.\n    */\n-  private Result checkDownload(Tile tile) {\n+  private Completable checkDownload(Tile tile) {", "originalCommit": "de5953f827699ffb70383cb6557d9a04904851cf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ5OTU3MA==", "url": "https://github.com/google/ground-android/pull/392#discussion_r394499570", "bodyText": "Done! 6373a71", "author": "scolsen", "createdAt": "2020-03-18T16:57:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDQ4MTUyMQ=="}], "type": "inlineReview"}, {"oid": "6373a716eeba077eeb6fd3da605a0eb441e18835", "url": "https://github.com/google/ground-android/commit/6373a716eeba077eeb6fd3da605a0eb441e18835", "message": "Rename checkDownload -> downloadIfNotFound", "committedDate": "2020-03-18T16:56:49Z", "type": "commit"}, {"oid": "7d32a1b5ccea340fb0fea692de4fad82fdf1af44", "url": "https://github.com/google/ground-android/commit/7d32a1b5ccea340fb0fea692de4fad82fdf1af44", "message": "Merge branch 'master' into tile-worker", "committedDate": "2020-03-18T17:32:49Z", "type": "commit"}]}