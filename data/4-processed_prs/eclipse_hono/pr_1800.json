{"pr_number": 1800, "pr_title": "[#1272] Add new Device Connection API methods", "pr_createdAt": "2020-03-02T16:01:50Z", "pr_url": "https://github.com/eclipse/hono/pull/1800", "timeline": [{"oid": "26e8e54e6f4919309ba244f97f4f2296a3bdd9aa", "url": "https://github.com/eclipse/hono/commit/26e8e54e6f4919309ba244f97f4f2296a3bdd9aa", "message": "[#1272] Add new Device Connection API methods.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>", "committedDate": "2020-03-02T20:44:59Z", "type": "forcePushed"}, {"oid": "833d149421641ee28020b6ba6586a8af79211b4c", "url": "https://github.com/eclipse/hono/commit/833d149421641ee28020b6ba6586a8af79211b4c", "message": "[#1272] Add new Device Connection API methods.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>", "committedDate": "2020-03-08T20:48:57Z", "type": "forcePushed"}, {"oid": "c38abdaa92f2f40aecde3acb5bb17d0a6f6fb74a", "url": "https://github.com/eclipse/hono/commit/c38abdaa92f2f40aecde3acb5bb17d0a6f6fb74a", "message": "[#1272] Add new Device Connection API methods.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>", "committedDate": "2020-03-08T21:11:40Z", "type": "forcePushed"}, {"oid": "e95562ca2b4f1dcbc6a91d153de1243b3c31be65", "url": "https://github.com/eclipse/hono/commit/e95562ca2b4f1dcbc6a91d153de1243b3c31be65", "message": "[#1272] Add new Device Connection API methods.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>", "committedDate": "2020-03-10T08:18:15Z", "type": "forcePushed"}, {"oid": "904a8cb84121cf4b83841d7a96261919f444ae15", "url": "https://github.com/eclipse/hono/commit/904a8cb84121cf4b83841d7a96261919f444ae15", "message": "[#1272] Add new Device Connection API methods.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>", "committedDate": "2020-03-10T12:20:57Z", "type": "forcePushed"}, {"oid": "50cee3621ab8b1f250bc76726113677d59dc6579", "url": "https://github.com/eclipse/hono/commit/50cee3621ab8b1f250bc76726113677d59dc6579", "message": "[#1272] Add new Device Connection API methods.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>", "committedDate": "2020-03-10T18:46:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc5NjUxOA==", "url": "https://github.com/eclipse/hono/pull/1800#discussion_r390796518", "bodyText": "IMHO we should simply refer to the Device Connection API here in order to prevent duplication and diverging documentation. WDYT?", "author": "sophokles73", "createdAt": "2020-03-11T07:59:55Z", "path": "client/src/main/java/org/eclipse/hono/client/DeviceConnectionClient.java", "diffHunk": "@@ -64,4 +66,93 @@\n      * @throws NullPointerException if device id is {@code null}.\n      */\n     Future<JsonObject> getLastKnownGatewayForDevice(String deviceId, SpanContext context);\n+\n+    /**\n+     * Sets the protocol adapter instance that handles commands for the given device.\n+     *\n+     * @param deviceId The device id.\n+     * @param adapterInstanceId The protocol adapter instance id.\n+     * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.\n+     *            An implementation should use this as the parent for any span it creates for tracing\n+     *            the execution of this operation.\n+     * @return A future indicating whether the operation succeeded or not.\n+     * @throws NullPointerException if device id or adapter instance id is {@code null}.\n+     */\n+    Future<Void> setCommandHandlingAdapterInstance(String deviceId, String adapterInstanceId, SpanContext context);\n+\n+    /**\n+     * Removes the mapping information that associates the given device with the given protocol adapter instance\n+     * that handles commands for the given device. The mapping entry is only deleted if its value\n+     * contains the given protocol adapter instance id.\n+     *\n+     * @param deviceId The device id.\n+     * @param adapterInstanceId The protocol adapter instance id that the entry to be removed has to contain.\n+     * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.\n+     *            An implementation should use this as the parent for any span it creates for tracing\n+     *            the execution of this operation.\n+     * @return A future indicating the outcome of the operation.\n+     *         <p>\n+     *         The future will be succeeded if the entry was successfully removed.\n+     *         Otherwise the future will be failed with a {@link org.eclipse.hono.client.ServiceInvocationException}.\n+     * @throws NullPointerException if device id or adapter instance id is {@code null}.\n+     */\n+    Future<Void> removeCommandHandlingAdapterInstance(String deviceId, String adapterInstanceId, SpanContext context);\n+\n+    /**\n+     * Gets information about the adapter instances that can handle a command for the given device.\n+     * <p>\n+     * For a device that may communicate via a gateway, the list of all these gateways configured for the device\n+     * has to be given in the <em>viaGateways</em> parameter.\n+     * <p>\n+     * The resulting JSON object contains a list of entries associating device id and adapter instance id. This device\n+     * id may not necessarily be the <em>deviceId</em> given in the method parameter, it may be the ID of one of the\n+     * gateways acting on behalf of the device.\n+     * Example result JSON:\n+     * <pre>\n+     *  {\n+     *   \"adapter-instances\": [\n+     *     {\n+     *       \"adapter-instance-id\": \"adapter-1\",\n+     *       \"device-id\": \"4711\"\n+     *     }\n+     *   ]\n+     * }\n+     * </pre>\n+     * A JSON object with a single <em>adapter-instances</em> entry is returned if (in order of precedence)\n+     * <ol>\n+     *     <li>an adapter instance is registered for the given device</li>\n+     *     <li>or there is an adapter instance registered for the last known gateway associated with the given device.\n+     *     (That gateway also has to be contained in the given list of <em>viaGateways</em>.)</li>\n+     * </ol>\n+     * If both conditions are <i>not</i> met, all registered adapter instances for the given gateway ids (<em>viaGateways</em>)\n+     * are returned in the JSON object. Example:\n+     * <pre>\n+     *  {\n+     *   \"adapter-instances\": [\n+     *     {\n+     *       \"adapter-instance-id\": \"adapter-1\",\n+     *       \"device-id\": \"gw-1\"\n+     *     },\n+     *     {\n+     *       \"adapter-instance-id\": \"adapter-1\",\n+     *       \"device-id\": \"gw-2\"\n+     *     }\n+     *   ]\n+     * }\n+     * </pre>", "originalCommit": "50cee3621ab8b1f250bc76726113677d59dc6579", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDc5ODg3NA==", "url": "https://github.com/eclipse/hono/pull/1800#discussion_r390798874", "bodyText": "refer to API docs?", "author": "sophokles73", "createdAt": "2020-03-11T08:05:54Z", "path": "service-base/src/main/java/org/eclipse/hono/service/deviceconnection/DeviceConnectionService.java", "diffHunk": "@@ -70,4 +72,98 @@\n      * @throws NullPointerException if any of the parameters is {@code null}.\n      */\n     Future<DeviceConnectionResult> getLastKnownGatewayForDevice(String tenantId, String deviceId, Span span);\n+\n+    /**\n+     * Sets the protocol adapter instance that handles commands for the given device or gateway.\n+     *\n+     * @param tenantId The tenant id.\n+     * @param deviceId The device id.\n+     * @param adapterInstanceId The protocol adapter instance id.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be <em>204 No Content</em> if the operation completed successfully.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    Future<DeviceConnectionResult> setCommandHandlingAdapterInstance(String tenantId, String deviceId, String adapterInstanceId, Span span);\n+\n+    /**\n+     * Removes the mapping information that associates the given device with the given protocol adapter instance\n+     * that handles commands for the given device. The mapping entry is only deleted if its value\n+     * contains the given protocol adapter instance id.\n+     *\n+     * @param tenantId The tenant id.\n+     * @param deviceId The device id.\n+     * @param adapterInstanceId The protocol adapter instance id that the entry to be removed has to contain.\n+     * @param span The active OpenTracing span for this operation. It is not to be closed in this method! An\n+     *            implementation should log (error) events on this span and it may set tags and use this span as the\n+     *            parent for any spans created in this method.\n+     * @return A future indicating the outcome of the operation.\n+     *         The <em>status</em> will be <em>204 No Content</em> if the entry was successfully removed.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     */\n+    Future<DeviceConnectionResult> removeCommandHandlingAdapterInstance(String tenantId, String deviceId, String adapterInstanceId, Span span);\n+\n+    /**\n+     * Gets information about the adapter instances that can handle a command for the given device.\n+     * <p>\n+     * For a device that may communicate via a gateway, the list of all these gateways configured for the device\n+     * has to be given in the <em>viaGateways</em> parameter.\n+     * <p>\n+     * The resulting JSON object contains a list of entries associating device id and adapter instance id. This device\n+     * id may not necessarily be the <em>deviceId</em> given in the method parameter, it may be the ID of one of the\n+     * gateways acting on behalf of the device.\n+     * Example result JSON:\n+     * <pre>\n+     *  {\n+     *   \"adapter-instances\": [\n+     *     {\n+     *       \"adapter-instance-id\": \"adapter-1\",\n+     *       \"device-id\": \"4711\"\n+     *     }\n+     *   ]\n+     * }\n+     * </pre>\n+     * A JSON object with a single <em>adapter-instances</em> entry is returned if (in order of precedence)\n+     * <ol>\n+     *     <li>an adapter instance is registered for the given device</li>\n+     *     <li>or there is an adapter instance registered for the last known gateway associated with the given device.\n+     *     (That gateway also has to be contained in the given list of <em>viaGateways</em>.)</li>\n+     * </ol>\n+     * If both conditions are <i>not</i> met, all registered adapter instances for the given gateway ids (<em>viaGateways</em>)\n+     * are returned in the JSON object. Example:\n+     * <pre>\n+     *  {\n+     *   \"adapter-instances\": [\n+     *     {\n+     *       \"adapter-instance-id\": \"adapter-1\",\n+     *       \"device-id\": \"gw-1\"\n+     *     },\n+     *     {\n+     *       \"adapter-instance-id\": \"adapter-1\",\n+     *       \"device-id\": \"gw-2\"\n+     *     }\n+     *   ]\n+     * }\n+     * </pre>", "originalCommit": "50cee3621ab8b1f250bc76726113677d59dc6579", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgwNDgxNA==", "url": "https://github.com/eclipse/hono/pull/1800#discussion_r390804814", "bodyText": "IMHO this should simply be\nfinal JsonArray adapterInstancesArray = new JsonArray();", "author": "sophokles73", "createdAt": "2020-03-11T08:20:22Z", "path": "services/device-registry-base/src/main/java/org/eclipse/hono/deviceregistry/service/deviceconnection/MapBasedDeviceConnectionService.java", "diffHunk": "@@ -105,17 +111,151 @@ public MapBasedDeviceConnectionsConfigProperties getConfig() {\n         return Future.succeededFuture(result);\n     }\n \n+    @Override\n+    public Future<DeviceConnectionResult> setCommandHandlingAdapterInstance(final String tenantId, final String deviceId,\n+            final String protocolAdapterInstanceId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+        Objects.requireNonNull(protocolAdapterInstanceId);\n+\n+        final Map<String, JsonObject> adapterInstancesForTenantMap = commandHandlingAdapterInstancesMap.computeIfAbsent(tenantId,\n+                k -> new ConcurrentHashMap<>());\n+        final DeviceConnectionResult result;\n+        final int currentMapSize = adapterInstancesForTenantMap.size();\n+        if (currentMapSize < getConfig().getMaxDevicesPerTenant()\n+                || (currentMapSize == getConfig().getMaxDevicesPerTenant() && adapterInstancesForTenantMap.containsKey(deviceId))) {\n+            adapterInstancesForTenantMap.put(deviceId, createAdapterInstanceIdJson(protocolAdapterInstanceId));\n+            result = DeviceConnectionResult.from(HttpURLConnection.HTTP_NO_CONTENT);\n+        } else {\n+            log.debug(\"cannot set protocol adapter instance for handling commands of device [{}], tenant [{}]: max number of entries per tenant reached ({})\",\n+                    deviceId, tenantId, getConfig().getMaxDevicesPerTenant());\n+            result = DeviceConnectionResult.from(HttpURLConnection.HTTP_FORBIDDEN);\n+        }\n+        return Future.succeededFuture(result);\n+    }\n+\n+    @Override\n+    public Future<DeviceConnectionResult> removeCommandHandlingAdapterInstance(final String tenantId, final String deviceId,\n+            final String adapterInstanceId, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+        Objects.requireNonNull(adapterInstanceId);\n+\n+        final Map<String, JsonObject> adapterInstancesForTenantMap = commandHandlingAdapterInstancesMap.computeIfAbsent(tenantId,\n+                k -> new ConcurrentHashMap<>());\n+\n+        final JsonObject adapterInstanceIdJson = adapterInstancesForTenantMap.get(deviceId);\n+        final Future<DeviceConnectionResult> resultFuture;\n+        if (adapterInstanceIdJson != null) {\n+            // remove entry only if existing value contains matching adapterInstanceId\n+            final boolean removed = adapterInstanceId.equals(getAdapterInstanceIdFromJson(adapterInstanceIdJson))\n+                    && adapterInstancesForTenantMap.remove(deviceId, adapterInstanceIdJson);\n+            if (removed) {\n+                resultFuture = Future.succeededFuture(DeviceConnectionResult.from(HttpURLConnection.HTTP_NO_CONTENT));\n+            } else {\n+                log.debug(\"cannot remove command handling adapter instance for device [{}], tenant [{}] - given value does not match current\",\n+                        deviceId, tenantId);\n+                resultFuture = Future.succeededFuture(DeviceConnectionResult.from(HttpURLConnection.HTTP_PRECON_FAILED));\n+            }\n+        } else {\n+            resultFuture = Future.succeededFuture(DeviceConnectionResult.from(HttpURLConnection.HTTP_NOT_FOUND));\n+        }\n+        return resultFuture;\n+    }\n+\n+    @Override\n+    public Future<DeviceConnectionResult> getCommandHandlingAdapterInstances(final String tenantId,\n+            final String deviceId, final List<String> viaGateways, final Span span) {\n+        Objects.requireNonNull(tenantId);\n+        Objects.requireNonNull(deviceId);\n+\n+        final Map<String, JsonObject> commandHandlersForTenantMap = commandHandlingAdapterInstancesMap.get(tenantId);\n+        final DeviceConnectionResult result;\n+        if (commandHandlersForTenantMap != null) {\n+            // resultMap has device id as key and adapter instance id as value\n+            final Map<String, String> resultMap = new HashMap<>();\n+            final JsonObject deviceAdapterInstanceIdJson = commandHandlersForTenantMap.get(deviceId);\n+            if (deviceAdapterInstanceIdJson != null) {\n+                // found mapping for given device id\n+                resultMap.put(deviceId, getAdapterInstanceIdFromJson(deviceAdapterInstanceIdJson));\n+            } else if (!viaGateways.isEmpty()) {\n+                // no mapping found for given device; check last known gateway of device\n+                final Map<String, JsonObject> lastKnownGatewaysForTenantMap = lastKnownGatewaysMap.get(tenantId);\n+                if (lastKnownGatewaysForTenantMap != null) {\n+                    final JsonObject lastKnownGatewayJson = lastKnownGatewaysForTenantMap.get(deviceId);\n+                    if (lastKnownGatewayJson != null) {\n+                        final String gatewayId = getGatewayIdFromLastKnownGatewayJson(lastKnownGatewayJson);\n+                        if (viaGateways.contains(gatewayId)) {\n+                            // get command handler for found gateway device\n+                            final JsonObject gwAdapterInstanceIdJson = commandHandlersForTenantMap.get(gatewayId);\n+                            if (gwAdapterInstanceIdJson != null) {\n+                                resultMap.put(gatewayId, getAdapterInstanceIdFromJson(gwAdapterInstanceIdJson));\n+                            }\n+                        } else {\n+                            log.trace(\"ignoring found last known gateway [{}]; gateway is not in given via list\", gatewayId);\n+                        }\n+                    }\n+                }\n+            }\n+            if (resultMap.isEmpty() && !viaGateways.isEmpty()) {\n+                log.trace(\"no command handling adapter instance found for given device or last known gateway; getting instances for all via gateways\");\n+                for (final String viaGateway : viaGateways) {\n+                    final JsonObject gwAdapterInstanceIdJson = commandHandlersForTenantMap.get(viaGateway);\n+                    if (gwAdapterInstanceIdJson != null) {\n+                        resultMap.put(viaGateway, getAdapterInstanceIdFromJson(gwAdapterInstanceIdJson));\n+                    }\n+                }\n+            }\n+            if (!resultMap.isEmpty()) {\n+                result = DeviceConnectionResult.from(HttpURLConnection.HTTP_OK, getResultJson(resultMap));\n+            } else {\n+                result = DeviceConnectionResult.from(HttpURLConnection.HTTP_NOT_FOUND);\n+            }\n+        } else {\n+            result = DeviceConnectionResult.from(HttpURLConnection.HTTP_NOT_FOUND);\n+        }\n+        return Future.succeededFuture(result);\n+    }\n+\n+    private JsonObject getResultJson(final Map<String, String> deviceToAdapterInstanceMap) {\n+        final JsonObject jsonObject = new JsonObject();\n+        final JsonArray adapterInstancesArray = new JsonArray(new ArrayList<>(deviceToAdapterInstanceMap.size()));", "originalCommit": "50cee3621ab8b1f250bc76726113677d59dc6579", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgxNzY0OA==", "url": "https://github.com/eclipse/hono/pull/1800#discussion_r390817648", "bodyText": "Since the array size is fixed here, I want to initialize the JsonArray with that size like that (for lack of a corresponding JsonArray constructor).", "author": "calohmn", "createdAt": "2020-03-11T08:46:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgwNDgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDgwNzQ3Ng==", "url": "https://github.com/eclipse/hono/pull/1800#discussion_r390807476", "bodyText": "this seems to be repeated over and over again, maybe you can extract it into a helper method?", "author": "sophokles73", "createdAt": "2020-03-11T08:26:00Z", "path": "client/src/test/java/org/eclipse/hono/client/impl/DeviceConnectionClientImplTest.java", "diffHunk": "@@ -136,9 +143,73 @@ public void testSetLastKnownGatewayForDeviceSuccess(final VertxTestContext ctx)\n         // WHEN setting the last known gateway\n         client.setLastKnownGatewayForDevice(\"deviceId\", \"gatewayId\", span.context())\n                 .setHandler(ctx.succeeding(r -> {\n-                    // THEN the response for setting the last known gateway has been handled by the service\n-                    // and the span is finished\n-                    verify(span).finish();\n+                    ctx.verify(() -> {\n+                        // THEN the response for setting the last known gateway has been handled by the service\n+                        // and the span is finished\n+                        verify(span).finish();\n+                    });\n+                    ctx.completeNow();\n+                }));\n+\n+        final ArgumentCaptor<Message> messageCaptor = ArgumentCaptor.forClass(Message.class);\n+        verify(sender).send(messageCaptor.capture(), any(Handler.class));\n+        final Message response = ProtonHelper.message();\n+        MessageHelper.addProperty(response, MessageHelper.APP_PROPERTY_STATUS, HttpURLConnection.HTTP_NO_CONTENT);\n+        MessageHelper.addCacheDirective(response, CacheDirective.maxAgeDirective(60));\n+        response.setCorrelationId(messageCaptor.getValue().getMessageId());\n+        final ProtonDelivery delivery = mock(ProtonDelivery.class);\n+        client.handleResponse(delivery, response);", "originalCommit": "50cee3621ab8b1f250bc76726113677d59dc6579", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5530b64b8e047e83b1caf15a595b2928c5a5c19e", "url": "https://github.com/eclipse/hono/commit/5530b64b8e047e83b1caf15a595b2928c5a5c19e", "message": "[#1272] Add new Device Connection API methods.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>", "committedDate": "2020-03-11T09:25:54Z", "type": "commit"}, {"oid": "5530b64b8e047e83b1caf15a595b2928c5a5c19e", "url": "https://github.com/eclipse/hono/commit/5530b64b8e047e83b1caf15a595b2928c5a5c19e", "message": "[#1272] Add new Device Connection API methods.\n\nSigned-off-by: Carsten Lohmann <carsten.lohmann@bosch.io>", "committedDate": "2020-03-11T09:25:54Z", "type": "forcePushed"}]}