{"pr_number": 2158, "pr_title": "Refactor JDBC storage layer, add tenant store", "pr_createdAt": "2020-09-07T07:20:01Z", "pr_url": "https://github.com/eclipse/hono/pull/2158", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1NDM4NA==", "url": "https://github.com/eclipse/hono/pull/2158#discussion_r485054384", "bodyText": "Could you have a look at the comment in the old PR (#2118 (comment)) and elaborate a bit on the internal tenant id you mentioned?\nDo you mean the TenantKey#name value (javadoc: \"tenant name in an external system\")?\nTo me, the resolveGroupMembers method above doesn't seem to be invoked in a way that such a name/identifier is used for the first parameter here, though.", "author": "calohmn", "createdAt": "2020-09-08T16:37:04Z", "path": "services/base-jdbc/src/main/java/org/eclipse/hono/service/base/jdbc/store/device/TableAdapterStore.java", "diffHunk": "@@ -114,4 +195,52 @@ public TableAdapterStore(final SQLClient client, final Tracer tracer, final Stat\n \n     }\n \n+    /**\n+     * Resolve a list of group members.\n+     *\n+     * @param tenantId The tenant the device belongs to.\n+     * @param viaGroups The viaGroups list of a device. This list contains the ids of groups.\n+     * @param spanContext The span to contribute to.\n+     *\n+     * @return A future tracking the outcome of the operation.\n+     *\n+     * @see org.eclipse.hono.deviceregistry.service.device.AbstractRegistrationService#resolveGroupMembers(String, JsonArray, Span)\n+     */\n+    public Future<Set<String>> resolveGroupMembers(final String tenantId, final Set<String> viaGroups, final SpanContext spanContext) {\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"resolve group members\", getClass().getSimpleName())\n+                .withTag(\"tenant_instance_id\", tenantId)", "originalCommit": "8a66252d1e36188aa2df0242eaba1326032276bb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjgyNjU0MQ==", "url": "https://github.com/eclipse/hono/pull/2158#discussion_r486826541", "bodyText": "Taking a closer look at the code, I think we have a problem here with the way this was migrated from EnMasse.\nThe \"name\" used to be the user facing name, where \"id\" is the internal ID, e.g. in the database. The tenant information service can (if implemented that way) translate from the external name to the internal name.\nThe JDBC device registry must only use the internal name.\nSo the resolveGroupMembers method, should either receive the internal ID (which is the current code), receive a TenantKey and use the internal ID, or do the lookup (via the tenant information service) itself.\nI think it would be ok to ignore this for the moment, and simply use the \"ID\" as \"tenant_id\". And sort that out later.", "author": "ctron", "createdAt": "2020-09-11T07:28:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTA1NDM4NA=="}], "type": "inlineReview"}, {"oid": "42aec07433390d0d0f9a65583145887b50b32548", "url": "https://github.com/eclipse/hono/commit/42aec07433390d0d0f9a65583145887b50b32548", "message": "Refactor JDBC storage layer, add tenant store", "committedDate": "2020-09-11T07:20:57Z", "type": "forcePushed"}, {"oid": "ca8947efead5c0f96dca3103075276886180786d", "url": "https://github.com/eclipse/hono/commit/ca8947efead5c0f96dca3103075276886180786d", "message": "Refactor JDBC storage layer, add tenant store", "committedDate": "2020-09-11T07:30:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYwNDY0OA==", "url": "https://github.com/eclipse/hono/pull/2158#discussion_r488604648", "bodyText": "please use the Tags defined in org.eclipse.hono.util.tracing.TracingHelper instead of using literal strings here", "author": "sophokles73", "createdAt": "2020-09-15T11:51:46Z", "path": "services/base-jdbc/src/main/java/org/eclipse/hono/service/base/jdbc/store/devcon/Store.java", "diffHunk": "@@ -118,7 +118,7 @@ public static StatementConfiguration defaultStatementConfiguration(final String\n     public Future<Optional<DeviceState>> readDeviceState(final DeviceConnectionKey key, final SpanContext spanContext) {\n \n         final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"read device state\", getClass().getSimpleName())\n-                .withTag(\"tenant_instance_id\", key.getTenantId())\n+                .withTag(\"tenant_id\", key.getTenantId())", "originalCommit": "ca8947efead5c0f96dca3103075276886180786d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYwNDc2NA==", "url": "https://github.com/eclipse/hono/pull/2158#discussion_r488604764", "bodyText": "please use the Tags defined in org.eclipse.hono.util.tracing.TracingHelper instead of using literal strings here", "author": "sophokles73", "createdAt": "2020-09-15T11:51:59Z", "path": "services/base-jdbc/src/main/java/org/eclipse/hono/service/base/jdbc/store/devcon/Store.java", "diffHunk": "@@ -167,7 +167,7 @@ public static StatementConfiguration defaultStatementConfiguration(final String\n     public Future<UpdateResult> setLastKnownGateway(final DeviceConnectionKey key, final String gatewayId, final SpanContext spanContext) {\n \n         final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"update device state\", getClass().getSimpleName())\n-                .withTag(\"tenant_instance_id\", key.getTenantId())\n+                .withTag(\"tenant_id\", key.getTenantId())", "originalCommit": "ca8947efead5c0f96dca3103075276886180786d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYwNDgwNQ==", "url": "https://github.com/eclipse/hono/pull/2158#discussion_r488604805", "bodyText": "please use the Tags defined in org.eclipse.hono.util.tracing.TracingHelper instead of using literal strings here", "author": "sophokles73", "createdAt": "2020-09-15T11:52:05Z", "path": "services/base-jdbc/src/main/java/org/eclipse/hono/service/base/jdbc/store/devcon/Store.java", "diffHunk": "@@ -196,15 +196,15 @@ public static StatementConfiguration defaultStatementConfiguration(final String\n     public Future<UpdateResult> dropTenant(final String tenantId, final SpanContext spanContext) {\n \n         final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"drop tenant\", getClass().getSimpleName())\n-                .withTag(\"tenant_instance_id\", tenantId)\n+                .withTag(\"tenant_id\", tenantId)", "originalCommit": "ca8947efead5c0f96dca3103075276886180786d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYwODUyOQ==", "url": "https://github.com/eclipse/hono/pull/2158#discussion_r488608529", "bodyText": "please use Tags from TracingHelper", "author": "sophokles73", "createdAt": "2020-09-15T11:58:35Z", "path": "services/base-jdbc/src/main/java/org/eclipse/hono/service/base/jdbc/store/device/TableAdapterStore.java", "diffHunk": "@@ -61,15 +67,88 @@ public TableAdapterStore(final SQLClient client, final Tracer tracer, final Stat\n                         \"type\",\n                         \"auth_id\");\n \n+        this.resolveGroupsStatement = cfg\n+                .getRequiredStatement(\"resolveGroups\")\n+                .validateParameters(\n+                        \"tenant_id\",\n+                        \"group_ids\");\n+\n+    }\n+\n+\n+    /**\n+     * Read a device using {@link #readDevice(io.vertx.ext.sql.SQLOperations, DeviceKey, Span)} and the\n+     * current SQL client.\n+     *\n+     * @param key The key of the device to read.\n+     * @param span The span to contribute to.\n+     *\n+     * @return The result from {@link #readDevice(io.vertx.ext.sql.SQLOperations, DeviceKey, Span)}.\n+     */\n+    protected Future<ResultSet> readDevice(final DeviceKey key, final Span span) {\n+        return readDevice(this.client, key, span);\n+    }\n+\n+    /**\n+     * Reads the device data.\n+     * <p>\n+     * This reads the device data using\n+     * {@link #readDevice(io.vertx.ext.sql.SQLOperations, DeviceKey, Span)} and\n+     * transforms the plain result into a {@link DeviceReadResult}.\n+     * <p>\n+     * If now rows where found, the result will be empty. If more than one row is found,\n+     * the result will be failed with an {@link IllegalStateException}.\n+     * <p>\n+     * If there is exactly one row, it will read the device registration information from the column\n+     * {@code data} and optionally current resource version from the column {@code version}.\n+     *\n+     * @param key The key of the device to read.\n+     * @param spanContext The span to contribute to.\n+     *\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<Optional<DeviceReadResult>> readDevice(final DeviceKey key, final SpanContext spanContext) {\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"read device\", getClass().getSimpleName())\n+                .withTag(\"tenant_id\", key.getTenantId())", "originalCommit": "ca8947efead5c0f96dca3103075276886180786d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYwODYzOQ==", "url": "https://github.com/eclipse/hono/pull/2158#discussion_r488608639", "bodyText": "please use Tags from TracingHelper", "author": "sophokles73", "createdAt": "2020-09-15T11:58:47Z", "path": "services/base-jdbc/src/main/java/org/eclipse/hono/service/base/jdbc/store/device/TableAdapterStore.java", "diffHunk": "@@ -114,4 +195,52 @@ public TableAdapterStore(final SQLClient client, final Tracer tracer, final Stat\n \n     }\n \n+    /**\n+     * Resolve a list of group members.\n+     *\n+     * @param tenantId The tenant the device belongs to.\n+     * @param viaGroups The viaGroups list of a device. This list contains the ids of groups.\n+     * @param spanContext The span to contribute to.\n+     *\n+     * @return A future tracking the outcome of the operation.\n+     *\n+     * @see org.eclipse.hono.deviceregistry.service.device.AbstractRegistrationService#resolveGroupMembers(String, JsonArray, Span)\n+     */\n+    public Future<Set<String>> resolveGroupMembers(final String tenantId, final Set<String> viaGroups, final SpanContext spanContext) {\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"resolve group members\", getClass().getSimpleName())\n+                .withTag(\"tenant_id\", tenantId)", "originalCommit": "ca8947efead5c0f96dca3103075276886180786d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYwOTEzMA==", "url": "https://github.com/eclipse/hono/pull/2158#discussion_r488609130", "bodyText": "please use Tags from TracingHelper", "author": "sophokles73", "createdAt": "2020-09-15T11:59:38Z", "path": "services/base-jdbc/src/main/java/org/eclipse/hono/service/base/jdbc/store/device/TableManagementStore.java", "diffHunk": "@@ -122,67 +183,414 @@ public TableManagementStore(final SQLClient client, final Tracer tracer, final S\n      *\n      * @param connection The connection to use.\n      * @param key The key of the device.\n-     * @param resourceVersion An optional resource version.\n      * @param span The span to contribute to.\n-     *\n      * @return A future tracking the outcome of the operation.\n      */\n-    protected Future<ResultSet> readDeviceForUpdate(final SQLConnection connection, final DeviceKey key, final Optional<String> resourceVersion, final Span span) {\n+    protected Future<ResultSet> readDeviceForUpdate(final SQLConnection connection, final DeviceKey key, final SpanContext span) {\n+        return read(connection, key, Optional.empty(), this.readForUpdateStatement, span);\n+    }\n+\n+    /**\n+     * Create a new device.\n+     * <p>\n+     * This method executes the {@code create} statement, providing the named parameters\n+     * {@code tenant_id}, {@code device_id}, {@code version}, and {@code data}.\n+     * <p>\n+     * It returns the plain update result. In case a device with the same ID already\n+     * exists, the underlying database must throw an {@link SQLException}, indicating\n+     * a duplicate entity or constraint violation. This will be translated into a\n+     * failed future with an {@link DuplicateKeyException}.\n+     *\n+     * @param key The key of the device to create.\n+     * @param device The device data.\n+     * @param spanContext The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<Versioned<Void>> createDevice(final DeviceKey key, final Device device, final SpanContext spanContext) {\n+\n+        final String json = Json.encode(device);\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"create device\", getClass().getSimpleName())\n+                .withTag(\"tenant_id\", key.getTenantId())", "originalCommit": "ca8947efead5c0f96dca3103075276886180786d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYwOTI2Mw==", "url": "https://github.com/eclipse/hono/pull/2158#discussion_r488609263", "bodyText": "please use Tags from TracingHelper", "author": "sophokles73", "createdAt": "2020-09-15T11:59:51Z", "path": "services/base-jdbc/src/main/java/org/eclipse/hono/service/base/jdbc/store/device/TableManagementStore.java", "diffHunk": "@@ -122,67 +183,414 @@ public TableManagementStore(final SQLClient client, final Tracer tracer, final S\n      *\n      * @param connection The connection to use.\n      * @param key The key of the device.\n-     * @param resourceVersion An optional resource version.\n      * @param span The span to contribute to.\n-     *\n      * @return A future tracking the outcome of the operation.\n      */\n-    protected Future<ResultSet> readDeviceForUpdate(final SQLConnection connection, final DeviceKey key, final Optional<String> resourceVersion, final Span span) {\n+    protected Future<ResultSet> readDeviceForUpdate(final SQLConnection connection, final DeviceKey key, final SpanContext span) {\n+        return read(connection, key, Optional.empty(), this.readForUpdateStatement, span);\n+    }\n+\n+    /**\n+     * Create a new device.\n+     * <p>\n+     * This method executes the {@code create} statement, providing the named parameters\n+     * {@code tenant_id}, {@code device_id}, {@code version}, and {@code data}.\n+     * <p>\n+     * It returns the plain update result. In case a device with the same ID already\n+     * exists, the underlying database must throw an {@link SQLException}, indicating\n+     * a duplicate entity or constraint violation. This will be translated into a\n+     * failed future with an {@link DuplicateKeyException}.\n+     *\n+     * @param key The key of the device to create.\n+     * @param device The device data.\n+     * @param spanContext The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<Versioned<Void>> createDevice(final DeviceKey key, final Device device, final SpanContext spanContext) {\n+\n+        final String json = Json.encode(device);\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"create device\", getClass().getSimpleName())\n+                .withTag(\"tenant_id\", key.getTenantId())\n+                .withTag(\"device_id\", key.getDeviceId())\n+                .withTag(\"data\", json)\n+                .start();\n+\n+        final var version = UUID.randomUUID().toString();\n+\n+        return SQL\n+\n+                .runTransactionally(this.client, this.tracer, span.context(), (connection, context) -> {\n+\n+                    final var expanded = this.createStatement.expand(params -> {\n+                        params.put(\"tenant_id\", key.getTenantId());\n+                        params.put(\"device_id\", key.getDeviceId());\n+                        params.put(\"version\", version);\n+                        params.put(\"data\", json);\n+                    });\n+\n+                    log.debug(\"createDevice - statement: {}\", expanded);\n+\n+                    return expanded\n+\n+                            .trace(this.tracer, context)\n+                            .update(this.client)\n+                            .recover(SQL::translateException)\n+\n+                            .flatMap(x -> createGroups(connection, key, new HashSet<>(device.getMemberOf()), context));\n+\n+                })\n+\n+                .map(new Versioned<Void>(version, null))\n+                .onComplete(x -> span.finish());\n+\n+    }\n+\n+    private Future<?> createGroups(\n+            final SQLConnection connection,\n+            final DeviceKey key,\n+            final Set<String> memberOf,\n+            final SpanContext context) {\n+\n+        return CompositeFuture.all(memberOf.stream()\n+                .map(groupId -> {\n+\n+                    final var expanded = this.createMemberOfStatement.expand(params -> {\n+                        params.put(\"tenant_id\", key.getTenantId());\n+                        params.put(\"device_id\", key.getDeviceId());\n+                        params.put(\"group_id\", groupId);\n+                    });\n+\n+                    log.debug(\"addToGroup - statement: {}\", expanded);\n+\n+                    return expanded\n+                            .trace(this.tracer, context)\n+                            .update(connection)\n+                            .recover(SQL::translateException);\n+                })\n+                .collect(Collectors.toList()));\n+\n+    }\n+\n+    private Future<?> deleteGroups(final SQLConnection connection,\n+                                   final DeviceKey key,\n+                                   final SpanContext context) {\n+\n+        final var expanded = this.deleteAllMemberOfStatement.expand(params -> {\n+            params.put(\"tenant_id\", key.getTenantId());\n+            params.put(\"device_id\", key.getDeviceId());\n+        });\n+\n+        log.debug(\"deleteGroups - statement: {}\", expanded);\n+\n+        return expanded\n+                .trace(this.tracer, context)\n+                .update(connection)\n+                .recover(SQL::translateException);\n+\n+    }\n+\n+    /**\n+     * Update a field of device information entry.\n+     * <p>\n+     * The method executes the provided statement, setting the named parameters\n+     * {@code tenant_id}, {@code device_id}, {@code next_version} and {@code data}.\n+     * Additionally it will provide the named parameter {@code expected_version}, if\n+     * resource version is not empty.\n+     * <p>\n+     * The update must only be performed if the resource version is either empty\n+     * or matches the current version.\n+     * <p>\n+     * It returns the plain update result, which includes the number of rows changes.\n+     * This is one, if the device was updated. It may also be zero, if the device does\n+     * not exists. If the device exists, but the resource version does not match, the result\n+     * will fail with an {@link OptimisticLockingException}.\n+     *\n+     * @param key The key of the device to update.\n+     * @param statement The statement to use for the update.\n+     * @param jsonValue The value to set.\n+     * @param resourceVersion The optional resource version.\n+     * @param nextVersion The new version to set.\n+     * @param span The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    protected Future<UpdateResult> updateJsonField(final DeviceKey key, final Statement statement, final String jsonValue, final Optional<String> resourceVersion,\n+                                                   final String nextVersion, final Span span) {\n+\n+        final var expanded = statement.expand(map -> {\n+            map.put(\"tenant_id\", key.getTenantId());\n+            map.put(\"device_id\", key.getDeviceId());\n+            map.put(\"next_version\", nextVersion);\n+            map.put(\"data\", jsonValue);\n+            resourceVersion.ifPresent(version -> map.put(\"expected_version\", version));\n+        });\n+\n+        log.debug(\"update - statement: {}\", expanded);\n+\n+        // execute update\n+        final var result = expanded\n+                .trace(this.tracer, span.context())\n+                .update(this.client);\n+\n+        // process result, check optimistic lock\n+        return checkOptimisticLock(\n+                result, span,\n+                resourceVersion,\n+                checkSpan -> readDevice(this.client, key, checkSpan));\n+\n+    }\n+\n+    /**\n+     * Update device registration information.\n+     * <p>\n+     * This called the {@link #updateJsonField(DeviceKey, Statement, String, Optional, String, Span)} method\n+     * with either the {@code updateRegistration} or {@code updateRegistrationVersioned}\n+     * statement.\n+     *\n+     * @param key The key of the device to update.\n+     * @param device The device data to store.\n+     * @param resourceVersion The optional resource version.\n+     * @param spanContext The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<Versioned<Void>> updateDevice(final DeviceKey key, final Device device, final Optional<String> resourceVersion, final SpanContext spanContext) {\n+\n+        final String json = Json.encode(device);\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"update device\", getClass().getSimpleName())\n+                .withTag(\"tenant_id\", key.getTenantId())", "originalCommit": "ca8947efead5c0f96dca3103075276886180786d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYwOTM1Ng==", "url": "https://github.com/eclipse/hono/pull/2158#discussion_r488609356", "bodyText": "please use Tags from TracingHelper", "author": "sophokles73", "createdAt": "2020-09-15T12:00:02Z", "path": "services/base-jdbc/src/main/java/org/eclipse/hono/service/base/jdbc/store/device/TableManagementStore.java", "diffHunk": "@@ -122,67 +183,414 @@ public TableManagementStore(final SQLClient client, final Tracer tracer, final S\n      *\n      * @param connection The connection to use.\n      * @param key The key of the device.\n-     * @param resourceVersion An optional resource version.\n      * @param span The span to contribute to.\n-     *\n      * @return A future tracking the outcome of the operation.\n      */\n-    protected Future<ResultSet> readDeviceForUpdate(final SQLConnection connection, final DeviceKey key, final Optional<String> resourceVersion, final Span span) {\n+    protected Future<ResultSet> readDeviceForUpdate(final SQLConnection connection, final DeviceKey key, final SpanContext span) {\n+        return read(connection, key, Optional.empty(), this.readForUpdateStatement, span);\n+    }\n+\n+    /**\n+     * Create a new device.\n+     * <p>\n+     * This method executes the {@code create} statement, providing the named parameters\n+     * {@code tenant_id}, {@code device_id}, {@code version}, and {@code data}.\n+     * <p>\n+     * It returns the plain update result. In case a device with the same ID already\n+     * exists, the underlying database must throw an {@link SQLException}, indicating\n+     * a duplicate entity or constraint violation. This will be translated into a\n+     * failed future with an {@link DuplicateKeyException}.\n+     *\n+     * @param key The key of the device to create.\n+     * @param device The device data.\n+     * @param spanContext The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<Versioned<Void>> createDevice(final DeviceKey key, final Device device, final SpanContext spanContext) {\n+\n+        final String json = Json.encode(device);\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"create device\", getClass().getSimpleName())\n+                .withTag(\"tenant_id\", key.getTenantId())\n+                .withTag(\"device_id\", key.getDeviceId())\n+                .withTag(\"data\", json)\n+                .start();\n+\n+        final var version = UUID.randomUUID().toString();\n+\n+        return SQL\n+\n+                .runTransactionally(this.client, this.tracer, span.context(), (connection, context) -> {\n+\n+                    final var expanded = this.createStatement.expand(params -> {\n+                        params.put(\"tenant_id\", key.getTenantId());\n+                        params.put(\"device_id\", key.getDeviceId());\n+                        params.put(\"version\", version);\n+                        params.put(\"data\", json);\n+                    });\n+\n+                    log.debug(\"createDevice - statement: {}\", expanded);\n+\n+                    return expanded\n+\n+                            .trace(this.tracer, context)\n+                            .update(this.client)\n+                            .recover(SQL::translateException)\n+\n+                            .flatMap(x -> createGroups(connection, key, new HashSet<>(device.getMemberOf()), context));\n+\n+                })\n+\n+                .map(new Versioned<Void>(version, null))\n+                .onComplete(x -> span.finish());\n+\n+    }\n+\n+    private Future<?> createGroups(\n+            final SQLConnection connection,\n+            final DeviceKey key,\n+            final Set<String> memberOf,\n+            final SpanContext context) {\n+\n+        return CompositeFuture.all(memberOf.stream()\n+                .map(groupId -> {\n+\n+                    final var expanded = this.createMemberOfStatement.expand(params -> {\n+                        params.put(\"tenant_id\", key.getTenantId());\n+                        params.put(\"device_id\", key.getDeviceId());\n+                        params.put(\"group_id\", groupId);\n+                    });\n+\n+                    log.debug(\"addToGroup - statement: {}\", expanded);\n+\n+                    return expanded\n+                            .trace(this.tracer, context)\n+                            .update(connection)\n+                            .recover(SQL::translateException);\n+                })\n+                .collect(Collectors.toList()));\n+\n+    }\n+\n+    private Future<?> deleteGroups(final SQLConnection connection,\n+                                   final DeviceKey key,\n+                                   final SpanContext context) {\n+\n+        final var expanded = this.deleteAllMemberOfStatement.expand(params -> {\n+            params.put(\"tenant_id\", key.getTenantId());\n+            params.put(\"device_id\", key.getDeviceId());\n+        });\n+\n+        log.debug(\"deleteGroups - statement: {}\", expanded);\n+\n+        return expanded\n+                .trace(this.tracer, context)\n+                .update(connection)\n+                .recover(SQL::translateException);\n+\n+    }\n+\n+    /**\n+     * Update a field of device information entry.\n+     * <p>\n+     * The method executes the provided statement, setting the named parameters\n+     * {@code tenant_id}, {@code device_id}, {@code next_version} and {@code data}.\n+     * Additionally it will provide the named parameter {@code expected_version}, if\n+     * resource version is not empty.\n+     * <p>\n+     * The update must only be performed if the resource version is either empty\n+     * or matches the current version.\n+     * <p>\n+     * It returns the plain update result, which includes the number of rows changes.\n+     * This is one, if the device was updated. It may also be zero, if the device does\n+     * not exists. If the device exists, but the resource version does not match, the result\n+     * will fail with an {@link OptimisticLockingException}.\n+     *\n+     * @param key The key of the device to update.\n+     * @param statement The statement to use for the update.\n+     * @param jsonValue The value to set.\n+     * @param resourceVersion The optional resource version.\n+     * @param nextVersion The new version to set.\n+     * @param span The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    protected Future<UpdateResult> updateJsonField(final DeviceKey key, final Statement statement, final String jsonValue, final Optional<String> resourceVersion,\n+                                                   final String nextVersion, final Span span) {\n+\n+        final var expanded = statement.expand(map -> {\n+            map.put(\"tenant_id\", key.getTenantId());\n+            map.put(\"device_id\", key.getDeviceId());\n+            map.put(\"next_version\", nextVersion);\n+            map.put(\"data\", jsonValue);\n+            resourceVersion.ifPresent(version -> map.put(\"expected_version\", version));\n+        });\n+\n+        log.debug(\"update - statement: {}\", expanded);\n+\n+        // execute update\n+        final var result = expanded\n+                .trace(this.tracer, span.context())\n+                .update(this.client);\n+\n+        // process result, check optimistic lock\n+        return checkOptimisticLock(\n+                result, span,\n+                resourceVersion,\n+                checkSpan -> readDevice(this.client, key, checkSpan));\n+\n+    }\n+\n+    /**\n+     * Update device registration information.\n+     * <p>\n+     * This called the {@link #updateJsonField(DeviceKey, Statement, String, Optional, String, Span)} method\n+     * with either the {@code updateRegistration} or {@code updateRegistrationVersioned}\n+     * statement.\n+     *\n+     * @param key The key of the device to update.\n+     * @param device The device data to store.\n+     * @param resourceVersion The optional resource version.\n+     * @param spanContext The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<Versioned<Void>> updateDevice(final DeviceKey key, final Device device, final Optional<String> resourceVersion, final SpanContext spanContext) {\n+\n+        final String json = Json.encode(device);\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"update device\", getClass().getSimpleName())\n+                .withTag(\"tenant_id\", key.getTenantId())\n+                .withTag(\"device_id\", key.getDeviceId())\n+                .withTag(\"data\", json)\n+                .start();\n+\n+        final var nextVersion = UUID.randomUUID().toString();\n+        resourceVersion.ifPresent(version -> span.setTag(\"version\", version));\n+\n+        final var memberOf = Optional.ofNullable(device.getMemberOf())\n+                .<Set<String>>map(HashSet::new)\n+                .orElse(Collections.emptySet());\n+\n+        return SQL\n+                .runTransactionally(this.client, this.tracer, span.context(), (connection, context) ->\n+\n+                        readDeviceForUpdate(connection, key, context)\n+\n+                                // check if we got back a result, if not this will abort early\n+                                .flatMap(result -> extractVersionForUpdate(result, resourceVersion))\n+\n+                                // take the version and start processing on\n+                                .flatMap(version -> deleteGroups(connection, key, context)\n+                                        .map(version))\n+\n+                                .flatMap(version -> createGroups(connection, key, memberOf, context)\n+                                        .map(version))\n+\n+                                // update the version, this will release the lock\n+                                .flatMap(version -> this.updateRegistrationVersionedStatement\n+                                        .expand(map -> {\n+                                            map.put(\"tenant_id\", key.getTenantId());\n+                                            map.put(\"device_id\", key.getDeviceId());\n+                                            map.put(\"data\", json);\n+                                            map.put(\"expected_version\", version);\n+                                            map.put(\"next_version\", nextVersion);\n+                                        })\n+                                        .trace(this.tracer, span.context()).update(connection)\n+\n+                                        // check the update outcome\n+                                        .flatMap(TableManagementStore::checkUpdateOutcome)\n+                                        .map(version)\n+                                )\n+\n+\n+                )\n+\n+                .map(x -> new Versioned<Void>(nextVersion, null))\n+                .onComplete(x -> span.finish());\n+\n+    }\n+\n+    /**\n+     * Reads the device data.\n+     * <p>\n+     * This reads the device data using\n+     * {@link #readDevice(io.vertx.ext.sql.SQLOperations, DeviceKey, Span)} and\n+     * transforms the plain result into a {@link DeviceReadResult}.\n+     * <p>\n+     * If now rows where found, the result will be empty. If more than one row is found,\n+     * the result will be failed with an {@link IllegalStateException}.\n+     * <p>\n+     * If there is exactly one row, it will read the device registration information from the column\n+     * {@code data} and optionally current resource version from the column {@code version}.\n+     *\n+     * @param key The key of the device to read.\n+     * @param spanContext The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<Optional<DeviceReadResult>> readDevice(final DeviceKey key, final SpanContext spanContext) {\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"read device\", getClass().getSimpleName())\n+                .withTag(\"tenant_id\", key.getTenantId())", "originalCommit": "ca8947efead5c0f96dca3103075276886180786d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYwOTQzNg==", "url": "https://github.com/eclipse/hono/pull/2158#discussion_r488609436", "bodyText": "please use Tags from TracingHelper", "author": "sophokles73", "createdAt": "2020-09-15T12:00:11Z", "path": "services/base-jdbc/src/main/java/org/eclipse/hono/service/base/jdbc/store/device/TableManagementStore.java", "diffHunk": "@@ -122,67 +183,414 @@ public TableManagementStore(final SQLClient client, final Tracer tracer, final S\n      *\n      * @param connection The connection to use.\n      * @param key The key of the device.\n-     * @param resourceVersion An optional resource version.\n      * @param span The span to contribute to.\n-     *\n      * @return A future tracking the outcome of the operation.\n      */\n-    protected Future<ResultSet> readDeviceForUpdate(final SQLConnection connection, final DeviceKey key, final Optional<String> resourceVersion, final Span span) {\n+    protected Future<ResultSet> readDeviceForUpdate(final SQLConnection connection, final DeviceKey key, final SpanContext span) {\n+        return read(connection, key, Optional.empty(), this.readForUpdateStatement, span);\n+    }\n+\n+    /**\n+     * Create a new device.\n+     * <p>\n+     * This method executes the {@code create} statement, providing the named parameters\n+     * {@code tenant_id}, {@code device_id}, {@code version}, and {@code data}.\n+     * <p>\n+     * It returns the plain update result. In case a device with the same ID already\n+     * exists, the underlying database must throw an {@link SQLException}, indicating\n+     * a duplicate entity or constraint violation. This will be translated into a\n+     * failed future with an {@link DuplicateKeyException}.\n+     *\n+     * @param key The key of the device to create.\n+     * @param device The device data.\n+     * @param spanContext The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<Versioned<Void>> createDevice(final DeviceKey key, final Device device, final SpanContext spanContext) {\n+\n+        final String json = Json.encode(device);\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"create device\", getClass().getSimpleName())\n+                .withTag(\"tenant_id\", key.getTenantId())\n+                .withTag(\"device_id\", key.getDeviceId())\n+                .withTag(\"data\", json)\n+                .start();\n+\n+        final var version = UUID.randomUUID().toString();\n+\n+        return SQL\n+\n+                .runTransactionally(this.client, this.tracer, span.context(), (connection, context) -> {\n+\n+                    final var expanded = this.createStatement.expand(params -> {\n+                        params.put(\"tenant_id\", key.getTenantId());\n+                        params.put(\"device_id\", key.getDeviceId());\n+                        params.put(\"version\", version);\n+                        params.put(\"data\", json);\n+                    });\n+\n+                    log.debug(\"createDevice - statement: {}\", expanded);\n+\n+                    return expanded\n+\n+                            .trace(this.tracer, context)\n+                            .update(this.client)\n+                            .recover(SQL::translateException)\n+\n+                            .flatMap(x -> createGroups(connection, key, new HashSet<>(device.getMemberOf()), context));\n+\n+                })\n+\n+                .map(new Versioned<Void>(version, null))\n+                .onComplete(x -> span.finish());\n+\n+    }\n+\n+    private Future<?> createGroups(\n+            final SQLConnection connection,\n+            final DeviceKey key,\n+            final Set<String> memberOf,\n+            final SpanContext context) {\n+\n+        return CompositeFuture.all(memberOf.stream()\n+                .map(groupId -> {\n+\n+                    final var expanded = this.createMemberOfStatement.expand(params -> {\n+                        params.put(\"tenant_id\", key.getTenantId());\n+                        params.put(\"device_id\", key.getDeviceId());\n+                        params.put(\"group_id\", groupId);\n+                    });\n+\n+                    log.debug(\"addToGroup - statement: {}\", expanded);\n+\n+                    return expanded\n+                            .trace(this.tracer, context)\n+                            .update(connection)\n+                            .recover(SQL::translateException);\n+                })\n+                .collect(Collectors.toList()));\n+\n+    }\n+\n+    private Future<?> deleteGroups(final SQLConnection connection,\n+                                   final DeviceKey key,\n+                                   final SpanContext context) {\n+\n+        final var expanded = this.deleteAllMemberOfStatement.expand(params -> {\n+            params.put(\"tenant_id\", key.getTenantId());\n+            params.put(\"device_id\", key.getDeviceId());\n+        });\n+\n+        log.debug(\"deleteGroups - statement: {}\", expanded);\n+\n+        return expanded\n+                .trace(this.tracer, context)\n+                .update(connection)\n+                .recover(SQL::translateException);\n+\n+    }\n+\n+    /**\n+     * Update a field of device information entry.\n+     * <p>\n+     * The method executes the provided statement, setting the named parameters\n+     * {@code tenant_id}, {@code device_id}, {@code next_version} and {@code data}.\n+     * Additionally it will provide the named parameter {@code expected_version}, if\n+     * resource version is not empty.\n+     * <p>\n+     * The update must only be performed if the resource version is either empty\n+     * or matches the current version.\n+     * <p>\n+     * It returns the plain update result, which includes the number of rows changes.\n+     * This is one, if the device was updated. It may also be zero, if the device does\n+     * not exists. If the device exists, but the resource version does not match, the result\n+     * will fail with an {@link OptimisticLockingException}.\n+     *\n+     * @param key The key of the device to update.\n+     * @param statement The statement to use for the update.\n+     * @param jsonValue The value to set.\n+     * @param resourceVersion The optional resource version.\n+     * @param nextVersion The new version to set.\n+     * @param span The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    protected Future<UpdateResult> updateJsonField(final DeviceKey key, final Statement statement, final String jsonValue, final Optional<String> resourceVersion,\n+                                                   final String nextVersion, final Span span) {\n+\n+        final var expanded = statement.expand(map -> {\n+            map.put(\"tenant_id\", key.getTenantId());\n+            map.put(\"device_id\", key.getDeviceId());\n+            map.put(\"next_version\", nextVersion);\n+            map.put(\"data\", jsonValue);\n+            resourceVersion.ifPresent(version -> map.put(\"expected_version\", version));\n+        });\n+\n+        log.debug(\"update - statement: {}\", expanded);\n+\n+        // execute update\n+        final var result = expanded\n+                .trace(this.tracer, span.context())\n+                .update(this.client);\n+\n+        // process result, check optimistic lock\n+        return checkOptimisticLock(\n+                result, span,\n+                resourceVersion,\n+                checkSpan -> readDevice(this.client, key, checkSpan));\n+\n+    }\n+\n+    /**\n+     * Update device registration information.\n+     * <p>\n+     * This called the {@link #updateJsonField(DeviceKey, Statement, String, Optional, String, Span)} method\n+     * with either the {@code updateRegistration} or {@code updateRegistrationVersioned}\n+     * statement.\n+     *\n+     * @param key The key of the device to update.\n+     * @param device The device data to store.\n+     * @param resourceVersion The optional resource version.\n+     * @param spanContext The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<Versioned<Void>> updateDevice(final DeviceKey key, final Device device, final Optional<String> resourceVersion, final SpanContext spanContext) {\n+\n+        final String json = Json.encode(device);\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"update device\", getClass().getSimpleName())\n+                .withTag(\"tenant_id\", key.getTenantId())\n+                .withTag(\"device_id\", key.getDeviceId())\n+                .withTag(\"data\", json)\n+                .start();\n+\n+        final var nextVersion = UUID.randomUUID().toString();\n+        resourceVersion.ifPresent(version -> span.setTag(\"version\", version));\n+\n+        final var memberOf = Optional.ofNullable(device.getMemberOf())\n+                .<Set<String>>map(HashSet::new)\n+                .orElse(Collections.emptySet());\n+\n+        return SQL\n+                .runTransactionally(this.client, this.tracer, span.context(), (connection, context) ->\n+\n+                        readDeviceForUpdate(connection, key, context)\n+\n+                                // check if we got back a result, if not this will abort early\n+                                .flatMap(result -> extractVersionForUpdate(result, resourceVersion))\n+\n+                                // take the version and start processing on\n+                                .flatMap(version -> deleteGroups(connection, key, context)\n+                                        .map(version))\n+\n+                                .flatMap(version -> createGroups(connection, key, memberOf, context)\n+                                        .map(version))\n+\n+                                // update the version, this will release the lock\n+                                .flatMap(version -> this.updateRegistrationVersionedStatement\n+                                        .expand(map -> {\n+                                            map.put(\"tenant_id\", key.getTenantId());\n+                                            map.put(\"device_id\", key.getDeviceId());\n+                                            map.put(\"data\", json);\n+                                            map.put(\"expected_version\", version);\n+                                            map.put(\"next_version\", nextVersion);\n+                                        })\n+                                        .trace(this.tracer, span.context()).update(connection)\n+\n+                                        // check the update outcome\n+                                        .flatMap(TableManagementStore::checkUpdateOutcome)\n+                                        .map(version)\n+                                )\n+\n+\n+                )\n+\n+                .map(x -> new Versioned<Void>(nextVersion, null))\n+                .onComplete(x -> span.finish());\n+\n+    }\n+\n+    /**\n+     * Reads the device data.\n+     * <p>\n+     * This reads the device data using\n+     * {@link #readDevice(io.vertx.ext.sql.SQLOperations, DeviceKey, Span)} and\n+     * transforms the plain result into a {@link DeviceReadResult}.\n+     * <p>\n+     * If now rows where found, the result will be empty. If more than one row is found,\n+     * the result will be failed with an {@link IllegalStateException}.\n+     * <p>\n+     * If there is exactly one row, it will read the device registration information from the column\n+     * {@code data} and optionally current resource version from the column {@code version}.\n+     *\n+     * @param key The key of the device to read.\n+     * @param spanContext The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<Optional<DeviceReadResult>> readDevice(final DeviceKey key, final SpanContext spanContext) {\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"read device\", getClass().getSimpleName())\n+                .withTag(\"tenant_id\", key.getTenantId())\n+                .withTag(\"device_id\", key.getDeviceId())\n+                .start();\n+\n+        return readDevice(this.client, key, span)\n+\n+                .<Optional<DeviceReadResult>>flatMap(r -> {\n+                    final var entries = r.getRows(true);\n+                    switch (entries.size()) {\n+                        case 0:\n+                            return Future.succeededFuture((Optional.empty()));\n+                        case 1:\n+                            final var entry = entries.get(0);\n+                            final var device = Json.decodeValue(entry.getString(\"data\"), Device.class);\n+                            final var version = Optional.ofNullable(entry.getString(\"version\"));\n+                            return Future.succeededFuture(Optional.of(new DeviceReadResult(device, version)));\n+                        default:\n+                            return Future.failedFuture(new IllegalStateException(\"Found multiple entries for a single device\"));\n+                    }\n+                })\n \n-        final Statement readStatement;\n+                .onComplete(x -> span.finish());\n \n+    }\n+\n+    /**\n+     * Delete a single device.\n+     * <p>\n+     * This will execute the {@code delete} or {@code deleteVersioned} SQL statement and provide\n+     * the named parameters {@code tenant_id}, {@code device_id}, and {@code expected_version} (if set).\n+     * It will return the plain update result of the operation.\n+     *\n+     * @param key The key of the device to delete.\n+     * @param resourceVersion An optional resource version.\n+     * @param spanContext The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<UpdateResult> deleteDevice(final DeviceKey key, final Optional<String> resourceVersion, final SpanContext spanContext) {\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"delete device\", getClass().getSimpleName())\n+                .withTag(\"tenant_id\", key.getTenantId())", "originalCommit": "ca8947efead5c0f96dca3103075276886180786d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYwOTU0Mw==", "url": "https://github.com/eclipse/hono/pull/2158#discussion_r488609543", "bodyText": "please use Tags from TracingHelper", "author": "sophokles73", "createdAt": "2020-09-15T12:00:22Z", "path": "services/base-jdbc/src/main/java/org/eclipse/hono/service/base/jdbc/store/device/TableManagementStore.java", "diffHunk": "@@ -122,67 +183,414 @@ public TableManagementStore(final SQLClient client, final Tracer tracer, final S\n      *\n      * @param connection The connection to use.\n      * @param key The key of the device.\n-     * @param resourceVersion An optional resource version.\n      * @param span The span to contribute to.\n-     *\n      * @return A future tracking the outcome of the operation.\n      */\n-    protected Future<ResultSet> readDeviceForUpdate(final SQLConnection connection, final DeviceKey key, final Optional<String> resourceVersion, final Span span) {\n+    protected Future<ResultSet> readDeviceForUpdate(final SQLConnection connection, final DeviceKey key, final SpanContext span) {\n+        return read(connection, key, Optional.empty(), this.readForUpdateStatement, span);\n+    }\n+\n+    /**\n+     * Create a new device.\n+     * <p>\n+     * This method executes the {@code create} statement, providing the named parameters\n+     * {@code tenant_id}, {@code device_id}, {@code version}, and {@code data}.\n+     * <p>\n+     * It returns the plain update result. In case a device with the same ID already\n+     * exists, the underlying database must throw an {@link SQLException}, indicating\n+     * a duplicate entity or constraint violation. This will be translated into a\n+     * failed future with an {@link DuplicateKeyException}.\n+     *\n+     * @param key The key of the device to create.\n+     * @param device The device data.\n+     * @param spanContext The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<Versioned<Void>> createDevice(final DeviceKey key, final Device device, final SpanContext spanContext) {\n+\n+        final String json = Json.encode(device);\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"create device\", getClass().getSimpleName())\n+                .withTag(\"tenant_id\", key.getTenantId())\n+                .withTag(\"device_id\", key.getDeviceId())\n+                .withTag(\"data\", json)\n+                .start();\n+\n+        final var version = UUID.randomUUID().toString();\n+\n+        return SQL\n+\n+                .runTransactionally(this.client, this.tracer, span.context(), (connection, context) -> {\n+\n+                    final var expanded = this.createStatement.expand(params -> {\n+                        params.put(\"tenant_id\", key.getTenantId());\n+                        params.put(\"device_id\", key.getDeviceId());\n+                        params.put(\"version\", version);\n+                        params.put(\"data\", json);\n+                    });\n+\n+                    log.debug(\"createDevice - statement: {}\", expanded);\n+\n+                    return expanded\n+\n+                            .trace(this.tracer, context)\n+                            .update(this.client)\n+                            .recover(SQL::translateException)\n+\n+                            .flatMap(x -> createGroups(connection, key, new HashSet<>(device.getMemberOf()), context));\n+\n+                })\n+\n+                .map(new Versioned<Void>(version, null))\n+                .onComplete(x -> span.finish());\n+\n+    }\n+\n+    private Future<?> createGroups(\n+            final SQLConnection connection,\n+            final DeviceKey key,\n+            final Set<String> memberOf,\n+            final SpanContext context) {\n+\n+        return CompositeFuture.all(memberOf.stream()\n+                .map(groupId -> {\n+\n+                    final var expanded = this.createMemberOfStatement.expand(params -> {\n+                        params.put(\"tenant_id\", key.getTenantId());\n+                        params.put(\"device_id\", key.getDeviceId());\n+                        params.put(\"group_id\", groupId);\n+                    });\n+\n+                    log.debug(\"addToGroup - statement: {}\", expanded);\n+\n+                    return expanded\n+                            .trace(this.tracer, context)\n+                            .update(connection)\n+                            .recover(SQL::translateException);\n+                })\n+                .collect(Collectors.toList()));\n+\n+    }\n+\n+    private Future<?> deleteGroups(final SQLConnection connection,\n+                                   final DeviceKey key,\n+                                   final SpanContext context) {\n+\n+        final var expanded = this.deleteAllMemberOfStatement.expand(params -> {\n+            params.put(\"tenant_id\", key.getTenantId());\n+            params.put(\"device_id\", key.getDeviceId());\n+        });\n+\n+        log.debug(\"deleteGroups - statement: {}\", expanded);\n+\n+        return expanded\n+                .trace(this.tracer, context)\n+                .update(connection)\n+                .recover(SQL::translateException);\n+\n+    }\n+\n+    /**\n+     * Update a field of device information entry.\n+     * <p>\n+     * The method executes the provided statement, setting the named parameters\n+     * {@code tenant_id}, {@code device_id}, {@code next_version} and {@code data}.\n+     * Additionally it will provide the named parameter {@code expected_version}, if\n+     * resource version is not empty.\n+     * <p>\n+     * The update must only be performed if the resource version is either empty\n+     * or matches the current version.\n+     * <p>\n+     * It returns the plain update result, which includes the number of rows changes.\n+     * This is one, if the device was updated. It may also be zero, if the device does\n+     * not exists. If the device exists, but the resource version does not match, the result\n+     * will fail with an {@link OptimisticLockingException}.\n+     *\n+     * @param key The key of the device to update.\n+     * @param statement The statement to use for the update.\n+     * @param jsonValue The value to set.\n+     * @param resourceVersion The optional resource version.\n+     * @param nextVersion The new version to set.\n+     * @param span The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    protected Future<UpdateResult> updateJsonField(final DeviceKey key, final Statement statement, final String jsonValue, final Optional<String> resourceVersion,\n+                                                   final String nextVersion, final Span span) {\n+\n+        final var expanded = statement.expand(map -> {\n+            map.put(\"tenant_id\", key.getTenantId());\n+            map.put(\"device_id\", key.getDeviceId());\n+            map.put(\"next_version\", nextVersion);\n+            map.put(\"data\", jsonValue);\n+            resourceVersion.ifPresent(version -> map.put(\"expected_version\", version));\n+        });\n+\n+        log.debug(\"update - statement: {}\", expanded);\n+\n+        // execute update\n+        final var result = expanded\n+                .trace(this.tracer, span.context())\n+                .update(this.client);\n+\n+        // process result, check optimistic lock\n+        return checkOptimisticLock(\n+                result, span,\n+                resourceVersion,\n+                checkSpan -> readDevice(this.client, key, checkSpan));\n+\n+    }\n+\n+    /**\n+     * Update device registration information.\n+     * <p>\n+     * This called the {@link #updateJsonField(DeviceKey, Statement, String, Optional, String, Span)} method\n+     * with either the {@code updateRegistration} or {@code updateRegistrationVersioned}\n+     * statement.\n+     *\n+     * @param key The key of the device to update.\n+     * @param device The device data to store.\n+     * @param resourceVersion The optional resource version.\n+     * @param spanContext The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<Versioned<Void>> updateDevice(final DeviceKey key, final Device device, final Optional<String> resourceVersion, final SpanContext spanContext) {\n+\n+        final String json = Json.encode(device);\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"update device\", getClass().getSimpleName())\n+                .withTag(\"tenant_id\", key.getTenantId())\n+                .withTag(\"device_id\", key.getDeviceId())\n+                .withTag(\"data\", json)\n+                .start();\n+\n+        final var nextVersion = UUID.randomUUID().toString();\n+        resourceVersion.ifPresent(version -> span.setTag(\"version\", version));\n+\n+        final var memberOf = Optional.ofNullable(device.getMemberOf())\n+                .<Set<String>>map(HashSet::new)\n+                .orElse(Collections.emptySet());\n+\n+        return SQL\n+                .runTransactionally(this.client, this.tracer, span.context(), (connection, context) ->\n+\n+                        readDeviceForUpdate(connection, key, context)\n+\n+                                // check if we got back a result, if not this will abort early\n+                                .flatMap(result -> extractVersionForUpdate(result, resourceVersion))\n+\n+                                // take the version and start processing on\n+                                .flatMap(version -> deleteGroups(connection, key, context)\n+                                        .map(version))\n+\n+                                .flatMap(version -> createGroups(connection, key, memberOf, context)\n+                                        .map(version))\n+\n+                                // update the version, this will release the lock\n+                                .flatMap(version -> this.updateRegistrationVersionedStatement\n+                                        .expand(map -> {\n+                                            map.put(\"tenant_id\", key.getTenantId());\n+                                            map.put(\"device_id\", key.getDeviceId());\n+                                            map.put(\"data\", json);\n+                                            map.put(\"expected_version\", version);\n+                                            map.put(\"next_version\", nextVersion);\n+                                        })\n+                                        .trace(this.tracer, span.context()).update(connection)\n+\n+                                        // check the update outcome\n+                                        .flatMap(TableManagementStore::checkUpdateOutcome)\n+                                        .map(version)\n+                                )\n+\n+\n+                )\n+\n+                .map(x -> new Versioned<Void>(nextVersion, null))\n+                .onComplete(x -> span.finish());\n+\n+    }\n+\n+    /**\n+     * Reads the device data.\n+     * <p>\n+     * This reads the device data using\n+     * {@link #readDevice(io.vertx.ext.sql.SQLOperations, DeviceKey, Span)} and\n+     * transforms the plain result into a {@link DeviceReadResult}.\n+     * <p>\n+     * If now rows where found, the result will be empty. If more than one row is found,\n+     * the result will be failed with an {@link IllegalStateException}.\n+     * <p>\n+     * If there is exactly one row, it will read the device registration information from the column\n+     * {@code data} and optionally current resource version from the column {@code version}.\n+     *\n+     * @param key The key of the device to read.\n+     * @param spanContext The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<Optional<DeviceReadResult>> readDevice(final DeviceKey key, final SpanContext spanContext) {\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"read device\", getClass().getSimpleName())\n+                .withTag(\"tenant_id\", key.getTenantId())\n+                .withTag(\"device_id\", key.getDeviceId())\n+                .start();\n+\n+        return readDevice(this.client, key, span)\n+\n+                .<Optional<DeviceReadResult>>flatMap(r -> {\n+                    final var entries = r.getRows(true);\n+                    switch (entries.size()) {\n+                        case 0:\n+                            return Future.succeededFuture((Optional.empty()));\n+                        case 1:\n+                            final var entry = entries.get(0);\n+                            final var device = Json.decodeValue(entry.getString(\"data\"), Device.class);\n+                            final var version = Optional.ofNullable(entry.getString(\"version\"));\n+                            return Future.succeededFuture(Optional.of(new DeviceReadResult(device, version)));\n+                        default:\n+                            return Future.failedFuture(new IllegalStateException(\"Found multiple entries for a single device\"));\n+                    }\n+                })\n \n-        final Statement readStatement;\n+                .onComplete(x -> span.finish());\n \n+    }\n+\n+    /**\n+     * Delete a single device.\n+     * <p>\n+     * This will execute the {@code delete} or {@code deleteVersioned} SQL statement and provide\n+     * the named parameters {@code tenant_id}, {@code device_id}, and {@code expected_version} (if set).\n+     * It will return the plain update result of the operation.\n+     *\n+     * @param key The key of the device to delete.\n+     * @param resourceVersion An optional resource version.\n+     * @param spanContext The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<UpdateResult> deleteDevice(final DeviceKey key, final Optional<String> resourceVersion, final SpanContext spanContext) {\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"delete device\", getClass().getSimpleName())\n+                .withTag(\"tenant_id\", key.getTenantId())\n+                .withTag(\"device_id\", key.getDeviceId())\n+                .start();\n+\n+        resourceVersion.ifPresent(version -> span.setTag(\"version\", version));\n+\n+        final Statement statement;\n         if (resourceVersion.isPresent()) {\n-            readStatement = this.readForUpdateVersionedStatement;\n+            statement = this.deleteVersionedStatement;\n         } else {\n-            readStatement = this.readForUpdateStatement;\n+            statement = this.deleteStatement;\n         }\n \n-        return read(connection, key, resourceVersion, readStatement, span);\n+        final var expanded = statement.expand(map -> {\n+            map.put(\"tenant_id\", key.getTenantId());\n+            map.put(\"device_id\", key.getDeviceId());\n+            resourceVersion.ifPresent(version -> map.put(\"expected_version\", version));\n+        });\n+\n+        log.debug(\"delete - statement: {}\", expanded);\n+\n+        final var result = expanded\n+                .trace(this.tracer, span.context())\n+                .update(this.client);\n+\n+        return checkOptimisticLock(\n+                result, span,\n+                resourceVersion,\n+                checkSpan -> readDevice(this.client, key, checkSpan))\n+                .onComplete(x -> span.finish());\n \n     }\n \n-    @Override\n-    public Future<Boolean> setCredentials(final DeviceKey key, final List<CommonCredential> credentials, final Optional<String> resourceVersion,\n-            final SpanContext spanContext) {\n+    /**\n+     * Delete all devices belonging to the provided tenant.\n+     *\n+     * @param tenantId The tenant to clean up.\n+     * @param spanContext The span to contribute to.\n+     * @return A future tracking the outcome of the operation.\n+     */\n+    public Future<UpdateResult> dropTenant(final String tenantId, final SpanContext spanContext) {\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"drop tenant\", getClass().getSimpleName())\n+                .withTag(\"tenant_id\", tenantId)\n+                .start();\n+\n+        final var expanded = this.dropTenantStatement.expand(params -> {\n+            params.put(\"tenant_id\", tenantId);\n+        });\n+\n+        log.debug(\"delete - statement: {}\", expanded);\n+\n+        return expanded\n+                .trace(this.tracer, span.context())\n+                .update(this.client)\n+                .onComplete(x -> span.finish());\n+\n+    }\n \n-        final String json = Json.encode(credentials.toArray(CommonCredential[]::new));\n+    /**\n+     * Set all credentials for a device.\n+     * <p>\n+     * This will set/replace all credentials of the device. If the device does not exists, the result\n+     * will be {@code false}. If the update was successful, then the result will be {@code true}.\n+     * If the resource version was provided, but the provided version was no longer the current version,\n+     * then the future will fail with a {@link OptimisticLockingException}.\n+     *\n+     * @param key The key of the device to update.\n+     * @param credentials The credentials to set.\n+     * @param resourceVersion The optional resource version to update.\n+     * @param spanContext The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<Versioned<Boolean>> setCredentials(final DeviceKey key, final List<CommonCredential> credentials, final Optional<String> resourceVersion,\n+                                                     final SpanContext spanContext) {\n \n         final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"set credentials\", getClass().getSimpleName())\n-                .withTag(\"tenant_instance_id\", key.getTenantId())\n+                .withTag(\"tenant_id\", key.getTenantId())", "originalCommit": "ca8947efead5c0f96dca3103075276886180786d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYxMDQwNA==", "url": "https://github.com/eclipse/hono/pull/2158#discussion_r488610404", "bodyText": "please use Tags from TracingHelper", "author": "sophokles73", "createdAt": "2020-09-15T12:01:55Z", "path": "services/base-jdbc/src/main/java/org/eclipse/hono/service/base/jdbc/store/tenant/ManagementStore.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.service.base.jdbc.store.tenant;\n+\n+import java.io.IOException;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.base.jdbc.store.EntityNotFoundException;\n+import org.eclipse.hono.service.base.jdbc.store.SQL;\n+import org.eclipse.hono.service.base.jdbc.store.Statement;\n+import org.eclipse.hono.service.base.jdbc.store.StatementConfiguration;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.sql.SQLClient;\n+import io.vertx.ext.sql.SQLConnection;\n+import io.vertx.ext.sql.SQLOperations;\n+import io.vertx.ext.sql.UpdateResult;\n+\n+/**\n+ * A data store for device connection information.\n+ */\n+public class ManagementStore extends AbstractTenantStore {\n+\n+    private static final Logger log = LoggerFactory.getLogger(ManagementStore.class);\n+\n+    private final Statement createStatement;\n+\n+    private final Statement insertTrustAnchorStatement;\n+    private final Statement deleteAllTrustAnchorsStatement;\n+\n+    private final Statement updateStatement;\n+    private final Statement updateVersionedStatement;\n+\n+    private final Statement deleteStatement;\n+    private final Statement deleteVersionedStatement;\n+\n+    /**\n+     * Create a new instance.\n+     *\n+     * @param client The SQL client to use.\n+     * @param tracer The tracer to use.\n+     * @param cfg The statement configuration to use.\n+     */\n+    public ManagementStore(final SQLClient client, final Tracer tracer, final StatementConfiguration cfg) {\n+        super(client, tracer, cfg);\n+\n+        this.createStatement = cfg\n+                .getRequiredStatement(\"create\")\n+                .validateParameters(\n+                        \"tenant_id\",\n+                        \"version\",\n+                        \"data\"\n+                );\n+\n+        this.insertTrustAnchorStatement = cfg\n+                .getRequiredStatement(\"insertTrustAnchor\")\n+                .validateParameters(\n+                        \"tenant_id\",\n+                        \"subject_dn\",\n+                        \"data\"\n+                );\n+        this.deleteAllTrustAnchorsStatement = cfg\n+                .getRequiredStatement(\"deleteAllTrustAnchors\")\n+                .validateParameters(\n+                        \"tenant_id\"\n+                );\n+\n+        this.updateStatement = cfg\n+                .getRequiredStatement(\"update\")\n+                .validateParameters(\n+                        \"tenant_id\",\n+                        \"next_version\",\n+                        \"data\"\n+                );\n+        this.updateVersionedStatement = cfg\n+                .getRequiredStatement(\"updateVersioned\")\n+                .validateParameters(\n+                        \"tenant_id\",\n+                        \"next_version\",\n+                        \"data\",\n+                        \"expected_version\"\n+                );\n+\n+        this.deleteStatement = cfg.getRequiredStatement(\"delete\")\n+                .validateParameters(\n+                        \"tenant_id\"\n+                );\n+        this.deleteVersionedStatement = cfg.getRequiredStatement(\"deleteVersioned\")\n+                .validateParameters(\n+                        \"tenant_id\",\n+                        \"expected_version\"\n+                );\n+\n+    }\n+\n+    /**\n+     * Create a device statement configuration for the device connection store.\n+     *\n+     * @param jdbcUrl The JDBC URL for detecting the database dialect.\n+     * @param tenantTableName The table name to use for tenants.\n+     * @param trustAnchorsTenantName The table name to use trust anchors.\n+     * @return The new configuration.\n+     * @throws IOException in case an IO error occurs.\n+     */\n+    public static StatementConfiguration defaultStatementConfiguration(final String jdbcUrl, final Optional<String> tenantTableName, final Optional<String> trustAnchorsTenantName) throws IOException {\n+\n+        final String dialect = SQL.getDatabaseDialect(jdbcUrl);\n+        final String tenantTableNameString = tenantTableName.orElse(DEFAULT_TENANTS_TABLE_NAME);\n+        final String trustAnchorsTableNameString = trustAnchorsTenantName.orElse(DEFAULT_TRUST_ANCHORS_NAME);\n+\n+        return StatementConfiguration\n+                .empty(tenantTableNameString, trustAnchorsTableNameString)\n+                .overrideWithDefaultPattern(\"base\", dialect, ManagementStore.class, StatementConfiguration.DEFAULT_PATH.resolve(\"tenant\"));\n+\n+    }\n+\n+    /**\n+     * Encode the tenant information as JSON, for storing in the data field.\n+     *\n+     * @param tenant The tenant to encode.\n+     * @return The encoded JSON, without the trust anchors.\n+     */\n+    private String tenantToJson(final Tenant tenant) {\n+        final var jsonObjectObj = JsonObject.mapFrom(tenant);\n+        // we store this separately\n+        jsonObjectObj.remove(TenantConstants.FIELD_PAYLOAD_TRUSTED_CA);\n+        return jsonObjectObj.toString();\n+    }\n+\n+    /**\n+     * Create a new tenant.\n+     * <p>\n+     * The operation may fail with a {@link org.eclipse.hono.service.base.jdbc.store.DuplicateKeyException} if a\n+     * tenant with the ID or trust anchor already exists.\n+     *\n+     * @param tenantId The ID of the new tenant.\n+     * @param tenant The tenant information.\n+     * @param spanContext The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<Versioned<Void>> create(final String tenantId, final Tenant tenant, final SpanContext spanContext) {\n+\n+        final var json = tenantToJson(tenant);\n+        final var version = UUID.randomUUID().toString();\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"create tenant\", getClass().getSimpleName())\n+                .withTag(\"tenant_id\", tenantId)", "originalCommit": "ca8947efead5c0f96dca3103075276886180786d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYxMDU0MQ==", "url": "https://github.com/eclipse/hono/pull/2158#discussion_r488610541", "bodyText": "please use Tags from TracingHelper", "author": "sophokles73", "createdAt": "2020-09-15T12:02:08Z", "path": "services/base-jdbc/src/main/java/org/eclipse/hono/service/base/jdbc/store/tenant/ManagementStore.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.service.base.jdbc.store.tenant;\n+\n+import java.io.IOException;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.base.jdbc.store.EntityNotFoundException;\n+import org.eclipse.hono.service.base.jdbc.store.SQL;\n+import org.eclipse.hono.service.base.jdbc.store.Statement;\n+import org.eclipse.hono.service.base.jdbc.store.StatementConfiguration;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.sql.SQLClient;\n+import io.vertx.ext.sql.SQLConnection;\n+import io.vertx.ext.sql.SQLOperations;\n+import io.vertx.ext.sql.UpdateResult;\n+\n+/**\n+ * A data store for device connection information.\n+ */\n+public class ManagementStore extends AbstractTenantStore {\n+\n+    private static final Logger log = LoggerFactory.getLogger(ManagementStore.class);\n+\n+    private final Statement createStatement;\n+\n+    private final Statement insertTrustAnchorStatement;\n+    private final Statement deleteAllTrustAnchorsStatement;\n+\n+    private final Statement updateStatement;\n+    private final Statement updateVersionedStatement;\n+\n+    private final Statement deleteStatement;\n+    private final Statement deleteVersionedStatement;\n+\n+    /**\n+     * Create a new instance.\n+     *\n+     * @param client The SQL client to use.\n+     * @param tracer The tracer to use.\n+     * @param cfg The statement configuration to use.\n+     */\n+    public ManagementStore(final SQLClient client, final Tracer tracer, final StatementConfiguration cfg) {\n+        super(client, tracer, cfg);\n+\n+        this.createStatement = cfg\n+                .getRequiredStatement(\"create\")\n+                .validateParameters(\n+                        \"tenant_id\",\n+                        \"version\",\n+                        \"data\"\n+                );\n+\n+        this.insertTrustAnchorStatement = cfg\n+                .getRequiredStatement(\"insertTrustAnchor\")\n+                .validateParameters(\n+                        \"tenant_id\",\n+                        \"subject_dn\",\n+                        \"data\"\n+                );\n+        this.deleteAllTrustAnchorsStatement = cfg\n+                .getRequiredStatement(\"deleteAllTrustAnchors\")\n+                .validateParameters(\n+                        \"tenant_id\"\n+                );\n+\n+        this.updateStatement = cfg\n+                .getRequiredStatement(\"update\")\n+                .validateParameters(\n+                        \"tenant_id\",\n+                        \"next_version\",\n+                        \"data\"\n+                );\n+        this.updateVersionedStatement = cfg\n+                .getRequiredStatement(\"updateVersioned\")\n+                .validateParameters(\n+                        \"tenant_id\",\n+                        \"next_version\",\n+                        \"data\",\n+                        \"expected_version\"\n+                );\n+\n+        this.deleteStatement = cfg.getRequiredStatement(\"delete\")\n+                .validateParameters(\n+                        \"tenant_id\"\n+                );\n+        this.deleteVersionedStatement = cfg.getRequiredStatement(\"deleteVersioned\")\n+                .validateParameters(\n+                        \"tenant_id\",\n+                        \"expected_version\"\n+                );\n+\n+    }\n+\n+    /**\n+     * Create a device statement configuration for the device connection store.\n+     *\n+     * @param jdbcUrl The JDBC URL for detecting the database dialect.\n+     * @param tenantTableName The table name to use for tenants.\n+     * @param trustAnchorsTenantName The table name to use trust anchors.\n+     * @return The new configuration.\n+     * @throws IOException in case an IO error occurs.\n+     */\n+    public static StatementConfiguration defaultStatementConfiguration(final String jdbcUrl, final Optional<String> tenantTableName, final Optional<String> trustAnchorsTenantName) throws IOException {\n+\n+        final String dialect = SQL.getDatabaseDialect(jdbcUrl);\n+        final String tenantTableNameString = tenantTableName.orElse(DEFAULT_TENANTS_TABLE_NAME);\n+        final String trustAnchorsTableNameString = trustAnchorsTenantName.orElse(DEFAULT_TRUST_ANCHORS_NAME);\n+\n+        return StatementConfiguration\n+                .empty(tenantTableNameString, trustAnchorsTableNameString)\n+                .overrideWithDefaultPattern(\"base\", dialect, ManagementStore.class, StatementConfiguration.DEFAULT_PATH.resolve(\"tenant\"));\n+\n+    }\n+\n+    /**\n+     * Encode the tenant information as JSON, for storing in the data field.\n+     *\n+     * @param tenant The tenant to encode.\n+     * @return The encoded JSON, without the trust anchors.\n+     */\n+    private String tenantToJson(final Tenant tenant) {\n+        final var jsonObjectObj = JsonObject.mapFrom(tenant);\n+        // we store this separately\n+        jsonObjectObj.remove(TenantConstants.FIELD_PAYLOAD_TRUSTED_CA);\n+        return jsonObjectObj.toString();\n+    }\n+\n+    /**\n+     * Create a new tenant.\n+     * <p>\n+     * The operation may fail with a {@link org.eclipse.hono.service.base.jdbc.store.DuplicateKeyException} if a\n+     * tenant with the ID or trust anchor already exists.\n+     *\n+     * @param tenantId The ID of the new tenant.\n+     * @param tenant The tenant information.\n+     * @param spanContext The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<Versioned<Void>> create(final String tenantId, final Tenant tenant, final SpanContext spanContext) {\n+\n+        final var json = tenantToJson(tenant);\n+        final var version = UUID.randomUUID().toString();\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"create tenant\", getClass().getSimpleName())\n+                .withTag(\"tenant_id\", tenantId)\n+                .withTag(\"data\", json)\n+                .start();\n+\n+        return SQL.runTransactionally(this.client, this.tracer, span.context(),\n+                (connection, context) -> {\n+\n+                    final var expanded = this.createStatement.expand(params -> {\n+                        params.put(\"tenant_id\", tenantId);\n+                        params.put(\"version\", version);\n+                        params.put(\"data\", json);\n+                    });\n+\n+                    log.debug(\"create - statement: {}\", expanded);\n+                    return expanded\n+                            .trace(this.tracer, span.context())\n+                            .update(this.client)\n+                            .recover(SQL::translateException)\n+\n+                            // insert all trust anchors\n+                            .flatMap(r -> insertAllTrustAnchors(connection, tenantId, tenant,  span));\n+\n+                }\n+        )\n+                .map(new Versioned<Void>(version, null))\n+\n+                .onComplete(x -> span.finish());\n+\n+    }\n+\n+    private Future<Void> deleteAllTrustAnchors(final SQLConnection connection, final String tenantId, final Span span) {\n+\n+        return this.deleteAllTrustAnchorsStatement\n+\n+                .expand(params -> {\n+                    params.put(\"tenant_id\", tenantId);\n+                })\n+                .trace(this.tracer, span.context())\n+                .update(connection)\n+\n+                .mapEmpty();\n+\n+    }\n+\n+    private Future<Void> insertAllTrustAnchors(final SQLConnection connection, final String tenantId, final Tenant tenant, final Span span) {\n+\n+        if (tenant.getTrustedCertificateAuthorities() == null || tenant.getTrustedCertificateAuthorities().isEmpty()) {\n+            return Future.succeededFuture();\n+        }\n+\n+        return CompositeFuture\n+\n+                .all(tenant.getTrustedCertificateAuthorities().stream()\n+\n+                        .map(anchor -> {\n+                            final var json = JsonObject.mapFrom(anchor);\n+                            final var subjectDn = json.remove(TenantConstants.FIELD_PAYLOAD_SUBJECT_DN);\n+\n+                            if (!(subjectDn instanceof String) || ((String) subjectDn).isEmpty()) {\n+                                return Future.failedFuture(new IllegalArgumentException(String.format(\"Missing field '%s' in trust anchor\", TenantConstants.FIELD_PAYLOAD_SUBJECT_DN)));\n+                            }\n+\n+                            return this.insertTrustAnchorStatement\n+                                .expand(params -> {\n+                                    params.put(\"tenant_id\", tenantId);\n+                                    params.put(\"subject_dn\", subjectDn);\n+                                    params.put(\"data\", json.toString());\n+                                })\n+                                .trace(this.tracer, span.context())\n+                                .update(connection)\n+                                .recover(SQL::translateException);\n+                            }\n+                        )\n+                        .collect(Collectors.toList())\n+                )\n+\n+                .mapEmpty();\n+\n+    }\n+\n+    /**\n+     * Read a tenant.\n+     *\n+     * @param id The ID of the tenant to read.\n+     * @param spanContext The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<Optional<TenantReadResult>> read(final String id, final SpanContext spanContext) {\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"get tenant by id\", getClass().getSimpleName())\n+                .withTag(\"tenant_id\", id)\n+                .start();\n+\n+        return readTenant(id, span.context())\n+                .onComplete(x -> span.finish());\n+\n+    }\n+\n+    /**\n+     * Delete the tenant.\n+     *\n+     * @param tenantId The tenant to delete.\n+     * @param resourceVersion The version of the resource to delete.\n+     * @param spanContext The span to contribute to.\n+     * @return The future, tracking the outcome of the operation.\n+     */\n+    public Future<UpdateResult> delete(final String tenantId, final Optional<String> resourceVersion, final SpanContext spanContext) {\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"delete tenant\", getClass().getSimpleName())\n+                .withTag(\"tenant_id\", tenantId)\n+                .start();\n+\n+        resourceVersion.ifPresent(version -> span.setTag(\"version\", version));\n+\n+        final Statement statement;\n+        if (resourceVersion.isPresent()) {\n+            statement = this.deleteVersionedStatement;\n+        } else {\n+            statement = this.deleteStatement;\n+        }\n+\n+        final var expanded = statement.expand(map -> {\n+            map.put(\"tenant_id\", tenantId);\n+            resourceVersion.ifPresent(version -> map.put(\"expected_version\", version));\n+        });\n+\n+        log.debug(\"delete - statement: {}\", expanded);\n+\n+        final var result = expanded\n+                .trace(this.tracer, span.context())\n+                .update(this.client)\n+                .onComplete(x -> span.finish());\n+\n+        return checkOptimisticLock(\n+                result, span,\n+                resourceVersion,\n+                checkSpan -> readTenantEntryById(this.client, tenantId, checkSpan.context()))\n+                .onComplete(x -> span.finish());\n+\n+    }\n+\n+    /**\n+     * Create a new tenant.\n+     * <p>\n+     * The operation may fail with a {@link org.eclipse.hono.service.base.jdbc.store.EntityNotFoundException} if the\n+     * specified tenant does not exist.\n+     * <p>\n+     * The operation may fail with a {@link org.eclipse.hono.service.base.jdbc.store.DuplicateKeyException} if a\n+     * tenant with the ID or trust anchor already exists.\n+     * <p>\n+     * The operation may fail with an {@link org.eclipse.hono.service.base.jdbc.store.OptimisticLockingException} if\n+     * an expected resource version was provided, but the current version did not match.\n+     *\n+     * @param tenantId The ID of the new tenant.\n+     * @param tenant The tenant information.\n+     * @param resourceVersion An optional resource version.\n+     * @param spanContext The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<Versioned<Void>> update(final String tenantId, final Tenant tenant, final Optional<String> resourceVersion, final SpanContext spanContext) {\n+\n+        final var json = tenantToJson(tenant);\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"update tenant\", getClass().getSimpleName())\n+                .withTag(\"tenant_id\", tenantId)", "originalCommit": "ca8947efead5c0f96dca3103075276886180786d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "63a735265538596ceefb3c37a4d583280535ac99", "url": "https://github.com/eclipse/hono/commit/63a735265538596ceefb3c37a4d583280535ac99", "message": "Refactor JDBC storage layer, add tenant store", "committedDate": "2020-09-15T12:21:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYzNTIwNA==", "url": "https://github.com/eclipse/hono/pull/2158#discussion_r488635204", "bodyText": "Do you intend to provide full text searching on all CRUD method payloads via the tracing system? We do nothing like this for the other device registries so I wonder why we would want/need to do this in the JDBC registry.\nFMPOV the Tags are intended as markers for the spans by which it is easy to group and filter them. Adding full payloads here doesn't seem right to me. If at all, the payload should be logged to the span but it should not go into a tag ....", "author": "sophokles73", "createdAt": "2020-09-15T12:43:40Z", "path": "services/base-jdbc/src/main/java/org/eclipse/hono/service/base/jdbc/store/tenant/ManagementStore.java", "diffHunk": "@@ -0,0 +1,422 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+\n+package org.eclipse.hono.service.base.jdbc.store.tenant;\n+\n+import java.io.IOException;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n+\n+import org.eclipse.hono.deviceregistry.util.Versioned;\n+import org.eclipse.hono.service.base.jdbc.store.EntityNotFoundException;\n+import org.eclipse.hono.service.base.jdbc.store.SQL;\n+import org.eclipse.hono.service.base.jdbc.store.Statement;\n+import org.eclipse.hono.service.base.jdbc.store.StatementConfiguration;\n+import org.eclipse.hono.service.management.tenant.Tenant;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.TenantConstants;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.opentracing.Tracer;\n+import io.vertx.core.CompositeFuture;\n+import io.vertx.core.Future;\n+import io.vertx.core.json.JsonObject;\n+import io.vertx.ext.sql.SQLClient;\n+import io.vertx.ext.sql.SQLConnection;\n+import io.vertx.ext.sql.SQLOperations;\n+import io.vertx.ext.sql.UpdateResult;\n+\n+/**\n+ * A data store for device connection information.\n+ */\n+public class ManagementStore extends AbstractTenantStore {\n+\n+    private static final Logger log = LoggerFactory.getLogger(ManagementStore.class);\n+\n+    private final Statement createStatement;\n+\n+    private final Statement insertTrustAnchorStatement;\n+    private final Statement deleteAllTrustAnchorsStatement;\n+\n+    private final Statement updateStatement;\n+    private final Statement updateVersionedStatement;\n+\n+    private final Statement deleteStatement;\n+    private final Statement deleteVersionedStatement;\n+\n+    /**\n+     * Create a new instance.\n+     *\n+     * @param client The SQL client to use.\n+     * @param tracer The tracer to use.\n+     * @param cfg The statement configuration to use.\n+     */\n+    public ManagementStore(final SQLClient client, final Tracer tracer, final StatementConfiguration cfg) {\n+        super(client, tracer, cfg);\n+\n+        this.createStatement = cfg\n+                .getRequiredStatement(\"create\")\n+                .validateParameters(\n+                        \"tenant_id\",\n+                        \"version\",\n+                        \"data\"\n+                );\n+\n+        this.insertTrustAnchorStatement = cfg\n+                .getRequiredStatement(\"insertTrustAnchor\")\n+                .validateParameters(\n+                        \"tenant_id\",\n+                        \"subject_dn\",\n+                        \"data\"\n+                );\n+        this.deleteAllTrustAnchorsStatement = cfg\n+                .getRequiredStatement(\"deleteAllTrustAnchors\")\n+                .validateParameters(\n+                        \"tenant_id\"\n+                );\n+\n+        this.updateStatement = cfg\n+                .getRequiredStatement(\"update\")\n+                .validateParameters(\n+                        \"tenant_id\",\n+                        \"next_version\",\n+                        \"data\"\n+                );\n+        this.updateVersionedStatement = cfg\n+                .getRequiredStatement(\"updateVersioned\")\n+                .validateParameters(\n+                        \"tenant_id\",\n+                        \"next_version\",\n+                        \"data\",\n+                        \"expected_version\"\n+                );\n+\n+        this.deleteStatement = cfg.getRequiredStatement(\"delete\")\n+                .validateParameters(\n+                        \"tenant_id\"\n+                );\n+        this.deleteVersionedStatement = cfg.getRequiredStatement(\"deleteVersioned\")\n+                .validateParameters(\n+                        \"tenant_id\",\n+                        \"expected_version\"\n+                );\n+\n+    }\n+\n+    /**\n+     * Create a device statement configuration for the device connection store.\n+     *\n+     * @param jdbcUrl The JDBC URL for detecting the database dialect.\n+     * @param tenantTableName The table name to use for tenants.\n+     * @param trustAnchorsTenantName The table name to use trust anchors.\n+     * @return The new configuration.\n+     * @throws IOException in case an IO error occurs.\n+     */\n+    public static StatementConfiguration defaultStatementConfiguration(final String jdbcUrl, final Optional<String> tenantTableName, final Optional<String> trustAnchorsTenantName) throws IOException {\n+\n+        final String dialect = SQL.getDatabaseDialect(jdbcUrl);\n+        final String tenantTableNameString = tenantTableName.orElse(DEFAULT_TENANTS_TABLE_NAME);\n+        final String trustAnchorsTableNameString = trustAnchorsTenantName.orElse(DEFAULT_TRUST_ANCHORS_NAME);\n+\n+        return StatementConfiguration\n+                .empty(tenantTableNameString, trustAnchorsTableNameString)\n+                .overrideWithDefaultPattern(\"base\", dialect, ManagementStore.class, StatementConfiguration.DEFAULT_PATH.resolve(\"tenant\"));\n+\n+    }\n+\n+    /**\n+     * Encode the tenant information as JSON, for storing in the data field.\n+     *\n+     * @param tenant The tenant to encode.\n+     * @return The encoded JSON, without the trust anchors.\n+     */\n+    private String tenantToJson(final Tenant tenant) {\n+        final var jsonObjectObj = JsonObject.mapFrom(tenant);\n+        // we store this separately\n+        jsonObjectObj.remove(TenantConstants.FIELD_PAYLOAD_TRUSTED_CA);\n+        return jsonObjectObj.toString();\n+    }\n+\n+    /**\n+     * Create a new tenant.\n+     * <p>\n+     * The operation may fail with a {@link org.eclipse.hono.service.base.jdbc.store.DuplicateKeyException} if a\n+     * tenant with the ID or trust anchor already exists.\n+     *\n+     * @param tenantId The ID of the new tenant.\n+     * @param tenant The tenant information.\n+     * @param spanContext The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<Versioned<Void>> create(final String tenantId, final Tenant tenant, final SpanContext spanContext) {\n+\n+        final var json = tenantToJson(tenant);\n+        final var version = UUID.randomUUID().toString();\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"create tenant\", getClass().getSimpleName())\n+                .withTag(TracingHelper.TAG_TENANT_ID, tenantId)\n+                .withTag(\"data\", json)\n+                .start();\n+\n+        return SQL.runTransactionally(this.client, this.tracer, span.context(),\n+                (connection, context) -> {\n+\n+                    final var expanded = this.createStatement.expand(params -> {\n+                        params.put(\"tenant_id\", tenantId);\n+                        params.put(\"version\", version);\n+                        params.put(\"data\", json);\n+                    });\n+\n+                    log.debug(\"create - statement: {}\", expanded);\n+                    return expanded\n+                            .trace(this.tracer, span.context())\n+                            .update(this.client)\n+                            .recover(SQL::translateException)\n+\n+                            // insert all trust anchors\n+                            .flatMap(r -> insertAllTrustAnchors(connection, tenantId, tenant,  span));\n+\n+                }\n+        )\n+                .map(new Versioned<Void>(version, null))\n+\n+                .onComplete(x -> span.finish());\n+\n+    }\n+\n+    private Future<Void> deleteAllTrustAnchors(final SQLConnection connection, final String tenantId, final Span span) {\n+\n+        return this.deleteAllTrustAnchorsStatement\n+\n+                .expand(params -> {\n+                    params.put(\"tenant_id\", tenantId);\n+                })\n+                .trace(this.tracer, span.context())\n+                .update(connection)\n+\n+                .mapEmpty();\n+\n+    }\n+\n+    private Future<Void> insertAllTrustAnchors(final SQLConnection connection, final String tenantId, final Tenant tenant, final Span span) {\n+\n+        if (tenant.getTrustedCertificateAuthorities() == null || tenant.getTrustedCertificateAuthorities().isEmpty()) {\n+            return Future.succeededFuture();\n+        }\n+\n+        return CompositeFuture\n+\n+                .all(tenant.getTrustedCertificateAuthorities().stream()\n+\n+                        .map(anchor -> {\n+                            final var json = JsonObject.mapFrom(anchor);\n+                            final var subjectDn = json.remove(TenantConstants.FIELD_PAYLOAD_SUBJECT_DN);\n+\n+                            if (!(subjectDn instanceof String) || ((String) subjectDn).isEmpty()) {\n+                                return Future.failedFuture(new IllegalArgumentException(String.format(\"Missing field '%s' in trust anchor\", TenantConstants.FIELD_PAYLOAD_SUBJECT_DN)));\n+                            }\n+\n+                            return this.insertTrustAnchorStatement\n+                                .expand(params -> {\n+                                    params.put(\"tenant_id\", tenantId);\n+                                    params.put(\"subject_dn\", subjectDn);\n+                                    params.put(\"data\", json.toString());\n+                                })\n+                                .trace(this.tracer, span.context())\n+                                .update(connection)\n+                                .recover(SQL::translateException);\n+                            }\n+                        )\n+                        .collect(Collectors.toList())\n+                )\n+\n+                .mapEmpty();\n+\n+    }\n+\n+    /**\n+     * Read a tenant.\n+     *\n+     * @param id The ID of the tenant to read.\n+     * @param spanContext The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<Optional<TenantReadResult>> read(final String id, final SpanContext spanContext) {\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"get tenant by id\", getClass().getSimpleName())\n+                .withTag(TracingHelper.TAG_TENANT_ID, id)\n+                .start();\n+\n+        return readTenant(id, span.context())\n+                .onComplete(x -> span.finish());\n+\n+    }\n+\n+    /**\n+     * Delete the tenant.\n+     *\n+     * @param tenantId The tenant to delete.\n+     * @param resourceVersion The version of the resource to delete.\n+     * @param spanContext The span to contribute to.\n+     * @return The future, tracking the outcome of the operation.\n+     */\n+    public Future<UpdateResult> delete(final String tenantId, final Optional<String> resourceVersion, final SpanContext spanContext) {\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"delete tenant\", getClass().getSimpleName())\n+                .withTag(TracingHelper.TAG_TENANT_ID, tenantId)\n+                .start();\n+\n+        resourceVersion.ifPresent(version -> span.setTag(\"version\", version));\n+\n+        final Statement statement;\n+        if (resourceVersion.isPresent()) {\n+            statement = this.deleteVersionedStatement;\n+        } else {\n+            statement = this.deleteStatement;\n+        }\n+\n+        final var expanded = statement.expand(map -> {\n+            map.put(\"tenant_id\", tenantId);\n+            resourceVersion.ifPresent(version -> map.put(\"expected_version\", version));\n+        });\n+\n+        log.debug(\"delete - statement: {}\", expanded);\n+\n+        final var result = expanded\n+                .trace(this.tracer, span.context())\n+                .update(this.client)\n+                .onComplete(x -> span.finish());\n+\n+        return checkOptimisticLock(\n+                result, span,\n+                resourceVersion,\n+                checkSpan -> readTenantEntryById(this.client, tenantId, checkSpan.context()))\n+                .onComplete(x -> span.finish());\n+\n+    }\n+\n+    /**\n+     * Create a new tenant.\n+     * <p>\n+     * The operation may fail with a {@link org.eclipse.hono.service.base.jdbc.store.EntityNotFoundException} if the\n+     * specified tenant does not exist.\n+     * <p>\n+     * The operation may fail with a {@link org.eclipse.hono.service.base.jdbc.store.DuplicateKeyException} if a\n+     * tenant with the ID or trust anchor already exists.\n+     * <p>\n+     * The operation may fail with an {@link org.eclipse.hono.service.base.jdbc.store.OptimisticLockingException} if\n+     * an expected resource version was provided, but the current version did not match.\n+     *\n+     * @param tenantId The ID of the new tenant.\n+     * @param tenant The tenant information.\n+     * @param resourceVersion An optional resource version.\n+     * @param spanContext The span to contribute to.\n+     * @return A future, tracking the outcome of the operation.\n+     */\n+    public Future<Versioned<Void>> update(final String tenantId, final Tenant tenant, final Optional<String> resourceVersion, final SpanContext spanContext) {\n+\n+        final var json = tenantToJson(tenant);\n+\n+        final Span span = TracingHelper.buildChildSpan(this.tracer, spanContext, \"update tenant\", getClass().getSimpleName())\n+                .withTag(TracingHelper.TAG_TENANT_ID, tenantId)\n+                .withTag(\"data\", json)", "originalCommit": "63a735265538596ceefb3c37a4d583280535ac99", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc3MTY2NA==", "url": "https://github.com/eclipse/hono/pull/2158#discussion_r488771664", "bodyText": "Is there anything else on this PR to fix?", "author": "ctron", "createdAt": "2020-09-15T15:44:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYzNTIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgwNDkwMw==", "url": "https://github.com/eclipse/hono/pull/2158#discussion_r488804903", "bodyText": "As I wrote above, FMPOV the data should not be written into Tags ...", "author": "sophokles73", "createdAt": "2020-09-15T16:33:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYzNTIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIyNTkxMA==", "url": "https://github.com/eclipse/hono/pull/2158#discussion_r489225910", "bodyText": "Yes, I understand that. But with every round of changes I add, new comments come up. Instead of endlessly updating the PR, I would like to understand \"what else\" I need to change on the PR, in order get it merged.", "author": "ctron", "createdAt": "2020-09-16T07:35:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYzNTIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI4NjYwMA==", "url": "https://github.com/eclipse/hono/pull/2158#discussion_r489286600", "bodyText": "Sorry for the inconvenience. Nothing else from my side.", "author": "sophokles73", "createdAt": "2020-09-16T09:12:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODYzNTIwNA=="}], "type": "inlineReview"}, {"oid": "66de1c9fd38016d28d97ad407af48be83a1fa47a", "url": "https://github.com/eclipse/hono/commit/66de1c9fd38016d28d97ad407af48be83a1fa47a", "message": "Refactor JDBC storage layer, add tenant store", "committedDate": "2020-09-16T15:24:21Z", "type": "commit"}, {"oid": "66de1c9fd38016d28d97ad407af48be83a1fa47a", "url": "https://github.com/eclipse/hono/commit/66de1c9fd38016d28d97ad407af48be83a1fa47a", "message": "Refactor JDBC storage layer, add tenant store", "committedDate": "2020-09-16T15:24:21Z", "type": "forcePushed"}]}