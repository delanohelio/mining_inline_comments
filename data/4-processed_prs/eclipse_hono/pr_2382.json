{"pr_number": 2382, "pr_title": "Introduce response caching at Tenant service client level", "pr_createdAt": "2020-12-23T13:12:45Z", "pr_url": "https://github.com/eclipse/hono/pull/2382", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk3MzE2Mw==", "url": "https://github.com/eclipse/hono/pull/2382#discussion_r547973163", "bodyText": "It looks like Pair<TenantAction, T> could be used here instead, because the Object param is always set to null.", "author": "calohmn", "createdAt": "2020-12-23T14:02:31Z", "path": "clients/adapter-amqp/src/main/java/org/eclipse/hono/adapter/client/registry/amqp/ProtonBasedTenantClient.java", "diffHunk": "@@ -54,56 +75,124 @@ public ProtonBasedTenantClient(\n             final SendMessageSampler.Factory samplerFactory,\n             final ProtocolAdapterProperties adapterConfig,\n             final CacheProvider cacheProvider) {\n-        super(connection, samplerFactory, adapterConfig, cacheProvider);\n-        this.tenantClientFactory = new CachingClientFactory<>(connection.getVertx(), c -> c.isOpen());\n+        super(connection, samplerFactory, adapterConfig, new CachingClientFactory<>(\n+                connection.getVertx(), RequestResponseClient::isOpen), cacheProvider);\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected String getKey(final String tenantId) {\n+        // there is one client for all tenant IDs only\n+        return TenantConstants.TENANT_ENDPOINT;\n     }\n \n-    private Future<org.eclipse.hono.client.TenantClient> getOrCreateTenantClient() {\n+    private Future<RequestResponseClient<TenantResult<TenantObject>>> getOrCreateClient() {\n \n         return connection.isConnected(getDefaultConnectionCheckTimeout())\n                 .compose(v -> connection.executeOnContext(result -> {\n-                    tenantClientFactory.getOrCreateClient(\n-                            TenantClientImpl.getTargetAddress(),\n-                            () -> TenantClientImpl.create(\n-                                    responseCacheProvider,\n-                                    connection,\n-                                    samplerFactory.create(TenantConstants.TENANT_ENDPOINT),\n-                                    this::removeTenantClient,\n-                                    this::removeTenantClient),\n+                    clientFactory.getOrCreateClient(\n+                            TenantConstants.TENANT_ENDPOINT,\n+                            () -> {\n+                                return RequestResponseClient.forEndpoint(\n+                                        connection,\n+                                        TenantConstants.TENANT_ENDPOINT,\n+                                        null,\n+                                        samplerFactory.create(TenantConstants.TENANT_ENDPOINT),\n+                                        this::removeClient,\n+                                        this::removeClient);\n+                            },\n                             result);\n                 }));\n     }\n \n-    private void removeTenantClient(final String tenantId) {\n-        // the tenantId is not relevant for this client, so ignore it\n-        tenantClientFactory.removeClient(TenantClientImpl.getTargetAddress());\n+    @Override\n+    protected TenantResult<TenantObject> getResult(\n+            final int status,\n+            final String contentType,\n+            final Buffer payload,\n+            final CacheDirective cacheDirective,\n+            final ApplicationProperties applicationProperties) {\n+\n+        if (isSuccessResponse(status, contentType, payload)) {\n+            try {\n+                return TenantResult.from(\n+                        status,\n+                        Json.decodeValue(payload, TenantObject.class),\n+                        cacheDirective,\n+                        applicationProperties);\n+            } catch (final DecodeException e) {\n+                LOG.warn(\"received malformed payload from Tenant service\", e);\n+                return TenantResult.from(HttpURLConnection.HTTP_INTERNAL_ERROR, null, null, applicationProperties);\n+            }\n+        } else {\n+            return TenantResult.from(status, null, null, applicationProperties);\n+        }\n     }\n \n     /**\n      * {@inheritDoc}\n-     *\n-     * Clears the state of the client factory.\n      */\n     @Override\n-    protected void onDisconnect() {\n-        tenantClientFactory.clearState();\n+    public Future<TenantObject> get(final String tenantId, final SpanContext parent) {\n+\n+        Objects.requireNonNull(tenantId);\n+\n+        final TriTuple<TenantAction, String, Object> key = TriTuple.of(TenantAction.get, tenantId, null);\n+        final Span span = newChildSpan(parent, \"get Tenant by ID\");\n+        span.setTag(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);\n+        return get(\n+                key,\n+                () -> new JsonObject().put(TenantConstants.FIELD_PAYLOAD_TENANT_ID, tenantId),\n+                span);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public Future<TenantObject> get(final String tenantId, final SpanContext context) {\n-        return getOrCreateTenantClient()\n-                .compose(client -> client.get(tenantId, context));\n+    public Future<TenantObject> get(final X500Principal subjectDn, final SpanContext parent) {\n+\n+        Objects.requireNonNull(subjectDn);\n+\n+        final String subjectDnRfc2253 = subjectDn.getName(X500Principal.RFC2253);\n+        final TriTuple<TenantAction, X500Principal, Object> key = TriTuple.of(TenantAction.get, subjectDn, null);\n+        final Span span = newChildSpan(parent, \"get Tenant by subject DN\");\n+        TAG_SUBJECT_DN.set(span, subjectDnRfc2253);\n+        return get(\n+                key,\n+                () -> new JsonObject().put(TenantConstants.FIELD_PAYLOAD_SUBJECT_DN, subjectDnRfc2253),\n+                span);\n     }\n \n-    /**\n-     * {@inheritDoc}\n-     */\n-    @Override\n-    public Future<TenantObject> get(final X500Principal subjectDn, final SpanContext context) {\n-        return getOrCreateTenantClient()\n-                .compose(client -> client.get(subjectDn, context));\n+    private <T> Future<TenantObject> get(\n+            final TriTuple<TenantAction, T, Object> key,", "originalCommit": "6c57ce940de5a07ef1a68f123774640c8e90eac8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Nzk3NTQyNQ==", "url": "https://github.com/eclipse/hono/pull/2382#discussion_r547975425", "bodyText": "superfluous semicolon", "author": "calohmn", "createdAt": "2020-12-23T14:07:47Z", "path": "clients/adapter-amqp/src/main/java/org/eclipse/hono/adapter/client/amqp/RequestResponseClient.java", "diffHunk": "@@ -0,0 +1,647 @@\n+/*******************************************************************************\n+ * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.adapter.client.amqp;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+import org.apache.qpid.proton.amqp.messaging.Accepted;\n+import org.apache.qpid.proton.amqp.messaging.Modified;\n+import org.apache.qpid.proton.amqp.messaging.Rejected;\n+import org.apache.qpid.proton.amqp.messaging.Released;\n+import org.apache.qpid.proton.amqp.transport.DeliveryState;\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.RequestResponseClientConfigProperties;\n+import org.eclipse.hono.client.SendMessageSampler;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.RequestResponseResult;\n+import org.eclipse.hono.util.TriTuple;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+import io.vertx.proton.ProtonQoS;\n+import io.vertx.proton.ProtonReceiver;\n+import io.vertx.proton.ProtonSender;\n+\n+/**\n+ * A vertx-proton based client for invoking operations on AMQP 1.0 based service endpoints.\n+ * <p>\n+ * The client holds a sender and a receiver link for sending request messages and receiving\n+ * response messages.\n+ *\n+ * @param <R> The type of result this client expects the service to return.\n+ *\n+ */\n+public class RequestResponseClient<R extends RequestResponseResult<?>> extends AbstractHonoClient {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(RequestResponseClient.class);\n+\n+    /**\n+     * The target address of the sender link used to send requests to the service.\n+     */\n+    private final String linkTargetAddress;\n+    /**\n+     * The source address of the receiver link used to receive responses from the service.\n+     */\n+    private final String replyToAddress;\n+    private final SendMessageSampler sampler;\n+    private final Map<Object, TriTuple<Promise<R>, Function<Message, R>, Span>> replyMap = new HashMap<>();\n+    private final String endpointName;\n+    private final String tenantId;\n+    private long requestTimeoutMillis;\n+\n+    /**\n+     * Creates a request-response client.\n+     * <p>\n+     * The created instance's sender link's target address is set to\n+     * <em>${endpointName}[/${tenantId}]</em> and the receiver link's source\n+     * address is set to <em>${endpointName}[/${tenantId}]/${UUID}</em>\n+     * (where ${UUID} is a generated UUID).\n+     * <p>\n+     * The latter address is also used as the value of the <em>reply-to</em>\n+     * property of all request messages sent by this client.\n+     * <p>\n+     * The client will be ready to use after invoking {@link #createLinks()} or\n+     * {@link #createLinks(Handler, Handler)} only.\n+     *\n+     * @param connection The connection to the service.\n+     * @param endpointName The name of the endpoint to send request messages to.\n+     * @param tenantId The tenant that the client should be scoped to or {@code null} if the\n+     *                 client should not be scoped to a tenant.\n+     * @param sampler The sampler to use.\n+     * @throws NullPointerException if any of the parameters except tenantId is {@code null}.\n+     */\n+    private RequestResponseClient(\n+            final HonoConnection connection,\n+            final String endpointName,\n+            final String tenantId,\n+            final SendMessageSampler sampler) {\n+\n+        this(connection, endpointName, tenantId, UUID.randomUUID().toString(), sampler);\n+    }\n+\n+    /**\n+     * Creates a request-response client.\n+     * <p>\n+     * The created instance's sender link's target address is set to\n+     * <em>${endpointName}[/${tenantId}]</em> and the receiver link's source\n+     * address is set to <em>${endpointName}[/${tenantId}]/${replyId}</em>.\n+     * <p>\n+     * The latter address is also used as the value of the <em>reply-to</em>\n+     * property of all request messages sent by this client.\n+     * <p>\n+     * The client will be ready to use after invoking {@link #createLinks()} or\n+     * {@link #createLinks(Handler, Handler)} only.\n+     *\n+     * @param connection The connection to the service.\n+     * @param endpointName The name of the endpoint to send request messages to.\n+     * @param tenantId The tenant that the client should be scoped to or {@code null} if the\n+     *                 client should not be scoped to a tenant.\n+     * @param replyId The replyId to use in the reply-to address.\n+     * @param sampler The sampler to use.\n+     * @throws NullPointerException if any of the parameters except tenantId is {@code null}.\n+     */\n+    private RequestResponseClient(\n+            final HonoConnection connection,\n+            final String endpointName,\n+            final String tenantId,\n+            final String replyId,\n+            final SendMessageSampler sampler) {\n+\n+        super(connection);\n+        this.endpointName = Objects.requireNonNull(endpointName);\n+        Objects.requireNonNull(replyId);\n+        this.sampler = Objects.requireNonNull(sampler);\n+        this.requestTimeoutMillis = connection.getConfig().getRequestTimeout();\n+        if (tenantId == null) {\n+            this.linkTargetAddress = endpointName;\n+            this.replyToAddress = String.format(\"%s/%s\", endpointName, replyId);\n+        } else {\n+            this.linkTargetAddress = String.format(\"%s/%s\", endpointName, tenantId);\n+            this.replyToAddress = String.format(\"%s/%s/%s\", endpointName, tenantId, replyId);\n+        }\n+        this.tenantId = tenantId;\n+    }\n+\n+    /**\n+     * Creates a request-response client for an endpoint.\n+     * <p>\n+     * The client has a sender and a receiver link opened to the service\n+     * endpoint. The sender link's target address is set to\n+     * <em>${endpointName}[/${tenantId}]</em> and the receiver link's source\n+     * address is set to <em>${endpointName}[/${tenantId}]/${UUID}</em>\n+     * (where ${UUID} is a generated UUID).\n+     * <p>\n+     * The latter address is also used as the value of the <em>reply-to</em>\n+     * property of all request messages sent by the client.\n+     *\n+     * @param <T> The type of response that the client expects the service to return.\n+     * @param connection The connection to the service.\n+     * @param endpointName The name of the endpoint to send request messages to.\n+     * @param tenantId The tenant that the client should be scoped to or {@code null} if the\n+     *                 client should not be scoped to a tenant.\n+     * @param sampler The sampler to use.\n+     * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly (may be {@code null}).\n+     * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly (may be {@code null}).\n+     * @return A future indicating the outcome of creating the client. The future will be failed\n+     *         with a {@link org.eclipse.hono.client.ServiceInvocationException} if the links\n+     *         cannot be opened.\n+     * @throws NullPointerException if any of the parameters except tenantId is {@code null}.\n+     */\n+    public static <T extends RequestResponseResult<?>> Future<RequestResponseClient<T>> forEndpoint(\n+            final HonoConnection connection,\n+            final String endpointName,\n+            final String tenantId,\n+            final SendMessageSampler sampler,\n+            final Handler<String> senderCloseHook,\n+            final Handler<String> receiverCloseHook) {\n+\n+        final RequestResponseClient<T> result = new RequestResponseClient<>(connection, endpointName, tenantId, sampler);\n+        return result.createLinks(senderCloseHook, receiverCloseHook).map(result);\n+    }\n+\n+    /**\n+     * Gets the default value for the period of time after which an entry in the response cache\n+     * is considered invalid.\n+     * <p>\n+     * The value is derived from the configuration properties as follows:\n+     * <ol>\n+     * <li>if the properties are of type {@link RequestResponseClientConfigProperties}\n+     * then the value of its <em>responseCacheDefaultTimeout</em> property is used</li>\n+     * <li>otherwise the {@linkplain RequestResponseClientConfigProperties#DEFAULT_RESPONSE_CACHE_TIMEOUT\n+     * default timeout value} is used</li>\n+     * </ol>\n+     *\n+     * @return The timeout period in seconds.\n+     */\n+    protected final long getResponseCacheDefaultTimeout() {\n+        if (connection.getConfig() instanceof RequestResponseClientConfigProperties) {\n+            return ((RequestResponseClientConfigProperties) connection.getConfig()).getResponseCacheDefaultTimeout();\n+        } else {\n+            return RequestResponseClientConfigProperties.DEFAULT_RESPONSE_CACHE_TIMEOUT;\n+        }\n+    }\n+\n+    /**\n+     * Sets the period of time after which any requests are considered to have timed out.\n+     * <p>\n+     * The client will fail the result handler passed in to any of the operations if no response\n+     * has been received from the peer after the given amount of time.\n+     * <p>\n+     * When setting this property to 0, requests do not time out at all. Note that this will\n+     * allow for unanswered requests piling up in the client, which eventually may cause the\n+     * client to run out of memory.\n+     * <p>\n+     * The default value of this property is 200 milliseconds.\n+     *\n+     * @param timoutMillis The number of milliseconds after which a request is considered to have timed out.\n+     * @throws IllegalArgumentException if the value is &lt; 0\n+     */\n+    public final void setRequestTimeout(final long timoutMillis) {\n+\n+        if (timoutMillis < 0) {\n+            throw new IllegalArgumentException(\"request timeout must be >= 0\");\n+        } else {\n+            this.requestTimeoutMillis = timoutMillis;\n+        }\n+    }\n+\n+    /**\n+     * Build a unique messageId for a request that serves as an identifier for a new message.\n+     *\n+     * @return The unique messageId;\n+     */\n+    private String createMessageId() {\n+        return String.format(\"%s-client-%s\", endpointName, UUID.randomUUID());\n+    };", "originalCommit": "6c57ce940de5a07ef1a68f123774640c8e90eac8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAwNDAyOA==", "url": "https://github.com/eclipse/hono/pull/2382#discussion_r548004028", "bodyText": "Not directly related to the changes here, but:\nHave you considered letting the same cache instance be used for all client instances, i.e. across verticle instances?\nThen we would not only get cached tenant values when a connection is down, but also when the tenant object has already been retrieved via another connection/verticle.\nI guess from a thread-safety point of view, this would be ok using CaffeineCache.", "author": "calohmn", "createdAt": "2020-12-23T15:09:15Z", "path": "clients/adapter-amqp/src/main/java/org/eclipse/hono/adapter/client/amqp/AbstractRequestResponseServiceClient.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*******************************************************************************\n+ * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.adapter.client.amqp;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.cache.CacheProvider;\n+import org.eclipse.hono.cache.ExpiringValueCache;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.RequestResponseClientConfigProperties;\n+import org.eclipse.hono.client.SendMessageSampler;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.client.impl.CachingClientFactory;\n+import org.eclipse.hono.config.ProtocolAdapterProperties;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.CacheDirective;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.RequestResponseResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.Future;\n+import io.vertx.core.buffer.Buffer;\n+\n+/**\n+ * A vertx-proton based parent class for the implementation of API clients that follow the request response pattern.\n+ * <p>\n+ * Provides access to a {@link CacheProvider} which can be used to create caches for service response messages.\n+ *\n+ * @param <R> The type of response this client expects the peer to return.\n+ * @param <T> The type of object contained in the peer's response.\n+ *\n+ */\n+public abstract class AbstractRequestResponseServiceClient<T, R extends RequestResponseResult<T>> extends AbstractServiceClient {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AbstractRequestResponseServiceClient.class);\n+    private static final int[] CACHEABLE_STATUS_CODES = new int[] {\n+                            HttpURLConnection.HTTP_OK,\n+                            HttpURLConnection.HTTP_NOT_AUTHORITATIVE,\n+                            HttpURLConnection.HTTP_PARTIAL,\n+                            HttpURLConnection.HTTP_MULT_CHOICE,\n+                            HttpURLConnection.HTTP_MOVED_PERM,\n+                            HttpURLConnection.HTTP_GONE\n+    };\n+\n+    /**\n+     * Contains the AMQP link sender/receiver link pairs for invoking the service.\n+     */\n+    protected final CachingClientFactory<RequestResponseClient<R>> clientFactory;\n+    /**\n+     * A cache to use for responses received from the service.\n+     */\n+    private final ExpiringValueCache<Object, R> responseCache;", "originalCommit": "6c57ce940de5a07ef1a68f123774640c8e90eac8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAxMDc0OQ==", "url": "https://github.com/eclipse/hono/pull/2382#discussion_r548010749", "bodyText": "In general, that should already be possible because the verticle instances get access to the ExpiringvalueCache via a CacheProvider. If they are all configured to use the same CacheProvider instance, then they should all use the same cache instance as well.", "author": "sophokles73", "createdAt": "2020-12-23T15:23:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAwNDAyOA=="}], "type": "inlineReview"}, {"oid": "80ed4b445c4e3659dee74caaac45b6d7d62d4378", "url": "https://github.com/eclipse/hono/commit/80ed4b445c4e3659dee74caaac45b6d7d62d4378", "message": "[#2381] Introduce response caching at Tenant service client level\n\nResponses from the Tenant service are now being stored in a cache that\nis independent from the life cycle of the underlying connection to the\nservice.\n\nSigned-off-by: Kai Hudalla <kai.hudalla@bosch.io>", "committedDate": "2020-12-23T15:16:44Z", "type": "forcePushed"}, {"oid": "35acfda23480ce14efcfd2a86129019700ec8835", "url": "https://github.com/eclipse/hono/commit/35acfda23480ce14efcfd2a86129019700ec8835", "message": "[#2381] Introduce response caching at Tenant service client level\n\nResponses from the Tenant service are now being stored in a cache that\nis independent from the life cycle of the underlying connection to the\nservice.\n\nSigned-off-by: Kai Hudalla <kai.hudalla@bosch.io>", "committedDate": "2020-12-23T15:37:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAyODAyMA==", "url": "https://github.com/eclipse/hono/pull/2382#discussion_r548028020", "bodyText": "2020", "author": "calohmn", "createdAt": "2020-12-23T16:00:44Z", "path": "clients/adapter-amqp/src/main/java/org/eclipse/hono/adapter/client/amqp/AbstractRequestResponseServiceClient.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*******************************************************************************\n+ * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation", "originalCommit": "35acfda23480ce14efcfd2a86129019700ec8835", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA1NDUzNw==", "url": "https://github.com/eclipse/hono/pull/2382#discussion_r548054537", "bodyText": "I had deliberately kept the origin year because most of the code has been copied over from the legacy client.", "author": "sophokles73", "createdAt": "2020-12-23T17:00:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAyODAyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAyOTAxMw==", "url": "https://github.com/eclipse/hono/pull/2382#discussion_r548029013", "bodyText": "This sentence originating from AbstractRequestResponseClient doesn't really fit here.", "author": "calohmn", "createdAt": "2020-12-23T16:03:00Z", "path": "clients/adapter-amqp/src/main/java/org/eclipse/hono/adapter/client/amqp/AbstractRequestResponseServiceClient.java", "diffHunk": "@@ -0,0 +1,369 @@\n+/*******************************************************************************\n+ * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.adapter.client.amqp;\n+\n+import java.net.HttpURLConnection;\n+import java.time.Duration;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.function.Function;\n+\n+import org.apache.qpid.proton.amqp.messaging.ApplicationProperties;\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.cache.CacheProvider;\n+import org.eclipse.hono.cache.ExpiringValueCache;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.RequestResponseClientConfigProperties;\n+import org.eclipse.hono.client.SendMessageSampler;\n+import org.eclipse.hono.client.ServiceInvocationException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.client.impl.CachingClientFactory;\n+import org.eclipse.hono.config.ProtocolAdapterProperties;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.CacheDirective;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.RequestResponseResult;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.Future;\n+import io.vertx.core.buffer.Buffer;\n+\n+/**\n+ * A vertx-proton based parent class for the implementation of API clients that follow the request response pattern.\n+ * <p>\n+ * Provides access to a {@link CacheProvider} which can be used to create caches for service response messages.", "originalCommit": "35acfda23480ce14efcfd2a86129019700ec8835", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAzMDA4MQ==", "url": "https://github.com/eclipse/hono/pull/2382#discussion_r548030081", "bodyText": "2020", "author": "calohmn", "createdAt": "2020-12-23T16:05:26Z", "path": "clients/adapter-amqp/src/test/java/org/eclipse/hono/adapter/client/amqp/RequestResponseClientTest.java", "diffHunk": "@@ -0,0 +1,379 @@\n+/*******************************************************************************\n+ * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation", "originalCommit": "35acfda23480ce14efcfd2a86129019700ec8835", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA1NTIwNw==", "url": "https://github.com/eclipse/hono/pull/2382#discussion_r548055207", "bodyText": "I had deliberately kept the origin year because most of the code has been copied over from the legacy client.", "author": "sophokles73", "createdAt": "2020-12-23T17:02:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAzMDA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAzMjc4Mg==", "url": "https://github.com/eclipse/hono/pull/2382#discussion_r548032782", "bodyText": "There is no con parameter.", "author": "calohmn", "createdAt": "2020-12-23T16:11:29Z", "path": "clients/adapter-amqp/src/main/java/org/eclipse/hono/adapter/client/amqp/RequestResponseClient.java", "diffHunk": "@@ -0,0 +1,647 @@\n+/*******************************************************************************\n+ * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.adapter.client.amqp;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+import org.apache.qpid.proton.amqp.messaging.Accepted;\n+import org.apache.qpid.proton.amqp.messaging.Modified;\n+import org.apache.qpid.proton.amqp.messaging.Rejected;\n+import org.apache.qpid.proton.amqp.messaging.Released;\n+import org.apache.qpid.proton.amqp.transport.DeliveryState;\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.RequestResponseClientConfigProperties;\n+import org.eclipse.hono.client.SendMessageSampler;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.RequestResponseResult;\n+import org.eclipse.hono.util.TriTuple;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+import io.vertx.proton.ProtonQoS;\n+import io.vertx.proton.ProtonReceiver;\n+import io.vertx.proton.ProtonSender;\n+\n+/**\n+ * A vertx-proton based client for invoking operations on AMQP 1.0 based service endpoints.\n+ * <p>\n+ * The client holds a sender and a receiver link for sending request messages and receiving\n+ * response messages.\n+ *\n+ * @param <R> The type of result this client expects the service to return.\n+ *\n+ */\n+public class RequestResponseClient<R extends RequestResponseResult<?>> extends AbstractHonoClient {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(RequestResponseClient.class);\n+\n+    /**\n+     * The target address of the sender link used to send requests to the service.\n+     */\n+    private final String linkTargetAddress;\n+    /**\n+     * The source address of the receiver link used to receive responses from the service.\n+     */\n+    private final String replyToAddress;\n+    private final SendMessageSampler sampler;\n+    private final Map<Object, TriTuple<Promise<R>, Function<Message, R>, Span>> replyMap = new HashMap<>();\n+    private final String endpointName;\n+    private final String tenantId;\n+    private long requestTimeoutMillis;\n+\n+    /**\n+     * Creates a request-response client.\n+     * <p>\n+     * The created instance's sender link's target address is set to\n+     * <em>${endpointName}[/${tenantId}]</em> and the receiver link's source\n+     * address is set to <em>${endpointName}[/${tenantId}]/${UUID}</em>\n+     * (where ${UUID} is a generated UUID).\n+     * <p>\n+     * The latter address is also used as the value of the <em>reply-to</em>\n+     * property of all request messages sent by this client.\n+     * <p>\n+     * The client will be ready to use after invoking {@link #createLinks()} or\n+     * {@link #createLinks(Handler, Handler)} only.\n+     *\n+     * @param connection The connection to the service.\n+     * @param endpointName The name of the endpoint to send request messages to.\n+     * @param tenantId The tenant that the client should be scoped to or {@code null} if the\n+     *                 client should not be scoped to a tenant.\n+     * @param sampler The sampler to use.\n+     * @throws NullPointerException if any of the parameters except tenantId is {@code null}.\n+     */\n+    private RequestResponseClient(\n+            final HonoConnection connection,\n+            final String endpointName,\n+            final String tenantId,\n+            final SendMessageSampler sampler) {\n+\n+        this(connection, endpointName, tenantId, UUID.randomUUID().toString(), sampler);\n+    }\n+\n+    /**\n+     * Creates a request-response client.\n+     * <p>\n+     * The created instance's sender link's target address is set to\n+     * <em>${endpointName}[/${tenantId}]</em> and the receiver link's source\n+     * address is set to <em>${endpointName}[/${tenantId}]/${replyId}</em>.\n+     * <p>\n+     * The latter address is also used as the value of the <em>reply-to</em>\n+     * property of all request messages sent by this client.\n+     * <p>\n+     * The client will be ready to use after invoking {@link #createLinks()} or\n+     * {@link #createLinks(Handler, Handler)} only.\n+     *\n+     * @param connection The connection to the service.\n+     * @param endpointName The name of the endpoint to send request messages to.\n+     * @param tenantId The tenant that the client should be scoped to or {@code null} if the\n+     *                 client should not be scoped to a tenant.\n+     * @param replyId The replyId to use in the reply-to address.\n+     * @param sampler The sampler to use.\n+     * @throws NullPointerException if any of the parameters except tenantId is {@code null}.\n+     */\n+    private RequestResponseClient(\n+            final HonoConnection connection,\n+            final String endpointName,\n+            final String tenantId,\n+            final String replyId,\n+            final SendMessageSampler sampler) {\n+\n+        super(connection);\n+        this.endpointName = Objects.requireNonNull(endpointName);\n+        Objects.requireNonNull(replyId);\n+        this.sampler = Objects.requireNonNull(sampler);\n+        this.requestTimeoutMillis = connection.getConfig().getRequestTimeout();\n+        if (tenantId == null) {\n+            this.linkTargetAddress = endpointName;\n+            this.replyToAddress = String.format(\"%s/%s\", endpointName, replyId);\n+        } else {\n+            this.linkTargetAddress = String.format(\"%s/%s\", endpointName, tenantId);\n+            this.replyToAddress = String.format(\"%s/%s/%s\", endpointName, tenantId, replyId);\n+        }\n+        this.tenantId = tenantId;\n+    }\n+\n+    /**\n+     * Creates a request-response client for an endpoint.\n+     * <p>\n+     * The client has a sender and a receiver link opened to the service\n+     * endpoint. The sender link's target address is set to\n+     * <em>${endpointName}[/${tenantId}]</em> and the receiver link's source\n+     * address is set to <em>${endpointName}[/${tenantId}]/${UUID}</em>\n+     * (where ${UUID} is a generated UUID).\n+     * <p>\n+     * The latter address is also used as the value of the <em>reply-to</em>\n+     * property of all request messages sent by the client.\n+     *\n+     * @param <T> The type of response that the client expects the service to return.\n+     * @param connection The connection to the service.\n+     * @param endpointName The name of the endpoint to send request messages to.\n+     * @param tenantId The tenant that the client should be scoped to or {@code null} if the\n+     *                 client should not be scoped to a tenant.\n+     * @param sampler The sampler to use.\n+     * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly (may be {@code null}).\n+     * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly (may be {@code null}).\n+     * @return A future indicating the outcome of creating the client. The future will be failed\n+     *         with a {@link org.eclipse.hono.client.ServiceInvocationException} if the links\n+     *         cannot be opened.\n+     * @throws NullPointerException if any of the parameters except tenantId is {@code null}.\n+     */\n+    public static <T extends RequestResponseResult<?>> Future<RequestResponseClient<T>> forEndpoint(\n+            final HonoConnection connection,\n+            final String endpointName,\n+            final String tenantId,\n+            final SendMessageSampler sampler,\n+            final Handler<String> senderCloseHook,\n+            final Handler<String> receiverCloseHook) {\n+\n+        final RequestResponseClient<T> result = new RequestResponseClient<>(connection, endpointName, tenantId, sampler);\n+        return result.createLinks(senderCloseHook, receiverCloseHook).map(result);\n+    }\n+\n+    /**\n+     * Gets the default value for the period of time after which an entry in the response cache\n+     * is considered invalid.\n+     * <p>\n+     * The value is derived from the configuration properties as follows:\n+     * <ol>\n+     * <li>if the properties are of type {@link RequestResponseClientConfigProperties}\n+     * then the value of its <em>responseCacheDefaultTimeout</em> property is used</li>\n+     * <li>otherwise the {@linkplain RequestResponseClientConfigProperties#DEFAULT_RESPONSE_CACHE_TIMEOUT\n+     * default timeout value} is used</li>\n+     * </ol>\n+     *\n+     * @return The timeout period in seconds.\n+     */\n+    protected final long getResponseCacheDefaultTimeout() {\n+        if (connection.getConfig() instanceof RequestResponseClientConfigProperties) {\n+            return ((RequestResponseClientConfigProperties) connection.getConfig()).getResponseCacheDefaultTimeout();\n+        } else {\n+            return RequestResponseClientConfigProperties.DEFAULT_RESPONSE_CACHE_TIMEOUT;\n+        }\n+    }\n+\n+    /**\n+     * Sets the period of time after which any requests are considered to have timed out.\n+     * <p>\n+     * The client will fail the result handler passed in to any of the operations if no response\n+     * has been received from the peer after the given amount of time.\n+     * <p>\n+     * When setting this property to 0, requests do not time out at all. Note that this will\n+     * allow for unanswered requests piling up in the client, which eventually may cause the\n+     * client to run out of memory.\n+     * <p>\n+     * The default value of this property is 200 milliseconds.\n+     *\n+     * @param timoutMillis The number of milliseconds after which a request is considered to have timed out.\n+     * @throws IllegalArgumentException if the value is &lt; 0\n+     */\n+    public final void setRequestTimeout(final long timoutMillis) {\n+\n+        if (timoutMillis < 0) {\n+            throw new IllegalArgumentException(\"request timeout must be >= 0\");\n+        } else {\n+            this.requestTimeoutMillis = timoutMillis;\n+        }\n+    }\n+\n+    /**\n+     * Build a unique messageId for a request that serves as an identifier for a new message.\n+     *\n+     * @return The unique messageId;\n+     */\n+    private String createMessageId() {\n+        return String.format(\"%s-client-%s\", endpointName, UUID.randomUUID());\n+    }\n+\n+    /**\n+     * Creates the sender and receiver links to the peer for sending requests\n+     * and receiving responses.\n+     *\n+     * @return A future indicating the outcome. The future will succeed if the links\n+     *         have been created.\n+     * @throws NullPointerException if con is {@code null}.", "originalCommit": "35acfda23480ce14efcfd2a86129019700ec8835", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAzNzMyMA==", "url": "https://github.com/eclipse/hono/pull/2382#discussion_r548037320", "bodyText": "No result handler param here. It looks like the responseMapper param mustn't be null instead here.", "author": "calohmn", "createdAt": "2020-12-23T16:21:38Z", "path": "clients/adapter-amqp/src/main/java/org/eclipse/hono/adapter/client/amqp/RequestResponseClient.java", "diffHunk": "@@ -0,0 +1,647 @@\n+/*******************************************************************************\n+ * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.adapter.client.amqp;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+import org.apache.qpid.proton.amqp.messaging.Accepted;\n+import org.apache.qpid.proton.amqp.messaging.Modified;\n+import org.apache.qpid.proton.amqp.messaging.Rejected;\n+import org.apache.qpid.proton.amqp.messaging.Released;\n+import org.apache.qpid.proton.amqp.transport.DeliveryState;\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.RequestResponseClientConfigProperties;\n+import org.eclipse.hono.client.SendMessageSampler;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.RequestResponseResult;\n+import org.eclipse.hono.util.TriTuple;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+import io.vertx.proton.ProtonQoS;\n+import io.vertx.proton.ProtonReceiver;\n+import io.vertx.proton.ProtonSender;\n+\n+/**\n+ * A vertx-proton based client for invoking operations on AMQP 1.0 based service endpoints.\n+ * <p>\n+ * The client holds a sender and a receiver link for sending request messages and receiving\n+ * response messages.\n+ *\n+ * @param <R> The type of result this client expects the service to return.\n+ *\n+ */\n+public class RequestResponseClient<R extends RequestResponseResult<?>> extends AbstractHonoClient {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(RequestResponseClient.class);\n+\n+    /**\n+     * The target address of the sender link used to send requests to the service.\n+     */\n+    private final String linkTargetAddress;\n+    /**\n+     * The source address of the receiver link used to receive responses from the service.\n+     */\n+    private final String replyToAddress;\n+    private final SendMessageSampler sampler;\n+    private final Map<Object, TriTuple<Promise<R>, Function<Message, R>, Span>> replyMap = new HashMap<>();\n+    private final String endpointName;\n+    private final String tenantId;\n+    private long requestTimeoutMillis;\n+\n+    /**\n+     * Creates a request-response client.\n+     * <p>\n+     * The created instance's sender link's target address is set to\n+     * <em>${endpointName}[/${tenantId}]</em> and the receiver link's source\n+     * address is set to <em>${endpointName}[/${tenantId}]/${UUID}</em>\n+     * (where ${UUID} is a generated UUID).\n+     * <p>\n+     * The latter address is also used as the value of the <em>reply-to</em>\n+     * property of all request messages sent by this client.\n+     * <p>\n+     * The client will be ready to use after invoking {@link #createLinks()} or\n+     * {@link #createLinks(Handler, Handler)} only.\n+     *\n+     * @param connection The connection to the service.\n+     * @param endpointName The name of the endpoint to send request messages to.\n+     * @param tenantId The tenant that the client should be scoped to or {@code null} if the\n+     *                 client should not be scoped to a tenant.\n+     * @param sampler The sampler to use.\n+     * @throws NullPointerException if any of the parameters except tenantId is {@code null}.\n+     */\n+    private RequestResponseClient(\n+            final HonoConnection connection,\n+            final String endpointName,\n+            final String tenantId,\n+            final SendMessageSampler sampler) {\n+\n+        this(connection, endpointName, tenantId, UUID.randomUUID().toString(), sampler);\n+    }\n+\n+    /**\n+     * Creates a request-response client.\n+     * <p>\n+     * The created instance's sender link's target address is set to\n+     * <em>${endpointName}[/${tenantId}]</em> and the receiver link's source\n+     * address is set to <em>${endpointName}[/${tenantId}]/${replyId}</em>.\n+     * <p>\n+     * The latter address is also used as the value of the <em>reply-to</em>\n+     * property of all request messages sent by this client.\n+     * <p>\n+     * The client will be ready to use after invoking {@link #createLinks()} or\n+     * {@link #createLinks(Handler, Handler)} only.\n+     *\n+     * @param connection The connection to the service.\n+     * @param endpointName The name of the endpoint to send request messages to.\n+     * @param tenantId The tenant that the client should be scoped to or {@code null} if the\n+     *                 client should not be scoped to a tenant.\n+     * @param replyId The replyId to use in the reply-to address.\n+     * @param sampler The sampler to use.\n+     * @throws NullPointerException if any of the parameters except tenantId is {@code null}.\n+     */\n+    private RequestResponseClient(\n+            final HonoConnection connection,\n+            final String endpointName,\n+            final String tenantId,\n+            final String replyId,\n+            final SendMessageSampler sampler) {\n+\n+        super(connection);\n+        this.endpointName = Objects.requireNonNull(endpointName);\n+        Objects.requireNonNull(replyId);\n+        this.sampler = Objects.requireNonNull(sampler);\n+        this.requestTimeoutMillis = connection.getConfig().getRequestTimeout();\n+        if (tenantId == null) {\n+            this.linkTargetAddress = endpointName;\n+            this.replyToAddress = String.format(\"%s/%s\", endpointName, replyId);\n+        } else {\n+            this.linkTargetAddress = String.format(\"%s/%s\", endpointName, tenantId);\n+            this.replyToAddress = String.format(\"%s/%s/%s\", endpointName, tenantId, replyId);\n+        }\n+        this.tenantId = tenantId;\n+    }\n+\n+    /**\n+     * Creates a request-response client for an endpoint.\n+     * <p>\n+     * The client has a sender and a receiver link opened to the service\n+     * endpoint. The sender link's target address is set to\n+     * <em>${endpointName}[/${tenantId}]</em> and the receiver link's source\n+     * address is set to <em>${endpointName}[/${tenantId}]/${UUID}</em>\n+     * (where ${UUID} is a generated UUID).\n+     * <p>\n+     * The latter address is also used as the value of the <em>reply-to</em>\n+     * property of all request messages sent by the client.\n+     *\n+     * @param <T> The type of response that the client expects the service to return.\n+     * @param connection The connection to the service.\n+     * @param endpointName The name of the endpoint to send request messages to.\n+     * @param tenantId The tenant that the client should be scoped to or {@code null} if the\n+     *                 client should not be scoped to a tenant.\n+     * @param sampler The sampler to use.\n+     * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly (may be {@code null}).\n+     * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly (may be {@code null}).\n+     * @return A future indicating the outcome of creating the client. The future will be failed\n+     *         with a {@link org.eclipse.hono.client.ServiceInvocationException} if the links\n+     *         cannot be opened.\n+     * @throws NullPointerException if any of the parameters except tenantId is {@code null}.\n+     */\n+    public static <T extends RequestResponseResult<?>> Future<RequestResponseClient<T>> forEndpoint(\n+            final HonoConnection connection,\n+            final String endpointName,\n+            final String tenantId,\n+            final SendMessageSampler sampler,\n+            final Handler<String> senderCloseHook,\n+            final Handler<String> receiverCloseHook) {\n+\n+        final RequestResponseClient<T> result = new RequestResponseClient<>(connection, endpointName, tenantId, sampler);\n+        return result.createLinks(senderCloseHook, receiverCloseHook).map(result);\n+    }\n+\n+    /**\n+     * Gets the default value for the period of time after which an entry in the response cache\n+     * is considered invalid.\n+     * <p>\n+     * The value is derived from the configuration properties as follows:\n+     * <ol>\n+     * <li>if the properties are of type {@link RequestResponseClientConfigProperties}\n+     * then the value of its <em>responseCacheDefaultTimeout</em> property is used</li>\n+     * <li>otherwise the {@linkplain RequestResponseClientConfigProperties#DEFAULT_RESPONSE_CACHE_TIMEOUT\n+     * default timeout value} is used</li>\n+     * </ol>\n+     *\n+     * @return The timeout period in seconds.\n+     */\n+    protected final long getResponseCacheDefaultTimeout() {\n+        if (connection.getConfig() instanceof RequestResponseClientConfigProperties) {\n+            return ((RequestResponseClientConfigProperties) connection.getConfig()).getResponseCacheDefaultTimeout();\n+        } else {\n+            return RequestResponseClientConfigProperties.DEFAULT_RESPONSE_CACHE_TIMEOUT;\n+        }\n+    }\n+\n+    /**\n+     * Sets the period of time after which any requests are considered to have timed out.\n+     * <p>\n+     * The client will fail the result handler passed in to any of the operations if no response\n+     * has been received from the peer after the given amount of time.\n+     * <p>\n+     * When setting this property to 0, requests do not time out at all. Note that this will\n+     * allow for unanswered requests piling up in the client, which eventually may cause the\n+     * client to run out of memory.\n+     * <p>\n+     * The default value of this property is 200 milliseconds.\n+     *\n+     * @param timoutMillis The number of milliseconds after which a request is considered to have timed out.\n+     * @throws IllegalArgumentException if the value is &lt; 0\n+     */\n+    public final void setRequestTimeout(final long timoutMillis) {\n+\n+        if (timoutMillis < 0) {\n+            throw new IllegalArgumentException(\"request timeout must be >= 0\");\n+        } else {\n+            this.requestTimeoutMillis = timoutMillis;\n+        }\n+    }\n+\n+    /**\n+     * Build a unique messageId for a request that serves as an identifier for a new message.\n+     *\n+     * @return The unique messageId;\n+     */\n+    private String createMessageId() {\n+        return String.format(\"%s-client-%s\", endpointName, UUID.randomUUID());\n+    }\n+\n+    /**\n+     * Creates the sender and receiver links to the peer for sending requests\n+     * and receiving responses.\n+     *\n+     * @return A future indicating the outcome. The future will succeed if the links\n+     *         have been created.\n+     * @throws NullPointerException if con is {@code null}.\n+     */\n+    public final Future<Void> createLinks() {\n+        return createLinks(null, null);\n+    }\n+\n+    /**\n+     * Creates the sender and receiver links to the peer for sending requests\n+     * and receiving responses.\n+     *\n+     * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly (may be {@code null}).\n+     * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly (may be {@code null}).\n+     * @return A future indicating the outcome. The future will succeed if the links\n+     *         have been created.\n+     */\n+    public final Future<Void> createLinks(\n+            final Handler<String> senderCloseHook,\n+            final Handler<String> receiverCloseHook) {\n+\n+        return createReceiver(replyToAddress, receiverCloseHook)\n+                .compose(recv -> {\n+                    this.receiver = recv;\n+                    return createSender(linkTargetAddress, senderCloseHook);\n+                })\n+                .compose(sender -> {\n+                    LOG.debug(\"request-response client for peer [{}] created\", connection.getConfig().getHost());\n+                    this.offeredCapabilities = Optional.ofNullable(sender.getRemoteOfferedCapabilities())\n+                            .map(caps -> Collections.unmodifiableList(Arrays.asList(caps)))\n+                            .orElse(Collections.emptyList());\n+                    this.sender = sender;\n+                    return Future.succeededFuture();\n+                });\n+    }\n+\n+    private Future<ProtonSender> createSender(final String targetAddress, final Handler<String> closeHook) {\n+\n+        return connection.createSender(targetAddress, ProtonQoS.AT_LEAST_ONCE, closeHook);\n+    }\n+\n+    private Future<ProtonReceiver> createReceiver(final String sourceAddress, final Handler<String> closeHook) {\n+\n+        return connection.createReceiver(sourceAddress, ProtonQoS.AT_LEAST_ONCE, this::handleResponse, closeHook);\n+    }\n+\n+    /**\n+     * Handles a response received from the peer.\n+     * <p>\n+     * In particular, this method tries to correlate the message with a previous request\n+     * using the message's <em>correlation-id</em> and, if successful, the delivery is <em>accepted</em>\n+     * and the message is passed to the handler registered with the original request.\n+     * <p>\n+     * If the response cannot be correlated to a request, e.g. because the request has timed\n+     * out, then the delivery is <em>released</em> and the message is silently discarded.\n+     *\n+     * @param delivery The handle for accessing the message's disposition.\n+     * @param message The response message.\n+     */\n+    private void handleResponse(final ProtonDelivery delivery, final Message message) {\n+\n+        // the tuple from the reply map contains\n+        // 1. the handler for processing the response and\n+        // 2. the function for mapping the raw AMQP message to the response type\n+        // 3. the Opentracing span covering the execution\n+        final TriTuple<Promise<R>, Function<Message, R>, Span> handler = replyMap.remove(message.getCorrelationId());\n+\n+        if (handler == null) {\n+            LOG.debug(\"discarding unexpected response [reply-to: {}, correlation ID: {}]\",\n+                    replyToAddress, message.getCorrelationId());\n+            ProtonHelper.rejected(delivery, true);\n+        } else {\n+            final R response = handler.two().apply(message);\n+            final Span span = handler.three();\n+            if (response == null) {\n+                LOG.debug(\"discarding malformed response [reply-to: {}, correlation ID: {}]\",\n+                        replyToAddress, message.getCorrelationId());\n+                handler.one().handle(Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                        \"cannot process response from service [\" + endpointName + \"]\")));\n+                ProtonHelper.released(delivery, true);\n+            } else {\n+                LOG.debug(\"received response [reply-to: {}, subject: {}, correlation ID: {}, status: {}, cache-directive: {}]\",\n+                        replyToAddress, message.getSubject(), message.getCorrelationId(), response.getStatus(), response.getCacheDirective());\n+                if (span != null) {\n+                    span.log(\"response from peer accepted\");\n+                }\n+                handler.one().handle(Future.succeededFuture(response));\n+                ProtonHelper.accepted(delivery, true);\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Cancels an outstanding request with a given result.\n+     *\n+     * @param correlationId The identifier of the request to cancel.\n+     * @param result The result to pass to the result handler registered for the correlation ID.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     * @throws IllegalArgumentException if the result is succeeded.\n+     */\n+    private void cancelRequest(final Object correlationId, final AsyncResult<R> result) {\n+\n+        Objects.requireNonNull(correlationId);\n+        Objects.requireNonNull(result);\n+\n+        if (result.succeeded()) {\n+            throw new IllegalArgumentException(\"result must be failed\");\n+        } else {\n+            Optional.ofNullable(replyMap.remove(correlationId))\n+                .ifPresent(handler -> {\n+                    LOG.debug(\"canceling request [target: {}, correlation ID: {}]: {}\",\n+                            linkTargetAddress, correlationId, result.cause().getMessage());\n+                    handler.one().handle(result);\n+                });\n+        }\n+    }\n+\n+    /**\n+     * Creates an AMQP message for a subject and address.\n+     * <p>\n+     * The message can be extended by arbitrary application properties passed in.\n+     *\n+     * @param subject The subject system property of the message.\n+     * @param address The address of the message, put in the <em>to</em> property.\n+     * @param appProperties The map containing arbitrary application properties.\n+     *                      Maybe null if no application properties are needed.\n+     * @return The message constructed from the provided parameters.\n+     * @throws NullPointerException if the subject is {@code null}.\n+     * @throws IllegalArgumentException if the application properties contain values of types that are not\n+     *                                  {@linkplain AbstractHonoClient#setApplicationProperties(Message, Map)\n+     *                                  supported by AMQP 1.0}.\n+     */\n+    private Message createMessage(\n+            final String subject,\n+            final String address,\n+            final Map<String, Object> appProperties) {\n+\n+        Objects.requireNonNull(subject);\n+        final Message msg = ProtonHelper.message();\n+        AbstractHonoClient.setApplicationProperties(msg, appProperties);\n+        msg.setAddress(address);\n+        msg.setReplyTo(replyToAddress);\n+        msg.setMessageId(createMessageId());\n+        msg.setSubject(subject);\n+        return msg;\n+    }\n+\n+    /**\n+     * Creates a request message for a payload and headers and sends it to the peer.\n+     * <p>\n+     * This method uses the sender link's target address as the value for the message's\n+     * <em>to</em> property.\n+     * <p>\n+     * This method first checks if the sender has any credit left. If not, a failed future is returned immediately.\n+     * Otherwise, the request message is sent and a timer is started which fails the returned future,\n+     * if no response is received within <em>requestTimeoutMillis</em> milliseconds.\n+     * <p>\n+     * In case of an error the {@code Tags.HTTP_STATUS} tag of the span is set accordingly.\n+     * However, the span is never finished by this method.\n+     *\n+     * @param action The operation that the request is supposed to trigger/invoke.\n+     * @param properties The headers to include in the request message as AMQP application properties.\n+     * @param payload The payload to include in the request message as an AMQP Value section.\n+     * @param contentType The content type of the payload.\n+     * @param responseMapper A function mapping a raw AMQP message to the response type.\n+     * @param currentSpan The <em>Opentracing</em> span used to trace the request execution.\n+     * @return A future indicating the outcome of the operation.\n+     *         The future will be failed with a {@link ServerErrorException} if the request cannot be sent to\n+     *         the remote service, e.g. because there is no connection to the service or there are no credits\n+     *         available for sending the request or the request timed out.\n+     * @throws NullPointerException if any of action, result handler or currentSpan is {@code null}.", "originalCommit": "35acfda23480ce14efcfd2a86129019700ec8835", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODAzNzY0NA==", "url": "https://github.com/eclipse/hono/pull/2382#discussion_r548037644", "bodyText": "No result handler param here.\nIt looks like the responseMapper param mustn't be null instead here. The corresponding null check is missing below.", "author": "calohmn", "createdAt": "2020-12-23T16:22:22Z", "path": "clients/adapter-amqp/src/main/java/org/eclipse/hono/adapter/client/amqp/RequestResponseClient.java", "diffHunk": "@@ -0,0 +1,647 @@\n+/*******************************************************************************\n+ * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.adapter.client.amqp;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+import org.apache.qpid.proton.amqp.messaging.Accepted;\n+import org.apache.qpid.proton.amqp.messaging.Modified;\n+import org.apache.qpid.proton.amqp.messaging.Rejected;\n+import org.apache.qpid.proton.amqp.messaging.Released;\n+import org.apache.qpid.proton.amqp.transport.DeliveryState;\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.RequestResponseClientConfigProperties;\n+import org.eclipse.hono.client.SendMessageSampler;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.RequestResponseResult;\n+import org.eclipse.hono.util.TriTuple;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+import io.vertx.proton.ProtonQoS;\n+import io.vertx.proton.ProtonReceiver;\n+import io.vertx.proton.ProtonSender;\n+\n+/**\n+ * A vertx-proton based client for invoking operations on AMQP 1.0 based service endpoints.\n+ * <p>\n+ * The client holds a sender and a receiver link for sending request messages and receiving\n+ * response messages.\n+ *\n+ * @param <R> The type of result this client expects the service to return.\n+ *\n+ */\n+public class RequestResponseClient<R extends RequestResponseResult<?>> extends AbstractHonoClient {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(RequestResponseClient.class);\n+\n+    /**\n+     * The target address of the sender link used to send requests to the service.\n+     */\n+    private final String linkTargetAddress;\n+    /**\n+     * The source address of the receiver link used to receive responses from the service.\n+     */\n+    private final String replyToAddress;\n+    private final SendMessageSampler sampler;\n+    private final Map<Object, TriTuple<Promise<R>, Function<Message, R>, Span>> replyMap = new HashMap<>();\n+    private final String endpointName;\n+    private final String tenantId;\n+    private long requestTimeoutMillis;\n+\n+    /**\n+     * Creates a request-response client.\n+     * <p>\n+     * The created instance's sender link's target address is set to\n+     * <em>${endpointName}[/${tenantId}]</em> and the receiver link's source\n+     * address is set to <em>${endpointName}[/${tenantId}]/${UUID}</em>\n+     * (where ${UUID} is a generated UUID).\n+     * <p>\n+     * The latter address is also used as the value of the <em>reply-to</em>\n+     * property of all request messages sent by this client.\n+     * <p>\n+     * The client will be ready to use after invoking {@link #createLinks()} or\n+     * {@link #createLinks(Handler, Handler)} only.\n+     *\n+     * @param connection The connection to the service.\n+     * @param endpointName The name of the endpoint to send request messages to.\n+     * @param tenantId The tenant that the client should be scoped to or {@code null} if the\n+     *                 client should not be scoped to a tenant.\n+     * @param sampler The sampler to use.\n+     * @throws NullPointerException if any of the parameters except tenantId is {@code null}.\n+     */\n+    private RequestResponseClient(\n+            final HonoConnection connection,\n+            final String endpointName,\n+            final String tenantId,\n+            final SendMessageSampler sampler) {\n+\n+        this(connection, endpointName, tenantId, UUID.randomUUID().toString(), sampler);\n+    }\n+\n+    /**\n+     * Creates a request-response client.\n+     * <p>\n+     * The created instance's sender link's target address is set to\n+     * <em>${endpointName}[/${tenantId}]</em> and the receiver link's source\n+     * address is set to <em>${endpointName}[/${tenantId}]/${replyId}</em>.\n+     * <p>\n+     * The latter address is also used as the value of the <em>reply-to</em>\n+     * property of all request messages sent by this client.\n+     * <p>\n+     * The client will be ready to use after invoking {@link #createLinks()} or\n+     * {@link #createLinks(Handler, Handler)} only.\n+     *\n+     * @param connection The connection to the service.\n+     * @param endpointName The name of the endpoint to send request messages to.\n+     * @param tenantId The tenant that the client should be scoped to or {@code null} if the\n+     *                 client should not be scoped to a tenant.\n+     * @param replyId The replyId to use in the reply-to address.\n+     * @param sampler The sampler to use.\n+     * @throws NullPointerException if any of the parameters except tenantId is {@code null}.\n+     */\n+    private RequestResponseClient(\n+            final HonoConnection connection,\n+            final String endpointName,\n+            final String tenantId,\n+            final String replyId,\n+            final SendMessageSampler sampler) {\n+\n+        super(connection);\n+        this.endpointName = Objects.requireNonNull(endpointName);\n+        Objects.requireNonNull(replyId);\n+        this.sampler = Objects.requireNonNull(sampler);\n+        this.requestTimeoutMillis = connection.getConfig().getRequestTimeout();\n+        if (tenantId == null) {\n+            this.linkTargetAddress = endpointName;\n+            this.replyToAddress = String.format(\"%s/%s\", endpointName, replyId);\n+        } else {\n+            this.linkTargetAddress = String.format(\"%s/%s\", endpointName, tenantId);\n+            this.replyToAddress = String.format(\"%s/%s/%s\", endpointName, tenantId, replyId);\n+        }\n+        this.tenantId = tenantId;\n+    }\n+\n+    /**\n+     * Creates a request-response client for an endpoint.\n+     * <p>\n+     * The client has a sender and a receiver link opened to the service\n+     * endpoint. The sender link's target address is set to\n+     * <em>${endpointName}[/${tenantId}]</em> and the receiver link's source\n+     * address is set to <em>${endpointName}[/${tenantId}]/${UUID}</em>\n+     * (where ${UUID} is a generated UUID).\n+     * <p>\n+     * The latter address is also used as the value of the <em>reply-to</em>\n+     * property of all request messages sent by the client.\n+     *\n+     * @param <T> The type of response that the client expects the service to return.\n+     * @param connection The connection to the service.\n+     * @param endpointName The name of the endpoint to send request messages to.\n+     * @param tenantId The tenant that the client should be scoped to or {@code null} if the\n+     *                 client should not be scoped to a tenant.\n+     * @param sampler The sampler to use.\n+     * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly (may be {@code null}).\n+     * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly (may be {@code null}).\n+     * @return A future indicating the outcome of creating the client. The future will be failed\n+     *         with a {@link org.eclipse.hono.client.ServiceInvocationException} if the links\n+     *         cannot be opened.\n+     * @throws NullPointerException if any of the parameters except tenantId is {@code null}.\n+     */\n+    public static <T extends RequestResponseResult<?>> Future<RequestResponseClient<T>> forEndpoint(\n+            final HonoConnection connection,\n+            final String endpointName,\n+            final String tenantId,\n+            final SendMessageSampler sampler,\n+            final Handler<String> senderCloseHook,\n+            final Handler<String> receiverCloseHook) {\n+\n+        final RequestResponseClient<T> result = new RequestResponseClient<>(connection, endpointName, tenantId, sampler);\n+        return result.createLinks(senderCloseHook, receiverCloseHook).map(result);\n+    }\n+\n+    /**\n+     * Gets the default value for the period of time after which an entry in the response cache\n+     * is considered invalid.\n+     * <p>\n+     * The value is derived from the configuration properties as follows:\n+     * <ol>\n+     * <li>if the properties are of type {@link RequestResponseClientConfigProperties}\n+     * then the value of its <em>responseCacheDefaultTimeout</em> property is used</li>\n+     * <li>otherwise the {@linkplain RequestResponseClientConfigProperties#DEFAULT_RESPONSE_CACHE_TIMEOUT\n+     * default timeout value} is used</li>\n+     * </ol>\n+     *\n+     * @return The timeout period in seconds.\n+     */\n+    protected final long getResponseCacheDefaultTimeout() {\n+        if (connection.getConfig() instanceof RequestResponseClientConfigProperties) {\n+            return ((RequestResponseClientConfigProperties) connection.getConfig()).getResponseCacheDefaultTimeout();\n+        } else {\n+            return RequestResponseClientConfigProperties.DEFAULT_RESPONSE_CACHE_TIMEOUT;\n+        }\n+    }\n+\n+    /**\n+     * Sets the period of time after which any requests are considered to have timed out.\n+     * <p>\n+     * The client will fail the result handler passed in to any of the operations if no response\n+     * has been received from the peer after the given amount of time.\n+     * <p>\n+     * When setting this property to 0, requests do not time out at all. Note that this will\n+     * allow for unanswered requests piling up in the client, which eventually may cause the\n+     * client to run out of memory.\n+     * <p>\n+     * The default value of this property is 200 milliseconds.\n+     *\n+     * @param timoutMillis The number of milliseconds after which a request is considered to have timed out.\n+     * @throws IllegalArgumentException if the value is &lt; 0\n+     */\n+    public final void setRequestTimeout(final long timoutMillis) {\n+\n+        if (timoutMillis < 0) {\n+            throw new IllegalArgumentException(\"request timeout must be >= 0\");\n+        } else {\n+            this.requestTimeoutMillis = timoutMillis;\n+        }\n+    }\n+\n+    /**\n+     * Build a unique messageId for a request that serves as an identifier for a new message.\n+     *\n+     * @return The unique messageId;\n+     */\n+    private String createMessageId() {\n+        return String.format(\"%s-client-%s\", endpointName, UUID.randomUUID());\n+    }\n+\n+    /**\n+     * Creates the sender and receiver links to the peer for sending requests\n+     * and receiving responses.\n+     *\n+     * @return A future indicating the outcome. The future will succeed if the links\n+     *         have been created.\n+     * @throws NullPointerException if con is {@code null}.\n+     */\n+    public final Future<Void> createLinks() {\n+        return createLinks(null, null);\n+    }\n+\n+    /**\n+     * Creates the sender and receiver links to the peer for sending requests\n+     * and receiving responses.\n+     *\n+     * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly (may be {@code null}).\n+     * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly (may be {@code null}).\n+     * @return A future indicating the outcome. The future will succeed if the links\n+     *         have been created.\n+     */\n+    public final Future<Void> createLinks(\n+            final Handler<String> senderCloseHook,\n+            final Handler<String> receiverCloseHook) {\n+\n+        return createReceiver(replyToAddress, receiverCloseHook)\n+                .compose(recv -> {\n+                    this.receiver = recv;\n+                    return createSender(linkTargetAddress, senderCloseHook);\n+                })\n+                .compose(sender -> {\n+                    LOG.debug(\"request-response client for peer [{}] created\", connection.getConfig().getHost());\n+                    this.offeredCapabilities = Optional.ofNullable(sender.getRemoteOfferedCapabilities())\n+                            .map(caps -> Collections.unmodifiableList(Arrays.asList(caps)))\n+                            .orElse(Collections.emptyList());\n+                    this.sender = sender;\n+                    return Future.succeededFuture();\n+                });\n+    }\n+\n+    private Future<ProtonSender> createSender(final String targetAddress, final Handler<String> closeHook) {\n+\n+        return connection.createSender(targetAddress, ProtonQoS.AT_LEAST_ONCE, closeHook);\n+    }\n+\n+    private Future<ProtonReceiver> createReceiver(final String sourceAddress, final Handler<String> closeHook) {\n+\n+        return connection.createReceiver(sourceAddress, ProtonQoS.AT_LEAST_ONCE, this::handleResponse, closeHook);\n+    }\n+\n+    /**\n+     * Handles a response received from the peer.\n+     * <p>\n+     * In particular, this method tries to correlate the message with a previous request\n+     * using the message's <em>correlation-id</em> and, if successful, the delivery is <em>accepted</em>\n+     * and the message is passed to the handler registered with the original request.\n+     * <p>\n+     * If the response cannot be correlated to a request, e.g. because the request has timed\n+     * out, then the delivery is <em>released</em> and the message is silently discarded.\n+     *\n+     * @param delivery The handle for accessing the message's disposition.\n+     * @param message The response message.\n+     */\n+    private void handleResponse(final ProtonDelivery delivery, final Message message) {\n+\n+        // the tuple from the reply map contains\n+        // 1. the handler for processing the response and\n+        // 2. the function for mapping the raw AMQP message to the response type\n+        // 3. the Opentracing span covering the execution\n+        final TriTuple<Promise<R>, Function<Message, R>, Span> handler = replyMap.remove(message.getCorrelationId());\n+\n+        if (handler == null) {\n+            LOG.debug(\"discarding unexpected response [reply-to: {}, correlation ID: {}]\",\n+                    replyToAddress, message.getCorrelationId());\n+            ProtonHelper.rejected(delivery, true);\n+        } else {\n+            final R response = handler.two().apply(message);\n+            final Span span = handler.three();\n+            if (response == null) {\n+                LOG.debug(\"discarding malformed response [reply-to: {}, correlation ID: {}]\",\n+                        replyToAddress, message.getCorrelationId());\n+                handler.one().handle(Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                        \"cannot process response from service [\" + endpointName + \"]\")));\n+                ProtonHelper.released(delivery, true);\n+            } else {\n+                LOG.debug(\"received response [reply-to: {}, subject: {}, correlation ID: {}, status: {}, cache-directive: {}]\",\n+                        replyToAddress, message.getSubject(), message.getCorrelationId(), response.getStatus(), response.getCacheDirective());\n+                if (span != null) {\n+                    span.log(\"response from peer accepted\");\n+                }\n+                handler.one().handle(Future.succeededFuture(response));\n+                ProtonHelper.accepted(delivery, true);\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Cancels an outstanding request with a given result.\n+     *\n+     * @param correlationId The identifier of the request to cancel.\n+     * @param result The result to pass to the result handler registered for the correlation ID.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     * @throws IllegalArgumentException if the result is succeeded.\n+     */\n+    private void cancelRequest(final Object correlationId, final AsyncResult<R> result) {\n+\n+        Objects.requireNonNull(correlationId);\n+        Objects.requireNonNull(result);\n+\n+        if (result.succeeded()) {\n+            throw new IllegalArgumentException(\"result must be failed\");\n+        } else {\n+            Optional.ofNullable(replyMap.remove(correlationId))\n+                .ifPresent(handler -> {\n+                    LOG.debug(\"canceling request [target: {}, correlation ID: {}]: {}\",\n+                            linkTargetAddress, correlationId, result.cause().getMessage());\n+                    handler.one().handle(result);\n+                });\n+        }\n+    }\n+\n+    /**\n+     * Creates an AMQP message for a subject and address.\n+     * <p>\n+     * The message can be extended by arbitrary application properties passed in.\n+     *\n+     * @param subject The subject system property of the message.\n+     * @param address The address of the message, put in the <em>to</em> property.\n+     * @param appProperties The map containing arbitrary application properties.\n+     *                      Maybe null if no application properties are needed.\n+     * @return The message constructed from the provided parameters.\n+     * @throws NullPointerException if the subject is {@code null}.\n+     * @throws IllegalArgumentException if the application properties contain values of types that are not\n+     *                                  {@linkplain AbstractHonoClient#setApplicationProperties(Message, Map)\n+     *                                  supported by AMQP 1.0}.\n+     */\n+    private Message createMessage(\n+            final String subject,\n+            final String address,\n+            final Map<String, Object> appProperties) {\n+\n+        Objects.requireNonNull(subject);\n+        final Message msg = ProtonHelper.message();\n+        AbstractHonoClient.setApplicationProperties(msg, appProperties);\n+        msg.setAddress(address);\n+        msg.setReplyTo(replyToAddress);\n+        msg.setMessageId(createMessageId());\n+        msg.setSubject(subject);\n+        return msg;\n+    }\n+\n+    /**\n+     * Creates a request message for a payload and headers and sends it to the peer.\n+     * <p>\n+     * This method uses the sender link's target address as the value for the message's\n+     * <em>to</em> property.\n+     * <p>\n+     * This method first checks if the sender has any credit left. If not, a failed future is returned immediately.\n+     * Otherwise, the request message is sent and a timer is started which fails the returned future,\n+     * if no response is received within <em>requestTimeoutMillis</em> milliseconds.\n+     * <p>\n+     * In case of an error the {@code Tags.HTTP_STATUS} tag of the span is set accordingly.\n+     * However, the span is never finished by this method.\n+     *\n+     * @param action The operation that the request is supposed to trigger/invoke.\n+     * @param properties The headers to include in the request message as AMQP application properties.\n+     * @param payload The payload to include in the request message as an AMQP Value section.\n+     * @param contentType The content type of the payload.\n+     * @param responseMapper A function mapping a raw AMQP message to the response type.\n+     * @param currentSpan The <em>Opentracing</em> span used to trace the request execution.\n+     * @return A future indicating the outcome of the operation.\n+     *         The future will be failed with a {@link ServerErrorException} if the request cannot be sent to\n+     *         the remote service, e.g. because there is no connection to the service or there are no credits\n+     *         available for sending the request or the request timed out.\n+     * @throws NullPointerException if any of action, result handler or currentSpan is {@code null}.\n+     * @throws IllegalArgumentException if the properties contain any non-primitive typed values.\n+     * @see AbstractHonoClient#setApplicationProperties(Message, Map)\n+     */\n+    public final Future<R> createAndSendRequest(\n+            final String action,\n+            final Map<String, Object> properties,\n+            final Buffer payload,\n+            final String contentType,\n+            final Function<Message, R> responseMapper,\n+            final Span currentSpan) {\n+\n+        return createAndSendRequest(\n+                action,\n+                linkTargetAddress,\n+                properties,\n+                payload,\n+                contentType,\n+                responseMapper,\n+                currentSpan);\n+    }\n+\n+    /**\n+     * Creates a request message for a payload and headers and sends it to the peer.\n+     * <p>\n+     * This method first checks if the sender has any credit left. If not, a failed future is returned immediately.\n+     * Otherwise, the request message is sent and a timer is started which fails the returned future,\n+     * if no response is received within <em>requestTimeoutMillis</em> milliseconds.\n+     * <p>\n+     * In case of an error the {@code Tags.HTTP_STATUS} tag of the span is set accordingly.\n+     * However, the span is never finished by this method.\n+     *\n+     * @param action The operation that the request is supposed to trigger/invoke.\n+     * @param address The address to send the message to.\n+     * @param properties The headers to include in the request message as AMQP application properties.\n+     * @param payload The payload to include in the request message as an AMQP Value section.\n+     * @param contentType The content type of the payload.\n+     * @param responseMapper A function mapping a raw AMQP message to the response type.\n+     * @param currentSpan The <em>Opentracing</em> span used to trace the request execution.\n+     * @return A future indicating the outcome of the operation.\n+     *         The future will be failed with a {@link ServerErrorException} if the request cannot be sent to\n+     *         the remote service, e.g. because there is no connection to the service or there are no credits\n+     *         available for sending the request or the request timed out.\n+     * @throws NullPointerException if any of action, result handler or currentSpan is {@code null}.", "originalCommit": "35acfda23480ce14efcfd2a86129019700ec8835", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODA0NTYyMg==", "url": "https://github.com/eclipse/hono/pull/2382#discussion_r548045622", "bodyText": "Could be refactored to return Future<Void> instead of taking the handler parameter (which would be in line with createLinks for example).", "author": "calohmn", "createdAt": "2020-12-23T16:39:42Z", "path": "clients/adapter-amqp/src/main/java/org/eclipse/hono/adapter/client/amqp/RequestResponseClient.java", "diffHunk": "@@ -0,0 +1,647 @@\n+/*******************************************************************************\n+ * Copyright (c) 2016, 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.hono.adapter.client.amqp;\n+\n+import java.net.HttpURLConnection;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.UUID;\n+import java.util.function.Function;\n+\n+import org.apache.qpid.proton.amqp.messaging.Accepted;\n+import org.apache.qpid.proton.amqp.messaging.Modified;\n+import org.apache.qpid.proton.amqp.messaging.Rejected;\n+import org.apache.qpid.proton.amqp.messaging.Released;\n+import org.apache.qpid.proton.amqp.transport.DeliveryState;\n+import org.apache.qpid.proton.message.Message;\n+import org.eclipse.hono.client.ClientErrorException;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.RequestResponseClientConfigProperties;\n+import org.eclipse.hono.client.SendMessageSampler;\n+import org.eclipse.hono.client.ServerErrorException;\n+import org.eclipse.hono.client.StatusCodeMapper;\n+import org.eclipse.hono.tracing.TracingHelper;\n+import org.eclipse.hono.util.MessageHelper;\n+import org.eclipse.hono.util.RequestResponseResult;\n+import org.eclipse.hono.util.TriTuple;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import io.opentracing.Span;\n+import io.opentracing.tag.Tags;\n+import io.vertx.core.AsyncResult;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.core.Promise;\n+import io.vertx.core.buffer.Buffer;\n+import io.vertx.proton.ProtonDelivery;\n+import io.vertx.proton.ProtonHelper;\n+import io.vertx.proton.ProtonQoS;\n+import io.vertx.proton.ProtonReceiver;\n+import io.vertx.proton.ProtonSender;\n+\n+/**\n+ * A vertx-proton based client for invoking operations on AMQP 1.0 based service endpoints.\n+ * <p>\n+ * The client holds a sender and a receiver link for sending request messages and receiving\n+ * response messages.\n+ *\n+ * @param <R> The type of result this client expects the service to return.\n+ *\n+ */\n+public class RequestResponseClient<R extends RequestResponseResult<?>> extends AbstractHonoClient {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(RequestResponseClient.class);\n+\n+    /**\n+     * The target address of the sender link used to send requests to the service.\n+     */\n+    private final String linkTargetAddress;\n+    /**\n+     * The source address of the receiver link used to receive responses from the service.\n+     */\n+    private final String replyToAddress;\n+    private final SendMessageSampler sampler;\n+    private final Map<Object, TriTuple<Promise<R>, Function<Message, R>, Span>> replyMap = new HashMap<>();\n+    private final String endpointName;\n+    private final String tenantId;\n+    private long requestTimeoutMillis;\n+\n+    /**\n+     * Creates a request-response client.\n+     * <p>\n+     * The created instance's sender link's target address is set to\n+     * <em>${endpointName}[/${tenantId}]</em> and the receiver link's source\n+     * address is set to <em>${endpointName}[/${tenantId}]/${UUID}</em>\n+     * (where ${UUID} is a generated UUID).\n+     * <p>\n+     * The latter address is also used as the value of the <em>reply-to</em>\n+     * property of all request messages sent by this client.\n+     * <p>\n+     * The client will be ready to use after invoking {@link #createLinks()} or\n+     * {@link #createLinks(Handler, Handler)} only.\n+     *\n+     * @param connection The connection to the service.\n+     * @param endpointName The name of the endpoint to send request messages to.\n+     * @param tenantId The tenant that the client should be scoped to or {@code null} if the\n+     *                 client should not be scoped to a tenant.\n+     * @param sampler The sampler to use.\n+     * @throws NullPointerException if any of the parameters except tenantId is {@code null}.\n+     */\n+    private RequestResponseClient(\n+            final HonoConnection connection,\n+            final String endpointName,\n+            final String tenantId,\n+            final SendMessageSampler sampler) {\n+\n+        this(connection, endpointName, tenantId, UUID.randomUUID().toString(), sampler);\n+    }\n+\n+    /**\n+     * Creates a request-response client.\n+     * <p>\n+     * The created instance's sender link's target address is set to\n+     * <em>${endpointName}[/${tenantId}]</em> and the receiver link's source\n+     * address is set to <em>${endpointName}[/${tenantId}]/${replyId}</em>.\n+     * <p>\n+     * The latter address is also used as the value of the <em>reply-to</em>\n+     * property of all request messages sent by this client.\n+     * <p>\n+     * The client will be ready to use after invoking {@link #createLinks()} or\n+     * {@link #createLinks(Handler, Handler)} only.\n+     *\n+     * @param connection The connection to the service.\n+     * @param endpointName The name of the endpoint to send request messages to.\n+     * @param tenantId The tenant that the client should be scoped to or {@code null} if the\n+     *                 client should not be scoped to a tenant.\n+     * @param replyId The replyId to use in the reply-to address.\n+     * @param sampler The sampler to use.\n+     * @throws NullPointerException if any of the parameters except tenantId is {@code null}.\n+     */\n+    private RequestResponseClient(\n+            final HonoConnection connection,\n+            final String endpointName,\n+            final String tenantId,\n+            final String replyId,\n+            final SendMessageSampler sampler) {\n+\n+        super(connection);\n+        this.endpointName = Objects.requireNonNull(endpointName);\n+        Objects.requireNonNull(replyId);\n+        this.sampler = Objects.requireNonNull(sampler);\n+        this.requestTimeoutMillis = connection.getConfig().getRequestTimeout();\n+        if (tenantId == null) {\n+            this.linkTargetAddress = endpointName;\n+            this.replyToAddress = String.format(\"%s/%s\", endpointName, replyId);\n+        } else {\n+            this.linkTargetAddress = String.format(\"%s/%s\", endpointName, tenantId);\n+            this.replyToAddress = String.format(\"%s/%s/%s\", endpointName, tenantId, replyId);\n+        }\n+        this.tenantId = tenantId;\n+    }\n+\n+    /**\n+     * Creates a request-response client for an endpoint.\n+     * <p>\n+     * The client has a sender and a receiver link opened to the service\n+     * endpoint. The sender link's target address is set to\n+     * <em>${endpointName}[/${tenantId}]</em> and the receiver link's source\n+     * address is set to <em>${endpointName}[/${tenantId}]/${UUID}</em>\n+     * (where ${UUID} is a generated UUID).\n+     * <p>\n+     * The latter address is also used as the value of the <em>reply-to</em>\n+     * property of all request messages sent by the client.\n+     *\n+     * @param <T> The type of response that the client expects the service to return.\n+     * @param connection The connection to the service.\n+     * @param endpointName The name of the endpoint to send request messages to.\n+     * @param tenantId The tenant that the client should be scoped to or {@code null} if the\n+     *                 client should not be scoped to a tenant.\n+     * @param sampler The sampler to use.\n+     * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly (may be {@code null}).\n+     * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly (may be {@code null}).\n+     * @return A future indicating the outcome of creating the client. The future will be failed\n+     *         with a {@link org.eclipse.hono.client.ServiceInvocationException} if the links\n+     *         cannot be opened.\n+     * @throws NullPointerException if any of the parameters except tenantId is {@code null}.\n+     */\n+    public static <T extends RequestResponseResult<?>> Future<RequestResponseClient<T>> forEndpoint(\n+            final HonoConnection connection,\n+            final String endpointName,\n+            final String tenantId,\n+            final SendMessageSampler sampler,\n+            final Handler<String> senderCloseHook,\n+            final Handler<String> receiverCloseHook) {\n+\n+        final RequestResponseClient<T> result = new RequestResponseClient<>(connection, endpointName, tenantId, sampler);\n+        return result.createLinks(senderCloseHook, receiverCloseHook).map(result);\n+    }\n+\n+    /**\n+     * Gets the default value for the period of time after which an entry in the response cache\n+     * is considered invalid.\n+     * <p>\n+     * The value is derived from the configuration properties as follows:\n+     * <ol>\n+     * <li>if the properties are of type {@link RequestResponseClientConfigProperties}\n+     * then the value of its <em>responseCacheDefaultTimeout</em> property is used</li>\n+     * <li>otherwise the {@linkplain RequestResponseClientConfigProperties#DEFAULT_RESPONSE_CACHE_TIMEOUT\n+     * default timeout value} is used</li>\n+     * </ol>\n+     *\n+     * @return The timeout period in seconds.\n+     */\n+    protected final long getResponseCacheDefaultTimeout() {\n+        if (connection.getConfig() instanceof RequestResponseClientConfigProperties) {\n+            return ((RequestResponseClientConfigProperties) connection.getConfig()).getResponseCacheDefaultTimeout();\n+        } else {\n+            return RequestResponseClientConfigProperties.DEFAULT_RESPONSE_CACHE_TIMEOUT;\n+        }\n+    }\n+\n+    /**\n+     * Sets the period of time after which any requests are considered to have timed out.\n+     * <p>\n+     * The client will fail the result handler passed in to any of the operations if no response\n+     * has been received from the peer after the given amount of time.\n+     * <p>\n+     * When setting this property to 0, requests do not time out at all. Note that this will\n+     * allow for unanswered requests piling up in the client, which eventually may cause the\n+     * client to run out of memory.\n+     * <p>\n+     * The default value of this property is 200 milliseconds.\n+     *\n+     * @param timoutMillis The number of milliseconds after which a request is considered to have timed out.\n+     * @throws IllegalArgumentException if the value is &lt; 0\n+     */\n+    public final void setRequestTimeout(final long timoutMillis) {\n+\n+        if (timoutMillis < 0) {\n+            throw new IllegalArgumentException(\"request timeout must be >= 0\");\n+        } else {\n+            this.requestTimeoutMillis = timoutMillis;\n+        }\n+    }\n+\n+    /**\n+     * Build a unique messageId for a request that serves as an identifier for a new message.\n+     *\n+     * @return The unique messageId;\n+     */\n+    private String createMessageId() {\n+        return String.format(\"%s-client-%s\", endpointName, UUID.randomUUID());\n+    }\n+\n+    /**\n+     * Creates the sender and receiver links to the peer for sending requests\n+     * and receiving responses.\n+     *\n+     * @return A future indicating the outcome. The future will succeed if the links\n+     *         have been created.\n+     * @throws NullPointerException if con is {@code null}.\n+     */\n+    public final Future<Void> createLinks() {\n+        return createLinks(null, null);\n+    }\n+\n+    /**\n+     * Creates the sender and receiver links to the peer for sending requests\n+     * and receiving responses.\n+     *\n+     * @param senderCloseHook A handler to invoke if the peer closes the sender link unexpectedly (may be {@code null}).\n+     * @param receiverCloseHook A handler to invoke if the peer closes the receiver link unexpectedly (may be {@code null}).\n+     * @return A future indicating the outcome. The future will succeed if the links\n+     *         have been created.\n+     */\n+    public final Future<Void> createLinks(\n+            final Handler<String> senderCloseHook,\n+            final Handler<String> receiverCloseHook) {\n+\n+        return createReceiver(replyToAddress, receiverCloseHook)\n+                .compose(recv -> {\n+                    this.receiver = recv;\n+                    return createSender(linkTargetAddress, senderCloseHook);\n+                })\n+                .compose(sender -> {\n+                    LOG.debug(\"request-response client for peer [{}] created\", connection.getConfig().getHost());\n+                    this.offeredCapabilities = Optional.ofNullable(sender.getRemoteOfferedCapabilities())\n+                            .map(caps -> Collections.unmodifiableList(Arrays.asList(caps)))\n+                            .orElse(Collections.emptyList());\n+                    this.sender = sender;\n+                    return Future.succeededFuture();\n+                });\n+    }\n+\n+    private Future<ProtonSender> createSender(final String targetAddress, final Handler<String> closeHook) {\n+\n+        return connection.createSender(targetAddress, ProtonQoS.AT_LEAST_ONCE, closeHook);\n+    }\n+\n+    private Future<ProtonReceiver> createReceiver(final String sourceAddress, final Handler<String> closeHook) {\n+\n+        return connection.createReceiver(sourceAddress, ProtonQoS.AT_LEAST_ONCE, this::handleResponse, closeHook);\n+    }\n+\n+    /**\n+     * Handles a response received from the peer.\n+     * <p>\n+     * In particular, this method tries to correlate the message with a previous request\n+     * using the message's <em>correlation-id</em> and, if successful, the delivery is <em>accepted</em>\n+     * and the message is passed to the handler registered with the original request.\n+     * <p>\n+     * If the response cannot be correlated to a request, e.g. because the request has timed\n+     * out, then the delivery is <em>released</em> and the message is silently discarded.\n+     *\n+     * @param delivery The handle for accessing the message's disposition.\n+     * @param message The response message.\n+     */\n+    private void handleResponse(final ProtonDelivery delivery, final Message message) {\n+\n+        // the tuple from the reply map contains\n+        // 1. the handler for processing the response and\n+        // 2. the function for mapping the raw AMQP message to the response type\n+        // 3. the Opentracing span covering the execution\n+        final TriTuple<Promise<R>, Function<Message, R>, Span> handler = replyMap.remove(message.getCorrelationId());\n+\n+        if (handler == null) {\n+            LOG.debug(\"discarding unexpected response [reply-to: {}, correlation ID: {}]\",\n+                    replyToAddress, message.getCorrelationId());\n+            ProtonHelper.rejected(delivery, true);\n+        } else {\n+            final R response = handler.two().apply(message);\n+            final Span span = handler.three();\n+            if (response == null) {\n+                LOG.debug(\"discarding malformed response [reply-to: {}, correlation ID: {}]\",\n+                        replyToAddress, message.getCorrelationId());\n+                handler.one().handle(Future.failedFuture(new ServerErrorException(HttpURLConnection.HTTP_INTERNAL_ERROR,\n+                        \"cannot process response from service [\" + endpointName + \"]\")));\n+                ProtonHelper.released(delivery, true);\n+            } else {\n+                LOG.debug(\"received response [reply-to: {}, subject: {}, correlation ID: {}, status: {}, cache-directive: {}]\",\n+                        replyToAddress, message.getSubject(), message.getCorrelationId(), response.getStatus(), response.getCacheDirective());\n+                if (span != null) {\n+                    span.log(\"response from peer accepted\");\n+                }\n+                handler.one().handle(Future.succeededFuture(response));\n+                ProtonHelper.accepted(delivery, true);\n+            }\n+        }\n+    }\n+\n+\n+    /**\n+     * Cancels an outstanding request with a given result.\n+     *\n+     * @param correlationId The identifier of the request to cancel.\n+     * @param result The result to pass to the result handler registered for the correlation ID.\n+     * @throws NullPointerException if any of the parameters is {@code null}.\n+     * @throws IllegalArgumentException if the result is succeeded.\n+     */\n+    private void cancelRequest(final Object correlationId, final AsyncResult<R> result) {\n+\n+        Objects.requireNonNull(correlationId);\n+        Objects.requireNonNull(result);\n+\n+        if (result.succeeded()) {\n+            throw new IllegalArgumentException(\"result must be failed\");\n+        } else {\n+            Optional.ofNullable(replyMap.remove(correlationId))\n+                .ifPresent(handler -> {\n+                    LOG.debug(\"canceling request [target: {}, correlation ID: {}]: {}\",\n+                            linkTargetAddress, correlationId, result.cause().getMessage());\n+                    handler.one().handle(result);\n+                });\n+        }\n+    }\n+\n+    /**\n+     * Creates an AMQP message for a subject and address.\n+     * <p>\n+     * The message can be extended by arbitrary application properties passed in.\n+     *\n+     * @param subject The subject system property of the message.\n+     * @param address The address of the message, put in the <em>to</em> property.\n+     * @param appProperties The map containing arbitrary application properties.\n+     *                      Maybe null if no application properties are needed.\n+     * @return The message constructed from the provided parameters.\n+     * @throws NullPointerException if the subject is {@code null}.\n+     * @throws IllegalArgumentException if the application properties contain values of types that are not\n+     *                                  {@linkplain AbstractHonoClient#setApplicationProperties(Message, Map)\n+     *                                  supported by AMQP 1.0}.\n+     */\n+    private Message createMessage(\n+            final String subject,\n+            final String address,\n+            final Map<String, Object> appProperties) {\n+\n+        Objects.requireNonNull(subject);\n+        final Message msg = ProtonHelper.message();\n+        AbstractHonoClient.setApplicationProperties(msg, appProperties);\n+        msg.setAddress(address);\n+        msg.setReplyTo(replyToAddress);\n+        msg.setMessageId(createMessageId());\n+        msg.setSubject(subject);\n+        return msg;\n+    }\n+\n+    /**\n+     * Creates a request message for a payload and headers and sends it to the peer.\n+     * <p>\n+     * This method uses the sender link's target address as the value for the message's\n+     * <em>to</em> property.\n+     * <p>\n+     * This method first checks if the sender has any credit left. If not, a failed future is returned immediately.\n+     * Otherwise, the request message is sent and a timer is started which fails the returned future,\n+     * if no response is received within <em>requestTimeoutMillis</em> milliseconds.\n+     * <p>\n+     * In case of an error the {@code Tags.HTTP_STATUS} tag of the span is set accordingly.\n+     * However, the span is never finished by this method.\n+     *\n+     * @param action The operation that the request is supposed to trigger/invoke.\n+     * @param properties The headers to include in the request message as AMQP application properties.\n+     * @param payload The payload to include in the request message as an AMQP Value section.\n+     * @param contentType The content type of the payload.\n+     * @param responseMapper A function mapping a raw AMQP message to the response type.\n+     * @param currentSpan The <em>Opentracing</em> span used to trace the request execution.\n+     * @return A future indicating the outcome of the operation.\n+     *         The future will be failed with a {@link ServerErrorException} if the request cannot be sent to\n+     *         the remote service, e.g. because there is no connection to the service or there are no credits\n+     *         available for sending the request or the request timed out.\n+     * @throws NullPointerException if any of action, result handler or currentSpan is {@code null}.\n+     * @throws IllegalArgumentException if the properties contain any non-primitive typed values.\n+     * @see AbstractHonoClient#setApplicationProperties(Message, Map)\n+     */\n+    public final Future<R> createAndSendRequest(\n+            final String action,\n+            final Map<String, Object> properties,\n+            final Buffer payload,\n+            final String contentType,\n+            final Function<Message, R> responseMapper,\n+            final Span currentSpan) {\n+\n+        return createAndSendRequest(\n+                action,\n+                linkTargetAddress,\n+                properties,\n+                payload,\n+                contentType,\n+                responseMapper,\n+                currentSpan);\n+    }\n+\n+    /**\n+     * Creates a request message for a payload and headers and sends it to the peer.\n+     * <p>\n+     * This method first checks if the sender has any credit left. If not, a failed future is returned immediately.\n+     * Otherwise, the request message is sent and a timer is started which fails the returned future,\n+     * if no response is received within <em>requestTimeoutMillis</em> milliseconds.\n+     * <p>\n+     * In case of an error the {@code Tags.HTTP_STATUS} tag of the span is set accordingly.\n+     * However, the span is never finished by this method.\n+     *\n+     * @param action The operation that the request is supposed to trigger/invoke.\n+     * @param address The address to send the message to.\n+     * @param properties The headers to include in the request message as AMQP application properties.\n+     * @param payload The payload to include in the request message as an AMQP Value section.\n+     * @param contentType The content type of the payload.\n+     * @param responseMapper A function mapping a raw AMQP message to the response type.\n+     * @param currentSpan The <em>Opentracing</em> span used to trace the request execution.\n+     * @return A future indicating the outcome of the operation.\n+     *         The future will be failed with a {@link ServerErrorException} if the request cannot be sent to\n+     *         the remote service, e.g. because there is no connection to the service or there are no credits\n+     *         available for sending the request or the request timed out.\n+     * @throws NullPointerException if any of action, result handler or currentSpan is {@code null}.\n+     * @throws IllegalArgumentException if the properties contain any non-primitive typed values.\n+     * @see AbstractHonoClient#setApplicationProperties(Message, Map)\n+     */\n+    private Future<R> createAndSendRequest(\n+            final String action,\n+            final String address,\n+            final Map<String, Object> properties,\n+            final Buffer payload,\n+            final String contentType,\n+            final Function<Message, R> responseMapper,\n+            final Span currentSpan) {\n+\n+        Objects.requireNonNull(action);\n+        Objects.requireNonNull(currentSpan);\n+\n+        if (isOpen()) {\n+            final Message request = createMessage(action, address, properties);\n+            MessageHelper.setPayload(request, contentType, payload);\n+            return sendRequest(request, responseMapper, currentSpan);\n+        } else {\n+             return Future.failedFuture(new ServerErrorException(\n+                    HttpURLConnection.HTTP_UNAVAILABLE, \"sender and/or receiver link is not open\"));\n+        }\n+    }\n+\n+    /**\n+     * Sends a request message via this client's sender link to the peer.\n+     * <p>\n+     * This method first checks if the sender has any credit left. If not, the result handler is failed immediately.\n+     * Otherwise, the request message is sent and a timer is started which fails the result handler,\n+     * if no response is received within <em>requestTimeoutMillis</em> milliseconds.\n+     * <p>\n+     * The given span is never finished by this method.\n+     *\n+     * @param request The message to send.\n+     * @param responseMapper A function mapping a raw AMQP message to the response type.\n+     * @param currentSpan The <em>Opentracing</em> span used to trace the request execution.\n+     * @return A future indicating the outcome of the operation.\n+     *         The future will be failed with a {@link ServerErrorException} if the request cannot be sent to\n+     *         the remote service, e.g. because there is no connection to the service or there are no credits\n+     *         available for sending the request or the request timed out.\n+     */\n+    private Future<R> sendRequest(\n+            final Message request,\n+            final Function<Message, R> responseMapper,\n+            final Span currentSpan) {\n+\n+        final String requestTargetAddress = Optional.ofNullable(request.getAddress()).orElse(linkTargetAddress);\n+        Tags.MESSAGE_BUS_DESTINATION.set(currentSpan, requestTargetAddress);\n+        Tags.SPAN_KIND.set(currentSpan, Tags.SPAN_KIND_CLIENT);\n+        Tags.HTTP_METHOD.set(currentSpan, request.getSubject());\n+        if (tenantId != null) {\n+            currentSpan.setTag(MessageHelper.APP_PROPERTY_TENANT_ID, tenantId);\n+        }\n+\n+        return connection.executeOnContext((Promise<R> res) -> {\n+\n+            if (sender.sendQueueFull()) {\n+\n+                LOG.debug(\"cannot send request to peer, no credit left for link [link target: {}]\", linkTargetAddress);\n+                res.fail(new ServerErrorException(\n+                        HttpURLConnection.HTTP_UNAVAILABLE, \"no credit available for sending request\"));\n+\n+                sampler.queueFull(tenantId);\n+\n+            } else {\n+\n+                final Map<String, Object> details = new HashMap<>(3);\n+                final Object correlationId = Optional.ofNullable(request.getCorrelationId()).orElse(request.getMessageId());\n+                if (correlationId instanceof String) {\n+                    details.put(TracingHelper.TAG_CORRELATION_ID.getKey(), correlationId);\n+                }\n+                details.put(TracingHelper.TAG_CREDIT.getKey(), sender.getCredit());\n+                details.put(TracingHelper.TAG_QOS.getKey(), sender.getQoS().toString());\n+                currentSpan.log(details);\n+\n+                final TriTuple<Promise<R>, Function<Message, R>, Span> handler = TriTuple.of(res, responseMapper, currentSpan);\n+                TracingHelper.injectSpanContext(connection.getTracer(), currentSpan.context(), request);\n+                replyMap.put(correlationId, handler);\n+\n+                final SendMessageSampler.Sample sample = sampler.start(tenantId);\n+\n+                sender.send(request, deliveryUpdated -> {\n+                    final Promise<R> failedResult = Promise.promise();\n+                    final DeliveryState remoteState = deliveryUpdated.getRemoteState();\n+                    sample.completed(remoteState);\n+                    if (Rejected.class.isInstance(remoteState)) {\n+                        final Rejected rejected = (Rejected) remoteState;\n+                        if (rejected.getError() != null) {\n+                            LOG.debug(\"service did not accept request [target address: {}, subject: {}, correlation ID: {}]: {}\",\n+                                    requestTargetAddress, request.getSubject(), correlationId, rejected.getError());\n+                            failedResult.fail(StatusCodeMapper.from(rejected.getError()));\n+                            cancelRequest(correlationId, failedResult.future());\n+                        } else {\n+                            LOG.debug(\"service did not accept request [target address: {}, subject: {}, correlation ID: {}]\",\n+                                    requestTargetAddress, request.getSubject(), correlationId);\n+                            failedResult.fail(new ClientErrorException(HttpURLConnection.HTTP_BAD_REQUEST));\n+                            cancelRequest(correlationId, failedResult.future());\n+                        }\n+                    } else if (Accepted.class.isInstance(remoteState)) {\n+                        LOG.trace(\"service has accepted request [target address: {}, subject: {}, correlation ID: {}]\",\n+                                requestTargetAddress, request.getSubject(), correlationId);\n+                        currentSpan.log(\"request accepted by peer\");\n+                        // if no reply-to is set, the request is assumed to be one-way (no response is expected)\n+                        if (request.getReplyTo() == null) {\n+                            if (replyMap.remove(correlationId) != null) {\n+                                res.complete();\n+                            } else {\n+                                LOG.trace(\"accepted request won't be acted upon, request already cancelled [target address: {}, subject: {}, correlation ID: {}]\",\n+                                        requestTargetAddress, request.getSubject(), correlationId);\n+                            }\n+                        }\n+                    } else if (Released.class.isInstance(remoteState)) {\n+                        LOG.debug(\"service did not accept request [target address: {}, subject: {}, correlation ID: {}], remote state: {}\",\n+                                requestTargetAddress, request.getSubject(), correlationId, remoteState);\n+                        failedResult.fail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE));\n+                        cancelRequest(correlationId, failedResult.future());\n+                    } else if (Modified.class.isInstance(remoteState)) {\n+                        LOG.debug(\"service did not accept request [target address: {}, subject: {}, correlation ID: {}], remote state: {}\",\n+                                requestTargetAddress, request.getSubject(), correlationId, remoteState);\n+                        final Modified modified = (Modified) deliveryUpdated.getRemoteState();\n+                        failedResult.fail(modified.getUndeliverableHere() ? new ClientErrorException(HttpURLConnection.HTTP_NOT_FOUND)\n+                                : new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE));\n+                        cancelRequest(correlationId, failedResult.future());\n+                    } else if (remoteState == null) {\n+                        // possible scenario here: sender link got closed while waiting on the delivery update\n+                        final String furtherInfo = !sender.isOpen() ? \", sender link was closed in between\" : \"\";\n+                        LOG.warn(\"got undefined delivery state for service request{} [target address: {}, subject: {}, correlation ID: {}]\",\n+                                furtherInfo, requestTargetAddress, request.getSubject(), correlationId);\n+                        failedResult.fail(new ServerErrorException(HttpURLConnection.HTTP_UNAVAILABLE));\n+                        cancelRequest(correlationId, failedResult.future());\n+                    }\n+                });\n+                if (requestTimeoutMillis > 0) {\n+                    connection.getVertx().setTimer(requestTimeoutMillis, tid -> {\n+                        cancelRequest(correlationId, Future.failedFuture(new ServerErrorException(\n+                                HttpURLConnection.HTTP_UNAVAILABLE, \"request timed out after \" + requestTimeoutMillis + \"ms\")));\n+                        sample.timeout();\n+                    });\n+                }\n+                if (LOG.isDebugEnabled()) {\n+                    final String deviceId = MessageHelper.getDeviceId(request);\n+                    if (deviceId == null) {\n+                        LOG.debug(\"sent request [target address: {}, subject: {}, correlation ID: {}] to service\",\n+                                requestTargetAddress, request.getSubject(), correlationId);\n+                    } else {\n+                        LOG.debug(\"sent request [target address: {}, subject: {}, correlation ID: {}, device ID: {}] to service\",\n+                                requestTargetAddress, request.getSubject(), correlationId, deviceId);\n+                    }\n+                }\n+            }\n+          });\n+    }\n+\n+    /**\n+     * Checks if this client's sender and receiver links are open.\n+     *\n+     * @return {@code true} if a request can be sent to and a response can be received\n+     * from the peer.\n+     */\n+    public final boolean isOpen() {\n+        return sender != null && sender.isOpen() && receiver != null && receiver.isOpen();\n+    }\n+\n+    /**\n+     * Closes the links.\n+     *\n+     * @param closeHandler The handler to invoke with the result.\n+     */\n+    public final void close(final Handler<AsyncResult<Void>> closeHandler) {", "originalCommit": "35acfda23480ce14efcfd2a86129019700ec8835", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "27e78ebbf0f9c6a87f5716a2b4b5fd4a9cb2156f", "url": "https://github.com/eclipse/hono/commit/27e78ebbf0f9c6a87f5716a2b4b5fd4a9cb2156f", "message": "[#2381] Introduce response caching at Tenant service client level\n\nResponses from the Tenant service are now being stored in a cache that\nis independent from the life cycle of the underlying connection to the\nservice.\n\nSigned-off-by: Kai Hudalla <kai.hudalla@bosch.io>", "committedDate": "2020-12-23T17:20:56Z", "type": "commit"}, {"oid": "27e78ebbf0f9c6a87f5716a2b4b5fd4a9cb2156f", "url": "https://github.com/eclipse/hono/commit/27e78ebbf0f9c6a87f5716a2b4b5fd4a9cb2156f", "message": "[#2381] Introduce response caching at Tenant service client level\n\nResponses from the Tenant service are now being stored in a cache that\nis independent from the life cycle of the underlying connection to the\nservice.\n\nSigned-off-by: Kai Hudalla <kai.hudalla@bosch.io>", "committedDate": "2020-12-23T17:20:56Z", "type": "forcePushed"}]}