{"pr_number": 2138, "pr_title": "[#2112] Add integration tests for search devices operation", "pr_createdAt": "2020-08-27T16:23:31Z", "pr_url": "https://github.com/eclipse/hono/pull/2138", "timeline": [{"oid": "845fc62c799551ebb4e7e83b308ac0c800c840a3", "url": "https://github.com/eclipse/hono/commit/845fc62c799551ebb4e7e83b308ac0c800c840a3", "message": "[#2112] Add integration tests for search devices operation\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>", "committedDate": "2020-08-28T08:29:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkyMDc5NQ==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r480920795", "bodyText": "can we use the simple parameter types? I do not see why we need to use Optionals here. There is certainly no problem with providing a page size and an offset and empty lists, if no filters nor sort options are used, right?", "author": "sophokles73", "createdAt": "2020-09-01T07:32:01Z", "path": "tests/src/test/java/org/eclipse/hono/tests/DeviceRegistryHttpClient.java", "diffHunk": "@@ -532,6 +542,45 @@ private static String registrationWithoutIdUri(final String tenant) {\n         return httpClient.delete(requestUri, status -> status == HttpURLConnection.HTTP_NO_CONTENT);\n     }\n \n+    /**\n+     * Finds devices belonging to the given tenant with optional filters, paging and sorting options.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param pageSize The maximum number of results to include in a response.\n+     * @param pageOffset The offset into the result set from which to include objects in the response.\n+     * @param filters The filters are predicates that objects in the result set must match.\n+     * @param sortOptions A list of sort options.\n+     * @param expectedStatus The status code indicating a successful outcome.\n+     * @return A future indicating the outcome of the operation. The future will contain the response payload\n+     *         if the request succeeded. Otherwise the future will fail with a \n+     *         {@link org.eclipse.hono.client.ServiceInvocationException}.\n+     * @throws NullPointerException if the tenant is {@code null}.\n+     */\n+    public Future<Buffer> searchDevices(\n+            final String tenantId,\n+            final Optional<Integer> pageSize,\n+            final Optional<Integer> pageOffset,\n+            final Optional<List<String>> filters,\n+            final Optional<List<String>> sortOptions,", "originalCommit": "845fc62c799551ebb4e7e83b308ac0c800c840a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDk4NjAzOA==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r480986038", "bodyText": "The page size and offset are not mandatory fields. I thought its better to test some cases without page size or offset. Hence I defined them as Optional parameters.", "author": "kaniyan", "createdAt": "2020-09-01T09:04:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkyMDc5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTE1MDcyMg==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481150722", "bodyText": "So, we remove the Optionals for the Lists but keep them for the Integer params?", "author": "sophokles73", "createdAt": "2020-09-01T13:47:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkyMDc5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTIzNzczNw==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481237737", "bodyText": "I have removed the Optionals for the Lists and also rebased the code for PR#2412. Would you mind taking a look again?", "author": "kaniyan", "createdAt": "2020-09-01T15:37:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDkyMDc5NQ=="}], "type": "inlineReview"}, {"oid": "dec1f16371bf4fcad58cee306475f1a3c2a96f93", "url": "https://github.com/eclipse/hono/commit/dec1f16371bf4fcad58cee306475f1a3c2a96f93", "message": "Changes related to review comments\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>", "committedDate": "2020-09-01T14:16:21Z", "type": "forcePushed"}, {"oid": "f951a077e1fbc1806a332c0c23d0a4fdc1fed7c7", "url": "https://github.com/eclipse/hono/commit/f951a077e1fbc1806a332c0c23d0a4fdc1fed7c7", "message": "Changes related to review comments and rebase due to PR#2142\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>", "committedDate": "2020-09-01T15:19:29Z", "type": "forcePushed"}, {"oid": "f92c3f68cd920bda3d26282f942c46300e984c0b", "url": "https://github.com/eclipse/hono/commit/f92c3f68cd920bda3d26282f942c46300e984c0b", "message": "[#2112] Add integration tests for search devices operation\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>", "committedDate": "2020-09-01T15:35:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzMTExOQ==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481831119", "bodyText": "maybe we can keep the name of this feature flag in line with the other two flags that we already use?", "author": "sophokles73", "createdAt": "2020-09-02T07:29:15Z", "path": "tests/pom.xml", "diffHunk": "@@ -43,6 +43,8 @@ Test cases are run against Docker images of Hono server + (Apache Qpid Dispatch\n     <!-- should be set to false if testing against a registry that doesn't support GW mode -->\n     <deviceregistry.supportsGatewayMode>true</deviceregistry.supportsGatewayMode>\n     <deviceregistry.credentials.supportsClientContext>true</deviceregistry.credentials.supportsClientContext>\n+    <!-- should be set to true if testing against a registry that supports search devices operation -->\n+    <hono.deviceregistry.supportsSearchDevices>false</hono.deviceregistry.supportsSearchDevices>", "originalCommit": "f92c3f68cd920bda3d26282f942c46300e984c0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNDExMQ==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481834111", "bodyText": "well, the idea here is to make all parameters mandatory, right?", "author": "sophokles73", "createdAt": "2020-09-02T07:32:42Z", "path": "tests/src/test/java/org/eclipse/hono/tests/DeviceRegistryHttpClient.java", "diffHunk": "@@ -577,6 +587,49 @@ private static String registrationWithoutIdUri(final String tenant) {\n                 ResponsePredicate.status(expectedStatus));\n     }\n \n+    /**\n+     * Finds devices belonging to the given tenant with optional filters, paging and sorting options.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param pageSize The maximum number of results to include in a response.\n+     * @param pageOffset The offset into the result set from which to include objects in the response.\n+     * @param filters The filters are predicates that objects in the result set must match.\n+     * @param sortOptions A list of sort options.\n+     * @param expectedStatusCode The status code indicating a successful outcome.\n+     * @return A future indicating the outcome of the operation. The future will contain the response if the\n+     *         response contained the expected status code. Otherwise the future will fail.\n+     * @throws NullPointerException if the tenant is {@code null}.", "originalCommit": "f92c3f68cd920bda3d26282f942c46300e984c0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNDQ0NA==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481834444", "bodyText": "missing null checks", "author": "sophokles73", "createdAt": "2020-09-02T07:33:05Z", "path": "tests/src/test/java/org/eclipse/hono/tests/DeviceRegistryHttpClient.java", "diffHunk": "@@ -577,6 +587,49 @@ private static String registrationWithoutIdUri(final String tenant) {\n                 ResponsePredicate.status(expectedStatus));\n     }\n \n+    /**\n+     * Finds devices belonging to the given tenant with optional filters, paging and sorting options.\n+     *\n+     * @param tenantId The tenant that the device belongs to.\n+     * @param pageSize The maximum number of results to include in a response.\n+     * @param pageOffset The offset into the result set from which to include objects in the response.\n+     * @param filters The filters are predicates that objects in the result set must match.\n+     * @param sortOptions A list of sort options.\n+     * @param expectedStatusCode The status code indicating a successful outcome.\n+     * @return A future indicating the outcome of the operation. The future will contain the response if the\n+     *         response contained the expected status code. Otherwise the future will fail.\n+     * @throws NullPointerException if the tenant is {@code null}.\n+     */\n+    public Future<HttpResponse<Buffer>> searchDevices(\n+            final String tenantId,\n+            final Optional<Integer> pageSize,\n+            final Optional<Integer> pageOffset,\n+            final List<String> filters,\n+            final List<String> sortOptions,\n+            final int expectedStatusCode) {\n+\n+        Objects.requireNonNull(tenantId);", "originalCommit": "f92c3f68cd920bda3d26282f942c46300e984c0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNjQyNQ==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481836425", "bodyText": "does what?", "author": "sophokles73", "createdAt": "2020-09-02T07:35:28Z", "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.", "originalCommit": "f92c3f68cd920bda3d26282f942c46300e984c0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNjgwNA==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481836804", "bodyText": "...WithValidPageSizeSucceeds?", "author": "sophokles73", "createdAt": "2020-09-02T07:35:52Z", "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {", "originalCommit": "f92c3f68cd920bda3d26282f942c46300e984c0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNzYyNw==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481837627", "bodyText": "how about also asserting the overall result set size?", "author": "sophokles73", "createdAt": "2020-09-02T07:36:50Z", "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), null, null,\n+                            HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);", "originalCommit": "f92c3f68cd920bda3d26282f942c46300e984c0b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg3MTY3Ng==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481871676", "bodyText": "Here the result set size is being asserted to the page size. I didn't get it what do you mean by overall result set size?", "author": "kaniyan", "createdAt": "2020-09-02T08:15:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNzYyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTk5Nzg5Mg==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481997892", "bodyText": "well, you have registered two devices and the first page of the search result contains the first match (page size = 1). However, the overall result set size should be 2 because you haven't specified any search criteria, right? So we could also check the total property in the response body. But wait a second, it looks like the response body currently doesn't contain the total and result properties but instead only contains the result set as a JSON array. IMHO this is currently not compliant with the spec ...", "author": "sophokles73", "createdAt": "2020-09-02T11:29:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNzYyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA5NTI2Mw==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r482095263", "bodyText": "I see what do you mean now. My bad I failed to notice the change in the result structure of the search devices operation and I followed the old one. I will create a separate PR to comply with the spec and then continue with the integration tests here.", "author": "kaniyan", "createdAt": "2020-09-02T14:04:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNzYyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjEwMTk1Ng==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r482101956", "bodyText": "sounds good. No worries, I missed it too while reviewing the MongoDB registry implementation ...", "author": "sophokles73", "createdAt": "2020-09-02T14:13:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNzYyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjg0NTI0MQ==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r482845241", "bodyText": "I have created  a PR #2150 to make the search devices result in compliant with the spec.", "author": "kaniyan", "createdAt": "2020-09-03T09:36:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNzYyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mjk4ODA5Nw==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r482988097", "bodyText": "The overall size value is now being asserted and changes are made in accordance with the PR #2150 (Fix search devices result). I have pushed a separate commit for that.", "author": "kaniyan", "createdAt": "2020-09-03T13:43:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNzYyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzNzkwOQ==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481837909", "bodyText": "does what?", "author": "sophokles73", "createdAt": "2020-09-02T07:37:12Z", "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), null, null,\n+                            HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);\n+                        });\n+                        ctx.completeNow();\n+                    })));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page offset is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageOffset(final VertxTestContext ctx) {\n+            final int invalidPageOffset = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.of(invalidPageOffset),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page offset.", "originalCommit": "f92c3f68cd920bda3d26282f942c46300e984c0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTgzOTA4Ng==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481839086", "bodyText": "Multiple", "author": "sophokles73", "createdAt": "2020-09-02T07:38:40Z", "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), null, null,\n+                            HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);\n+                        });\n+                        ctx.completeNow();\n+                    })));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page offset is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageOffset(final VertxTestContext ctx) {\n+            final int invalidPageOffset = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.of(invalidPageOffset),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page offset.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageOffset(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final int pageSize = 1;\n+            final int pageOffset = 1;\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.of(pageOffset),\n+                            null, List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);\n+\n+                            final JsonObject deviceObject = response.getJsonObject(0);\n+                            assertThat(deviceObject.getString(\"id\")).isEqualTo(deviceId1);\n+                        });\n+                        ctx.completeNow();\n+                    }));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when filterJson is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidFilterJson(final VertxTestContext ctx) {\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(\"Invalid filterJson\"), null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with multiple filters succeeds and matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithMutlipleFilters(final VertxTestContext ctx) {", "originalCommit": "f92c3f68cd920bda3d26282f942c46300e984c0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg0MDAwNw==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481840007", "bodyText": "how about adding a step verifying that a combination of other filters actually yields a result?", "author": "sophokles73", "createdAt": "2020-09-02T07:39:49Z", "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), null, null,\n+                            HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);\n+                        });\n+                        ctx.completeNow();\n+                    })));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page offset is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageOffset(final VertxTestContext ctx) {\n+            final int invalidPageOffset = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.of(invalidPageOffset),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page offset.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageOffset(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final int pageSize = 1;\n+            final int pageOffset = 1;\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.of(pageOffset),\n+                            null, List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);\n+\n+                            final JsonObject deviceObject = response.getJsonObject(0);\n+                            assertThat(deviceObject.getString(\"id\")).isEqualTo(deviceId1);\n+                        });\n+                        ctx.completeNow();\n+                    }));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when filterJson is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidFilterJson(final VertxTestContext ctx) {\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(\"Invalid filterJson\"), null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with multiple filters succeeds and matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithMutlipleFilters(final VertxTestContext ctx) {\n+            final Device device1 = new Device().setEnabled(false).setExtensions(Map.of(\"id\", \"1\"));\n+            final Device device2 = new Device().setEnabled(true).setExtensions(Map.of(\"id\", \"2\"));\n+            final String filterJson1 = getFilterJson(\"/ext/id\", \"1\", \"eq\");\n+            final String filterJson2 = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, device1), registry.registerDevice(tenantId, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson1, filterJson2), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());", "originalCommit": "f92c3f68cd920bda3d26282f942c46300e984c0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTg0MTY2Ng==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r481841666", "bodyText": "how about also checking position 1?", "author": "sophokles73", "createdAt": "2020-09-02T07:41:40Z", "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -423,6 +430,209 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageSize(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageSize(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), null, null,\n+                            HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);\n+                        });\n+                        ctx.completeNow();\n+                    })));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page offset is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidPageOffset(final VertxTestContext ctx) {\n+            final int invalidPageOffset = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.of(invalidPageOffset),\n+                            null, null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid page offset.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithPageOffset(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final int pageSize = 1;\n+            final int pageOffset = 1;\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.of(pageOffset),\n+                            null, List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(1);\n+\n+                            final JsonObject deviceObject = response.getJsonObject(0);\n+                            assertThat(deviceObject.getString(\"id\")).isEqualTo(deviceId1);\n+                        });\n+                        ctx.completeNow();\n+                    }));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when filterJson is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidFilterJson(final VertxTestContext ctx) {\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(\"Invalid filterJson\"), null, HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with multiple filters succeeds and matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithMutlipleFilters(final VertxTestContext ctx) {\n+            final Device device1 = new Device().setEnabled(false).setExtensions(Map.of(\"id\", \"1\"));\n+            final Device device2 = new Device().setEnabled(true).setExtensions(Map.of(\"id\", \"2\"));\n+            final String filterJson1 = getFilterJson(\"/ext/id\", \"1\", \"eq\");\n+            final String filterJson2 = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, device1), registry.registerDevice(tenantId, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson1, filterJson2), null, HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when sortJson is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsForInvalidSortJson(final VertxTestContext ctx) {\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(), null,\n+                            List.of(\"Invalid sortJson\"), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid sort option succeeds and the result is sorted accordingly.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithSortOption(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(), null,\n+                            List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonArray response = httpResponse.bodyAsJsonArray();\n+                            assertThat(response.size()).isEqualTo(2);\n+\n+                            final JsonObject deviceObject = response.getJsonObject(0);\n+                            assertThat(deviceObject.getString(\"id\")).isEqualTo(deviceId2);", "originalCommit": "f92c3f68cd920bda3d26282f942c46300e984c0b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8d0862922fcbf8f51380f7b4c6fa0ed4453942f6", "url": "https://github.com/eclipse/hono/commit/8d0862922fcbf8f51380f7b4c6fa0ed4453942f6", "message": "Changes based on review comments\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>", "committedDate": "2020-09-02T08:43:13Z", "type": "forcePushed"}, {"oid": "275e8d9b2066e0e2d4ed28db5267e3b7c61441d2", "url": "https://github.com/eclipse/hono/commit/275e8d9b2066e0e2d4ed28db5267e3b7c61441d2", "message": "[#2112] Add integration tests for search devices operation\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>", "committedDate": "2020-09-03T13:39:48Z", "type": "commit"}, {"oid": "f48fe68ec5aade35775992b7cf089c6b0402c9f7", "url": "https://github.com/eclipse/hono/commit/f48fe68ec5aade35775992b7cf089c6b0402c9f7", "message": "Changes based on review comments\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>", "committedDate": "2020-09-03T13:39:48Z", "type": "commit"}, {"oid": "00692ee0f93fbfc8ba22625f80914de1f6229f5a", "url": "https://github.com/eclipse/hono/commit/00692ee0f93fbfc8ba22625f80914de1f6229f5a", "message": "Changes with respect to PR #2150 (fix search devices result)\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>", "committedDate": "2020-09-03T13:39:48Z", "type": "commit"}, {"oid": "00692ee0f93fbfc8ba22625f80914de1f6229f5a", "url": "https://github.com/eclipse/hono/commit/00692ee0f93fbfc8ba22625f80914de1f6229f5a", "message": "Changes with respect to PR #2150 (fix search devices result)\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>", "committedDate": "2020-09-03T13:39:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwMzQ1MA==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r483003450", "bodyText": "httpResponse.bodyAsJson(SearchDeviceResult.class)?", "author": "sophokles73", "createdAt": "2020-09-03T14:04:24Z", "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -420,6 +427,243 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), List.of(), HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageSizeFails(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with pageSize succeeds and the result is in accordance\n+         * with the specified page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageSizeSucceeds(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), List.of(),\n+                            List.of(), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();", "originalCommit": "00692ee0f93fbfc8ba22625f80914de1f6229f5a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwNjgxOA==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r483006818", "bodyText": "\ud83d\udc4d I am not aware of that method. I will update it.", "author": "kaniyan", "createdAt": "2020-09-03T14:08:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwMzQ1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAyMDg2Ng==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r483020866", "bodyText": "I have updated to use httpResponse.bodyAsJson(SearchDeviceResult.class) and pushed a commit for that.", "author": "kaniyan", "createdAt": "2020-09-03T14:27:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwMzQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwNDEwMA==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r483004100", "bodyText": "httpResponse.bodyAsJson(SearchDeviceResult.class)?", "author": "sophokles73", "createdAt": "2020-09-03T14:05:13Z", "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -420,6 +427,243 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), List.of(), HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageSizeFails(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with pageSize succeeds and the result is in accordance\n+         * with the specified page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageSizeSucceeds(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), List.of(),\n+                            List.of(), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();\n+                            assertThat(searchDevicesResultJson).isNotNull();\n+\n+                            final SearchDevicesResult searchDevicesResult = searchDevicesResultJson\n+                                    .mapTo(SearchDevicesResult.class);\n+                            assertThat(searchDevicesResult.getTotal()).isEqualTo(2);\n+                            assertThat(searchDevicesResult.getResult()).hasSize(1);\n+                        });\n+                        ctx.completeNow();\n+                    })));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page offset is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageOffsetFails(final VertxTestContext ctx) {\n+            final int invalidPageOffset = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.of(invalidPageOffset),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with page offset succeeds and the result is in accordance with\n+         * the specified page offset.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageOffsetSucceeds(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final int pageSize = 1;\n+            final int pageOffset = 1;\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.of(pageOffset),\n+                            List.of(), List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();", "originalCommit": "00692ee0f93fbfc8ba22625f80914de1f6229f5a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwNDI4OQ==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r483004289", "bodyText": "httpResponse.bodyAsJson(SearchDeviceResult.class)?", "author": "sophokles73", "createdAt": "2020-09-03T14:05:27Z", "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -420,6 +427,243 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), List.of(), HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageSizeFails(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with pageSize succeeds and the result is in accordance\n+         * with the specified page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageSizeSucceeds(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), List.of(),\n+                            List.of(), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();\n+                            assertThat(searchDevicesResultJson).isNotNull();\n+\n+                            final SearchDevicesResult searchDevicesResult = searchDevicesResultJson\n+                                    .mapTo(SearchDevicesResult.class);\n+                            assertThat(searchDevicesResult.getTotal()).isEqualTo(2);\n+                            assertThat(searchDevicesResult.getResult()).hasSize(1);\n+                        });\n+                        ctx.completeNow();\n+                    })));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page offset is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageOffsetFails(final VertxTestContext ctx) {\n+            final int invalidPageOffset = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.of(invalidPageOffset),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with page offset succeeds and the result is in accordance with\n+         * the specified page offset.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageOffsetSucceeds(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final int pageSize = 1;\n+            final int pageOffset = 1;\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.of(pageOffset),\n+                            List.of(), List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();\n+                            assertThat(searchDevicesResultJson).isNotNull();\n+\n+                            final SearchDevicesResult searchDevicesResult = searchDevicesResultJson\n+                                    .mapTo(SearchDevicesResult.class);\n+                            assertThat(searchDevicesResult.getTotal()).isEqualTo(2);\n+                            assertThat(searchDevicesResult.getResult()).hasSize(1);\n+                            assertThat(searchDevicesResult.getResult().get(0).getId()).isEqualTo(deviceId1);\n+                        });\n+                        ctx.completeNow();\n+                    }));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when filterJson is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidFilterJsonFails(final VertxTestContext ctx) {\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(\"Invalid filterJson\"), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with multiple filters succeeds and matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidMultipleFiltersSucceeds(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setEnabled(false).setExtensions(Map.of(\"id\", \"1\"));\n+            final Device device2 = new Device().setEnabled(true).setExtensions(Map.of(\"id\", \"2\"));\n+            final String filterJson1 = getFilterJson(\"/ext/id\", \"1\", \"eq\");\n+            final String filterJson2 = getFilterJson(\"/enabled\", true, \"eq\");\n+            final String filterJson3 = getFilterJson(\"/enabled\", false, \"eq\");\n+\n+            CompositeFuture\n+                    .all(registry.registerDevice(tenantId, deviceId1, device1),\n+                            registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson1, filterJson2), List.of(), HttpURLConnection.HTTP_NOT_FOUND))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson1, filterJson3), List.of(), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();", "originalCommit": "00692ee0f93fbfc8ba22625f80914de1f6229f5a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzAwNDQ1NQ==", "url": "https://github.com/eclipse/hono/pull/2138#discussion_r483004455", "bodyText": "httpResponse.bodyAsJson(SearchDeviceResult.class)?", "author": "sophokles73", "createdAt": "2020-09-03T14:05:39Z", "path": "tests/src/test/java/org/eclipse/hono/tests/registry/DeviceManagementIT.java", "diffHunk": "@@ -420,6 +427,243 @@ public void testDeregisterDeviceFailsForNonExistingDevice(final VertxTestContext\n             .onComplete(ctx.completing());\n     }\n \n+    /**\n+     * Tests verifying the search devices operation.\n+     *\n+     * @see <a href=\"https://www.eclipse.org/hono/docs/api/management/#/devices/searchDevicesForTenant\"> \n+     *      Device Registry Management API - Search Devices</a>\n+     */\n+    @Nested\n+    @EnabledIfSystemProperty(named = \"hono.deviceregistry.supportsSearchDevices\", matches = \"true\")\n+    class SearchDevicesIT {\n+        /**\n+         * Verifies that a request to search devices fails with a {@value HttpURLConnection#HTTP_NOT_FOUND}\n+         * when no matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesFailsWhenNoDevicesAreFound(final VertxTestContext ctx) {\n+            final Device device = new Device().setEnabled(false);\n+            final String filterJson = getFilterJson(\"/enabled\", true, \"eq\");\n+\n+            registry.registerDevice(tenantId, deviceId, device)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson), List.of(), HttpURLConnection.HTTP_NOT_FOUND))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page size is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageSizeFails(final VertxTestContext ctx) {\n+            final int invalidPageSize = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(invalidPageSize), Optional.empty(),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with pageSize succeeds and the result is in accordance\n+         * with the specified page size.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageSizeSucceeds(final VertxTestContext ctx) {\n+            final int pageSize = 1;\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, new Device()), registry\n+                    .registerDevice(tenantId, new Device())\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.empty(), List.of(),\n+                            List.of(), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();\n+                            assertThat(searchDevicesResultJson).isNotNull();\n+\n+                            final SearchDevicesResult searchDevicesResult = searchDevicesResultJson\n+                                    .mapTo(SearchDevicesResult.class);\n+                            assertThat(searchDevicesResult.getTotal()).isEqualTo(2);\n+                            assertThat(searchDevicesResult.getResult()).hasSize(1);\n+                        });\n+                        ctx.completeNow();\n+                    })));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when page offset is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidPageOffsetFails(final VertxTestContext ctx) {\n+            final int invalidPageOffset = -100;\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.of(invalidPageOffset),\n+                            List.of(), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with page offset succeeds and the result is in accordance with\n+         * the specified page offset.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidPageOffsetSucceeds(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final int pageSize = 1;\n+            final int pageOffset = 1;\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.of(pageSize), Optional.of(pageOffset),\n+                            List.of(), List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();\n+                            assertThat(searchDevicesResultJson).isNotNull();\n+\n+                            final SearchDevicesResult searchDevicesResult = searchDevicesResultJson\n+                                    .mapTo(SearchDevicesResult.class);\n+                            assertThat(searchDevicesResult.getTotal()).isEqualTo(2);\n+                            assertThat(searchDevicesResult.getResult()).hasSize(1);\n+                            assertThat(searchDevicesResult.getResult().get(0).getId()).isEqualTo(deviceId1);\n+                        });\n+                        ctx.completeNow();\n+                    }));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when filterJson is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidFilterJsonFails(final VertxTestContext ctx) {\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(\"Invalid filterJson\"), List.of(), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with multiple filters succeeds and matching devices are found.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidMultipleFiltersSucceeds(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setEnabled(false).setExtensions(Map.of(\"id\", \"1\"));\n+            final Device device2 = new Device().setEnabled(true).setExtensions(Map.of(\"id\", \"2\"));\n+            final String filterJson1 = getFilterJson(\"/ext/id\", \"1\", \"eq\");\n+            final String filterJson2 = getFilterJson(\"/enabled\", true, \"eq\");\n+            final String filterJson3 = getFilterJson(\"/enabled\", false, \"eq\");\n+\n+            CompositeFuture\n+                    .all(registry.registerDevice(tenantId, deviceId1, device1),\n+                            registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson1, filterJson2), List.of(), HttpURLConnection.HTTP_NOT_FOUND))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(),\n+                            List.of(filterJson1, filterJson3), List.of(), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();\n+                            assertThat(searchDevicesResultJson).isNotNull();\n+\n+                            final SearchDevicesResult searchDevicesResult = searchDevicesResultJson\n+                                    .mapTo(SearchDevicesResult.class);\n+                            assertThat(searchDevicesResult.getTotal()).isEqualTo(1);\n+                            assertThat(searchDevicesResult.getResult()).hasSize(1);\n+                            assertThat(searchDevicesResult.getResult().get(0).getId()).isEqualTo(deviceId1);\n+                        });\n+                        ctx.completeNow();\n+                    }));\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices fails when sortJson is invalid.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithInvalidSortJsonFails(final VertxTestContext ctx) {\n+\n+            registry.registerDevice(tenantId, deviceId)\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(), List.of(),\n+                            List.of(\"Invalid sortJson\"), HttpURLConnection.HTTP_BAD_REQUEST))\n+                    .onComplete(ctx.completing());\n+        }\n+\n+        /**\n+         * Verifies that a request to search devices with a valid sort option succeeds and the result is sorted\n+         * accordingly.\n+         *\n+         * @param ctx The vert.x test context.\n+         */\n+        @Test\n+        public void testSearchDevicesWithValidSortOptionSucceeds(final VertxTestContext ctx) {\n+            final String deviceId1 = helper.getRandomDeviceId(tenantId);\n+            final String deviceId2 = helper.getRandomDeviceId(tenantId);\n+            final Device device1 = new Device().setExtensions(Map.of(\"id\", \"aaa\"));\n+            final Device device2 = new Device().setExtensions(Map.of(\"id\", \"bbb\"));\n+            final String sortJson = getSortJson(\"/ext/id\", \"desc\");\n+\n+            CompositeFuture.all(registry.registerDevice(tenantId, deviceId1, device1),\n+                    registry.registerDevice(tenantId, deviceId2, device2))\n+                    .compose(ok -> registry.searchDevices(tenantId, Optional.empty(), Optional.empty(), List.of(),\n+                            List.of(sortJson), HttpURLConnection.HTTP_OK))\n+                    .onComplete(ctx.succeeding(httpResponse -> {\n+                        ctx.verify(() -> {\n+                            final JsonObject searchDevicesResultJson = httpResponse.bodyAsJsonObject();", "originalCommit": "00692ee0f93fbfc8ba22625f80914de1f6229f5a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3a2504733c6d43b3bd5bb9e70928bb25d4ca5399", "url": "https://github.com/eclipse/hono/commit/3a2504733c6d43b3bd5bb9e70928bb25d4ca5399", "message": "Use httpResponse.bodyAsJson(...) to map the body from http response.\n\nSigned-off-by: Kartheeswaran Kalidass <kartheeswaran.kalidass@bosch.io>", "committedDate": "2020-09-03T14:25:00Z", "type": "commit"}]}