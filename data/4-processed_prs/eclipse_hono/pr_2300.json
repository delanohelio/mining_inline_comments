{"pr_number": 2300, "pr_title": "[#2267] Add AMQP 1.0 based CommandConsumerFactory implementation", "pr_createdAt": "2020-11-17T07:32:52Z", "pr_url": "https://github.com/eclipse/hono/pull/2300", "timeline": [{"oid": "ed4cd535a6525546a9fa07cc98f514b7a978d121", "url": "https://github.com/eclipse/hono/commit/ed4cd535a6525546a9fa07cc98f514b7a978d121", "message": "[#2267] Add AMQP 1.0 based CommandConsumerFactory implementation\n\nAdded transport protocol agnostic CommandConsumerFactory interface to\nthe adapter client module.\nAdded AMQP 1.0 based implementation which simply wraps the existing\nvertx-proton based \"legacy\" AdapterProtocolCommandConsumerFactoryImpl.\n\nSigned-off-by: Kai Hudalla <kai.hudalla@bosch.io>", "committedDate": "2020-11-16T16:28:17Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDk5MTc4Mg==", "url": "https://github.com/eclipse/hono/pull/2300#discussion_r524991782", "bodyText": "I think the two connectToService methods can be removed as well.", "author": "calohmn", "createdAt": "2020-11-17T09:07:25Z", "path": "service-base/src/main/java/org/eclipse/hono/service/AbstractProtocolAdapterBase.java", "diffHunk": "@@ -500,17 +503,6 @@ protected void doStart(final Promise<Void> startPromise) {\n         return client.stop();\n     }\n \n-    private Future<Void> disconnectFromService(final ConnectionLifecycle<?> connection) {", "originalCommit": "ed4cd535a6525546a9fa07cc98f514b7a978d121", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAyMjc3Nw==", "url": "https://github.com/eclipse/hono/pull/2300#discussion_r525022777", "bodyText": "Typo: \"cannot not\".\nThe command message possibly was delivered to its target but got rejected there.\nIt could be added here that the reason a command gets rejected usually is that the message is invalid (or a message limit got exceeded).", "author": "calohmn", "createdAt": "2020-11-17T09:52:54Z", "path": "clients/adapter/src/main/java/org/eclipse/hono/adapter/client/command/CommandContext.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+package org.eclipse.hono.adapter.client.command;\n+\n+import org.eclipse.hono.util.ExecutionContext;\n+\n+import io.opentracing.Span;\n+\n+/**\n+ * A context for processing a command that is targeted at a device.\n+ *\n+ */\n+public interface CommandContext extends ExecutionContext {\n+\n+    /**\n+     * The key under which the current CommandContext is stored.\n+     */\n+    String KEY_COMMAND_CONTEXT = \"command-context\";\n+\n+    /**\n+     * Logs information about the command.\n+     *\n+     * @param span The span to log to.\n+     * @throws NullPointerException if span is {@code null}.\n+     */\n+    void logCommandToSpan(Span span);\n+\n+    /**\n+     * Gets the command to process.\n+     *\n+     * @return The command.\n+     */\n+    Command getCommand();\n+\n+    /**\n+     * Indicates to the sender that the command message has been delivered to its target.\n+     */\n+    void accept();\n+\n+    /**\n+     * Indicates to the sender that the command message could not be delivered to its target due to\n+     * reasons that are not the responsibility of the sender of the command.\n+     */\n+    void release();\n+\n+    /**\n+     * Indicates to the sender that the command message could not be delivered to its target due to\n+     * reasons that are not the responsibility of the sender of the command.\n+     *\n+     * @param deliveryFailed {@code true} if the attempt to send the command to the target device\n+     *                       has failed.\n+     * @param undeliverableHere {@code true} if the component processing the context\n+     *                          has no access to the command's target device.\n+     */\n+    void modify(boolean deliveryFailed, boolean undeliverableHere);\n+\n+    /**\n+     * Indicates to the sender that the command message cannot not be delivered to its target due to\n+     * reasons that are the responsibility of the sender of the command.", "originalCommit": "ed4cd535a6525546a9fa07cc98f514b7a978d121", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTA0NTQ3OA==", "url": "https://github.com/eclipse/hono/pull/2300#discussion_r525045478", "bodyText": "IMHO it would help readability to move this inner class to the bottom of the class.", "author": "calohmn", "createdAt": "2020-11-17T10:27:21Z", "path": "clients/adapter-amqp/src/main/java/org/eclipse/hono/adapter/client/command/amqp/ProtonBasedCommandConsumerFactory.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/**\n+ * Copyright (c) 2020 Contributors to the Eclipse Foundation\n+ *\n+ * See the NOTICE file(s) distributed with this work for additional\n+ * information regarding copyright ownership.\n+ *\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+\n+\n+package org.eclipse.hono.adapter.client.command.amqp;\n+\n+import java.time.Duration;\n+import java.util.Objects;\n+\n+import org.apache.qpid.proton.amqp.transport.ErrorCondition;\n+import org.eclipse.hono.adapter.client.amqp.AbstractServiceClient;\n+import org.eclipse.hono.adapter.client.command.Command;\n+import org.eclipse.hono.adapter.client.command.CommandConsumer;\n+import org.eclipse.hono.adapter.client.command.CommandConsumerFactory;\n+import org.eclipse.hono.adapter.client.command.CommandContext;\n+import org.eclipse.hono.client.CommandTargetMapper;\n+import org.eclipse.hono.client.HonoConnection;\n+import org.eclipse.hono.client.ProtocolAdapterCommandConsumerFactory;\n+import org.eclipse.hono.client.ProtocolAdapterCommandConsumerFactory.CommandHandlingAdapterInfoAccess;\n+import org.eclipse.hono.client.SendMessageSampler.Factory;\n+import org.eclipse.hono.config.ProtocolAdapterProperties;\n+import org.eclipse.hono.util.Constants;\n+\n+import io.opentracing.Span;\n+import io.opentracing.SpanContext;\n+import io.vertx.core.Future;\n+import io.vertx.core.Handler;\n+import io.vertx.proton.ProtonHelper;\n+\n+\n+/**\n+ * A vertx-proton based factory for creating consumers of command messages received via the\n+ * AMQP 1.0 Messaging Network.\n+ * <p>\n+ * This implementation wraps a {@link ProtocolAdapterCommandConsumerFactory} and thus also supports\n+ * routing of commands to a target protocol adapter instance.\n+ *\n+ */\n+public class ProtonBasedCommandConsumerFactory extends AbstractServiceClient implements CommandConsumerFactory {\n+\n+    private final ProtocolAdapterCommandConsumerFactory factory;\n+\n+    /**\n+     * Creates a new client for a connection.\n+     *\n+     * @param connection The connection to the AMQP 1.0 Messaging Network.\n+     * @param samplerFactory The factory for creating samplers for tracing AMQP messages being sent.\n+     * @param adapterConfig The protocol adapter's configuration properties.\n+     * @param commandTargetMapper The component for mapping an incoming command to the gateway (if applicable) and\n+     *            protocol adapter instance that can handle it.\n+     * @param commandRoutingInfoAccess The component for setting and clearing information that maps a device to\n+     *                                 a protocol adapter instance.\n+     * @throws NullPointerException if any of the parameters are {@code null}.\n+     */\n+    public ProtonBasedCommandConsumerFactory(\n+            final HonoConnection connection,\n+            final Factory samplerFactory,\n+            final ProtocolAdapterProperties adapterConfig,\n+            final CommandTargetMapper commandTargetMapper,\n+            final CommandHandlingAdapterInfoAccess commandRoutingInfoAccess) {\n+\n+        super(connection, samplerFactory, adapterConfig);\n+\n+        Objects.requireNonNull(commandTargetMapper);\n+        Objects.requireNonNull(commandRoutingInfoAccess);\n+\n+        factory = ProtocolAdapterCommandConsumerFactory.create(connection, samplerFactory);\n+        factory.initialize(commandTargetMapper, commandRoutingInfoAccess);\n+    }\n+\n+    private static class CommandContextAdapter implements CommandContext {", "originalCommit": "ed4cd535a6525546a9fa07cc98f514b7a978d121", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "48b5e118caf4ade21bdc361a02d7233604186d6c", "url": "https://github.com/eclipse/hono/commit/48b5e118caf4ade21bdc361a02d7233604186d6c", "message": "Incorporate feedback\n\nSigned-off-by: Kai Hudalla <kai.hudalla@bosch.io>", "committedDate": "2020-11-17T14:56:37Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg3MzI0Nw==", "url": "https://github.com/eclipse/hono/pull/2300#discussion_r525873247", "bodyText": "The creation of the CommandHandlingAdapterInfoAccess object here and in the Quarkus AbstractProtocolAdapterApplication can be moved to the ProtonBasedCommandConsumerFactory constructor, passing along the  DeviceConnectionClient object instead of CommandHandlingAdapterInfoAccess.\nThis simplifies the code in AbstractAdapterConfig and AbstractProtocolAdapterApplication.", "author": "calohmn", "createdAt": "2020-11-18T07:48:12Z", "path": "service-base/src/main/java/org/eclipse/hono/service/AbstractAdapterConfig.java", "diffHunk": "@@ -619,71 +624,97 @@ public HonoConnection commandConsumerConnection() {\n         return HonoConnection.newConnection(vertx(), commandConsumerFactoryConfig());\n     }\n \n-    ProtocolAdapterCommandConsumerFactory commandConsumerFactory(\n+    CommandConsumerFactory commandConsumerFactory(\n             final ProtocolAdapterProperties adapterProperties,\n             final SendMessageSampler.Factory samplerFactory,\n             final DeviceRegistrationClient registrationClient,\n-            final DeviceConnectionClient deviceConnectionClient) {\n-\n-        final CommandTargetMapper commandTargetMapper = CommandTargetMapper.create(getTracer());\n-\n-        commandTargetMapper.initialize(new CommandTargetMapperContext() {\n-\n-            @Override\n-            public Future<List<String>> getViaGateways(\n-                    final String tenant,\n-                    final String deviceId,\n-                    final SpanContext context) {\n-\n-                Objects.requireNonNull(tenant);\n-                Objects.requireNonNull(deviceId);\n-\n-                return registrationClient.assertRegistration(tenant, deviceId, null, context)\n-                        .map(RegistrationAssertion::getAuthorizedGateways);\n-            }\n-\n-            @Override\n-            public Future<JsonObject> getCommandHandlingAdapterInstances(\n-                    final String tenant,\n-                    final String deviceId,\n-                    final List<String> viaGateways,\n-                    final SpanContext context) {\n-\n-                Objects.requireNonNull(tenant);\n-                Objects.requireNonNull(deviceId);\n-                Objects.requireNonNull(viaGateways);\n-\n-                return deviceConnectionClient.getCommandHandlingAdapterInstances(\n-                        tenant, deviceId, viaGateways, context);\n-            }\n-        });\n-\n-        final ProtocolAdapterCommandConsumerFactory commandConsumerFactory =\n-                ProtocolAdapterCommandConsumerFactory.create(commandConsumerConnection());\n-\n-        commandConsumerFactory.initialize(commandTargetMapper, new CommandHandlingAdapterInfoAccess() {\n-\n-                    @Override\n-                    public Future<Void> setCommandHandlingAdapterInstance(\n-                            final String tenant,\n-                            final String deviceId,\n-                            final String adapterInstanceId,\n-                            final Duration lifespan,\n-                            final SpanContext context) {\n-                        return deviceConnectionClient.setCommandHandlingAdapterInstance(tenant, deviceId, adapterInstanceId, lifespan, context);\n-                    }\n-\n-                    @Override\n-                    public Future<Void> removeCommandHandlingAdapterInstance(\n-                            final String tenant,\n-                            final String deviceId,\n-                            final String adapterInstanceId,\n-                            final SpanContext context) {\n-                        return deviceConnectionClient.removeCommandHandlingAdapterInstance(tenant, deviceId, adapterInstanceId, context);\n-                    }\n-                });\n-\n-        return commandConsumerFactory;\n+            final CommandRouterClient commandRouterClient) {\n+\n+        if (commandRouterClient instanceof DeviceConnectionClient) {\n+\n+            final DeviceConnectionClient deviceConnectionClient = (DeviceConnectionClient) commandRouterClient;\n+            final CommandTargetMapper commandTargetMapper = CommandTargetMapper.create(getTracer());\n+\n+            commandTargetMapper.initialize(new CommandTargetMapperContext() {\n+\n+                @Override\n+                public Future<List<String>> getViaGateways(\n+                        final String tenant,\n+                        final String deviceId,\n+                        final SpanContext context) {\n+\n+                    Objects.requireNonNull(tenant);\n+                    Objects.requireNonNull(deviceId);\n+\n+                    return registrationClient.assertRegistration(tenant, deviceId, null, context)\n+                            .map(RegistrationAssertion::getAuthorizedGateways);\n+                }\n+\n+                @Override\n+                public Future<JsonObject> getCommandHandlingAdapterInstances(\n+                        final String tenant,\n+                        final String deviceId,\n+                        final List<String> viaGateways,\n+                        final SpanContext context) {\n+\n+                    Objects.requireNonNull(tenant);\n+                    Objects.requireNonNull(deviceId);\n+                    Objects.requireNonNull(viaGateways);\n+\n+                    return deviceConnectionClient.getCommandHandlingAdapterInstances(\n+                            tenant, deviceId, viaGateways, context);\n+                }\n+            });\n+\n+            return new ProtonBasedCommandConsumerFactory(\n+                    commandConsumerConnection(),\n+                    samplerFactory,\n+                    adapterProperties,\n+                    commandTargetMapper,\n+                    new CommandHandlingAdapterInfoAccess() {\n+\n+                        @Override\n+                        public Future<Void> setCommandHandlingAdapterInstance(\n+                                final String tenant,", "originalCommit": "48b5e118caf4ade21bdc361a02d7233604186d6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk2ODExMw==", "url": "https://github.com/eclipse/hono/pull/2300#discussion_r525968113", "bodyText": "But it makes the factory (again) dependent on a particular other client which we already saw to be problematic. The config and application classes are the right place to set up the beans and that is what we are doing here. FMPOV there is no need to change this.", "author": "sophokles73", "createdAt": "2020-11-18T10:15:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg3MzI0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjY2MDU0Mw==", "url": "https://github.com/eclipse/hono/pull/2300#discussion_r526660543", "bodyText": "But it makes the factory (again) dependent on a particular other client which we already saw to be problematic.\n\nAs far as I remember, such a case was problematic when creating the factory in a bean method directly, where e.g. the used registration client bean was created via a @Scope(\"prototype\") bean definition and there were therefore issues when requiring the very same registration client bean instance in the adapter instance that used the above factory bean.\nBut, with the setCollaborators method, from which the above commandConsumerFactory() method is called, we have already decoupled that. I don't see that another layer of decoupling is needed here, seeing that usage of the DeviceRegistrationClient is the primary way to create the factory. Therefore I think creating an additional ProtonBasedCommandConsumerFactory constructor with a DeviceRegistrationClient parameter would be a good way to remove some clutter and duplicate code from the AbstractAdapterConfig and AbstractProtocolAdapterApplication classes.", "author": "calohmn", "createdAt": "2020-11-19T08:01:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg3MzI0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgzNDA2Mg==", "url": "https://github.com/eclipse/hono/pull/2300#discussion_r526834062", "bodyText": "Ok, I'll do that.", "author": "sophokles73", "createdAt": "2020-11-19T12:25:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg3MzI0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg3NDE4Nw==", "url": "https://github.com/eclipse/hono/pull/2300#discussion_r525874187", "bodyText": "commandConsumerConnection() can be used here instead of HonoConnection.newConnection(vertx, config.command), it is unused otherwise.", "author": "calohmn", "createdAt": "2020-11-18T07:50:01Z", "path": "service-base-quarkus/src/main/java/org/eclipse/hono/service/quarkus/AbstractProtocolAdapterApplication.java", "diffHunk": "@@ -283,10 +287,22 @@ protected HonoConnection commandConsumerConnection() {\n     /**\n      * Creates a new factory for command consumers.\n      *\n+     * @param commandTargetMapper The component for mapping an incoming command to the gateway (if applicable) and\n+     *            protocol adapter instance that can handle it.\n+     * @param commandRoutingInfoAccess The component for setting and clearing information that maps a device to\n+     *                                 a protocol adapter instance.\n      * @return The factory.\n      */\n-    protected ProtocolAdapterCommandConsumerFactory commandConsumerFactory() {\n-        return ProtocolAdapterCommandConsumerFactory.create(commandConsumerConnection());\n+    protected CommandConsumerFactory commandConsumerFactory(\n+            final CommandTargetMapper commandTargetMapper,\n+            final CommandHandlingAdapterInfoAccess commandRoutingInfoAccess) {\n+\n+        return new ProtonBasedCommandConsumerFactory(\n+                HonoConnection.newConnection(vertx, config.command),", "originalCommit": "48b5e118caf4ade21bdc361a02d7233604186d6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg3OTY1OA==", "url": "https://github.com/eclipse/hono/pull/2300#discussion_r525879658", "bodyText": "The onCommandConnectionEstablished method should be removed then as well. It is not used anymore.", "author": "calohmn", "createdAt": "2020-11-18T08:00:48Z", "path": "service-base/src/main/java/org/eclipse/hono/service/AbstractProtocolAdapterBase.java", "diffHunk": "@@ -422,18 +431,9 @@ protected final ConnectionLimitManager getConnectionLimitManager() {\n             startServiceClient(tenantClient, \"Tenant service\");\n             startServiceClient(registrationClient, \"Device Registration service\");\n             startServiceClient(credentialsClient, \"Credentials service\");\n-            startServiceClient(deviceConnectionClient, \"Device Connection service\");\n-\n-            connectToService(\n-                    commandConsumerFactory,\n-                    \"Command & Control\",\n-                    this::onCommandConnectionLost,\n-                    this::onCommandConnectionEstablished)\n-            .onComplete(c -> {\n-                if (c.succeeded()) {\n-                    onCommandConnectionEstablished(c.result());", "originalCommit": "48b5e118caf4ade21bdc361a02d7233604186d6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg4MDM3NA==", "url": "https://github.com/eclipse/hono/pull/2300#discussion_r525880374", "bodyText": "The onCommandConnectionLost method should be removed then as well. It is not used anymore.", "author": "calohmn", "createdAt": "2020-11-18T08:02:06Z", "path": "service-base/src/main/java/org/eclipse/hono/service/AbstractProtocolAdapterBase.java", "diffHunk": "@@ -422,18 +431,9 @@ protected final ConnectionLimitManager getConnectionLimitManager() {\n             startServiceClient(tenantClient, \"Tenant service\");\n             startServiceClient(registrationClient, \"Device Registration service\");\n             startServiceClient(credentialsClient, \"Credentials service\");\n-            startServiceClient(deviceConnectionClient, \"Device Connection service\");\n-\n-            connectToService(\n-                    commandConsumerFactory,\n-                    \"Command & Control\",\n-                    this::onCommandConnectionLost,", "originalCommit": "48b5e118caf4ade21bdc361a02d7233604186d6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg4MzkxMg==", "url": "https://github.com/eclipse/hono/pull/2300#discussion_r525883912", "bodyText": "adapter.setCommandResponseSender(commandResponseSender());\n\nis missing here (commandResponseSender() is currently not used).", "author": "calohmn", "createdAt": "2020-11-18T08:09:01Z", "path": "service-base-quarkus/src/main/java/org/eclipse/hono/service/quarkus/AbstractProtocolAdapterApplication.java", "diffHunk": "@@ -181,7 +185,7 @@ protected void setCollaborators(final AbstractProtocolAdapterBase<?> adapter) {\n         Optional.ofNullable(connectionEventProducer())\n             .ifPresent(adapter::setConnectionEventProducer);\n         adapter.setCredentialsClient(credentialsClient());\n-        adapter.setDeviceConnectionClient(deviceConnectionClient);\n+        adapter.setCommandRouterClient(deviceConnectionClient);", "originalCommit": "48b5e118caf4ade21bdc361a02d7233604186d6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkzOTA5NQ==", "url": "https://github.com/eclipse/hono/pull/2300#discussion_r525939095", "bodyText": "FMPOV, an UnsupportedOperationException should be thrown here. The registerCommandConsumer method should not be invoked on the DeviceConnectionClient.\nSame goes for the unregisterCommandConsumer method.", "author": "calohmn", "createdAt": "2020-11-18T09:33:18Z", "path": "clients/adapter-amqp/src/main/java/org/eclipse/hono/adapter/client/command/amqp/ProtonBasedDeviceConnectionClient.java", "diffHunk": "@@ -122,41 +122,43 @@ protected void onDisconnect() {\n \n     /**\n      * {@inheritDoc}\n+     * <p>\n+     * Simply delegates to {@link #registerCommandConsumer(String, String, String, Duration, SpanContext)}.\n      */\n     @Override\n-    public Future<JsonObject> getLastKnownGatewayForDevice(\n+    public Future<Void> setCommandHandlingAdapterInstance(\n             final String tenant,\n             final String deviceId,\n+            final String adapterInstanceId,\n+            final Duration lifespan,\n             final SpanContext context) {\n \n-        Objects.requireNonNull(tenant);\n-        Objects.requireNonNull(deviceId);\n-\n-        return getOrCreateDeviceConnectionClient(tenant)\n-                .compose(client -> client.getLastKnownGatewayForDevice(deviceId, context));\n+        return registerCommandConsumer(tenant, deviceId, adapterInstanceId, lifespan, context);\n     }\n \n     /**\n      * {@inheritDoc}\n      */\n     @Override\n-    public Future<Void> setCommandHandlingAdapterInstance(\n-            final String tenant,\n+    public Future<Void> registerCommandConsumer(\n+            final String tenantId,\n             final String deviceId,\n             final String adapterInstanceId,\n             final Duration lifespan,\n             final SpanContext context) {\n \n-        Objects.requireNonNull(tenant);\n+        Objects.requireNonNull(tenantId);\n         Objects.requireNonNull(deviceId);\n         Objects.requireNonNull(adapterInstanceId);\n \n-        return getOrCreateDeviceConnectionClient(tenant)\n+        return getOrCreateDeviceConnectionClient(tenantId)\n                 .compose(client -> client.setCommandHandlingAdapterInstance(deviceId, adapterInstanceId, lifespan, context));", "originalCommit": "48b5e118caf4ade21bdc361a02d7233604186d6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTkzOTU4Ng==", "url": "https://github.com/eclipse/hono/pull/2300#discussion_r525939586", "bodyText": "FMPOV, an UnsupportedOperationException should be thrown here. The registerCommandConsumer method should not be invoked on the DeviceConnectionClient.\nSame goes for the unregisterCommandConsumer method.", "author": "calohmn", "createdAt": "2020-11-18T09:33:56Z", "path": "client-device-connection-infinispan/src/main/java/org/eclipse/hono/deviceconnection/infinispan/client/CacheBasedDeviceConnectionClient.java", "diffHunk": "@@ -81,21 +80,25 @@ public CacheBasedDeviceConnectionClient(final DeviceConnectionInfo cache, final\n \n     /**\n      * {@inheritDoc}\n+     * <p>\n+     * Simply delegates to {@link #registerCommandConsumer(String, String, String, Duration, SpanContext)}.\n      */\n     @Override\n-    public Future<JsonObject> getLastKnownGatewayForDevice(\n+    public Future<Void> setCommandHandlingAdapterInstance(\n             final String tenantId,\n             final String deviceId,\n+            final String adapterInstanceId,\n+            final Duration lifespan,\n             final SpanContext context) {\n \n-        final Span span = newSpan(context, SPAN_NAME_GET_LAST_GATEWAY);\n-        TracingHelper.setDeviceTags(span, tenantId, deviceId);\n-\n-        return finishSpan(connectionInfoCache.getLastKnownGatewayForDevice(tenantId, deviceId, span), span);\n+        return registerCommandConsumer(tenantId, deviceId, adapterInstanceId, lifespan, context);\n     }\n \n+    /**\n+     * {@inheritDoc}\n+     */\n     @Override\n-    public Future<Void> setCommandHandlingAdapterInstance(\n+    public Future<Void> registerCommandConsumer(", "originalCommit": "48b5e118caf4ade21bdc361a02d7233604186d6c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk0MDIxMA==", "url": "https://github.com/eclipse/hono/pull/2300#discussion_r525940210", "bodyText": "I'm still not convinced that having the possibility to use just one bean (CommandRouterClient) for both the old commandConsumerFactory implementation and the new, CommandRouter-based one is worth the added confusion about the DeviceConnectionClient and CommandRouterClient being mixed up like this.\nFMPOV, having a CommandRouterClient bean and a separate DeviceConnectionClient bean and allowing one or the other to be null would probably be easier to understand.\nAt least, when mixing the interfaces, I think it would be good to document the motivation in the DeviceConnectionClient javadoc.", "author": "calohmn", "createdAt": "2020-11-18T09:34:49Z", "path": "clients/adapter/src/main/java/org/eclipse/hono/adapter/client/command/DeviceConnectionClient.java", "diffHunk": "@@ -28,47 +26,7 @@\n  * See Hono's <a href=\"https://www.eclipse.org/hono/docs/api/device-connection/\">\n  * Device Connection API specification</a> for a description of the result codes returned.\n  */\n-public interface DeviceConnectionClient extends Lifecycle {\n-\n-    /**\n-     * Sets the given gateway as the last gateway that acted on behalf of the given device.\n-     * <p>\n-     * If a device connects directly instead of through a gateway, the device identifier itself is to be used as value\n-     * for the <em>gatewayId</em> parameter.\n-     *\n-     * @param tenant The tenant that the device belongs to.\n-     * @param deviceId The device id.\n-     * @param gatewayId The gateway id (or the device id if the last message came from the device directly).\n-     * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.\n-     *            An implementation should use this as the parent for any span it creates for tracing\n-     *            the execution of this operation.\n-     * @return A future indicating whether the operation succeeded or not.\n-     * @throws NullPointerException if tenant, device id or gateway id are {@code null}.\n-     */\n-    Future<Void> setLastKnownGatewayForDevice(String tenant, String deviceId, String gatewayId, SpanContext context);\n-\n-    /**\n-     * Gets the gateway that last acted on behalf of the given device.\n-     * <p>\n-     * If no last known gateway has been set for the given device yet, a failed future with status <em>Not Found</em>\n-     * is returned.\n-     *\n-     * @param tenant The tenant that the device belongs to.\n-     * @param deviceId The device id.\n-     * @param context The currently active OpenTracing span context or {@code null} if no span is currently active.\n-     *            An implementation should use this as the parent for any span it creates for tracing\n-     *            the execution of this operation.\n-     * @return A future indicating the result of the operation.\n-     *         <p>\n-     *         The future will succeed if a response with status 200 has been received from the device connection service.\n-     *         In that case the value of the future will contain a <em>gateway-id</em> property with the\n-     *         gateway id.\n-     *         <p>\n-     *         In case a status other then 200 is received, the future will fail with a\n-     *         {@code org.eclipse.hono.client.ServiceInvocationException} containing the (error) status code returned by the service.\n-     * @throws NullPointerException if tenant or device id are {@code null}.\n-     */\n-    Future<JsonObject> getLastKnownGatewayForDevice(String tenant, String deviceId, SpanContext context);\n+public interface DeviceConnectionClient extends CommandRouterClient {", "originalCommit": "48b5e118caf4ade21bdc361a02d7233604186d6c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk3MjM4OQ==", "url": "https://github.com/eclipse/hono/pull/2300#discussion_r525972389", "bodyText": "I'll give it another thought ...", "author": "sophokles73", "createdAt": "2020-11-18T10:22:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk0MDIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgxNjcwNg==", "url": "https://github.com/eclipse/hono/pull/2300#discussion_r526816706", "bodyText": "In any case we would have two different CommandConsumerFactory implementations, right?\n\nThe old one which simply wraps org.eclipse.hono.client.ProtocolAdapterCommandConsumerFactory and requires a DeviceConnectionClient and DeviceRegistrationClient implementation, and\nthe new one which only requires the CommandRouterClient.\n\nBased on whether the DeviceConnectionClient bean or the CommandRouterClient bean has been configured, we would instantiate the former or the latter, right?", "author": "sophokles73", "createdAt": "2020-11-19T12:06:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk0MDIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjgzMjE1OQ==", "url": "https://github.com/eclipse/hono/pull/2300#discussion_r526832159", "bodyText": "Yes.", "author": "calohmn", "createdAt": "2020-11-19T12:21:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk0MDIxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzAzNTU0NA==", "url": "https://github.com/eclipse/hono/pull/2300#discussion_r527035544", "bodyText": "Ok, I have pushed corresponding changes ...", "author": "sophokles73", "createdAt": "2020-11-19T16:44:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTk0MDIxMA=="}], "type": "inlineReview"}, {"oid": "a5fafc01ab3e685ea0ab74987932ef36c8960555", "url": "https://github.com/eclipse/hono/commit/a5fafc01ab3e685ea0ab74987932ef36c8960555", "message": "Incorporate feedback\n\nSigned-off-by: Kai Hudalla <kai.hudalla@bosch.io>", "committedDate": "2020-11-19T10:40:58Z", "type": "commit"}, {"oid": "f7782d059f1d4af2f6bf646b9508e4dd0e3037c3", "url": "https://github.com/eclipse/hono/commit/f7782d059f1d4af2f6bf646b9508e4dd0e3037c3", "message": "Do not let DeviceConnectionClient extend CommandRouterClient anymore\n\nAbstractProtocolAdapterBase still only has a CommandRouterClient typed\nproperty. During startup, a configured DeviceConnectionClient instance\nis being adapted to the CommandRouterClient interface.\n\nSigned-off-by: Kai Hudalla <kai.hudalla@bosch.io>", "committedDate": "2020-11-19T16:43:40Z", "type": "commit"}]}