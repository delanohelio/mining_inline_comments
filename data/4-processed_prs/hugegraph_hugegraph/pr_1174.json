{"pr_number": 1174, "pr_title": "Custom kout/kneighbor, multi-node-shortest-path, jaccard-similar and template paths", "pr_createdAt": "2020-09-15T03:28:55Z", "pr_url": "https://github.com/hugegraph/hugegraph/pull/1174", "timeline": [{"oid": "9eb68d856aa061de0fd3bb52c16e40ab18f5d8cc", "url": "https://github.com/hugegraph/hugegraph/commit/9eb68d856aa061de0fd3bb52c16e40ab18f5d8cc", "message": "upgrade api version to 58\n\nimplements: #1173\n\nChange-Id: I85aa1d4274554d65f85a0deb7ac596e65dbb503b", "committedDate": "2020-09-15T03:30:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkxNjkzNA==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r490916934", "bodyText": "move Consumers to com/baidu/hugegraph/util", "author": "javeme", "createdAt": "2020-09-18T12:33:11Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/job/algorithm/Consumers.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.job.algorithm;\n+\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+import java.util.function.Consumer;\n+\n+import org.slf4j.Logger;\n+\n+import com.baidu.hugegraph.HugeException;\n+import com.baidu.hugegraph.task.TaskManager.ContextCallable;\n+import com.baidu.hugegraph.util.ExecutorUtil;\n+import com.baidu.hugegraph.util.Log;\n+\n+public class Consumers<V> {", "originalCommit": "3fc98af7e395491d35a619a7e26268e0e614b730", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkwNTc3MQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r491905771", "bodyText": "rebase #1183", "author": "javeme", "createdAt": "2020-09-21T09:32:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkxNjkzNA=="}], "type": "inlineReview"}, {"oid": "ab1564a02ac53174e09ee92121ba12d84c188c2a", "url": "https://github.com/hugegraph/hugegraph/commit/ab1564a02ac53174e09ee92121ba12d84c188c2a", "message": "Add customized kout/kneighbor, template path, multi-node-shortest-path and jaccard similar\n\n* fix OLTP algorithm not check if source/target vertex exist (#1156)\n* support customized kout and kneighbor\n* support multi node shortest path API\n* support template paths api\n* support jaccard similars find oltp api\n* use multi-thread to accelerate customized kout/kneighbor, multi-node-shortest-path, jaccard-similar and template-paths\n* big depth and both direction use multi threads, otherwise single threead\n* fix shortest path api NLP\n\nChange-Id: I7eb4ceaccdc4a6b2a4a7b944edc83dff64a98f5d", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "5660ca98fd1017fbc9e8143532f6eef3564bda38", "url": "https://github.com/hugegraph/hugegraph/commit/5660ca98fd1017fbc9e8143532f6eef3564bda38", "message": "Szzq paths improve (#51)\n\n* template path use concurrent hashset to save paths in concurrent mode\r\n* support property filter for paths api\r\n\r\nChange-Id: I2e589f58cdfc48b4b8d16b7780b78cc17ab107d6", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "851760ba26dc70bd08634e8d389293021d75f62c", "url": "https://github.com/hugegraph/hugegraph/commit/851760ba26dc70bd08634e8d389293021d75f62c", "message": "fix configuration not supported with auth (#55)\n\nalso paths and template paths use single thread\r\n\r\nChange-Id: I4375c455f377d9e4d43c0284ec30da1725fdf6bc", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "64088e548bd4008f550d4a430153825920d79337", "url": "https://github.com/hugegraph/hugegraph/commit/64088e548bd4008f550d4a430153825920d79337", "message": "template path supports repeat times args (#57)\n\npaths supports nearest args\r\noltp multiple threads reuse\r\nadd multiple thread depth config\r\n\r\nChange-Id: I8c2f921ffb56302fb8d300c09a5a13857dac187a", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "b120508e30ba39e92fc9693b1eeab387de5e677b", "url": "https://github.com/hugegraph/hugegraph/commit/b120508e30ba39e92fc9693b1eeab387de5e677b", "message": "fix group perperty can't be empty\n\nChange-Id: I6d972894f3eec339181e5626bf45d01f36dbd4c0", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "e178508397470933745464a7cf82ca0a88068f35", "url": "https://github.com/hugegraph/hugegraph/commit/e178508397470933745464a7cf82ca0a88068f35", "message": "upgrade api version to 58\n\nimplements: #1173\n\nChange-Id: I85aa1d4274554d65f85a0deb7ac596e65dbb503b", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "e98555e8f31371672d9bfb57527c226dd274f4b8", "url": "https://github.com/hugegraph/hugegraph/commit/e98555e8f31371672d9bfb57527c226dd274f4b8", "message": "add Consumers class\n\nChange-Id: I73d877fbd2099d9e63ef29ee0a10df30354595f9", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "a0f44c002cb3eefcae5317f77b5b9601c0ae4e28", "url": "https://github.com/hugegraph/hugegraph/commit/a0f44c002cb3eefcae5317f77b5b9601c0ae4e28", "message": "move customized kout/kneighbor to kout/kneighbor\n\nChange-Id: Ib6fa985ff48fab203611218cc955079ad8cc90c3", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "924c5e174b626fba1be366c35c3713645cd28490", "url": "https://github.com/hugegraph/hugegraph/commit/924c5e174b626fba1be366c35c3713645cd28490", "message": "move jaccard similar into jaccard similarity\n\nChange-Id: Ia6ff5efd7e2a195f85427992b7bff875d30dec48", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "f31cf3adff9c7e1351744ce06a0cd057e96d3e23", "url": "https://github.com/hugegraph/hugegraph/commit/f31cf3adff9c7e1351744ce06a0cd057e96d3e23", "message": "improve\n\nChange-Id: Ib43614c252912427c6ddaeb52c974a59b06934e6", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "b9706e1777e47efff757b9e71a132da3c3793c30", "url": "https://github.com/hugegraph/hugegraph/commit/b9706e1777e47efff757b9e71a132da3c3793c30", "message": "improve\n\nChange-Id: I5ef4b33e8c5b4ade0b372d3810e596d335f37f29", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "ebe3157ef79189cc661c1a93cfbcb270a11d0750", "url": "https://github.com/hugegraph/hugegraph/commit/ebe3157ef79189cc661c1a93cfbcb270a11d0750", "message": "fix kout/kneighbor withVertex not work\n\nChange-Id: Icbc65aa24e069b67bd5653b79473da48e2f973c6", "committedDate": "2020-09-21T09:48:35Z", "type": "commit"}, {"oid": "25cb47ad2f8ad21d0657cd96277f79ec37c981a2", "url": "https://github.com/hugegraph/hugegraph/commit/25cb47ad2f8ad21d0657cd96277f79ec37c981a2", "message": "rebase ramtable\n\nChange-Id: I606772946a2a55f7472274242fb18f4ca91c189a", "committedDate": "2020-09-21T10:04:17Z", "type": "commit"}, {"oid": "25cb47ad2f8ad21d0657cd96277f79ec37c981a2", "url": "https://github.com/hugegraph/hugegraph/commit/25cb47ad2f8ad21d0657cd96277f79ec37c981a2", "message": "rebase ramtable\n\nChange-Id: I606772946a2a55f7472274242fb18f4ca91c189a", "committedDate": "2020-09-21T10:04:17Z", "type": "forcePushed"}, {"oid": "bff5a6a67a3c1f0868bf2a23aefa3cecf13fb12e", "url": "https://github.com/hugegraph/hugegraph/commit/bff5a6a67a3c1f0868bf2a23aefa3cecf13fb12e", "message": "improve\n\nChange-Id: I4ab46bc68644d35fab1fa966e27a0d7ab87b433b", "committedDate": "2020-09-22T03:09:25Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDIzODUxNg==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r494238516", "bodyText": "add common method", "author": "javeme", "createdAt": "2020-09-24T11:29:08Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -0,0 +1,636 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+import org.slf4j.Logger;\n+\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.structure.HugeVertex;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.E;\n+import com.baidu.hugegraph.util.Log;\n+import com.google.common.collect.ImmutableList;\n+\n+public class TemplatePathsTraverser extends TpTraverser {\n+\n+    private static final Logger LOG = Log.logger(TemplatePathsTraverser.class);\n+\n+    public TemplatePathsTraverser(HugeGraph graph) {\n+        super(graph, \"template-paths\");\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Set<Path> templatePaths(Iterator<Vertex> sources,\n+                                   Iterator<Vertex> targets,\n+                                   List<RepeatEdgeStep> steps,\n+                                   boolean withRing,\n+                                   long capacity, long limit) {\n+        checkCapacity(capacity);\n+        checkLimit(limit);\n+\n+        List<Id> sourceList = new ArrayList<>();\n+        while (sources.hasNext()) {\n+            sourceList.add(((HugeVertex) sources.next()).id());\n+        }\n+        int sourceSize = sourceList.size();\n+        E.checkState(sourceSize >= 1 && sourceSize <= MAX_VERTICES,\n+                     \"The number of source vertices must in [1, %s], \" +\n+                     \"but got: %s\", MAX_VERTICES, sourceList.size());\n+        List<Id> targetList = new ArrayList<>();\n+        while (targets.hasNext()) {\n+            targetList.add(((HugeVertex) targets.next()).id());\n+        }\n+        int targetSize = targetList.size();\n+        E.checkState(targetSize >= 1 && targetSize <= MAX_VERTICES,\n+                     \"The number of target vertices must in [1, %s], \" +\n+                     \"but got: %s\", MAX_VERTICES, sourceList.size());\n+\n+        int totalSteps = 0;\n+        for (RepeatEdgeStep step : steps) {\n+            totalSteps += step.maxTimes;\n+        }\n+        Traverser traverser = totalSteps >= this.concurrentDepth() ?\n+                              new ConcurrentTraverser(sourceList, targetList,\n+                                                      steps, withRing,\n+                                                      capacity, limit) :\n+                              new SingleTraverser(sourceList, targetList,\n+                                                  steps, withRing,\n+                                                  capacity, limit);\n+\n+        do {\n+            // Forward\n+            traverser.forward();\n+            if (traverser.finish()) {\n+                return traverser.paths();\n+            }\n+\n+            // Backward\n+            traverser.backward();\n+            if (traverser.finish()) {\n+                return traverser.paths();\n+            }\n+        } while (true);\n+    }\n+\n+    private class Traverser {\n+\n+        protected final List<RepeatEdgeStep> steps;\n+        protected int stepCount;\n+        protected final long capacity;\n+        protected final long limit;\n+        protected int totalSteps;\n+        protected boolean withRing;\n+        protected int sourceIndex;\n+        protected int targetIndex;\n+\n+        protected boolean sourceFinishOneStep = false;\n+        protected boolean targetFinishOneStep = false;\n+\n+        public Traverser(List<RepeatEdgeStep> steps,\n+                         long capacity, long limit, boolean withRing) {\n+            this.steps = steps;\n+            this.capacity = capacity;\n+            this.limit = limit;\n+            this.withRing = withRing;\n+\n+            this.stepCount = 0;\n+            for (RepeatEdgeStep step : steps) {\n+                this.totalSteps += step.maxTimes;\n+            }\n+            this.sourceIndex = 0;\n+            this.targetIndex = this.steps.size() - 1;\n+        }\n+\n+        public void forward() {\n+        }\n+\n+        public void backward() {\n+        }\n+\n+        public Set<Path> paths() {\n+            return new PathSet();\n+        }\n+\n+        public int pathCount() {\n+            return 0;\n+        }\n+\n+        protected boolean finish() {\n+            return this.stepCount >= this.totalSteps || this.reachLimit();\n+        }\n+\n+        protected boolean lastStep() {\n+            return this.stepCount == this.totalSteps - 1;\n+        }\n+\n+        protected int accessedNodes() {\n+            return 0;\n+        }\n+\n+        protected boolean reachLimit() {\n+            checkCapacity(this.capacity, this.accessedNodes(),\n+                          \"template paths\");\n+            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n+                return false;\n+            }\n+            return true;\n+        }\n+\n+        public boolean lastSuperStep() {\n+            return this.targetIndex == this.sourceIndex ||\n+                   this.targetIndex == this.sourceIndex + 1;\n+        }\n+    }\n+\n+    private class ConcurrentTraverser extends Traverser {\n+\n+        private ConcurrentMultiValuedMap<Id, Node> sources =\n+                new ConcurrentMultiValuedMap<>();\n+        private ConcurrentMultiValuedMap<Id, Node> targets =\n+                new ConcurrentMultiValuedMap<>();\n+        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n+                new ConcurrentMultiValuedMap<>();\n+        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n+                new ConcurrentMultiValuedMap<>();\n+\n+        private Set<Path> paths;\n+\n+        public ConcurrentTraverser(Collection<Id> sources,\n+                                   Collection<Id> targets,\n+                                   List<RepeatEdgeStep> steps, boolean withRing,\n+                                   long capacity, long limit) {\n+            super(steps, capacity, limit, withRing);\n+            for (Id id : sources) {\n+                this.sources.add(id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.targets.add(id, new Node(id));\n+            }\n+            this.paths = ConcurrentHashMap.newKeySet();\n+        }\n+\n+        /**\n+         * Search forward from sources\n+         */\n+        public void forward() {\n+            ConcurrentMultiValuedMap<Id, Node> newVertices =\n+                                               new ConcurrentMultiValuedMap<>();\n+            RepeatEdgeStep currentStep = null;\n+            // Find next step to forward\n+            for (int i = 0; i < this.steps.size(); i++) {\n+                RepeatEdgeStep step = this.steps.get(i);\n+                if (step.remainTimes() > 0) {\n+                    currentStep = step;\n+                    this.sourceIndex = i;\n+                    break;\n+                }\n+            }\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            // Re-init source all if last forward finished one super step and\n+            // not last super step\n+            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n+                this.sourcesAll = new ConcurrentMultiValuedMap<>();\n+                this.sourceFinishOneStep = false;\n+            }\n+\n+            // Traversal vertices of previous level\n+            RepeatEdgeStep finalCurrentStep = currentStep;\n+            traverseIds(this.sources.keySet().iterator(), vid -> {", "originalCommit": "bff5a6a67a3c1f0868bf2a23aefa3cecf13fb12e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "url": "https://github.com/hugegraph/hugegraph/commit/8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "message": "extract common traverser from template paths traversers\n\nChange-Id: If6f0c1370a2376ef176ce2db39e002ae11590e8d", "committedDate": "2020-09-29T07:10:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5MTE1NA==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496691154", "bodyText": "rename pre to prev", "author": "javeme", "createdAt": "2020-09-29T12:52:53Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java", "diffHunk": "@@ -551,6 +551,26 @@ public static void checkSkipDegree(long skipDegree, long degree,\n         return new MultivaluedHashMap<>();\n     }\n \n+    protected static List<Id> joinPath(Node pre, Node back, boolean ring) {", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5NDA5NQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496694095", "bodyText": "rename v to source", "author": "javeme", "createdAt": "2020-09-29T12:57:02Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        protected int accessedNodes() {\n-            return 0;\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public abstract void traverseOneLayer(\n+                             Map<Id, List<Node>> vertices,\n+                             RepeatEdgeStep step,\n+                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+\n+        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        private void forward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, true);\n         }\n-    }\n \n-    private class ConcurrentTraverser extends Traverser {\n+        private void backward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, false);\n+        }\n \n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n+        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5NjMyNw==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496696327", "bodyText": "reInitCurrentStepIfNeeded", "author": "javeme", "createdAt": "2020-09-29T13:00:22Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        protected int accessedNodes() {\n-            return 0;\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public abstract void traverseOneLayer(\n+                             Map<Id, List<Node>> vertices,\n+                             RepeatEdgeStep step,\n+                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+\n+        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        private void forward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, true);\n         }\n-    }\n \n-    private class ConcurrentTraverser extends Traverser {\n+        private void backward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, false);\n+        }\n \n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n+        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n+            if (this.reachLimit()) {\n+                return;\n+            }\n \n-        private Set<Path> paths;\n+            Iterator<Edge> edges = edgesOfVertex(v, step);\n+            while (edges.hasNext()) {\n+                HugeEdge edge = (HugeEdge) edges.next();\n+                Id target = edge.id().otherVertexId();\n \n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n+                this.processOne(v, target, forward);\n             }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n+        }\n+\n+        private void processOne(Id source, Id target, boolean forward) {\n+            if (forward) {\n+                processOneForForward(source, target);\n+            } else {\n+                processOneForBackward(source, target);\n             }\n-            this.paths = ConcurrentHashMap.newKeySet();\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n+        private void processOneForForward(Id source, Id target) {\n+            for (Node n : this.sources.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n+                }\n+\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.targetsAll.containsKey(target)) {\n+                    for (Node node : this.targetsAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            this.paths.add(new Path(target, path));\n+                            if (this.reachLimit()) {\n+                                return;\n+                            }\n+                        }\n+                    }\n                 }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n \n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = new ConcurrentMultiValuedMap<>();\n-                this.sourceFinishOneStep = false;\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n             }\n+        }\n \n-            // Traversal vertices of previous level\n-            RepeatEdgeStep finalCurrentStep = currentStep;\n-            traverseIds(this.sources.keySet().iterator(), vid -> {\n-                if (this.reachLimit()) {\n-                    return;\n+        private void processOneForBackward(Id source, Id target) {\n+            for (Node n : this.targets.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n                 }\n-                Iterator<Edge> edges = edgesOfVertex(vid, finalCurrentStep);\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : this.sources.get(vid)) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n \n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.targets.containsKey(target)) {\n-                            for (Node node : this.targets.get(target)) {\n-                                List<Id> path = n.joinPath(node);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.sourcesAll.containsKey(target)) {\n+                    for (Node node : this.sourcesAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            Path newPath = new Path(target, path);\n+                            newPath.reverse();\n+                            this.paths.add(newPath);\n+                            if (this.reachLimit()) {\n+                                return;\n                             }\n                         }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n                     }\n                 }\n-            });\n \n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n+            }\n+        }\n+\n+        private void reInitAllIfNeeded(boolean forward) {\n+            if (forward) {\n+                // Re-init source all if last forward finished one super step\n+                // and not last super step\n+                if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n+                    this.sourcesAll = this.newMultiValueMap();\n+                    this.sourceFinishOneStep = false;\n+                }\n+            } else {\n+                // Re-init target all if last forward finished one super step\n+                // and not last super step\n+                if (this.targetFinishOneStep && !this.lastSuperStep()) {\n+                    this.targetsAll = this.newMultiValueMap();\n+                    this.targetFinishOneStep = false;\n+                }\n             }\n+        }\n \n-            currentStep.decreaseTimes();\n-            // Re-init sources\n-            if (currentStep.remainTimes() > 0) {\n-                this.sources = newVertices;\n+        private void reInitCurrentIfNeeded(RepeatEdgeStep step,", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5NjgzMQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496696831", "bodyText": "not finished last super step? or current step is not the last super step?\nand use /*", "author": "javeme", "createdAt": "2020-09-29T13:01:08Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        protected int accessedNodes() {\n-            return 0;\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public abstract void traverseOneLayer(\n+                             Map<Id, List<Node>> vertices,\n+                             RepeatEdgeStep step,\n+                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+\n+        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        private void forward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, true);\n         }\n-    }\n \n-    private class ConcurrentTraverser extends Traverser {\n+        private void backward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, false);\n+        }\n \n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n+        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n+            if (this.reachLimit()) {\n+                return;\n+            }\n \n-        private Set<Path> paths;\n+            Iterator<Edge> edges = edgesOfVertex(v, step);\n+            while (edges.hasNext()) {\n+                HugeEdge edge = (HugeEdge) edges.next();\n+                Id target = edge.id().otherVertexId();\n \n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n+                this.processOne(v, target, forward);\n             }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n+        }\n+\n+        private void processOne(Id source, Id target, boolean forward) {\n+            if (forward) {\n+                processOneForForward(source, target);\n+            } else {\n+                processOneForBackward(source, target);\n             }\n-            this.paths = ConcurrentHashMap.newKeySet();\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n+        private void processOneForForward(Id source, Id target) {\n+            for (Node n : this.sources.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n+                }\n+\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.targetsAll.containsKey(target)) {\n+                    for (Node node : this.targetsAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            this.paths.add(new Path(target, path));\n+                            if (this.reachLimit()) {\n+                                return;\n+                            }\n+                        }\n+                    }\n                 }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n \n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = new ConcurrentMultiValuedMap<>();\n-                this.sourceFinishOneStep = false;\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n             }\n+        }\n \n-            // Traversal vertices of previous level\n-            RepeatEdgeStep finalCurrentStep = currentStep;\n-            traverseIds(this.sources.keySet().iterator(), vid -> {\n-                if (this.reachLimit()) {\n-                    return;\n+        private void processOneForBackward(Id source, Id target) {\n+            for (Node n : this.targets.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n                 }\n-                Iterator<Edge> edges = edgesOfVertex(vid, finalCurrentStep);\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : this.sources.get(vid)) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n \n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.targets.containsKey(target)) {\n-                            for (Node node : this.targets.get(target)) {\n-                                List<Id> path = n.joinPath(node);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.sourcesAll.containsKey(target)) {\n+                    for (Node node : this.sourcesAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            Path newPath = new Path(target, path);\n+                            newPath.reverse();\n+                            this.paths.add(newPath);\n+                            if (this.reachLimit()) {\n+                                return;\n                             }\n                         }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n                     }\n                 }\n-            });\n \n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n+            }\n+        }\n+\n+        private void reInitAllIfNeeded(boolean forward) {\n+            if (forward) {\n+                // Re-init source all if last forward finished one super step\n+                // and not last super step", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5Njk0Mg==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496696942", "bodyText": "ditto", "author": "javeme", "createdAt": "2020-09-29T13:01:17Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        protected int accessedNodes() {\n-            return 0;\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public abstract void traverseOneLayer(\n+                             Map<Id, List<Node>> vertices,\n+                             RepeatEdgeStep step,\n+                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+\n+        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        private void forward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, true);\n         }\n-    }\n \n-    private class ConcurrentTraverser extends Traverser {\n+        private void backward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, false);\n+        }\n \n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n+        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n+            if (this.reachLimit()) {\n+                return;\n+            }\n \n-        private Set<Path> paths;\n+            Iterator<Edge> edges = edgesOfVertex(v, step);\n+            while (edges.hasNext()) {\n+                HugeEdge edge = (HugeEdge) edges.next();\n+                Id target = edge.id().otherVertexId();\n \n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n+                this.processOne(v, target, forward);\n             }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n+        }\n+\n+        private void processOne(Id source, Id target, boolean forward) {\n+            if (forward) {\n+                processOneForForward(source, target);\n+            } else {\n+                processOneForBackward(source, target);\n             }\n-            this.paths = ConcurrentHashMap.newKeySet();\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n+        private void processOneForForward(Id source, Id target) {\n+            for (Node n : this.sources.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n+                }\n+\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.targetsAll.containsKey(target)) {\n+                    for (Node node : this.targetsAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            this.paths.add(new Path(target, path));\n+                            if (this.reachLimit()) {\n+                                return;\n+                            }\n+                        }\n+                    }\n                 }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n \n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = new ConcurrentMultiValuedMap<>();\n-                this.sourceFinishOneStep = false;\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n             }\n+        }\n \n-            // Traversal vertices of previous level\n-            RepeatEdgeStep finalCurrentStep = currentStep;\n-            traverseIds(this.sources.keySet().iterator(), vid -> {\n-                if (this.reachLimit()) {\n-                    return;\n+        private void processOneForBackward(Id source, Id target) {\n+            for (Node n : this.targets.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n                 }\n-                Iterator<Edge> edges = edgesOfVertex(vid, finalCurrentStep);\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : this.sources.get(vid)) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n \n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.targets.containsKey(target)) {\n-                            for (Node node : this.targets.get(target)) {\n-                                List<Id> path = n.joinPath(node);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.sourcesAll.containsKey(target)) {\n+                    for (Node node : this.sourcesAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            Path newPath = new Path(target, path);\n+                            newPath.reverse();\n+                            this.paths.add(newPath);\n+                            if (this.reachLimit()) {\n+                                return;\n                             }\n                         }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n                     }\n                 }\n-            });\n \n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n+            }\n+        }\n+\n+        private void reInitAllIfNeeded(boolean forward) {\n+            if (forward) {\n+                // Re-init source all if last forward finished one super step\n+                // and not last super step\n+                if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n+                    this.sourcesAll = this.newMultiValueMap();\n+                    this.sourceFinishOneStep = false;\n+                }\n+            } else {\n+                // Re-init target all if last forward finished one super step\n+                // and not last super step", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5Nzk0OA==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496697948", "bodyText": "move to previous line", "author": "javeme", "createdAt": "2020-09-29T13:02:50Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -389,228 +413,89 @@ protected int accessedNodes() {\n         }\n     }\n \n-    private class SingleTraverser extends Traverser {\n-\n-        private MultivaluedMap<Id, Node> sources = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targets = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> sourcesAll = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targetsAll = newMultivalueMap();\n-\n-        private Set<Path> paths;\n+    private class ConcurrentTraverser extends Traverser {\n \n-        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n-                               List<RepeatEdgeStep> steps, boolean withRing,\n-                               long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n-            }\n-            this.paths = new PathSet();\n+        public ConcurrentTraverser(Collection<Id> sources,\n+                                   Collection<Id> targets,", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzEzNTM5Mg==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r503135392", "bodyText": "move to previous line will exceed 80 char", "author": "zhoney", "createdAt": "2020-10-12T08:45:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5Nzk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5ODk3Ng==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496698976", "bodyText": "use this \"this.traverseIds()\"\nand don't need \"()\" in \"(id)\"", "author": "javeme", "createdAt": "2020-09-29T13:04:23Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -389,228 +413,89 @@ protected int accessedNodes() {\n         }\n     }\n \n-    private class SingleTraverser extends Traverser {\n-\n-        private MultivaluedMap<Id, Node> sources = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targets = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> sourcesAll = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targetsAll = newMultivalueMap();\n-\n-        private Set<Path> paths;\n+    private class ConcurrentTraverser extends Traverser {\n \n-        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n-                               List<RepeatEdgeStep> steps, boolean withRing,\n-                               long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n-            }\n-            this.paths = new PathSet();\n+        public ConcurrentTraverser(Collection<Id> sources,\n+                                   Collection<Id> targets,\n+                                   List<RepeatEdgeStep> steps, boolean withRing,\n+                                   long capacity, long limit) {\n+            super(sources, targets, steps, withRing, capacity, limit);\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n-                }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = newMultivalueMap();\n-                this.sourceFinishOneStep = false;\n-            }\n-\n-            Iterator<Edge> edges;\n-            // Traversal vertices of previous level\n-            for (Map.Entry<Id, List<Node>> entry : this.sources.entrySet()) {\n-                Id vid = entry.getKey();\n-                edges = edgesOfVertex(vid, currentStep);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : entry.getValue()) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n-\n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.targetsAll.containsKey(target)) {\n-                            for (Node node : this.targetsAll.get(target)) {\n-                                List<Id> path = joinPath(n, node, withRing);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n-                            }\n-                        }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n-                    }\n-                }\n-            }\n-\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n-            }\n-\n-            currentStep.decreaseTimes();\n-            // Re-init sources\n-            if (currentStep.remainTimes() > 0) {\n-                this.sources = newVertices;\n-            } else {\n-                this.sources = this.sourcesAll;\n-                this.sourceFinishOneStep = true;\n-            }\n-            this.stepCount++;\n+        @Override\n+        public Map<Id, List<Node>> newMultiValueMap() {\n+            return new ConcurrentMultiValuedMap<>();\n         }\n \n-        /**\n-         * Search backward from target\n-         */\n-        public void backward() {\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n-            RepeatEdgeStep currentStep = null;\n-\n-            // Find next step to backward\n-            for (int i = this.steps.size() - 1; i >= 0; i--) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.targetIndex = i;\n-                    break;\n-                }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            // Re-init target all if last forward finished one super step and\n-            // not last super step\n-            if (this.targetFinishOneStep && !this.lastSuperStep()) {\n-                this.targetsAll = newMultivalueMap();\n-                this.targetFinishOneStep = false;\n-            }\n+        @Override\n+        public void traverseOneLayer(\n+                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n+                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {\n+            traverseIds(this.sources.keySet().iterator(), (id) -> {", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY5OTUxMw==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496699513", "bodyText": "just named consumer", "author": "javeme", "createdAt": "2020-09-29T13:05:12Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -389,228 +413,89 @@ protected int accessedNodes() {\n         }\n     }\n \n-    private class SingleTraverser extends Traverser {\n-\n-        private MultivaluedMap<Id, Node> sources = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targets = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> sourcesAll = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targetsAll = newMultivalueMap();\n-\n-        private Set<Path> paths;\n+    private class ConcurrentTraverser extends Traverser {\n \n-        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n-                               List<RepeatEdgeStep> steps, boolean withRing,\n-                               long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n-            }\n-            this.paths = new PathSet();\n+        public ConcurrentTraverser(Collection<Id> sources,\n+                                   Collection<Id> targets,\n+                                   List<RepeatEdgeStep> steps, boolean withRing,\n+                                   long capacity, long limit) {\n+            super(sources, targets, steps, withRing, capacity, limit);\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n-                }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = newMultivalueMap();\n-                this.sourceFinishOneStep = false;\n-            }\n-\n-            Iterator<Edge> edges;\n-            // Traversal vertices of previous level\n-            for (Map.Entry<Id, List<Node>> entry : this.sources.entrySet()) {\n-                Id vid = entry.getKey();\n-                edges = edgesOfVertex(vid, currentStep);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : entry.getValue()) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n-\n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.targetsAll.containsKey(target)) {\n-                            for (Node node : this.targetsAll.get(target)) {\n-                                List<Id> path = joinPath(n, node, withRing);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n-                            }\n-                        }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n-                    }\n-                }\n-            }\n-\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n-            }\n-\n-            currentStep.decreaseTimes();\n-            // Re-init sources\n-            if (currentStep.remainTimes() > 0) {\n-                this.sources = newVertices;\n-            } else {\n-                this.sources = this.sourcesAll;\n-                this.sourceFinishOneStep = true;\n-            }\n-            this.stepCount++;\n+        @Override\n+        public Map<Id, List<Node>> newMultiValueMap() {\n+            return new ConcurrentMultiValuedMap<>();\n         }\n \n-        /**\n-         * Search backward from target\n-         */\n-        public void backward() {\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n-            RepeatEdgeStep currentStep = null;\n-\n-            // Find next step to backward\n-            for (int i = this.steps.size() - 1; i >= 0; i--) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.targetIndex = i;\n-                    break;\n-                }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            // Re-init target all if last forward finished one super step and\n-            // not last super step\n-            if (this.targetFinishOneStep && !this.lastSuperStep()) {\n-                this.targetsAll = newMultivalueMap();\n-                this.targetFinishOneStep = false;\n-            }\n+        @Override\n+        public void traverseOneLayer(\n+                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n+                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcwMDQwMQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496700401", "bodyText": "ditto", "author": "javeme", "createdAt": "2020-09-29T13:06:29Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -389,228 +413,89 @@ protected int accessedNodes() {\n         }\n     }\n \n-    private class SingleTraverser extends Traverser {\n-\n-        private MultivaluedMap<Id, Node> sources = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targets = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> sourcesAll = newMultivalueMap();\n-        private MultivaluedMap<Id, Node> targetsAll = newMultivalueMap();\n-\n-        private Set<Path> paths;\n+    private class ConcurrentTraverser extends Traverser {\n \n-        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n-                               List<RepeatEdgeStep> steps, boolean withRing,\n-                               long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n-            }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n-            }\n-            this.paths = new PathSet();\n+        public ConcurrentTraverser(Collection<Id> sources,\n+                                   Collection<Id> targets,\n+                                   List<RepeatEdgeStep> steps, boolean withRing,\n+                                   long capacity, long limit) {\n+            super(sources, targets, steps, withRing, capacity, limit);\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n-                }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = newMultivalueMap();\n-                this.sourceFinishOneStep = false;\n-            }\n-\n-            Iterator<Edge> edges;\n-            // Traversal vertices of previous level\n-            for (Map.Entry<Id, List<Node>> entry : this.sources.entrySet()) {\n-                Id vid = entry.getKey();\n-                edges = edgesOfVertex(vid, currentStep);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : entry.getValue()) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n-\n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.targetsAll.containsKey(target)) {\n-                            for (Node node : this.targetsAll.get(target)) {\n-                                List<Id> path = joinPath(n, node, withRing);\n-                                if (!path.isEmpty()) {\n-                                    this.paths.add(new Path(target, path));\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n-                            }\n-                        }\n-\n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n-                    }\n-                }\n-            }\n-\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.sourcesAll.addAll(entry.getKey(), entry.getValue());\n-            }\n-\n-            currentStep.decreaseTimes();\n-            // Re-init sources\n-            if (currentStep.remainTimes() > 0) {\n-                this.sources = newVertices;\n-            } else {\n-                this.sources = this.sourcesAll;\n-                this.sourceFinishOneStep = true;\n-            }\n-            this.stepCount++;\n+        @Override\n+        public Map<Id, List<Node>> newMultiValueMap() {\n+            return new ConcurrentMultiValuedMap<>();\n         }\n \n-        /**\n-         * Search backward from target\n-         */\n-        public void backward() {\n-            MultivaluedMap<Id, Node> newVertices = newMultivalueMap();\n-            RepeatEdgeStep currentStep = null;\n-\n-            // Find next step to backward\n-            for (int i = this.steps.size() - 1; i >= 0; i--) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.targetIndex = i;\n-                    break;\n-                }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n-\n-            // Re-init target all if last forward finished one super step and\n-            // not last super step\n-            if (this.targetFinishOneStep && !this.lastSuperStep()) {\n-                this.targetsAll = newMultivalueMap();\n-                this.targetFinishOneStep = false;\n-            }\n+        @Override\n+        public void traverseOneLayer(\n+                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n+                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {\n+            traverseIds(this.sources.keySet().iterator(), (id) -> {\n+                biConsumer.accept(id, step);\n+            });\n+        }\n \n-            currentStep.swithDirection();\n-            Iterator<Edge> edges;\n-            // Traversal vertices of previous level\n-            for (Map.Entry<Id, List<Node>> entry : this.targets.entrySet()) {\n-                Id vid = entry.getKey();\n-                edges = edgesOfVertex(vid, currentStep);\n-\n-                while (edges.hasNext()) {\n-                    HugeEdge edge = (HugeEdge) edges.next();\n-                    Id target = edge.id().otherVertexId();\n-\n-                    for (Node n : entry.getValue()) {\n-                        // If have loop, skip target\n-                        if (!this.withRing && n.contains(target)) {\n-                            continue;\n-                        }\n+        @Override\n+        public Set<Path> newPathSet() {\n+            return ConcurrentHashMap.newKeySet();\n+        }\n \n-                        // If cross point exists, path found, concat them\n-                        if (this.lastSuperStep() &&\n-                            this.sourcesAll.containsKey(target)) {\n-                            for (Node node : this.sourcesAll.get(target)) {\n-                                List<Id> path = joinPath(n, node, withRing);\n-                                if (!path.isEmpty()) {\n-                                    Path newPath = new Path(target, path);\n-                                    newPath.reverse();\n-                                    this.paths.add(newPath);\n-                                    if (this.reachLimit()) {\n-                                        return;\n-                                    }\n-                                }\n-                            }\n-                        }\n+        @Override\n+        public void addNode(Map<Id, List<Node>> vertices, Id id, Node node) {\n+            ((ConcurrentMultiValuedMap<Id, Node>) vertices).add(id, node);\n+        }\n \n-                        // Add node to next start-nodes\n-                        newVertices.add(target, new Node(target, n));\n-                    }\n-                }\n+        @Override\n+        public void addNewVerticesToAll(Map<Id, List<Node>> targets) {\n+            ConcurrentMultiValuedMap<Id, Node> vertices =\n+                    (ConcurrentMultiValuedMap<Id, Node>) targets;\n+            for (Map.Entry<Id, List<Node>> entry : this.newVertices.entrySet()) {\n+                vertices.addAll(entry.getKey(), entry.getValue());\n             }\n+        }\n+    }\n \n-            currentStep.swithDirection();\n-\n-            for (Map.Entry<Id, List<Node>> entry : newVertices.entrySet()) {\n-                this.targetsAll.addAll(entry.getKey(), entry.getValue());\n-            }\n+    private class SingleTraverser extends Traverser {\n \n-            currentStep.decreaseTimes();\n-            // Re-init targets\n-            if (currentStep.remainTimes() > 0) {\n-                this.targets = newVertices;\n-            } else {\n-                this.targets = this.targetsAll;\n-                this.targetFinishOneStep = true;\n-            }\n-            this.stepCount++;\n+        public SingleTraverser(Collection<Id> sources, Collection<Id> targets,\n+                               List<RepeatEdgeStep> steps, boolean withRing,\n+                               long capacity, long limit) {\n+            super(sources, targets, steps, withRing, capacity, limit);\n         }\n \n         @Override\n-        public Set<Path> paths() {\n-            return this.paths;\n+        public Map<Id, List<Node>> newMultiValueMap() {\n+            return newMultivalueMap();\n         }\n \n         @Override\n-        public int pathCount() {\n-            return this.paths.size();\n+        public Set<Path> newPathSet() {\n+            return new PathSet();\n         }\n \n-        protected int accessedNodes() {\n-            int size = 0;\n-            for (List<Node> value : this.sourcesAll.values()) {\n-                size += value.size();\n-            }\n-            for (List<Node> value : this.targetsAll.values()) {\n-                size += value.size();\n+        @Override\n+        public void traverseOneLayer(\n+                    Map<Id, List<Node>> vertices, RepeatEdgeStep step,\n+                    BiConsumer<Id, RepeatEdgeStep> biConsumer) {", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcwMTU5OQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496701599", "bodyText": "prefer nextStep", "author": "javeme", "createdAt": "2020-09-29T13:08:14Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcwNDU4OQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496704589", "bodyText": "rename source to sourceV, and rename n to source, same as target", "author": "javeme", "createdAt": "2020-09-29T13:12:38Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        protected int accessedNodes() {\n-            return 0;\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public abstract void traverseOneLayer(\n+                             Map<Id, List<Node>> vertices,\n+                             RepeatEdgeStep step,\n+                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+\n+        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        private void forward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, true);\n         }\n-    }\n \n-    private class ConcurrentTraverser extends Traverser {\n+        private void backward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, false);\n+        }\n \n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n+        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n+            if (this.reachLimit()) {\n+                return;\n+            }\n \n-        private Set<Path> paths;\n+            Iterator<Edge> edges = edgesOfVertex(v, step);\n+            while (edges.hasNext()) {\n+                HugeEdge edge = (HugeEdge) edges.next();\n+                Id target = edge.id().otherVertexId();\n \n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n+                this.processOne(v, target, forward);\n             }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n+        }\n+\n+        private void processOne(Id source, Id target, boolean forward) {\n+            if (forward) {\n+                processOneForForward(source, target);\n+            } else {\n+                processOneForBackward(source, target);\n             }\n-            this.paths = ConcurrentHashMap.newKeySet();\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n+        private void processOneForForward(Id source, Id target) {\n+            for (Node n : this.sources.get(source)) {", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcwODAxMg==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496708012", "bodyText": "ditto", "author": "javeme", "createdAt": "2020-09-29T13:17:24Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        protected int accessedNodes() {\n-            return 0;\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public abstract void traverseOneLayer(\n+                             Map<Id, List<Node>> vertices,\n+                             RepeatEdgeStep step,\n+                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+\n+        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        private void forward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, true);\n         }\n-    }\n \n-    private class ConcurrentTraverser extends Traverser {\n+        private void backward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, false);\n+        }\n \n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n+        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n+            if (this.reachLimit()) {\n+                return;\n+            }\n \n-        private Set<Path> paths;\n+            Iterator<Edge> edges = edgesOfVertex(v, step);\n+            while (edges.hasNext()) {\n+                HugeEdge edge = (HugeEdge) edges.next();\n+                Id target = edge.id().otherVertexId();\n \n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n+                this.processOne(v, target, forward);\n             }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n+        }\n+\n+        private void processOne(Id source, Id target, boolean forward) {\n+            if (forward) {\n+                processOneForForward(source, target);\n+            } else {\n+                processOneForBackward(source, target);\n             }\n-            this.paths = ConcurrentHashMap.newKeySet();\n         }\n \n-        /**\n-         * Search forward from sources\n-         */\n-        public void forward() {\n-            ConcurrentMultiValuedMap<Id, Node> newVertices =\n-                                               new ConcurrentMultiValuedMap<>();\n-            RepeatEdgeStep currentStep = null;\n-            // Find next step to forward\n-            for (int i = 0; i < this.steps.size(); i++) {\n-                RepeatEdgeStep step = this.steps.get(i);\n-                if (step.remainTimes() > 0) {\n-                    currentStep = step;\n-                    this.sourceIndex = i;\n-                    break;\n+        private void processOneForForward(Id source, Id target) {\n+            for (Node n : this.sources.get(source)) {\n+                // If have loop, skip target\n+                if (!this.withRing && n.contains(target)) {\n+                    continue;\n+                }\n+\n+                // If cross point exists, path found, concat them\n+                if (this.lastSuperStep() &&\n+                    this.targetsAll.containsKey(target)) {\n+                    for (Node node : this.targetsAll.get(target)) {\n+                        List<Id> path = joinPath(n, node, this.withRing);\n+                        if (!path.isEmpty()) {\n+                            this.paths.add(new Path(target, path));\n+                            if (this.reachLimit()) {\n+                                return;\n+                            }\n+                        }\n+                    }\n                 }\n-            }\n-            if (currentStep == null) {\n-                return;\n-            }\n \n-            // Re-init source all if last forward finished one super step and\n-            // not last super step\n-            if (this.sourceFinishOneStep && !this.lastSuperStep()) {\n-                this.sourcesAll = new ConcurrentMultiValuedMap<>();\n-                this.sourceFinishOneStep = false;\n+                // Add node to next start-nodes\n+                this.addNodeToNewVertices(target, new Node(target, n));\n             }\n+        }\n \n-            // Traversal vertices of previous level\n-            RepeatEdgeStep finalCurrentStep = currentStep;\n-            traverseIds(this.sources.keySet().iterator(), vid -> {\n-                if (this.reachLimit()) {\n-                    return;\n+        private void processOneForBackward(Id source, Id target) {\n+            for (Node n : this.targets.get(source)) {", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcwODYyOQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496708629", "bodyText": "can we merge the two methods with one, and pass sourcesAll or targetsAll to that method", "author": "javeme", "createdAt": "2020-09-29T13:18:15Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TemplatePathsTraverser.java", "diffHunk": "@@ -132,252 +141,267 @@ public Traverser(List<RepeatEdgeStep> steps,\n             }\n             this.sourceIndex = 0;\n             this.targetIndex = this.steps.size() - 1;\n+\n+            for (Id id : sources) {\n+                this.addNode(this.sources, id, new Node(id));\n+            }\n+            for (Id id : targets) {\n+                this.addNode(this.targets, id, new Node(id));\n+            }\n+            this.sourcesAll.putAll(this.sources);\n+            this.targetsAll.putAll(this.targets);\n+\n+            this.paths = this.newPathSet();\n         }\n \n         public void forward() {\n+            RepeatEdgeStep currentStep = this.step(true);\n+            if (currentStep == null) {\n+                return;\n+            }\n+\n+            this.beforeTraverse(true);\n+\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+            this.afterTraverse(currentStep, true);\n         }\n \n         public void backward() {\n-        }\n+            RepeatEdgeStep currentStep = this.step(false);\n+            if (currentStep == null) {\n+                return;\n+            }\n \n-        public Set<Path> paths() {\n-            return new PathSet();\n-        }\n+            this.beforeTraverse(false);\n \n-        public int pathCount() {\n-            return 0;\n-        }\n+            currentStep.swithDirection();\n+            // Traversal vertices of previous level\n+            traverseOneLayer(this.targets, currentStep, this::backward);\n+            currentStep.swithDirection();\n \n-        protected boolean finish() {\n-            return this.stepCount >= this.totalSteps || this.reachLimit();\n+            this.afterTraverse(currentStep, false);\n         }\n \n-        protected boolean lastStep() {\n-            return this.stepCount == this.totalSteps - 1;\n+        public RepeatEdgeStep step(boolean forward) {\n+            return forward ? this.forwardStep() : this.backwardStep();\n         }\n \n-        protected int accessedNodes() {\n-            return 0;\n+        public void beforeTraverse(boolean forward) {\n+            this.clearNewVertices();\n+            this.reInitAllIfNeeded(forward);\n         }\n \n-        protected boolean reachLimit() {\n-            checkCapacity(this.capacity, this.accessedNodes(),\n-                          \"template paths\");\n-            if (this.limit == NO_LIMIT || this.pathCount() < this.limit) {\n-                return false;\n-            }\n-            return true;\n+        public abstract void traverseOneLayer(\n+                             Map<Id, List<Node>> vertices,\n+                             RepeatEdgeStep step,\n+                             BiConsumer<Id, RepeatEdgeStep> consumer);\n+\n+        public void afterTraverse(RepeatEdgeStep step, boolean forward) {\n+            Map<Id, List<Node>> all = forward ? this.sourcesAll :\n+                                                this.targetsAll;\n+            this.addNewVerticesToAll(all);\n+            this.reInitCurrentIfNeeded(step, forward);\n+            this.stepCount++;\n         }\n \n-        public boolean lastSuperStep() {\n-            return this.targetIndex == this.sourceIndex ||\n-                   this.targetIndex == this.sourceIndex + 1;\n+        private void forward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, true);\n         }\n-    }\n \n-    private class ConcurrentTraverser extends Traverser {\n+        private void backward(Id v, RepeatEdgeStep step) {\n+            this.traverseOne(v, step, false);\n+        }\n \n-        private ConcurrentMultiValuedMap<Id, Node> sources =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targets =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> sourcesAll =\n-                new ConcurrentMultiValuedMap<>();\n-        private ConcurrentMultiValuedMap<Id, Node> targetsAll =\n-                new ConcurrentMultiValuedMap<>();\n+        private void traverseOne(Id v, RepeatEdgeStep step, boolean forward) {\n+            if (this.reachLimit()) {\n+                return;\n+            }\n \n-        private Set<Path> paths;\n+            Iterator<Edge> edges = edgesOfVertex(v, step);\n+            while (edges.hasNext()) {\n+                HugeEdge edge = (HugeEdge) edges.next();\n+                Id target = edge.id().otherVertexId();\n \n-        public ConcurrentTraverser(Collection<Id> sources,\n-                                   Collection<Id> targets,\n-                                   List<RepeatEdgeStep> steps, boolean withRing,\n-                                   long capacity, long limit) {\n-            super(steps, capacity, limit, withRing);\n-            for (Id id : sources) {\n-                this.sources.add(id, new Node(id));\n+                this.processOne(v, target, forward);\n             }\n-            for (Id id : targets) {\n-                this.targets.add(id, new Node(id));\n+        }\n+\n+        private void processOne(Id source, Id target, boolean forward) {\n+            if (forward) {\n+                processOneForForward(source, target);\n+            } else {\n+                processOneForBackward(source, target);", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxMzExMQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496713111", "bodyText": "keep origin", "author": "javeme", "createdAt": "2020-09-29T13:24:29Z", "path": "hugegraph-api/src/main/java/com/baidu/hugegraph/core/GraphManager.java", "diffHunk": "@@ -165,7 +165,7 @@ private HugeAuthenticator authenticator() {\n \n     @SuppressWarnings(\"unused\")\n     private void installLicense(HugeConfig config, String md5) {\n-        LicenseVerifier.instance().install(config, this, md5);\n+//        LicenseVerifier.instance().install(config, this, md5);", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxMzM4Mw==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496713383", "bodyText": "keep in one line", "author": "javeme", "createdAt": "2020-09-29T13:24:51Z", "path": "hugegraph-api/src/main/java/com/baidu/hugegraph/serializer/JsonSerializer.java", "diffHunk": "@@ -286,4 +288,23 @@ public String writeWeightedPaths(WeightedPaths paths,\n         return JsonUtil.toJson(ImmutableMap.of(\"paths\", paths.toMap(),\n                                                \"vertices\", vertices));\n     }\n+\n+    @Override\n+    public String writeNodesWithPath(String name, Set<Id> nodes,\n+                                     Collection<HugeTraverser.Path> paths,\n+                                     Iterator<Vertex> iterator,\n+                                     boolean countOnly) {\n+        List<Map<String, Object>> pathList;\n+        pathList = new ArrayList<>();", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxMzc2MQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496713761", "bodyText": "remove empty line", "author": "javeme", "createdAt": "2020-09-29T13:25:22Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/config/CoreOptions.java", "diffHunk": "@@ -503,4 +503,21 @@ public static synchronized CoreOptions instance() {\n                     disallowEmpty(),\n                     \"./conf/computer.yaml\"\n             );\n+\n+    public static final ConfigOption<Integer> OLTP_CONCURRENT_THREADS =\n+            new ConfigOption<>(\n+                    \"oltp.concurrent_threads\",\n+                    \"Thread number to concurrently execute oltp algorithm.\",\n+                    rangeInt(0, 65535),\n+                    10\n+            );\n+\n+    public static final ConfigOption<Integer> OLTP_CONCURRENT_DEPTH =\n+            new ConfigOption<>(\n+                    \"oltp.concurrent_depth\",\n+                    \"The min depth to enable concurrent oltp algorithm.\",\n+                    rangeInt(0, 65535),\n+                    10\n+            );\n+", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxNDMzNQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496714335", "bodyText": "also refactor this class, and can we share code with templatepath?", "author": "javeme", "createdAt": "2020-09-29T13:26:07Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java", "diffHunk": "@@ -0,0 +1,587 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+import org.apache.tinkerpop.gremlin.structure.Vertex;\n+import org.slf4j.Logger;\n+\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.structure.HugeVertex;\n+import com.baidu.hugegraph.util.E;\n+import com.baidu.hugegraph.util.Log;\n+\n+public class CollectionPathsTraverser extends TpTraverser {\n+\n+    private static final Logger LOG = Log.logger(CollectionPathsTraverser.class);\n+\n+    public CollectionPathsTraverser(HugeGraph graph) {\n+        super(graph, \"collection-paths\");\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public Collection<Path> paths(Iterator<Vertex> sources,\n+                                  Iterator<Vertex> targets,\n+                                  EdgeStep step, int depth, boolean nearest,\n+                                  long capacity, long limit) {\n+        checkCapacity(capacity);\n+        checkLimit(limit);\n+\n+        List<Id> sourceList = new ArrayList<>();\n+        while (sources.hasNext()) {\n+            sourceList.add(((HugeVertex) sources.next()).id());\n+        }\n+        int sourceSize = sourceList.size();\n+        E.checkState(sourceSize >= 1 && sourceSize <= MAX_VERTICES,\n+                     \"The number of source vertices must in [1, %s], \" +\n+                     \"but got: %s\", MAX_VERTICES, sourceList.size());\n+        List<Id> targetList = new ArrayList<>();\n+        while (targets.hasNext()) {\n+            targetList.add(((HugeVertex) targets.next()).id());\n+        }\n+        int targetSize = targetList.size();\n+        E.checkState(targetSize >= 1 && targetSize <= MAX_VERTICES,\n+                     \"The number of target vertices must in [1, %s], \" +\n+                     \"but got: %s\", MAX_VERTICES, sourceList.size());\n+        checkPositive(depth, \"max depth\");\n+\n+        Traverser traverser = depth >= this.concurrentDepth() ?\n+                              this.concurrentTraverser(sourceList, targetList,\n+                                                       step, nearest,\n+                                                       capacity, limit) :\n+                              this.singleTraverser(sourceList, targetList, step,\n+                                                   nearest, capacity, limit);\n+\n+        while (true) {\n+            if (--depth < 0 || traverser.reachLimit()) {\n+                break;\n+            }\n+            traverser.forward();\n+\n+            if (--depth < 0 || traverser.reachLimit()) {\n+                break;\n+            }\n+            traverser.backward();\n+        }\n+        return traverser.paths();\n+    }\n+\n+    private Traverser singleTraverser(List<Id> sources, List<Id> targets,\n+                                      EdgeStep step, boolean nearest,\n+                                      long capacity, long limit) {\n+        return nearest ? new SingleNearestTraverser(sources, targets, step,\n+                                                    capacity, limit) :\n+                         new SingleAllTraverser(sources, targets, step,\n+                                                capacity, limit);\n+    }\n+\n+    private Traverser concurrentTraverser(List<Id> sources, List<Id> targets,\n+                                          EdgeStep step, boolean nearest,\n+                                          long capacity, long limit) {\n+        return new ConcurrentTraverser(sources, targets, step, capacity, limit);", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxNzEyMQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496717121", "bodyText": "refactor with one method and call newSet() of Single and Concurrent", "author": "javeme", "createdAt": "2020-09-29T13:29:42Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CustomizedKneighborTraverser.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.Iterator;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.E;\n+\n+public class CustomizedKneighborTraverser extends TpTraverser {\n+\n+    public CustomizedKneighborTraverser(HugeGraph graph) {\n+        super(graph, \"kneighbor\");\n+    }\n+\n+    public Set<Node> customizedKneighbor(Id source, EdgeStep step,\n+                                         int maxDepth, long limit) {\n+        E.checkNotNull(source, \"source vertex id\");\n+        this.checkVertexExist(source, \"source vertex\");\n+        checkPositive(maxDepth, \"k-neighbor max_depth\");\n+        checkLimit(limit);\n+\n+        if (maxDepth >= this.concurrentDepth() &&\n+            step.direction == Directions.BOTH) {\n+            return this.customizedKneighborConcurrent(source, step,\n+                                                      maxDepth, limit);\n+        } else {\n+            return this.customizedKneighborSingle(source, step,\n+                                                  maxDepth, limit);\n+        }\n+    }\n+\n+    public Set<Node> customizedKneighborConcurrent(Id source, EdgeStep step,\n+                                                   int maxDepth, long limit) {\n+        Set<Node> latest = ConcurrentHashMap.newKeySet();\n+        Set<Node> all = ConcurrentHashMap.newKeySet();\n+\n+        Node sourceV = new KNode(source, null);\n+\n+        latest.add(sourceV);\n+        all.add(sourceV);\n+\n+        while (maxDepth-- > 0) {\n+            long remaining = limit == NO_LIMIT ? NO_LIMIT : limit - all.size();\n+            AtomicLong remain = new AtomicLong(remaining);\n+            latest = this.adjacentVertices(latest, step, all, remain);\n+            int size = all.size() + latest.size();\n+            if (limit != NO_LIMIT && size >= limit) {\n+                int subLength = (int) limit - all.size();\n+                Iterator<Node> iterator = latest.iterator();\n+                for (int i = 0; i < subLength && iterator.hasNext(); i++) {\n+                    all.add(iterator.next());\n+                }\n+                break;\n+            } else {\n+                all.addAll(latest);\n+            }\n+        }\n+\n+        return all;\n+    }\n+\n+    public Set<Node> customizedKneighborSingle(Id source, EdgeStep step,\n+                                               int maxDepth, long limit) {", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxNzQ5MA==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496717490", "bodyText": "ditto", "author": "javeme", "createdAt": "2020-09-29T13:30:07Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CustomizedKoutTraverser.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import com.baidu.hugegraph.HugeException;\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.CollectionUtil;\n+import com.baidu.hugegraph.util.E;\n+\n+public class CustomizedKoutTraverser extends TpTraverser {\n+\n+    public CustomizedKoutTraverser(HugeGraph graph) {\n+        super(graph, \"kout\");\n+    }\n+\n+    public Set<Node> customizedKout(Id source, EdgeStep step, int maxDepth,\n+                                    boolean nearest, long capacity,\n+                                    long limit) {\n+        E.checkNotNull(source, \"source vertex id\");\n+        this.checkVertexExist(source, \"source vertex\");\n+        checkPositive(maxDepth, \"k-out max_depth\");\n+        checkCapacity(capacity);\n+        checkLimit(limit);\n+\n+        Set<Node> results;\n+        if (maxDepth >= this.concurrentDepth() &&\n+            step.direction == Directions.BOTH) {\n+            results = this.customizedKoutConcurrent(source, step, maxDepth,\n+                                                    nearest, capacity);\n+        } else {\n+            results = this.customizedKoutSingle(source, step, maxDepth,\n+                                                nearest, capacity);\n+        }\n+\n+        if (limit != NO_LIMIT && results.size() > limit) {\n+            results = CollectionUtil.subSet(results, 0, (int) limit);\n+        }\n+\n+        return results;\n+    }\n+\n+    public Set<Node> customizedKoutConcurrent(Id source, EdgeStep step,\n+                                              int maxDepth, boolean nearest,\n+                                              long capacity) {\n+        Set<Node> latest = ConcurrentHashMap.newKeySet();\n+        Set<Node> all = ConcurrentHashMap.newKeySet();\n+\n+        Node sourceV = new KNode(source, null);\n+\n+        latest.add(sourceV);\n+        all.add(sourceV);\n+\n+        int depth = maxDepth;\n+        long remaining = capacity == NO_LIMIT ?\n+                         NO_LIMIT : capacity - latest.size();\n+        while (depth-- > 0) {\n+            AtomicLong remain = new AtomicLong(remaining);\n+            if (nearest) {\n+                latest = this.adjacentVertices(latest, step, all, remain);\n+                all.addAll(latest);\n+            } else {\n+                latest = this.adjacentVertices(latest, step, null, remain);\n+            }\n+            if (capacity != NO_LIMIT) {\n+                // Update 'remaining' value to record remaining capacity\n+                remaining -= latest.size();\n+                reachCapacity(remaining, capacity, depth);\n+            }\n+        }\n+\n+        return latest;\n+    }\n+\n+    public Set<Node> customizedKoutSingle(Id source, EdgeStep step,", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxODA2Ng==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496718066", "bodyText": "align", "author": "javeme", "createdAt": "2020-09-29T13:30:53Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java", "diffHunk": "@@ -194,7 +194,13 @@ public SimilarsMap fusiformSimilarity(Iterator<Vertex> vertices,\n     }\n \n     private static void checkGroupArgs(String groupProperty, int minGroups) {\n-        if (groupProperty != null) {\n+        if (groupProperty == null) {\n+            E.checkArgument(minGroups == 0,\n+                            \"Can not set min group count when \" +\n+                                    \"group property not set\");", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcxODY0NA==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496718644", "bodyText": "Can't", "author": "javeme", "createdAt": "2020-09-29T13:31:40Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/FusiformSimilarityTraverser.java", "diffHunk": "@@ -194,7 +194,13 @@ public SimilarsMap fusiformSimilarity(Iterator<Vertex> vertices,\n     }\n \n     private static void checkGroupArgs(String groupProperty, int minGroups) {\n-        if (groupProperty != null) {\n+        if (groupProperty == null) {\n+            E.checkArgument(minGroups == 0,\n+                            \"Can not set min group count when \" +", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyMTI0OQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496721249", "bodyText": "move  Iterator adjacentVertices() to line 293", "author": "javeme", "createdAt": "2020-09-29T13:35:09Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java", "diffHunk": "@@ -259,6 +262,35 @@ public double jaccardSimilarity(Id vertex, Id other, Directions dir,\n         });\n     }\n \n+    protected Set<Node> adjacentVertices(Set<Node> vertices, EdgeStep step,", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyMjU4Ng==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496722586", "bodyText": "prefer move kout/jaccardSimilarity out of this class", "author": "javeme", "createdAt": "2020-09-29T13:36:50Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java", "diffHunk": "@@ -217,10 +218,12 @@ public double jaccardSimilarity(Id vertex, Id other, Directions dir,\n                                   vertex, dir, labelId, degree));\n         Set<Id> targetNeighbors = IteratorUtils.set(this.adjacentVertices(\n                                   other, dir, labelId, degree));\n-        int interNum = CollectionUtil.intersect(sourceNeighbors,\n-                                                targetNeighbors).size();\n-        int unionNum = CollectionUtil.union(sourceNeighbors,\n-                                            targetNeighbors).size();\n+        return jaccardSimilarity(sourceNeighbors, targetNeighbors);\n+    }\n+\n+    public double jaccardSimilarity(Set<Id> set1, Set<Id> set2) {", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjcyMzA5NQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r496723095", "bodyText": "ditto", "author": "javeme", "createdAt": "2020-09-29T13:37:31Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/JaccardSimilarTraverser.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import com.baidu.hugegraph.HugeException;\n+import com.baidu.hugegraph.HugeGraph;\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.type.define.Directions;\n+import com.baidu.hugegraph.util.E;\n+import com.google.common.collect.ImmutableMap;\n+\n+public class JaccardSimilarTraverser extends TpTraverser {\n+\n+    public JaccardSimilarTraverser(HugeGraph graph) {\n+        super(graph, \"jaccard-similar\");\n+    }\n+\n+    public Map<Id, Double> jaccardSimilars(Id source, EdgeStep step,\n+                                           int top, long capacity) {\n+        E.checkNotNull(source, \"source vertex id\");\n+        this.checkVertexExist(source, \"source vertex\");\n+        checkCapacity(capacity);\n+\n+        Map<Id, Double> results;\n+        if (3 >= this.concurrentDepth() &&\n+            step.direction == Directions.BOTH) {\n+            results = this.jaccardSimilarsConcurrent(source, step, capacity);\n+        } else {\n+            results = this.jaccardSimilarsSingle(source, step, capacity);\n+        }\n+\n+        if (top > 0) {\n+            results = HugeTraverser.topN(results, true, top);\n+        }\n+\n+        return results;\n+    }\n+\n+    public Map<Id, Double> jaccardSimilarsConcurrent(Id source, EdgeStep step,\n+                                                     long capacity) {\n+        AtomicLong count = new AtomicLong(0L);\n+        Set<Id> accessed = ConcurrentHashMap.newKeySet();\n+        accessed.add(source);\n+        reachCapacity(count.incrementAndGet(), capacity);\n+\n+        // Query neighbors\n+        Set<Id> layer1s = this.adjacentVertices(source, step);\n+        reachCapacity(count.get() + layer1s.size(), capacity);\n+        count.addAndGet(layer1s.size());\n+        if (layer1s.isEmpty()) {\n+            return ImmutableMap.of();\n+        }\n+\n+        Map<Id, Double> results = new ConcurrentHashMap<>();\n+        Set<Id> layer2All = ConcurrentHashMap.newKeySet();\n+\n+        this.traverseIds(layer1s.iterator(), id -> {\n+            // Skip if accessed already\n+            if (accessed.contains(id)) {\n+                return;\n+            }\n+            Set<Id> layer2s = this.adjacentVertices(id, step);\n+            if (layer2s.isEmpty()) {\n+                results.put(id, 0.0D);\n+            }\n+\n+            layer2All.addAll(layer2s);\n+            reachCapacity(count.get() + layer2All.size(), capacity);\n+            double jaccardSimilarity = this.jaccardSimilarity(layer1s, layer2s);\n+            results.put(id, jaccardSimilarity);\n+            accessed.add(id);\n+        });\n+\n+        count.addAndGet(layer2All.size());\n+\n+        this.traverseIds(layer2All.iterator(), id -> {\n+            // Skip if accessed already\n+            if (accessed.contains(id)) {\n+                return;\n+            }\n+            Set<Id> layer3s = this.adjacentVertices(id, step);\n+            reachCapacity(count.get() + layer3s.size(), capacity);\n+            if (layer3s.isEmpty()) {\n+                results.put(id, 0.0D);\n+            }\n+\n+            double jaccardSimilarity = this.jaccardSimilarity(layer1s, layer3s);\n+            results.put(id, jaccardSimilarity);\n+            accessed.add(id);\n+        });\n+\n+        return results;\n+    }\n+\n+    public Map<Id, Double> jaccardSimilarsSingle(Id source, EdgeStep step,", "originalCommit": "8523889ee44e23f0bccc1282bd3ab2cbac3576f6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "21ea44cac2593462828060d846c5192bc76a78dd", "url": "https://github.com/hugegraph/hugegraph/commit/21ea44cac2593462828060d846c5192bc76a78dd", "message": "improve\n\nChange-Id: I7d6912f33836ac9a36fd0dda82b446780675a390", "committedDate": "2020-10-12T13:10:10Z", "type": "commit"}, {"oid": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "url": "https://github.com/hugegraph/hugegraph/commit/876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "message": "extract path traverser for template paths and collection paths\n\nChange-Id: I5b7441f562106fa3810d6d844c897add3010ef30", "committedDate": "2020-10-13T12:31:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk3OTQxOQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r503979419", "bodyText": "no nearest when Concurrent?", "author": "javeme", "createdAt": "2020-10-13T14:04:05Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java", "diffHunk": "@@ -75,509 +73,215 @@ public CollectionPathsTraverser(HugeGraph graph) {\n                      \"but got: %s\", MAX_VERTICES, sourceList.size());\n         checkPositive(depth, \"max depth\");\n \n-        Traverser traverser = depth >= this.concurrentDepth() ?\n-                              this.concurrentTraverser(sourceList, targetList,\n-                                                       step, nearest,\n-                                                       capacity, limit) :\n-                              this.singleTraverser(sourceList, targetList, step,\n-                                                   nearest, capacity, limit);\n-\n-        while (true) {\n-            if (--depth < 0 || traverser.reachLimit()) {\n-                break;\n-            }\n-            traverser.forward();\n-\n-            if (--depth < 0 || traverser.reachLimit()) {\n-                break;\n+        Traverser traverser;\n+\n+        TraverseStrategy strategy;\n+        if (depth >= this.concurrentDepth()) {\n+            strategy = new ConcurrentTraverseStrategy(this.graph());\n+            traverser = new Traverser(sourceList, targetList, step, depth,\n+                                      capacity, limit, strategy);\n+        } else {\n+            strategy = new SingleTraverseStrategy(this.graph());\n+            if (nearest) {\n+                traverser = new SingleNearestTraverser(sourceList, targetList,", "originalCommit": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4MDE0OA==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r503980148", "bodyText": "unused empty line", "author": "javeme", "createdAt": "2020-10-13T14:05:01Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/CollectionPathsTraverser.java", "diffHunk": "@@ -75,509 +73,215 @@ public CollectionPathsTraverser(HugeGraph graph) {\n                      \"but got: %s\", MAX_VERTICES, sourceList.size());\n         checkPositive(depth, \"max depth\");\n \n-        Traverser traverser = depth >= this.concurrentDepth() ?\n-                              this.concurrentTraverser(sourceList, targetList,\n-                                                       step, nearest,\n-                                                       capacity, limit) :\n-                              this.singleTraverser(sourceList, targetList, step,\n-                                                   nearest, capacity, limit);\n-\n-        while (true) {\n-            if (--depth < 0 || traverser.reachLimit()) {\n-                break;\n-            }\n-            traverser.forward();\n-\n-            if (--depth < 0 || traverser.reachLimit()) {\n-                break;\n+        Traverser traverser;\n+", "originalCommit": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3OTAzMw==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r509079033", "bodyText": "unused empty line", "author": "javeme", "createdAt": "2020-10-21T08:16:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4MDE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4MTg2NQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r503981865", "bodyText": "prefer rename to concurrent", "author": "javeme", "createdAt": "2020-10-13T14:07:15Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/HugeTraverser.java", "diffHunk": "@@ -540,7 +403,15 @@ public static void checkSkipDegree(long skipDegree, long degree,\n     }\n \n     protected static <V> Set<V> newSet() {\n-        return new HashSet<>();\n+        return newSet(true);\n+    }\n+\n+    protected static <V> Set<V> newSet(boolean single) {", "originalCommit": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzk4MjkwMQ==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r503982901", "bodyText": "add a new java file", "author": "javeme", "createdAt": "2020-10-13T14:08:35Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java", "diffHunk": "@@ -160,6 +177,199 @@ protected boolean match(Element elem, String key, Object value) {\n         return p.isPresent() && Objects.equal(p.value(), value);\n     }\n \n+    protected TraverseStrategy traverseStrategy(boolean single) {\n+        return single ? new SingleTraverseStrategy(this.graph()) :\n+                        new ConcurrentTraverseStrategy(this.graph());\n+\n+    }\n+\n+    public abstract class PathTraverser {", "originalCommit": "876b3e1584d768ec09572a41f6726b1f9b2c6f6f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9e8372a3adb05d109ed1c640a0087016ab0ad571", "url": "https://github.com/hugegraph/hugegraph/commit/9e8372a3adb05d109ed1c640a0087016ab0ad571", "message": "improve\n\nChange-Id: I760194b0f02a41873c2157a5ddf59dd4d1c3ceff", "committedDate": "2020-10-14T03:12:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNjY0Mw==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r508436643", "bodyText": "this.traverseOneLayer", "author": "javeme", "createdAt": "2020-10-20T11:52:29Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.traversal.algorithm.strategy.TraverseStrategy;\n+\n+import static com.baidu.hugegraph.traversal.algorithm.HugeTraverser.NO_LIMIT;\n+\n+public abstract class PathTraverser {\n+\n+    protected int stepCount;\n+    protected final long capacity;\n+    protected final long limit;\n+    protected int totalSteps; // TODO: delete or implement abstract method\n+\n+    protected Map<Id, List<HugeTraverser.Node>> sources;\n+    protected Map<Id, List<HugeTraverser.Node>> sourcesAll;\n+    protected Map<Id, List<HugeTraverser.Node>> targets;\n+    protected Map<Id, List<HugeTraverser.Node>> targetsAll;\n+\n+    protected Map<Id, List<HugeTraverser.Node>> newVertices;\n+\n+    protected Set<HugeTraverser.Path> paths;\n+\n+    protected TraverseStrategy traverseStrategy;\n+\n+    public PathTraverser(Collection<Id> sources, Collection<Id> targets,\n+                         long capacity, long limit,\n+                         TraverseStrategy strategy) {\n+        this.traverseStrategy = strategy;\n+\n+        this.capacity = capacity;\n+        this.limit = limit;\n+\n+        this.stepCount = 0;\n+\n+        this.sources = this.newMultiValueMap();\n+        this.sourcesAll = this.newMultiValueMap();\n+        this.targets = this.newMultiValueMap();\n+        this.targetsAll = this.newMultiValueMap();\n+\n+        for (Id id : sources) {\n+            this.addNode(this.sources, id, new HugeTraverser.Node(id));\n+        }\n+        for (Id id : targets) {\n+            this.addNode(this.targets, id, new HugeTraverser.Node(id));\n+        }\n+        this.sourcesAll.putAll(this.sources);\n+        this.targetsAll.putAll(this.targets);\n+\n+        this.paths = this.newPathSet();\n+    }\n+\n+    public void forward() {\n+        EdgeStep currentStep = this.nextStep(true);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(true);\n+\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.sources, currentStep, this::forward);", "originalCommit": "9e8372a3adb05d109ed1c640a0087016ab0ad571", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNzUxMA==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r508437510", "bodyText": "ditto", "author": "javeme", "createdAt": "2020-10-20T11:54:08Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.traversal.algorithm.strategy.TraverseStrategy;\n+\n+import static com.baidu.hugegraph.traversal.algorithm.HugeTraverser.NO_LIMIT;\n+\n+public abstract class PathTraverser {\n+\n+    protected int stepCount;\n+    protected final long capacity;\n+    protected final long limit;\n+    protected int totalSteps; // TODO: delete or implement abstract method\n+\n+    protected Map<Id, List<HugeTraverser.Node>> sources;\n+    protected Map<Id, List<HugeTraverser.Node>> sourcesAll;\n+    protected Map<Id, List<HugeTraverser.Node>> targets;\n+    protected Map<Id, List<HugeTraverser.Node>> targetsAll;\n+\n+    protected Map<Id, List<HugeTraverser.Node>> newVertices;\n+\n+    protected Set<HugeTraverser.Path> paths;\n+\n+    protected TraverseStrategy traverseStrategy;\n+\n+    public PathTraverser(Collection<Id> sources, Collection<Id> targets,\n+                         long capacity, long limit,\n+                         TraverseStrategy strategy) {\n+        this.traverseStrategy = strategy;\n+\n+        this.capacity = capacity;\n+        this.limit = limit;\n+\n+        this.stepCount = 0;\n+\n+        this.sources = this.newMultiValueMap();\n+        this.sourcesAll = this.newMultiValueMap();\n+        this.targets = this.newMultiValueMap();\n+        this.targetsAll = this.newMultiValueMap();\n+\n+        for (Id id : sources) {\n+            this.addNode(this.sources, id, new HugeTraverser.Node(id));\n+        }\n+        for (Id id : targets) {\n+            this.addNode(this.targets, id, new HugeTraverser.Node(id));\n+        }\n+        this.sourcesAll.putAll(this.sources);\n+        this.targetsAll.putAll(this.targets);\n+\n+        this.paths = this.newPathSet();\n+    }\n+\n+    public void forward() {\n+        EdgeStep currentStep = this.nextStep(true);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(true);\n+\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+        this.afterTraverse(currentStep, true);\n+    }\n+\n+    public void backward() {\n+        EdgeStep currentStep = this.nextStep(false);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(false);\n+\n+        currentStep.swithDirection();\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.targets, currentStep, this::backward);", "originalCommit": "9e8372a3adb05d109ed1c640a0087016ab0ad571", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNzczNA==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r508437734", "bodyText": "ditto", "author": "javeme", "createdAt": "2020-10-20T11:54:30Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.traversal.algorithm.strategy.TraverseStrategy;\n+\n+import static com.baidu.hugegraph.traversal.algorithm.HugeTraverser.NO_LIMIT;\n+\n+public abstract class PathTraverser {\n+\n+    protected int stepCount;\n+    protected final long capacity;\n+    protected final long limit;\n+    protected int totalSteps; // TODO: delete or implement abstract method\n+\n+    protected Map<Id, List<HugeTraverser.Node>> sources;\n+    protected Map<Id, List<HugeTraverser.Node>> sourcesAll;\n+    protected Map<Id, List<HugeTraverser.Node>> targets;\n+    protected Map<Id, List<HugeTraverser.Node>> targetsAll;\n+\n+    protected Map<Id, List<HugeTraverser.Node>> newVertices;\n+\n+    protected Set<HugeTraverser.Path> paths;\n+\n+    protected TraverseStrategy traverseStrategy;\n+\n+    public PathTraverser(Collection<Id> sources, Collection<Id> targets,\n+                         long capacity, long limit,\n+                         TraverseStrategy strategy) {\n+        this.traverseStrategy = strategy;\n+\n+        this.capacity = capacity;\n+        this.limit = limit;\n+\n+        this.stepCount = 0;\n+\n+        this.sources = this.newMultiValueMap();\n+        this.sourcesAll = this.newMultiValueMap();\n+        this.targets = this.newMultiValueMap();\n+        this.targetsAll = this.newMultiValueMap();\n+\n+        for (Id id : sources) {\n+            this.addNode(this.sources, id, new HugeTraverser.Node(id));\n+        }\n+        for (Id id : targets) {\n+            this.addNode(this.targets, id, new HugeTraverser.Node(id));\n+        }\n+        this.sourcesAll.putAll(this.sources);\n+        this.targetsAll.putAll(this.targets);\n+\n+        this.paths = this.newPathSet();\n+    }\n+\n+    public void forward() {\n+        EdgeStep currentStep = this.nextStep(true);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(true);\n+\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+        this.afterTraverse(currentStep, true);\n+    }\n+\n+    public void backward() {\n+        EdgeStep currentStep = this.nextStep(false);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(false);\n+\n+        currentStep.swithDirection();\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.targets, currentStep, this::backward);\n+        currentStep.swithDirection();\n+\n+        this.afterTraverse(currentStep, false);\n+    }\n+\n+    public abstract EdgeStep nextStep(boolean forward);\n+\n+    public void beforeTraverse(boolean forward) {\n+        this.clearNewVertices();\n+    }\n+\n+    public void traverseOneLayer(Map<Id, List<HugeTraverser.Node>> vertices,\n+                                 EdgeStep step,\n+                                 BiConsumer<Id, EdgeStep> consumer) {\n+        this.traverseStrategy.traverseOneLayer(vertices, step, consumer);\n+    }\n+\n+    public void afterTraverse(EdgeStep step, boolean forward) {\n+        this.reInitCurrentStepIfNeeded(step, forward);\n+        this.stepCount++;\n+    }\n+\n+    private void forward(Id v, EdgeStep step) {\n+        this.traverseOne(v, step, true);\n+    }\n+\n+    private void backward(Id v, EdgeStep step) {\n+        this.traverseOne(v, step, false);\n+    }\n+\n+    private void traverseOne(Id v, EdgeStep step, boolean forward) {\n+        if (this.reachLimit()) {\n+            return;\n+        }\n+\n+        Iterator<Edge> edges = this.edgesOfVertex(v, step);\n+        while (edges.hasNext()) {\n+            HugeEdge edge = (HugeEdge) edges.next();\n+            Id target = edge.id().otherVertexId();\n+\n+            this.processOne(v, target, forward);\n+        }\n+    }\n+\n+    protected Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep) {\n+        return this.traverseStrategy.edgesOfVertex(source, edgeStep);\n+    }\n+\n+    private void processOne(Id source, Id target, boolean forward) {\n+        if (forward) {\n+            processOneForForward(source, target);", "originalCommit": "9e8372a3adb05d109ed1c640a0087016ab0ad571", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzNzc3Ng==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r508437776", "bodyText": "ditto", "author": "javeme", "createdAt": "2020-10-20T11:54:35Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.traversal.algorithm.strategy.TraverseStrategy;\n+\n+import static com.baidu.hugegraph.traversal.algorithm.HugeTraverser.NO_LIMIT;\n+\n+public abstract class PathTraverser {\n+\n+    protected int stepCount;\n+    protected final long capacity;\n+    protected final long limit;\n+    protected int totalSteps; // TODO: delete or implement abstract method\n+\n+    protected Map<Id, List<HugeTraverser.Node>> sources;\n+    protected Map<Id, List<HugeTraverser.Node>> sourcesAll;\n+    protected Map<Id, List<HugeTraverser.Node>> targets;\n+    protected Map<Id, List<HugeTraverser.Node>> targetsAll;\n+\n+    protected Map<Id, List<HugeTraverser.Node>> newVertices;\n+\n+    protected Set<HugeTraverser.Path> paths;\n+\n+    protected TraverseStrategy traverseStrategy;\n+\n+    public PathTraverser(Collection<Id> sources, Collection<Id> targets,\n+                         long capacity, long limit,\n+                         TraverseStrategy strategy) {\n+        this.traverseStrategy = strategy;\n+\n+        this.capacity = capacity;\n+        this.limit = limit;\n+\n+        this.stepCount = 0;\n+\n+        this.sources = this.newMultiValueMap();\n+        this.sourcesAll = this.newMultiValueMap();\n+        this.targets = this.newMultiValueMap();\n+        this.targetsAll = this.newMultiValueMap();\n+\n+        for (Id id : sources) {\n+            this.addNode(this.sources, id, new HugeTraverser.Node(id));\n+        }\n+        for (Id id : targets) {\n+            this.addNode(this.targets, id, new HugeTraverser.Node(id));\n+        }\n+        this.sourcesAll.putAll(this.sources);\n+        this.targetsAll.putAll(this.targets);\n+\n+        this.paths = this.newPathSet();\n+    }\n+\n+    public void forward() {\n+        EdgeStep currentStep = this.nextStep(true);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(true);\n+\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+        this.afterTraverse(currentStep, true);\n+    }\n+\n+    public void backward() {\n+        EdgeStep currentStep = this.nextStep(false);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(false);\n+\n+        currentStep.swithDirection();\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.targets, currentStep, this::backward);\n+        currentStep.swithDirection();\n+\n+        this.afterTraverse(currentStep, false);\n+    }\n+\n+    public abstract EdgeStep nextStep(boolean forward);\n+\n+    public void beforeTraverse(boolean forward) {\n+        this.clearNewVertices();\n+    }\n+\n+    public void traverseOneLayer(Map<Id, List<HugeTraverser.Node>> vertices,\n+                                 EdgeStep step,\n+                                 BiConsumer<Id, EdgeStep> consumer) {\n+        this.traverseStrategy.traverseOneLayer(vertices, step, consumer);\n+    }\n+\n+    public void afterTraverse(EdgeStep step, boolean forward) {\n+        this.reInitCurrentStepIfNeeded(step, forward);\n+        this.stepCount++;\n+    }\n+\n+    private void forward(Id v, EdgeStep step) {\n+        this.traverseOne(v, step, true);\n+    }\n+\n+    private void backward(Id v, EdgeStep step) {\n+        this.traverseOne(v, step, false);\n+    }\n+\n+    private void traverseOne(Id v, EdgeStep step, boolean forward) {\n+        if (this.reachLimit()) {\n+            return;\n+        }\n+\n+        Iterator<Edge> edges = this.edgesOfVertex(v, step);\n+        while (edges.hasNext()) {\n+            HugeEdge edge = (HugeEdge) edges.next();\n+            Id target = edge.id().otherVertexId();\n+\n+            this.processOne(v, target, forward);\n+        }\n+    }\n+\n+    protected Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep) {\n+        return this.traverseStrategy.edgesOfVertex(source, edgeStep);\n+    }\n+\n+    private void processOne(Id source, Id target, boolean forward) {\n+        if (forward) {\n+            processOneForForward(source, target);\n+        } else {\n+            processOneForBackward(source, target);", "originalCommit": "9e8372a3adb05d109ed1c640a0087016ab0ad571", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQzODI1Mw==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r508438253", "bodyText": "finished", "author": "javeme", "createdAt": "2020-10-20T11:55:25Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/PathTraverser.java", "diffHunk": "@@ -0,0 +1,226 @@\n+/*\n+ * Copyright 2017 HugeGraph Authors\n+ *\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements. See the NOTICE file distributed with this\n+ * work for additional information regarding copyright ownership. The ASF\n+ * licenses this file to You under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package com.baidu.hugegraph.traversal.algorithm;\n+\n+import java.util.Collection;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+\n+import org.apache.tinkerpop.gremlin.structure.Edge;\n+\n+import com.baidu.hugegraph.backend.id.Id;\n+import com.baidu.hugegraph.structure.HugeEdge;\n+import com.baidu.hugegraph.traversal.algorithm.strategy.TraverseStrategy;\n+\n+import static com.baidu.hugegraph.traversal.algorithm.HugeTraverser.NO_LIMIT;\n+\n+public abstract class PathTraverser {\n+\n+    protected int stepCount;\n+    protected final long capacity;\n+    protected final long limit;\n+    protected int totalSteps; // TODO: delete or implement abstract method\n+\n+    protected Map<Id, List<HugeTraverser.Node>> sources;\n+    protected Map<Id, List<HugeTraverser.Node>> sourcesAll;\n+    protected Map<Id, List<HugeTraverser.Node>> targets;\n+    protected Map<Id, List<HugeTraverser.Node>> targetsAll;\n+\n+    protected Map<Id, List<HugeTraverser.Node>> newVertices;\n+\n+    protected Set<HugeTraverser.Path> paths;\n+\n+    protected TraverseStrategy traverseStrategy;\n+\n+    public PathTraverser(Collection<Id> sources, Collection<Id> targets,\n+                         long capacity, long limit,\n+                         TraverseStrategy strategy) {\n+        this.traverseStrategy = strategy;\n+\n+        this.capacity = capacity;\n+        this.limit = limit;\n+\n+        this.stepCount = 0;\n+\n+        this.sources = this.newMultiValueMap();\n+        this.sourcesAll = this.newMultiValueMap();\n+        this.targets = this.newMultiValueMap();\n+        this.targetsAll = this.newMultiValueMap();\n+\n+        for (Id id : sources) {\n+            this.addNode(this.sources, id, new HugeTraverser.Node(id));\n+        }\n+        for (Id id : targets) {\n+            this.addNode(this.targets, id, new HugeTraverser.Node(id));\n+        }\n+        this.sourcesAll.putAll(this.sources);\n+        this.targetsAll.putAll(this.targets);\n+\n+        this.paths = this.newPathSet();\n+    }\n+\n+    public void forward() {\n+        EdgeStep currentStep = this.nextStep(true);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(true);\n+\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.sources, currentStep, this::forward);\n+\n+        this.afterTraverse(currentStep, true);\n+    }\n+\n+    public void backward() {\n+        EdgeStep currentStep = this.nextStep(false);\n+        if (currentStep == null) {\n+            return;\n+        }\n+\n+        this.beforeTraverse(false);\n+\n+        currentStep.swithDirection();\n+        // Traversal vertices of previous level\n+        traverseOneLayer(this.targets, currentStep, this::backward);\n+        currentStep.swithDirection();\n+\n+        this.afterTraverse(currentStep, false);\n+    }\n+\n+    public abstract EdgeStep nextStep(boolean forward);\n+\n+    public void beforeTraverse(boolean forward) {\n+        this.clearNewVertices();\n+    }\n+\n+    public void traverseOneLayer(Map<Id, List<HugeTraverser.Node>> vertices,\n+                                 EdgeStep step,\n+                                 BiConsumer<Id, EdgeStep> consumer) {\n+        this.traverseStrategy.traverseOneLayer(vertices, step, consumer);\n+    }\n+\n+    public void afterTraverse(EdgeStep step, boolean forward) {\n+        this.reInitCurrentStepIfNeeded(step, forward);\n+        this.stepCount++;\n+    }\n+\n+    private void forward(Id v, EdgeStep step) {\n+        this.traverseOne(v, step, true);\n+    }\n+\n+    private void backward(Id v, EdgeStep step) {\n+        this.traverseOne(v, step, false);\n+    }\n+\n+    private void traverseOne(Id v, EdgeStep step, boolean forward) {\n+        if (this.reachLimit()) {\n+            return;\n+        }\n+\n+        Iterator<Edge> edges = this.edgesOfVertex(v, step);\n+        while (edges.hasNext()) {\n+            HugeEdge edge = (HugeEdge) edges.next();\n+            Id target = edge.id().otherVertexId();\n+\n+            this.processOne(v, target, forward);\n+        }\n+    }\n+\n+    protected Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep) {\n+        return this.traverseStrategy.edgesOfVertex(source, edgeStep);\n+    }\n+\n+    private void processOne(Id source, Id target, boolean forward) {\n+        if (forward) {\n+            processOneForForward(source, target);\n+        } else {\n+            processOneForBackward(source, target);\n+        }\n+    }\n+\n+    protected abstract void processOneForForward(Id source, Id target);\n+\n+    protected abstract void processOneForBackward(Id source, Id target);\n+\n+    protected abstract void reInitCurrentStepIfNeeded(EdgeStep step,\n+                                                      boolean forward);\n+\n+    public void clearNewVertices() {\n+        this.newVertices = this.newMultiValueMap();\n+    }\n+\n+    public void addNodeToNewVertices(Id id, HugeTraverser.Node node) {\n+        this.addNode(this.newVertices, id, node);\n+    }\n+\n+    public Map<Id, List<HugeTraverser.Node>> newMultiValueMap() {\n+        return this.traverseStrategy.newMultiValueMap();\n+    }\n+\n+    public Set<HugeTraverser.Path> newPathSet() {\n+        return this.traverseStrategy.newPathSet();\n+    }\n+\n+    public void addNode(Map<Id, List<HugeTraverser.Node>> vertices, Id id,\n+                        HugeTraverser.Node node) {\n+        this.traverseStrategy.addNode(vertices, id, node);\n+    }\n+\n+    public void addNewVerticesToAll(Map<Id, List<HugeTraverser.Node>> targets) {\n+        this.traverseStrategy.addNewVerticesToAll(this.newVertices, targets);\n+    }\n+\n+    public Set<HugeTraverser.Path> paths() {\n+        return this.paths;\n+    }\n+\n+    public int pathCount() {\n+        return this.paths.size();\n+    }\n+\n+    protected boolean finish() {", "originalCommit": "9e8372a3adb05d109ed1c640a0087016ab0ad571", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ1NTgzNg==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r508455836", "bodyText": "delete it", "author": "javeme", "createdAt": "2020-10-20T12:25:02Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/ConcurrentTraverseStrategy.java", "diffHunk": "@@ -71,4 +74,9 @@ public void addNewVerticesToAll(Map<Id, List<Node>> newVertices,\n             vertices.addAll(entry.getKey(), entry.getValue());\n         }\n     }\n+\n+    @Override\n+    public Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep) {\n+        return super.edgesOfVertex(source, edgeStep);\n+    }", "originalCommit": "9e8372a3adb05d109ed1c640a0087016ab0ad571", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODQ1NTk4MA==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r508455980", "bodyText": "delete it", "author": "javeme", "createdAt": "2020-10-20T12:25:15Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java", "diffHunk": "@@ -44,4 +47,6 @@ public abstract void addNode(Map<Id, List<HugeTraverser.Node>> vertices,\n     public abstract void addNewVerticesToAll(\n                          Map<Id, List<HugeTraverser.Node>> newVertices,\n                          Map<Id, List<HugeTraverser.Node>> targets);\n+\n+    public Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep);", "originalCommit": "9e8372a3adb05d109ed1c640a0087016ab0ad571", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4fd93f95cdac548c3d56f431d753a03e5ec6da69", "url": "https://github.com/hugegraph/hugegraph/commit/4fd93f95cdac548c3d56f431d753a03e5ec6da69", "message": "normalize traverser\n\nChange-Id: I68226c55ca387ecfdd103e4af8b5e45faa9a934e", "committedDate": "2020-10-21T03:42:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3NjMzNA==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r509076334", "bodyText": "also rename TpTraverser to OltpTraverser", "author": "javeme", "createdAt": "2020-10-21T08:12:12Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java", "diffHunk": "@@ -41,48 +38,34 @@\n import com.baidu.hugegraph.HugeGraph;\n import com.baidu.hugegraph.backend.id.Id;\n import com.baidu.hugegraph.config.CoreOptions;\n-import com.baidu.hugegraph.config.HugeConfig;\n import com.baidu.hugegraph.iterator.FilterIterator;\n import com.baidu.hugegraph.structure.HugeEdge;\n-import com.baidu.hugegraph.traversal.algorithm.strategy.ConcurrentTraverseStrategy;\n-import com.baidu.hugegraph.traversal.algorithm.strategy.SingleTraverseStrategy;\n-import com.baidu.hugegraph.traversal.algorithm.strategy.TraverseStrategy;\n import com.baidu.hugegraph.util.Consumers;\n \n import jersey.repackaged.com.google.common.base.Objects;\n \n public abstract class TpTraverser extends HugeTraverser\n                                   implements AutoCloseable {\n \n-    protected static ExecutorService executor;\n+    private static final String EXECUTOR_NAME = \"oltp\";", "originalCommit": "4fd93f95cdac548c3d56f431d753a03e5ec6da69", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3NjYxMw==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r509076613", "bodyText": "empty line", "author": "javeme", "createdAt": "2020-10-21T08:12:40Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/strategy/TraverseStrategy.java", "diffHunk": "@@ -48,5 +46,9 @@ public abstract void addNewVerticesToAll(\n                          Map<Id, List<HugeTraverser.Node>> newVertices,\n                          Map<Id, List<HugeTraverser.Node>> targets);\n \n-    public Iterator<Edge> edgesOfVertex(Id source, EdgeStep edgeStep);\n+    public static TraverseStrategy create(boolean concurrent, HugeGraph graph) {\n+        return concurrent ? new ConcurrentTraverseStrategy(graph) :\n+                            new SingleTraverseStrategy(graph);\n+", "originalCommit": "4fd93f95cdac548c3d56f431d753a03e5ec6da69", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA3ODYxMw==", "url": "https://github.com/hugegraph/hugegraph/pull/1174#discussion_r509078613", "bodyText": "lock for null judgment and assignment", "author": "javeme", "createdAt": "2020-10-21T08:15:36Z", "path": "hugegraph-core/src/main/java/com/baidu/hugegraph/traversal/algorithm/TpTraverser.java", "diffHunk": "@@ -41,48 +38,34 @@\n import com.baidu.hugegraph.HugeGraph;\n import com.baidu.hugegraph.backend.id.Id;\n import com.baidu.hugegraph.config.CoreOptions;\n-import com.baidu.hugegraph.config.HugeConfig;\n import com.baidu.hugegraph.iterator.FilterIterator;\n import com.baidu.hugegraph.structure.HugeEdge;\n-import com.baidu.hugegraph.traversal.algorithm.strategy.ConcurrentTraverseStrategy;\n-import com.baidu.hugegraph.traversal.algorithm.strategy.SingleTraverseStrategy;\n-import com.baidu.hugegraph.traversal.algorithm.strategy.TraverseStrategy;\n import com.baidu.hugegraph.util.Consumers;\n \n import jersey.repackaged.com.google.common.base.Objects;\n \n public abstract class TpTraverser extends HugeTraverser\n                                   implements AutoCloseable {\n \n-    protected static ExecutorService executor;\n+    private static final String EXECUTOR_NAME = \"oltp\";\n+    private static ExecutorService executor;\n \n     protected TpTraverser(HugeGraph graph) {\n         super(graph);\n-    }\n-\n-    protected TpTraverser(HugeGraph graph, String name) {\n-        super(graph);\n         if (executor == null) {\n             int workers = this.config().get(CoreOptions.OLTP_CONCURRENT_THREADS);\n             if (workers > 0) {\n-                executor = Consumers.newThreadPool(name, workers);\n+                executor = Consumers.newThreadPool(EXECUTOR_NAME, workers);", "originalCommit": "4fd93f95cdac548c3d56f431d753a03e5ec6da69", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "20c1ff5252049df1ab2f4ad36d6e18af70c71690", "url": "https://github.com/hugegraph/hugegraph/commit/20c1ff5252049df1ab2f4ad36d6e18af70c71690", "message": "improve\n\nChange-Id: I882e472d001c40c0f1ffdc89c1c3c28bd6d34a17", "committedDate": "2020-10-21T08:26:56Z", "type": "commit"}]}