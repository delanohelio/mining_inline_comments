{"pr_number": 15199, "pr_title": "Fix encrypt large value", "pr_createdAt": "2020-09-21T19:38:29Z", "pr_url": "https://github.com/prestodb/presto/pull/15199", "timeline": [{"oid": "ccca0457a599fd036ea3521763759d13ef84d125", "url": "https://github.com/prestodb/presto/commit/ccca0457a599fd036ea3521763759d13ef84d125", "message": "Fix dwrf encryption for large column valuess\n\nWe were using the incorrect offsets for the datat we were encrypting and\nfor the output buffer", "committedDate": "2020-09-21T19:40:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwMzIzMA==", "url": "https://github.com/prestodb/presto/pull/15199#discussion_r492303230", "bodyText": "this test doesn't use testRoundTrip() because there is some bug with the hive reader reading the list value test (unrelated to encryption)", "author": "rschlussel", "createdAt": "2020-09-21T19:42:22Z", "path": "presto-orc/src/test/java/com/facebook/presto/orc/AbstractTestOrcReader.java", "diffHunk": "@@ -493,6 +494,19 @@ public void testDwrfInvalidCheckpointsForStripeDictionary()\n                         .collect(toList()));\n     }\n \n+    @Test\n+    public void testExtraLargeColumnValue()\n+            throws Exception\n+    {\n+\n+        Random rnd = new Random(0);\n+        String val = rnd.doubles(50_000).mapToObj(Double::toString).collect(Collectors.joining(\",\"));\n+        tester.assertRoundTrip(", "originalCommit": "ccca0457a599fd036ea3521763759d13ef84d125", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwODA0NA==", "url": "https://github.com/prestodb/presto/pull/15199#discussion_r492308044", "bodyText": "The message has two %s placeholders, it should either have two length arguments or not have the last %s.", "author": "sdruzkin", "createdAt": "2020-09-21T19:51:40Z", "path": "presto-orc/src/main/java/com/facebook/presto/orc/OrcOutputBuffer.java", "diffHunk": "@@ -446,35 +446,31 @@ private void writeChunkToOutputStream(byte[] chunk, int offset, int length)\n \n         checkArgument(length <= buffer.length, \"Write chunk length must be less than compression buffer size\");\n \n+        boolean isCompressed = false;\n         if (compressor != null) {\n             int minCompressionBufferSize = compressor.maxCompressedLength(length);\n             if (compressionBuffer.length < minCompressionBufferSize) {\n                 compressionBuffer = new byte[minCompressionBufferSize];\n             }\n             int compressedSize = compressor.compress(chunk, offset, length, compressionBuffer, 0, compressionBuffer.length);\n             if (compressedSize < length) {\n-                if (dwrfEncryptor.isPresent()) {\n-                    compressionBuffer = dwrfEncryptor.get().encrypt(compressionBuffer, 0, compressedSize);\n-                    compressedSize = compressionBuffer.length;\n-                    // size after encryption should not exceed what the 3 byte header can hold (2^23)\n-                    if (compressedSize > 8388608) {\n-                        throw new OrcEncryptionException(\"Encrypted data size %s exceeds limit of 2^23 %s\", compressedSize);\n-                    }\n-                }\n-                int chunkHeader = (compressedSize << 1);\n-                writeChunkedOutput(compressionBuffer, 0, compressedSize, chunkHeader);\n-                return;\n+                isCompressed = true;\n+                chunk = compressionBuffer;\n+                length = compressedSize;\n+                offset = 0;\n             }\n         }\n         if (dwrfEncryptor.isPresent()) {\n-            chunk = dwrfEncryptor.get().encrypt(chunk, 0, length);\n+            chunk = dwrfEncryptor.get().encrypt(chunk, offset, length);\n             length = chunk.length;\n+            offset = 0;\n             // size after encryption should not exceed what the 3 byte header can hold (2^23)\n             if (length > 8388608) {\n                 throw new OrcEncryptionException(\"Encrypted data size %s exceeds limit of 2^23 %s\", length);", "originalCommit": "ccca0457a599fd036ea3521763759d13ef84d125", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMxMzQ1Ng==", "url": "https://github.com/prestodb/presto/pull/15199#discussion_r492313456", "bodyText": "good catch, thank you!", "author": "rschlussel", "createdAt": "2020-09-21T20:02:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjMwODA0NA=="}], "type": "inlineReview"}, {"oid": "30228870aa3d20293f2c92f1db579d9aaf0b79b3", "url": "https://github.com/prestodb/presto/commit/30228870aa3d20293f2c92f1db579d9aaf0b79b3", "message": "Fix error message formatting", "committedDate": "2020-09-21T20:19:06Z", "type": "forcePushed"}, {"oid": "353ba0a129e044d6075dd7797f6f3fa8ae68639a", "url": "https://github.com/prestodb/presto/commit/353ba0a129e044d6075dd7797f6f3fa8ae68639a", "message": "Fix dwrf encryption for large column values\n\nWe were using the incorrect offsets for the data we were encrypting and\nfor the output buffer", "committedDate": "2020-09-22T18:59:01Z", "type": "commit"}, {"oid": "217e24b9245dd479963086af5247bb791cc31737", "url": "https://github.com/prestodb/presto/commit/217e24b9245dd479963086af5247bb791cc31737", "message": "Fix error message formatting", "committedDate": "2020-09-22T18:59:01Z", "type": "commit"}, {"oid": "217e24b9245dd479963086af5247bb791cc31737", "url": "https://github.com/prestodb/presto/commit/217e24b9245dd479963086af5247bb791cc31737", "message": "Fix error message formatting", "committedDate": "2020-09-22T18:59:01Z", "type": "forcePushed"}]}