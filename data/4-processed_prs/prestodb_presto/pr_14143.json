{"pr_number": 14143, "pr_title": "Add stats and cost rule for IntersectNode", "pr_createdAt": "2020-02-22T01:12:38Z", "pr_url": "https://github.com/prestodb/presto/pull/14143", "timeline": [{"oid": "01a4fe63d6aaebc5fafea2f1d66a76644b2b9b6f", "url": "https://github.com/prestodb/presto/commit/01a4fe63d6aaebc5fafea2f1d66a76644b2b9b6f", "message": "Add stats and cost rule for IntersectNode", "committedDate": "2020-02-27T01:01:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4OTEyNw==", "url": "https://github.com/prestodb/presto/pull/14143#discussion_r392289127", "bodyText": "This means that for the rowcount we'll use the min of the left and right sides.  I wonder if instead we should also filter based on percentage of overlapping ranges.\ne.g. if the column stats range for a column of one table are values 1-10, and the other table has a range of  5-20, then we would say maybe the new row count is the min of 1/2 the rows in the first table or 1/3 of the rows in the second table.  We could see problems for tables that have big ranges due to outliers (a common problem in all our stats rules, which assume a uniform distribution), so perhaps we should be more conservative that my suggestion so we don't do anything too terrible in that case, but aside from that I think it makes more sense.  @arhimondr what do you think?\nNote: a difference between this and the union node is that the union node is really a UNION ALL node. we do unions as a union all + group by.", "author": "rschlussel", "createdAt": "2020-03-13T15:12:18Z", "path": "presto-main/src/main/java/com/facebook/presto/cost/PlanNodeStatsEstimateMath.java", "diffHunk": "@@ -150,29 +150,41 @@ private static PlanNodeStatsEstimate createZeroStats(PlanNodeStatsEstimate stats\n         StatisticRange add(StatisticRange leftRange, StatisticRange rightRange);\n     }\n \n+    @FunctionalInterface\n+    private interface RowCountMergeStrategy\n+    {\n+        double merge(double left, double right);\n+    }\n+\n     public static PlanNodeStatsEstimate addStatsAndSumDistinctValues(PlanNodeStatsEstimate left, PlanNodeStatsEstimate right)\n     {\n-        return addStats(left, right, StatisticRange::addAndSumDistinctValues);\n+        return addStats(left, right, StatisticRange::addAndSumDistinctValues, Double::sum);\n     }\n \n     public static PlanNodeStatsEstimate addStatsAndMaxDistinctValues(PlanNodeStatsEstimate left, PlanNodeStatsEstimate right)\n     {\n-        return addStats(left, right, StatisticRange::addAndMaxDistinctValues);\n+        return addStats(left, right, StatisticRange::addAndMaxDistinctValues, Double::sum);\n     }\n \n     public static PlanNodeStatsEstimate addStatsAndCollapseDistinctValues(PlanNodeStatsEstimate left, PlanNodeStatsEstimate right)\n     {\n-        return addStats(left, right, StatisticRange::addAndCollapseDistinctValues);\n+        return addStats(left, right, StatisticRange::addAndCollapseDistinctValues, Double::sum);\n+    }\n+\n+    public static PlanNodeStatsEstimate addStatsAndIntersect(PlanNodeStatsEstimate left, PlanNodeStatsEstimate right)", "originalCommit": "01a4fe63d6aaebc5fafea2f1d66a76644b2b9b6f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjc0NTgzNg==", "url": "https://github.com/prestodb/presto/pull/14143#discussion_r392745836", "bodyText": "@rschlussel You are right. In my logic, I was calculating worst-case number of rows (assuming random distribution). However, as you pointed out, the other estimators (filter node, inner join, etc.) assume uniform distribution.\nI will update my estimation logic accordingly.", "author": "ssaumitra", "createdAt": "2020-03-16T01:40:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4OTEyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjYyNTQzNg==", "url": "https://github.com/prestodb/presto/pull/14143#discussion_r412625436", "bodyText": "@rschlussel At this point in code (https://github.com/prestodb/presto/pull/14143/files#diff-59fa6c2264eb72e0587e7e77ce155e59R187), row count is calculated for all columns together. So aggregated ColumnStats are unavailable.\nIn the latest amend, I am evaluating stats for all columns and setting min distinct row count as row count for the intersect operator. Please have a look and let me know if that's correct.", "author": "ssaumitra", "createdAt": "2020-04-22T02:36:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4OTEyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjczMDg1Ng==", "url": "https://github.com/prestodb/presto/pull/14143#discussion_r416730856", "bodyText": "Using an estimated row count and then changing it at the end doesn't really work because it can make the null fraction and such be very far off.  I think instead of reusing the addStats method, you need to implement special logic for this case yourself.\nYou can use overlapPercentwith() from statisticRange in order to estimate the final rowcount (e.g. take the min overlap percent from the different columns and then multiply the rowcount by the overlap percent to get the final result). and then you can combine the column stats using intersect as you're doing already.\n@arhimondr @ssaumitra what do you think?  The alternative is to go back to the original approach of setting the rowcount to the min of the two tables and not doing any range based filters.", "author": "rschlussel", "createdAt": "2020-04-28T15:56:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4OTEyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc4MzI3MQ==", "url": "https://github.com/prestodb/presto/pull/14143#discussion_r416783271", "bodyText": "@rschlussel I did not understand side effect of updating row count completely. I would like to discuss it in more detail. Maybe I can open a conversation thread in Slack later day. Right now, I will just take your word for it.\nI will give a shot to overlapPercentWith approach that you are talking about unless @arhimondr thinks differently.", "author": "ssaumitra", "createdAt": "2020-04-28T17:11:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4OTEyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg0ODA4Nw==", "url": "https://github.com/prestodb/presto/pull/14143#discussion_r416848087", "bodyText": "This means that for the rowcount we'll use the min of the left and right sides. I wonder if instead we should also filter based on percentage of overlapping ranges.\ne.g. if the column stats range for a column of one table are values 1-10, and the other table has a range of 5-20, then we would say maybe the new row count is the min of 1/2 the rows in the first table or 1/3 of the rows in the second table. We could see problems for tables that have big ranges due to outliers (a common problem in all our stats rules, which assume a uniform distribution), so perhaps we should be more conservative that my suggestion so we don't do anything too terrible in that case, but aside from that I think it makes more sense. @arhimondr what do you think?\n\nI think it makes sense", "author": "arhimondr", "createdAt": "2020-04-28T18:55:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4OTEyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzcxMTUxNw==", "url": "https://github.com/prestodb/presto/pull/14143#discussion_r417711517", "bodyText": "I have now updated row counting logic.", "author": "ssaumitra", "createdAt": "2020-04-30T01:54:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjI4OTEyNw=="}], "type": "inlineReview"}, {"oid": "64f6e7e3c7960f2daa0b94828d1a453167993138", "url": "https://github.com/prestodb/presto/commit/64f6e7e3c7960f2daa0b94828d1a453167993138", "message": "Add stats and cost rule for IntersectNode", "committedDate": "2020-04-22T02:15:41Z", "type": "forcePushed"}, {"oid": "59e0108a32c90e62377470271bf8fdc1589ea9de", "url": "https://github.com/prestodb/presto/commit/59e0108a32c90e62377470271bf8fdc1589ea9de", "message": "Add stats and cost rule for IntersectNode", "committedDate": "2020-04-22T02:31:38Z", "type": "forcePushed"}, {"oid": "228b1a3f3237d27ac8b47aebc1d3ebe747797331", "url": "https://github.com/prestodb/presto/commit/228b1a3f3237d27ac8b47aebc1d3ebe747797331", "message": "Add stats and cost rule for IntersectNode", "committedDate": "2020-04-28T02:00:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjcxMTg1NA==", "url": "https://github.com/prestodb/presto/pull/14143#discussion_r416711854", "bodyText": "why did you get rid of the argument check? also, same comment about formatting method arguments.", "author": "rschlussel", "createdAt": "2020-04-28T15:33:23Z", "path": "presto-main/src/main/java/com/facebook/presto/cost/PlanNodeStatsEstimateMath.java", "diffHunk": "@@ -165,38 +167,62 @@ public static PlanNodeStatsEstimate addStatsAndCollapseDistinctValues(PlanNodeSt\n         return addStats(left, right, StatisticRange::addAndCollapseDistinctValues);\n     }\n \n-    private static PlanNodeStatsEstimate addStats(PlanNodeStatsEstimate left, PlanNodeStatsEstimate right, RangeAdditionStrategy strategy)\n+    public static PlanNodeStatsEstimate addStatsAndIntersect(PlanNodeStatsEstimate left, PlanNodeStatsEstimate right)\n+    {\n+        if (left.isOutputRowCountUnknown() || right.isOutputRowCountUnknown()) {\n+            return PlanNodeStatsEstimate.unknown();\n+        }\n+\n+        PlanNodeStatsEstimate.Builder statsBuilder = PlanNodeStatsEstimate.builder();\n+        double estimatedRowCount = Math.min(left.getOutputRowCount(), right.getOutputRowCount());\n+\n+        List<Double> allRowCounts = buildVariableStatistics(\n+                left, right, statsBuilder, estimatedRowCount, StatisticRange::intersect);\n+\n+        double preciseRowCount = allRowCounts.stream().reduce(estimatedRowCount, Double::min);\n+        return statsBuilder.setOutputRowCount(preciseRowCount).build();\n+    }\n+\n+    private static PlanNodeStatsEstimate addStats(PlanNodeStatsEstimate left, PlanNodeStatsEstimate right,\n+            RangeAdditionStrategy rangeAdder)\n     {\n         if (left.isOutputRowCountUnknown() || right.isOutputRowCountUnknown()) {\n             return PlanNodeStatsEstimate.unknown();\n         }\n \n         PlanNodeStatsEstimate.Builder statsBuilder = PlanNodeStatsEstimate.builder();\n-        double newRowCount = left.getOutputRowCount() + right.getOutputRowCount();\n+        double rowCount = left.getOutputRowCount() + right.getOutputRowCount();\n+        buildVariableStatistics(left, right, statsBuilder, rowCount, rangeAdder);\n+\n+        return statsBuilder.setOutputRowCount(rowCount).build();\n+    }\n \n+    private static List<Double> buildVariableStatistics(PlanNodeStatsEstimate left, PlanNodeStatsEstimate right,\n+            PlanNodeStatsEstimate.Builder statsBuilder, double estimatedRowCount, RangeAdditionStrategy rangeAdder)\n+    {\n+        List<Double> allRowCounts = new LinkedList<>();\n         concat(left.getVariablesWithKnownStatistics().stream(), right.getVariablesWithKnownStatistics().stream())\n                 .distinct()\n                 .forEach(symbol -> {\n                     VariableStatsEstimate symbolStats = VariableStatsEstimate.zero();\n-                    if (newRowCount > 0) {\n+                    if (estimatedRowCount > 0) {\n                         symbolStats = addColumnStats(\n                                 left.getVariableStatistics(symbol),\n                                 left.getOutputRowCount(),\n                                 right.getVariableStatistics(symbol),\n                                 right.getOutputRowCount(),\n-                                newRowCount,\n-                                strategy);\n+                                estimatedRowCount,\n+                                rangeAdder);\n                     }\n                     statsBuilder.addVariableStatistics(symbol, symbolStats);\n+                    allRowCounts.add(symbolStats.getDistinctValuesCount());\n                 });\n-\n-        return statsBuilder.setOutputRowCount(newRowCount).build();\n+        return allRowCounts;\n     }\n \n-    private static VariableStatsEstimate addColumnStats(VariableStatsEstimate leftStats, double leftRows, VariableStatsEstimate rightStats, double rightRows, double newRowCount, RangeAdditionStrategy strategy)\n+    private static VariableStatsEstimate addColumnStats(VariableStatsEstimate leftStats, double leftRows,", "originalCommit": "228b1a3f3237d27ac8b47aebc1d3ebe747797331", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc3NjY4OA==", "url": "https://github.com/prestodb/presto/pull/14143#discussion_r416776688", "bodyText": "This was indeed a mistake while moving the lines of code around. Thanks for catching it. I will bring this back.", "author": "ssaumitra", "createdAt": "2020-04-28T17:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjcxMTg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjcxMzA4OQ==", "url": "https://github.com/prestodb/presto/pull/14143#discussion_r416713089", "bodyText": "style note: we either have all the arguments on one line, or if that's too long, we split it to one per-line.", "author": "rschlussel", "createdAt": "2020-04-28T15:34:56Z", "path": "presto-main/src/main/java/com/facebook/presto/cost/PlanNodeStatsEstimateMath.java", "diffHunk": "@@ -165,38 +167,62 @@ public static PlanNodeStatsEstimate addStatsAndCollapseDistinctValues(PlanNodeSt\n         return addStats(left, right, StatisticRange::addAndCollapseDistinctValues);\n     }\n \n-    private static PlanNodeStatsEstimate addStats(PlanNodeStatsEstimate left, PlanNodeStatsEstimate right, RangeAdditionStrategy strategy)\n+    public static PlanNodeStatsEstimate addStatsAndIntersect(PlanNodeStatsEstimate left, PlanNodeStatsEstimate right)\n+    {\n+        if (left.isOutputRowCountUnknown() || right.isOutputRowCountUnknown()) {\n+            return PlanNodeStatsEstimate.unknown();\n+        }\n+\n+        PlanNodeStatsEstimate.Builder statsBuilder = PlanNodeStatsEstimate.builder();\n+        double estimatedRowCount = Math.min(left.getOutputRowCount(), right.getOutputRowCount());\n+\n+        List<Double> allRowCounts = buildVariableStatistics(\n+                left, right, statsBuilder, estimatedRowCount, StatisticRange::intersect);\n+\n+        double preciseRowCount = allRowCounts.stream().reduce(estimatedRowCount, Double::min);\n+        return statsBuilder.setOutputRowCount(preciseRowCount).build();\n+    }\n+\n+    private static PlanNodeStatsEstimate addStats(PlanNodeStatsEstimate left, PlanNodeStatsEstimate right,", "originalCommit": "228b1a3f3237d27ac8b47aebc1d3ebe747797331", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjc4NDEyMw==", "url": "https://github.com/prestodb/presto/pull/14143#discussion_r416784123", "bodyText": "Okay. I did not know that. I see several other pre-existing functions in this file were not following this convention. I will update the new function as well as other existing ones.", "author": "ssaumitra", "createdAt": "2020-04-28T17:13:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjcxMzA4OQ=="}], "type": "inlineReview"}, {"oid": "fadbbd65123d96477dfdfa606ca60644e12baf52", "url": "https://github.com/prestodb/presto/commit/fadbbd65123d96477dfdfa606ca60644e12baf52", "message": "Add stats and cost rule for IntersectNode", "committedDate": "2020-04-28T17:14:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjg0ODc0OQ==", "url": "https://github.com/prestodb/presto/pull/14143#discussion_r416848749", "bodyText": "nit: Please use ImmutableList.builder()", "author": "arhimondr", "createdAt": "2020-04-28T18:56:16Z", "path": "presto-main/src/main/java/com/facebook/presto/cost/PlanNodeStatsEstimateMath.java", "diffHunk": "@@ -165,35 +168,72 @@ public static PlanNodeStatsEstimate addStatsAndCollapseDistinctValues(PlanNodeSt\n         return addStats(left, right, StatisticRange::addAndCollapseDistinctValues);\n     }\n \n-    private static PlanNodeStatsEstimate addStats(PlanNodeStatsEstimate left, PlanNodeStatsEstimate right, RangeAdditionStrategy strategy)\n+    public static PlanNodeStatsEstimate addStatsAndIntersect(PlanNodeStatsEstimate left, PlanNodeStatsEstimate right)\n     {\n         if (left.isOutputRowCountUnknown() || right.isOutputRowCountUnknown()) {\n             return PlanNodeStatsEstimate.unknown();\n         }\n \n         PlanNodeStatsEstimate.Builder statsBuilder = PlanNodeStatsEstimate.builder();\n-        double newRowCount = left.getOutputRowCount() + right.getOutputRowCount();\n+        double estimatedRowCount = Math.min(left.getOutputRowCount(), right.getOutputRowCount());\n+\n+        List<Double> allRowCounts = buildVariableStatistics(\n+                left, right, statsBuilder, estimatedRowCount, StatisticRange::intersect);\n+\n+        double preciseRowCount = allRowCounts.stream().reduce(estimatedRowCount, Double::min);\n+        return statsBuilder.setOutputRowCount(preciseRowCount).build();\n+    }\n \n+    private static PlanNodeStatsEstimate addStats(\n+            PlanNodeStatsEstimate left,\n+            PlanNodeStatsEstimate right,\n+            RangeAdditionStrategy rangeAdder)\n+    {\n+        if (left.isOutputRowCountUnknown() || right.isOutputRowCountUnknown()) {\n+            return PlanNodeStatsEstimate.unknown();\n+        }\n+\n+        PlanNodeStatsEstimate.Builder statsBuilder = PlanNodeStatsEstimate.builder();\n+        double rowCount = left.getOutputRowCount() + right.getOutputRowCount();\n+        buildVariableStatistics(left, right, statsBuilder, rowCount, rangeAdder);\n+\n+        return statsBuilder.setOutputRowCount(rowCount).build();\n+    }\n+\n+    private static List<Double> buildVariableStatistics(\n+            PlanNodeStatsEstimate left,\n+            PlanNodeStatsEstimate right,\n+            PlanNodeStatsEstimate.Builder statsBuilder,\n+            double estimatedRowCount,\n+            RangeAdditionStrategy rangeAdder)\n+    {\n+        List<Double> allRowCounts = new LinkedList<>();", "originalCommit": "fadbbd65123d96477dfdfa606ca60644e12baf52", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "56de83454d6e687fc9a63bb5f90a9367679db45d", "url": "https://github.com/prestodb/presto/commit/56de83454d6e687fc9a63bb5f90a9367679db45d", "message": "Add stats and cost rule for IntersectNode", "committedDate": "2020-04-30T01:47:47Z", "type": "commit"}, {"oid": "56de83454d6e687fc9a63bb5f90a9367679db45d", "url": "https://github.com/prestodb/presto/commit/56de83454d6e687fc9a63bb5f90a9367679db45d", "message": "Add stats and cost rule for IntersectNode", "committedDate": "2020-04-30T01:47:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzcxMjc1MQ==", "url": "https://github.com/prestodb/presto/pull/14143#discussion_r417712751", "bodyText": "@rschlussel This happens when nulls in left and right are more than row count of intersect. In intersect clause nulls will appear in the result when value of rest of the columns will match. So I felt that estimating null fraction at column level is tricky. I am considering conservative case here when all nulls from left and right land in the output. Please let me know if it's incorrect. Sorry for bit of a trial-and-error here.", "author": "ssaumitra", "createdAt": "2020-04-30T01:59:15Z", "path": "presto-main/src/main/java/com/facebook/presto/cost/PlanNodeStatsEstimateMath.java", "diffHunk": "@@ -205,7 +248,7 @@ private static VariableStatsEstimate addColumnStats(VariableStatsEstimate leftSt\n         double nullsCountLeft = leftStats.getNullsFraction() * leftRows;\n         double totalSizeLeft = (leftRows - nullsCountLeft) * leftStats.getAverageRowSize();\n         double totalSizeRight = (rightRows - nullsCountRight) * rightStats.getAverageRowSize();\n-        double newNullsFraction = (nullsCountLeft + nullsCountRight) / newRowCount;\n+        double newNullsFraction = Math.min((nullsCountLeft + nullsCountRight) / newRowCount, 1);", "originalCommit": "56de83454d6e687fc9a63bb5f90a9367679db45d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}