{"pr_number": 13967, "pr_title": "Properly handle optimizable filter expressions", "pr_createdAt": "2020-01-15T00:52:22Z", "pr_url": "https://github.com/prestodb/presto/pull/13967", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY2NDk3Mg==", "url": "https://github.com/prestodb/presto/pull/13967#discussion_r366664972", "bodyText": "@bhhari Filter expressions that get optimized into null should be eliminated at the query planning phase. Why is this not happening? CC: @highker", "author": "mbasmanova", "createdAt": "2020-01-15T02:03:44Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/HivePageSourceProvider.java", "diffHunk": "@@ -177,8 +178,15 @@ public ConnectorPageSource createPageSource(ConnectorTransactionHandle transacti\n             TypeManager typeManager,\n             LoadingCache<RowExpressionCacheKey, RowExpression> rowExpressionCache)\n     {\n-        Set<HiveColumnHandle> interimColumns = ImmutableSet.<HiveColumnHandle>builder()\n-                .addAll(layout.getPredicateColumns().values())\n+        RowExpression optimizedRemainingPredicate = rowExpressionCache.getUnchecked(new RowExpressionCacheKey(layout.getRemainingPredicate(), session));\n+\n+        ImmutableSet.Builder<HiveColumnHandle> interimColumnsBuilder = ImmutableSet.builder();", "originalCommit": "4350626cb69399a8163f04ab44cb629c99b224ef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2Njg1MjkxMw==", "url": "https://github.com/prestodb/presto/pull/13967#discussion_r366852913", "bodyText": "@bhhari There is another scenario that needs to be handled. An original expression may use 3 columns, but optimized one only one column. In this case, we need to scan only one column, not three.", "author": "mbasmanova", "createdAt": "2020-01-15T12:37:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY2NDk3Mg=="}], "type": "inlineReview"}, {"oid": "c3bcbe703327b1e3035294cb5809e1654be6c942", "url": "https://github.com/prestodb/presto/commit/c3bcbe703327b1e3035294cb5809e1654be6c942", "message": "Optimize remaining expression and return empty result if its null/false\n\nA SelectiveStreamReader should be created only if the column is in output\nor is required in a filter function evaluation. We get the columns\nto be read from unoptimized expression, but column mappings are created from\noptimized expression which will result in error if optimization results in discarding\nany column. The fix is addressing the case where the whole expression is\noptimized to null or false and return empty. If there are 2 columns and the optimization\nresults in removing 1 then we still have an issue.", "committedDate": "2020-01-16T01:58:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwMDg1NQ==", "url": "https://github.com/prestodb/presto/pull/13967#discussion_r367200855", "bodyText": "@bhhari Looks like there is some redundancy here. The expression is being split into tuple domain and remaining predicate and these parts are being checked for \"always-false\" separately. Let's just optimize the whole expression and check the result.\nLooks like translatedExpression.getRemainingExpression(), can be replaced by expression and logic using translatedExpression can be removed.\n        // optimize rowExpression and return ValuesNode if false. e.g. 0=1 => false, 1>2 => false, (a = 1 and a = 2) => false\n        RowExpression optimizedRemainingExpression = new RowExpressionOptimizer(metadata).optimize(expression, OPTIMIZED, session.toConnectorSession());\n        if (optimizedRemainingExpression instanceof ConstantExpression) {\n            ConstantExpression constantExpression = (ConstantExpression) optimizedRemainingExpression;\n            if (FALSE_CONSTANT.equals(constantExpression) || constantExpression.getValue() == null) {\n                return new ValuesNode(idAllocator.getNextId(), node.getOutputVariables(), ImmutableList.of());\n            }\n        }\n\nThere is still a question about the case when optimized expression is not always-false, but rather uses fewer columns when original expression. This will generate an error, right?", "author": "mbasmanova", "createdAt": "2020-01-16T02:13:26Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/iterative/rule/PickTableLayout.java", "diffHunk": "@@ -329,6 +333,14 @@ public static PlanNode pushPredicateIntoTableScan(\n             return new ValuesNode(idAllocator.getNextId(), node.getOutputVariables(), ImmutableList.of());\n         }\n \n+        RowExpression optimizedRemainingExpression = new RowExpressionOptimizer(metadata).optimize(translatedExpression.getRemainingExpression(), OPTIMIZED, session.toConnectorSession());", "originalCommit": "c3bcbe703327b1e3035294cb5809e1654be6c942", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNTkzNA==", "url": "https://github.com/prestodb/presto/pull/13967#discussion_r367205934", "bodyText": "yes mentioned that in the commit message, it looks like if we use the optmization level as \"Optimize\" we can not serialize it back. This commit only solves the case where its null/false", "author": "bhhari", "createdAt": "2020-01-16T02:38:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwMDg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwNjYxOA==", "url": "https://github.com/prestodb/presto/pull/13967#discussion_r367206618", "bodyText": "@bhhari  Are you planning to add another commit to fix the remaining issue. Something similar to the original fix could work. E.g. prune the predicate columns on the worker after optimizing the remaining expression.", "author": "mbasmanova", "createdAt": "2020-01-16T02:42:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwMDg1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwOTg5MA==", "url": "https://github.com/prestodb/presto/pull/13967#discussion_r367209890", "bodyText": "I m going to update the same commit, prune it during the planning", "author": "bhhari", "createdAt": "2020-01-16T02:59:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIwMDg1NQ=="}], "type": "inlineReview"}, {"oid": "02aedacfb0e16e7369b701a77e39b68765d0cee9", "url": "https://github.com/prestodb/presto/commit/02aedacfb0e16e7369b701a77e39b68765d0cee9", "message": "Optimize remaining expression and return empty result if its null/false\n\nA SelectiveStreamReader should be created only if the column is in output\nor is required in a filter function evaluation. We get the columns\nto be read from unoptimized expression, but column mappings are created from\noptimized expression which will result in error if optimization results in discarding\nany column. The fix is addressing the case where the whole expression is\noptimized to null or false and return empty. If there are 2 columns and the optimization\nresults in removing 1 then we only add the remaining column in pushdown", "committedDate": "2020-01-16T03:00:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIxMjU2OA==", "url": "https://github.com/prestodb/presto/pull/13967#discussion_r367212568", "bodyText": "Let's add a test case for expression over multiple columns being optimized into an expression over fewer columns.", "author": "mbasmanova", "createdAt": "2020-01-16T03:13:14Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/HiveMetadata.java", "diffHunk": "@@ -1911,7 +1911,9 @@ public ConnectorPushdownFilterResult pushdownFilter(ConnectorSession session, Co\n         domainPredicate.getDomains().get().keySet().stream()\n                 .map(Subfield::getRootName)\n                 .forEach(predicateColumnNames::add);\n-        extractAll(decomposedFilter.getRemainingExpression()).stream()\n+        // optimize the remaining expression before adding to predicateColumns", "originalCommit": "02aedacfb0e16e7369b701a77e39b68765d0cee9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIxMjg2NA==", "url": "https://github.com/prestodb/presto/pull/13967#discussion_r367212864", "bodyText": "I'm seeing the following test case failing. It used to work because PickTableLayout extracted tuple domain and checked for isNone. I don't think that's a proper way though. It seems like HiveMetadata.pushdownFilter needs to check decomposedFilter.getTupleDomain() for isNone.\n        assertPlan(pushdownFilterEnabled(), \"SELECT linenumber FROM lineitem WHERE linenumber > 10 AND linenumber < 0\",\n                output(values(\"linenumber\")));", "author": "mbasmanova", "createdAt": "2020-01-16T03:14:59Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/HiveMetadata.java", "diffHunk": "@@ -1911,7 +1911,9 @@ public ConnectorPushdownFilterResult pushdownFilter(ConnectorSession session, Co\n         domainPredicate.getDomains().get().keySet().stream()\n                 .map(Subfield::getRootName)\n                 .forEach(predicateColumnNames::add);\n-        extractAll(decomposedFilter.getRemainingExpression()).stream()\n+        // optimize the remaining expression before adding to predicateColumns\n+        RowExpression optimizedRemainingExpression = rowExpressionService.getExpressionOptimizer().optimize(decomposedFilter.getRemainingExpression(), OPTIMIZED, session);\n+        extractAll(optimizedRemainingExpression).stream()", "originalCommit": "02aedacfb0e16e7369b701a77e39b68765d0cee9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIyMzU0NQ==", "url": "https://github.com/prestodb/presto/pull/13967#discussion_r367223545", "bodyText": "yes looks like the optimization does not do a good job there, so I will put my previous version", "author": "bhhari", "createdAt": "2020-01-16T04:15:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIxMjg2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzUwNjEwNA==", "url": "https://github.com/prestodb/presto/pull/13967#discussion_r367506104", "bodyText": "@bhhari The previous version is masking the bug in the connector, but it doesn't fix it. The connector must handle properly the case when tuple domain part of the expression matches nothing (e.g. isNone() == true). Currently, it treats it as if any value matches. You can see that the bug is still there, by changing the query to use range filters on struct subfields:\nSELECT id FROM test WHERE x.a > 10 AND x.a < 0\n\nHere, the connector simply drops the filter as if it is always true.\nA proper fix could be to\n\n[Hive connector] check isNone on tuple domain and return new ConnectorPushdownFilterResult(getTableLayout(session, currentLayoutHandle.get()), FALSE_CONSTANT);\n[Hive connector] check if optimized remaining expression is always false and  return new ConnectorPushdownFilterResult(getTableLayout(session, currentLayoutHandle.get()), FALSE_CONSTANT);\n[Engine/PickTableLayout] Optimize entire expression and, if always false, return ValuesNode without calling the connector. This optimization is optional though. There might not be any reason to put it in. E.g. the change might be to just remove the existing optimization that extracts tuple domain and checks it for isNone.", "author": "mbasmanova", "createdAt": "2020-01-16T16:06:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzIxMjg2NA=="}], "type": "inlineReview"}, {"oid": "53970e35c030cf98cea1ff5f145f0cc4c20abdce", "url": "https://github.com/prestodb/presto/commit/53970e35c030cf98cea1ff5f145f0cc4c20abdce", "message": "Optimize remaining expression and return empty result if its null/false\n\nA SelectiveStreamReader should be created only if the column is in output\nor is required in a filter function evaluation. We get the columns\nto be read from unoptimized expression, but column mappings are created from\noptimized expression which will result in error if optimization results in discarding\nany column. The fix is addressing the case where the whole expression is\noptimized to null or false and return empty. If there are 2 columns and the optimization\nresults in removing 1 then we only add the remaining column in pushdown", "committedDate": "2020-01-16T09:04:59Z", "type": "forcePushed"}, {"oid": "215d673daece59f0ac056bd15958149d6ec8bffc", "url": "https://github.com/prestodb/presto/commit/215d673daece59f0ac056bd15958149d6ec8bffc", "message": "Optimize remaining expression and return empty result if its null/false\n\nA SelectiveStreamReader should be created only if the column is in output\nor is required in a filter function evaluation. We get the columns\nto be read from unoptimized expression, but column mappings are created from\noptimized expression which will result in error if optimization results in discarding\nany column. The fix is addressing the case where the whole expression is\noptimized to null or false and return empty. If there are 2 columns and the optimization\nresults in removing 1 then we only add the remaining column in pushdown", "committedDate": "2020-01-16T09:10:06Z", "type": "forcePushed"}, {"oid": "2f531d3eac42e1d013c0c924ae0f5802fbf66dc8", "url": "https://github.com/prestodb/presto/commit/2f531d3eac42e1d013c0c924ae0f5802fbf66dc8", "message": "Optimize remaining expression and return empty result if its null/false\n\nA SelectiveStreamReader should be created only if the column is in output\nor is required in a filter function evaluation. We get the columns\nto be read from unoptimized expression, but column mappings are created from\noptimized expression which will result in error if optimization results in discarding\nany column. The fix is addressing the case where the whole expression is\noptimized to null or false and return empty. If there are 2 columns and the optimization\nresults in removing 1 then we only add the remaining column in pushdown", "committedDate": "2020-01-17T23:12:46Z", "type": "forcePushed"}, {"oid": "76ebb8e532132c466544cef147263b26ce703f1c", "url": "https://github.com/prestodb/presto/commit/76ebb8e532132c466544cef147263b26ce703f1c", "message": "Optimize remaining expression and return empty result if its null/false\n\nA SelectiveStreamReader should be created only if the column is in output\nor is required in a filter function evaluation. We get the columns\nto be read from unoptimized expression, but column mappings are created from\noptimized expression which will result in error if optimization results in discarding\nany column. The fix is addressing the case where the whole expression is\noptimized to null or false and return empty. If there are 2 columns and the optimization\nresults in removing 1 then we only add the remaining column in pushdown", "committedDate": "2020-01-17T23:48:49Z", "type": "forcePushed"}, {"oid": "2cfd14e0d63451c8a03c775685b147e63fa21872", "url": "https://github.com/prestodb/presto/commit/2cfd14e0d63451c8a03c775685b147e63fa21872", "message": "Optimize remaining expression and return empty result if its null/false\n\nA SelectiveStreamReader should be created only if the column is in output\nor is required in a filter function evaluation. We get the columns\nto be read from unoptimized expression, but column mappings are created from\noptimized expression which will result in error if optimization results in discarding\nany column. The fix is addressing the case where the whole expression is\noptimized to null or false and return empty. If there are 2 columns and the optimization\nresults in removing 1 then we only add the remaining column in pushdown", "committedDate": "2020-01-17T23:53:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkyMzI0OA==", "url": "https://github.com/prestodb/presto/pull/13967#discussion_r368923248", "bodyText": "I think it would be clearer to make an empty layout and run this check earlier in this method\nI would also update PickTableLayout to remove the logic of extracting TupleDomain and checking for none.\n\nprivate static final ConnectorTableLayout EMPTY_TABLE_LAYOUT = new ConnectorTableLayout(new ConnectorTableLayoutHandle() {}) {};\n\n        ExtractionResult<Subfield> decomposedFilter = rowExpressionService.getDomainTranslator()\n                .fromPredicate(session, filter, new SubfieldExtractor(functionResolution, rowExpressionService.getExpressionOptimizer(), session).toColumnExtractor());\n        if (currentLayoutHandle.isPresent()) {\n            HiveTableLayoutHandle currentHiveLayout = (HiveTableLayoutHandle) currentLayoutHandle.get();\n            decomposedFilter = intersectExtractionResult(decomposedFilter, new ExtractionResult(currentHiveLayout.getDomainPredicate(), currentHiveLayout.getRemainingPredicate()));\n        }\n\n        if (decomposedFilter.getTupleDomain().isNone()) {\n            return new ConnectorPushdownFilterResult(EMPTY_TABLE_LAYOUT, FALSE_CONSTANT);\n        }\n\n        RowExpression optimizedRemainingExpression = rowExpressionService.getExpressionOptimizer().optimize(decomposedFilter.getRemainingExpression(), OPTIMIZED, session);\n        if (optimizedRemainingExpression instanceof ConstantExpression) {\n            ConstantExpression constantExpression = (ConstantExpression) optimizedRemainingExpression;\n            if (FALSE_CONSTANT.equals(constantExpression) || constantExpression.getValue() == null) {\n                return new ConnectorPushdownFilterResult(EMPTY_TABLE_LAYOUT, FALSE_CONSTANT);\n            }\n        }", "author": "mbasmanova", "createdAt": "2020-01-21T10:34:11Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/HiveMetadata.java", "diffHunk": "@@ -1894,8 +1895,25 @@ public ConnectorPushdownFilterResult pushdownFilter(ConnectorSession session, Co\n             }\n         }\n \n+        SchemaTableName tableName = ((HiveTableHandle) tableHandle).getSchemaTableName();\n         HivePartitionResult hivePartitionResult = partitionManager.getPartitions(metastore, tableHandle, constraint, session);\n \n+        //if TupleDomain isNone or optmized remaningExpression is false return ConnectorPushdownFilterResult with TupleDomain.none() layout\n+        if (decomposedFilter.getTupleDomain().isNone()) {\n+            return new ConnectorPushdownFilterResult(", "originalCommit": "2cfd14e0d63451c8a03c775685b147e63fa21872", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTI0ODc3OA==", "url": "https://github.com/prestodb/presto/pull/13967#discussion_r369248778", "bodyText": "\"I would also update PickTableLayout to remove the logic of extracting TupleDomain and checking for none.\"  This will result in assertion failure in MetadaManager.pushdownFilter", "author": "bhhari", "createdAt": "2020-01-21T21:20:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkyMzI0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkyNTkwMg==", "url": "https://github.com/prestodb/presto/pull/13967#discussion_r368925902", "bodyText": "This logic relies on the execution to optimize the expression before evaluation. Let's add a comment to highlight this requirement.\n        // Include only columns referenced in the optimized expression. Although the expression is sent to the worker node \n        // unoptimized, the worker is expected to optimize the expression before executing.\n        extractAll(optimizedRemainingExpression).stream()\n                .map(VariableReferenceExpression::getName)\n                .forEach(predicateColumnNames::add);", "author": "mbasmanova", "createdAt": "2020-01-21T10:39:51Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/HiveMetadata.java", "diffHunk": "@@ -1911,37 +1929,42 @@ public ConnectorPushdownFilterResult pushdownFilter(ConnectorSession session, Co\n         domainPredicate.getDomains().get().keySet().stream()\n                 .map(Subfield::getRootName)\n                 .forEach(predicateColumnNames::add);\n-        extractAll(decomposedFilter.getRemainingExpression()).stream()\n+        extractAll(optimizedRemainingExpression).stream()", "originalCommit": "2cfd14e0d63451c8a03c775685b147e63fa21872", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkyODgyNg==", "url": "https://github.com/prestodb/presto/pull/13967#discussion_r368928826", "bodyText": "Let's also add test cases where both tuple domain and remaining predicate are present, but one of them is always-false.\nLet's update comments for consistency, e.g. use \"remaining predicate\" or \"filter function\" but not both\nnit: capitalize SQL keywords in the queries: orderkey = 1 AND orderkey = 2\nLet's add a test case for always-false tuple domain on subfield; I'd put this into testPushdownFilterOnSubfields method\n\n        // Remaining predicate is NULL\n        assertPlan(pushdownFilterEnabled, \"SELECT linenumber FROM lineitem WHERE cardinality(NULL) > 0\",\n                output(values(\"linenumber\")));\n\n        assertPlan(pushdownFilterEnabled, \"SELECT linenumber FROM lineitem WHERE orderkey > 10 AND cardinality(NULL) > 0\",\n                output(values(\"linenumber\")));\n\n        // Remaining predicate is always FALSE\n        assertPlan(pushdownFilterEnabled, \"SELECT linenumber FROM lineitem WHERE cardinality(ARRAY[1]) > 1\",\n                output(values(\"linenumber\")));\n\n        assertPlan(pushdownFilterEnabled, \"SELECT linenumber FROM lineitem WHERE orderkey > 10 AND cardinality(ARRAY[1]) > 1\",\n                output(values(\"linenumber\")));\n\n        // TupleDomain predicate is always FALSE\n        assertPlan(pushdownFilterEnabled, \"SELECT linenumber FROM lineitem WHERE orderkey = 1 AND orderkey = 2\",\n                output(values(\"linenumber\")));\n\n        assertPlan(pushdownFilterEnabled, \"SELECT linenumber FROM lineitem WHERE orderkey = 1 AND orderkey = 2 AND linenumber % 2 = 1\",\n                output(values(\"linenumber\")));\n\n-- testPushdownFilterOnSubfields\n\n        // TupleDomain predicate is always FALSE\n        assertPlan(pushdownFilterEnabled(), \"SELECT id FROM test_pushdown_filter_on_subfields WHERE c.a = 1 AND c.a = 2\",\n                output(values(\"id\")));", "author": "mbasmanova", "createdAt": "2020-01-21T10:45:59Z", "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestHiveLogicalPlanner.java", "diffHunk": "@@ -181,6 +182,17 @@ public void testPushdownFilter()\n                 output(exchange(project(\n                         filter(\"mod(orderkey, 2) = 1\",\n                                 strictTableScan(\"lineitem\", identityMap(\"linenumber\", \"orderkey\")))))));\n+        // Null remaining predicate", "originalCommit": "2cfd14e0d63451c8a03c775685b147e63fa21872", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODkyOTQ3OA==", "url": "https://github.com/prestodb/presto/pull/13967#discussion_r368929478", "bodyText": "use assertQueryReturnsEmptyResult here", "author": "mbasmanova", "createdAt": "2020-01-21T10:47:22Z", "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestHivePushdownFilterQueries.java", "diffHunk": "@@ -644,6 +644,7 @@ public void testStructs()\n         // filter-only struct\n         assertQueryUsingH2Cte(\"SELECT orderkey FROM lineitem_ex WHERE info IS NOT NULL\");\n         assertQueryUsingH2Cte(\"SELECT orderkey FROM lineitem_ex WHERE info IS NOT NULL AND info.orderkey = 16515\", rewriter);\n+        assertQueryUsingH2Cte(\"SELECT orderkey FROM lineitem_ex WHERE info IS NOT NULL AND info.orderkey = 16515 and info.orderkye = 16516\", rewriter);", "originalCommit": "2cfd14e0d63451c8a03c775685b147e63fa21872", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODk2NTI4OA==", "url": "https://github.com/prestodb/presto/pull/13967#discussion_r368965288", "bodyText": "This query is a bit difficult to understand. Consider a simpler one:\nSELECT partkey FROM lineitem WHERE orderkey > 10 OR if(json_extract(json_parse('{}'), '$.a') IS NOT NULL, quantity * discount) > 0\n\nThe results of that query can be verified and the verification could double-serve as documentation:\n        assertQuery(\"SELECT partkey FROM lineitem WHERE orderkey > 10 OR if(json_extract(json_parse('{}'), '$.a') IS NOT NULL, quantity * discount) > 0\",\n                \"SELECT partkey FROM lineitem WHERE orderkey > 10\");\n\nIt would be nice to add this test to TestHiveLogicalPlanner where we can verify explicitly the list of columns in layout.predicateColumns.", "author": "mbasmanova", "createdAt": "2020-01-21T12:11:53Z", "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestHivePushdownFilterQueries.java", "diffHunk": "@@ -1033,6 +1034,15 @@ public void testNans()\n         }\n     }\n \n+    @Test\n+    public void testFilterFunctionsWithOptimization()\n+    {\n+        // the RowExpressionOptimizer optimizes the second part of the 2nd cardinality function to null hence not pushing down the linenumber as required predicate column\n+        assertQuerySucceeds(getSession(), \"SELECT partkey FROM lineitem WHERE \" +\n+                \"cardinality(ARRAY_INTERSECT(ARRAY[orderkey], map_values(CAST(json_extract(json_parse('{\\\"a\\\": {\\\"a1\\\": {\\\"0\\\": 1}}}'),concat(concat('$.', 'a'), '[\\\"a1\\\"]')) AS MAP(VARCHAR, BIGINT))))) > 0 \" +", "originalCommit": "2cfd14e0d63451c8a03c775685b147e63fa21872", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d5906f94ff6fae44618a95d31be4edef5dd2342b", "url": "https://github.com/prestodb/presto/commit/d5906f94ff6fae44618a95d31be4edef5dd2342b", "message": "Optimize remaining expression and return empty result if its null/false\n\nA SelectiveStreamReader should be created only if the column is in output\nor is required in a filter function evaluation. We get the columns\nto be read from unoptimized expression, but column mappings are created from\noptimized expression which will result in error if optimization results in discarding\nany column. The fix is addressing the case where the whole expression is\noptimized to null or false and return empty. If there are 2 columns and the optimization\nresults in removing 1 then we only add the remaining column in pushdown", "committedDate": "2020-01-21T21:12:09Z", "type": "forcePushed"}, {"oid": "cb5c0607a585b0677949ee4c145dffe65bd1e7e5", "url": "https://github.com/prestodb/presto/commit/cb5c0607a585b0677949ee4c145dffe65bd1e7e5", "message": "Optimize remaining expression and return empty result if its null/false\n\nA SelectiveStreamReader should be created only if the column is in output\nor is required in a filter function evaluation. We get the columns\nto be read from unoptimized expression, but column mappings are created from\noptimized expression which will result in error if optimization results in discarding\nany column. The fix is addressing the case where the whole expression is\noptimized to null or false and return empty. If there are 2 columns and the optimization\nresults in removing 1 then we only add the remaining column in pushdown", "committedDate": "2020-01-21T21:25:37Z", "type": "forcePushed"}, {"oid": "9947665b8b038257b8beeab09c7f60138edd8748", "url": "https://github.com/prestodb/presto/commit/9947665b8b038257b8beeab09c7f60138edd8748", "message": "Optimize remaining expression and return empty result if its null/false\n\nA SelectiveStreamReader should be created only if the column is in output\nor is required in a filter function evaluation. We get the columns\nto be read from unoptimized expression, but column mappings are created from\noptimized expression which will result in error if optimization results in discarding\nany column. The fix is addressing the case where the whole expression is\noptimized to null or false and return empty. If there are 2 columns and the optimization\nresults in removing 1 then we only add the remaining column in pushdown", "committedDate": "2020-01-21T21:53:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMzMTMyMA==", "url": "https://github.com/prestodb/presto/pull/13967#discussion_r369331320", "bodyText": "This comment is too low level for this high-level test. Consider removing.", "author": "mbasmanova", "createdAt": "2020-01-22T01:31:18Z", "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestHivePushdownFilterQueries.java", "diffHunk": "@@ -1033,6 +1034,14 @@ public void testNans()\n         }\n     }\n \n+    @Test\n+    public void testFilterFunctionsWithOptimization()\n+    {\n+        // the RowExpressionOptimizer optimizes the second part of the 2nd cardinality function to null hence not pushing down the linenumber as required predicate column", "originalCommit": "9947665b8b038257b8beeab09c7f60138edd8748", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTMzMTU0Mw==", "url": "https://github.com/prestodb/presto/pull/13967#discussion_r369331543", "bodyText": "typos: replaceExpression() may further optimize the expression; if the resulting expression is always false, then return empty Values node", "author": "mbasmanova", "createdAt": "2020-01-22T01:32:15Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/iterative/rule/PickTableLayout.java", "diffHunk": "@@ -323,17 +324,17 @@ public static PlanNode pushPredicateIntoTableScan(\n             expression = predicate;\n         }\n \n-        // optimize rowExpression and return ValuesNode if false. e.g. 0=1 => false, 1>2 => false, (a = 1 and a = 2) => false\n-        DomainTranslator.ExtractionResult<VariableReferenceExpression> translatedExpression = translator.fromPredicate(session.toConnectorSession(), expression, BASIC_COLUMN_EXTRACTOR);\n-        if (translatedExpression.getTupleDomain().isNone()) {\n-            return new ValuesNode(idAllocator.getNextId(), node.getOutputVariables(), ImmutableList.of());\n-        }\n-\n         BiMap<VariableReferenceExpression, VariableReferenceExpression> symbolToColumnMapping = node.getAssignments().entrySet().stream()\n                 .collect(toImmutableBiMap(\n                         Map.Entry::getKey,\n                         entry -> new VariableReferenceExpression(getColumnName(session, metadata, node.getTable(), entry.getValue()), entry.getKey().getType())));\n-        PushdownFilterResult pushdownFilterResult = metadata.pushdownFilter(session, node.getTable(), replaceExpression(expression, symbolToColumnMapping));\n+\n+        RowExpression replacedExpression = replaceExpression(expression, symbolToColumnMapping);\n+        // replaceExpression() may further optimize the expression, if the resulting expression is false and return an empty result", "originalCommit": "9947665b8b038257b8beeab09c7f60138edd8748", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "66da21130687492af996e2f5f1f3e3580cfa0a7f", "url": "https://github.com/prestodb/presto/commit/66da21130687492af996e2f5f1f3e3580cfa0a7f", "message": "Properly handle optimizable filter expressions\n\nFilter expression can be optimized to a constant value (true, false or null) or to a\nsimpler expression that uses fewer inputs (columns). Make sure to read only\ncolumns that are references from the optimized expression and replace table\nscan node with empty values node if filter expression can be optimized to false or null.", "committedDate": "2020-01-22T04:35:01Z", "type": "forcePushed"}, {"oid": "bf9a4b1e63d360ebcd261c5623dfcebd28ff5858", "url": "https://github.com/prestodb/presto/commit/bf9a4b1e63d360ebcd261c5623dfcebd28ff5858", "message": "Properly handle optimizable filter expressions\n\nFilter expression can be optimized to a constant value (true, false or null) or\nto a simpler expression that uses fewer inputs (columns). Make sure to read only\ncolumns that are references from the optimized expression and replace table\nscan node with empty values node if filter expression can be optimized to false or null.", "committedDate": "2020-01-22T07:39:11Z", "type": "commit"}, {"oid": "bf9a4b1e63d360ebcd261c5623dfcebd28ff5858", "url": "https://github.com/prestodb/presto/commit/bf9a4b1e63d360ebcd261c5623dfcebd28ff5858", "message": "Properly handle optimizable filter expressions\n\nFilter expression can be optimized to a constant value (true, false or null) or\nto a simpler expression that uses fewer inputs (columns). Make sure to read only\ncolumns that are references from the optimized expression and replace table\nscan node with empty values node if filter expression can be optimized to false or null.", "committedDate": "2020-01-22T07:39:11Z", "type": "forcePushed"}]}