{"pr_number": 14076, "pr_title": "Fix like pattern interpretation", "pr_createdAt": "2020-02-10T06:45:24Z", "pr_url": "https://github.com/prestodb/presto/pull/14076", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4NjMyNw==", "url": "https://github.com/prestodb/presto/pull/14076#discussion_r377286327", "bodyText": "I might use escape != null rather than hasEscape. I actually don't understand why hasEscape has to exist. \ud83d\ude02Also I think it's easier to read if you write write an if-else block with two different functionInvoker.invoke calls rather than this.", "author": "rongrong", "createdAt": "2020-02-10T20:02:38Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/RowExpressionInterpreter.java", "diffHunk": "@@ -883,8 +883,13 @@ private SpecialCallResult tryHandleLike(CallExpression callExpression, List<Obje\n                 if (possibleCompiledPattern == null) {\n                     return changed(null);\n                 }\n-                checkState((resolution.isCastFunction(((CallExpression) possibleCompiledPattern).getFunctionHandle())));\n-                possibleCompiledPattern = functionInvoker.invoke(((CallExpression) possibleCompiledPattern).getFunctionHandle(), session, nonCompiledPattern);\n+\n+                checkState(possibleCompiledPattern instanceof CallExpression);\n+                // this corresponds to ExpressionInterpreter::getConstantPattern\n+                Object[] arguments = hasEscape ? new Object[] {nonCompiledPattern, escape} : new Object[] {nonCompiledPattern};", "originalCommit": "b54f5e10c18731a57f7462656aa26e199680ce36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzM2NzEyNg==", "url": "https://github.com/prestodb/presto/pull/14076#discussion_r377367126", "bodyText": "Also curious why this part doesn't exist in previous code? -- From the comment it's corresponding to ExpressionInterpreter::getConstantPattern? :)", "author": "wenleix", "createdAt": "2020-02-10T22:56:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4NjMyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQzNDQwMA==", "url": "https://github.com/prestodb/presto/pull/14076#discussion_r377434400", "bodyText": "@wenleix, I think the original code was always wrong. It didn't respect the original ExpressionInterpreter::getConstantPattern semantics. @rongrong, escape != null and hasEscape should both exist. Because the escape part could be a function that returns a varchar. But the function is on-null-return-null so that the escape part could be null. That will directly nullify the like function as well though it has the escape part.", "author": "highker", "createdAt": "2020-02-11T03:36:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4NjMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4ODI1Mw==", "url": "https://github.com/prestodb/presto/pull/14076#discussion_r377288253", "bodyText": "I'm looking at the implementation of this function and I'm confused. What's the difference between nonCompiledPattern and value? It might be simpler to follow the logic if you just re-interpret the argument values unconditionally rather than sometimes do it and some times don't. If there's benefit in using both the processed and unprocessed versions of the arguments, could you document the differences and why this is needed?", "author": "rongrong", "createdAt": "2020-02-10T20:06:59Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/RowExpressionInterpreter.java", "diffHunk": "@@ -883,8 +883,13 @@ private SpecialCallResult tryHandleLike(CallExpression callExpression, List<Obje\n                 if (possibleCompiledPattern == null) {\n                     return changed(null);\n                 }\n-                checkState((resolution.isCastFunction(((CallExpression) possibleCompiledPattern).getFunctionHandle())));\n-                possibleCompiledPattern = functionInvoker.invoke(((CallExpression) possibleCompiledPattern).getFunctionHandle(), session, nonCompiledPattern);\n+", "originalCommit": "b54f5e10c18731a57f7462656aa26e199680ce36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzQzMzgwMg==", "url": "https://github.com/prestodb/presto/pull/14076#discussion_r377433802", "bodyText": "value LIKE pattern (escape). This is the logic. value is for like function. pattern and escape are for like_pattern function to compile a pattern (possibly with an escape) to regex. If like_pattern is called, then we don't have nonCompiledPattern; otherwise, we have possibleCompiledPattern.\nWe cannot always do or don't. It depends on when we wanna serialize it, evaluate it or optimize it. For example, if the given SQL is an expression with all constants, we just evaluate it. Otherwise, we should serialize it on the coordinator and optimize it on the worker. By serializing we mean not to evaluate like_pattern because Regex cannot be serialized to be sent to workers. However, on worker, we have to optimize it because we don't want to call like_pattern for every row.", "author": "highker", "createdAt": "2020-02-11T03:32:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NzI4ODI1Mw=="}], "type": "inlineReview"}, {"oid": "6e238b052d8539f99d27ea115666be1990babb50", "url": "https://github.com/prestodb/presto/commit/6e238b052d8539f99d27ea115666be1990babb50", "message": "Fix like pattern interpretation\n\nlike pattern constant folding happens only when the optimization level\nis above SERIALIZABLE. However, RowExpressionInterpreter::tryHandleLike\nhandles like function in a way that it will take the constant folded\nlike pattern result together with the original arguments. Under such\ncase, tryHandleLike expects the given constant folded like pattern\nshould always be a compiled Regex but is not in the above case.\n\nThe patch relaxes the restriction on the like pattern to be more\ngeneric. As long as the return type is Regex, tryHandleLike should be\nable to handle it.", "committedDate": "2020-02-11T03:27:14Z", "type": "commit"}, {"oid": "6e238b052d8539f99d27ea115666be1990babb50", "url": "https://github.com/prestodb/presto/commit/6e238b052d8539f99d27ea115666be1990babb50", "message": "Fix like pattern interpretation\n\nlike pattern constant folding happens only when the optimization level\nis above SERIALIZABLE. However, RowExpressionInterpreter::tryHandleLike\nhandles like function in a way that it will take the constant folded\nlike pattern result together with the original arguments. Under such\ncase, tryHandleLike expects the given constant folded like pattern\nshould always be a compiled Regex but is not in the above case.\n\nThe patch relaxes the restriction on the like pattern to be more\ngeneric. As long as the return type is Regex, tryHandleLike should be\nable to handle it.", "committedDate": "2020-02-11T03:27:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ3ODM1OQ==", "url": "https://github.com/prestodb/presto/pull/14076#discussion_r378478359", "bodyText": "So you mean even when hasEscape == true, escape can still be null?", "author": "rongrong", "createdAt": "2020-02-12T19:53:36Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/RowExpressionInterpreter.java", "diffHunk": "@@ -883,8 +883,19 @@ private SpecialCallResult tryHandleLike(CallExpression callExpression, List<Obje\n                 if (possibleCompiledPattern == null) {\n                     return changed(null);\n                 }\n-                checkState((resolution.isCastFunction(((CallExpression) possibleCompiledPattern).getFunctionHandle())));\n-                possibleCompiledPattern = functionInvoker.invoke(((CallExpression) possibleCompiledPattern).getFunctionHandle(), session, nonCompiledPattern);\n+\n+                checkState(possibleCompiledPattern instanceof CallExpression);\n+                // this corresponds to ExpressionInterpreter::getConstantPattern\n+                if (hasEscape) {\n+                    // like_pattern(pattern, escape)\n+                    possibleCompiledPattern = functionInvoker.invoke(((CallExpression) possibleCompiledPattern).getFunctionHandle(), session, nonCompiledPattern, escape);", "originalCommit": "6e238b052d8539f99d27ea115666be1990babb50", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ4MDM5Nw==", "url": "https://github.com/prestodb/presto/pull/14076#discussion_r378480397", "bodyText": "yes", "author": "highker", "createdAt": "2020-02-12T19:57:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ3ODM1OQ=="}], "type": "inlineReview"}]}