{"pr_number": 15477, "pr_title": "Reduce output buffer lock contention", "pr_createdAt": "2020-11-25T15:22:22Z", "pr_url": "https://github.com/prestodb/presto/pull/15477", "timeline": [{"oid": "330a77491af9a081799e69959e105102ec9d80aa", "url": "https://github.com/prestodb/presto/commit/330a77491af9a081799e69959e105102ec9d80aa", "message": "Avoid synchronizing in OutputBufferMemoryManager#isOverutilized()", "committedDate": "2020-11-25T17:20:00Z", "type": "forcePushed"}, {"oid": "aa5a0680a6ad957f3b824ba504a25f7a413dd716", "url": "https://github.com/prestodb/presto/commit/aa5a0680a6ad957f3b824ba504a25f7a413dd716", "message": "Remove lock contention bottlenecks from OutputBufferMemoryManager\n\n- Adds a fast-path to getBufferBlockedFuture() that avoids synchronizing\n  when the buffer is in a blocked state.\n- Avoids synchronizing for isOverutilized()\n- Refactors updateMemoryUsage (the hot path) to move some code outside\n  of the critical section and avoid registering more than one listener\n  action when blocked on memory", "committedDate": "2020-11-26T18:51:47Z", "type": "forcePushed"}, {"oid": "e912cf1ba7d65257b5f25204092bfb9667248a0c", "url": "https://github.com/prestodb/presto/commit/e912cf1ba7d65257b5f25204092bfb9667248a0c", "message": "Remove lock contention bottlenecks from OutputBufferMemoryManager\n\n- Adds a fast-path to getBufferBlockedFuture() that avoids synchronizing\n  when the buffer is in a blocked state.\n- Avoids synchronizing for isOverutilized()\n- Refactors updateMemoryUsage (the hot path) to move some code outside\n  of the critical section and avoid registering more than one listener\n  action when blocked on memory", "committedDate": "2020-11-26T19:34:25Z", "type": "forcePushed"}, {"oid": "3640c76ff29b5c86c4e304019b461a01ea7204aa", "url": "https://github.com/prestodb/presto/commit/3640c76ff29b5c86c4e304019b461a01ea7204aa", "message": "Remove lock contention bottlenecks from OutputBufferMemoryManager\n\n- Adds a fast-path to getBufferBlockedFuture() that avoids synchronizing\n  when the buffer is in a blocked state.\n- Avoids synchronizing for isOverutilized()\n- Refactors updateMemoryUsage (the hot path) to move some code outside\n  of the critical section and avoid registering more than one listener\n  action when blocked on memory", "committedDate": "2020-11-26T20:18:13Z", "type": "forcePushed"}, {"oid": "9c37f55c10b1c0e2591fb85dbe0c44914677f068", "url": "https://github.com/prestodb/presto/commit/9c37f55c10b1c0e2591fb85dbe0c44914677f068", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis, and created the opportunity to share\na single implementation for tracking lifespans and callbacks.", "committedDate": "2020-12-08T15:56:34Z", "type": "forcePushed"}, {"oid": "79d88dc0bd30db09acd6537d1ef4785143e40ad5", "url": "https://github.com/prestodb/presto/commit/79d88dc0bd30db09acd6537d1ef4785143e40ad5", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis, and created the opportunity to share\na single implementation for tracking lifespans and callbacks.", "committedDate": "2020-12-08T16:15:30Z", "type": "forcePushed"}, {"oid": "1e9c7b035fe9c7934b714dce33010a5027fa8a47", "url": "https://github.com/prestodb/presto/commit/1e9c7b035fe9c7934b714dce33010a5027fa8a47", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis, and created the opportunity to share\na single implementation for tracking lifespans and callbacks.", "committedDate": "2020-12-08T16:53:07Z", "type": "forcePushed"}, {"oid": "959a9012be3eff981ee62d4aa68d44fc3bc4e33c", "url": "https://github.com/prestodb/presto/commit/959a9012be3eff981ee62d4aa68d44fc3bc4e33c", "message": "Add unsynchronized fast path in ExchangeClient", "committedDate": "2020-12-09T13:41:07Z", "type": "forcePushed"}, {"oid": "86548af4718235a315a5acc7d86e4f991bcdd3d0", "url": "https://github.com/prestodb/presto/commit/86548af4718235a315a5acc7d86e4f991bcdd3d0", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis, and created the opportunity to share\na single implementation for tracking lifespans and callbacks.", "committedDate": "2020-12-09T13:41:07Z", "type": "forcePushed"}, {"oid": "2f0ff5a59ac91d7958884c2f0484e38312cd2433", "url": "https://github.com/prestodb/presto/commit/2f0ff5a59ac91d7958884c2f0484e38312cd2433", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis, and created the opportunity to share\na single implementation for tracking lifespans and callbacks.", "committedDate": "2020-12-14T17:34:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2MjY2MQ==", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r552962661", "bodyText": "nit: we can use decrementAndGet(releasedPageCount)", "author": "wenleix", "createdAt": "2021-01-06T21:10:07Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/LifespanSerializedPageTracker.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution.buffer;\n+\n+import com.facebook.presto.execution.Lifespan;\n+import com.facebook.presto.execution.buffer.SerializedPageReference.PagesReleasedListener;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+final class LifespanSerializedPageTracker\n+        implements PagesReleasedListener\n+{\n+    private final OutputBufferMemoryManager memoryManager;\n+    @Nullable\n+    private final PagesReleasedListener childListener;\n+    private final ConcurrentMap<Lifespan, AtomicLong> outstandingPageCountPerLifespan = new ConcurrentHashMap<>();\n+    private final Set<Lifespan> noMorePagesForLifespan = ConcurrentHashMap.newKeySet();\n+    private volatile Consumer<Lifespan> lifespanCompletionCallback;\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager)\n+    {\n+        this(memoryManager, Optional.empty());\n+    }\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager, Optional<PagesReleasedListener> childListener)\n+    {\n+        this.memoryManager = requireNonNull(memoryManager, \"memoryManager is null\");\n+        this.childListener = requireNonNull(childListener, \"childListener is null\").orElse(null);\n+    }\n+\n+    public boolean isLifespanCompletionCallbackRegistered()\n+    {\n+        return lifespanCompletionCallback != null;\n+    }\n+\n+    public void registerLifespanCompletionCallback(Consumer<Lifespan> callback)\n+    {\n+        checkState(lifespanCompletionCallback == null, \"lifespanCompletionCallback is already set\");\n+        this.lifespanCompletionCallback = requireNonNull(callback, \"callback is null\");\n+    }\n+\n+    public void incrementLifespanPageCount(Lifespan lifespan, int pagesAdded)\n+    {\n+        AtomicLong counter = outstandingPageCountPerLifespan.get(lifespan);\n+        if (counter == null) {\n+            counter = outstandingPageCountPerLifespan.computeIfAbsent(lifespan, ignore -> new AtomicLong());\n+        }\n+        counter.addAndGet(pagesAdded);\n+    }\n+\n+    public void setNoMorePagesForLifespan(Lifespan lifespan)\n+    {\n+        requireNonNull(lifespan, \"lifespan is null\");\n+        noMorePagesForLifespan.add(lifespan);\n+    }\n+\n+    public boolean isNoMorePagesForLifespan(Lifespan lifespan)\n+    {\n+        return noMorePagesForLifespan.contains(lifespan);\n+    }\n+\n+    public boolean isFinishedForLifespan(Lifespan lifespan)\n+    {\n+        if (!noMorePagesForLifespan.contains(lifespan)) {\n+            return false;\n+        }\n+\n+        AtomicLong outstandingPageCount = outstandingPageCountPerLifespan.get(lifespan);\n+        return outstandingPageCount == null || outstandingPageCount.get() == 0;\n+    }\n+\n+    @Override\n+    public void onPagesReleased(Lifespan lifespan, int releasedPageCount, long releasedSizeInBytes)\n+    {\n+        long outstandingPageCount = outstandingPageCountPerLifespan.get(lifespan).addAndGet(-releasedPageCount);", "originalCommit": "2f0ff5a59ac91d7958884c2f0484e38312cd2433", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk3NTI2OA==", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r552975268", "bodyText": "decrementAndGet() takes no arguments as it implies a value of -1", "author": "pettyjamesm", "createdAt": "2021-01-06T21:42:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2MjY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2MzY2NQ==", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r552963665", "bodyText": "I didn't see this childListener related logic in trinodb/trino#6097 ? And looks like it's only used in BroadcastOutputBuffer as a safety check:\ncheckState(totalBufferedPages.addAndGet(-releasedPageCount) >= 0);", "author": "wenleix", "createdAt": "2021-01-06T21:13:06Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/LifespanSerializedPageTracker.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution.buffer;\n+\n+import com.facebook.presto.execution.Lifespan;\n+import com.facebook.presto.execution.buffer.SerializedPageReference.PagesReleasedListener;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+final class LifespanSerializedPageTracker\n+        implements PagesReleasedListener\n+{\n+    private final OutputBufferMemoryManager memoryManager;\n+    @Nullable\n+    private final PagesReleasedListener childListener;\n+    private final ConcurrentMap<Lifespan, AtomicLong> outstandingPageCountPerLifespan = new ConcurrentHashMap<>();\n+    private final Set<Lifespan> noMorePagesForLifespan = ConcurrentHashMap.newKeySet();\n+    private volatile Consumer<Lifespan> lifespanCompletionCallback;\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager)\n+    {\n+        this(memoryManager, Optional.empty());\n+    }\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager, Optional<PagesReleasedListener> childListener)\n+    {\n+        this.memoryManager = requireNonNull(memoryManager, \"memoryManager is null\");\n+        this.childListener = requireNonNull(childListener, \"childListener is null\").orElse(null);\n+    }\n+\n+    public boolean isLifespanCompletionCallbackRegistered()\n+    {\n+        return lifespanCompletionCallback != null;\n+    }\n+\n+    public void registerLifespanCompletionCallback(Consumer<Lifespan> callback)\n+    {\n+        checkState(lifespanCompletionCallback == null, \"lifespanCompletionCallback is already set\");\n+        this.lifespanCompletionCallback = requireNonNull(callback, \"callback is null\");\n+    }\n+\n+    public void incrementLifespanPageCount(Lifespan lifespan, int pagesAdded)\n+    {\n+        AtomicLong counter = outstandingPageCountPerLifespan.get(lifespan);\n+        if (counter == null) {\n+            counter = outstandingPageCountPerLifespan.computeIfAbsent(lifespan, ignore -> new AtomicLong());\n+        }\n+        counter.addAndGet(pagesAdded);\n+    }\n+\n+    public void setNoMorePagesForLifespan(Lifespan lifespan)\n+    {\n+        requireNonNull(lifespan, \"lifespan is null\");\n+        noMorePagesForLifespan.add(lifespan);\n+    }\n+\n+    public boolean isNoMorePagesForLifespan(Lifespan lifespan)\n+    {\n+        return noMorePagesForLifespan.contains(lifespan);\n+    }\n+\n+    public boolean isFinishedForLifespan(Lifespan lifespan)\n+    {\n+        if (!noMorePagesForLifespan.contains(lifespan)) {\n+            return false;\n+        }\n+\n+        AtomicLong outstandingPageCount = outstandingPageCountPerLifespan.get(lifespan);\n+        return outstandingPageCount == null || outstandingPageCount.get() == 0;\n+    }\n+\n+    @Override\n+    public void onPagesReleased(Lifespan lifespan, int releasedPageCount, long releasedSizeInBytes)\n+    {\n+        long outstandingPageCount = outstandingPageCountPerLifespan.get(lifespan).addAndGet(-releasedPageCount);\n+        if (outstandingPageCount == 0 && noMorePagesForLifespan.contains(lifespan)) {\n+            Consumer<Lifespan> lifespanCompletionCallback = this.lifespanCompletionCallback;\n+            checkState(lifespanCompletionCallback != null, \"lifespanCompletionCallback is not null\");\n+            lifespanCompletionCallback.accept(lifespan);\n+        }\n+        memoryManager.updateMemoryUsage(-releasedSizeInBytes);\n+        if (childListener != null) {", "originalCommit": "2f0ff5a59ac91d7958884c2f0484e38312cd2433", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk3NjAyNQ==", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r552976025", "bodyText": "That's correct. Since trino doesn't perform that sanity check there wasn't a need to add the same sub-listener logic. I'm not sure you'd want to add another atomic counter to the other buffers as they all have a more straightforward way of counting currently buffered pages (eg: bufferedPages.size())", "author": "pettyjamesm", "createdAt": "2021-01-06T21:44:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2MzY2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NDUzMw==", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r552964533", "bodyText": "this check looks quite universal -- wondering why it cannot be used for other buffer as well?", "author": "wenleix", "createdAt": "2021-01-06T21:15:10Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/BroadcastOutputBuffer.java", "diffHunk": "@@ -90,6 +87,9 @@ public BroadcastOutputBuffer(\n                 requireNonNull(maxBufferSize, \"maxBufferSize is null\").toBytes(),\n                 requireNonNull(systemMemoryContextSupplier, \"systemMemoryContextSupplier is null\"),\n                 requireNonNull(notificationExecutor, \"notificationExecutor is null\"));\n+        this.pageTracker = new LifespanSerializedPageTracker(memoryManager, Optional.of((lifespan, releasedPageCount, releasedSizeInBytes) -> {\n+            checkState(totalBufferedPages.addAndGet(-releasedPageCount) >= 0);", "originalCommit": "2f0ff5a59ac91d7958884c2f0484e38312cd2433", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk3ODg4MQ==", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r552978881", "bodyText": "See above comments, but I'm not sure the extra cost of tracking the count makes sense there since the number of buffered pages is more easily reasoned about through other means except for the broadcast buffer.", "author": "pettyjamesm", "createdAt": "2021-01-06T21:52:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NDUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjkyMA==", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r552966920", "bodyText": "isn't computeIfAbsent will return the counter in the map if exist? -- so we don't need this extra get and can directly do\ncounter = outstandingPageCountPerLifespan.computeIfAbsent(lifespan, ignore -> new AtomicLong())", "author": "wenleix", "createdAt": "2021-01-06T21:21:18Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/buffer/LifespanSerializedPageTracker.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution.buffer;\n+\n+import com.facebook.presto.execution.Lifespan;\n+import com.facebook.presto.execution.buffer.SerializedPageReference.PagesReleasedListener;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static java.util.Objects.requireNonNull;\n+\n+final class LifespanSerializedPageTracker\n+        implements PagesReleasedListener\n+{\n+    private final OutputBufferMemoryManager memoryManager;\n+    @Nullable\n+    private final PagesReleasedListener childListener;\n+    private final ConcurrentMap<Lifespan, AtomicLong> outstandingPageCountPerLifespan = new ConcurrentHashMap<>();\n+    private final Set<Lifespan> noMorePagesForLifespan = ConcurrentHashMap.newKeySet();\n+    private volatile Consumer<Lifespan> lifespanCompletionCallback;\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager)\n+    {\n+        this(memoryManager, Optional.empty());\n+    }\n+\n+    public LifespanSerializedPageTracker(OutputBufferMemoryManager memoryManager, Optional<PagesReleasedListener> childListener)\n+    {\n+        this.memoryManager = requireNonNull(memoryManager, \"memoryManager is null\");\n+        this.childListener = requireNonNull(childListener, \"childListener is null\").orElse(null);\n+    }\n+\n+    public boolean isLifespanCompletionCallbackRegistered()\n+    {\n+        return lifespanCompletionCallback != null;\n+    }\n+\n+    public void registerLifespanCompletionCallback(Consumer<Lifespan> callback)\n+    {\n+        checkState(lifespanCompletionCallback == null, \"lifespanCompletionCallback is already set\");\n+        this.lifespanCompletionCallback = requireNonNull(callback, \"callback is null\");\n+    }\n+\n+    public void incrementLifespanPageCount(Lifespan lifespan, int pagesAdded)\n+    {\n+        AtomicLong counter = outstandingPageCountPerLifespan.get(lifespan);", "originalCommit": "2f0ff5a59ac91d7958884c2f0484e38312cd2433", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk3MTA1MA==", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r552971050", "bodyText": "In JDK8 ConcurrentHashMap#computeIfAbsent unconditionally acquires a write lock even when the value is present (and even so, would unconditionally create lambda in any JDK version). Later JDK's address that, but since prestodb still supports JDK8 I chose to go this route.", "author": "pettyjamesm", "createdAt": "2021-01-06T21:31:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjkyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzA5NTMzNg==", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r553095336", "bodyText": "@pettyjamesm : I see; that's good to learn :) . In that case perhaps add a comment explain why not directly using computeIfAbsent pattern?. Also since line 67 is not the common path, shall we just use putIfAbsent on line 67 instead?", "author": "wenleix", "createdAt": "2021-01-07T03:55:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjkyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzM0MzM2NA==", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r553343364", "bodyText": "putIfAbsent unfortunately returns the previous value which makes it more awkward to use in this context than computeIfAbsent. I've added a comment about the common case avoiding a lambda creation but omitted the minutia about ConcurrentHashMap locking behaviors in JDK 8 since people won't care about that once it's no longer supported.", "author": "pettyjamesm", "createdAt": "2021-01-07T13:59:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjkyMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzUwMDk1OQ==", "url": "https://github.com/prestodb/presto/pull/15477#discussion_r553500959", "bodyText": "@pettyjamesm : The major motivation of the comment is so maintainers of the code can refactor the code later by reading the comment, what about some comment like following:\n//  In JDK8 ConcurrentHashMap#computeIfAbsent unconditionally acquires a write lock even when the value is present\n// TODO: Remove this get ConcurrentHashMap#get call once Presto no longer supports JDK-8", "author": "wenleix", "createdAt": "2021-01-07T18:18:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjkyMA=="}], "type": "inlineReview"}, {"oid": "7f72e3189f048b4466ba5736961e8ac9181a3512", "url": "https://github.com/prestodb/presto/commit/7f72e3189f048b4466ba5736961e8ac9181a3512", "message": "Avoid unnecessary synchronization in LazyOutputBuffer\n\nAdds an initial dereference attempt against the delegate output\nbuffer before synchronizing so that the common case of having already\nset the delegate output buffer might avoid unnecessarily synchronizing\non the LazyOutputBuffer itself.", "committedDate": "2021-01-07T13:54:15Z", "type": "commit"}, {"oid": "097d864b713a93a104d05c8bff403876c13a15e0", "url": "https://github.com/prestodb/presto/commit/097d864b713a93a104d05c8bff403876c13a15e0", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis, and created the opportunity to share\na single implementation for tracking lifespans and callbacks.", "committedDate": "2021-01-07T13:54:15Z", "type": "forcePushed"}, {"oid": "2780e7aad2b66583ddbd7257e5817bf47f0812f2", "url": "https://github.com/prestodb/presto/commit/2780e7aad2b66583ddbd7257e5817bf47f0812f2", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis, and created the opportunity to share\na single implementation for tracking lifespans and callbacks.", "committedDate": "2021-01-07T18:18:59Z", "type": "commit"}, {"oid": "2780e7aad2b66583ddbd7257e5817bf47f0812f2", "url": "https://github.com/prestodb/presto/commit/2780e7aad2b66583ddbd7257e5817bf47f0812f2", "message": "Dereference SerializedPageReferences in batches\n\nRefactors SerializedPageReference and usage sites to perform dereferencing\nwork in batches which means only a single call into the synchronized memory\ntracker update logic will occur. Incidentally, this reduces a per page lambda\ncreation since the callback to invoke when the reference count hits 0 is\nnow created on a per output buffer basis, and created the opportunity to share\na single implementation for tracking lifespans and callbacks.", "committedDate": "2021-01-07T18:18:59Z", "type": "forcePushed"}]}