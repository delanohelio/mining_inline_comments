{"pr_number": 15437, "pr_title": "Add cpu and memory stats to NodeTaskMap", "pr_createdAt": "2020-11-13T16:40:38Z", "pr_url": "https://github.com/prestodb/presto/pull/15437", "timeline": [{"oid": "93fc71a82159422114e0d9f32845792ef2df28f3", "url": "https://github.com/prestodb/presto/commit/93fc71a82159422114e0d9f32845792ef2df28f3", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-11-13T16:41:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzEzOTQzNA==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r523139434", "bodyText": "Nit: add the units to the names (e.g., bytes, millis)", "author": "tdcmeehan", "createdAt": "2020-11-13T18:18:48Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -79,19 +103,33 @@ private NodeTasks addNodeTask(InternalNode node)\n     private static class NodeTasks\n     {\n         private final Set<RemoteTask> remoteTasks = Sets.newConcurrentHashSet();\n-        private final AtomicInteger nodeTotalPartitionedSplitCount = new AtomicInteger();\n+        private final AtomicLong nodeTotalPartitionedSplitCount = new AtomicLong();\n+        private final AtomicLong nodeTotalMemoryUsage = new AtomicLong();\n+        private final AtomicLong nodeTotalCpuUsage = new AtomicLong();", "originalCommit": "93fc71a82159422114e0d9f32845792ef2df28f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0MDA1NQ==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r523140055", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private class TaskCumulativeStatsTracker\n          \n          \n            \n                    private class CumulativeTaskStatsTracker", "author": "tdcmeehan", "createdAt": "2020-11-13T18:19:26Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +146,161 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsage);\n+            TaskCumulativeStatsTracker cpuUsageTracker = new TaskCumulativeStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuUsage, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        @ThreadSafe\n+        private class TaskCumulativeStatsTracker", "originalCommit": "93fc71a82159422114e0d9f32845792ef2df28f3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0NjMwOA==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r523146308", "bodyText": "Can you comment what this class is trying to do?  The class name doesn't seem to describe it well.", "author": "tdcmeehan", "createdAt": "2020-11-13T18:29:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0MDA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0NTc3MQ==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r523145771", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    if (delta >= 0 && duration > 0) {\n          \n          \n            \n                                        return delta / duration;\n          \n          \n            \n                                    }\n          \n          \n            \n                                    else {\n          \n          \n            \n                                        throw new IllegalArgumentException(stat + \"delta is negative\");\n          \n          \n            \n                                    }\n          \n          \n            \n                                    checkArgument(delta >= 0 && duration > 0, \"stat + \"delta is negative\");\n          \n          \n            \n                                    return delta / duration;", "author": "tdcmeehan", "createdAt": "2020-11-13T18:28:53Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +146,161 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsage);\n+            TaskCumulativeStatsTracker cpuUsageTracker = new TaskCumulativeStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuUsage, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        @ThreadSafe\n+        private class TaskCumulativeStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final String stat;\n+            private final long windowSizeInMilis;\n+            SortedMap<Long, Long> values = new TreeMap<>();\n+\n+            public TaskCumulativeStatsTracker(String stat, TaskId taskId, AtomicLong totalValue, long windowSizeInMilis)\n+            {\n+                super(stat, taskId, totalValue);\n+                this.stat = requireNonNull(stat, \"stat is null\");\n+                this.windowSizeInMilis = windowSizeInMilis;\n+            }\n+\n+            private long getDeltaPerSecond(long taskAge, long value)\n+            {\n+                if (value > 0) {\n+                    values.put(taskAge, value);\n+                    values = values.tailMap(values.lastKey() - windowSizeInMilis);\n+                    if (values.size() > 1) {\n+                        Long firstReporting = values.firstKey();\n+                        Long lastAge = values.lastKey();\n+                        long delta = (value - values.get(firstReporting)) * 100;\n+                        long duration = lastAge - firstReporting;\n+                        if (delta >= 0 && duration > 0) {\n+                            return delta / duration;\n+                        }\n+                        else {\n+                            throw new IllegalArgumentException(stat + \"delta is negative\");\n+                        }", "originalCommit": "93fc71a82159422114e0d9f32845792ef2df28f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0NzI2Nw==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r523147267", "bodyText": "Please add units to all names.", "author": "tdcmeehan", "createdAt": "2020-11-13T18:31:41Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskStatus.java", "diffHunk": "@@ -243,6 +244,20 @@ public long getPeakNodeTotalMemoryReservationInBytes()\n         return peakNodeTotalMemoryReservationInBytes;\n     }\n \n+    @JsonProperty\n+    @ThriftField(18)\n+    public long getTotalCpuTimeInNanos()\n+    {\n+        return totalCpuTimeInNanos;\n+    }\n+\n+    @JsonProperty\n+    @ThriftField(19)\n+    public long getTaskAge()", "originalCommit": "93fc71a82159422114e0d9f32845792ef2df28f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzE0ODQ3Ng==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r523148476", "bodyText": "Unrelated change?", "author": "tdcmeehan", "createdAt": "2020-11-13T18:33:47Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskStatus.java", "diffHunk": "@@ -57,22 +57,19 @@\n     private final TaskState state;\n     private final URI self;\n     private final Set<Lifespan> completedDriverGroups;\n-\n+    private final List<ExecutionFailureInfo> failures;", "originalCommit": "93fc71a82159422114e0d9f32845792ef2df28f3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bef23cb40992d75e3983939f72d6f7cae5116326", "url": "https://github.com/prestodb/presto/commit/bef23cb40992d75e3983939f72d6f7cae5116326", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-11-18T23:04:36Z", "type": "forcePushed"}, {"oid": "24db1948bf08b3b61e082e9194fb6325cd72f67f", "url": "https://github.com/prestodb/presto/commit/24db1948bf08b3b61e082e9194fb6325cd72f67f", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-11-18T23:27:37Z", "type": "forcePushed"}, {"oid": "b021e6e576e819227996f2f5d47144cac5c63d8f", "url": "https://github.com/prestodb/presto/commit/b021e6e576e819227996f2f5d47144cac5c63d8f", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-11-19T03:24:36Z", "type": "forcePushed"}, {"oid": "17155253987ac3bc9ee7787157c2749f1809ef09", "url": "https://github.com/prestodb/presto/commit/17155253987ac3bc9ee7787157c2749f1809ef09", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-11-20T02:56:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgwODk5Mg==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r532808992", "bodyText": "this is usually used for package private level access.\nCan we make the constructor package private if it is only used for testing.", "author": "ajaygeorge", "createdAt": "2020-11-30T18:27:27Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -35,11 +41,20 @@\n     private static final Logger log = Logger.get(NodeTaskMap.class);\n     private final ConcurrentHashMap<InternalNode, NodeTasks> nodeTasksMap = new ConcurrentHashMap<>();\n     private final FinalizerService finalizerService;\n+    private final long cpuStatsWindowSizeInMillis;\n \n     @Inject\n+    public NodeTaskMap(FinalizerService finalizerService, TaskManagerConfig taskConfig)\n+    {\n+        this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n+        this.cpuStatsWindowSizeInMillis = taskConfig.getStatusRefreshMaxWait().toMillis() * 2;\n+    }\n+\n+    @VisibleForTesting", "originalCommit": "17155253987ac3bc9ee7787157c2749f1809ef09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxMDIxNA==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r532810214", "bodyText": "just say 10_000 without using Duration class?", "author": "ajaygeorge", "createdAt": "2020-11-30T18:29:30Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -35,11 +41,20 @@\n     private static final Logger log = Logger.get(NodeTaskMap.class);\n     private final ConcurrentHashMap<InternalNode, NodeTasks> nodeTasksMap = new ConcurrentHashMap<>();\n     private final FinalizerService finalizerService;\n+    private final long cpuStatsWindowSizeInMillis;\n \n     @Inject\n+    public NodeTaskMap(FinalizerService finalizerService, TaskManagerConfig taskConfig)\n+    {\n+        this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n+        this.cpuStatsWindowSizeInMillis = taskConfig.getStatusRefreshMaxWait().toMillis() * 2;\n+    }\n+\n+    @VisibleForTesting\n     public NodeTaskMap(FinalizerService finalizerService)\n     {\n         this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n+        this.cpuStatsWindowSizeInMillis = Duration.valueOf(\"10s\").toMillis();", "originalCommit": "17155253987ac3bc9ee7787157c2749f1809ef09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxMjk0Mg==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r532812942", "bodyText": "can we use something like nodeTasksMap.computeIfAbsent here instead of the get and null check", "author": "ajaygeorge", "createdAt": "2020-11-30T18:34:00Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -49,12 +64,22 @@ public void addTask(InternalNode node, RemoteTask task)\n \n     public int getPartitionedSplitsOnNode(InternalNode node)\n     {\n-        return createOrGetNodeTasks(node).getPartitionedSplitCount();\n+        return (int) createOrGetNodeTasks(node).getPartitionedSplitCount();\n+    }\n+\n+    public long getMemoryUsageInBytesOnNode(InternalNode node)\n+    {\n+        return createOrGetNodeTasks(node).getTotalMemoryUsageInBytes();\n+    }\n+\n+    public long getCpuTimePerMillisOnNode(InternalNode node)\n+    {\n+        return createOrGetNodeTasks(node).getTotalCpuTimePerMillis();\n     }\n \n-    public PartitionedSplitCountTracker createPartitionedSplitCountTracker(InternalNode node, TaskId taskId)\n+    public NodeStatsTracker createTaskStatsTrackers(InternalNode node, TaskId taskId)\n     {\n-        return createOrGetNodeTasks(node).createPartitionedSplitCountTracker(taskId);\n+        return createOrGetNodeTasks(node).createTaskStatsTrackers(taskId);\n     }\n \n     private NodeTasks createOrGetNodeTasks(InternalNode node)", "originalCommit": "17155253987ac3bc9ee7787157c2749f1809ef09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxMzc4Ng==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r532813786", "bodyText": "createTaskStatsTrackers drop the trailing s maybe since we are returning a singular NodeStatsTracker .?", "author": "ajaygeorge", "createdAt": "2020-11-30T18:35:29Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +147,158 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)", "originalCommit": "17155253987ac3bc9ee7787157c2749f1809ef09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxNDQ1Mg==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r532814452", "bodyText": "keep split count as AtomicInt maybe to prevent the unsafe cast to int ?", "author": "ajaygeorge", "createdAt": "2020-11-30T18:36:40Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -49,12 +64,22 @@ public void addTask(InternalNode node, RemoteTask task)\n \n     public int getPartitionedSplitsOnNode(InternalNode node)\n     {\n-        return createOrGetNodeTasks(node).getPartitionedSplitCount();\n+        return (int) createOrGetNodeTasks(node).getPartitionedSplitCount();", "originalCommit": "17155253987ac3bc9ee7787157c2749f1809ef09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAxMTk4MA==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r538011980", "bodyText": "TaskStatsTracker is using AtomicLong. This would require another class definition.", "author": "cemcayiroglu", "createdAt": "2020-12-08T03:46:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxNDQ1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxOTU0Nw==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r532819547", "bodyText": "Can you help me understand the logic here .\nIf we are throwing an IllegalArg exception wondering why we need to set a negative value and then throw, shouldn't we just throw immediately.?", "author": "ajaygeorge", "createdAt": "2020-11-30T18:45:34Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +147,158 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");", "originalCommit": "17155253987ac3bc9ee7787157c2749f1809ef09", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODAxMjU3Mw==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r538012573", "bodyText": "The value is invalid. We need to fix the accumulated (per node) value for this task first and throw an exception.", "author": "cemcayiroglu", "createdAt": "2020-12-08T03:47:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgxOTU0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgyMTUzNQ==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r532821535", "bodyText": "\u2764\ufe0f", "author": "ajaygeorge", "createdAt": "2020-11-30T18:48:55Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskStatus.java", "diffHunk": "@@ -243,6 +246,20 @@ public long getPeakNodeTotalMemoryReservationInBytes()\n         return peakNodeTotalMemoryReservationInBytes;\n     }\n \n+    @JsonProperty\n+    @ThriftField(18)", "originalCommit": "17155253987ac3bc9ee7787157c2749f1809ef09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f1ca39a3605e6e899e04b68f58dc86439262c8d8", "url": "https://github.com/prestodb/presto/commit/f1ca39a3605e6e899e04b68f58dc86439262c8d8", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-12-08T04:01:11Z", "type": "forcePushed"}, {"oid": "170c5152efae77d381ae18b49c3bea05b7dc8ca5", "url": "https://github.com/prestodb/presto/commit/170c5152efae77d381ae18b49c3bea05b7dc8ca5", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-12-08T17:00:36Z", "type": "forcePushed"}, {"oid": "63b7ec3e62ec245fe087ce21a96b87c43ff62d3e", "url": "https://github.com/prestodb/presto/commit/63b7ec3e62ec245fe087ce21a96b87c43ff62d3e", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-12-08T17:33:39Z", "type": "forcePushed"}, {"oid": "565077a85b396072c1b4c6c8e5352f9966dacc1c", "url": "https://github.com/prestodb/presto/commit/565077a85b396072c1b4c6c8e5352f9966dacc1c", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-12-08T17:55:19Z", "type": "forcePushed"}, {"oid": "dca91925979431dbc9018cb6bf59e9a8a2dfa596", "url": "https://github.com/prestodb/presto/commit/dca91925979431dbc9018cb6bf59e9a8a2dfa596", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-12-08T18:33:30Z", "type": "forcePushed"}, {"oid": "76509cd84b16ebd31187fd15f698fa2336a558a0", "url": "https://github.com/prestodb/presto/commit/76509cd84b16ebd31187fd15f698fa2336a558a0", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-12-08T20:06:17Z", "type": "forcePushed"}, {"oid": "3fb5d68a7336fce4f6a015438c88db87a4ca7b48", "url": "https://github.com/prestodb/presto/commit/3fb5d68a7336fce4f6a015438c88db87a4ca7b48", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-12-09T04:25:31Z", "type": "forcePushed"}, {"oid": "49f150c05b4b1556b91db2558144269e132be4f6", "url": "https://github.com/prestodb/presto/commit/49f150c05b4b1556b91db2558144269e132be4f6", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-12-09T04:34:06Z", "type": "forcePushed"}, {"oid": "0012fe5ea51715e2b73c7fe9a1dab885ca11dfe3", "url": "https://github.com/prestodb/presto/commit/0012fe5ea51715e2b73c7fe9a1dab885ca11dfe3", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-12-09T05:10:13Z", "type": "forcePushed"}, {"oid": "a88d6c0f0f6b2077ebbf96e2a4811065cf19d8be", "url": "https://github.com/prestodb/presto/commit/a88d6c0f0f6b2077ebbf96e2a4811065cf19d8be", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-12-09T05:18:39Z", "type": "forcePushed"}, {"oid": "8034d96bd408b5a41e3ebba04d8fd01a21231809", "url": "https://github.com/prestodb/presto/commit/8034d96bd408b5a41e3ebba04d8fd01a21231809", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-12-09T05:20:01Z", "type": "forcePushed"}, {"oid": "c3e44415dbadbdc3cab7c1d32c769ecc142b0bd5", "url": "https://github.com/prestodb/presto/commit/c3e44415dbadbdc3cab7c1d32c769ecc142b0bd5", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-12-09T05:29:47Z", "type": "forcePushed"}, {"oid": "ebf2876f8d14c44774ab28794ca8c86806e6ae14", "url": "https://github.com/prestodb/presto/commit/ebf2876f8d14c44774ab28794ca8c86806e6ae14", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-12-09T05:59:45Z", "type": "forcePushed"}, {"oid": "5082119be836994b70731b0daf7a2d569ebac93e", "url": "https://github.com/prestodb/presto/commit/5082119be836994b70731b0daf7a2d569ebac93e", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-12-10T20:18:23Z", "type": "forcePushed"}, {"oid": "3877274fb7fbfe15400bc81b6c6d75da43aee859", "url": "https://github.com/prestodb/presto/commit/3877274fb7fbfe15400bc81b6c6d75da43aee859", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-12-10T20:49:04Z", "type": "forcePushed"}, {"oid": "455444da15878190d647bc065374cec705d738ec", "url": "https://github.com/prestodb/presto/commit/455444da15878190d647bc065374cec705d738ec", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-12-11T17:44:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY1MjY1OA==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542652658", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public NodeTaskMap(FinalizerService finalizerService, TaskManagerConfig taskConfig)\n          \n          \n            \n                {\n          \n          \n            \n                    this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n          \n          \n            \n                    this.cpuStatsWindowSizeInMillis = taskConfig.getStatusRefreshMaxWait().toMillis() * 2;\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public NodeTaskMap(FinalizerService finalizerService)\n          \n          \n            \n                {\n          \n          \n            \n                    this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n          \n          \n            \n                    this.cpuStatsWindowSizeInMillis = 10_000_000;\n          \n          \n            \n                }\n          \n          \n            \n                @Inject\n          \n          \n            \n                public NodeTaskMap(FinalizerService finalizerService, TaskManagerConfig taskConfig)\n          \n          \n            \n                {\n          \n          \n            \n                    this(\n          \n          \n            \n                            finalizerService,\n          \n          \n            \n                            requireNonNull(taskConfig, \"taskConfig is null\").getStatusRefreshMaxWait());\n          \n          \n            \n                }\n          \n          \n            \n            \n          \n          \n            \n                public NodeTaskMap(FinalizerService finalizerService, Duration statusRefreshMaxWait)\n          \n          \n            \n                {\n          \n          \n            \n                    this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n          \n          \n            \n                    this.cpuStatsWindowSizeInMillis = requireNonNull(statusRefreshMaxWait, \"statusRefreshMaxWait is null\").toMillis();\n          \n          \n            \n                }", "author": "tdcmeehan", "createdAt": "2020-12-14T19:01:52Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -35,11 +38,19 @@\n     private static final Logger log = Logger.get(NodeTaskMap.class);\n     private final ConcurrentHashMap<InternalNode, NodeTasks> nodeTasksMap = new ConcurrentHashMap<>();\n     private final FinalizerService finalizerService;\n+    private final long cpuStatsWindowSizeInMillis;\n \n     @Inject\n+    public NodeTaskMap(FinalizerService finalizerService, TaskManagerConfig taskConfig)\n+    {\n+        this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n+        this.cpuStatsWindowSizeInMillis = taskConfig.getStatusRefreshMaxWait().toMillis() * 2;\n+    }\n+\n     public NodeTaskMap(FinalizerService finalizerService)\n     {\n         this.finalizerService = requireNonNull(finalizerService, \"finalizerService is null\");\n+        this.cpuStatsWindowSizeInMillis = 10_000_000;\n     }", "originalCommit": "455444da15878190d647bc065374cec705d738ec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY1OTMzMg==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542659332", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public long getMemoryUsageInBytesOnNode(InternalNode node)\n          \n          \n            \n                public long getNodeTotalMemoryUsageInBytes(InternalNode node)", "author": "tdcmeehan", "createdAt": "2020-12-14T19:08:01Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -52,44 +63,54 @@ public int getPartitionedSplitsOnNode(InternalNode node)\n         return createOrGetNodeTasks(node).getPartitionedSplitCount();\n     }\n \n-    public PartitionedSplitCountTracker createPartitionedSplitCountTracker(InternalNode node, TaskId taskId)\n+    public long getMemoryUsageInBytesOnNode(InternalNode node)", "originalCommit": "455444da15878190d647bc065374cec705d738ec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MjY2MDI5MA==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542660290", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public long getCpuTimePerMillisOnNode(InternalNode node)\n          \n          \n            \n                public long getNodeCpuTimePerMillis(InternalNode node)", "author": "tdcmeehan", "createdAt": "2020-12-14T19:08:55Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -52,44 +63,54 @@ public int getPartitionedSplitsOnNode(InternalNode node)\n         return createOrGetNodeTasks(node).getPartitionedSplitCount();\n     }\n \n-    public PartitionedSplitCountTracker createPartitionedSplitCountTracker(InternalNode node, TaskId taskId)\n+    public long getMemoryUsageInBytesOnNode(InternalNode node)\n     {\n-        return createOrGetNodeTasks(node).createPartitionedSplitCountTracker(taskId);\n+        return createOrGetNodeTasks(node).getTotalMemoryUsageInBytes();\n     }\n \n-    private NodeTasks createOrGetNodeTasks(InternalNode node)\n+    public long getCpuTimePerMillisOnNode(InternalNode node)", "originalCommit": "455444da15878190d647bc065374cec705d738ec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc2ODA2OA==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542768068", "bodyText": "Missing visibility?", "author": "tdcmeehan", "createdAt": "2020-12-14T20:49:19Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +129,155 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final String stat;\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();", "originalCommit": "455444da15878190d647bc065374cec705d738ec", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc4MzE0NA==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542783144", "bodyText": "Where do we clear this map?  Or is it expected that it continuously grows during the lifetime of the task?", "author": "tdcmeehan", "createdAt": "2020-12-14T21:03:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc2ODA2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc4ODQ4Mw==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542788483", "bodyText": "I wonder if the keys will come into this class in time-order (and hence already sorted).  In which case we could use a LinkedHashMap instead.", "author": "tdcmeehan", "createdAt": "2020-12-14T21:08:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc2ODA2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjk3MDgwOQ==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542970809", "bodyText": "I added the following to avoid memory leak. There is a chance that It can be out of order since updateTaskStats in HttpRemoteTask being called from several places.\nvalues.headMap(values.lastKey() - windowSizeInMillis).clear();", "author": "cemcayiroglu", "createdAt": "2020-12-15T01:17:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc2ODA2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5MjYzNw==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r543592637", "bodyText": "It's still missing the visibility modifier.", "author": "tdcmeehan", "createdAt": "2020-12-15T18:41:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc2ODA2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYwMzcwNQ==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r543603705", "bodyText": "Also, do you want to use a fastutil Long2LongSortedMap to avoid boxing?", "author": "tdcmeehan", "createdAt": "2020-12-15T18:56:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc2ODA2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc4NTYwNw==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542785607", "bodyText": "The tail map is just a view over the original.  I think this is a memory leak.", "author": "tdcmeehan", "createdAt": "2020-12-14T21:05:45Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +129,155 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final String stat;\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();\n+\n+            public AccumulatedTaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue, long windowSizeInMillis)\n+            {\n+                super(stat, taskId, totalValue);\n+                this.stat = requireNonNull(stat, \"stat is null\");\n+                this.windowSizeInMillis = windowSizeInMillis;\n+            }\n+\n+            private long getDeltaPerSecond(long taskAgeInMillis, long value)\n+            {\n+                if (value > 0) {\n+                    values.put(taskAgeInMillis, value);\n+                    values = values.tailMap(values.lastKey() - windowSizeInMillis);", "originalCommit": "455444da15878190d647bc065374cec705d738ec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc4OTAxMA==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542789010", "bodyText": "Please static import", "author": "tdcmeehan", "createdAt": "2020-12-14T21:08:50Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/RemoteTaskFactory.java", "diffHunk": "@@ -31,7 +30,7 @@ RemoteTask createRemoteTask(Session session,\n             PlanFragment fragment,\n             Multimap<PlanNodeId, Split> initialSplits,\n             OutputBuffers outputBuffers,\n-            PartitionedSplitCountTracker partitionedSplitCountTracker,\n+            NodeTaskMap.NodeStatsTracker nodeStatsTracker,", "originalCommit": "455444da15878190d647bc065374cec705d738ec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc5MDQ4Nw==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542790487", "bodyText": "MILLISECONDS.toNanos", "author": "tdcmeehan", "createdAt": "2020-12-14T21:10:14Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/SqlTask.java", "diffHunk": "@@ -237,6 +240,7 @@ public TaskStatus getTaskStatus()\n \n     private TaskStatus createTaskStatus(TaskHolder taskHolder)\n     {\n+        long taskStatusAgeInMilis = MILLISECONDS.convert(System.nanoTime() - creationTime, NANOSECONDS);", "originalCommit": "455444da15878190d647bc065374cec705d738ec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc5MTM2NQ==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542791365", "bodyText": "Unrelated whitespace change?", "author": "tdcmeehan", "createdAt": "2020-12-14T21:11:02Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskStatus.java", "diffHunk": "@@ -57,23 +57,22 @@\n     private final TaskState state;\n     private final URI self;\n     private final Set<Lifespan> completedDriverGroups;\n-\n     private final int queuedPartitionedDrivers;\n     private final int runningPartitionedDrivers;\n-\n     private final double outputBufferUtilization;\n     private final boolean outputBufferOverutilized;\n-\n     private final long physicalWrittenDataSizeInBytes;\n     private final long memoryReservationInBytes;\n     private final long systemMemoryReservationInBytes;\n     private final long peakNodeTotalMemoryReservationInBytes;\n-\n     private final long fullGcCount;", "originalCommit": "455444da15878190d647bc065374cec705d738ec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mjc5MzQ4Ng==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r542793486", "bodyText": "Nit: testCpuUsage", "author": "tdcmeehan", "createdAt": "2020-12-14T21:12:59Z", "path": "presto-main/src/test/java/com/facebook/presto/execution/TestNodeScheduler.java", "diffHunk": "@@ -518,6 +518,86 @@ public void testSplitCount()\n         assertEquals(nodeTaskMap.getPartitionedSplitsOnNode(chosenNode), 0);\n     }\n \n+    @Test\n+    public void testCPUUsage()", "originalCommit": "455444da15878190d647bc065374cec705d738ec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e6b70e5e90048961cdf7ca065a113bd2e10b0d1f", "url": "https://github.com/prestodb/presto/commit/e6b70e5e90048961cdf7ca065a113bd2e10b0d1f", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-12-15T01:13:17Z", "type": "forcePushed"}, {"oid": "14ceffa597230e234430ef1a9c05fbb1d186d7b0", "url": "https://github.com/prestodb/presto/commit/14ceffa597230e234430ef1a9c05fbb1d186d7b0", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-12-15T01:18:34Z", "type": "forcePushed"}, {"oid": "6501c8563a16196e18ec48ac3da3d4c8ffa8a739", "url": "https://github.com/prestodb/presto/commit/6501c8563a16196e18ec48ac3da3d4c8ffa8a739", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-12-15T01:19:30Z", "type": "forcePushed"}, {"oid": "c718bff7b23b42f3eacb3acd75107e9cf01e80b4", "url": "https://github.com/prestodb/presto/commit/c718bff7b23b42f3eacb3acd75107e9cf01e80b4", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-12-15T01:20:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5NDA3MA==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r543594070", "bodyText": "Why multiply by 100?", "author": "tdcmeehan", "createdAt": "2020-12-15T18:42:57Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +130,154 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();\n+\n+            public AccumulatedTaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue, long windowSizeInMillis)\n+            {\n+                super(stat, taskId, totalValue);\n+                this.windowSizeInMillis = windowSizeInMillis;\n+            }\n+\n+            private long getDeltaPerSecond(long taskAgeInMillis, long value)\n+            {\n+                if (value > 0) {\n+                    values.put(taskAgeInMillis, value);\n+                    // this clears the map and make items eligible for GC\n+                    values.headMap(values.lastKey() - windowSizeInMillis).clear();\n+                    if (values.size() > 1) {\n+                        long deltaValue = (values.get(values.lastKey()) - values.get(values.firstKey())) * 100;", "originalCommit": "c718bff7b23b42f3eacb3acd75107e9cf01e80b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYwNzE3Ng==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r543607176", "bodyText": "This was there from the initial implementation. It was helping to calculate a percentage. I will remove.", "author": "cemcayiroglu", "createdAt": "2020-12-15T19:01:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5NDA3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYxODU4OQ==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r543618589", "bodyText": "Actually, using percentage as utilization unit is a common practice. I will keep 100 and change the of the method to get CPU utilization.", "author": "cemcayiroglu", "createdAt": "2020-12-15T19:16:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5NDA3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY4MzIwNQ==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r543683205", "bodyText": "There's methods which don't require boxing: e.g. lastLongKey, firstLongKey", "author": "tdcmeehan", "createdAt": "2020-12-15T21:01:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5NDA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTIwOQ==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r543599209", "bodyText": "Can you help me understand why this would return 0 here?", "author": "tdcmeehan", "createdAt": "2020-12-15T18:50:11Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/NodeTaskMap.java", "diffHunk": "@@ -108,87 +130,154 @@ private void addTask(RemoteTask task)\n             }\n         }\n \n-        public PartitionedSplitCountTracker createPartitionedSplitCountTracker(TaskId taskId)\n+        public NodeStatsTracker createTaskStatsTrackers(TaskId taskId)\n         {\n             requireNonNull(taskId, \"taskId is null\");\n \n-            TaskPartitionedSplitCountTracker tracker = new TaskPartitionedSplitCountTracker(taskId);\n-            PartitionedSplitCountTracker partitionedSplitCountTracker = new PartitionedSplitCountTracker(tracker::setPartitionedSplitCount);\n+            TaskStatsTracker splitTracker = new TaskStatsTracker(\"SplitTracker\", taskId, nodeTotalPartitionedSplitCount);\n+            TaskStatsTracker memoryUsageTracker = new TaskStatsTracker(\"MemoryTracker\", taskId, nodeTotalMemoryUsageInBytes);\n+            AccumulatedTaskStatsTracker cpuUsageTracker = new AccumulatedTaskStatsTracker(\"CpuTracker\", taskId, nodeTotalCpuTimePerMillis, windowSizeInMilis);\n+            NodeStatsTracker nodeStatsTracker = new NodeStatsTracker(splitTracker::setValue, memoryUsageTracker::setValue, cpuUsageTracker::setValue);\n \n-            // when partitionedSplitCountTracker is garbage collected, run the cleanup method on the tracker\n-            // Note: tracker can not have a reference to partitionedSplitCountTracker\n-            finalizerService.addFinalizer(partitionedSplitCountTracker, tracker::cleanup);\n+            // when nodeStatsTracker is garbage collected, run the cleanup method on the tracker\n+            // Note: tracker can not have a reference to nodeStatsTracker\n+            finalizerService.addFinalizer(nodeStatsTracker, splitTracker::cleanup);\n+            finalizerService.addFinalizer(memoryUsageTracker, memoryUsageTracker::cleanup);\n+            finalizerService.addFinalizer(cpuUsageTracker, cpuUsageTracker::cleanup);\n \n-            return partitionedSplitCountTracker;\n+            return nodeStatsTracker;\n         }\n \n         @ThreadSafe\n-        private class TaskPartitionedSplitCountTracker\n+        private class TaskStatsTracker\n         {\n+            private final String stat;\n             private final TaskId taskId;\n-            private final AtomicInteger localPartitionedSplitCount = new AtomicInteger();\n+            private final AtomicLong totalValue;\n+            private final AtomicLong value = new AtomicLong();\n \n-            public TaskPartitionedSplitCountTracker(TaskId taskId)\n+            public TaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue)\n             {\n+                this.stat = requireNonNull(stat, \"stat is null\");\n                 this.taskId = requireNonNull(taskId, \"taskId is null\");\n+                this.totalValue = requireNonNull(totalValue, \"totalValue is null\");\n             }\n \n-            public synchronized void setPartitionedSplitCount(int partitionedSplitCount)\n+            public synchronized void setValue(long value)\n             {\n-                if (partitionedSplitCount < 0) {\n-                    int oldValue = localPartitionedSplitCount.getAndSet(0);\n-                    nodeTotalPartitionedSplitCount.addAndGet(-oldValue);\n-                    throw new IllegalArgumentException(\"partitionedSplitCount is negative\");\n+                if (value < 0) {\n+                    long oldValue = this.value.getAndSet(0L);\n+                    totalValue.addAndGet(-oldValue);\n+                    throw new IllegalArgumentException(stat + \" is negative\");\n                 }\n \n-                int oldValue = localPartitionedSplitCount.getAndSet(partitionedSplitCount);\n-                nodeTotalPartitionedSplitCount.addAndGet(partitionedSplitCount - oldValue);\n+                long oldValue = this.value.getAndSet(value);\n+                totalValue.addAndGet(value - oldValue);\n             }\n \n             public void cleanup()\n             {\n-                int leakedSplits = localPartitionedSplitCount.getAndSet(0);\n-                if (leakedSplits == 0) {\n+                long leakedValues = value.getAndSet(0);\n+                if (leakedValues == 0) {\n                     return;\n                 }\n \n-                log.error(\"BUG! %s for %s leaked with %s partitioned splits.  Cleaning up so server can continue to function.\",\n+                log.error(\"BUG! %s for %s leaked with %s %s.  Cleaning up so server can continue to function.\",\n                         getClass().getName(),\n                         taskId,\n-                        leakedSplits);\n+                        leakedValues,\n+                        stat);\n \n-                nodeTotalPartitionedSplitCount.addAndGet(-leakedSplits);\n+                totalValue.addAndGet(-leakedValues);\n             }\n \n             @Override\n             public String toString()\n             {\n                 return toStringHelper(this)\n                         .add(\"taskId\", taskId)\n-                        .add(\"splits\", localPartitionedSplitCount)\n+                        .add(stat, value)\n                         .toString();\n             }\n         }\n+\n+        // tracks stats which are passed as accumulated (cpu time) by calculating delta / duration.\n+        @ThreadSafe\n+        private class AccumulatedTaskStatsTracker\n+                extends TaskStatsTracker\n+        {\n+            private final long windowSizeInMillis;\n+            SortedMap<Long, Long> values = new TreeMap<>();\n+\n+            public AccumulatedTaskStatsTracker(String stat, TaskId taskId, AtomicLong totalValue, long windowSizeInMillis)\n+            {\n+                super(stat, taskId, totalValue);\n+                this.windowSizeInMillis = windowSizeInMillis;\n+            }\n+\n+            private long getDeltaPerSecond(long taskAgeInMillis, long value)\n+            {\n+                if (value > 0) {\n+                    values.put(taskAgeInMillis, value);\n+                    // this clears the map and make items eligible for GC\n+                    values.headMap(values.lastKey() - windowSizeInMillis).clear();\n+                    if (values.size() > 1) {\n+                        long deltaValue = (values.get(values.lastKey()) - values.get(values.firstKey())) * 100;\n+                        long deltaDuration = values.lastKey() - values.firstKey();\n+                        return deltaDuration >= 0 && deltaValue > 0 ? deltaValue / deltaDuration : 0;\n+                    }\n+                }\n+                return 0;", "originalCommit": "c718bff7b23b42f3eacb3acd75107e9cf01e80b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYwNzcyMw==", "url": "https://github.com/prestodb/presto/pull/15437#discussion_r543607723", "bodyText": "We are return 0 if the reporting is not valid or we dont have enough data points.", "author": "cemcayiroglu", "createdAt": "2020-12-15T19:02:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU5OTIwOQ=="}], "type": "inlineReview"}, {"oid": "91a933be1fe5250bcd1db335f7331bc5049f7206", "url": "https://github.com/prestodb/presto/commit/91a933be1fe5250bcd1db335f7331bc5049f7206", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-12-15T19:26:45Z", "type": "forcePushed"}, {"oid": "5e3cb6639a02e4400bff0a2fe88409669e29679a", "url": "https://github.com/prestodb/presto/commit/5e3cb6639a02e4400bff0a2fe88409669e29679a", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2020-12-15T21:09:42Z", "type": "forcePushed"}, {"oid": "61d16946b5a7e636974ee56afbab387ae5010048", "url": "https://github.com/prestodb/presto/commit/61d16946b5a7e636974ee56afbab387ae5010048", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2021-01-04T20:26:58Z", "type": "commit"}, {"oid": "61d16946b5a7e636974ee56afbab387ae5010048", "url": "https://github.com/prestodb/presto/commit/61d16946b5a7e636974ee56afbab387ae5010048", "message": "Add cpu and memory stats to NodeTaskMap", "committedDate": "2021-01-04T20:26:58Z", "type": "forcePushed"}]}