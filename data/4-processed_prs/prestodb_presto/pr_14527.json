{"pr_number": 14527, "pr_title": "Aggregation ORDER BY & DISTINCT spilling", "pr_createdAt": "2020-05-14T05:52:23Z", "pr_url": "https://github.com/prestodb/presto/pull/14527", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4NTk5Ng==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r424885996", "bodyText": "main part to review 2).", "author": "sachdevs", "createdAt": "2020-05-14T05:53:25Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -557,13 +563,14 @@ public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n         @Override\n         public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n         {\n-            throw new UnsupportedOperationException();\n+            accumulator.addIntermediate(groupIdsBlock, block);\n         }\n \n         @Override\n         public void evaluateIntermediate(int groupId, BlockBuilder output)\n         {\n-            throw new UnsupportedOperationException();\n+            prepareFinal();", "originalCommit": "eb2fdeb9adb4d59260e7f23598d2ee993cb84704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4NjA1Nw==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r424886057", "bodyText": "main part to review 1).", "author": "sachdevs", "createdAt": "2020-05-14T05:53:38Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -477,22 +477,28 @@ public void addInput(WindowIndex index, List<Integer> channels, int startPositio\n         @Override\n         public void addIntermediate(Block block)\n         {\n-            throw new UnsupportedOperationException();\n+            accumulator.addIntermediate(block);\n         }\n \n         @Override\n         public void evaluateIntermediate(BlockBuilder blockBuilder)\n         {\n-            throw new UnsupportedOperationException();\n+            sortAndAccumulatePages();", "originalCommit": "eb2fdeb9adb4d59260e7f23598d2ee993cb84704", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a69f43e074331b83252a3f183cbd442f05d49dc8", "url": "https://github.com/prestodb/presto/commit/a69f43e074331b83252a3f183cbd442f05d49dc8", "message": "testing implementation", "committedDate": "2020-05-15T20:55:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA0NDA1Nw==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r426044057", "bodyText": "ignore these changes, they are not relevant  to the grouped accumulator which is what I've been focusing on.", "author": "sachdevs", "createdAt": "2020-05-15T20:58:41Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -477,22 +486,27 @@ public void addInput(WindowIndex index, List<Integer> channels, int startPositio\n         @Override\n         public void addIntermediate(Block block)\n         {\n-            throw new UnsupportedOperationException();\n+            accumulator.addIntermediate(block);\n         }\n \n         @Override\n         public void evaluateIntermediate(BlockBuilder blockBuilder)\n         {\n-            throw new UnsupportedOperationException();\n+            accumulator.evaluateIntermediate(blockBuilder);", "originalCommit": "a69f43e074331b83252a3f183cbd442f05d49dc8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIzMzU4NA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r426233584", "bodyText": "Essentially, this is our own way to main the GroupedAccumulatorState. Highly recommend to take a look at how some implementations of GroupedAccumulatorState are used. Especially, how to use ObjectBigArray as the hash table.", "author": "highker", "createdAt": "2020-05-17T08:33:09Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -503,6 +517,7 @@ public void evaluateFinal(BlockBuilder blockBuilder)\n         private final List<Integer> orderByChannels;\n         private final List<SortOrder> orderings;\n         private final PagesIndex pagesIndex;\n+        private final Map<Long, RowBlockBuilder> pageMap = new HashMap<>();", "originalCommit": "a69f43e074331b83252a3f183cbd442f05d49dc8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMTg4MQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r426311881", "bodyText": "Got it taking a look.", "author": "sachdevs", "createdAt": "2020-05-17T22:27:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIzMzU4NA=="}], "type": "inlineReview"}, {"oid": "3912702acafbc0685c069ff0d3246b78abab2e6b", "url": "https://github.com/prestodb/presto/commit/3912702acafbc0685c069ff0d3246b78abab2e6b", "message": "testing implementation", "committedDate": "2020-05-19T02:48:03Z", "type": "forcePushed"}, {"oid": "9909c3dc45f1b1ada1f83da01564d01b1f7d991c", "url": "https://github.com/prestodb/presto/commit/9909c3dc45f1b1ada1f83da01564d01b1f7d991c", "message": "testing implementation", "committedDate": "2020-05-19T03:04:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwNDI5NA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r427004294", "bodyText": "So this bit is causing some issues since we cant append multiple rows to a single groupId. That's why the code wasn't working earlier, I was only putting one block per group id so we were missing a bunch of rows in the final step.\nNow, when I add multiple blocks for a single row, the page becomes malformed since there is an inconsistent position count between its blocks. I.e. this column has multiple rows for a single input group Id.\nBeen thinking of some alternatives today and maybe we should just serialize this and then write it as bytes but that definitely would have overhead. What do you think @highker ?", "author": "sachdevs", "createdAt": "2020-05-19T03:09:01Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -563,7 +608,10 @@ public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n         @Override\n         public void evaluateIntermediate(int groupId, BlockBuilder output)\n         {\n-            throw new UnsupportedOperationException();\n+            RowBlock rowBlock = (RowBlock) pageMap.get((long) groupId).build();\n+            for (int i = 0; i < rowBlock.getPositionCount(); i++) {\n+                output.appendStructureInternal(rowBlock, i);\n+            }", "originalCommit": "9909c3dc45f1b1ada1f83da01564d01b1f7d991c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyNDYwMw==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r427024603", "bodyText": "I think one good place to understand how this code should behave is by reading AccumulatorCompiler. generateGroupedEvaluateIntermediate is the method to generate evaluateIntermediate. Looks like only one row is allowed per groupId and it needs to be serialized. So for that, you could squeeze all the rowBlocks into an array or something to make a single cell.", "author": "highker", "createdAt": "2020-05-19T04:35:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwNDI5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA2NTk0Nw==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r427065947", "bodyText": "Yeah, array is a good idea, let me try that. Since this BlockBuilder is of the type returned by getIntermediateType, I'm going to set this to ArrayType and see if that works.", "author": "sachdevs", "createdAt": "2020-05-19T06:45:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwNDI5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzEwNTQxMA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r427105410", "bodyText": "Okay almost have it - what's left is I need to figure out how to attach the group id block offsets correctly to the serialized array and it should work.", "author": "sachdevs", "createdAt": "2020-05-19T08:02:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwNDI5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzU2OTY2OA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r427569668", "bodyText": "Added a bit on unspill to rebuild the groupidsblock according to the nested rowblock array items", "author": "sachdevs", "createdAt": "2020-05-19T20:09:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAwNDI5NA=="}], "type": "inlineReview"}, {"oid": "6639b9188c15a7de00e72cc4d08cfe50dd52d4d3", "url": "https://github.com/prestodb/presto/commit/6639b9188c15a7de00e72cc4d08cfe50dd52d4d3", "message": "testing implementation", "committedDate": "2020-05-19T20:06:01Z", "type": "forcePushed"}, {"oid": "2073f624298619e83cdf793c13540e83a258e3a0", "url": "https://github.com/prestodb/presto/commit/2073f624298619e83cdf793c13540e83a258e3a0", "message": "semi working distinct spilling", "committedDate": "2020-05-29T22:04:03Z", "type": "forcePushed"}, {"oid": "2e869d8613f28033089596da191d96964a5f95d0", "url": "https://github.com/prestodb/presto/commit/2e869d8613f28033089596da191d96964a5f95d0", "message": "Distinct spilling", "committedDate": "2020-06-01T17:35:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzM4NTA4MQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r433385081", "bodyText": "We need a better way to tell if unspill is happening, if the distinct aggregation isnt the last variable in the select block this will just fail.", "author": "sachdevs", "createdAt": "2020-06-01T17:38:20Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -368,12 +401,44 @@ public Type getFinalType()\n         @Override\n         public Type getIntermediateType()\n         {\n-            throw new UnsupportedOperationException();\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n         }\n \n         @Override\n         public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n         {\n+            if (page.getBlock(page.getChannelCount() - 1) instanceof ArrayBlock) {", "originalCommit": "2e869d8613f28033089596da191d96964a5f95d0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ac1d598c60f7099a21b381dea316c7d01d8ae1af", "url": "https://github.com/prestodb/presto/commit/ac1d598c60f7099a21b381dea316c7d01d8ae1af", "message": "Distinct spilling", "committedDate": "2020-06-01T18:47:25Z", "type": "forcePushed"}, {"oid": "c1dd45d3f2432929e3065934be639bfb6a33fd3d", "url": "https://github.com/prestodb/presto/commit/c1dd45d3f2432929e3065934be639bfb6a33fd3d", "message": "Refactored Distinct - testing", "committedDate": "2020-06-04T19:09:35Z", "type": "forcePushed"}, {"oid": "3e6d3defe5dcdfb71ddeb9b054f95f34e576dd3b", "url": "https://github.com/prestodb/presto/commit/3e6d3defe5dcdfb71ddeb9b054f95f34e576dd3b", "message": "Refactored ORDER BY", "committedDate": "2020-06-04T19:55:02Z", "type": "forcePushed"}, {"oid": "7dc0fb367f013b8dce6c52208c6de02599359bdb", "url": "https://github.com/prestodb/presto/commit/7dc0fb367f013b8dce6c52208c6de02599359bdb", "message": "Refactored ORDER BY", "committedDate": "2020-06-04T20:04:26Z", "type": "forcePushed"}, {"oid": "ecd5f18e23c853235d2ea1f8e200e1df463a55e9", "url": "https://github.com/prestodb/presto/commit/ecd5f18e23c853235d2ea1f8e200e1df463a55e9", "message": "Refactored ORDER BY", "committedDate": "2020-06-04T20:10:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMTcwNw==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r435521707", "bodyText": "This should probably happen in prepareFinal() but unsure how to do this without using twice as much memory.", "author": "sachdevs", "createdAt": "2020-06-04T20:12:14Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +702,115 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    private static class SpillableOrderingGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final OrderingGroupedAccumulator orderingGroupedAccumulator;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableOrderingGroupedAccumulator(\n+                GroupedAccumulator accumulator,\n+                List<Type> aggregationSourceTypes,\n+                List<Integer> orderByChannels,\n+                List<SortOrder> orderings,\n+                PagesIndex.Factory pagesIndexFactory)\n+        {\n+            this.orderingGroupedAccumulator = new OrderingGroupedAccumulator(accumulator, aggregationSourceTypes, orderByChannels, orderings, pagesIndexFactory);\n+            this.spillingTypes = aggregationSourceTypes;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return orderingGroupedAccumulator.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return orderingGroupedAccumulator.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            for (int pos = 0; pos < groupIdsBlock.getPositionCount(); pos++) {\n+                long groupId = groupIdsBlock.getGroupId(pos);\n+                intermediateState.ensureCapacity(groupId);\n+                RowBlockBuilder rowBlockBuilder = intermediateState.get(groupId);\n+                if (rowBlockBuilder == null) {\n+                    rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                }\n+\n+                BlockBuilder output = rowBlockBuilder.beginBlockEntry();\n+                for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                    spillingTypes.get(channel).appendTo(page.getBlock(channel), pos, output);\n+                }\n+                rowBlockBuilder.closeEntry();\n+\n+                intermediateState.set(groupId, rowBlockBuilder);\n+            }\n+\n+            orderingGroupedAccumulator.addInput(groupIdsBlock, page);", "originalCommit": "ecd5f18e23c853235d2ea1f8e200e1df463a55e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMjAzMg==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r435522032", "bodyText": "Should happen in prepareFinal() but unsure how to do without using twice as much memory, same issue as order by.", "author": "sachdevs", "createdAt": "2020-06-04T20:12:51Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -399,27 +418,136 @@ public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n             accumulator.addInput(groupIds, new Page(filtered.getPositionCount(), columns));\n         }\n \n+        @Override\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n+        {\n+            accumulator.evaluateFinal(groupId, output);\n+        }\n+\n+        @Override\n+        public void prepareFinal()\n+        {\n+        }\n+\n+        public void addBlocksToHash(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Work<Block> work = hash.markDistinctRows(new Page(blocks));\n+            checkState(work.process());\n+            Block distinctMask = work.getResult();\n+\n+            blocks[0] = distinctMask;\n+            accumulator.addInput(groupIds, new Page(blocks));\n+        }\n+    }\n+\n+    private static class SpillableDistinctingGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final DistinctingGroupedAccumulator distinctingGroupedAccumulator;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableDistinctingGroupedAccumulator(GroupedAccumulator accumulator,\n+                List<Type> inputTypes,\n+                List<Type> sourceTypes,\n+                List<Integer> inputChannels,\n+                Optional<Integer> maskChannel,\n+                Session session,\n+                JoinCompiler joinCompiler)\n+        {\n+            this.distinctingGroupedAccumulator = new DistinctingGroupedAccumulator(accumulator, inputTypes, sourceTypes, inputChannels, maskChannel, session, joinCompiler);\n+            this.spillingTypes = sourceTypes;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return distinctingGroupedAccumulator.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return distinctingGroupedAccumulator.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIds, Page page)\n+        {\n+            for (int pos = 0; pos < groupIds.getPositionCount(); pos++) {\n+                long groupId = groupIds.getGroupId(pos);\n+                intermediateState.ensureCapacity(groupId);\n+                RowBlockBuilder rowBlockBuilder = intermediateState.get(groupId);\n+                if (rowBlockBuilder == null) {\n+                    rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIds.getGroupCount());\n+                }\n+\n+                BlockBuilder output = rowBlockBuilder.beginBlockEntry();\n+                for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                    spillingTypes.get(channel).appendTo(page.getBlock(channel), pos, output);\n+                }\n+                rowBlockBuilder.closeEntry();\n+\n+                intermediateState.set(groupId, rowBlockBuilder);\n+            }\n+            // TODO do this in prepareFinal() instead because this duplicates data in intermediateState and distincting hash table\n+            distinctingGroupedAccumulator.addInput(groupIds, page);", "originalCommit": "ecd5f18e23c853235d2ea1f8e200e1df463a55e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMjQzNg==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r435522436", "bodyText": "Block internals need to be exposed for this implementation. Let me know if there are any alternatives.", "author": "sachdevs", "createdAt": "2020-06-04T20:13:42Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -399,27 +418,136 @@ public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n             accumulator.addInput(groupIds, new Page(filtered.getPositionCount(), columns));\n         }\n \n+        @Override\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n+        {\n+            accumulator.evaluateFinal(groupId, output);\n+        }\n+\n+        @Override\n+        public void prepareFinal()\n+        {\n+        }\n+\n+        public void addBlocksToHash(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Work<Block> work = hash.markDistinctRows(new Page(blocks));\n+            checkState(work.process());\n+            Block distinctMask = work.getResult();\n+\n+            blocks[0] = distinctMask;\n+            accumulator.addInput(groupIds, new Page(blocks));\n+        }\n+    }\n+\n+    private static class SpillableDistinctingGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final DistinctingGroupedAccumulator distinctingGroupedAccumulator;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableDistinctingGroupedAccumulator(GroupedAccumulator accumulator,\n+                List<Type> inputTypes,\n+                List<Type> sourceTypes,\n+                List<Integer> inputChannels,\n+                Optional<Integer> maskChannel,\n+                Session session,\n+                JoinCompiler joinCompiler)\n+        {\n+            this.distinctingGroupedAccumulator = new DistinctingGroupedAccumulator(accumulator, inputTypes, sourceTypes, inputChannels, maskChannel, session, joinCompiler);\n+            this.spillingTypes = sourceTypes;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return distinctingGroupedAccumulator.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return distinctingGroupedAccumulator.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIds, Page page)\n+        {\n+            for (int pos = 0; pos < groupIds.getPositionCount(); pos++) {\n+                long groupId = groupIds.getGroupId(pos);\n+                intermediateState.ensureCapacity(groupId);\n+                RowBlockBuilder rowBlockBuilder = intermediateState.get(groupId);\n+                if (rowBlockBuilder == null) {\n+                    rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIds.getGroupCount());\n+                }\n+\n+                BlockBuilder output = rowBlockBuilder.beginBlockEntry();\n+                for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                    spillingTypes.get(channel).appendTo(page.getBlock(channel), pos, output);\n+                }\n+                rowBlockBuilder.closeEntry();\n+\n+                intermediateState.set(groupId, rowBlockBuilder);\n+            }\n+            // TODO do this in prepareFinal() instead because this duplicates data in intermediateState and distincting hash table\n+            distinctingGroupedAccumulator.addInput(groupIds, page);\n+        }\n+\n         @Override\n         public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n         {\n-            throw new UnsupportedOperationException();\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+            int newPositionCount = arrayBlock.getRawElementBlock().getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size() + 1];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel + 1] = ((RowBlock) arrayBlock.getRawElementBlock()).getRawFieldBlocks()[channel]; // super ugly exposing block internals", "originalCommit": "ecd5f18e23c853235d2ea1f8e200e1df463a55e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTUyMzAwMA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r435523000", "bodyText": "All of these need be conditionally created based on if spilling enabled/disabled + if we are using HashAggregationOperator. Not sure how to do this cleanly so left this as the default option for now.", "author": "sachdevs", "createdAt": "2020-06-04T20:14:50Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -167,23 +174,40 @@ public GroupedAccumulator createGroupedAccumulator()\n                 argumentTypes.add(sourceTypes.get(input));\n             }\n \n-            accumulator = new DistinctingGroupedAccumulator(accumulator, argumentTypes, inputChannels, maskChannel, session, joinCompiler);\n+            accumulator = new SpillableDistinctingGroupedAccumulator(accumulator, argumentTypes, sourceTypes, inputChannels, maskChannel, session, joinCompiler);\n         }\n         else {\n             accumulator = instantiateGroupedAccumulator(inputChannels, maskChannel);\n         }\n \n-        if (orderByChannels.isEmpty()) {\n+        if (!hasOrderBy()) {\n             return accumulator;\n         }\n \n-        return new OrderingGroupedAccumulator(accumulator, sourceTypes, orderByChannels, orderings, pagesIndexFactory);\n+        return new SpillableOrderingGroupedAccumulator(accumulator, sourceTypes, orderByChannels, orderings, pagesIndexFactory);", "originalCommit": "ecd5f18e23c853235d2ea1f8e200e1df463a55e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ec43556b3db434a0cdef7624fad0f1799d7d6737", "url": "https://github.com/prestodb/presto/commit/ec43556b3db434a0cdef7624fad0f1799d7d6737", "message": "Refactored ORDER BY", "committedDate": "2020-06-04T20:25:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwODIxNw==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r435708217", "bodyText": "SpillableDistinctingGroupedAccumulator and SpillableOrderingGroupedAccumulator are very much the same. We just need one and call it SpillableFinalOnlyGroupedAccumulator", "author": "highker", "createdAt": "2020-06-05T06:08:34Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -399,27 +418,136 @@ public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n             accumulator.addInput(groupIds, new Page(filtered.getPositionCount(), columns));\n         }\n \n+        @Override\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n+        {\n+            accumulator.evaluateFinal(groupId, output);\n+        }\n+\n+        @Override\n+        public void prepareFinal()\n+        {\n+        }\n+\n+        public void addBlocksToHash(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Work<Block> work = hash.markDistinctRows(new Page(blocks));\n+            checkState(work.process());\n+            Block distinctMask = work.getResult();\n+\n+            blocks[0] = distinctMask;\n+            accumulator.addInput(groupIds, new Page(blocks));\n+        }\n+    }\n+\n+    private static class SpillableDistinctingGroupedAccumulator", "originalCommit": "ec43556b3db434a0cdef7624fad0f1799d7d6737", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTcwODMyNw==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r435708327", "bodyText": "This can be FinalOnlyGroupedAccumulator", "author": "highker", "createdAt": "2020-06-05T06:08:57Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -399,27 +418,136 @@ public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n             accumulator.addInput(groupIds, new Page(filtered.getPositionCount(), columns));\n         }\n \n+        @Override\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n+        {\n+            accumulator.evaluateFinal(groupId, output);\n+        }\n+\n+        @Override\n+        public void prepareFinal()\n+        {\n+        }\n+\n+        public void addBlocksToHash(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Work<Block> work = hash.markDistinctRows(new Page(blocks));\n+            checkState(work.process());\n+            Block distinctMask = work.getResult();\n+\n+            blocks[0] = distinctMask;\n+            accumulator.addInput(groupIds, new Page(blocks));\n+        }\n+    }\n+\n+    private static class SpillableDistinctingGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final DistinctingGroupedAccumulator distinctingGroupedAccumulator;", "originalCommit": "ec43556b3db434a0cdef7624fad0f1799d7d6737", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjA3MTMxMQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436071311", "bodyText": "Not too happy about having to do this since unsure of the memory implications. But this is the only way since the two accumulators format their pages in different ways. Let me know if you can think of any alternatives.", "author": "sachdevs", "createdAt": "2020-06-05T17:47:12Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMTU2NA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436231564", "bodyText": "Do we need this change? Or this purely for test? If it's for test, I think we don't have to change this and just fix the tests.", "author": "highker", "createdAt": "2020-06-06T03:00:30Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/MemoryRevokingScheduler.java", "diffHunk": "@@ -41,7 +41,7 @@\n \n import static com.google.common.base.Preconditions.checkArgument;\n import static java.util.Objects.requireNonNull;\n-import static java.util.concurrent.TimeUnit.SECONDS;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg1ODAzNA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r439858034", "bodyText": "purely for test, removed in commit.", "author": "sachdevs", "createdAt": "2020-06-14T18:56:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMTU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzMTYxMg==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436231612", "bodyText": "Remove comment \"// hasOrderBy() || hasDistinct()\"", "author": "highker", "createdAt": "2020-06-06T03:01:04Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/HashAggregationOperator.java", "diffHunk": "@@ -367,7 +367,7 @@ public void addInput(Page page)\n \n         if (aggregationBuilder == null) {\n             // TODO: We ignore spillEnabled here if any aggregate has ORDER BY clause or DISTINCT because they are not yet implemented for spilling.\n-            if (step.isOutputPartial() || !spillEnabled || hasOrderBy() || hasDistinct()) {\n+            if (step.isOutputPartial() || !spillEnabled) { // hasOrderBy() || hasDistinct()", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzOTQ3Mg==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436239472", "bodyText": "Add a javadoc to denote such accumulator does not support partial aggregation. But they need to support spilling", "author": "highker", "createdAt": "2020-06-06T05:16:36Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/FinalOnlyGroupedAccumulator.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.GroupByIdBlock;\n+\n+public abstract class FinalOnlyGroupedAccumulator", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0MTY3MA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436241670", "bodyText": "Add a javadoc to denote this is for FinalOnlyGroupedAccumulator only", "author": "highker", "createdAt": "2020-06-06T05:54:03Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0MjE2OA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436242168", "bodyText": "blockBuilders", "author": "highker", "createdAt": "2020-06-06T06:02:53Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0MjIzNg==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436242236", "bodyText": "position", "author": "highker", "createdAt": "2020-06-06T06:04:11Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            for (int pos = 0; pos < groupIdsBlock.getPositionCount(); pos++) {", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0NDY2Mw==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436244663", "bodyText": "accidental change", "author": "highker", "createdAt": "2020-06-06T06:47:08Z", "path": "presto-tests/src/main/java/com/facebook/presto/tests/AbstractTestAggregations.java", "diffHunk": "@@ -910,7 +910,7 @@ public void testGroupBySum()\n     @Test\n     public void testGroupByRequireIntegerCoercion()\n     {\n-        assertQuery(\"SELECT partkey, COUNT(DISTINCT shipdate), SUM(linenumber) FROM lineitem GROUP BY partkey\");\n+        assertQuery(\"SELECT partkey, COUNT(DISTINCT shipdate), SUM(linenumber) FROM lineitem GROUP BY partkeyTestHivePushdownDistributedQuer\");", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyMjU0Mg==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436322542", "bodyText": "This will cause a bug: if the accumulator has distinct and orderBy, then the accumulator will be\n\nSpillableGroupedAccumulator wrapping\n\nOrderingGroupedAccumulator wrapping\n\nanother SpillableGroupedAccumulator and finally wrapping\n\nDistinctingGroupedAccumulator.\n\n\n\n\n\n\n\nHowever, it should be\n\nSpillableGroupedAccumulator wrapping\n\nOrderingGroupedAccumulator and then wrapping\n\nDistinctingGroupedAccumulator.", "author": "highker", "createdAt": "2020-06-07T04:08:04Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -167,23 +174,48 @@ public GroupedAccumulator createGroupedAccumulator()\n                 argumentTypes.add(sourceTypes.get(input));\n             }\n \n-            accumulator = new DistinctingGroupedAccumulator(accumulator, argumentTypes, inputChannels, maskChannel, session, joinCompiler);\n+            accumulator = new SpillableGroupedAccumulator(\n+                    sourceTypes,\n+                    new DistinctingGroupedAccumulator(accumulator, argumentTypes, inputChannels, maskChannel, session, joinCompiler));\n         }\n         else {\n             accumulator = instantiateGroupedAccumulator(inputChannels, maskChannel);\n         }\n \n-        if (orderByChannels.isEmpty()) {\n+        if (!hasOrderBy()) {\n             return accumulator;\n         }\n \n-        return new OrderingGroupedAccumulator(accumulator, sourceTypes, orderByChannels, orderings, pagesIndexFactory);\n+        return new SpillableGroupedAccumulator(", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg4NDc0Mg==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r439884742", "bodyText": "Fixed - nice catch.", "author": "sachdevs", "createdAt": "2020-06-15T00:34:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyMjU0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyMjY2Nw==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436322667", "bodyText": "Same here. What if it's orderBy + distinct?", "author": "highker", "createdAt": "2020-06-07T04:10:52Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -167,23 +174,48 @@ public GroupedAccumulator createGroupedAccumulator()\n                 argumentTypes.add(sourceTypes.get(input));\n             }\n \n-            accumulator = new DistinctingGroupedAccumulator(accumulator, argumentTypes, inputChannels, maskChannel, session, joinCompiler);\n+            accumulator = new SpillableGroupedAccumulator(\n+                    sourceTypes,\n+                    new DistinctingGroupedAccumulator(accumulator, argumentTypes, inputChannels, maskChannel, session, joinCompiler));\n         }\n         else {\n             accumulator = instantiateGroupedAccumulator(inputChannels, maskChannel);\n         }\n \n-        if (orderByChannels.isEmpty()) {\n+        if (!hasOrderBy()) {\n             return accumulator;\n         }\n \n-        return new OrderingGroupedAccumulator(accumulator, sourceTypes, orderByChannels, orderings, pagesIndexFactory);\n+        return new SpillableGroupedAccumulator(\n+                sourceTypes,\n+                new OrderingGroupedAccumulator(accumulator, sourceTypes, orderByChannels, orderings, pagesIndexFactory));\n     }\n \n     @Override\n     public GroupedAccumulator createGroupedIntermediateAccumulator()\n     {\n         try {\n+            if (hasOrderBy()) {\n+                GroupedAccumulator accumulator = groupedAccumulatorConstructor.newInstance(stateDescriptors, inputChannels, maskChannel, lambdaProviders);\n+                return new SpillableGroupedAccumulator(\n+                        sourceTypes,\n+                        new OrderingGroupedAccumulator(accumulator, sourceTypes, orderByChannels, orderings, pagesIndexFactory));\n+            }\n+            if (hasDistinct()) {\n+                List<Type> argumentTypes = new ArrayList<>();\n+                for (int input : inputChannels) {\n+                    argumentTypes.add(sourceTypes.get(input));\n+                }\n+                // grouped accumulator needs to have channel 0 as distinct mask\n+                GroupedAccumulator accumulator = instantiateGroupedAccumulator(\n+                        inputChannels.stream()\n+                                .map(value -> value + 1)\n+                                .collect(Collectors.toList()),\n+                        Optional.of(0));\n+                return new SpillableGroupedAccumulator(\n+                        sourceTypes,\n+                        new DistinctingGroupedAccumulator(accumulator, argumentTypes, inputChannels, maskChannel, session, joinCompiler));\n+            }", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyMjg1OQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436322859", "bodyText": "page.prependColumn is to do that right?", "author": "highker", "createdAt": "2020-06-07T04:15:18Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -400,26 +426,29 @@ public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n         }\n \n         @Override\n-        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n         {\n-            throw new UnsupportedOperationException();\n+            accumulator.evaluateFinal(groupId, output);\n         }\n \n         @Override\n-        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        public void prepareFinal()\n         {\n-            throw new UnsupportedOperationException();\n         }\n \n         @Override\n-        public void evaluateFinal(int groupId, BlockBuilder output)\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n         {\n-            accumulator.evaluateFinal(groupId, output);\n-        }\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            groupByAndBlocks[0] = groupIds;\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 1, blocks.length);", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyMjg3Ng==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436322876", "bodyText": "idAndBlocks", "author": "highker", "createdAt": "2020-06-07T04:15:42Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -400,26 +426,29 @@ public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n         }\n \n         @Override\n-        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n         {\n-            throw new UnsupportedOperationException();\n+            accumulator.evaluateFinal(groupId, output);\n         }\n \n         @Override\n-        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        public void prepareFinal()\n         {\n-            throw new UnsupportedOperationException();\n         }\n \n         @Override\n-        public void evaluateFinal(int groupId, BlockBuilder output)\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n         {\n-            accumulator.evaluateFinal(groupId, output);\n-        }\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyMzQzNw==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436323437", "bodyText": "The entire function body can be squashed into just one line right?\n\naddInput(groupIds, new Page(blocks));\n\nHaven't given a deep thought into distincting'saddIntermediateStateOnUnspill yet. But I assume it could be squashed. If that is the case, we don't need interface addIntermediateStateOnUnspill anymore. Will think about it in the next review iteration.", "author": "highker", "createdAt": "2020-06-07T04:27:40Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyNDEwMg==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436324102", "bodyText": "check state that it is an array block builder", "author": "highker", "createdAt": "2020-06-07T04:41:51Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            for (int pos = 0; pos < groupIdsBlock.getPositionCount(); pos++) {\n+                long groupId = groupIdsBlock.getGroupId(pos);\n+                intermediateState.ensureCapacity(groupId);\n+                RowBlockBuilder rowBlockBuilder = intermediateState.get(groupId);\n+                if (rowBlockBuilder == null) {\n+                    rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                }\n+\n+                BlockBuilder output = rowBlockBuilder.beginBlockEntry();\n+                for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                    spillingTypes.get(channel).appendTo(page.getBlock(channel), pos, output);\n+                }\n+                rowBlockBuilder.closeEntry();\n+\n+                intermediateState.set(groupId, rowBlockBuilder);\n+            }\n+\n+            // TODO do this in prepareFinal() instead because this duplicates data in intermediateState and distincting hash table\n+            delegate.addInput(groupIdsBlock, page);\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+            int newPositionCount = arrayBlock.getRawElementBlock().getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = ((RowBlock) arrayBlock.getRawElementBlock()).getRawFieldBlocks()[channel]; // super ugly exposing block internals\n+            }\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+            delegate.addIntermediateStateOnUnspill(squashedGroupIds, blocks);\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {\n+            BlockBuilder arrayBlockBuilder = output.beginBlockEntry();", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyNDE0MA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436324140", "bodyText": "check state that block is instance of ArrayBlock", "author": "highker", "createdAt": "2020-06-07T04:42:42Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            for (int pos = 0; pos < groupIdsBlock.getPositionCount(); pos++) {\n+                long groupId = groupIdsBlock.getGroupId(pos);\n+                intermediateState.ensureCapacity(groupId);\n+                RowBlockBuilder rowBlockBuilder = intermediateState.get(groupId);\n+                if (rowBlockBuilder == null) {\n+                    rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                }\n+\n+                BlockBuilder output = rowBlockBuilder.beginBlockEntry();\n+                for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                    spillingTypes.get(channel).appendTo(page.getBlock(channel), pos, output);\n+                }\n+                rowBlockBuilder.closeEntry();\n+\n+                intermediateState.set(groupId, rowBlockBuilder);\n+            }\n+\n+            // TODO do this in prepareFinal() instead because this duplicates data in intermediateState and distincting hash table\n+            delegate.addInput(groupIdsBlock, page);\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            ArrayBlock arrayBlock = (ArrayBlock) block;", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyNDE1Ng==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436324156", "bodyText": "Do we really need this line? I think we can remove it. Check my comment below.", "author": "highker", "createdAt": "2020-06-07T04:43:01Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            for (int pos = 0; pos < groupIdsBlock.getPositionCount(); pos++) {\n+                long groupId = groupIdsBlock.getGroupId(pos);\n+                intermediateState.ensureCapacity(groupId);\n+                RowBlockBuilder rowBlockBuilder = intermediateState.get(groupId);\n+                if (rowBlockBuilder == null) {\n+                    rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                }\n+\n+                BlockBuilder output = rowBlockBuilder.beginBlockEntry();\n+                for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                    spillingTypes.get(channel).appendTo(page.getBlock(channel), pos, output);\n+                }\n+                rowBlockBuilder.closeEntry();\n+\n+                intermediateState.set(groupId, rowBlockBuilder);\n+            }\n+\n+            // TODO do this in prepareFinal() instead because this duplicates data in intermediateState and distincting hash table\n+            delegate.addInput(groupIdsBlock, page);", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyNDU5MQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436324591", "bodyText": "I think for this function, we don't need to touch upon delegate. Instead, we need to collect all the squashedGroupIds and blocks into rawInputs by calling addInput(groupIdsBlock, page)", "author": "highker", "createdAt": "2020-06-07T04:51:44Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            for (int pos = 0; pos < groupIdsBlock.getPositionCount(); pos++) {\n+                long groupId = groupIdsBlock.getGroupId(pos);\n+                intermediateState.ensureCapacity(groupId);\n+                RowBlockBuilder rowBlockBuilder = intermediateState.get(groupId);\n+                if (rowBlockBuilder == null) {\n+                    rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                }\n+\n+                BlockBuilder output = rowBlockBuilder.beginBlockEntry();\n+                for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                    spillingTypes.get(channel).appendTo(page.getBlock(channel), pos, output);\n+                }\n+                rowBlockBuilder.closeEntry();\n+\n+                intermediateState.set(groupId, rowBlockBuilder);\n+            }\n+\n+            // TODO do this in prepareFinal() instead because this duplicates data in intermediateState and distincting hash table\n+            delegate.addInput(groupIdsBlock, page);\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+            int newPositionCount = arrayBlock.getRawElementBlock().getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = ((RowBlock) arrayBlock.getRawElementBlock()).getRawFieldBlocks()[channel]; // super ugly exposing block internals\n+            }\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+            delegate.addIntermediateStateOnUnspill(squashedGroupIds, blocks);", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyNDc2Nw==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436324767", "bodyText": "add a check state to make sure intermediateState is empty. We shouldn't touch intermediateState at this step anymore.", "author": "highker", "createdAt": "2020-06-07T04:55:31Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            for (int pos = 0; pos < groupIdsBlock.getPositionCount(); pos++) {\n+                long groupId = groupIdsBlock.getGroupId(pos);\n+                intermediateState.ensureCapacity(groupId);\n+                RowBlockBuilder rowBlockBuilder = intermediateState.get(groupId);\n+                if (rowBlockBuilder == null) {\n+                    rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                }\n+\n+                BlockBuilder output = rowBlockBuilder.beginBlockEntry();\n+                for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                    spillingTypes.get(channel).appendTo(page.getBlock(channel), pos, output);\n+                }\n+                rowBlockBuilder.closeEntry();\n+\n+                intermediateState.set(groupId, rowBlockBuilder);\n+            }\n+\n+            // TODO do this in prepareFinal() instead because this duplicates data in intermediateState and distincting hash table\n+            delegate.addInput(groupIdsBlock, page);\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyNTIwMQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436325201", "bodyText": "Add a check state to make sure intermediateState (or blockBuilders after renaming) is null. We shouldn't touch blockBuilders at this step anymore.\nNow, this is the key part. Let's take all the data in rawInputs and feed them into delegate.addInput(...). This should be the first time we touch delegate. Note that if rawInputs is a list or an array, we should deref the item so that we don't use 2X the memory. The easiest way to do so is to assign null to the entry that has just been fed into delegate.addInput(...).", "author": "highker", "createdAt": "2020-06-07T05:03:58Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            for (int pos = 0; pos < groupIdsBlock.getPositionCount(); pos++) {\n+                long groupId = groupIdsBlock.getGroupId(pos);\n+                intermediateState.ensureCapacity(groupId);\n+                RowBlockBuilder rowBlockBuilder = intermediateState.get(groupId);\n+                if (rowBlockBuilder == null) {\n+                    rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                }\n+\n+                BlockBuilder output = rowBlockBuilder.beginBlockEntry();\n+                for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                    spillingTypes.get(channel).appendTo(page.getBlock(channel), pos, output);\n+                }\n+                rowBlockBuilder.closeEntry();\n+\n+                intermediateState.set(groupId, rowBlockBuilder);\n+            }\n+\n+            // TODO do this in prepareFinal() instead because this duplicates data in intermediateState and distincting hash table\n+            delegate.addInput(groupIdsBlock, page);\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+            int newPositionCount = arrayBlock.getRawElementBlock().getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = ((RowBlock) arrayBlock.getRawElementBlock()).getRawFieldBlocks()[channel]; // super ugly exposing block internals\n+            }\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+            delegate.addIntermediateStateOnUnspill(squashedGroupIds, blocks);\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {\n+            BlockBuilder arrayBlockBuilder = output.beginBlockEntry();\n+            RowBlock rowBlock = (RowBlock) intermediateState.get((long) groupId).build();\n+            for (int i = 0; i < rowBlock.getPositionCount(); i++) {\n+                arrayBlockBuilder.appendStructure(rowBlock.getBlock(i));\n+            }\n+            output.closeEntry();\n+        }\n+\n+        @Override\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n+        {\n+            delegate.evaluateFinal(groupId, output);\n+        }\n+\n+        @Override\n+        public void prepareFinal()\n+        {", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyNzYzMQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436327631", "bodyText": "Let's keep track of two data structures:\nprivate ObjectBigArray<RowBlockBuilder> blockBuilders = null;\nprivate List<Page> rawInputs = new ArrayList<>();  // or other list/array data structure", "author": "highker", "createdAt": "2020-06-07T05:48:34Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyNzc0Nw==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436327747", "bodyText": "At this step, just do rawInputs.add(page.prependColumn(groupIdsBlock)); and that's it.", "author": "highker", "createdAt": "2020-06-07T05:50:40Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyNzg2Mw==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436327863", "bodyText": "At this step, explode block into page (RowBlock -> Block[]) with your logic. Then do addInput(groupIdsBlock, page);", "author": "highker", "createdAt": "2020-06-07T05:52:35Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            for (int pos = 0; pos < groupIdsBlock.getPositionCount(); pos++) {\n+                long groupId = groupIdsBlock.getGroupId(pos);\n+                intermediateState.ensureCapacity(groupId);\n+                RowBlockBuilder rowBlockBuilder = intermediateState.get(groupId);\n+                if (rowBlockBuilder == null) {\n+                    rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                }\n+\n+                BlockBuilder output = rowBlockBuilder.beginBlockEntry();\n+                for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                    spillingTypes.get(channel).appendTo(page.getBlock(channel), pos, output);\n+                }\n+                rowBlockBuilder.closeEntry();\n+\n+                intermediateState.set(groupId, rowBlockBuilder);\n+            }\n+\n+            // TODO do this in prepareFinal() instead because this duplicates data in intermediateState and distincting hash table\n+            delegate.addInput(groupIdsBlock, page);\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyODA3Mg==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r436328072", "bodyText": "We need to convert rawInputs into blockBuilders. So\n// this could be very expensive for the first time\nif (blockBuilders == null) {\n    blockBuilders = new ...;\n    for (Page page : rawInputs) {\n        // build the internal state just like your original logic for `addInput`.\n    }\n}\n\n// remaining logic", "author": "highker", "createdAt": "2020-06-07T05:55:30Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -585,5 +596,119 @@ public void prepareFinal()\n                 accumulator.addInput(groupIds, page);\n             });\n         }\n+\n+        @Override\n+        public void addIntermediateStateOnUnspill(GroupByIdBlock groupIds, Block[] blocks)\n+        {\n+            Block[] groupByAndBlocks = new Block[blocks.length + 1];\n+            System.arraycopy(blocks, 0, groupByAndBlocks, 0, blocks.length);\n+            groupByAndBlocks[blocks.length] = groupIds;\n+            groupCount = max(groupCount, groupIds.getGroupCount());\n+            pagesIndex.addPage(new Page(groupByAndBlocks));\n+        }\n+    }\n+\n+    private static class SpillableGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final ObjectBigArray<RowBlockBuilder> intermediateState;\n+        private final List<Type> spillingTypes;\n+\n+        public SpillableGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+            this.intermediateState = new ObjectBigArray<>();\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + intermediateState.sizeOf();\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            for (int pos = 0; pos < groupIdsBlock.getPositionCount(); pos++) {\n+                long groupId = groupIdsBlock.getGroupId(pos);\n+                intermediateState.ensureCapacity(groupId);\n+                RowBlockBuilder rowBlockBuilder = intermediateState.get(groupId);\n+                if (rowBlockBuilder == null) {\n+                    rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                }\n+\n+                BlockBuilder output = rowBlockBuilder.beginBlockEntry();\n+                for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                    spillingTypes.get(channel).appendTo(page.getBlock(channel), pos, output);\n+                }\n+                rowBlockBuilder.closeEntry();\n+\n+                intermediateState.set(groupId, rowBlockBuilder);\n+            }\n+\n+            // TODO do this in prepareFinal() instead because this duplicates data in intermediateState and distincting hash table\n+            delegate.addInput(groupIdsBlock, page);\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+            int newPositionCount = arrayBlock.getRawElementBlock().getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = ((RowBlock) arrayBlock.getRawElementBlock()).getRawFieldBlocks()[channel]; // super ugly exposing block internals\n+            }\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+            delegate.addIntermediateStateOnUnspill(squashedGroupIds, blocks);\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1OTEzMQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r437159131", "bodyText": "If we don't wanna use too much memory for this method, we can always call compact() to materialize the mask. This is true for filter. Haven't read the AccumulatorCompiler in details, but might also be fine for distinctMask as well. This trick has been used in many place (e.g, GroupedTopNBuilder)", "author": "highker", "createdAt": "2020-06-09T06:10:30Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -322,7 +354,7 @@ private static Page filter(Page page, Block mask)\n     }\n \n     private static class DistinctingGroupedAccumulator", "originalCommit": "8fecba0a5be03ff9ebc76fa2f57042b7f15dc8d8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "bdf63cfca5251134461e02fc75f584e57c5f1f0e", "url": "https://github.com/prestodb/presto/commit/bdf63cfca5251134461e02fc75f584e57c5f1f0e", "message": "Refactor order by and distinct spilling, will squash on merge", "committedDate": "2020-06-15T00:57:59Z", "type": "forcePushed"}, {"oid": "0e9b7dd3f36b8a399f33af1a7013e96900470731", "url": "https://github.com/prestodb/presto/commit/0e9b7dd3f36b8a399f33af1a7013e96900470731", "message": "Refactor order by and distinct spilling, will squash on merge", "committedDate": "2020-06-15T01:07:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg4OTI2Ng==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r439889266", "bodyText": "evaluateIntermediate can be called after prepareFinal since it is called by a separate revoking thread from my understanding. This means that we cannot set rawInputs = null.", "author": "sachdevs", "createdAt": "2020-06-15T01:12:04Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +592,163 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsSize;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + rawInputsSize + (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(groupIdsBlock, page));\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            checkState(block instanceof ArrayBlock);\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+\n+            int newPositionCount = arrayBlock.getRawElementBlock().getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = ((RowBlock) arrayBlock.getRawElementBlock()).getRawFieldBlocks()[channel]; // super ugly exposing block internals\n+            }\n+            Page page = new Page(blocks);\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(squashedGroupIds, page));\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {\n+            if (blockBuilders == null) {\n+                if (rawInputs == null) {\n+                    return;\n+                }\n+                blockBuilders = new ObjectBigArray<>();  // we need to spill now; let's build the hash table here\n+                for (GroupIdPage groupIdPage : rawInputs) {\n+                    Page page = groupIdPage.getPage();\n+                    GroupByIdBlock groupIdsBlock = groupIdPage.getGroupByIdBlock();\n+                    for (int position = 0; position < page.getPositionCount(); position++) {\n+                        long currentGroupId = groupIdsBlock.getGroupId(position);\n+                        blockBuilders.ensureCapacity(currentGroupId);\n+                        RowBlockBuilder rowBlockBuilder = blockBuilders.get(currentGroupId);\n+                        if (rowBlockBuilder == null) {\n+                            rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                        }\n+\n+                        BlockBuilder currentOutput = rowBlockBuilder.beginBlockEntry();\n+                        for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                            spillingTypes.get(channel).appendTo(page.getBlock(channel), position, currentOutput);\n+                        }\n+                        rowBlockBuilder.closeEntry();\n+\n+                        blockBuilders.set(currentGroupId, rowBlockBuilder);\n+                    }\n+                }\n+                rawInputs = null;\n+                rawInputsSize = 0;\n+            }\n+\n+            BlockBuilder singleArrayBlockWriter = output.beginBlockEntry();\n+            checkState(rawInputs == null && blockBuilders != null);\n+            checkState(singleArrayBlockWriter instanceof SingleArrayBlockWriter);\n+\n+            RowBlock rowBlock = (RowBlock) blockBuilders.get((long) groupId).build();\n+            for (int i = 0; i < rowBlock.getPositionCount(); i++) {\n+                singleArrayBlockWriter.appendStructure(rowBlock.getBlock(i));\n+            }\n+            output.closeEntry();\n+        }\n+\n+        @Override\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n+        {\n+            // checkState(rawInputs == null && blockBuilders == null);\n+            delegate.evaluateFinal(groupId, output);\n+        }\n+\n+        @Override\n+        public void prepareFinal()\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            for (GroupIdPage groupIdPage : rawInputs) {\n+                delegate.addInput(groupIdPage.getGroupByIdBlock(), groupIdPage.getPage());\n+            }\n+\n+            // cannot set raw inputs to null because evaluateIntermediate may be called after prepareFinal()", "originalCommit": "0e9b7dd3f36b8a399f33af1a7013e96900470731", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI2MzE5OQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441263199", "bodyText": "If we cannot set it to null, we can still deref it by rawInputs  = new ..", "author": "highker", "createdAt": "2020-06-17T03:43:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg4OTI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyNzg1Nw==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441327857", "bodyText": "Unfortunately we cant - this is because the outer function that calls this is buildResult() in hash agg builder - https://github.com/prestodb/presto/blob/master/presto-main/src/main/java/com/facebook/presto/operator/aggregation/builder/InMemoryHashAggregationBuilder.java#L306. It tries to build a page out of the result returned by evaluateIntermediate. If there's nothing in the array, it will create a malformed page and fail.", "author": "sachdevs", "createdAt": "2020-06-17T07:10:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg4OTI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTMyOTEwMQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441329101", "bodyText": "If that is case, meaning we shouldn't ever allow memory revoking if an aggregation has started to eval final right?", "author": "highker", "createdAt": "2020-06-17T07:13:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg4OTI2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc0MzAxMA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441743010", "bodyText": "The reason this is not that simple is that memory revoking is done at the driver level. I have implemented a check for this but it may not work. I have convinced myself that it makes sense but let me know since it seems a bit fishy.\nTake a look at hasBuiltFinalResult in InMemoryHashAggregationBuilder in my newest iteration.", "author": "sachdevs", "createdAt": "2020-06-17T18:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg4OTI2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg4OTYxNQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r439889615", "bodyText": "Made a pair class since otherwise we will have to separate group ids block and page every time we addInput to the delegate and make a new page object. Felt this was more efficient due to that.", "author": "sachdevs", "createdAt": "2020-06-15T01:14:37Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +592,163 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsSize;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + rawInputsSize + (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(groupIdsBlock, page));\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            checkState(block instanceof ArrayBlock);\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+\n+            int newPositionCount = arrayBlock.getRawElementBlock().getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = ((RowBlock) arrayBlock.getRawElementBlock()).getRawFieldBlocks()[channel]; // super ugly exposing block internals\n+            }\n+            Page page = new Page(blocks);\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(squashedGroupIds, page));\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {\n+            if (blockBuilders == null) {\n+                if (rawInputs == null) {\n+                    return;\n+                }\n+                blockBuilders = new ObjectBigArray<>();  // we need to spill now; let's build the hash table here\n+                for (GroupIdPage groupIdPage : rawInputs) {\n+                    Page page = groupIdPage.getPage();\n+                    GroupByIdBlock groupIdsBlock = groupIdPage.getGroupByIdBlock();\n+                    for (int position = 0; position < page.getPositionCount(); position++) {\n+                        long currentGroupId = groupIdsBlock.getGroupId(position);\n+                        blockBuilders.ensureCapacity(currentGroupId);\n+                        RowBlockBuilder rowBlockBuilder = blockBuilders.get(currentGroupId);\n+                        if (rowBlockBuilder == null) {\n+                            rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                        }\n+\n+                        BlockBuilder currentOutput = rowBlockBuilder.beginBlockEntry();\n+                        for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                            spillingTypes.get(channel).appendTo(page.getBlock(channel), position, currentOutput);\n+                        }\n+                        rowBlockBuilder.closeEntry();\n+\n+                        blockBuilders.set(currentGroupId, rowBlockBuilder);\n+                    }\n+                }\n+                rawInputs = null;\n+                rawInputsSize = 0;\n+            }\n+\n+            BlockBuilder singleArrayBlockWriter = output.beginBlockEntry();\n+            checkState(rawInputs == null && blockBuilders != null);\n+            checkState(singleArrayBlockWriter instanceof SingleArrayBlockWriter);\n+\n+            RowBlock rowBlock = (RowBlock) blockBuilders.get((long) groupId).build();\n+            for (int i = 0; i < rowBlock.getPositionCount(); i++) {\n+                singleArrayBlockWriter.appendStructure(rowBlock.getBlock(i));\n+            }\n+            output.closeEntry();\n+        }\n+\n+        @Override\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n+        {\n+            // checkState(rawInputs == null && blockBuilders == null);\n+            delegate.evaluateFinal(groupId, output);\n+        }\n+\n+        @Override\n+        public void prepareFinal()\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            for (GroupIdPage groupIdPage : rawInputs) {\n+                delegate.addInput(groupIdPage.getGroupByIdBlock(), groupIdPage.getPage());\n+            }\n+\n+            // cannot set raw inputs to null because evaluateIntermediate may be called after prepareFinal()\n+            delegate.prepareFinal();\n+        }\n+\n+        private static class GroupIdPage", "originalCommit": "0e9b7dd3f36b8a399f33af1a7013e96900470731", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI2NjM0Mg==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441266342", "bodyText": "That is ok", "author": "highker", "createdAt": "2020-06-17T03:57:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg4OTYxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkxODIwMw==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r439918203", "bodyText": "Take a look at ColumnarArray and ColumnarRow. That may be helpful to make the modifiers untouched in presto-common", "author": "highker", "createdAt": "2020-06-15T03:54:05Z", "path": "presto-common/src/main/java/com/facebook/presto/common/block/AbstractArrayBlock.java", "diffHunk": "@@ -30,7 +30,7 @@\n public abstract class AbstractArrayBlock\n         implements Block\n {\n-    protected abstract Block getRawElementBlock();\n+    public abstract Block getRawElementBlock();", "originalCommit": "0e9b7dd3f36b8a399f33af1a7013e96900470731", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY0OTU2MQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r440649561", "bodyText": "Show we create spillable accumulator based on isSpillEnabled(session)?", "author": "highker", "createdAt": "2020-06-16T07:43:05Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -168,23 +176,57 @@ public GroupedAccumulator createGroupedAccumulator()\n             }\n \n             accumulator = new DistinctingGroupedAccumulator(accumulator, argumentTypes, inputChannels, maskChannel, session, joinCompiler);\n+            if (!hasOrderBy()) {\n+                accumulator = new SpillableFinalOnlyGroupedAccumulator(sourceTypes, (FinalOnlyGroupedAccumulator) accumulator);", "originalCommit": "0e9b7dd3f36b8a399f33af1a7013e96900470731", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg0MDAwMQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441840001", "bodyText": "Did a few interface changes to accomplish this. Feel free to comment.", "author": "sachdevs", "createdAt": "2020-06-17T21:18:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDY0OTU2MQ=="}], "type": "inlineReview"}, {"oid": "a510ffee36d03f4683e32e22db1a6197e4ad0ff5", "url": "https://github.com/prestodb/presto/commit/a510ffee36d03f4683e32e22db1a6197e4ad0ff5", "message": "Refactor order by and distinct spilling, will squash on merge", "committedDate": "2020-06-16T19:46:06Z", "type": "forcePushed"}, {"oid": "3691c6e2cb3589bddb99ceb6e7789b7eb75d15b4", "url": "https://github.com/prestodb/presto/commit/3691c6e2cb3589bddb99ceb6e7789b7eb75d15b4", "message": "Refactor order by and distinct spilling, will squash on merge", "committedDate": "2020-06-16T19:49:20Z", "type": "forcePushed"}, {"oid": "e7b5eb567740a916c2456ee08d3e513cc4266c9a", "url": "https://github.com/prestodb/presto/commit/e7b5eb567740a916c2456ee08d3e513cc4266c9a", "message": "Refactor order by and distinct spilling, will squash on merge", "committedDate": "2020-06-16T20:09:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIzNTU1NA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441235554", "bodyText": "{@link SpillableFinalOnlyGroupedAccumulator} enables spilling for {@link FinalOnlyGroupedAccumulator}", "author": "highker", "createdAt": "2020-06-17T01:52:37Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +596,165 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators", "originalCommit": "e7b5eb567740a916c2456ee08d3e513cc4266c9a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTIzNTcyMg==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441235722", "bodyText": "{@link FinalOnlyGroupedAccumulator}", "author": "highker", "createdAt": "2020-06-17T01:53:10Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/FinalOnlyGroupedAccumulator.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.GroupByIdBlock;\n+\n+/**\n+ * FinalOnlyGroupedAccumulator is an accumulator that does not support partial aggregation", "originalCommit": "e7b5eb567740a916c2456ee08d3e513cc4266c9a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI0NTMxNg==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441245316", "bodyText": "Use ObjectBigArray as well. Then we can remove rawInputsSize", "author": "highker", "createdAt": "2020-06-17T02:29:47Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +596,165 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();", "originalCommit": "e7b5eb567740a916c2456ee08d3e513cc4266c9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3NDM5Nw==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441774397", "bodyText": "Good idea.", "author": "sachdevs", "createdAt": "2020-06-17T19:11:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI0NTMxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc3Njg5OQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441776899", "bodyText": "Seems like I have to track index of insertion now instead.", "author": "sachdevs", "createdAt": "2020-06-17T19:16:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI0NTMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI0NTM4Mg==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441245382", "bodyText": "break a line between constants and variables.", "author": "highker", "createdAt": "2020-06-17T02:30:03Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +596,165 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;", "originalCommit": "e7b5eb567740a916c2456ee08d3e513cc4266c9a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI0NTUyNA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441245524", "bodyText": "requireNonNull", "author": "highker", "createdAt": "2020-06-17T02:30:33Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +596,165 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsSize;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;", "originalCommit": "e7b5eb567740a916c2456ee08d3e513cc4266c9a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI1NjEzNg==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441256136", "bodyText": "check state output instanceof ArrayBlockBuilder", "author": "highker", "createdAt": "2020-06-17T03:13:30Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +596,165 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsSize;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + rawInputsSize + (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(groupIdsBlock, page));\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            checkState(block instanceof ArrayBlock);\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+\n+            ColumnarArray columnarArray = toColumnarArray(block);\n+            ColumnarRow columnarRow = toColumnarRow(columnarArray.getElementsBlock());\n+            int newPositionCount = columnarRow.getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = columnarRow.getField(channel);\n+            }\n+            Page page = new Page(blocks);\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(squashedGroupIds, page));\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {", "originalCommit": "e7b5eb567740a916c2456ee08d3e513cc4266c9a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI1NjE1OA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441256158", "bodyText": "break a line", "author": "highker", "createdAt": "2020-06-17T03:13:37Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +596,165 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsSize;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + rawInputsSize + (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(groupIdsBlock, page));\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            checkState(block instanceof ArrayBlock);\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+\n+            ColumnarArray columnarArray = toColumnarArray(block);\n+            ColumnarRow columnarRow = toColumnarRow(columnarArray.getElementsBlock());\n+            int newPositionCount = columnarRow.getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = columnarRow.getField(channel);\n+            }\n+            Page page = new Page(blocks);\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(squashedGroupIds, page));\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {\n+            if (blockBuilders == null) {\n+                if (rawInputs == null) {\n+                    return;\n+                }", "originalCommit": "e7b5eb567740a916c2456ee08d3e513cc4266c9a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI1NjQwNQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441256405", "bodyText": "(long) cast is redundant", "author": "highker", "createdAt": "2020-06-17T03:14:56Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +596,165 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsSize;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + rawInputsSize + (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(groupIdsBlock, page));\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            checkState(block instanceof ArrayBlock);\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+\n+            ColumnarArray columnarArray = toColumnarArray(block);\n+            ColumnarRow columnarRow = toColumnarRow(columnarArray.getElementsBlock());\n+            int newPositionCount = columnarRow.getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = columnarRow.getField(channel);\n+            }\n+            Page page = new Page(blocks);\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(squashedGroupIds, page));\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {\n+            if (blockBuilders == null) {\n+                if (rawInputs == null) {\n+                    return;\n+                }\n+                blockBuilders = new ObjectBigArray<>();  // we need to spill now; let's build the hash table here\n+                for (GroupIdPage groupIdPage : rawInputs) {\n+                    Page page = groupIdPage.getPage();\n+                    GroupByIdBlock groupIdsBlock = groupIdPage.getGroupByIdBlock();\n+                    for (int position = 0; position < page.getPositionCount(); position++) {\n+                        long currentGroupId = groupIdsBlock.getGroupId(position);\n+                        blockBuilders.ensureCapacity(currentGroupId);\n+                        RowBlockBuilder rowBlockBuilder = blockBuilders.get(currentGroupId);\n+                        if (rowBlockBuilder == null) {\n+                            rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                        }\n+\n+                        BlockBuilder currentOutput = rowBlockBuilder.beginBlockEntry();\n+                        for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                            spillingTypes.get(channel).appendTo(page.getBlock(channel), position, currentOutput);\n+                        }\n+                        rowBlockBuilder.closeEntry();\n+\n+                        blockBuilders.set(currentGroupId, rowBlockBuilder);\n+                    }\n+                }\n+                rawInputs = null;\n+                rawInputsSize = 0;\n+            }\n+\n+            BlockBuilder singleArrayBlockWriter = output.beginBlockEntry();\n+            checkState(rawInputs == null && blockBuilders != null);\n+            checkState(singleArrayBlockWriter instanceof SingleArrayBlockWriter);\n+\n+            RowBlock rowBlock = (RowBlock) blockBuilders.get((long) groupId).build();", "originalCommit": "e7b5eb567740a916c2456ee08d3e513cc4266c9a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI1ODA2NQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441258065", "bodyText": "Add a comment to explain why we need to squash everything into a single cell.", "author": "highker", "createdAt": "2020-06-17T03:21:36Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +596,165 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsSize;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + rawInputsSize + (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(groupIdsBlock, page));\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            checkState(block instanceof ArrayBlock);\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+\n+            ColumnarArray columnarArray = toColumnarArray(block);\n+            ColumnarRow columnarRow = toColumnarRow(columnarArray.getElementsBlock());\n+            int newPositionCount = columnarRow.getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = columnarRow.getField(channel);\n+            }\n+            Page page = new Page(blocks);\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(squashedGroupIds, page));\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {\n+            if (blockBuilders == null) {\n+                if (rawInputs == null) {\n+                    return;\n+                }\n+                blockBuilders = new ObjectBigArray<>();  // we need to spill now; let's build the hash table here\n+                for (GroupIdPage groupIdPage : rawInputs) {\n+                    Page page = groupIdPage.getPage();\n+                    GroupByIdBlock groupIdsBlock = groupIdPage.getGroupByIdBlock();\n+                    for (int position = 0; position < page.getPositionCount(); position++) {\n+                        long currentGroupId = groupIdsBlock.getGroupId(position);\n+                        blockBuilders.ensureCapacity(currentGroupId);\n+                        RowBlockBuilder rowBlockBuilder = blockBuilders.get(currentGroupId);\n+                        if (rowBlockBuilder == null) {\n+                            rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                        }\n+\n+                        BlockBuilder currentOutput = rowBlockBuilder.beginBlockEntry();\n+                        for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                            spillingTypes.get(channel).appendTo(page.getBlock(channel), position, currentOutput);\n+                        }\n+                        rowBlockBuilder.closeEntry();\n+\n+                        blockBuilders.set(currentGroupId, rowBlockBuilder);\n+                    }\n+                }\n+                rawInputs = null;\n+                rawInputsSize = 0;\n+            }\n+\n+            BlockBuilder singleArrayBlockWriter = output.beginBlockEntry();\n+            checkState(rawInputs == null && blockBuilders != null);\n+            checkState(singleArrayBlockWriter instanceof SingleArrayBlockWriter);\n+\n+            RowBlock rowBlock = (RowBlock) blockBuilders.get((long) groupId).build();\n+            for (int i = 0; i < rowBlock.getPositionCount(); i++) {\n+                singleArrayBlockWriter.appendStructure(rowBlock.getBlock(i));", "originalCommit": "e7b5eb567740a916c2456ee08d3e513cc4266c9a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI2MjMyOA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441262328", "bodyText": "It took me a long while to understand what this part is doing. We need detailed comments to explain:\n\nColumnarArray flattens the squashed arrays; so there is no need to flatten block again.\nnewPositionCount is the unrolled position count already.\nunused is unused because we are unrolling for the same group id; this corresponds to how ColumnarArray unrolls internal block.\nColumnarRow already contains the unrolled blocks.", "author": "highker", "createdAt": "2020-06-17T03:39:46Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +596,165 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsSize;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + rawInputsSize + (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(groupIdsBlock, page));\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            checkState(block instanceof ArrayBlock);\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+\n+            ColumnarArray columnarArray = toColumnarArray(block);\n+            ColumnarRow columnarRow = toColumnarRow(columnarArray.getElementsBlock());\n+            int newPositionCount = columnarRow.getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = columnarRow.getField(channel);\n+            }", "originalCommit": "e7b5eb567740a916c2456ee08d3e513cc4266c9a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI2NjI2OA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441266268", "bodyText": "Do we know if there will be a correctness issue if an aggregationBuilder already starts to build result and we start to revoke and produce intermediate ressult?", "author": "highker", "createdAt": "2020-06-17T03:56:57Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +596,165 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsSize;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + rawInputsSize + (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(groupIdsBlock, page));\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            checkState(block instanceof ArrayBlock);\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+\n+            ColumnarArray columnarArray = toColumnarArray(block);\n+            ColumnarRow columnarRow = toColumnarRow(columnarArray.getElementsBlock());\n+            int newPositionCount = columnarRow.getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = columnarRow.getField(channel);\n+            }\n+            Page page = new Page(blocks);\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(squashedGroupIds, page));\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {\n+            if (blockBuilders == null) {\n+                if (rawInputs == null) {\n+                    return;\n+                }\n+                blockBuilders = new ObjectBigArray<>();  // we need to spill now; let's build the hash table here\n+                for (GroupIdPage groupIdPage : rawInputs) {\n+                    Page page = groupIdPage.getPage();\n+                    GroupByIdBlock groupIdsBlock = groupIdPage.getGroupByIdBlock();\n+                    for (int position = 0; position < page.getPositionCount(); position++) {\n+                        long currentGroupId = groupIdsBlock.getGroupId(position);\n+                        blockBuilders.ensureCapacity(currentGroupId);\n+                        RowBlockBuilder rowBlockBuilder = blockBuilders.get(currentGroupId);\n+                        if (rowBlockBuilder == null) {\n+                            rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                        }\n+\n+                        BlockBuilder currentOutput = rowBlockBuilder.beginBlockEntry();\n+                        for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                            spillingTypes.get(channel).appendTo(page.getBlock(channel), position, currentOutput);\n+                        }\n+                        rowBlockBuilder.closeEntry();\n+\n+                        blockBuilders.set(currentGroupId, rowBlockBuilder);\n+                    }\n+                }\n+                rawInputs = null;\n+                rawInputsSize = 0;\n+            }\n+\n+            BlockBuilder singleArrayBlockWriter = output.beginBlockEntry();\n+            checkState(rawInputs == null && blockBuilders != null);\n+            checkState(singleArrayBlockWriter instanceof SingleArrayBlockWriter);\n+\n+            RowBlock rowBlock = (RowBlock) blockBuilders.get((long) groupId).build();\n+            for (int i = 0; i < rowBlock.getPositionCount(); i++) {\n+                singleArrayBlockWriter.appendStructure(rowBlock.getBlock(i));\n+            }\n+            output.closeEntry();\n+        }\n+\n+        @Override\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n+        {\n+            // checkState(rawInputs == null && blockBuilders == null);", "originalCommit": "e7b5eb567740a916c2456ee08d3e513cc4266c9a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTc4Njg3MQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441786871", "bodyText": "Take a look at hasBuiltFinalResult in InMemoryHashAggregationBuilder - that may fix it but unsure about the implications.", "author": "sachdevs", "createdAt": "2020-06-17T19:35:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI2NjI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTI2NjMyNA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r441266324", "bodyText": "requireNonNull", "author": "highker", "createdAt": "2020-06-17T03:57:12Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +596,165 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * SpillableFinalOnlyGroupedAccumulator enables spilling for FinalOnlyGroupedAccumulators\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+        private List<GroupIdPage> rawInputs = new ArrayList<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsSize;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = delegate;\n+            this.spillingTypes = types;\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + rawInputsSize + (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(groupIdsBlock, page));\n+        }\n+\n+        @Override\n+        public void addIntermediate(GroupByIdBlock groupIdsBlock, Block block)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            checkState(block instanceof ArrayBlock);\n+            ArrayBlock arrayBlock = (ArrayBlock) block;\n+\n+            ColumnarArray columnarArray = toColumnarArray(block);\n+            ColumnarRow columnarRow = toColumnarRow(columnarArray.getElementsBlock());\n+            int newPositionCount = columnarRow.getPositionCount();\n+            long[] newGroupIds = new long[newPositionCount];\n+            boolean[] nulls = new boolean[newPositionCount];\n+            int currentRowBlockIndex = 0;\n+            for (int groupIdPosition = 0; groupIdPosition < groupIdsBlock.getPositionCount(); groupIdPosition++) {\n+                for (int unused = 0; unused < arrayBlock.getBlock(groupIdPosition).getPositionCount(); unused++) {\n+                    newGroupIds[currentRowBlockIndex] = groupIdsBlock.getGroupId(groupIdPosition);\n+                    nulls[currentRowBlockIndex] = groupIdsBlock.isNull(groupIdPosition);\n+                    currentRowBlockIndex++;\n+                }\n+            }\n+\n+            Block[] blocks = new Block[spillingTypes.size()];\n+            for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                blocks[channel] = columnarRow.getField(channel);\n+            }\n+            Page page = new Page(blocks);\n+            GroupByIdBlock squashedGroupIds = new GroupByIdBlock(groupIdsBlock.getGroupCount(), new LongArrayBlock(newPositionCount, Optional.of(nulls), newGroupIds));\n+\n+            rawInputsSize += page.getSizeInBytes();\n+            rawInputs.add(new GroupIdPage(squashedGroupIds, page));\n+        }\n+\n+        @Override\n+        public void evaluateIntermediate(int groupId, BlockBuilder output)\n+        {\n+            if (blockBuilders == null) {\n+                if (rawInputs == null) {\n+                    return;\n+                }\n+                blockBuilders = new ObjectBigArray<>();  // we need to spill now; let's build the hash table here\n+                for (GroupIdPage groupIdPage : rawInputs) {\n+                    Page page = groupIdPage.getPage();\n+                    GroupByIdBlock groupIdsBlock = groupIdPage.getGroupByIdBlock();\n+                    for (int position = 0; position < page.getPositionCount(); position++) {\n+                        long currentGroupId = groupIdsBlock.getGroupId(position);\n+                        blockBuilders.ensureCapacity(currentGroupId);\n+                        RowBlockBuilder rowBlockBuilder = blockBuilders.get(currentGroupId);\n+                        if (rowBlockBuilder == null) {\n+                            rowBlockBuilder = new RowBlockBuilder(spillingTypes, null, (int) groupIdsBlock.getGroupCount());\n+                        }\n+\n+                        BlockBuilder currentOutput = rowBlockBuilder.beginBlockEntry();\n+                        for (int channel = 0; channel < spillingTypes.size(); channel++) {\n+                            spillingTypes.get(channel).appendTo(page.getBlock(channel), position, currentOutput);\n+                        }\n+                        rowBlockBuilder.closeEntry();\n+\n+                        blockBuilders.set(currentGroupId, rowBlockBuilder);\n+                    }\n+                }\n+                rawInputs = null;\n+                rawInputsSize = 0;\n+            }\n+\n+            BlockBuilder singleArrayBlockWriter = output.beginBlockEntry();\n+            checkState(rawInputs == null && blockBuilders != null);\n+            checkState(singleArrayBlockWriter instanceof SingleArrayBlockWriter);\n+\n+            RowBlock rowBlock = (RowBlock) blockBuilders.get((long) groupId).build();\n+            for (int i = 0; i < rowBlock.getPositionCount(); i++) {\n+                singleArrayBlockWriter.appendStructure(rowBlock.getBlock(i));\n+            }\n+            output.closeEntry();\n+        }\n+\n+        @Override\n+        public void evaluateFinal(int groupId, BlockBuilder output)\n+        {\n+            // checkState(rawInputs == null && blockBuilders == null);\n+            delegate.evaluateFinal(groupId, output);\n+        }\n+\n+        @Override\n+        public void prepareFinal()\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            for (GroupIdPage groupIdPage : rawInputs) {\n+                delegate.addInput(groupIdPage.getGroupByIdBlock(), groupIdPage.getPage());\n+            }\n+\n+            // cannot set raw inputs to null because evaluateIntermediate may be called after prepareFinal()\n+            delegate.prepareFinal();\n+        }\n+\n+        private static class GroupIdPage\n+        {\n+            private final GroupByIdBlock groupByIdBlock;\n+            private final Page page;\n+\n+            public GroupIdPage(GroupByIdBlock groupByIdBlock, Page page)\n+            {\n+                this.page = page;\n+                this.groupByIdBlock = groupByIdBlock;", "originalCommit": "e7b5eb567740a916c2456ee08d3e513cc4266c9a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "14268e4192b72c787923729b4d3350348ba99b5f", "url": "https://github.com/prestodb/presto/commit/14268e4192b72c787923729b4d3350348ba99b5f", "message": "Implement ORDER BY and DISTINCT spilling for aggregation", "committedDate": "2020-06-17T21:16:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzNzc3OQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r443337779", "bodyText": "Instead of having these two new interfaces, we can make spillingEnabled a variable for AccumulatorFactoryBinder. spillingEnabled can be passed in through AccumulatorFactoryBinder::bind. In that way, we can avoid a lot of tunneling. spillingEnabled can be directly obtained from LocalExecutionPlanner", "author": "highker", "createdAt": "2020-06-22T06:19:03Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/AccumulatorFactory.java", "diffHunk": "@@ -30,4 +30,8 @@\n     boolean hasOrderBy();\n \n     boolean hasDistinct();\n+\n+    GroupedAccumulator createSpillableGroupedAccumulator();\n+\n+    GroupedAccumulator createSpillableGroupedIntermediateAccumulator();", "originalCommit": "14268e4192b72c787923729b4d3350348ba99b5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE3NzM1OA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r445177358", "bodyText": "I'm not sure if checking if spill is enabled via LocalExecutionPlanner is correct. This is because of the way that HashAggOperator is constructed via its factory: see createHashAggregationOperatorFactory in LocalExecutionPlanner. It is explicitly created with spillEnabled = false in multiple places.\nThis means that if we were to check if spill is enabled on bind it it will break this existing functionality so tunneling, while ugly, may be the only way to do this.", "author": "sachdevs", "createdAt": "2020-06-24T21:18:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzNzc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTMyMjQ2Nw==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r445322467", "bodyText": "Why is that? Isn't it created from planGroupByAggregation with spillEnabled as a variable?", "author": "highker", "createdAt": "2020-06-25T05:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzNzc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMzOTgwMw==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r443339803", "bodyText": "Add a TODO to denote that there are tricks to avoid storing the whole page in memory. For distincting case, dedup is available by doing compaction.", "author": "highker", "createdAt": "2020-06-22T06:25:05Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +582,173 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * {@link SpillableFinalOnlyGroupedAccumulator} enables spilling for {@link FinalOnlyGroupedAccumulator}\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+\n+        private ObjectBigArray<GroupIdPage> rawInputs = new ObjectBigArray<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsLength;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = requireNonNull(delegate, \"delegate FinalOnlyGroupedAccumulator is null\");\n+            this.spillingTypes = requireNonNull(types, \"types is null\");\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()\n+        {\n+            return delegate.getEstimatedSize() + (rawInputs == null ? 0 : rawInputs.sizeOf()) + (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n+        }\n+\n+        @Override\n+        public Type getFinalType()\n+        {\n+            return delegate.getFinalType();\n+        }\n+\n+        @Override\n+        public Type getIntermediateType()\n+        {\n+            return new ArrayType(RowType.anonymous(spillingTypes));\n+        }\n+\n+        @Override\n+        public void addInput(GroupByIdBlock groupIdsBlock, Page page)\n+        {\n+            checkState(rawInputs != null && blockBuilders == null);\n+            rawInputs.ensureCapacity(rawInputsLength);\n+            rawInputs.set(rawInputsLength, new GroupIdPage(groupIdsBlock, page));", "originalCommit": "14268e4192b72c787923729b4d3350348ba99b5f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM0MTMyMg==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r443341322", "bodyText": "Is this part necessary?", "author": "highker", "createdAt": "2020-06-22T06:29:45Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/builder/SpillableHashAggregationBuilder.java", "diffHunk": "@@ -155,13 +155,19 @@ private boolean hasPreviousSpillCompletedSuccessfully()\n     public ListenableFuture<?> startMemoryRevoke()\n     {\n         checkState(spillInProgress.isDone());\n+        if (hashAggregationBuilder.hasBuiltFinalResult()) {\n+            return spillInProgress;\n+        }\n         spillToDisk();\n         return spillInProgress;\n     }\n \n     @Override\n     public void finishMemoryRevoke()\n     {\n+        if (hashAggregationBuilder.hasBuiltFinalResult()) {\n+            return;\n+        }", "originalCommit": "14268e4192b72c787923729b4d3350348ba99b5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2Nzc1MQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r445167751", "bodyText": "Yeah since memory usage is updated in updateMemory() to be set to the size of the empty hash agg builder. This is not correct since we never spilt in the first place in startMemoryRevoke.", "author": "sachdevs", "createdAt": "2020-06-24T20:57:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM0MTMyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2Nzk2NQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r445167965", "bodyText": "Adding comments.", "author": "sachdevs", "createdAt": "2020-06-24T20:58:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM0MTMyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM0MzAzMA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r443343030", "bodyText": "If I understand correctly, the original logic can only happen if an operator that has never spilled and just started to build final results; however, a revoke request comes in. Am I right? If that is the case, shall we make a comment here?", "author": "highker", "createdAt": "2020-06-22T06:34:44Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/builder/SpillableHashAggregationBuilder.java", "diffHunk": "@@ -155,13 +155,19 @@ private boolean hasPreviousSpillCompletedSuccessfully()\n     public ListenableFuture<?> startMemoryRevoke()\n     {\n         checkState(spillInProgress.isDone());\n+        if (hashAggregationBuilder.hasBuiltFinalResult()) {\n+            return spillInProgress;\n+        }", "originalCommit": "14268e4192b72c787923729b4d3350348ba99b5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2NzEwNA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r445167104", "bodyText": "Yeah so essentially we are declining memory revoking in the case that the hashaggbuilder has already completed. This is only set to true when InMemoryHashAggregationBuilder.buildResult is called - NOT InMemoryHashAggregationBuilder.buildHashSortedResult. This is because after buildResult, spilling should be impossible, because it can no longer process any more input anyway.", "author": "sachdevs", "createdAt": "2020-06-24T20:56:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM0MzAzMA=="}], "type": "inlineReview"}, {"oid": "f69f15176e1bc8116bca6c788061939a4c2b0b69", "url": "https://github.com/prestodb/presto/commit/f69f15176e1bc8116bca6c788061939a4c2b0b69", "message": "Implement ORDER BY and DISTINCT spilling for aggregation", "committedDate": "2020-06-24T21:02:16Z", "type": "forcePushed"}, {"oid": "0086104d5addf148d954c2960f49d0d9785b022b", "url": "https://github.com/prestodb/presto/commit/0086104d5addf148d954c2960f49d0d9785b022b", "message": "Implement ORDER BY and DISTINCT spilling for aggregation", "committedDate": "2020-06-24T21:22:15Z", "type": "forcePushed"}, {"oid": "8f9f6ea8256674083ea4ad1d85b7ec295206e6ca", "url": "https://github.com/prestodb/presto/commit/8f9f6ea8256674083ea4ad1d85b7ec295206e6ca", "message": "Implement ORDER BY and DISTINCT spilling for aggregation", "committedDate": "2020-06-30T18:05:56Z", "type": "forcePushed"}, {"oid": "58dddc4e837b75169f9c5be5f1c01780288017ea", "url": "https://github.com/prestodb/presto/commit/58dddc4e837b75169f9c5be5f1c01780288017ea", "message": "Implement ORDER BY and DISTINCT spilling for aggregation", "committedDate": "2020-06-30T23:28:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4MzUyMA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448083520", "bodyText": "add checkState(accumulator instance of FinalOnlyGroupedAccumulator)", "author": "highker", "createdAt": "2020-07-01T02:39:12Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -191,16 +228,22 @@ public GroupedAccumulator createGroupedIntermediateAccumulator()\n         }\n     }\n \n-    @Override\n-    public boolean hasOrderBy()\n+    private GroupedAccumulator createSpillableGroupedAccumulator()\n     {\n-        return !orderByChannels.isEmpty();\n+        GroupedAccumulator accumulator = createDefaultGroupedAccumulator();\n+        if (!hasDistinct() && !hasOrderBy()) {\n+            return accumulator;\n+        }\n+", "originalCommit": "58dddc4e837b75169f9c5be5f1c01780288017ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4NDg0OA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448084848", "bodyText": "For spillEnabled  == false, both returns createDefaultGroupedAccumulator()? That doesn't look right? Do we have unit tests to verify this?", "author": "highker", "createdAt": "2020-07-01T02:44:47Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -151,10 +166,33 @@ public Accumulator createIntermediateAccumulator()\n \n     @Override\n     public GroupedAccumulator createGroupedAccumulator()\n+    {\n+        return spillEnabled ? createSpillableGroupedAccumulator() : createDefaultGroupedAccumulator();\n+    }\n+\n+    @Override\n+    public GroupedAccumulator createGroupedIntermediateAccumulator()\n+    {\n+        return spillEnabled ? createSpillableGroupedIntermediateAccumulator() : createDefaultGroupedAccumulator();", "originalCommit": "58dddc4e837b75169f9c5be5f1c01780288017ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU2MzU4OQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448563589", "bodyText": "This is a copy paste bug from my last change.", "author": "sachdevs", "createdAt": "2020-07-01T19:10:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4NDg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4NTU1OQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448085559", "bodyText": "Is this right? the function is to create IntermediateAccumulator but here it delegates to GroupedAccumulator and then use createDefaultGroupedAccumulator instead of createDefaultGroupedIntermediateAccumulator?", "author": "highker", "createdAt": "2020-07-01T02:47:30Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -191,16 +228,22 @@ public GroupedAccumulator createGroupedIntermediateAccumulator()\n         }\n     }\n \n-    @Override\n-    public boolean hasOrderBy()\n+    private GroupedAccumulator createSpillableGroupedAccumulator()\n     {\n-        return !orderByChannels.isEmpty();\n+        GroupedAccumulator accumulator = createDefaultGroupedAccumulator();\n+        if (!hasDistinct() && !hasOrderBy()) {\n+            return accumulator;\n+        }\n+\n+        return new SpillableFinalOnlyGroupedAccumulator(sourceTypes, (FinalOnlyGroupedAccumulator) accumulator);\n     }\n \n-    @Override\n-    public boolean hasDistinct()\n+    private GroupedAccumulator createSpillableGroupedIntermediateAccumulator()\n     {\n-        return distinct;\n+        if (!hasOrderBy() && !hasDistinct()) {\n+            return createDefaultGroupedIntermediateAccumulator();\n+        }\n+        return createSpillableGroupedAccumulator();", "originalCommit": "58dddc4e837b75169f9c5be5f1c01780288017ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU2NzIwOQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448567209", "bodyText": "Yes since we do the same logic in either case since we do not care about the underlying accumulator working on intermediate values in our FinalOnlyGroupedAccumulator/SpillableFinalOnlyGroupedAccumulator delegate. If I was to separate these functions the resulting logic should be the same. It originally was separate but I noticed it could be simplified.", "author": "sachdevs", "createdAt": "2020-07-01T19:17:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4NTU1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4NjA4MA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448086080", "bodyText": "\"delegate is null\");", "author": "highker", "createdAt": "2020-07-01T02:49:45Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +593,174 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * {@link SpillableFinalOnlyGroupedAccumulator} enables spilling for {@link FinalOnlyGroupedAccumulator}\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+\n+        private ObjectBigArray<GroupIdPage> rawInputs = new ObjectBigArray<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsLength;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = requireNonNull(delegate, \"delegate FinalOnlyGroupedAccumulator is null\");", "originalCommit": "58dddc4e837b75169f9c5be5f1c01780288017ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4NjkyNg==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448086926", "bodyText": "What are these changes?", "author": "highker", "createdAt": "2020-07-01T02:53:28Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -2070,7 +2070,7 @@ private PhysicalOperation createLookupJoin(JoinNode node,\n             OptionalInt buildHashChannel = buildHashVariable.map(variableChannelGetter(buildSource))\n                     .map(OptionalInt::of).orElse(OptionalInt.empty());\n \n-            boolean spillEnabled = isSpillEnabled(context.getSession());\n+            boolean spillEnabled = false; //isSpillEnabled(context.getSession());", "originalCommit": "58dddc4e837b75169f9c5be5f1c01780288017ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODU2NzU3Mw==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448567573", "bodyText": "Carried in a few changes from my deployment branch, oops", "author": "sachdevs", "createdAt": "2020-07-01T19:18:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4NjkyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODA4Njk1MA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448086950", "bodyText": "Same", "author": "highker", "createdAt": "2020-07-01T02:53:36Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -2203,9 +2203,6 @@ private OperatorFactory createLookupJoin(\n         private OptionalInt getJoinOperatorsCountForSpill(LocalExecutionPlanContext context, Session session)\n         {\n             OptionalInt driverInstanceCount = context.getDriverInstanceCount();\n-            if (isSpillEnabled(session)) {\n-                checkState(driverInstanceCount.isPresent(), \"A fixed distribution is required for JOIN when spilling is enabled\");\n-            }", "originalCommit": "58dddc4e837b75169f9c5be5f1c01780288017ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "25d84bd505bb105516a7ecedfa65657b8da0bb6a", "url": "https://github.com/prestodb/presto/commit/25d84bd505bb105516a7ecedfa65657b8da0bb6a", "message": "Implement ORDER BY and DISTINCT spilling for aggregation", "committedDate": "2020-07-01T19:18:21Z", "type": "forcePushed"}, {"oid": "610733483ee27e956da837ce9b92b05d304030d7", "url": "https://github.com/prestodb/presto/commit/610733483ee27e956da837ce9b92b05d304030d7", "message": "Implement ORDER BY and DISTINCT spilling for aggregation", "committedDate": "2020-07-01T19:20:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc2MDMzMg==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448760332", "bodyText": "This is the format I would propose\n    @Override\n    public GroupedAccumulator createGroupedAccumulator()\n    {\n        GroupedAccumulator accumulator = createDefaultGroupedAccumulator();\n\n        if (!spillEnabled || (!hasDistinct() && !hasOrderBy())) {\n            return accumulator;\n        }\n\n        checkState(accumulator instanceof FinalOnlyGroupedAccumulator, \"accumulator must contain distinct or order by\");\n        return new SpillableFinalOnlyGroupedAccumulator(sourceTypes, (FinalOnlyGroupedAccumulator) accumulator);\n    }", "author": "highker", "createdAt": "2020-07-02T05:42:27Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -151,10 +166,33 @@ public Accumulator createIntermediateAccumulator()\n \n     @Override\n     public GroupedAccumulator createGroupedAccumulator()\n+    {\n+        return spillEnabled ? createSpillableGroupedAccumulator() : createDefaultGroupedAccumulator();", "originalCommit": "610733483ee27e956da837ce9b92b05d304030d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc2MDQ5OQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448760499", "bodyText": "createGenericGroupedAccumulator", "author": "highker", "createdAt": "2020-07-02T05:43:07Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -151,10 +166,33 @@ public Accumulator createIntermediateAccumulator()\n \n     @Override\n     public GroupedAccumulator createGroupedAccumulator()\n+    {\n+        return spillEnabled ? createSpillableGroupedAccumulator() : createDefaultGroupedAccumulator();\n+    }\n+\n+    @Override\n+    public GroupedAccumulator createGroupedIntermediateAccumulator()\n+    {\n+        return spillEnabled ? createSpillableGroupedIntermediateAccumulator() : createDefaultGroupedIntermediateAccumulator();\n+    }\n+\n+    @Override\n+    public boolean hasOrderBy()\n+    {\n+        return !orderByChannels.isEmpty();\n+    }\n+\n+    @Override\n+    public boolean hasDistinct()\n+    {\n+        return distinct;\n+    }\n+\n+    private GroupedAccumulator createDefaultGroupedAccumulator()", "originalCommit": "610733483ee27e956da837ce9b92b05d304030d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc2MTEzMQ==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448761131", "bodyText": "Actually, is it even possible we need createSpillableGroupedIntermediateAccumulator()? Can we check if the following is good enough?\n    @Override\n    public GroupedAccumulator createGroupedIntermediateAccumulator()\n    {\n        checkState(!hasDistinct() || !hasOrderBy(), \"distinct or order by cannot have partial aggregation\");\n        \n        try {\n            return groupedAccumulatorConstructor.newInstance(stateDescriptors, ImmutableList.of(), Optional.empty(), lambdaProviders);\n        }\n        catch (InstantiationException | IllegalAccessException | InvocationTargetException e) {\n            throw new RuntimeException(e);\n        }\n    }", "author": "highker", "createdAt": "2020-07-02T05:45:29Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -151,10 +166,33 @@ public Accumulator createIntermediateAccumulator()\n \n     @Override\n     public GroupedAccumulator createGroupedAccumulator()\n+    {\n+        return spillEnabled ? createSpillableGroupedAccumulator() : createDefaultGroupedAccumulator();\n+    }\n+\n+    @Override\n+    public GroupedAccumulator createGroupedIntermediateAccumulator()\n+    {\n+        return spillEnabled ? createSpillableGroupedIntermediateAccumulator() : createDefaultGroupedIntermediateAccumulator();", "originalCommit": "610733483ee27e956da837ce9b92b05d304030d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwMjg4Mw==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r449202883", "bodyText": "We do need this since before:\n\n\ncreateGroupedIntermediateAccumulator used to be never called (in case of ORDER BY or DISTINCT) since order by and distinct did not have support for intermediate results. Hence, when spill is enabled, we use createGroupedIntermediateAccumulator to recreate the intermediate version of the accumulator with the spillable wrapper when unspilling and creating intermediate accumulators.\n\n\ncheckState(!hasDistinct() || !hasOrderBy()) not sure what this does exactly in this context since having distinct AND orderby shouldnt be a state failure. createGroupedIntermediateAccumulator can be called with hasDistinct/hasOrderBy set to true.\n\n\nreturn groupedAccumulatorConstructor.newInstance would be a bug since this references the underlying accumulator (NOT order by or distinct, but the accumulator inside of order by or distinct). This means that during intermediate accumulation we would get non-distinct  non-ordered values.\n\n\nI actually tried writing this code without this section in a previous iteration but I realized we need the spillable wrapper in the intermediate case.", "author": "sachdevs", "createdAt": "2020-07-02T18:39:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc2MTEzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc2MTg0MA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448761840", "bodyText": "We don't need this helper", "author": "highker", "createdAt": "2020-07-02T05:48:10Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -191,16 +228,23 @@ public GroupedAccumulator createGroupedIntermediateAccumulator()\n         }\n     }\n \n-    @Override\n-    public boolean hasOrderBy()\n+    private GroupedAccumulator createSpillableGroupedAccumulator()", "originalCommit": "610733483ee27e956da837ce9b92b05d304030d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc2MTg3Nw==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448761877", "bodyText": "same", "author": "highker", "createdAt": "2020-07-02T05:48:17Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -191,16 +228,23 @@ public GroupedAccumulator createGroupedIntermediateAccumulator()\n         }\n     }\n \n-    @Override\n-    public boolean hasOrderBy()\n+    private GroupedAccumulator createSpillableGroupedAccumulator()\n     {\n-        return !orderByChannels.isEmpty();\n+        GroupedAccumulator accumulator = createDefaultGroupedAccumulator();\n+        if (!hasDistinct() && !hasOrderBy()) {\n+            return accumulator;\n+        }\n+\n+        checkState(accumulator instanceof FinalOnlyGroupedAccumulator);\n+        return new SpillableFinalOnlyGroupedAccumulator(sourceTypes, (FinalOnlyGroupedAccumulator) accumulator);\n     }\n \n-    @Override\n-    public boolean hasDistinct()\n+    private GroupedAccumulator createSpillableGroupedIntermediateAccumulator()", "originalCommit": "610733483ee27e956da837ce9b92b05d304030d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc2MjUxNw==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448762517", "bodyText": "Add\nprivate static final int INSTANCE_SIZE = ClassLayout.parseClass(SpillableFinalOnlyGroupedAccumulator.class).instanceSize();", "author": "highker", "createdAt": "2020-07-02T05:50:30Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +594,174 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * {@link SpillableFinalOnlyGroupedAccumulator} enables spilling for {@link FinalOnlyGroupedAccumulator}\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {", "originalCommit": "610733483ee27e956da837ce9b92b05d304030d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODc2MzA5NA==", "url": "https://github.com/prestodb/presto/pull/14527#discussion_r448763094", "bodyText": "@Override\n        public long getEstimatedSize()\n        {\n            return INSTANCE_SIZE +\n                    delegate.getEstimatedSize() +\n                    (rawInputs == null ? 0 : rawInputs.sizeOf()) +\n                    (blockBuilders == null ? 0 : blockBuilders.sizeOf());\n        }", "author": "highker", "createdAt": "2020-07-02T05:52:22Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/GenericAccumulatorFactory.java", "diffHunk": "@@ -586,4 +594,174 @@ public void prepareFinal()\n             });\n         }\n     }\n+\n+    /**\n+     * {@link SpillableFinalOnlyGroupedAccumulator} enables spilling for {@link FinalOnlyGroupedAccumulator}\n+     */\n+    private static class SpillableFinalOnlyGroupedAccumulator\n+            implements GroupedAccumulator\n+    {\n+        private final FinalOnlyGroupedAccumulator delegate;\n+        private final List<Type> spillingTypes;\n+\n+        private ObjectBigArray<GroupIdPage> rawInputs = new ObjectBigArray<>();\n+        private ObjectBigArray<RowBlockBuilder> blockBuilders;\n+        private long rawInputsLength;\n+\n+        public SpillableFinalOnlyGroupedAccumulator(List<Type> types, FinalOnlyGroupedAccumulator delegate)\n+        {\n+            this.delegate = requireNonNull(delegate, \"delegate is null\");\n+            this.spillingTypes = requireNonNull(types, \"types is null\");\n+        }\n+\n+        @Override\n+        public long getEstimatedSize()", "originalCommit": "610733483ee27e956da837ce9b92b05d304030d7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b53600fe25c55e9b1ffba74a4fe40542193ada8b", "url": "https://github.com/prestodb/presto/commit/b53600fe25c55e9b1ffba74a4fe40542193ada8b", "message": "Implement ORDER BY and DISTINCT spilling for aggregation", "committedDate": "2020-07-02T18:48:58Z", "type": "commit"}, {"oid": "b53600fe25c55e9b1ffba74a4fe40542193ada8b", "url": "https://github.com/prestodb/presto/commit/b53600fe25c55e9b1ffba74a4fe40542193ada8b", "message": "Implement ORDER BY and DISTINCT spilling for aggregation", "committedDate": "2020-07-02T18:48:58Z", "type": "forcePushed"}]}