{"pr_number": 14153, "pr_title": "Update Verifier documentation", "pr_createdAt": "2020-02-25T01:05:01Z", "pr_url": "https://github.com/prestodb/presto/pull/14153", "timeline": [{"oid": "35f5555b999ef5bfc264fc5b7d1079547481ea0c", "url": "https://github.com/prestodb/presto/commit/35f5555b999ef5bfc264fc5b7d1079547481ea0c", "message": "Update Verifier documentation", "committedDate": "2020-02-26T22:46:04Z", "type": "forcePushed"}, {"oid": "a3b19746da1f67d4e17dfd72346364b1ef0c3f7d", "url": "https://github.com/prestodb/presto/commit/a3b19746da1f67d4e17dfd72346364b1ef0c3f7d", "message": "Update Verifier documentation", "committedDate": "2020-02-26T23:40:11Z", "type": "forcePushed"}, {"oid": "4f978207f32b5b37174df5fa60e61d2510821a67", "url": "https://github.com/prestodb/presto/commit/4f978207f32b5b37174df5fa60e61d2510821a67", "message": "Update Verifier documentation", "committedDate": "2020-02-26T23:44:59Z", "type": "forcePushed"}, {"oid": "83ab83211b6b58f14d91038ecd59c9c80d9fc3aa", "url": "https://github.com/prestodb/presto/commit/83ab83211b6b58f14d91038ecd59c9c80d9fc3aa", "message": "Update Verifier documentation", "committedDate": "2020-02-27T00:49:14Z", "type": "forcePushed"}, {"oid": "82a92fa026e577b6af8b53f53453de501dd8557a", "url": "https://github.com/prestodb/presto/commit/82a92fa026e577b6af8b53f53453de501dd8557a", "message": "Update Verifier documentation", "committedDate": "2020-02-27T01:19:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2NTk3NQ==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r384865975", "bodyText": "typo: name -> names", "author": "mbasmanova", "createdAt": "2020-02-27T01:29:19Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,257 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.\n+\n+* **Importing Source Queries**\n+   * Read the list of source queries (query pairs with configuration) from the MySQL table.\n+\n+* **Query Pre-processing and Filtering**\n+   * Apply overrides to the catalog, schema, username, and password of each query.\n+   * Filter queries according to whitelist and blacklist. Whitelist is applied before blacklist.\n+   * Filter out queries with invalid syntax.\n+   * Filter out queries not supported for validation. ``Select``, ``Insert``, and ``CreateTableAsSelect`` are supported.\n+\n+* **Query rewriting**\n+    * Rewrite queries before execution to ensure that production data is not modified.\n+    * Rewrite ``Select`` queries to ``CreateTableAsSelect``\n+       * Column names are determined by running the ``Select`` query with ``LIMIT 0``.\n+       * Artificial name are used for unnamed columns.", "originalCommit": "82a92fa026e577b6af8b53f53453de501dd8557a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2NjA1OA==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r384866058", "bodyText": "typo: a Insert  -> an Insert", "author": "mbasmanova", "createdAt": "2020-02-27T01:29:39Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,257 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.\n+\n+* **Importing Source Queries**\n+   * Read the list of source queries (query pairs with configuration) from the MySQL table.\n+\n+* **Query Pre-processing and Filtering**\n+   * Apply overrides to the catalog, schema, username, and password of each query.\n+   * Filter queries according to whitelist and blacklist. Whitelist is applied before blacklist.\n+   * Filter out queries with invalid syntax.\n+   * Filter out queries not supported for validation. ``Select``, ``Insert``, and ``CreateTableAsSelect`` are supported.\n+\n+* **Query rewriting**\n+    * Rewrite queries before execution to ensure that production data is not modified.\n+    * Rewrite ``Select`` queries to ``CreateTableAsSelect``\n+       * Column names are determined by running the ``Select`` query with ``LIMIT 0``.\n+       * Artificial name are used for unnamed columns.\n+    * Rewrite ``Insert`` and ``CreateTableAsSelect`` queries to have their table names replaced.\n+       * Construct a setup query to create the table necessary for a ``Insert`` query.", "originalCommit": "82a92fa026e577b6af8b53f53453de501dd8557a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2NjE5OA==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r384866198", "bodyText": "typo: \"the retries ones\" -> \"the retries\"", "author": "mbasmanova", "createdAt": "2020-02-27T01:30:18Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,257 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.\n+\n+* **Importing Source Queries**\n+   * Read the list of source queries (query pairs with configuration) from the MySQL table.\n+\n+* **Query Pre-processing and Filtering**\n+   * Apply overrides to the catalog, schema, username, and password of each query.\n+   * Filter queries according to whitelist and blacklist. Whitelist is applied before blacklist.\n+   * Filter out queries with invalid syntax.\n+   * Filter out queries not supported for validation. ``Select``, ``Insert``, and ``CreateTableAsSelect`` are supported.\n+\n+* **Query rewriting**\n+    * Rewrite queries before execution to ensure that production data is not modified.\n+    * Rewrite ``Select`` queries to ``CreateTableAsSelect``\n+       * Column names are determined by running the ``Select`` query with ``LIMIT 0``.\n+       * Artificial name are used for unnamed columns.\n+    * Rewrite ``Insert`` and ``CreateTableAsSelect`` queries to have their table names replaced.\n+       * Construct a setup query to create the table necessary for a ``Insert`` query.\n+\n+* **Query Execution**\n+    * Conceptually, Verifier is configured with a control cluster and a test cluster. However, they\n+      may be pointed to the same Presto cluster for certain tests.\n+    * For each source query, execute the following queries in order.\n+        * Control setup queries\n+        * Control query\n+        * Test setup queries\n+        * Test query\n+        * Control and Test teardown\n+    * Queries are subject to timeouts and retries.\n+        * Cluster connection failures and transient Presto failures are retried.\n+        * Query retries may conceal reliability issues. All occurred Presto query failures, including the retries ones, are recorded.", "originalCommit": "82a92fa026e577b6af8b53f53453de501dd8557a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2NjYwMg==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r384866602", "bodyText": "typo: \"for automatic resolving query failures\" -> \"for auto-resolving of query failures\"", "author": "mbasmanova", "createdAt": "2020-02-27T01:31:28Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,257 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.\n+\n+* **Importing Source Queries**\n+   * Read the list of source queries (query pairs with configuration) from the MySQL table.\n+\n+* **Query Pre-processing and Filtering**\n+   * Apply overrides to the catalog, schema, username, and password of each query.\n+   * Filter queries according to whitelist and blacklist. Whitelist is applied before blacklist.\n+   * Filter out queries with invalid syntax.\n+   * Filter out queries not supported for validation. ``Select``, ``Insert``, and ``CreateTableAsSelect`` are supported.\n+\n+* **Query rewriting**\n+    * Rewrite queries before execution to ensure that production data is not modified.\n+    * Rewrite ``Select`` queries to ``CreateTableAsSelect``\n+       * Column names are determined by running the ``Select`` query with ``LIMIT 0``.\n+       * Artificial name are used for unnamed columns.\n+    * Rewrite ``Insert`` and ``CreateTableAsSelect`` queries to have their table names replaced.\n+       * Construct a setup query to create the table necessary for a ``Insert`` query.\n+\n+* **Query Execution**\n+    * Conceptually, Verifier is configured with a control cluster and a test cluster. However, they\n+      may be pointed to the same Presto cluster for certain tests.\n+    * For each source query, execute the following queries in order.\n+        * Control setup queries\n+        * Control query\n+        * Test setup queries\n+        * Test query\n+        * Control and Test teardown\n+    * Queries are subject to timeouts and retries.\n+        * Cluster connection failures and transient Presto failures are retried.\n+        * Query retries may conceal reliability issues. All occurred Presto query failures, including the retries ones, are recorded.\n+    * Certain query failures are automatically submitted for re-validation, such as partition dropped or table dropped during query.\n+    * See `Failure Resolution`_ for automatic resolving query failures.", "originalCommit": "82a92fa026e577b6af8b53f53453de501dd8557a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2Njg0OQ==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r384866849", "bodyText": "typo: \"one or more columns maybe generated \" -> \"one or more columns are generated\"", "author": "mbasmanova", "createdAt": "2020-02-27T01:32:22Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,257 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.\n+\n+* **Importing Source Queries**\n+   * Read the list of source queries (query pairs with configuration) from the MySQL table.\n+\n+* **Query Pre-processing and Filtering**\n+   * Apply overrides to the catalog, schema, username, and password of each query.\n+   * Filter queries according to whitelist and blacklist. Whitelist is applied before blacklist.\n+   * Filter out queries with invalid syntax.\n+   * Filter out queries not supported for validation. ``Select``, ``Insert``, and ``CreateTableAsSelect`` are supported.\n+\n+* **Query rewriting**\n+    * Rewrite queries before execution to ensure that production data is not modified.\n+    * Rewrite ``Select`` queries to ``CreateTableAsSelect``\n+       * Column names are determined by running the ``Select`` query with ``LIMIT 0``.\n+       * Artificial name are used for unnamed columns.\n+    * Rewrite ``Insert`` and ``CreateTableAsSelect`` queries to have their table names replaced.\n+       * Construct a setup query to create the table necessary for a ``Insert`` query.\n+\n+* **Query Execution**\n+    * Conceptually, Verifier is configured with a control cluster and a test cluster. However, they\n+      may be pointed to the same Presto cluster for certain tests.\n+    * For each source query, execute the following queries in order.\n+        * Control setup queries\n+        * Control query\n+        * Test setup queries\n+        * Test query\n+        * Control and Test teardown\n+    * Queries are subject to timeouts and retries.\n+        * Cluster connection failures and transient Presto failures are retried.\n+        * Query retries may conceal reliability issues. All occurred Presto query failures, including the retries ones, are recorded.\n+    * Certain query failures are automatically submitted for re-validation, such as partition dropped or table dropped during query.\n+    * See `Failure Resolution`_ for automatic resolving query failures.\n+\n+* **Results Comparison**\n+    * For ``Select``, ``Insert``, and ``CreateTableAsSelect`` queries, results are written into temporary tables.\n+    * Construct and run the checksum queries for both control and test.\n+    * Verify table schema and row count are the same for the control and the test result table.\n+    * Verify checksums are matching for each column. See `Column Checksums`_ for special handling of different column types.\n+    * See `Determinism`_ for handling of non-deterministic queries.\n+\n+* **Emitting Results**\n+    * Verification results can be exported as ``JSON``, or human readable text.\n+\n+Column Checksums\n+----------------\n+For each column in the control/test query, one or more columns maybe generated in the checksum", "originalCommit": "82a92fa026e577b6af8b53f53453de501dd8557a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2NzA5NA==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r384867094", "bodyText": "typo: kep -> key", "author": "mbasmanova", "createdAt": "2020-02-27T01:33:16Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,257 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.\n+\n+* **Importing Source Queries**\n+   * Read the list of source queries (query pairs with configuration) from the MySQL table.\n+\n+* **Query Pre-processing and Filtering**\n+   * Apply overrides to the catalog, schema, username, and password of each query.\n+   * Filter queries according to whitelist and blacklist. Whitelist is applied before blacklist.\n+   * Filter out queries with invalid syntax.\n+   * Filter out queries not supported for validation. ``Select``, ``Insert``, and ``CreateTableAsSelect`` are supported.\n+\n+* **Query rewriting**\n+    * Rewrite queries before execution to ensure that production data is not modified.\n+    * Rewrite ``Select`` queries to ``CreateTableAsSelect``\n+       * Column names are determined by running the ``Select`` query with ``LIMIT 0``.\n+       * Artificial name are used for unnamed columns.\n+    * Rewrite ``Insert`` and ``CreateTableAsSelect`` queries to have their table names replaced.\n+       * Construct a setup query to create the table necessary for a ``Insert`` query.\n+\n+* **Query Execution**\n+    * Conceptually, Verifier is configured with a control cluster and a test cluster. However, they\n+      may be pointed to the same Presto cluster for certain tests.\n+    * For each source query, execute the following queries in order.\n+        * Control setup queries\n+        * Control query\n+        * Test setup queries\n+        * Test query\n+        * Control and Test teardown\n+    * Queries are subject to timeouts and retries.\n+        * Cluster connection failures and transient Presto failures are retried.\n+        * Query retries may conceal reliability issues. All occurred Presto query failures, including the retries ones, are recorded.\n+    * Certain query failures are automatically submitted for re-validation, such as partition dropped or table dropped during query.\n+    * See `Failure Resolution`_ for automatic resolving query failures.\n+\n+* **Results Comparison**\n+    * For ``Select``, ``Insert``, and ``CreateTableAsSelect`` queries, results are written into temporary tables.\n+    * Construct and run the checksum queries for both control and test.\n+    * Verify table schema and row count are the same for the control and the test result table.\n+    * Verify checksums are matching for each column. See `Column Checksums`_ for special handling of different column types.\n+    * See `Determinism`_ for handling of non-deterministic queries.\n+\n+* **Emitting Results**\n+    * Verification results can be exported as ``JSON``, or human readable text.\n+\n+Column Checksums\n+----------------\n+For each column in the control/test query, one or more columns maybe generated in the checksum\n+queries.\n+\n+* **Floating Point Columns**\n+    * For ``DOUBLE`` and ``REAL`` columns, 4 columns are generated for verification:\n+       * Sum of the finite values of the column\n+       * ``NAN`` count of the column\n+       * Positive infinity count of the column\n+       * Negative infinity count of the column\n+    * Check if ``NAN`` count, positive and negative infinity count matches.\n+    * Check the nullity of control sum and test sum.\n+    * If either control mean or test mean very close 0, check if both are close to 0.\n+    * Check the relative error between control sum and test sum.\n+* **Array Columns**\n+    * 2 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Array checksum\n+    * For an array column ``arr`` of type ``array(E)``:\n+       * If ``E`` is not orderable, array checksum is ``checksum(arr)``.\n+       * If ``E`` is orderable, array checksum ``coalesce(checksum(try(array_sort(arr))), checksum(arr))``.\n+* **Map Columns**\n+    * 4 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Checksum of the map\n+       * Array checksum of the kep set", "originalCommit": "82a92fa026e577b6af8b53f53453de501dd8557a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2NzE5OQ==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r384867199", "bodyText": "typo: \"recursively, as according\" -> \"recursively according\"", "author": "mbasmanova", "createdAt": "2020-02-27T01:33:41Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,257 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.\n+\n+* **Importing Source Queries**\n+   * Read the list of source queries (query pairs with configuration) from the MySQL table.\n+\n+* **Query Pre-processing and Filtering**\n+   * Apply overrides to the catalog, schema, username, and password of each query.\n+   * Filter queries according to whitelist and blacklist. Whitelist is applied before blacklist.\n+   * Filter out queries with invalid syntax.\n+   * Filter out queries not supported for validation. ``Select``, ``Insert``, and ``CreateTableAsSelect`` are supported.\n+\n+* **Query rewriting**\n+    * Rewrite queries before execution to ensure that production data is not modified.\n+    * Rewrite ``Select`` queries to ``CreateTableAsSelect``\n+       * Column names are determined by running the ``Select`` query with ``LIMIT 0``.\n+       * Artificial name are used for unnamed columns.\n+    * Rewrite ``Insert`` and ``CreateTableAsSelect`` queries to have their table names replaced.\n+       * Construct a setup query to create the table necessary for a ``Insert`` query.\n+\n+* **Query Execution**\n+    * Conceptually, Verifier is configured with a control cluster and a test cluster. However, they\n+      may be pointed to the same Presto cluster for certain tests.\n+    * For each source query, execute the following queries in order.\n+        * Control setup queries\n+        * Control query\n+        * Test setup queries\n+        * Test query\n+        * Control and Test teardown\n+    * Queries are subject to timeouts and retries.\n+        * Cluster connection failures and transient Presto failures are retried.\n+        * Query retries may conceal reliability issues. All occurred Presto query failures, including the retries ones, are recorded.\n+    * Certain query failures are automatically submitted for re-validation, such as partition dropped or table dropped during query.\n+    * See `Failure Resolution`_ for automatic resolving query failures.\n+\n+* **Results Comparison**\n+    * For ``Select``, ``Insert``, and ``CreateTableAsSelect`` queries, results are written into temporary tables.\n+    * Construct and run the checksum queries for both control and test.\n+    * Verify table schema and row count are the same for the control and the test result table.\n+    * Verify checksums are matching for each column. See `Column Checksums`_ for special handling of different column types.\n+    * See `Determinism`_ for handling of non-deterministic queries.\n+\n+* **Emitting Results**\n+    * Verification results can be exported as ``JSON``, or human readable text.\n+\n+Column Checksums\n+----------------\n+For each column in the control/test query, one or more columns maybe generated in the checksum\n+queries.\n+\n+* **Floating Point Columns**\n+    * For ``DOUBLE`` and ``REAL`` columns, 4 columns are generated for verification:\n+       * Sum of the finite values of the column\n+       * ``NAN`` count of the column\n+       * Positive infinity count of the column\n+       * Negative infinity count of the column\n+    * Check if ``NAN`` count, positive and negative infinity count matches.\n+    * Check the nullity of control sum and test sum.\n+    * If either control mean or test mean very close 0, check if both are close to 0.\n+    * Check the relative error between control sum and test sum.\n+* **Array Columns**\n+    * 2 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Array checksum\n+    * For an array column ``arr`` of type ``array(E)``:\n+       * If ``E`` is not orderable, array checksum is ``checksum(arr)``.\n+       * If ``E`` is orderable, array checksum ``coalesce(checksum(try(array_sort(arr))), checksum(arr))``.\n+* **Map Columns**\n+    * 4 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Checksum of the map\n+       * Array checksum of the kep set\n+       * Array checksum of the value set\n+* **Row Columns**\n+    * Checksum row fields recursively, as according to the type of the fields.", "originalCommit": "82a92fa026e577b6af8b53f53453de501dd8557a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2NzM2NA==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r384867364", "bodyText": "nit: Would you mention the configuration property to use?", "author": "mbasmanova", "createdAt": "2020-02-27T01:34:27Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,257 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.\n+\n+* **Importing Source Queries**\n+   * Read the list of source queries (query pairs with configuration) from the MySQL table.\n+\n+* **Query Pre-processing and Filtering**\n+   * Apply overrides to the catalog, schema, username, and password of each query.\n+   * Filter queries according to whitelist and blacklist. Whitelist is applied before blacklist.\n+   * Filter out queries with invalid syntax.\n+   * Filter out queries not supported for validation. ``Select``, ``Insert``, and ``CreateTableAsSelect`` are supported.\n+\n+* **Query rewriting**\n+    * Rewrite queries before execution to ensure that production data is not modified.\n+    * Rewrite ``Select`` queries to ``CreateTableAsSelect``\n+       * Column names are determined by running the ``Select`` query with ``LIMIT 0``.\n+       * Artificial name are used for unnamed columns.\n+    * Rewrite ``Insert`` and ``CreateTableAsSelect`` queries to have their table names replaced.\n+       * Construct a setup query to create the table necessary for a ``Insert`` query.\n+\n+* **Query Execution**\n+    * Conceptually, Verifier is configured with a control cluster and a test cluster. However, they\n+      may be pointed to the same Presto cluster for certain tests.\n+    * For each source query, execute the following queries in order.\n+        * Control setup queries\n+        * Control query\n+        * Test setup queries\n+        * Test query\n+        * Control and Test teardown\n+    * Queries are subject to timeouts and retries.\n+        * Cluster connection failures and transient Presto failures are retried.\n+        * Query retries may conceal reliability issues. All occurred Presto query failures, including the retries ones, are recorded.\n+    * Certain query failures are automatically submitted for re-validation, such as partition dropped or table dropped during query.\n+    * See `Failure Resolution`_ for automatic resolving query failures.\n+\n+* **Results Comparison**\n+    * For ``Select``, ``Insert``, and ``CreateTableAsSelect`` queries, results are written into temporary tables.\n+    * Construct and run the checksum queries for both control and test.\n+    * Verify table schema and row count are the same for the control and the test result table.\n+    * Verify checksums are matching for each column. See `Column Checksums`_ for special handling of different column types.\n+    * See `Determinism`_ for handling of non-deterministic queries.\n+\n+* **Emitting Results**\n+    * Verification results can be exported as ``JSON``, or human readable text.\n+\n+Column Checksums\n+----------------\n+For each column in the control/test query, one or more columns maybe generated in the checksum\n+queries.\n+\n+* **Floating Point Columns**\n+    * For ``DOUBLE`` and ``REAL`` columns, 4 columns are generated for verification:\n+       * Sum of the finite values of the column\n+       * ``NAN`` count of the column\n+       * Positive infinity count of the column\n+       * Negative infinity count of the column\n+    * Check if ``NAN`` count, positive and negative infinity count matches.\n+    * Check the nullity of control sum and test sum.\n+    * If either control mean or test mean very close 0, check if both are close to 0.\n+    * Check the relative error between control sum and test sum.\n+* **Array Columns**\n+    * 2 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Array checksum\n+    * For an array column ``arr`` of type ``array(E)``:\n+       * If ``E`` is not orderable, array checksum is ``checksum(arr)``.\n+       * If ``E`` is orderable, array checksum ``coalesce(checksum(try(array_sort(arr))), checksum(arr))``.\n+* **Map Columns**\n+    * 4 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Checksum of the map\n+       * Array checksum of the kep set\n+       * Array checksum of the value set\n+* **Row Columns**\n+    * Checksum row fields recursively, as according to the type of the fields.\n+* For all other column types, generate a simple checksum using the :func:`checksum` function.\n+\n+Determinism\n+-----------\n+A result mismatch, either a row count mismatch or a column mismatch, can be caused by\n+non-deterministic query features. To avoid false alerts, we perform determinism analysis\n+for the control query. If a query is found non-deterministic, we skip the verification as it\n+does not provide insights.\n+\n+Determinism analysis follows the following steps. If a query is found non-deterministic at any\n+point, the analysis will conclude.\n+\n+* A list of non-deterministic catalogs can be specified. If a query references any table from a", "originalCommit": "82a92fa026e577b6af8b53f53453de501dd8557a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2NzQ4Mg==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r384867482", "bodyText": "typo: \"Run the control query again, and the compare\" -> \"Run the control query again and compare\"", "author": "mbasmanova", "createdAt": "2020-02-27T01:35:00Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,257 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.\n+\n+* **Importing Source Queries**\n+   * Read the list of source queries (query pairs with configuration) from the MySQL table.\n+\n+* **Query Pre-processing and Filtering**\n+   * Apply overrides to the catalog, schema, username, and password of each query.\n+   * Filter queries according to whitelist and blacklist. Whitelist is applied before blacklist.\n+   * Filter out queries with invalid syntax.\n+   * Filter out queries not supported for validation. ``Select``, ``Insert``, and ``CreateTableAsSelect`` are supported.\n+\n+* **Query rewriting**\n+    * Rewrite queries before execution to ensure that production data is not modified.\n+    * Rewrite ``Select`` queries to ``CreateTableAsSelect``\n+       * Column names are determined by running the ``Select`` query with ``LIMIT 0``.\n+       * Artificial name are used for unnamed columns.\n+    * Rewrite ``Insert`` and ``CreateTableAsSelect`` queries to have their table names replaced.\n+       * Construct a setup query to create the table necessary for a ``Insert`` query.\n+\n+* **Query Execution**\n+    * Conceptually, Verifier is configured with a control cluster and a test cluster. However, they\n+      may be pointed to the same Presto cluster for certain tests.\n+    * For each source query, execute the following queries in order.\n+        * Control setup queries\n+        * Control query\n+        * Test setup queries\n+        * Test query\n+        * Control and Test teardown\n+    * Queries are subject to timeouts and retries.\n+        * Cluster connection failures and transient Presto failures are retried.\n+        * Query retries may conceal reliability issues. All occurred Presto query failures, including the retries ones, are recorded.\n+    * Certain query failures are automatically submitted for re-validation, such as partition dropped or table dropped during query.\n+    * See `Failure Resolution`_ for automatic resolving query failures.\n+\n+* **Results Comparison**\n+    * For ``Select``, ``Insert``, and ``CreateTableAsSelect`` queries, results are written into temporary tables.\n+    * Construct and run the checksum queries for both control and test.\n+    * Verify table schema and row count are the same for the control and the test result table.\n+    * Verify checksums are matching for each column. See `Column Checksums`_ for special handling of different column types.\n+    * See `Determinism`_ for handling of non-deterministic queries.\n+\n+* **Emitting Results**\n+    * Verification results can be exported as ``JSON``, or human readable text.\n+\n+Column Checksums\n+----------------\n+For each column in the control/test query, one or more columns maybe generated in the checksum\n+queries.\n+\n+* **Floating Point Columns**\n+    * For ``DOUBLE`` and ``REAL`` columns, 4 columns are generated for verification:\n+       * Sum of the finite values of the column\n+       * ``NAN`` count of the column\n+       * Positive infinity count of the column\n+       * Negative infinity count of the column\n+    * Check if ``NAN`` count, positive and negative infinity count matches.\n+    * Check the nullity of control sum and test sum.\n+    * If either control mean or test mean very close 0, check if both are close to 0.\n+    * Check the relative error between control sum and test sum.\n+* **Array Columns**\n+    * 2 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Array checksum\n+    * For an array column ``arr`` of type ``array(E)``:\n+       * If ``E`` is not orderable, array checksum is ``checksum(arr)``.\n+       * If ``E`` is orderable, array checksum ``coalesce(checksum(try(array_sort(arr))), checksum(arr))``.\n+* **Map Columns**\n+    * 4 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Checksum of the map\n+       * Array checksum of the kep set\n+       * Array checksum of the value set\n+* **Row Columns**\n+    * Checksum row fields recursively, as according to the type of the fields.\n+* For all other column types, generate a simple checksum using the :func:`checksum` function.\n+\n+Determinism\n+-----------\n+A result mismatch, either a row count mismatch or a column mismatch, can be caused by\n+non-deterministic query features. To avoid false alerts, we perform determinism analysis\n+for the control query. If a query is found non-deterministic, we skip the verification as it\n+does not provide insights.\n+\n+Determinism analysis follows the following steps. If a query is found non-deterministic at any\n+point, the analysis will conclude.\n+\n+* A list of non-deterministic catalogs can be specified. If a query references any table from a\n+  non-deterministic catalog, the query is considered non-deterministic.\n+* Run the control query again, and the compare the results with the initial control query run.", "originalCommit": "82a92fa026e577b6af8b53f53453de501dd8557a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2NzY4OA==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r384867688", "bodyText": "Does the verifier run the query without the LIMIT clause or with larger value for the LIMIT? Running without a LIMIT may fail if there are too many rows.", "author": "mbasmanova", "createdAt": "2020-02-27T01:35:51Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,257 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.\n+\n+* **Importing Source Queries**\n+   * Read the list of source queries (query pairs with configuration) from the MySQL table.\n+\n+* **Query Pre-processing and Filtering**\n+   * Apply overrides to the catalog, schema, username, and password of each query.\n+   * Filter queries according to whitelist and blacklist. Whitelist is applied before blacklist.\n+   * Filter out queries with invalid syntax.\n+   * Filter out queries not supported for validation. ``Select``, ``Insert``, and ``CreateTableAsSelect`` are supported.\n+\n+* **Query rewriting**\n+    * Rewrite queries before execution to ensure that production data is not modified.\n+    * Rewrite ``Select`` queries to ``CreateTableAsSelect``\n+       * Column names are determined by running the ``Select`` query with ``LIMIT 0``.\n+       * Artificial name are used for unnamed columns.\n+    * Rewrite ``Insert`` and ``CreateTableAsSelect`` queries to have their table names replaced.\n+       * Construct a setup query to create the table necessary for a ``Insert`` query.\n+\n+* **Query Execution**\n+    * Conceptually, Verifier is configured with a control cluster and a test cluster. However, they\n+      may be pointed to the same Presto cluster for certain tests.\n+    * For each source query, execute the following queries in order.\n+        * Control setup queries\n+        * Control query\n+        * Test setup queries\n+        * Test query\n+        * Control and Test teardown\n+    * Queries are subject to timeouts and retries.\n+        * Cluster connection failures and transient Presto failures are retried.\n+        * Query retries may conceal reliability issues. All occurred Presto query failures, including the retries ones, are recorded.\n+    * Certain query failures are automatically submitted for re-validation, such as partition dropped or table dropped during query.\n+    * See `Failure Resolution`_ for automatic resolving query failures.\n+\n+* **Results Comparison**\n+    * For ``Select``, ``Insert``, and ``CreateTableAsSelect`` queries, results are written into temporary tables.\n+    * Construct and run the checksum queries for both control and test.\n+    * Verify table schema and row count are the same for the control and the test result table.\n+    * Verify checksums are matching for each column. See `Column Checksums`_ for special handling of different column types.\n+    * See `Determinism`_ for handling of non-deterministic queries.\n+\n+* **Emitting Results**\n+    * Verification results can be exported as ``JSON``, or human readable text.\n+\n+Column Checksums\n+----------------\n+For each column in the control/test query, one or more columns maybe generated in the checksum\n+queries.\n+\n+* **Floating Point Columns**\n+    * For ``DOUBLE`` and ``REAL`` columns, 4 columns are generated for verification:\n+       * Sum of the finite values of the column\n+       * ``NAN`` count of the column\n+       * Positive infinity count of the column\n+       * Negative infinity count of the column\n+    * Check if ``NAN`` count, positive and negative infinity count matches.\n+    * Check the nullity of control sum and test sum.\n+    * If either control mean or test mean very close 0, check if both are close to 0.\n+    * Check the relative error between control sum and test sum.\n+* **Array Columns**\n+    * 2 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Array checksum\n+    * For an array column ``arr`` of type ``array(E)``:\n+       * If ``E`` is not orderable, array checksum is ``checksum(arr)``.\n+       * If ``E`` is orderable, array checksum ``coalesce(checksum(try(array_sort(arr))), checksum(arr))``.\n+* **Map Columns**\n+    * 4 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Checksum of the map\n+       * Array checksum of the kep set\n+       * Array checksum of the value set\n+* **Row Columns**\n+    * Checksum row fields recursively, as according to the type of the fields.\n+* For all other column types, generate a simple checksum using the :func:`checksum` function.\n+\n+Determinism\n+-----------\n+A result mismatch, either a row count mismatch or a column mismatch, can be caused by\n+non-deterministic query features. To avoid false alerts, we perform determinism analysis\n+for the control query. If a query is found non-deterministic, we skip the verification as it\n+does not provide insights.\n+\n+Determinism analysis follows the following steps. If a query is found non-deterministic at any\n+point, the analysis will conclude.\n+\n+* A list of non-deterministic catalogs can be specified. If a query references any table from a\n+  non-deterministic catalog, the query is considered non-deterministic.\n+* Run the control query again, and the compare the results with the initial control query run.\n+* If a query has a ``LIMIT n`` clause but no ``ORDER BY`` clause at the top level:\n+   * Run a query to count the number of rows produced by the control query without the ``LIMIT`` clause.", "originalCommit": "82a92fa026e577b6af8b53f53453de501dd8557a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk2NDYwMQ==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r384964601", "bodyText": "For a query SELECT ... LIMIT n, Verifier runs\nSELECT count(*) FROM (SELECT ... )\n\nto get the row count without the limit clause.\nIt is expensive, and I'm planning to optimize it. This is what we actually need:\nSELECT count(*) FROM (SELECT ... LIMIT n+1)", "author": "caithagoras", "createdAt": "2020-02-27T08:03:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2NzY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2Nzg5Mg==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r384867892", "bodyText": "typo: \"do not have enough worker\" -> \"does not have enough workers\"", "author": "mbasmanova", "createdAt": "2020-02-27T01:36:35Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,257 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.\n+\n+* **Importing Source Queries**\n+   * Read the list of source queries (query pairs with configuration) from the MySQL table.\n+\n+* **Query Pre-processing and Filtering**\n+   * Apply overrides to the catalog, schema, username, and password of each query.\n+   * Filter queries according to whitelist and blacklist. Whitelist is applied before blacklist.\n+   * Filter out queries with invalid syntax.\n+   * Filter out queries not supported for validation. ``Select``, ``Insert``, and ``CreateTableAsSelect`` are supported.\n+\n+* **Query rewriting**\n+    * Rewrite queries before execution to ensure that production data is not modified.\n+    * Rewrite ``Select`` queries to ``CreateTableAsSelect``\n+       * Column names are determined by running the ``Select`` query with ``LIMIT 0``.\n+       * Artificial name are used for unnamed columns.\n+    * Rewrite ``Insert`` and ``CreateTableAsSelect`` queries to have their table names replaced.\n+       * Construct a setup query to create the table necessary for a ``Insert`` query.\n+\n+* **Query Execution**\n+    * Conceptually, Verifier is configured with a control cluster and a test cluster. However, they\n+      may be pointed to the same Presto cluster for certain tests.\n+    * For each source query, execute the following queries in order.\n+        * Control setup queries\n+        * Control query\n+        * Test setup queries\n+        * Test query\n+        * Control and Test teardown\n+    * Queries are subject to timeouts and retries.\n+        * Cluster connection failures and transient Presto failures are retried.\n+        * Query retries may conceal reliability issues. All occurred Presto query failures, including the retries ones, are recorded.\n+    * Certain query failures are automatically submitted for re-validation, such as partition dropped or table dropped during query.\n+    * See `Failure Resolution`_ for automatic resolving query failures.\n+\n+* **Results Comparison**\n+    * For ``Select``, ``Insert``, and ``CreateTableAsSelect`` queries, results are written into temporary tables.\n+    * Construct and run the checksum queries for both control and test.\n+    * Verify table schema and row count are the same for the control and the test result table.\n+    * Verify checksums are matching for each column. See `Column Checksums`_ for special handling of different column types.\n+    * See `Determinism`_ for handling of non-deterministic queries.\n+\n+* **Emitting Results**\n+    * Verification results can be exported as ``JSON``, or human readable text.\n+\n+Column Checksums\n+----------------\n+For each column in the control/test query, one or more columns maybe generated in the checksum\n+queries.\n+\n+* **Floating Point Columns**\n+    * For ``DOUBLE`` and ``REAL`` columns, 4 columns are generated for verification:\n+       * Sum of the finite values of the column\n+       * ``NAN`` count of the column\n+       * Positive infinity count of the column\n+       * Negative infinity count of the column\n+    * Check if ``NAN`` count, positive and negative infinity count matches.\n+    * Check the nullity of control sum and test sum.\n+    * If either control mean or test mean very close 0, check if both are close to 0.\n+    * Check the relative error between control sum and test sum.\n+* **Array Columns**\n+    * 2 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Array checksum\n+    * For an array column ``arr`` of type ``array(E)``:\n+       * If ``E`` is not orderable, array checksum is ``checksum(arr)``.\n+       * If ``E`` is orderable, array checksum ``coalesce(checksum(try(array_sort(arr))), checksum(arr))``.\n+* **Map Columns**\n+    * 4 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Checksum of the map\n+       * Array checksum of the kep set\n+       * Array checksum of the value set\n+* **Row Columns**\n+    * Checksum row fields recursively, as according to the type of the fields.\n+* For all other column types, generate a simple checksum using the :func:`checksum` function.\n+\n+Determinism\n+-----------\n+A result mismatch, either a row count mismatch or a column mismatch, can be caused by\n+non-deterministic query features. To avoid false alerts, we perform determinism analysis\n+for the control query. If a query is found non-deterministic, we skip the verification as it\n+does not provide insights.\n+\n+Determinism analysis follows the following steps. If a query is found non-deterministic at any\n+point, the analysis will conclude.\n+\n+* A list of non-deterministic catalogs can be specified. If a query references any table from a\n+  non-deterministic catalog, the query is considered non-deterministic.\n+* Run the control query again, and the compare the results with the initial control query run.\n+* If a query has a ``LIMIT n`` clause but no ``ORDER BY`` clause at the top level:\n+   * Run a query to count the number of rows produced by the control query without the ``LIMIT`` clause.\n+   * If the resulting row count is greater than ``n``, treat the control query as non-deterministic.\n+\n+Failure Resolution\n+------------------\n+The difference in configuration, including cluster size, can cause a query to succeed on the\n+control cluster but fail on the test cluster. A checksum query can also fail, which may be due to\n+limitation of Presto or Presto Verifier. Thus, we allow Verifier to automatically resolve certain\n+query failures.\n+\n+* ``EXCEEDED_GLOBAL_MEMORY_LIMIT``: Resolve if the control query uses more memory than the test query.\n+* ``EXCEEDED_TIME_LIMIT``: Resolve unconditionally.\n+* ``TOO_MANY_HIVE_PARTITIONS``: Resolve if the test cluster do not have enough worker to make sure the", "originalCommit": "82a92fa026e577b6af8b53f53453de501dd8557a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2ODE0Ng==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r384868146", "bodyText": "typo: \"from suite\" -> \"from the suite\"", "author": "mbasmanova", "createdAt": "2020-02-27T01:37:30Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,257 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.\n+\n+* **Importing Source Queries**\n+   * Read the list of source queries (query pairs with configuration) from the MySQL table.\n+\n+* **Query Pre-processing and Filtering**\n+   * Apply overrides to the catalog, schema, username, and password of each query.\n+   * Filter queries according to whitelist and blacklist. Whitelist is applied before blacklist.\n+   * Filter out queries with invalid syntax.\n+   * Filter out queries not supported for validation. ``Select``, ``Insert``, and ``CreateTableAsSelect`` are supported.\n+\n+* **Query rewriting**\n+    * Rewrite queries before execution to ensure that production data is not modified.\n+    * Rewrite ``Select`` queries to ``CreateTableAsSelect``\n+       * Column names are determined by running the ``Select`` query with ``LIMIT 0``.\n+       * Artificial name are used for unnamed columns.\n+    * Rewrite ``Insert`` and ``CreateTableAsSelect`` queries to have their table names replaced.\n+       * Construct a setup query to create the table necessary for a ``Insert`` query.\n+\n+* **Query Execution**\n+    * Conceptually, Verifier is configured with a control cluster and a test cluster. However, they\n+      may be pointed to the same Presto cluster for certain tests.\n+    * For each source query, execute the following queries in order.\n+        * Control setup queries\n+        * Control query\n+        * Test setup queries\n+        * Test query\n+        * Control and Test teardown\n+    * Queries are subject to timeouts and retries.\n+        * Cluster connection failures and transient Presto failures are retried.\n+        * Query retries may conceal reliability issues. All occurred Presto query failures, including the retries ones, are recorded.\n+    * Certain query failures are automatically submitted for re-validation, such as partition dropped or table dropped during query.\n+    * See `Failure Resolution`_ for automatic resolving query failures.\n+\n+* **Results Comparison**\n+    * For ``Select``, ``Insert``, and ``CreateTableAsSelect`` queries, results are written into temporary tables.\n+    * Construct and run the checksum queries for both control and test.\n+    * Verify table schema and row count are the same for the control and the test result table.\n+    * Verify checksums are matching for each column. See `Column Checksums`_ for special handling of different column types.\n+    * See `Determinism`_ for handling of non-deterministic queries.\n+\n+* **Emitting Results**\n+    * Verification results can be exported as ``JSON``, or human readable text.\n+\n+Column Checksums\n+----------------\n+For each column in the control/test query, one or more columns maybe generated in the checksum\n+queries.\n+\n+* **Floating Point Columns**\n+    * For ``DOUBLE`` and ``REAL`` columns, 4 columns are generated for verification:\n+       * Sum of the finite values of the column\n+       * ``NAN`` count of the column\n+       * Positive infinity count of the column\n+       * Negative infinity count of the column\n+    * Check if ``NAN`` count, positive and negative infinity count matches.\n+    * Check the nullity of control sum and test sum.\n+    * If either control mean or test mean very close 0, check if both are close to 0.\n+    * Check the relative error between control sum and test sum.\n+* **Array Columns**\n+    * 2 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Array checksum\n+    * For an array column ``arr`` of type ``array(E)``:\n+       * If ``E`` is not orderable, array checksum is ``checksum(arr)``.\n+       * If ``E`` is orderable, array checksum ``coalesce(checksum(try(array_sort(arr))), checksum(arr))``.\n+* **Map Columns**\n+    * 4 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Checksum of the map\n+       * Array checksum of the kep set\n+       * Array checksum of the value set\n+* **Row Columns**\n+    * Checksum row fields recursively, as according to the type of the fields.\n+* For all other column types, generate a simple checksum using the :func:`checksum` function.\n+\n+Determinism\n+-----------\n+A result mismatch, either a row count mismatch or a column mismatch, can be caused by\n+non-deterministic query features. To avoid false alerts, we perform determinism analysis\n+for the control query. If a query is found non-deterministic, we skip the verification as it\n+does not provide insights.\n+\n+Determinism analysis follows the following steps. If a query is found non-deterministic at any\n+point, the analysis will conclude.\n+\n+* A list of non-deterministic catalogs can be specified. If a query references any table from a\n+  non-deterministic catalog, the query is considered non-deterministic.\n+* Run the control query again, and the compare the results with the initial control query run.\n+* If a query has a ``LIMIT n`` clause but no ``ORDER BY`` clause at the top level:\n+   * Run a query to count the number of rows produced by the control query without the ``LIMIT`` clause.\n+   * If the resulting row count is greater than ``n``, treat the control query as non-deterministic.\n+\n+Failure Resolution\n+------------------\n+The difference in configuration, including cluster size, can cause a query to succeed on the\n+control cluster but fail on the test cluster. A checksum query can also fail, which may be due to\n+limitation of Presto or Presto Verifier. Thus, we allow Verifier to automatically resolve certain\n+query failures.\n+\n+* ``EXCEEDED_GLOBAL_MEMORY_LIMIT``: Resolve if the control query uses more memory than the test query.\n+* ``EXCEEDED_TIME_LIMIT``: Resolve unconditionally.\n+* ``TOO_MANY_HIVE_PARTITIONS``: Resolve if the test cluster do not have enough worker to make sure the\n+  number of partitions assigned to each worker stays within the limit.\n+* ``COMPILER_ERROR``: Resolve if checksum fails with this error. If a control query has too many\n+  columns, generated checksum query might be too large in certain cases.\n+\n+Extending Verifier\n+------------------\n+\n+Verifier can be extended for further behavioral changes in additional to configuration properties.\n+\n+`AbstractVerifyCommand <https://github.com/prestodb/presto/blob/master/presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerifyCommand.java>`_\n+shows the components that be extended. Implement the abstract class and create a command line wrapper similar to\n+`PrestoVerifier <https://github.com/prestodb/presto/blob/master/presto-verifier/src/main/java/com/facebook/presto/verifier/PrestoVerifier.java>`_.\n+\n+\n+Configuration Reference\n+-----------------------\n+\n+General Configuration\n+~~~~~~~~~~~~~~~~~~~~~\n+\n+=========================================== ===============================================================================\n+Name                                        Description\n+=========================================== ===============================================================================\n+``whitelist``                               A comma-separated list specifying the names of the queries within the suite\n+                                            to verify.\n+``blacklist``                               A comma-separated list specifying the names of the queries to be excluded\n+                                            from suite. ``blacklist`` is applied after ``whitelist``.", "originalCommit": "82a92fa026e577b6af8b53f53453de501dd8557a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2ODI1MQ==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r384868251", "bodyText": "typo: \"of table\" -> \"of the table\"", "author": "mbasmanova", "createdAt": "2020-02-27T01:37:56Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,257 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.\n+\n+* **Importing Source Queries**\n+   * Read the list of source queries (query pairs with configuration) from the MySQL table.\n+\n+* **Query Pre-processing and Filtering**\n+   * Apply overrides to the catalog, schema, username, and password of each query.\n+   * Filter queries according to whitelist and blacklist. Whitelist is applied before blacklist.\n+   * Filter out queries with invalid syntax.\n+   * Filter out queries not supported for validation. ``Select``, ``Insert``, and ``CreateTableAsSelect`` are supported.\n+\n+* **Query rewriting**\n+    * Rewrite queries before execution to ensure that production data is not modified.\n+    * Rewrite ``Select`` queries to ``CreateTableAsSelect``\n+       * Column names are determined by running the ``Select`` query with ``LIMIT 0``.\n+       * Artificial name are used for unnamed columns.\n+    * Rewrite ``Insert`` and ``CreateTableAsSelect`` queries to have their table names replaced.\n+       * Construct a setup query to create the table necessary for a ``Insert`` query.\n+\n+* **Query Execution**\n+    * Conceptually, Verifier is configured with a control cluster and a test cluster. However, they\n+      may be pointed to the same Presto cluster for certain tests.\n+    * For each source query, execute the following queries in order.\n+        * Control setup queries\n+        * Control query\n+        * Test setup queries\n+        * Test query\n+        * Control and Test teardown\n+    * Queries are subject to timeouts and retries.\n+        * Cluster connection failures and transient Presto failures are retried.\n+        * Query retries may conceal reliability issues. All occurred Presto query failures, including the retries ones, are recorded.\n+    * Certain query failures are automatically submitted for re-validation, such as partition dropped or table dropped during query.\n+    * See `Failure Resolution`_ for automatic resolving query failures.\n+\n+* **Results Comparison**\n+    * For ``Select``, ``Insert``, and ``CreateTableAsSelect`` queries, results are written into temporary tables.\n+    * Construct and run the checksum queries for both control and test.\n+    * Verify table schema and row count are the same for the control and the test result table.\n+    * Verify checksums are matching for each column. See `Column Checksums`_ for special handling of different column types.\n+    * See `Determinism`_ for handling of non-deterministic queries.\n+\n+* **Emitting Results**\n+    * Verification results can be exported as ``JSON``, or human readable text.\n+\n+Column Checksums\n+----------------\n+For each column in the control/test query, one or more columns maybe generated in the checksum\n+queries.\n+\n+* **Floating Point Columns**\n+    * For ``DOUBLE`` and ``REAL`` columns, 4 columns are generated for verification:\n+       * Sum of the finite values of the column\n+       * ``NAN`` count of the column\n+       * Positive infinity count of the column\n+       * Negative infinity count of the column\n+    * Check if ``NAN`` count, positive and negative infinity count matches.\n+    * Check the nullity of control sum and test sum.\n+    * If either control mean or test mean very close 0, check if both are close to 0.\n+    * Check the relative error between control sum and test sum.\n+* **Array Columns**\n+    * 2 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Array checksum\n+    * For an array column ``arr`` of type ``array(E)``:\n+       * If ``E`` is not orderable, array checksum is ``checksum(arr)``.\n+       * If ``E`` is orderable, array checksum ``coalesce(checksum(try(array_sort(arr))), checksum(arr))``.\n+* **Map Columns**\n+    * 4 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Checksum of the map\n+       * Array checksum of the kep set\n+       * Array checksum of the value set\n+* **Row Columns**\n+    * Checksum row fields recursively, as according to the type of the fields.\n+* For all other column types, generate a simple checksum using the :func:`checksum` function.\n+\n+Determinism\n+-----------\n+A result mismatch, either a row count mismatch or a column mismatch, can be caused by\n+non-deterministic query features. To avoid false alerts, we perform determinism analysis\n+for the control query. If a query is found non-deterministic, we skip the verification as it\n+does not provide insights.\n+\n+Determinism analysis follows the following steps. If a query is found non-deterministic at any\n+point, the analysis will conclude.\n+\n+* A list of non-deterministic catalogs can be specified. If a query references any table from a\n+  non-deterministic catalog, the query is considered non-deterministic.\n+* Run the control query again, and the compare the results with the initial control query run.\n+* If a query has a ``LIMIT n`` clause but no ``ORDER BY`` clause at the top level:\n+   * Run a query to count the number of rows produced by the control query without the ``LIMIT`` clause.\n+   * If the resulting row count is greater than ``n``, treat the control query as non-deterministic.\n+\n+Failure Resolution\n+------------------\n+The difference in configuration, including cluster size, can cause a query to succeed on the\n+control cluster but fail on the test cluster. A checksum query can also fail, which may be due to\n+limitation of Presto or Presto Verifier. Thus, we allow Verifier to automatically resolve certain\n+query failures.\n+\n+* ``EXCEEDED_GLOBAL_MEMORY_LIMIT``: Resolve if the control query uses more memory than the test query.\n+* ``EXCEEDED_TIME_LIMIT``: Resolve unconditionally.\n+* ``TOO_MANY_HIVE_PARTITIONS``: Resolve if the test cluster do not have enough worker to make sure the\n+  number of partitions assigned to each worker stays within the limit.\n+* ``COMPILER_ERROR``: Resolve if checksum fails with this error. If a control query has too many\n+  columns, generated checksum query might be too large in certain cases.\n+\n+Extending Verifier\n+------------------\n+\n+Verifier can be extended for further behavioral changes in additional to configuration properties.\n+\n+`AbstractVerifyCommand <https://github.com/prestodb/presto/blob/master/presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerifyCommand.java>`_\n+shows the components that be extended. Implement the abstract class and create a command line wrapper similar to\n+`PrestoVerifier <https://github.com/prestodb/presto/blob/master/presto-verifier/src/main/java/com/facebook/presto/verifier/PrestoVerifier.java>`_.\n+\n+\n+Configuration Reference\n+-----------------------\n+\n+General Configuration\n+~~~~~~~~~~~~~~~~~~~~~\n+\n+=========================================== ===============================================================================\n+Name                                        Description\n+=========================================== ===============================================================================\n+``whitelist``                               A comma-separated list specifying the names of the queries within the suite\n+                                            to verify.\n+``blacklist``                               A comma-separated list specifying the names of the queries to be excluded\n+                                            from suite. ``blacklist`` is applied after ``whitelist``.\n+``source-query-supplier``                   The name of the source query supplier. Supports ``mysql``.\n+``source-query.table-name``                 The name of table that holds verifier queries. Available only when", "originalCommit": "82a92fa026e577b6af8b53f53453de501dd8557a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2ODM4Nw==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r384868387", "bodyText": "typo: \"String\" -> \"string\"; \"with\" -> \"to\"", "author": "mbasmanova", "createdAt": "2020-02-27T01:38:27Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,257 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.\n+\n+* **Importing Source Queries**\n+   * Read the list of source queries (query pairs with configuration) from the MySQL table.\n+\n+* **Query Pre-processing and Filtering**\n+   * Apply overrides to the catalog, schema, username, and password of each query.\n+   * Filter queries according to whitelist and blacklist. Whitelist is applied before blacklist.\n+   * Filter out queries with invalid syntax.\n+   * Filter out queries not supported for validation. ``Select``, ``Insert``, and ``CreateTableAsSelect`` are supported.\n+\n+* **Query rewriting**\n+    * Rewrite queries before execution to ensure that production data is not modified.\n+    * Rewrite ``Select`` queries to ``CreateTableAsSelect``\n+       * Column names are determined by running the ``Select`` query with ``LIMIT 0``.\n+       * Artificial name are used for unnamed columns.\n+    * Rewrite ``Insert`` and ``CreateTableAsSelect`` queries to have their table names replaced.\n+       * Construct a setup query to create the table necessary for a ``Insert`` query.\n+\n+* **Query Execution**\n+    * Conceptually, Verifier is configured with a control cluster and a test cluster. However, they\n+      may be pointed to the same Presto cluster for certain tests.\n+    * For each source query, execute the following queries in order.\n+        * Control setup queries\n+        * Control query\n+        * Test setup queries\n+        * Test query\n+        * Control and Test teardown\n+    * Queries are subject to timeouts and retries.\n+        * Cluster connection failures and transient Presto failures are retried.\n+        * Query retries may conceal reliability issues. All occurred Presto query failures, including the retries ones, are recorded.\n+    * Certain query failures are automatically submitted for re-validation, such as partition dropped or table dropped during query.\n+    * See `Failure Resolution`_ for automatic resolving query failures.\n+\n+* **Results Comparison**\n+    * For ``Select``, ``Insert``, and ``CreateTableAsSelect`` queries, results are written into temporary tables.\n+    * Construct and run the checksum queries for both control and test.\n+    * Verify table schema and row count are the same for the control and the test result table.\n+    * Verify checksums are matching for each column. See `Column Checksums`_ for special handling of different column types.\n+    * See `Determinism`_ for handling of non-deterministic queries.\n+\n+* **Emitting Results**\n+    * Verification results can be exported as ``JSON``, or human readable text.\n+\n+Column Checksums\n+----------------\n+For each column in the control/test query, one or more columns maybe generated in the checksum\n+queries.\n+\n+* **Floating Point Columns**\n+    * For ``DOUBLE`` and ``REAL`` columns, 4 columns are generated for verification:\n+       * Sum of the finite values of the column\n+       * ``NAN`` count of the column\n+       * Positive infinity count of the column\n+       * Negative infinity count of the column\n+    * Check if ``NAN`` count, positive and negative infinity count matches.\n+    * Check the nullity of control sum and test sum.\n+    * If either control mean or test mean very close 0, check if both are close to 0.\n+    * Check the relative error between control sum and test sum.\n+* **Array Columns**\n+    * 2 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Array checksum\n+    * For an array column ``arr`` of type ``array(E)``:\n+       * If ``E`` is not orderable, array checksum is ``checksum(arr)``.\n+       * If ``E`` is orderable, array checksum ``coalesce(checksum(try(array_sort(arr))), checksum(arr))``.\n+* **Map Columns**\n+    * 4 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Checksum of the map\n+       * Array checksum of the kep set\n+       * Array checksum of the value set\n+* **Row Columns**\n+    * Checksum row fields recursively, as according to the type of the fields.\n+* For all other column types, generate a simple checksum using the :func:`checksum` function.\n+\n+Determinism\n+-----------\n+A result mismatch, either a row count mismatch or a column mismatch, can be caused by\n+non-deterministic query features. To avoid false alerts, we perform determinism analysis\n+for the control query. If a query is found non-deterministic, we skip the verification as it\n+does not provide insights.\n+\n+Determinism analysis follows the following steps. If a query is found non-deterministic at any\n+point, the analysis will conclude.\n+\n+* A list of non-deterministic catalogs can be specified. If a query references any table from a\n+  non-deterministic catalog, the query is considered non-deterministic.\n+* Run the control query again, and the compare the results with the initial control query run.\n+* If a query has a ``LIMIT n`` clause but no ``ORDER BY`` clause at the top level:\n+   * Run a query to count the number of rows produced by the control query without the ``LIMIT`` clause.\n+   * If the resulting row count is greater than ``n``, treat the control query as non-deterministic.\n+\n+Failure Resolution\n+------------------\n+The difference in configuration, including cluster size, can cause a query to succeed on the\n+control cluster but fail on the test cluster. A checksum query can also fail, which may be due to\n+limitation of Presto or Presto Verifier. Thus, we allow Verifier to automatically resolve certain\n+query failures.\n+\n+* ``EXCEEDED_GLOBAL_MEMORY_LIMIT``: Resolve if the control query uses more memory than the test query.\n+* ``EXCEEDED_TIME_LIMIT``: Resolve unconditionally.\n+* ``TOO_MANY_HIVE_PARTITIONS``: Resolve if the test cluster do not have enough worker to make sure the\n+  number of partitions assigned to each worker stays within the limit.\n+* ``COMPILER_ERROR``: Resolve if checksum fails with this error. If a control query has too many\n+  columns, generated checksum query might be too large in certain cases.\n+\n+Extending Verifier\n+------------------\n+\n+Verifier can be extended for further behavioral changes in additional to configuration properties.\n+\n+`AbstractVerifyCommand <https://github.com/prestodb/presto/blob/master/presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerifyCommand.java>`_\n+shows the components that be extended. Implement the abstract class and create a command line wrapper similar to\n+`PrestoVerifier <https://github.com/prestodb/presto/blob/master/presto-verifier/src/main/java/com/facebook/presto/verifier/PrestoVerifier.java>`_.\n+\n+\n+Configuration Reference\n+-----------------------\n+\n+General Configuration\n+~~~~~~~~~~~~~~~~~~~~~\n+\n+=========================================== ===============================================================================\n+Name                                        Description\n+=========================================== ===============================================================================\n+``whitelist``                               A comma-separated list specifying the names of the queries within the suite\n+                                            to verify.\n+``blacklist``                               A comma-separated list specifying the names of the queries to be excluded\n+                                            from suite. ``blacklist`` is applied after ``whitelist``.\n+``source-query-supplier``                   The name of the source query supplier. Supports ``mysql``.\n+``source-query.table-name``                 The name of table that holds verifier queries. Available only when\n+                                            ``source-query-supplier`` is ``mysql``.\n+``event-clients``                           A comma-separated list specifying where the output events should be emitted.\n+                                            Supports ``json`` and ``human-readable``.\n+``json.log-file``                           The output files of ``JSON`` events. If not set, ``JSON`` events are emitted to\n+                                            ``stdout``.\n+``human-readable.log-file``                 The output files for human-readable events. If not set, human-readable events\n+                                            are emitted to ``stdout``.\n+``test-id``                                 A String to be attached with output events.", "originalCommit": "82a92fa026e577b6af8b53f53453de501dd8557a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2ODYwOA==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r384868608", "bodyText": "typo: \"Number of time\" -> \"How many times\"", "author": "mbasmanova", "createdAt": "2020-02-27T01:39:27Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,257 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.\n+\n+* **Importing Source Queries**\n+   * Read the list of source queries (query pairs with configuration) from the MySQL table.\n+\n+* **Query Pre-processing and Filtering**\n+   * Apply overrides to the catalog, schema, username, and password of each query.\n+   * Filter queries according to whitelist and blacklist. Whitelist is applied before blacklist.\n+   * Filter out queries with invalid syntax.\n+   * Filter out queries not supported for validation. ``Select``, ``Insert``, and ``CreateTableAsSelect`` are supported.\n+\n+* **Query rewriting**\n+    * Rewrite queries before execution to ensure that production data is not modified.\n+    * Rewrite ``Select`` queries to ``CreateTableAsSelect``\n+       * Column names are determined by running the ``Select`` query with ``LIMIT 0``.\n+       * Artificial name are used for unnamed columns.\n+    * Rewrite ``Insert`` and ``CreateTableAsSelect`` queries to have their table names replaced.\n+       * Construct a setup query to create the table necessary for a ``Insert`` query.\n+\n+* **Query Execution**\n+    * Conceptually, Verifier is configured with a control cluster and a test cluster. However, they\n+      may be pointed to the same Presto cluster for certain tests.\n+    * For each source query, execute the following queries in order.\n+        * Control setup queries\n+        * Control query\n+        * Test setup queries\n+        * Test query\n+        * Control and Test teardown\n+    * Queries are subject to timeouts and retries.\n+        * Cluster connection failures and transient Presto failures are retried.\n+        * Query retries may conceal reliability issues. All occurred Presto query failures, including the retries ones, are recorded.\n+    * Certain query failures are automatically submitted for re-validation, such as partition dropped or table dropped during query.\n+    * See `Failure Resolution`_ for automatic resolving query failures.\n+\n+* **Results Comparison**\n+    * For ``Select``, ``Insert``, and ``CreateTableAsSelect`` queries, results are written into temporary tables.\n+    * Construct and run the checksum queries for both control and test.\n+    * Verify table schema and row count are the same for the control and the test result table.\n+    * Verify checksums are matching for each column. See `Column Checksums`_ for special handling of different column types.\n+    * See `Determinism`_ for handling of non-deterministic queries.\n+\n+* **Emitting Results**\n+    * Verification results can be exported as ``JSON``, or human readable text.\n+\n+Column Checksums\n+----------------\n+For each column in the control/test query, one or more columns maybe generated in the checksum\n+queries.\n+\n+* **Floating Point Columns**\n+    * For ``DOUBLE`` and ``REAL`` columns, 4 columns are generated for verification:\n+       * Sum of the finite values of the column\n+       * ``NAN`` count of the column\n+       * Positive infinity count of the column\n+       * Negative infinity count of the column\n+    * Check if ``NAN`` count, positive and negative infinity count matches.\n+    * Check the nullity of control sum and test sum.\n+    * If either control mean or test mean very close 0, check if both are close to 0.\n+    * Check the relative error between control sum and test sum.\n+* **Array Columns**\n+    * 2 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Array checksum\n+    * For an array column ``arr`` of type ``array(E)``:\n+       * If ``E`` is not orderable, array checksum is ``checksum(arr)``.\n+       * If ``E`` is orderable, array checksum ``coalesce(checksum(try(array_sort(arr))), checksum(arr))``.\n+* **Map Columns**\n+    * 4 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Checksum of the map\n+       * Array checksum of the kep set\n+       * Array checksum of the value set\n+* **Row Columns**\n+    * Checksum row fields recursively, as according to the type of the fields.\n+* For all other column types, generate a simple checksum using the :func:`checksum` function.\n+\n+Determinism\n+-----------\n+A result mismatch, either a row count mismatch or a column mismatch, can be caused by\n+non-deterministic query features. To avoid false alerts, we perform determinism analysis\n+for the control query. If a query is found non-deterministic, we skip the verification as it\n+does not provide insights.\n+\n+Determinism analysis follows the following steps. If a query is found non-deterministic at any\n+point, the analysis will conclude.\n+\n+* A list of non-deterministic catalogs can be specified. If a query references any table from a\n+  non-deterministic catalog, the query is considered non-deterministic.\n+* Run the control query again, and the compare the results with the initial control query run.\n+* If a query has a ``LIMIT n`` clause but no ``ORDER BY`` clause at the top level:\n+   * Run a query to count the number of rows produced by the control query without the ``LIMIT`` clause.\n+   * If the resulting row count is greater than ``n``, treat the control query as non-deterministic.\n+\n+Failure Resolution\n+------------------\n+The difference in configuration, including cluster size, can cause a query to succeed on the\n+control cluster but fail on the test cluster. A checksum query can also fail, which may be due to\n+limitation of Presto or Presto Verifier. Thus, we allow Verifier to automatically resolve certain\n+query failures.\n+\n+* ``EXCEEDED_GLOBAL_MEMORY_LIMIT``: Resolve if the control query uses more memory than the test query.\n+* ``EXCEEDED_TIME_LIMIT``: Resolve unconditionally.\n+* ``TOO_MANY_HIVE_PARTITIONS``: Resolve if the test cluster do not have enough worker to make sure the\n+  number of partitions assigned to each worker stays within the limit.\n+* ``COMPILER_ERROR``: Resolve if checksum fails with this error. If a control query has too many\n+  columns, generated checksum query might be too large in certain cases.\n+\n+Extending Verifier\n+------------------\n+\n+Verifier can be extended for further behavioral changes in additional to configuration properties.\n+\n+`AbstractVerifyCommand <https://github.com/prestodb/presto/blob/master/presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerifyCommand.java>`_\n+shows the components that be extended. Implement the abstract class and create a command line wrapper similar to\n+`PrestoVerifier <https://github.com/prestodb/presto/blob/master/presto-verifier/src/main/java/com/facebook/presto/verifier/PrestoVerifier.java>`_.\n+\n+\n+Configuration Reference\n+-----------------------\n+\n+General Configuration\n+~~~~~~~~~~~~~~~~~~~~~\n+\n+=========================================== ===============================================================================\n+Name                                        Description\n+=========================================== ===============================================================================\n+``whitelist``                               A comma-separated list specifying the names of the queries within the suite\n+                                            to verify.\n+``blacklist``                               A comma-separated list specifying the names of the queries to be excluded\n+                                            from suite. ``blacklist`` is applied after ``whitelist``.\n+``source-query-supplier``                   The name of the source query supplier. Supports ``mysql``.\n+``source-query.table-name``                 The name of table that holds verifier queries. Available only when\n+                                            ``source-query-supplier`` is ``mysql``.\n+``event-clients``                           A comma-separated list specifying where the output events should be emitted.\n+                                            Supports ``json`` and ``human-readable``.\n+``json.log-file``                           The output files of ``JSON`` events. If not set, ``JSON`` events are emitted to\n+                                            ``stdout``.\n+``human-readable.log-file``                 The output files for human-readable events. If not set, human-readable events\n+                                            are emitted to ``stdout``.\n+``test-id``                                 A String to be attached with output events.\n+``max-concurrency``                         Maximum number of concurrent verifications.\n+``suite-repetition``                        Number of time a suite is verified.", "originalCommit": "82a92fa026e577b6af8b53f53453de501dd8557a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2ODY0MA==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r384868640", "bodyText": "typo: \"Number of time\" -> \"How many times\"", "author": "mbasmanova", "createdAt": "2020-02-27T01:39:32Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,257 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.\n+\n+* **Importing Source Queries**\n+   * Read the list of source queries (query pairs with configuration) from the MySQL table.\n+\n+* **Query Pre-processing and Filtering**\n+   * Apply overrides to the catalog, schema, username, and password of each query.\n+   * Filter queries according to whitelist and blacklist. Whitelist is applied before blacklist.\n+   * Filter out queries with invalid syntax.\n+   * Filter out queries not supported for validation. ``Select``, ``Insert``, and ``CreateTableAsSelect`` are supported.\n+\n+* **Query rewriting**\n+    * Rewrite queries before execution to ensure that production data is not modified.\n+    * Rewrite ``Select`` queries to ``CreateTableAsSelect``\n+       * Column names are determined by running the ``Select`` query with ``LIMIT 0``.\n+       * Artificial name are used for unnamed columns.\n+    * Rewrite ``Insert`` and ``CreateTableAsSelect`` queries to have their table names replaced.\n+       * Construct a setup query to create the table necessary for a ``Insert`` query.\n+\n+* **Query Execution**\n+    * Conceptually, Verifier is configured with a control cluster and a test cluster. However, they\n+      may be pointed to the same Presto cluster for certain tests.\n+    * For each source query, execute the following queries in order.\n+        * Control setup queries\n+        * Control query\n+        * Test setup queries\n+        * Test query\n+        * Control and Test teardown\n+    * Queries are subject to timeouts and retries.\n+        * Cluster connection failures and transient Presto failures are retried.\n+        * Query retries may conceal reliability issues. All occurred Presto query failures, including the retries ones, are recorded.\n+    * Certain query failures are automatically submitted for re-validation, such as partition dropped or table dropped during query.\n+    * See `Failure Resolution`_ for automatic resolving query failures.\n+\n+* **Results Comparison**\n+    * For ``Select``, ``Insert``, and ``CreateTableAsSelect`` queries, results are written into temporary tables.\n+    * Construct and run the checksum queries for both control and test.\n+    * Verify table schema and row count are the same for the control and the test result table.\n+    * Verify checksums are matching for each column. See `Column Checksums`_ for special handling of different column types.\n+    * See `Determinism`_ for handling of non-deterministic queries.\n+\n+* **Emitting Results**\n+    * Verification results can be exported as ``JSON``, or human readable text.\n+\n+Column Checksums\n+----------------\n+For each column in the control/test query, one or more columns maybe generated in the checksum\n+queries.\n+\n+* **Floating Point Columns**\n+    * For ``DOUBLE`` and ``REAL`` columns, 4 columns are generated for verification:\n+       * Sum of the finite values of the column\n+       * ``NAN`` count of the column\n+       * Positive infinity count of the column\n+       * Negative infinity count of the column\n+    * Check if ``NAN`` count, positive and negative infinity count matches.\n+    * Check the nullity of control sum and test sum.\n+    * If either control mean or test mean very close 0, check if both are close to 0.\n+    * Check the relative error between control sum and test sum.\n+* **Array Columns**\n+    * 2 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Array checksum\n+    * For an array column ``arr`` of type ``array(E)``:\n+       * If ``E`` is not orderable, array checksum is ``checksum(arr)``.\n+       * If ``E`` is orderable, array checksum ``coalesce(checksum(try(array_sort(arr))), checksum(arr))``.\n+* **Map Columns**\n+    * 4 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Checksum of the map\n+       * Array checksum of the kep set\n+       * Array checksum of the value set\n+* **Row Columns**\n+    * Checksum row fields recursively, as according to the type of the fields.\n+* For all other column types, generate a simple checksum using the :func:`checksum` function.\n+\n+Determinism\n+-----------\n+A result mismatch, either a row count mismatch or a column mismatch, can be caused by\n+non-deterministic query features. To avoid false alerts, we perform determinism analysis\n+for the control query. If a query is found non-deterministic, we skip the verification as it\n+does not provide insights.\n+\n+Determinism analysis follows the following steps. If a query is found non-deterministic at any\n+point, the analysis will conclude.\n+\n+* A list of non-deterministic catalogs can be specified. If a query references any table from a\n+  non-deterministic catalog, the query is considered non-deterministic.\n+* Run the control query again, and the compare the results with the initial control query run.\n+* If a query has a ``LIMIT n`` clause but no ``ORDER BY`` clause at the top level:\n+   * Run a query to count the number of rows produced by the control query without the ``LIMIT`` clause.\n+   * If the resulting row count is greater than ``n``, treat the control query as non-deterministic.\n+\n+Failure Resolution\n+------------------\n+The difference in configuration, including cluster size, can cause a query to succeed on the\n+control cluster but fail on the test cluster. A checksum query can also fail, which may be due to\n+limitation of Presto or Presto Verifier. Thus, we allow Verifier to automatically resolve certain\n+query failures.\n+\n+* ``EXCEEDED_GLOBAL_MEMORY_LIMIT``: Resolve if the control query uses more memory than the test query.\n+* ``EXCEEDED_TIME_LIMIT``: Resolve unconditionally.\n+* ``TOO_MANY_HIVE_PARTITIONS``: Resolve if the test cluster do not have enough worker to make sure the\n+  number of partitions assigned to each worker stays within the limit.\n+* ``COMPILER_ERROR``: Resolve if checksum fails with this error. If a control query has too many\n+  columns, generated checksum query might be too large in certain cases.\n+\n+Extending Verifier\n+------------------\n+\n+Verifier can be extended for further behavioral changes in additional to configuration properties.\n+\n+`AbstractVerifyCommand <https://github.com/prestodb/presto/blob/master/presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerifyCommand.java>`_\n+shows the components that be extended. Implement the abstract class and create a command line wrapper similar to\n+`PrestoVerifier <https://github.com/prestodb/presto/blob/master/presto-verifier/src/main/java/com/facebook/presto/verifier/PrestoVerifier.java>`_.\n+\n+\n+Configuration Reference\n+-----------------------\n+\n+General Configuration\n+~~~~~~~~~~~~~~~~~~~~~\n+\n+=========================================== ===============================================================================\n+Name                                        Description\n+=========================================== ===============================================================================\n+``whitelist``                               A comma-separated list specifying the names of the queries within the suite\n+                                            to verify.\n+``blacklist``                               A comma-separated list specifying the names of the queries to be excluded\n+                                            from suite. ``blacklist`` is applied after ``whitelist``.\n+``source-query-supplier``                   The name of the source query supplier. Supports ``mysql``.\n+``source-query.table-name``                 The name of table that holds verifier queries. Available only when\n+                                            ``source-query-supplier`` is ``mysql``.\n+``event-clients``                           A comma-separated list specifying where the output events should be emitted.\n+                                            Supports ``json`` and ``human-readable``.\n+``json.log-file``                           The output files of ``JSON`` events. If not set, ``JSON`` events are emitted to\n+                                            ``stdout``.\n+``human-readable.log-file``                 The output files for human-readable events. If not set, human-readable events\n+                                            are emitted to ``stdout``.\n+``test-id``                                 A String to be attached with output events.\n+``max-concurrency``                         Maximum number of concurrent verifications.\n+``suite-repetition``                        Number of time a suite is verified.\n+``query-repetition``                        Number of time a source query is verified.", "originalCommit": "82a92fa026e577b6af8b53f53453de501dd8557a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2ODg0Ng==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r384868846", "bodyText": "typo: \"Maximum number of time\" -> \"A limit on how many times\"", "author": "mbasmanova", "createdAt": "2020-02-27T01:40:24Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,257 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.\n+\n+* **Importing Source Queries**\n+   * Read the list of source queries (query pairs with configuration) from the MySQL table.\n+\n+* **Query Pre-processing and Filtering**\n+   * Apply overrides to the catalog, schema, username, and password of each query.\n+   * Filter queries according to whitelist and blacklist. Whitelist is applied before blacklist.\n+   * Filter out queries with invalid syntax.\n+   * Filter out queries not supported for validation. ``Select``, ``Insert``, and ``CreateTableAsSelect`` are supported.\n+\n+* **Query rewriting**\n+    * Rewrite queries before execution to ensure that production data is not modified.\n+    * Rewrite ``Select`` queries to ``CreateTableAsSelect``\n+       * Column names are determined by running the ``Select`` query with ``LIMIT 0``.\n+       * Artificial name are used for unnamed columns.\n+    * Rewrite ``Insert`` and ``CreateTableAsSelect`` queries to have their table names replaced.\n+       * Construct a setup query to create the table necessary for a ``Insert`` query.\n+\n+* **Query Execution**\n+    * Conceptually, Verifier is configured with a control cluster and a test cluster. However, they\n+      may be pointed to the same Presto cluster for certain tests.\n+    * For each source query, execute the following queries in order.\n+        * Control setup queries\n+        * Control query\n+        * Test setup queries\n+        * Test query\n+        * Control and Test teardown\n+    * Queries are subject to timeouts and retries.\n+        * Cluster connection failures and transient Presto failures are retried.\n+        * Query retries may conceal reliability issues. All occurred Presto query failures, including the retries ones, are recorded.\n+    * Certain query failures are automatically submitted for re-validation, such as partition dropped or table dropped during query.\n+    * See `Failure Resolution`_ for automatic resolving query failures.\n+\n+* **Results Comparison**\n+    * For ``Select``, ``Insert``, and ``CreateTableAsSelect`` queries, results are written into temporary tables.\n+    * Construct and run the checksum queries for both control and test.\n+    * Verify table schema and row count are the same for the control and the test result table.\n+    * Verify checksums are matching for each column. See `Column Checksums`_ for special handling of different column types.\n+    * See `Determinism`_ for handling of non-deterministic queries.\n+\n+* **Emitting Results**\n+    * Verification results can be exported as ``JSON``, or human readable text.\n+\n+Column Checksums\n+----------------\n+For each column in the control/test query, one or more columns maybe generated in the checksum\n+queries.\n+\n+* **Floating Point Columns**\n+    * For ``DOUBLE`` and ``REAL`` columns, 4 columns are generated for verification:\n+       * Sum of the finite values of the column\n+       * ``NAN`` count of the column\n+       * Positive infinity count of the column\n+       * Negative infinity count of the column\n+    * Check if ``NAN`` count, positive and negative infinity count matches.\n+    * Check the nullity of control sum and test sum.\n+    * If either control mean or test mean very close 0, check if both are close to 0.\n+    * Check the relative error between control sum and test sum.\n+* **Array Columns**\n+    * 2 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Array checksum\n+    * For an array column ``arr`` of type ``array(E)``:\n+       * If ``E`` is not orderable, array checksum is ``checksum(arr)``.\n+       * If ``E`` is orderable, array checksum ``coalesce(checksum(try(array_sort(arr))), checksum(arr))``.\n+* **Map Columns**\n+    * 4 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Checksum of the map\n+       * Array checksum of the kep set\n+       * Array checksum of the value set\n+* **Row Columns**\n+    * Checksum row fields recursively, as according to the type of the fields.\n+* For all other column types, generate a simple checksum using the :func:`checksum` function.\n+\n+Determinism\n+-----------\n+A result mismatch, either a row count mismatch or a column mismatch, can be caused by\n+non-deterministic query features. To avoid false alerts, we perform determinism analysis\n+for the control query. If a query is found non-deterministic, we skip the verification as it\n+does not provide insights.\n+\n+Determinism analysis follows the following steps. If a query is found non-deterministic at any\n+point, the analysis will conclude.\n+\n+* A list of non-deterministic catalogs can be specified. If a query references any table from a\n+  non-deterministic catalog, the query is considered non-deterministic.\n+* Run the control query again, and the compare the results with the initial control query run.\n+* If a query has a ``LIMIT n`` clause but no ``ORDER BY`` clause at the top level:\n+   * Run a query to count the number of rows produced by the control query without the ``LIMIT`` clause.\n+   * If the resulting row count is greater than ``n``, treat the control query as non-deterministic.\n+\n+Failure Resolution\n+------------------\n+The difference in configuration, including cluster size, can cause a query to succeed on the\n+control cluster but fail on the test cluster. A checksum query can also fail, which may be due to\n+limitation of Presto or Presto Verifier. Thus, we allow Verifier to automatically resolve certain\n+query failures.\n+\n+* ``EXCEEDED_GLOBAL_MEMORY_LIMIT``: Resolve if the control query uses more memory than the test query.\n+* ``EXCEEDED_TIME_LIMIT``: Resolve unconditionally.\n+* ``TOO_MANY_HIVE_PARTITIONS``: Resolve if the test cluster do not have enough worker to make sure the\n+  number of partitions assigned to each worker stays within the limit.\n+* ``COMPILER_ERROR``: Resolve if checksum fails with this error. If a control query has too many\n+  columns, generated checksum query might be too large in certain cases.\n+\n+Extending Verifier\n+------------------\n+\n+Verifier can be extended for further behavioral changes in additional to configuration properties.\n+\n+`AbstractVerifyCommand <https://github.com/prestodb/presto/blob/master/presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerifyCommand.java>`_\n+shows the components that be extended. Implement the abstract class and create a command line wrapper similar to\n+`PrestoVerifier <https://github.com/prestodb/presto/blob/master/presto-verifier/src/main/java/com/facebook/presto/verifier/PrestoVerifier.java>`_.\n+\n+\n+Configuration Reference\n+-----------------------\n+\n+General Configuration\n+~~~~~~~~~~~~~~~~~~~~~\n+\n+=========================================== ===============================================================================\n+Name                                        Description\n+=========================================== ===============================================================================\n+``whitelist``                               A comma-separated list specifying the names of the queries within the suite\n+                                            to verify.\n+``blacklist``                               A comma-separated list specifying the names of the queries to be excluded\n+                                            from suite. ``blacklist`` is applied after ``whitelist``.\n+``source-query-supplier``                   The name of the source query supplier. Supports ``mysql``.\n+``source-query.table-name``                 The name of table that holds verifier queries. Available only when\n+                                            ``source-query-supplier`` is ``mysql``.\n+``event-clients``                           A comma-separated list specifying where the output events should be emitted.\n+                                            Supports ``json`` and ``human-readable``.\n+``json.log-file``                           The output files of ``JSON`` events. If not set, ``JSON`` events are emitted to\n+                                            ``stdout``.\n+``human-readable.log-file``                 The output files for human-readable events. If not set, human-readable events\n+                                            are emitted to ``stdout``.\n+``test-id``                                 A String to be attached with output events.\n+``max-concurrency``                         Maximum number of concurrent verifications.\n+``suite-repetition``                        Number of time a suite is verified.\n+``query-repetition``                        Number of time a source query is verified.\n+``relative-error-margin``                   Maximum tolerable relative error between control sum and test sum of a\n+                                            floating point column.\n+``absolute-error-margin``                   Floating point averages that are below this threshold are treated as ``0``.\n+``run-teardown-on-result-mismatch``         Whether to run teardown query in case of result mismatch.\n+``verification-resubmission.limit``         Maximum number of time a source query can be re-submitted for verification.", "originalCommit": "82a92fa026e577b6af8b53f53453de501dd8557a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2OTA2Nw==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r384869067", "bodyText": "Http -> HTTP", "author": "mbasmanova", "createdAt": "2020-02-27T01:41:10Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,257 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.\n+\n+* **Importing Source Queries**\n+   * Read the list of source queries (query pairs with configuration) from the MySQL table.\n+\n+* **Query Pre-processing and Filtering**\n+   * Apply overrides to the catalog, schema, username, and password of each query.\n+   * Filter queries according to whitelist and blacklist. Whitelist is applied before blacklist.\n+   * Filter out queries with invalid syntax.\n+   * Filter out queries not supported for validation. ``Select``, ``Insert``, and ``CreateTableAsSelect`` are supported.\n+\n+* **Query rewriting**\n+    * Rewrite queries before execution to ensure that production data is not modified.\n+    * Rewrite ``Select`` queries to ``CreateTableAsSelect``\n+       * Column names are determined by running the ``Select`` query with ``LIMIT 0``.\n+       * Artificial name are used for unnamed columns.\n+    * Rewrite ``Insert`` and ``CreateTableAsSelect`` queries to have their table names replaced.\n+       * Construct a setup query to create the table necessary for a ``Insert`` query.\n+\n+* **Query Execution**\n+    * Conceptually, Verifier is configured with a control cluster and a test cluster. However, they\n+      may be pointed to the same Presto cluster for certain tests.\n+    * For each source query, execute the following queries in order.\n+        * Control setup queries\n+        * Control query\n+        * Test setup queries\n+        * Test query\n+        * Control and Test teardown\n+    * Queries are subject to timeouts and retries.\n+        * Cluster connection failures and transient Presto failures are retried.\n+        * Query retries may conceal reliability issues. All occurred Presto query failures, including the retries ones, are recorded.\n+    * Certain query failures are automatically submitted for re-validation, such as partition dropped or table dropped during query.\n+    * See `Failure Resolution`_ for automatic resolving query failures.\n+\n+* **Results Comparison**\n+    * For ``Select``, ``Insert``, and ``CreateTableAsSelect`` queries, results are written into temporary tables.\n+    * Construct and run the checksum queries for both control and test.\n+    * Verify table schema and row count are the same for the control and the test result table.\n+    * Verify checksums are matching for each column. See `Column Checksums`_ for special handling of different column types.\n+    * See `Determinism`_ for handling of non-deterministic queries.\n+\n+* **Emitting Results**\n+    * Verification results can be exported as ``JSON``, or human readable text.\n+\n+Column Checksums\n+----------------\n+For each column in the control/test query, one or more columns maybe generated in the checksum\n+queries.\n+\n+* **Floating Point Columns**\n+    * For ``DOUBLE`` and ``REAL`` columns, 4 columns are generated for verification:\n+       * Sum of the finite values of the column\n+       * ``NAN`` count of the column\n+       * Positive infinity count of the column\n+       * Negative infinity count of the column\n+    * Check if ``NAN`` count, positive and negative infinity count matches.\n+    * Check the nullity of control sum and test sum.\n+    * If either control mean or test mean very close 0, check if both are close to 0.\n+    * Check the relative error between control sum and test sum.\n+* **Array Columns**\n+    * 2 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Array checksum\n+    * For an array column ``arr`` of type ``array(E)``:\n+       * If ``E`` is not orderable, array checksum is ``checksum(arr)``.\n+       * If ``E`` is orderable, array checksum ``coalesce(checksum(try(array_sort(arr))), checksum(arr))``.\n+* **Map Columns**\n+    * 4 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Checksum of the map\n+       * Array checksum of the kep set\n+       * Array checksum of the value set\n+* **Row Columns**\n+    * Checksum row fields recursively, as according to the type of the fields.\n+* For all other column types, generate a simple checksum using the :func:`checksum` function.\n+\n+Determinism\n+-----------\n+A result mismatch, either a row count mismatch or a column mismatch, can be caused by\n+non-deterministic query features. To avoid false alerts, we perform determinism analysis\n+for the control query. If a query is found non-deterministic, we skip the verification as it\n+does not provide insights.\n+\n+Determinism analysis follows the following steps. If a query is found non-deterministic at any\n+point, the analysis will conclude.\n+\n+* A list of non-deterministic catalogs can be specified. If a query references any table from a\n+  non-deterministic catalog, the query is considered non-deterministic.\n+* Run the control query again, and the compare the results with the initial control query run.\n+* If a query has a ``LIMIT n`` clause but no ``ORDER BY`` clause at the top level:\n+   * Run a query to count the number of rows produced by the control query without the ``LIMIT`` clause.\n+   * If the resulting row count is greater than ``n``, treat the control query as non-deterministic.\n+\n+Failure Resolution\n+------------------\n+The difference in configuration, including cluster size, can cause a query to succeed on the\n+control cluster but fail on the test cluster. A checksum query can also fail, which may be due to\n+limitation of Presto or Presto Verifier. Thus, we allow Verifier to automatically resolve certain\n+query failures.\n+\n+* ``EXCEEDED_GLOBAL_MEMORY_LIMIT``: Resolve if the control query uses more memory than the test query.\n+* ``EXCEEDED_TIME_LIMIT``: Resolve unconditionally.\n+* ``TOO_MANY_HIVE_PARTITIONS``: Resolve if the test cluster do not have enough worker to make sure the\n+  number of partitions assigned to each worker stays within the limit.\n+* ``COMPILER_ERROR``: Resolve if checksum fails with this error. If a control query has too many\n+  columns, generated checksum query might be too large in certain cases.\n+\n+Extending Verifier\n+------------------\n+\n+Verifier can be extended for further behavioral changes in additional to configuration properties.\n+\n+`AbstractVerifyCommand <https://github.com/prestodb/presto/blob/master/presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerifyCommand.java>`_\n+shows the components that be extended. Implement the abstract class and create a command line wrapper similar to\n+`PrestoVerifier <https://github.com/prestodb/presto/blob/master/presto-verifier/src/main/java/com/facebook/presto/verifier/PrestoVerifier.java>`_.\n+\n+\n+Configuration Reference\n+-----------------------\n+\n+General Configuration\n+~~~~~~~~~~~~~~~~~~~~~\n+\n+=========================================== ===============================================================================\n+Name                                        Description\n+=========================================== ===============================================================================\n+``whitelist``                               A comma-separated list specifying the names of the queries within the suite\n+                                            to verify.\n+``blacklist``                               A comma-separated list specifying the names of the queries to be excluded\n+                                            from suite. ``blacklist`` is applied after ``whitelist``.\n+``source-query-supplier``                   The name of the source query supplier. Supports ``mysql``.\n+``source-query.table-name``                 The name of table that holds verifier queries. Available only when\n+                                            ``source-query-supplier`` is ``mysql``.\n+``event-clients``                           A comma-separated list specifying where the output events should be emitted.\n+                                            Supports ``json`` and ``human-readable``.\n+``json.log-file``                           The output files of ``JSON`` events. If not set, ``JSON`` events are emitted to\n+                                            ``stdout``.\n+``human-readable.log-file``                 The output files for human-readable events. If not set, human-readable events\n+                                            are emitted to ``stdout``.\n+``test-id``                                 A String to be attached with output events.\n+``max-concurrency``                         Maximum number of concurrent verifications.\n+``suite-repetition``                        Number of time a suite is verified.\n+``query-repetition``                        Number of time a source query is verified.\n+``relative-error-margin``                   Maximum tolerable relative error between control sum and test sum of a\n+                                            floating point column.\n+``absolute-error-margin``                   Floating point averages that are below this threshold are treated as ``0``.\n+``run-teardown-on-result-mismatch``         Whether to run teardown query in case of result mismatch.\n+``verification-resubmission.limit``         Maximum number of time a source query can be re-submitted for verification.\n+=========================================== ===============================================================================\n+\n+\n+Query Override Configuration\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+The following configurations controls the behavior of query metadata modification before verification starts.\n+Counterparts are also available for test queries with prefix ``control`` being replaced with ``test``.\n+\n+================================================ ===============================================================================\n+Name                                             Description\n+================================================ ===============================================================================\n+``control.catalog-override``                     The catalog to be applied to all queries if specified.\n+``control.schema-override``                      The schema to be applied to all queries if specified.\n+``control.username-override``                    The username to be applied to all queries if specified.\n+``control.password-override``                    The password to be applied to all queries if specified.\n+``control.session-properties-override-strategy`` Supports 3 values. ``NO_ACTION``: Use the session properties as specified for\n+                                                 each query. ``OVERRIDE``: Merge the session properties of each query with the\n+                                                 override, with override being the dominant. ``SUBSTITUTE``, The session\n+                                                 properties of each query is replaced with the override.\n+``control.session-properties-override``          The session property to be applied to all queries.\n+================================================ ===============================================================================\n+\n+Query Execution Configuration\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+The following configurations controls the behavior of query execution on the control cluster.\n+Counterparts are also available for test clusters with prefix ``control`` being replaced with ``test``.\n+\n+=========================================== ===============================================================================\n+Name                                        Description\n+=========================================== ===============================================================================\n+``control.host``                            Host of the control cluster.\n+``control.jdbc-port``                       JDBC port of the control cluster.\n+``control.http-host``                       Http port of the control cluster.", "originalCommit": "82a92fa026e577b6af8b53f53453de501dd8557a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDg2OTE4MA==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r384869180", "bodyText": "addition -> additional", "author": "mbasmanova", "createdAt": "2020-02-27T01:41:32Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,257 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.\n+\n+* **Importing Source Queries**\n+   * Read the list of source queries (query pairs with configuration) from the MySQL table.\n+\n+* **Query Pre-processing and Filtering**\n+   * Apply overrides to the catalog, schema, username, and password of each query.\n+   * Filter queries according to whitelist and blacklist. Whitelist is applied before blacklist.\n+   * Filter out queries with invalid syntax.\n+   * Filter out queries not supported for validation. ``Select``, ``Insert``, and ``CreateTableAsSelect`` are supported.\n+\n+* **Query rewriting**\n+    * Rewrite queries before execution to ensure that production data is not modified.\n+    * Rewrite ``Select`` queries to ``CreateTableAsSelect``\n+       * Column names are determined by running the ``Select`` query with ``LIMIT 0``.\n+       * Artificial name are used for unnamed columns.\n+    * Rewrite ``Insert`` and ``CreateTableAsSelect`` queries to have their table names replaced.\n+       * Construct a setup query to create the table necessary for a ``Insert`` query.\n+\n+* **Query Execution**\n+    * Conceptually, Verifier is configured with a control cluster and a test cluster. However, they\n+      may be pointed to the same Presto cluster for certain tests.\n+    * For each source query, execute the following queries in order.\n+        * Control setup queries\n+        * Control query\n+        * Test setup queries\n+        * Test query\n+        * Control and Test teardown\n+    * Queries are subject to timeouts and retries.\n+        * Cluster connection failures and transient Presto failures are retried.\n+        * Query retries may conceal reliability issues. All occurred Presto query failures, including the retries ones, are recorded.\n+    * Certain query failures are automatically submitted for re-validation, such as partition dropped or table dropped during query.\n+    * See `Failure Resolution`_ for automatic resolving query failures.\n+\n+* **Results Comparison**\n+    * For ``Select``, ``Insert``, and ``CreateTableAsSelect`` queries, results are written into temporary tables.\n+    * Construct and run the checksum queries for both control and test.\n+    * Verify table schema and row count are the same for the control and the test result table.\n+    * Verify checksums are matching for each column. See `Column Checksums`_ for special handling of different column types.\n+    * See `Determinism`_ for handling of non-deterministic queries.\n+\n+* **Emitting Results**\n+    * Verification results can be exported as ``JSON``, or human readable text.\n+\n+Column Checksums\n+----------------\n+For each column in the control/test query, one or more columns maybe generated in the checksum\n+queries.\n+\n+* **Floating Point Columns**\n+    * For ``DOUBLE`` and ``REAL`` columns, 4 columns are generated for verification:\n+       * Sum of the finite values of the column\n+       * ``NAN`` count of the column\n+       * Positive infinity count of the column\n+       * Negative infinity count of the column\n+    * Check if ``NAN`` count, positive and negative infinity count matches.\n+    * Check the nullity of control sum and test sum.\n+    * If either control mean or test mean very close 0, check if both are close to 0.\n+    * Check the relative error between control sum and test sum.\n+* **Array Columns**\n+    * 2 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Array checksum\n+    * For an array column ``arr`` of type ``array(E)``:\n+       * If ``E`` is not orderable, array checksum is ``checksum(arr)``.\n+       * If ``E`` is orderable, array checksum ``coalesce(checksum(try(array_sort(arr))), checksum(arr))``.\n+* **Map Columns**\n+    * 4 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Checksum of the map\n+       * Array checksum of the kep set\n+       * Array checksum of the value set\n+* **Row Columns**\n+    * Checksum row fields recursively, as according to the type of the fields.\n+* For all other column types, generate a simple checksum using the :func:`checksum` function.\n+\n+Determinism\n+-----------\n+A result mismatch, either a row count mismatch or a column mismatch, can be caused by\n+non-deterministic query features. To avoid false alerts, we perform determinism analysis\n+for the control query. If a query is found non-deterministic, we skip the verification as it\n+does not provide insights.\n+\n+Determinism analysis follows the following steps. If a query is found non-deterministic at any\n+point, the analysis will conclude.\n+\n+* A list of non-deterministic catalogs can be specified. If a query references any table from a\n+  non-deterministic catalog, the query is considered non-deterministic.\n+* Run the control query again, and the compare the results with the initial control query run.\n+* If a query has a ``LIMIT n`` clause but no ``ORDER BY`` clause at the top level:\n+   * Run a query to count the number of rows produced by the control query without the ``LIMIT`` clause.\n+   * If the resulting row count is greater than ``n``, treat the control query as non-deterministic.\n+\n+Failure Resolution\n+------------------\n+The difference in configuration, including cluster size, can cause a query to succeed on the\n+control cluster but fail on the test cluster. A checksum query can also fail, which may be due to\n+limitation of Presto or Presto Verifier. Thus, we allow Verifier to automatically resolve certain\n+query failures.\n+\n+* ``EXCEEDED_GLOBAL_MEMORY_LIMIT``: Resolve if the control query uses more memory than the test query.\n+* ``EXCEEDED_TIME_LIMIT``: Resolve unconditionally.\n+* ``TOO_MANY_HIVE_PARTITIONS``: Resolve if the test cluster do not have enough worker to make sure the\n+  number of partitions assigned to each worker stays within the limit.\n+* ``COMPILER_ERROR``: Resolve if checksum fails with this error. If a control query has too many\n+  columns, generated checksum query might be too large in certain cases.\n+\n+Extending Verifier\n+------------------\n+\n+Verifier can be extended for further behavioral changes in additional to configuration properties.\n+\n+`AbstractVerifyCommand <https://github.com/prestodb/presto/blob/master/presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerifyCommand.java>`_\n+shows the components that be extended. Implement the abstract class and create a command line wrapper similar to\n+`PrestoVerifier <https://github.com/prestodb/presto/blob/master/presto-verifier/src/main/java/com/facebook/presto/verifier/PrestoVerifier.java>`_.\n+\n+\n+Configuration Reference\n+-----------------------\n+\n+General Configuration\n+~~~~~~~~~~~~~~~~~~~~~\n+\n+=========================================== ===============================================================================\n+Name                                        Description\n+=========================================== ===============================================================================\n+``whitelist``                               A comma-separated list specifying the names of the queries within the suite\n+                                            to verify.\n+``blacklist``                               A comma-separated list specifying the names of the queries to be excluded\n+                                            from suite. ``blacklist`` is applied after ``whitelist``.\n+``source-query-supplier``                   The name of the source query supplier. Supports ``mysql``.\n+``source-query.table-name``                 The name of table that holds verifier queries. Available only when\n+                                            ``source-query-supplier`` is ``mysql``.\n+``event-clients``                           A comma-separated list specifying where the output events should be emitted.\n+                                            Supports ``json`` and ``human-readable``.\n+``json.log-file``                           The output files of ``JSON`` events. If not set, ``JSON`` events are emitted to\n+                                            ``stdout``.\n+``human-readable.log-file``                 The output files for human-readable events. If not set, human-readable events\n+                                            are emitted to ``stdout``.\n+``test-id``                                 A String to be attached with output events.\n+``max-concurrency``                         Maximum number of concurrent verifications.\n+``suite-repetition``                        Number of time a suite is verified.\n+``query-repetition``                        Number of time a source query is verified.\n+``relative-error-margin``                   Maximum tolerable relative error between control sum and test sum of a\n+                                            floating point column.\n+``absolute-error-margin``                   Floating point averages that are below this threshold are treated as ``0``.\n+``run-teardown-on-result-mismatch``         Whether to run teardown query in case of result mismatch.\n+``verification-resubmission.limit``         Maximum number of time a source query can be re-submitted for verification.\n+=========================================== ===============================================================================\n+\n+\n+Query Override Configuration\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+The following configurations controls the behavior of query metadata modification before verification starts.\n+Counterparts are also available for test queries with prefix ``control`` being replaced with ``test``.\n+\n+================================================ ===============================================================================\n+Name                                             Description\n+================================================ ===============================================================================\n+``control.catalog-override``                     The catalog to be applied to all queries if specified.\n+``control.schema-override``                      The schema to be applied to all queries if specified.\n+``control.username-override``                    The username to be applied to all queries if specified.\n+``control.password-override``                    The password to be applied to all queries if specified.\n+``control.session-properties-override-strategy`` Supports 3 values. ``NO_ACTION``: Use the session properties as specified for\n+                                                 each query. ``OVERRIDE``: Merge the session properties of each query with the\n+                                                 override, with override being the dominant. ``SUBSTITUTE``, The session\n+                                                 properties of each query is replaced with the override.\n+``control.session-properties-override``          The session property to be applied to all queries.\n+================================================ ===============================================================================\n+\n+Query Execution Configuration\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+The following configurations controls the behavior of query execution on the control cluster.\n+Counterparts are also available for test clusters with prefix ``control`` being replaced with ``test``.\n+\n+=========================================== ===============================================================================\n+Name                                        Description\n+=========================================== ===============================================================================\n+``control.host``                            Host of the control cluster.\n+``control.jdbc-port``                       JDBC port of the control cluster.\n+``control.http-host``                       Http port of the control cluster.\n+``control.jdbc-url-parameters``             A ``JSON`` map representing the additional URL parameters for control JDBC.\n+``control.query-timeout``                   The execution time limit of the control and the test queries.\n+``control.metadata-timeout``                The execution time limit of ``DESC`` queries and ``LIMIT 0`` queries.\n+``control.checksum-timeout``                The execution time limit of checksum queries.\n+=========================================== ===============================================================================\n+\n+Determinism Analyzer Configuration\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+=========================================== ===============================================================================\n+Name                                        Description\n+=========================================== ===============================================================================\n+``determinism.run-teardown``                Whether to run teardown queries for tables produced in determinism analysis.\n+``determinism.max-analysis-runs``           Maximum number of addition control runs to check for the determinism of the", "originalCommit": "82a92fa026e577b6af8b53f53453de501dd8557a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cc54e40b364c2db7e430603afdd2169cd843d26e", "url": "https://github.com/prestodb/presto/commit/cc54e40b364c2db7e430603afdd2169cd843d26e", "message": "Update Verifier documentation", "committedDate": "2020-02-27T07:53:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIxNjkxNg==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r385216916", "bodyText": "nit: produce -> produces", "author": "rschlussel", "createdAt": "2020-02-27T16:21:17Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,258 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have", "originalCommit": "cc54e40b364c2db7e430603afdd2169cd843d26e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIxNzA3OQ==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r385217079", "bodyText": "ran -> run", "author": "rschlussel", "createdAt": "2020-02-27T16:21:31Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,258 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.", "originalCommit": "cc54e40b364c2db7e430603afdd2169cd843d26e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIxOTkxNg==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r385219916", "bodyText": "additional -> addition", "author": "rschlussel", "createdAt": "2020-02-27T16:25:40Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,258 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.\n+\n+* **Importing Source Queries**\n+   * Read the list of source queries (query pairs with configuration) from the MySQL table.\n+\n+* **Query Pre-processing and Filtering**\n+   * Apply overrides to the catalog, schema, username, and password of each query.\n+   * Filter queries according to whitelist and blacklist. Whitelist is applied before blacklist.\n+   * Filter out queries with invalid syntax.\n+   * Filter out queries not supported for validation. ``Select``, ``Insert``, and ``CreateTableAsSelect`` are supported.\n+\n+* **Query rewriting**\n+    * Rewrite queries before execution to ensure that production data is not modified.\n+    * Rewrite ``Select`` queries to ``CreateTableAsSelect``\n+       * Column names are determined by running the ``Select`` query with ``LIMIT 0``.\n+       * Artificial names are used for unnamed columns.\n+    * Rewrite ``Insert`` and ``CreateTableAsSelect`` queries to have their table names replaced.\n+       * Construct a setup query to create the table necessary for an ``Insert`` query.\n+\n+* **Query Execution**\n+    * Conceptually, Verifier is configured with a control cluster and a test cluster. However, they\n+      may be pointed to the same Presto cluster for certain tests.\n+    * For each source query, execute the following queries in order.\n+        * Control setup queries\n+        * Control query\n+        * Test setup queries\n+        * Test query\n+        * Control and Test teardown\n+    * Queries are subject to timeouts and retries.\n+        * Cluster connection failures and transient Presto failures are retried.\n+        * Query retries may conceal reliability issues. All occurred Presto query failures, including the retries, are recorded.\n+    * Certain query failures are automatically submitted for re-validation, such as partition dropped or table dropped during query.\n+    * See `Failure Resolution`_ for auto-resolving of query failures.\n+\n+* **Results Comparison**\n+    * For ``Select``, ``Insert``, and ``CreateTableAsSelect`` queries, results are written into temporary tables.\n+    * Construct and run the checksum queries for both control and test.\n+    * Verify table schema and row count are the same for the control and the test result table.\n+    * Verify checksums are matching for each column. See `Column Checksums`_ for special handling of different column types.\n+    * See `Determinism`_ for handling of non-deterministic queries.\n+\n+* **Emitting Results**\n+    * Verification results can be exported as ``JSON``, or human readable text.\n+\n+Column Checksums\n+----------------\n+For each column in the control/test query, one or more columns are generated in the checksum\n+queries.\n+\n+* **Floating Point Columns**\n+    * For ``DOUBLE`` and ``REAL`` columns, 4 columns are generated for verification:\n+       * Sum of the finite values of the column\n+       * ``NAN`` count of the column\n+       * Positive infinity count of the column\n+       * Negative infinity count of the column\n+    * Check if ``NAN`` count, positive and negative infinity count matches.\n+    * Check the nullity of control sum and test sum.\n+    * If either control mean or test mean very close 0, check if both are close to 0.\n+    * Check the relative error between control sum and test sum.\n+* **Array Columns**\n+    * 2 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Array checksum\n+    * For an array column ``arr`` of type ``array(E)``:\n+       * If ``E`` is not orderable, array checksum is ``checksum(arr)``.\n+       * If ``E`` is orderable, array checksum ``coalesce(checksum(try(array_sort(arr))), checksum(arr))``.\n+* **Map Columns**\n+    * 4 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Checksum of the map\n+       * Array checksum of the key set\n+       * Array checksum of the value set\n+* **Row Columns**\n+    * Checksum row fields recursively according to the type of the fields.\n+* For all other column types, generate a simple checksum using the :func:`checksum` function.\n+\n+Determinism\n+-----------\n+A result mismatch, either a row count mismatch or a column mismatch, can be caused by\n+non-deterministic query features. To avoid false alerts, we perform determinism analysis\n+for the control query. If a query is found non-deterministic, we skip the verification as it\n+does not provide insights.\n+\n+Determinism analysis follows the following steps. If a query is found non-deterministic at any\n+point, the analysis will conclude.\n+\n+* Non-deterministic catalogs can be specified with ``determinism.non-deterministic-catalog``.\n+  If a query references any table from those catalogs, the query is considered non-deterministic.\n+* Run the control query again and compare the results with the initial control query run.\n+* If a query has a ``LIMIT n`` clause but no ``ORDER BY`` clause at the top level:\n+   * Run a query to count the number of rows produced by the control query without the ``LIMIT`` clause.\n+   * If the resulting row count is greater than ``n``, treat the control query as non-deterministic.\n+\n+Failure Resolution\n+------------------\n+The difference in configuration, including cluster size, can cause a query to succeed on the\n+control cluster but fail on the test cluster. A checksum query can also fail, which may be due to\n+limitation of Presto or Presto Verifier. Thus, we allow Verifier to automatically resolve certain\n+query failures.\n+\n+* ``EXCEEDED_GLOBAL_MEMORY_LIMIT``: Resolve if the control query uses more memory than the test\n+  query.\n+* ``EXCEEDED_TIME_LIMIT``: Resolve unconditionally.\n+* ``TOO_MANY_HIVE_PARTITIONS``: Resolve if the test cluster does not have enough workers to make\n+  sure the number of partitions assigned to each worker stays within the limit.\n+* ``COMPILER_ERROR``: Resolve if checksum fails with this error. If a control query has too many\n+  columns, generated checksum query might be too large in certain cases.\n+\n+Extending Verifier\n+------------------\n+\n+Verifier can be extended for further behavioral changes in additional to configuration properties.", "originalCommit": "cc54e40b364c2db7e430603afdd2169cd843d26e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIyNjQ5NQ==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r385226495", "bodyText": "I think using the imperative mood (read, apply, rewrite) for these descriptions is a bit confusing because it's not clear when you're instructing the user to do something vs. when you're just describing what the verifier does. It would be helpful if when you're describing what the verifier does you just used present tense (e.g. Reads the list of source queries, Applies overrides to the catalog, ...), and only use imperative if you're instructing the user to do something (e.g. set up the mysql database)", "author": "rschlussel", "createdAt": "2020-02-27T16:35:24Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,258 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.", "originalCommit": "cc54e40b364c2db7e430603afdd2169cd843d26e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIyNzM5OQ==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r385227399", "bodyText": "controls -> control", "author": "rschlussel", "createdAt": "2020-02-27T16:36:45Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,258 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.\n+\n+* **Importing Source Queries**\n+   * Read the list of source queries (query pairs with configuration) from the MySQL table.\n+\n+* **Query Pre-processing and Filtering**\n+   * Apply overrides to the catalog, schema, username, and password of each query.\n+   * Filter queries according to whitelist and blacklist. Whitelist is applied before blacklist.\n+   * Filter out queries with invalid syntax.\n+   * Filter out queries not supported for validation. ``Select``, ``Insert``, and ``CreateTableAsSelect`` are supported.\n+\n+* **Query rewriting**\n+    * Rewrite queries before execution to ensure that production data is not modified.\n+    * Rewrite ``Select`` queries to ``CreateTableAsSelect``\n+       * Column names are determined by running the ``Select`` query with ``LIMIT 0``.\n+       * Artificial names are used for unnamed columns.\n+    * Rewrite ``Insert`` and ``CreateTableAsSelect`` queries to have their table names replaced.\n+       * Construct a setup query to create the table necessary for an ``Insert`` query.\n+\n+* **Query Execution**\n+    * Conceptually, Verifier is configured with a control cluster and a test cluster. However, they\n+      may be pointed to the same Presto cluster for certain tests.\n+    * For each source query, execute the following queries in order.\n+        * Control setup queries\n+        * Control query\n+        * Test setup queries\n+        * Test query\n+        * Control and Test teardown\n+    * Queries are subject to timeouts and retries.\n+        * Cluster connection failures and transient Presto failures are retried.\n+        * Query retries may conceal reliability issues. All occurred Presto query failures, including the retries, are recorded.\n+    * Certain query failures are automatically submitted for re-validation, such as partition dropped or table dropped during query.\n+    * See `Failure Resolution`_ for auto-resolving of query failures.\n+\n+* **Results Comparison**\n+    * For ``Select``, ``Insert``, and ``CreateTableAsSelect`` queries, results are written into temporary tables.\n+    * Construct and run the checksum queries for both control and test.\n+    * Verify table schema and row count are the same for the control and the test result table.\n+    * Verify checksums are matching for each column. See `Column Checksums`_ for special handling of different column types.\n+    * See `Determinism`_ for handling of non-deterministic queries.\n+\n+* **Emitting Results**\n+    * Verification results can be exported as ``JSON``, or human readable text.\n+\n+Column Checksums\n+----------------\n+For each column in the control/test query, one or more columns are generated in the checksum\n+queries.\n+\n+* **Floating Point Columns**\n+    * For ``DOUBLE`` and ``REAL`` columns, 4 columns are generated for verification:\n+       * Sum of the finite values of the column\n+       * ``NAN`` count of the column\n+       * Positive infinity count of the column\n+       * Negative infinity count of the column\n+    * Check if ``NAN`` count, positive and negative infinity count matches.\n+    * Check the nullity of control sum and test sum.\n+    * If either control mean or test mean very close 0, check if both are close to 0.\n+    * Check the relative error between control sum and test sum.\n+* **Array Columns**\n+    * 2 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Array checksum\n+    * For an array column ``arr`` of type ``array(E)``:\n+       * If ``E`` is not orderable, array checksum is ``checksum(arr)``.\n+       * If ``E`` is orderable, array checksum ``coalesce(checksum(try(array_sort(arr))), checksum(arr))``.\n+* **Map Columns**\n+    * 4 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Checksum of the map\n+       * Array checksum of the key set\n+       * Array checksum of the value set\n+* **Row Columns**\n+    * Checksum row fields recursively according to the type of the fields.\n+* For all other column types, generate a simple checksum using the :func:`checksum` function.\n+\n+Determinism\n+-----------\n+A result mismatch, either a row count mismatch or a column mismatch, can be caused by\n+non-deterministic query features. To avoid false alerts, we perform determinism analysis\n+for the control query. If a query is found non-deterministic, we skip the verification as it\n+does not provide insights.\n+\n+Determinism analysis follows the following steps. If a query is found non-deterministic at any\n+point, the analysis will conclude.\n+\n+* Non-deterministic catalogs can be specified with ``determinism.non-deterministic-catalog``.\n+  If a query references any table from those catalogs, the query is considered non-deterministic.\n+* Run the control query again and compare the results with the initial control query run.\n+* If a query has a ``LIMIT n`` clause but no ``ORDER BY`` clause at the top level:\n+   * Run a query to count the number of rows produced by the control query without the ``LIMIT`` clause.\n+   * If the resulting row count is greater than ``n``, treat the control query as non-deterministic.\n+\n+Failure Resolution\n+------------------\n+The difference in configuration, including cluster size, can cause a query to succeed on the\n+control cluster but fail on the test cluster. A checksum query can also fail, which may be due to\n+limitation of Presto or Presto Verifier. Thus, we allow Verifier to automatically resolve certain\n+query failures.\n+\n+* ``EXCEEDED_GLOBAL_MEMORY_LIMIT``: Resolve if the control query uses more memory than the test\n+  query.\n+* ``EXCEEDED_TIME_LIMIT``: Resolve unconditionally.\n+* ``TOO_MANY_HIVE_PARTITIONS``: Resolve if the test cluster does not have enough workers to make\n+  sure the number of partitions assigned to each worker stays within the limit.\n+* ``COMPILER_ERROR``: Resolve if checksum fails with this error. If a control query has too many\n+  columns, generated checksum query might be too large in certain cases.\n+\n+Extending Verifier\n+------------------\n+\n+Verifier can be extended for further behavioral changes in additional to configuration properties.\n+\n+`AbstractVerifyCommand <https://github.com/prestodb/presto/blob/master/presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerifyCommand.java>`_\n+shows the components that be extended. Implement the abstract class and create a command line wrapper similar to\n+`PrestoVerifier <https://github.com/prestodb/presto/blob/master/presto-verifier/src/main/java/com/facebook/presto/verifier/PrestoVerifier.java>`_.\n+\n+\n+Configuration Reference\n+-----------------------\n+\n+General Configuration\n+~~~~~~~~~~~~~~~~~~~~~\n+\n+=========================================== ===============================================================================\n+Name                                        Description\n+=========================================== ===============================================================================\n+``whitelist``                               A comma-separated list specifying the names of the queries within the suite\n+                                            to verify.\n+``blacklist``                               A comma-separated list specifying the names of the queries to be excluded\n+                                            from the suite. ``blacklist`` is applied after ``whitelist``.\n+``source-query-supplier``                   The name of the source query supplier. Supports ``mysql``.\n+``source-query.table-name``                 The name of the table that holds verifier queries. Available only when\n+                                            ``source-query-supplier`` is ``mysql``.\n+``event-clients``                           A comma-separated list specifying where the output events should be emitted.\n+                                            Supports ``json`` and ``human-readable``.\n+``json.log-file``                           The output files of ``JSON`` events. If not set, ``JSON`` events are emitted to\n+                                            ``stdout``.\n+``human-readable.log-file``                 The output files for human-readable events. If not set, human-readable events\n+                                            are emitted to ``stdout``.\n+``test-id``                                 A string to be attached to output events.\n+``max-concurrency``                         Maximum number of concurrent verifications.\n+``suite-repetition``                        How many times a suite is verified.\n+``query-repetition``                        How many times a source query is verified.\n+``relative-error-margin``                   Maximum tolerable relative error between control sum and test sum of a\n+                                            floating point column.\n+``absolute-error-margin``                   Floating point averages that are below this threshold are treated as ``0``.\n+``run-teardown-on-result-mismatch``         Whether to run teardown query in case of result mismatch.\n+``verification-resubmission.limit``         A limit on how many times a source query can be re-submitted for verification.\n+=========================================== ===============================================================================\n+\n+\n+Query Override Configuration\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+The following configurations controls the behavior of query metadata modification before verification starts.", "originalCommit": "cc54e40b364c2db7e430603afdd2169cd843d26e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTIyNzYxMA==", "url": "https://github.com/prestodb/presto/pull/14153#discussion_r385227610", "bodyText": "controls -> control", "author": "rschlussel", "createdAt": "2020-02-27T16:37:06Z", "path": "presto-docs/src/main/sphinx/admin/verifier.rst", "diffHunk": "@@ -0,0 +1,258 @@\n+===============\n+Presto Verifier\n+===============\n+\n+Presto Verifier is a tool to run queries and verify correctness. It can be used to test whether a\n+new Presto version produce the correct query results, or to test if pairs of Presto queries have\n+the same semantics.\n+\n+During each Presto release, Verifier is ran to ensure that there is no correctness regression.\n+\n+Using Verifier\n+--------------\n+\n+In a MySQL database, create the following table and load it with the queries you would like to run:\n+\n+.. code-block:: sql\n+\n+    CREATE TABLE verifier_queries (\n+        id int(11) unsigned NOT NULL PRIMARY KEY AUTO_INCREMENT,\n+        suite varchar(256) NOT NULL,\n+        name varchar(256) DEFAULT NULL,\n+        control_catalog varchar(256) NOT NULL,\n+        control_schema varchar(256) NOT NULL,\n+        control_query text NOT NULL,\n+        control_username varchar(256) DEFAULT NULL,\n+        control_password varchar(256) DEFAULT NULL,\n+        control_session_properties text DEFAULT NULL,\n+        test_catalog varchar(256) NOT NULL,\n+        test_schema varchar(256) NOT NULL,\n+        test_query text NOT NULL,\n+        test_username varchar(256) DEFAULT NULL,\n+        test_password varchar(256) DEFAULT NULL,\n+        test_session_properties text DEFAULT NULL)\n+\n+Next, create a ``config.properties`` file:\n+\n+.. code-block:: none\n+\n+    source-query.suite=my_suite\n+    source-query.database=jdbc:mysql://localhost:3306/my_database?user=my_username&password=my_password\n+    control.gateway=jdbc:presto://localhost:8080\n+    test.gateway=jdbc:presto://localhost:8081\n+    test-id=1\n+\n+Download :maven_download:`verifier` and rename it to ``verifier``. To run the Verifier:\n+\n+.. code-block:: none\n+\n+    chmod +x verifier\n+    ./verifier verify config.properties\n+\n+\n+Verifier Procedures\n+-------------------\n+\n+The following steps summarize the workflow of Verifier.\n+\n+* **Importing Source Queries**\n+   * Read the list of source queries (query pairs with configuration) from the MySQL table.\n+\n+* **Query Pre-processing and Filtering**\n+   * Apply overrides to the catalog, schema, username, and password of each query.\n+   * Filter queries according to whitelist and blacklist. Whitelist is applied before blacklist.\n+   * Filter out queries with invalid syntax.\n+   * Filter out queries not supported for validation. ``Select``, ``Insert``, and ``CreateTableAsSelect`` are supported.\n+\n+* **Query rewriting**\n+    * Rewrite queries before execution to ensure that production data is not modified.\n+    * Rewrite ``Select`` queries to ``CreateTableAsSelect``\n+       * Column names are determined by running the ``Select`` query with ``LIMIT 0``.\n+       * Artificial names are used for unnamed columns.\n+    * Rewrite ``Insert`` and ``CreateTableAsSelect`` queries to have their table names replaced.\n+       * Construct a setup query to create the table necessary for an ``Insert`` query.\n+\n+* **Query Execution**\n+    * Conceptually, Verifier is configured with a control cluster and a test cluster. However, they\n+      may be pointed to the same Presto cluster for certain tests.\n+    * For each source query, execute the following queries in order.\n+        * Control setup queries\n+        * Control query\n+        * Test setup queries\n+        * Test query\n+        * Control and Test teardown\n+    * Queries are subject to timeouts and retries.\n+        * Cluster connection failures and transient Presto failures are retried.\n+        * Query retries may conceal reliability issues. All occurred Presto query failures, including the retries, are recorded.\n+    * Certain query failures are automatically submitted for re-validation, such as partition dropped or table dropped during query.\n+    * See `Failure Resolution`_ for auto-resolving of query failures.\n+\n+* **Results Comparison**\n+    * For ``Select``, ``Insert``, and ``CreateTableAsSelect`` queries, results are written into temporary tables.\n+    * Construct and run the checksum queries for both control and test.\n+    * Verify table schema and row count are the same for the control and the test result table.\n+    * Verify checksums are matching for each column. See `Column Checksums`_ for special handling of different column types.\n+    * See `Determinism`_ for handling of non-deterministic queries.\n+\n+* **Emitting Results**\n+    * Verification results can be exported as ``JSON``, or human readable text.\n+\n+Column Checksums\n+----------------\n+For each column in the control/test query, one or more columns are generated in the checksum\n+queries.\n+\n+* **Floating Point Columns**\n+    * For ``DOUBLE`` and ``REAL`` columns, 4 columns are generated for verification:\n+       * Sum of the finite values of the column\n+       * ``NAN`` count of the column\n+       * Positive infinity count of the column\n+       * Negative infinity count of the column\n+    * Check if ``NAN`` count, positive and negative infinity count matches.\n+    * Check the nullity of control sum and test sum.\n+    * If either control mean or test mean very close 0, check if both are close to 0.\n+    * Check the relative error between control sum and test sum.\n+* **Array Columns**\n+    * 2 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Array checksum\n+    * For an array column ``arr`` of type ``array(E)``:\n+       * If ``E`` is not orderable, array checksum is ``checksum(arr)``.\n+       * If ``E`` is orderable, array checksum ``coalesce(checksum(try(array_sort(arr))), checksum(arr))``.\n+* **Map Columns**\n+    * 4 columns are generated for verification:\n+       * Sum of the cardinality\n+       * Checksum of the map\n+       * Array checksum of the key set\n+       * Array checksum of the value set\n+* **Row Columns**\n+    * Checksum row fields recursively according to the type of the fields.\n+* For all other column types, generate a simple checksum using the :func:`checksum` function.\n+\n+Determinism\n+-----------\n+A result mismatch, either a row count mismatch or a column mismatch, can be caused by\n+non-deterministic query features. To avoid false alerts, we perform determinism analysis\n+for the control query. If a query is found non-deterministic, we skip the verification as it\n+does not provide insights.\n+\n+Determinism analysis follows the following steps. If a query is found non-deterministic at any\n+point, the analysis will conclude.\n+\n+* Non-deterministic catalogs can be specified with ``determinism.non-deterministic-catalog``.\n+  If a query references any table from those catalogs, the query is considered non-deterministic.\n+* Run the control query again and compare the results with the initial control query run.\n+* If a query has a ``LIMIT n`` clause but no ``ORDER BY`` clause at the top level:\n+   * Run a query to count the number of rows produced by the control query without the ``LIMIT`` clause.\n+   * If the resulting row count is greater than ``n``, treat the control query as non-deterministic.\n+\n+Failure Resolution\n+------------------\n+The difference in configuration, including cluster size, can cause a query to succeed on the\n+control cluster but fail on the test cluster. A checksum query can also fail, which may be due to\n+limitation of Presto or Presto Verifier. Thus, we allow Verifier to automatically resolve certain\n+query failures.\n+\n+* ``EXCEEDED_GLOBAL_MEMORY_LIMIT``: Resolve if the control query uses more memory than the test\n+  query.\n+* ``EXCEEDED_TIME_LIMIT``: Resolve unconditionally.\n+* ``TOO_MANY_HIVE_PARTITIONS``: Resolve if the test cluster does not have enough workers to make\n+  sure the number of partitions assigned to each worker stays within the limit.\n+* ``COMPILER_ERROR``: Resolve if checksum fails with this error. If a control query has too many\n+  columns, generated checksum query might be too large in certain cases.\n+\n+Extending Verifier\n+------------------\n+\n+Verifier can be extended for further behavioral changes in additional to configuration properties.\n+\n+`AbstractVerifyCommand <https://github.com/prestodb/presto/blob/master/presto-verifier/src/main/java/com/facebook/presto/verifier/framework/AbstractVerifyCommand.java>`_\n+shows the components that be extended. Implement the abstract class and create a command line wrapper similar to\n+`PrestoVerifier <https://github.com/prestodb/presto/blob/master/presto-verifier/src/main/java/com/facebook/presto/verifier/PrestoVerifier.java>`_.\n+\n+\n+Configuration Reference\n+-----------------------\n+\n+General Configuration\n+~~~~~~~~~~~~~~~~~~~~~\n+\n+=========================================== ===============================================================================\n+Name                                        Description\n+=========================================== ===============================================================================\n+``whitelist``                               A comma-separated list specifying the names of the queries within the suite\n+                                            to verify.\n+``blacklist``                               A comma-separated list specifying the names of the queries to be excluded\n+                                            from the suite. ``blacklist`` is applied after ``whitelist``.\n+``source-query-supplier``                   The name of the source query supplier. Supports ``mysql``.\n+``source-query.table-name``                 The name of the table that holds verifier queries. Available only when\n+                                            ``source-query-supplier`` is ``mysql``.\n+``event-clients``                           A comma-separated list specifying where the output events should be emitted.\n+                                            Supports ``json`` and ``human-readable``.\n+``json.log-file``                           The output files of ``JSON`` events. If not set, ``JSON`` events are emitted to\n+                                            ``stdout``.\n+``human-readable.log-file``                 The output files for human-readable events. If not set, human-readable events\n+                                            are emitted to ``stdout``.\n+``test-id``                                 A string to be attached to output events.\n+``max-concurrency``                         Maximum number of concurrent verifications.\n+``suite-repetition``                        How many times a suite is verified.\n+``query-repetition``                        How many times a source query is verified.\n+``relative-error-margin``                   Maximum tolerable relative error between control sum and test sum of a\n+                                            floating point column.\n+``absolute-error-margin``                   Floating point averages that are below this threshold are treated as ``0``.\n+``run-teardown-on-result-mismatch``         Whether to run teardown query in case of result mismatch.\n+``verification-resubmission.limit``         A limit on how many times a source query can be re-submitted for verification.\n+=========================================== ===============================================================================\n+\n+\n+Query Override Configuration\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+The following configurations controls the behavior of query metadata modification before verification starts.\n+Counterparts are also available for test queries with prefix ``control`` being replaced with ``test``.\n+\n+================================================ ===============================================================================\n+Name                                             Description\n+================================================ ===============================================================================\n+``control.catalog-override``                     The catalog to be applied to all queries if specified.\n+``control.schema-override``                      The schema to be applied to all queries if specified.\n+``control.username-override``                    The username to be applied to all queries if specified.\n+``control.password-override``                    The password to be applied to all queries if specified.\n+``control.session-properties-override-strategy`` Supports 3 values. ``NO_ACTION``: Use the session properties as specified for\n+                                                 each query. ``OVERRIDE``: Merge the session properties of each query with the\n+                                                 override, with override being the dominant. ``SUBSTITUTE``, The session\n+                                                 properties of each query is replaced with the override.\n+``control.session-properties-override``          The session property to be applied to all queries.\n+================================================ ===============================================================================\n+\n+Query Execution Configuration\n+~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n+\n+The following configurations controls the behavior of query execution on the control cluster.", "originalCommit": "cc54e40b364c2db7e430603afdd2169cd843d26e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c34a8344d25dd1636efdfa691ae5c9b1769cfbff", "url": "https://github.com/prestodb/presto/commit/c34a8344d25dd1636efdfa691ae5c9b1769cfbff", "message": "Update Verifier documentation", "committedDate": "2020-02-27T20:17:38Z", "type": "commit"}, {"oid": "c34a8344d25dd1636efdfa691ae5c9b1769cfbff", "url": "https://github.com/prestodb/presto/commit/c34a8344d25dd1636efdfa691ae5c9b1769cfbff", "message": "Update Verifier documentation", "committedDate": "2020-02-27T20:17:38Z", "type": "forcePushed"}]}