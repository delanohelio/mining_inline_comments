{"pr_number": 14646, "pr_title": "Adding time type support for Pinot predicate pushdown", "pr_createdAt": "2020-06-12T19:49:00Z", "pr_url": "https://github.com/prestodb/presto/pull/14646", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxODQ5NQ==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441018495", "bodyText": "I think I would prefer handleLogicalBinary to check for the presence of date/time etc and then delegate to a helper method instead of inlining the logic here. Here is what I mean in code:\nif (isDateTimeExpression(arguments)) {\n  return handleDateTimeBinaryExpression(operator, call, context) // or pass it arguments, context ..  whatever\n}\n// Continue normal handleLogicalBinary flow here", "author": "agrawaldevesh", "createdAt": "2020-06-16T17:23:34Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,50 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            String def0 = arguments.get(0).accept(this, context).getDefinition();", "originalCommit": "c6d6bef91e8d0e6f719eb2d14ed729810911e607", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM3MzE2Nw==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441373167", "bodyText": "will do", "author": "xiangfu0", "createdAt": "2020-06-17T08:28:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxODQ5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxOTUxMA==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441019510", "bodyText": "I didn't follow why handleTimeStampAndDateCast is not called from handleCast ? I don't understand why the codepath is entering handleLogicalBinary vs handleCast.", "author": "agrawaldevesh", "createdAt": "2020-06-16T17:25:22Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,50 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            String def0 = arguments.get(0).accept(this, context).getDefinition();\n+            String def1 = arguments.get(1).accept(this, context).getDefinition();\n+            def1 = handleTimeStampAndDateCast(arguments.get(0), def1);\n+            def0 = handleTimeStampAndDateCast(arguments.get(1), def0);\n+            return derived(format(\"(%s %s %s)\", def0, operator, def1));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private String handleTimeStampAndDateCast(RowExpression rowExpression, String definition)\n+    {\n+        if (!(rowExpression instanceof CallExpression)) {\n+            return definition;\n+        }\n+        CallExpression callExpr = (CallExpression) rowExpression;\n+        if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {", "originalCommit": "c6d6bef91e8d0e6f719eb2d14ed729810911e607", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM3Njk2Nw==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441376967", "bodyText": "this is a bit tricky, the logic behind is that Presto can compare a timestamp to a Date literal or a date to a timestamp literal.\nCast only works when user explicitly convert the time field to corresponding literal type.\nE.g. WHERE eventDate < current_time\nWe know that left is a date, right side is a timestamp.\nbut until hit the binary logic, we know that we need to convert current_time to date value so that the pushing down logic is correct with the correct time value.", "author": "xiangfu0", "createdAt": "2020-06-17T08:35:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAxOTUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyMDQ3OQ==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441020479", "bodyText": "By having handleTimeStampAndDateCast as written, its not clear what definition means.", "author": "agrawaldevesh", "createdAt": "2020-06-16T17:26:58Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,50 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            String def0 = arguments.get(0).accept(this, context).getDefinition();\n+            String def1 = arguments.get(1).accept(this, context).getDefinition();\n+            def1 = handleTimeStampAndDateCast(arguments.get(0), def1);\n+            def0 = handleTimeStampAndDateCast(arguments.get(1), def0);\n+            return derived(format(\"(%s %s %s)\", def0, operator, def1));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private String handleTimeStampAndDateCast(RowExpression rowExpression, String definition)", "originalCommit": "c6d6bef91e8d0e6f719eb2d14ed729810911e607", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM3MzA5Ng==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441373096", "bodyText": "It's the value of timestamp or date(millsSinceEpoch/daysSinceEpoch)", "author": "xiangfu0", "createdAt": "2020-06-17T08:28:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyMDQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyMTc4NA==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441021784", "bodyText": "Shouldn't we be returning output as a timestamp instead of number of days, if the expected type is a timestamp and input is a date ? We seem to be doing the opposite: returning the days when expected type is a timestamp.\nAlso what about timezone handling ?", "author": "agrawaldevesh", "createdAt": "2020-06-16T17:29:09Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,50 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            String def0 = arguments.get(0).accept(this, context).getDefinition();\n+            String def1 = arguments.get(1).accept(this, context).getDefinition();\n+            def1 = handleTimeStampAndDateCast(arguments.get(0), def1);\n+            def0 = handleTimeStampAndDateCast(arguments.get(1), def0);\n+            return derived(format(\"(%s %s %s)\", def0, operator, def1));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private String handleTimeStampAndDateCast(RowExpression rowExpression, String definition)\n+    {\n+        if (!(rowExpression instanceof CallExpression)) {\n+            return definition;\n+        }\n+        CallExpression callExpr = (CallExpression) rowExpression;\n+        if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {\n+            return definition;\n+        }\n+        if (callExpr.getArguments().size() != 1) {\n+            return definition;\n+        }\n+        Type inputType = callExpr.getArguments().get(0).getType();\n+        Type expectedType = callExpr.getType();\n+        if (inputType == DateType.DATE && (expectedType == TimestampType.TIMESTAMP || expectedType == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE)) {", "originalCommit": "c6d6bef91e8d0e6f719eb2d14ed729810911e607", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM4MDAyOA==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441380028", "bodyText": "take example of WHERE eventDate < current_time.\ninput type is the eventDate field data type, which is daysSinceEpoch.\nexpect type is the right side literal type, which means right side is millisSinceEpoch.\nIn order to make the pushdown work, we need to convert right side to input type which is date.\nTimestampWithTimeZone will also be converted to epoch value then to epoch date.", "author": "xiangfu0", "createdAt": "2020-06-17T08:39:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyMTc4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyNTYzNA==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441025634", "bodyText": "Perhaps a comment here about why the substring offsets are chosen ?\nIs this branch about handling of literals / constants ? Is there another way to check for a RowExpression being a constant/literal rather than checking for its type ?", "author": "agrawaldevesh", "createdAt": "2020-06-16T17:35:39Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -141,6 +187,21 @@ private PinotExpression handleCast(CallExpression cast, Function<VariableReferen\n             if (typeManager.canCoerce(input.getType(), expectedType)) {\n                 return input.accept(this, context);\n             }\n+            if (expectedType == DateType.DATE) {\n+                try {\n+                    PinotExpression expression = input.accept(this, context);\n+                    if (input.getType() == TimestampType.TIMESTAMP || input.getType() == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE) {\n+                        return expression;\n+                    }\n+                    if (input.getType() == VarcharType.VARCHAR) {\n+                        Integer daysSinceEpoch = (int) TimeUnit.MILLISECONDS.toDays(DATE_FORMATTER.parseMillis(expression.getDefinition().substring(1, expression.getDefinition().length() - 1)));", "originalCommit": "c6d6bef91e8d0e6f719eb2d14ed729810911e607", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM4MTk5Ng==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441381996", "bodyText": "This substring is to remove the leading and tailing quotes.\nThe special handling is specially for date and the string column\ne.g. WHERE eventDateStr <date '2012-08-08'", "author": "xiangfu0", "createdAt": "2020-06-17T08:42:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyNTYzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyNjU2NQ==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441026565", "bodyText": "definition is actually a PQL expression fragment corresponding to a whole expression subtree, and need not be a number. IMHO, Its a bit brittle to first cast an expression tree to a PQL expression-string and then assume that is parseable as a number.", "author": "agrawaldevesh", "createdAt": "2020-06-16T17:37:13Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,50 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            String def0 = arguments.get(0).accept(this, context).getDefinition();\n+            String def1 = arguments.get(1).accept(this, context).getDefinition();\n+            def1 = handleTimeStampAndDateCast(arguments.get(0), def1);\n+            def0 = handleTimeStampAndDateCast(arguments.get(1), def0);\n+            return derived(format(\"(%s %s %s)\", def0, operator, def1));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private String handleTimeStampAndDateCast(RowExpression rowExpression, String definition)\n+    {\n+        if (!(rowExpression instanceof CallExpression)) {\n+            return definition;\n+        }\n+        CallExpression callExpr = (CallExpression) rowExpression;\n+        if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {\n+            return definition;\n+        }\n+        if (callExpr.getArguments().size() != 1) {\n+            return definition;\n+        }\n+        Type inputType = callExpr.getArguments().get(0).getType();\n+        Type expectedType = callExpr.getType();\n+        if (inputType == DateType.DATE && (expectedType == TimestampType.TIMESTAMP || expectedType == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE)) {\n+            try {\n+                Long daysSinceEpoch = TimeUnit.MILLISECONDS.toDays(Long.parseLong(definition));", "originalCommit": "c6d6bef91e8d0e6f719eb2d14ed729810911e607", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM4MDk0MA==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441380940", "bodyText": "You are right, this logic only handles the literal pushdown, otherwise we will fallback to row retrieval and relies on presto to do the filtering.", "author": "xiangfu0", "createdAt": "2020-06-17T08:41:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyNjU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyODU4Ng==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441028586", "bodyText": "Since handleLogicalBinary is called here (above), I wonder if we can move all of the special logic around handling of date/timestamps into a separate function that is called here without dirtying up handleLogicalBinary, as we have already done so for some class of functions on line 235", "author": "agrawaldevesh", "createdAt": "2020-06-16T17:40:50Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -171,9 +232,26 @@ public PinotExpression visitCall(CallExpression call, Function<VariableReference\n                 return handleLogicalBinary(operatorType.getOperator(), call, context);\n             }\n         }\n+        if (functionMetadata.getName().getFunctionName().equalsIgnoreCase(\"$literal$timestamp\") ||", "originalCommit": "c6d6bef91e8d0e6f719eb2d14ed729810911e607", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM5Mjk2NA==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441392964", "bodyText": "This is the handling to allow queries like millisSinceEpoch < 1391126400000 been handled correctly. typeManager.canCoerce will return false and directly fail this query.", "author": "xiangfu0", "createdAt": "2020-06-17T08:59:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyODU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyOTQ2NA==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441029464", "bodyText": "Where is this logic around rendering a json array to string used in this PR ?", "author": "agrawaldevesh", "createdAt": "2020-06-16T17:42:19Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/PinotBrokerPageSource.java", "diffHunk": "@@ -280,8 +281,18 @@ private int issuePqlAndPopulate(\n \n     private static String asText(JsonNode node)\n     {\n+        if (node.isNull()) {", "originalCommit": "c6d6bef91e8d0e6f719eb2d14ed729810911e607", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQwMTUxMw==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441401513", "bodyText": "This is to show  multi-value column as string.", "author": "xiangfu0", "createdAt": "2020-06-17T09:13:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyOTQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1Njc3MA==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441656770", "bodyText": "So is this a related change ? Where do multi value columns creep in here ? Or should this be a different PR ?", "author": "agrawaldevesh", "createdAt": "2020-06-17T16:00:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyOTQ2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTg5MjkwOQ==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441892909", "bodyText": "I was test with a table has multi-value column, hence this change, I can revert it and open another pr.", "author": "xiangfu0", "createdAt": "2020-06-17T23:47:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTAyOTQ2NA=="}], "type": "inlineReview"}, {"oid": "fcf551edfa2f1b84d4e88d014674673fd969fc6a", "url": "https://github.com/prestodb/presto/commit/fcf551edfa2f1b84d4e88d014674673fd969fc6a", "message": "Address comments", "committedDate": "2020-06-17T09:23:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1Nzc5NQ==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441657795", "bodyText": "nit: swap the right and left to make it be consistent with above 2 lines", "author": "agrawaldevesh", "createdAt": "2020-06-17T16:02:25Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -100,48 +100,85 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            String def0 = arguments.get(0).accept(this, context).getDefinition();\n-            String def1 = arguments.get(1).accept(this, context).getDefinition();\n-            def1 = handleTimeStampAndDateCast(arguments.get(0), def1);\n-            def0 = handleTimeStampAndDateCast(arguments.get(1), def0);\n-            return derived(format(\"(%s %s %s)\", def0, operator, def1));\n+            if (isDateTimeExpression(arguments)) {\n+                return handleDateTimeBinaryExpression(operator, arguments, context);\n+            }\n+            return derived(format(\n+                \"(%s %s %s)\",\n+                arguments.get(0).accept(this, context).getDefinition(),\n+                operator,\n+                arguments.get(1).accept(this, context).getDefinition()));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n-    private String handleTimeStampAndDateCast(RowExpression rowExpression, String definition)\n+    private PinotExpression handleDateTimeBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        String left = arguments.get(0).accept(this, context).getDefinition();\n+        String right = arguments.get(1).accept(this, context).getDefinition();\n+        right = handleTimeStampAndDateCast(arguments.get(0), right);", "originalCommit": "fcf551edfa2f1b84d4e88d014674673fd969fc6a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1ODE0MQ==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441658141", "bodyText": "typo: trailing", "author": "agrawaldevesh", "createdAt": "2020-06-17T16:02:58Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -194,6 +231,7 @@ private PinotExpression handleCast(CallExpression cast, Function<VariableReferen\n                         return expression;\n                     }\n                     if (input.getType() == VarcharType.VARCHAR) {\n+                        // Remove the leading & tailing quote then parse", "originalCommit": "fcf551edfa2f1b84d4e88d014674673fd969fc6a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ffdaa42e257a1294ce600658526065a2a1465988", "url": "https://github.com/prestodb/presto/commit/ffdaa42e257a1294ce600658526065a2a1465988", "message": "Address comments", "committedDate": "2020-06-18T00:12:19Z", "type": "forcePushed"}, {"oid": "f4c2152772cf65635b3c6a20d0258b115efdb623", "url": "https://github.com/prestodb/presto/commit/f4c2152772cf65635b3c6a20d0258b115efdb623", "message": "Address comments", "committedDate": "2020-06-18T00:15:48Z", "type": "forcePushed"}, {"oid": "7329acd418feff6875ba7b5ab137a38f857bade0", "url": "https://github.com/prestodb/presto/commit/7329acd418feff6875ba7b5ab137a38f857bade0", "message": "Address comments", "committedDate": "2020-06-18T00:21:32Z", "type": "forcePushed"}, {"oid": "8e3ab8eb8b97e9e42c084d7e725a89706bbb7df0", "url": "https://github.com/prestodb/presto/commit/8e3ab8eb8b97e9e42c084d7e725a89706bbb7df0", "message": "Address comments", "committedDate": "2020-06-18T02:48:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzMzc0Mw==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441933743", "bodyText": "<binary ops> -> <binary  op>", "author": "agrawaldevesh", "createdAt": "2020-06-18T02:31:03Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,103 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n+            // Trying to pushdown the predicate of time field comparing to a time literal.\n+            if (isDateOrTimestampExpression(arguments)) {\n+                return handleDateOrTimestampBinaryExpression(operator, arguments, context);\n+            }\n             return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+                \"(%s %s %s)\",\n+                arguments.get(0).accept(this, context).getDefinition(),\n+                operator,\n+                arguments.get(1).accept(this, context).getDefinition()));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private PinotExpression handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        String left = arguments.get(0).accept(this, context).getDefinition();\n+        String right = arguments.get(1).accept(this, context).getDefinition();\n+        left = handleTimeStampAndDateCast(arguments.get(1), left);\n+        right = handleTimeStampAndDateCast(arguments.get(0), right);\n+        return derived(format(\"(%s %s %s)\", left, operator, right));\n+    }\n+\n+    private boolean isDateOrTimestampExpression(List<RowExpression> arguments)\n+    {\n+        for (RowExpression rowExpression : arguments) {\n+            if (!(rowExpression instanceof CallExpression)) {\n+                continue;\n+            }\n+            CallExpression callExpr = (CallExpression) rowExpression;\n+            if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {\n+                continue;\n+            }\n+            if (callExpr.getArguments().size() != 1) {\n+                continue;\n+            }\n+            Type inputType = callExpr.getArguments().get(0).getType();\n+            Type expectedType = callExpr.getType();\n+            if (inputType == DateType.DATE && (expectedType == TimestampType.TIMESTAMP || expectedType == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE)) {\n+                return true;\n+            }\n+            if ((inputType == TimestampType.TIMESTAMP || inputType == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE) && expectedType == DateType.DATE) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private String handleTimeStampAndDateCast(RowExpression rowExpression, String timeStampOrDateString)\n+    {\n+        if (!(rowExpression instanceof CallExpression)) {\n+            return timeStampOrDateString;\n+        }\n+        CallExpression callExpr = (CallExpression) rowExpression;\n+        if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {\n+            return timeStampOrDateString;\n+        }\n+        if (callExpr.getArguments().size() != 1) {\n+            return timeStampOrDateString;\n+        }\n+\n+        // Handle the binary comparison logic of <DATE/TIMESTAMP field> <binary ops> <DATE/TIMESTAMP literal>.", "originalCommit": "7329acd418feff6875ba7b5ab137a38f857bade0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA4MDAwMg==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r442080002", "bodyText": "done", "author": "xiangfu0", "createdAt": "2020-06-18T09:05:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzMzc0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzMzkzMg==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441933932", "bodyText": "Pinot stores time as: (remove underlying)", "author": "agrawaldevesh", "createdAt": "2020-06-18T02:31:48Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,103 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n+            // Trying to pushdown the predicate of time field comparing to a time literal.\n+            if (isDateOrTimestampExpression(arguments)) {\n+                return handleDateOrTimestampBinaryExpression(operator, arguments, context);\n+            }\n             return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+                \"(%s %s %s)\",\n+                arguments.get(0).accept(this, context).getDefinition(),\n+                operator,\n+                arguments.get(1).accept(this, context).getDefinition()));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private PinotExpression handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        String left = arguments.get(0).accept(this, context).getDefinition();\n+        String right = arguments.get(1).accept(this, context).getDefinition();\n+        left = handleTimeStampAndDateCast(arguments.get(1), left);\n+        right = handleTimeStampAndDateCast(arguments.get(0), right);\n+        return derived(format(\"(%s %s %s)\", left, operator, right));\n+    }\n+\n+    private boolean isDateOrTimestampExpression(List<RowExpression> arguments)\n+    {\n+        for (RowExpression rowExpression : arguments) {\n+            if (!(rowExpression instanceof CallExpression)) {\n+                continue;\n+            }\n+            CallExpression callExpr = (CallExpression) rowExpression;\n+            if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {\n+                continue;\n+            }\n+            if (callExpr.getArguments().size() != 1) {\n+                continue;\n+            }\n+            Type inputType = callExpr.getArguments().get(0).getType();\n+            Type expectedType = callExpr.getType();\n+            if (inputType == DateType.DATE && (expectedType == TimestampType.TIMESTAMP || expectedType == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE)) {\n+                return true;\n+            }\n+            if ((inputType == TimestampType.TIMESTAMP || inputType == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE) && expectedType == DateType.DATE) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private String handleTimeStampAndDateCast(RowExpression rowExpression, String timeStampOrDateString)\n+    {\n+        if (!(rowExpression instanceof CallExpression)) {\n+            return timeStampOrDateString;\n+        }\n+        CallExpression callExpr = (CallExpression) rowExpression;\n+        if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {\n+            return timeStampOrDateString;\n+        }\n+        if (callExpr.getArguments().size() != 1) {\n+            return timeStampOrDateString;\n+        }\n+\n+        // Handle the binary comparison logic of <DATE/TIMESTAMP field> <binary ops> <DATE/TIMESTAMP literal>.\n+        // Pinot underlying stores time as:", "originalCommit": "7329acd418feff6875ba7b5ab137a38f857bade0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzNjE1Nw==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441936157", "bodyText": "Should this comment be moved to handleDateOrTimestampBinaryExpression since it has a reference to the \"binary op\" ?", "author": "agrawaldevesh", "createdAt": "2020-06-18T02:40:38Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,103 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n+            // Trying to pushdown the predicate of time field comparing to a time literal.\n+            if (isDateOrTimestampExpression(arguments)) {\n+                return handleDateOrTimestampBinaryExpression(operator, arguments, context);\n+            }\n             return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+                \"(%s %s %s)\",\n+                arguments.get(0).accept(this, context).getDefinition(),\n+                operator,\n+                arguments.get(1).accept(this, context).getDefinition()));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private PinotExpression handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        String left = arguments.get(0).accept(this, context).getDefinition();\n+        String right = arguments.get(1).accept(this, context).getDefinition();\n+        left = handleTimeStampAndDateCast(arguments.get(1), left);\n+        right = handleTimeStampAndDateCast(arguments.get(0), right);\n+        return derived(format(\"(%s %s %s)\", left, operator, right));\n+    }\n+\n+    private boolean isDateOrTimestampExpression(List<RowExpression> arguments)\n+    {\n+        for (RowExpression rowExpression : arguments) {\n+            if (!(rowExpression instanceof CallExpression)) {\n+                continue;\n+            }\n+            CallExpression callExpr = (CallExpression) rowExpression;\n+            if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {\n+                continue;\n+            }\n+            if (callExpr.getArguments().size() != 1) {\n+                continue;\n+            }\n+            Type inputType = callExpr.getArguments().get(0).getType();\n+            Type expectedType = callExpr.getType();\n+            if (inputType == DateType.DATE && (expectedType == TimestampType.TIMESTAMP || expectedType == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE)) {\n+                return true;\n+            }\n+            if ((inputType == TimestampType.TIMESTAMP || inputType == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE) && expectedType == DateType.DATE) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private String handleTimeStampAndDateCast(RowExpression rowExpression, String timeStampOrDateString)\n+    {\n+        if (!(rowExpression instanceof CallExpression)) {\n+            return timeStampOrDateString;\n+        }\n+        CallExpression callExpr = (CallExpression) rowExpression;\n+        if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {\n+            return timeStampOrDateString;\n+        }\n+        if (callExpr.getArguments().size() != 1) {\n+            return timeStampOrDateString;\n+        }\n+\n+        // Handle the binary comparison logic of <DATE/TIMESTAMP field> <binary ops> <DATE/TIMESTAMP literal>.", "originalCommit": "7329acd418feff6875ba7b5ab137a38f857bade0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzNjgzMA==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441936830", "bodyText": "How about naming rowExpression to 'argument' ?\nCan you please add a Preconditions.checkState that arguments.size() == 2, I think this is only called in the binary codepath  ?\nI didn't follow why we return success right away when the first argument matches. It seems you want exactly one of these two cases:\n\nLeft should be a cast of the valid type, right should be a literal (ConstantExpression)\nRight should be a cast of the valid type, Left should be a literal (ConstantExpression)\n\nWhereas this function is being a bit more permissive than that. The reason I am concerned about that permissiveness is because then we will eventually crap out at line 185 or 194 below. Is it possible to tighten the check ?", "author": "agrawaldevesh", "createdAt": "2020-06-18T02:43:15Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,103 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n+            // Trying to pushdown the predicate of time field comparing to a time literal.\n+            if (isDateOrTimestampExpression(arguments)) {\n+                return handleDateOrTimestampBinaryExpression(operator, arguments, context);\n+            }\n             return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+                \"(%s %s %s)\",\n+                arguments.get(0).accept(this, context).getDefinition(),\n+                operator,\n+                arguments.get(1).accept(this, context).getDefinition()));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private PinotExpression handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        String left = arguments.get(0).accept(this, context).getDefinition();\n+        String right = arguments.get(1).accept(this, context).getDefinition();\n+        left = handleTimeStampAndDateCast(arguments.get(1), left);\n+        right = handleTimeStampAndDateCast(arguments.get(0), right);\n+        return derived(format(\"(%s %s %s)\", left, operator, right));\n+    }\n+\n+    private boolean isDateOrTimestampExpression(List<RowExpression> arguments)\n+    {\n+        for (RowExpression rowExpression : arguments) {", "originalCommit": "7329acd418feff6875ba7b5ab137a38f857bade0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA4MDM1Mg==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r442080352", "bodyText": "Yes, refined this code block and add comments.", "author": "xiangfu0", "createdAt": "2020-06-18T09:05:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzNjgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzNzMwMQ==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441937301", "bodyText": "This will enable to work inside Pinot.\nI think the use of the word underlying is superfluous.", "author": "agrawaldevesh", "createdAt": "2020-06-18T02:45:07Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,103 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n+            // Trying to pushdown the predicate of time field comparing to a time literal.\n+            if (isDateOrTimestampExpression(arguments)) {\n+                return handleDateOrTimestampBinaryExpression(operator, arguments, context);\n+            }\n             return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+                \"(%s %s %s)\",\n+                arguments.get(0).accept(this, context).getDefinition(),\n+                operator,\n+                arguments.get(1).accept(this, context).getDefinition()));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private PinotExpression handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        String left = arguments.get(0).accept(this, context).getDefinition();\n+        String right = arguments.get(1).accept(this, context).getDefinition();\n+        left = handleTimeStampAndDateCast(arguments.get(1), left);\n+        right = handleTimeStampAndDateCast(arguments.get(0), right);\n+        return derived(format(\"(%s %s %s)\", left, operator, right));\n+    }\n+\n+    private boolean isDateOrTimestampExpression(List<RowExpression> arguments)\n+    {\n+        for (RowExpression rowExpression : arguments) {\n+            if (!(rowExpression instanceof CallExpression)) {\n+                continue;\n+            }\n+            CallExpression callExpr = (CallExpression) rowExpression;\n+            if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {\n+                continue;\n+            }\n+            if (callExpr.getArguments().size() != 1) {\n+                continue;\n+            }\n+            Type inputType = callExpr.getArguments().get(0).getType();\n+            Type expectedType = callExpr.getType();\n+            if (inputType == DateType.DATE && (expectedType == TimestampType.TIMESTAMP || expectedType == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE)) {\n+                return true;\n+            }\n+            if ((inputType == TimestampType.TIMESTAMP || inputType == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE) && expectedType == DateType.DATE) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private String handleTimeStampAndDateCast(RowExpression rowExpression, String timeStampOrDateString)\n+    {\n+        if (!(rowExpression instanceof CallExpression)) {\n+            return timeStampOrDateString;\n+        }\n+        CallExpression callExpr = (CallExpression) rowExpression;\n+        if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {\n+            return timeStampOrDateString;\n+        }\n+        if (callExpr.getArguments().size() != 1) {\n+            return timeStampOrDateString;\n+        }\n+\n+        // Handle the binary comparison logic of <DATE/TIMESTAMP field> <binary ops> <DATE/TIMESTAMP literal>.\n+        // Pinot underlying stores time as:\n+        //   - `DATE`: Stored as `INT`/`LONG` `daysSinceEpoch` value\n+        //   - `TIMESTAMP`: Stored as `LONG` `millisSinceEpoch` value.\n+        // In order to push down this predicate, we need to convert the literal to the type of Pinot time field.\n+        // Below code compares the time type of both side:\n+        //   - if same, then directly push down.\n+        //   - if not same, then convert the literal time type to the field time type.\n+        // Take an example of comparing a `DATE` field to a `TIMESTAMP` literal:\n+        //   - Sample predicate: `WHERE eventDate < current_time`.\n+        //   - Input type is the `eventDate` field data type, which is `DATE`.\n+        //   - Expect type is the right side `literal type`, which means right side is `TIMESTAMP`.\n+        // So below code will convert `current_time` in `millisSinceEpoch` value to `daysSinceEpoch` value.\n+        // Then the comparison underlying inside Pinot will work.", "originalCommit": "7329acd418feff6875ba7b5ab137a38f857bade0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzODA4OQ==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r441938089", "bodyText": "I really liked the block comment you added on line 163: I am wondering if it is possible to add a similar level of explanation here ?\nAlso, we do special handling for date expectedType. I am not sure we need to handle timestamp types too ?", "author": "agrawaldevesh", "createdAt": "2020-06-18T02:48:10Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -141,6 +240,22 @@ private PinotExpression handleCast(CallExpression cast, Function<VariableReferen\n             if (typeManager.canCoerce(input.getType(), expectedType)) {\n                 return input.accept(this, context);\n             }\n+            if (expectedType == DateType.DATE) {", "originalCommit": "7329acd418feff6875ba7b5ab137a38f857bade0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjA4NDUyMQ==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r442084521", "bodyText": "Added comments :)\nSo something interesting is that we get a parsed ConstantExpression for TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literal but not DATE literal.\nFor example,\n\n\nDATE '2014-01-31', we get a cast function on top of ConstantExpression of VARCHAR type\n\n\n\nTIMESTAMP '2014-01-31 00:00:00 UTC', we directly get a ConstantExpression of LONG value.", "author": "xiangfu0", "createdAt": "2020-06-18T09:12:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTkzODA4OQ=="}], "type": "inlineReview"}, {"oid": "863ab2a47d7ff4a68379725e8ca858caf6d275c8", "url": "https://github.com/prestodb/presto/commit/863ab2a47d7ff4a68379725e8ca858caf6d275c8", "message": "Address comments", "committedDate": "2020-06-18T09:02:57Z", "type": "forcePushed"}, {"oid": "70729d5e98c63d0770f475fc52368032570d7f07", "url": "https://github.com/prestodb/presto/commit/70729d5e98c63d0770f475fc52368032570d7f07", "message": "Address comments", "committedDate": "2020-06-18T09:24:52Z", "type": "forcePushed"}, {"oid": "916e095701ce9b4380f5df0b60fe8019a2ff0d57", "url": "https://github.com/prestodb/presto/commit/916e095701ce9b4380f5df0b60fe8019a2ff0d57", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals.", "committedDate": "2020-06-19T02:49:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwNDA1NA==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r442604054", "bodyText": "Small comment nit: Handle queries like millisSinceEpoch < 1391126400000", "author": "agrawaldevesh", "createdAt": "2020-06-19T02:53:47Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -171,9 +297,28 @@ public PinotExpression visitCall(CallExpression call, Function<VariableReference\n                 return handleLogicalBinary(operatorType.getOperator(), call, context);\n             }\n         }\n+        // This is the handling to allow queries like `millisSinceEpoch < 1391126400000` been handled correctly.", "originalCommit": "916e095701ce9b4380f5df0b60fe8019a2ff0d57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwNDQyOA==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r442604428", "bodyText": "I am not sure where my previous comment went, but should we rename this method to handleDateAndTimestampMagicLiteralFunction ? (Magic literal function is how presto refers to them ... see LiteralEncoder)", "author": "agrawaldevesh", "createdAt": "2020-06-19T02:55:36Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -171,9 +297,28 @@ public PinotExpression visitCall(CallExpression call, Function<VariableReference\n                 return handleLogicalBinary(operatorType.getOperator(), call, context);\n             }\n         }\n+        // This is the handling to allow queries like `millisSinceEpoch < 1391126400000` been handled correctly.\n+        // Otherwise TypeManager.canCoerce(...) will return false and directly fail this query.\n+        if (functionMetadata.getName().getFunctionName().equalsIgnoreCase(\"$literal$timestamp\") ||\n+                    functionMetadata.getName().getFunctionName().equalsIgnoreCase(\"$literal$date\")) {\n+            return handleDateAndTimestamp(call, context);", "originalCommit": "916e095701ce9b4380f5df0b60fe8019a2ff0d57", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwNTAxMA==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r442605010", "bodyText": "Should the above comment read:\nExpression like DATE '2014-01-31' is not cast to a constant number (like days since epoch) and thus it needs to be specifically handled here.\nI feel that the daysSinceEpoch reference is ambiguous: Because you also refer it to mean a Pinot column name in other places.", "author": "agrawaldevesh", "createdAt": "2020-06-19T02:58:03Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -141,6 +246,27 @@ private PinotExpression handleCast(CallExpression cast, Function<VariableReferen\n             if (typeManager.canCoerce(input.getType(), expectedType)) {\n                 return input.accept(this, context);\n             }\n+            // Special handling for Date type casting. Expression like `DATE '2014-01-31'` is not cast to daysSinceEpoch", "originalCommit": "916e095701ce9b4380f5df0b60fe8019a2ff0d57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYxNzQ2Nw==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r442617467", "bodyText": "make sense, changed column to eventDate, eventTimestamp to be distinguish from the value type", "author": "xiangfu0", "createdAt": "2020-06-19T03:55:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjYwNTAxMA=="}], "type": "inlineReview"}, {"oid": "24134fe9be4669768c233993d9caa7d082c3995c", "url": "https://github.com/prestodb/presto/commit/24134fe9be4669768c233993d9caa7d082c3995c", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals.", "committedDate": "2020-06-19T03:56:43Z", "type": "forcePushed"}, {"oid": "05c03240fef4accf22745885103d166d9357cee3", "url": "https://github.com/prestodb/presto/commit/05c03240fef4accf22745885103d166d9357cee3", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals.", "committedDate": "2020-06-19T05:28:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzNDA1MA==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443034050", "bodyText": "Should this comment be amended ? Perhaps something like: \"Check if call compares a date/time column with a date/time constant. Otherwise just treat it like a regular binary operator.\"", "author": "agrawaldevesh", "createdAt": "2020-06-19T20:36:38Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,109 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            // Trying to pushdown the predicate of comparing a time column to a time literal.", "originalCommit": "05c03240fef4accf22745885103d166d9357cee3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0MTQ4MA==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443041480", "bodyText": "done.", "author": "xiangfu0", "createdAt": "2020-06-19T20:59:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzNDA1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzNDc0MQ==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443034741", "bodyText": "I am sorry, I was wrong: I think this comment is really best suited now for handleTimeValueCast. There is no current_time/millisecondsSinceEpoch below.", "author": "agrawaldevesh", "createdAt": "2020-06-19T20:37:47Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,109 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            // Trying to pushdown the predicate of comparing a time column to a time literal.\n+            return handleDateOrTimestampBinaryExpression(operator, arguments, context).orElseGet(\n+                    () -> derived(format(\n+                            \"(%s %s %s)\",\n+                            arguments.get(0).accept(this, context).getDefinition(),\n+                            operator,\n+                            arguments.get(1).accept(this, context).getDefinition())));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private Optional<PinotExpression> handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        // Handle the binary comparison logic of <DATE/TIMESTAMP field> <binary op> <DATE/TIMESTAMP literal>.\n+        // Pinot stores time as:\n+        //   - `DATE`: Stored as `INT`/`LONG` `daysSinceEpoch` value\n+        //   - `TIMESTAMP`: Stored as `LONG` `millisSinceEpoch` value.\n+        // In order to push down this predicate, we need to convert the literal to the type of Pinot time field.\n+        // Below code compares the time type of both side:\n+        //   - if same, then directly push down.\n+        //   - if not same, then convert the literal time type to the field time type.\n+        // Take an example of comparing a `DATE` field to a `TIMESTAMP` literal:\n+        //   - Sample predicate: `WHERE eventDate < current_time`.\n+        //   - Input type is the `eventDate` field data type, which is `DATE`.\n+        //   - Expect type is the right side `literal type`, which means right side is `TIMESTAMP`.\n+        // The code below converts `current_time` from `millisSinceEpoch` value to `daysSinceEpoch` value, which is\n+        // comparable to values in `eventDate` column.", "originalCommit": "05c03240fef4accf22745885103d166d9357cee3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0MTQ0Ng==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443041446", "bodyText": "done", "author": "xiangfu0", "createdAt": "2020-06-19T20:59:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzNDc0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzNTAyNQ==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443035025", "bodyText": "Its just a little bit weird to have the \"left\" arguments at the end. I am wondering if it would be simpler to read by changing the order of arguments to:\n        Optional<String> left = handleTimeValueCast(arguments.get(0), leftDefinition, arguments.get(1));", "author": "agrawaldevesh", "createdAt": "2020-06-19T20:38:45Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,109 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            // Trying to pushdown the predicate of comparing a time column to a time literal.\n+            return handleDateOrTimestampBinaryExpression(operator, arguments, context).orElseGet(\n+                    () -> derived(format(\n+                            \"(%s %s %s)\",\n+                            arguments.get(0).accept(this, context).getDefinition(),\n+                            operator,\n+                            arguments.get(1).accept(this, context).getDefinition())));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private Optional<PinotExpression> handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        // Handle the binary comparison logic of <DATE/TIMESTAMP field> <binary op> <DATE/TIMESTAMP literal>.\n+        // Pinot stores time as:\n+        //   - `DATE`: Stored as `INT`/`LONG` `daysSinceEpoch` value\n+        //   - `TIMESTAMP`: Stored as `LONG` `millisSinceEpoch` value.\n+        // In order to push down this predicate, we need to convert the literal to the type of Pinot time field.\n+        // Below code compares the time type of both side:\n+        //   - if same, then directly push down.\n+        //   - if not same, then convert the literal time type to the field time type.\n+        // Take an example of comparing a `DATE` field to a `TIMESTAMP` literal:\n+        //   - Sample predicate: `WHERE eventDate < current_time`.\n+        //   - Input type is the `eventDate` field data type, which is `DATE`.\n+        //   - Expect type is the right side `literal type`, which means right side is `TIMESTAMP`.\n+        // The code below converts `current_time` from `millisSinceEpoch` value to `daysSinceEpoch` value, which is\n+        // comparable to values in `eventDate` column.\n+        String leftDefinition = arguments.get(0).accept(this, context).getDefinition();\n+        String rightDefinition = arguments.get(1).accept(this, context).getDefinition();\n+        Optional<String> left = handleTimeValueCast(arguments.get(1), arguments.get(0), leftDefinition);", "originalCommit": "05c03240fef4accf22745885103d166d9357cee3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0MTQyMA==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443041420", "bodyText": "Changed to\nOptional<String> left = handleTimeValueCast(context, arguments.get(0), arguments.get(1));", "author": "xiangfu0", "createdAt": "2020-06-19T20:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzNTAyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzNTExOQ==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443035119", "bodyText": "Can be private static", "author": "agrawaldevesh", "createdAt": "2020-06-19T20:39:03Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,109 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            // Trying to pushdown the predicate of comparing a time column to a time literal.\n+            return handleDateOrTimestampBinaryExpression(operator, arguments, context).orElseGet(\n+                    () -> derived(format(\n+                            \"(%s %s %s)\",\n+                            arguments.get(0).accept(this, context).getDefinition(),\n+                            operator,\n+                            arguments.get(1).accept(this, context).getDefinition())));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private Optional<PinotExpression> handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        // Handle the binary comparison logic of <DATE/TIMESTAMP field> <binary op> <DATE/TIMESTAMP literal>.\n+        // Pinot stores time as:\n+        //   - `DATE`: Stored as `INT`/`LONG` `daysSinceEpoch` value\n+        //   - `TIMESTAMP`: Stored as `LONG` `millisSinceEpoch` value.\n+        // In order to push down this predicate, we need to convert the literal to the type of Pinot time field.\n+        // Below code compares the time type of both side:\n+        //   - if same, then directly push down.\n+        //   - if not same, then convert the literal time type to the field time type.\n+        // Take an example of comparing a `DATE` field to a `TIMESTAMP` literal:\n+        //   - Sample predicate: `WHERE eventDate < current_time`.\n+        //   - Input type is the `eventDate` field data type, which is `DATE`.\n+        //   - Expect type is the right side `literal type`, which means right side is `TIMESTAMP`.\n+        // The code below converts `current_time` from `millisSinceEpoch` value to `daysSinceEpoch` value, which is\n+        // comparable to values in `eventDate` column.\n+        String leftDefinition = arguments.get(0).accept(this, context).getDefinition();\n+        String rightDefinition = arguments.get(1).accept(this, context).getDefinition();\n+        Optional<String> left = handleTimeValueCast(arguments.get(1), arguments.get(0), leftDefinition);\n+        Optional<String> right = handleTimeValueCast(arguments.get(0), arguments.get(1), rightDefinition);\n+        if (left.isPresent() && right.isPresent()) {\n+            return Optional.of(derived(format(\"(%s %s %s)\", left.get(), operator, right.get())));\n+        }\n+        else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private boolean isDateTimeConstantType(Type type)", "originalCommit": "05c03240fef4accf22745885103d166d9357cee3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0MTUxOA==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443041518", "bodyText": "done", "author": "xiangfu0", "createdAt": "2020-06-19T20:59:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzNTExOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzNjA2MA==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443036060", "bodyText": "I think that giant block of comment makes more sense for this method. Perhaps also amend that block to inform what the Optional.empty return signifies", "author": "agrawaldevesh", "createdAt": "2020-06-19T20:41:57Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,109 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            // Trying to pushdown the predicate of comparing a time column to a time literal.\n+            return handleDateOrTimestampBinaryExpression(operator, arguments, context).orElseGet(\n+                    () -> derived(format(\n+                            \"(%s %s %s)\",\n+                            arguments.get(0).accept(this, context).getDefinition(),\n+                            operator,\n+                            arguments.get(1).accept(this, context).getDefinition())));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private Optional<PinotExpression> handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        // Handle the binary comparison logic of <DATE/TIMESTAMP field> <binary op> <DATE/TIMESTAMP literal>.\n+        // Pinot stores time as:\n+        //   - `DATE`: Stored as `INT`/`LONG` `daysSinceEpoch` value\n+        //   - `TIMESTAMP`: Stored as `LONG` `millisSinceEpoch` value.\n+        // In order to push down this predicate, we need to convert the literal to the type of Pinot time field.\n+        // Below code compares the time type of both side:\n+        //   - if same, then directly push down.\n+        //   - if not same, then convert the literal time type to the field time type.\n+        // Take an example of comparing a `DATE` field to a `TIMESTAMP` literal:\n+        //   - Sample predicate: `WHERE eventDate < current_time`.\n+        //   - Input type is the `eventDate` field data type, which is `DATE`.\n+        //   - Expect type is the right side `literal type`, which means right side is `TIMESTAMP`.\n+        // The code below converts `current_time` from `millisSinceEpoch` value to `daysSinceEpoch` value, which is\n+        // comparable to values in `eventDate` column.\n+        String leftDefinition = arguments.get(0).accept(this, context).getDefinition();\n+        String rightDefinition = arguments.get(1).accept(this, context).getDefinition();\n+        Optional<String> left = handleTimeValueCast(arguments.get(1), arguments.get(0), leftDefinition);\n+        Optional<String> right = handleTimeValueCast(arguments.get(0), arguments.get(1), rightDefinition);\n+        if (left.isPresent() && right.isPresent()) {\n+            return Optional.of(derived(format(\"(%s %s %s)\", left.get(), operator, right.get())));\n+        }\n+        else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private boolean isDateTimeConstantType(Type type)\n+    {\n+        return type == DateType.DATE || type == TimestampType.TIMESTAMP || type == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE;\n+    }\n+\n+    private Optional<String> handleTimeValueCast(RowExpression timeFieldExpression, RowExpression timeValueExpression, String timeValueString)\n+    {\n+        Type inputType;", "originalCommit": "05c03240fef4accf22745885103d166d9357cee3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzA0MTU2MA==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443041560", "bodyText": "done", "author": "xiangfu0", "createdAt": "2020-06-19T20:59:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzAzNjA2MA=="}], "type": "inlineReview"}, {"oid": "0b163630dd0b47a9f574bcba83d7780ae88e893b", "url": "https://github.com/prestodb/presto/commit/0b163630dd0b47a9f574bcba83d7780ae88e893b", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals.", "committedDate": "2020-06-19T20:58:49Z", "type": "forcePushed"}, {"oid": "cde22b2b632a42255e21a5450169daf2fe072050", "url": "https://github.com/prestodb/presto/commit/cde22b2b632a42255e21a5450169daf2fe072050", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals.", "committedDate": "2020-06-19T22:07:55Z", "type": "forcePushed"}, {"oid": "006cb09b9c61852a36140d3340c7467ec35d8ac4", "url": "https://github.com/prestodb/presto/commit/006cb09b9c61852a36140d3340c7467ec35d8ac4", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals.", "committedDate": "2020-06-20T00:04:30Z", "type": "forcePushed"}, {"oid": "eeac2d1744b01f2233e41fbef704e6e09ac46e25", "url": "https://github.com/prestodb/presto/commit/eeac2d1744b01f2233e41fbef704e6e09ac46e25", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals.", "committedDate": "2020-06-20T11:02:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE5ODIwNw==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443198207", "bodyText": "Directly return without else branch", "author": "highker", "createdAt": "2020-06-21T08:58:33Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,109 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            // Check if call compares a date/time column with a date/time constant. Otherwise just treat it like a regular binary operator.\n+            return handleDateOrTimestampBinaryExpression(operator, arguments, context).orElseGet(\n+                    () -> derived(format(\n+                            \"(%s %s %s)\",\n+                            arguments.get(0).accept(this, context).getDefinition(),\n+                            operator,\n+                            arguments.get(1).accept(this, context).getDefinition())));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private Optional<PinotExpression> handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        Optional<String> left = handleTimeValueCast(context, arguments.get(1), arguments.get(0));\n+        Optional<String> right = handleTimeValueCast(context, arguments.get(0), arguments.get(1));\n+        if (left.isPresent() && right.isPresent()) {\n+            return Optional.of(derived(format(\"(%s %s %s)\", left.get(), operator, right.get())));\n+        }\n+        else {", "originalCommit": "eeac2d1744b01f2233e41fbef704e6e09ac46e25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzIwMjA3MQ==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443202071", "bodyText": "done", "author": "xiangfu0", "createdAt": "2020-06-21T09:47:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE5ODIwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE5ODIzNQ==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443198235", "bodyText": "callExpression", "author": "highker", "createdAt": "2020-06-21T08:59:00Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,109 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            // Check if call compares a date/time column with a date/time constant. Otherwise just treat it like a regular binary operator.\n+            return handleDateOrTimestampBinaryExpression(operator, arguments, context).orElseGet(\n+                    () -> derived(format(\n+                            \"(%s %s %s)\",\n+                            arguments.get(0).accept(this, context).getDefinition(),\n+                            operator,\n+                            arguments.get(1).accept(this, context).getDefinition())));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private Optional<PinotExpression> handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        Optional<String> left = handleTimeValueCast(context, arguments.get(1), arguments.get(0));\n+        Optional<String> right = handleTimeValueCast(context, arguments.get(0), arguments.get(1));\n+        if (left.isPresent() && right.isPresent()) {\n+            return Optional.of(derived(format(\"(%s %s %s)\", left.get(), operator, right.get())));\n+        }\n+        else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private static boolean isDateTimeConstantType(Type type)\n+    {\n+        return type == DateType.DATE || type == TimestampType.TIMESTAMP || type == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE;\n+    }\n+\n+    private Optional<String> handleTimeValueCast(Function<VariableReferenceExpression, Selection> context, RowExpression timeFieldExpression, RowExpression timeValueExpression)\n+    {\n+        // Handle the binary comparison logic of <DATE/TIMESTAMP field> <binary op> <DATE/TIMESTAMP literal>.\n+        // Pinot stores time as:\n+        //   - `DATE`: Stored as `INT`/`LONG` `daysSinceEpoch` value\n+        //   - `TIMESTAMP`: Stored as `LONG` `millisSinceEpoch` value.\n+        // In order to push down this predicate, we need to convert the literal to the type of Pinot time field.\n+        // Below code compares the time type of both side:\n+        //   - if same, then directly push down.\n+        //   - if not same, then convert the literal time type to the field time type.\n+        //   - if not compatible time types, returns Optional.empty(), indicates no change has been made in this cast.\n+        // Take an example of comparing a `DATE` field to a `TIMESTAMP` literal:\n+        //   - Sample predicate: `WHERE eventDate < current_time`.\n+        //   - Input type is the `eventDate` field data type, which is `DATE`.\n+        //   - Expect type is the right side `literal type`, which means right side is `TIMESTAMP`.\n+        // The code below converts `current_time` from `millisSinceEpoch` value to `daysSinceEpoch` value, which is\n+        // comparable to values in `eventDate` column.\n+        Type inputType;\n+        Type expectedType;\n+        if (!isDateTimeConstantType(timeFieldExpression.getType()) || !isDateTimeConstantType(timeValueExpression.getType())) {\n+            return Optional.empty();\n+        }\n+        String timeValueString = timeValueExpression.accept(this, context).getDefinition();\n+        if (timeFieldExpression instanceof CallExpression) {\n+            // Handles cases like: `cast(eventDate as TIMESTAMP) <  DATE '2014-01-31'`\n+            // For cast function,\n+            // - inputType is the argument type,\n+            // - expectedType is the cast function return type.\n+            CallExpression callExpr = (CallExpression) timeFieldExpression;", "originalCommit": "eeac2d1744b01f2233e41fbef704e6e09ac46e25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzIwMjA4NA==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443202084", "bodyText": "done", "author": "xiangfu0", "createdAt": "2020-06-21T09:47:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE5ODIzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE5ODI1OA==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443198258", "bodyText": "same", "author": "highker", "createdAt": "2020-06-21T08:59:18Z", "path": "presto-pinot-toolkit/src/main/java/com/facebook/presto/pinot/query/PinotFilterExpressionConverter.java", "diffHunk": "@@ -89,15 +100,109 @@ private PinotExpression handleLogicalBinary(\n         }\n         List<RowExpression> arguments = call.getArguments();\n         if (arguments.size() == 2) {\n-            return derived(format(\n-                    \"(%s %s %s)\",\n-                    arguments.get(0).accept(this, context).getDefinition(),\n-                    operator,\n-                    arguments.get(1).accept(this, context).getDefinition()));\n+            // Check if call compares a date/time column with a date/time constant. Otherwise just treat it like a regular binary operator.\n+            return handleDateOrTimestampBinaryExpression(operator, arguments, context).orElseGet(\n+                    () -> derived(format(\n+                            \"(%s %s %s)\",\n+                            arguments.get(0).accept(this, context).getDefinition(),\n+                            operator,\n+                            arguments.get(1).accept(this, context).getDefinition())));\n         }\n         throw new PinotException(PINOT_UNSUPPORTED_EXPRESSION, Optional.empty(), format(\"Unknown logical binary: '%s'\", call));\n     }\n \n+    private Optional<PinotExpression> handleDateOrTimestampBinaryExpression(String operator, List<RowExpression> arguments, Function<VariableReferenceExpression, Selection> context)\n+    {\n+        Optional<String> left = handleTimeValueCast(context, arguments.get(1), arguments.get(0));\n+        Optional<String> right = handleTimeValueCast(context, arguments.get(0), arguments.get(1));\n+        if (left.isPresent() && right.isPresent()) {\n+            return Optional.of(derived(format(\"(%s %s %s)\", left.get(), operator, right.get())));\n+        }\n+        else {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private static boolean isDateTimeConstantType(Type type)\n+    {\n+        return type == DateType.DATE || type == TimestampType.TIMESTAMP || type == TimestampWithTimeZoneType.TIMESTAMP_WITH_TIME_ZONE;\n+    }\n+\n+    private Optional<String> handleTimeValueCast(Function<VariableReferenceExpression, Selection> context, RowExpression timeFieldExpression, RowExpression timeValueExpression)\n+    {\n+        // Handle the binary comparison logic of <DATE/TIMESTAMP field> <binary op> <DATE/TIMESTAMP literal>.\n+        // Pinot stores time as:\n+        //   - `DATE`: Stored as `INT`/`LONG` `daysSinceEpoch` value\n+        //   - `TIMESTAMP`: Stored as `LONG` `millisSinceEpoch` value.\n+        // In order to push down this predicate, we need to convert the literal to the type of Pinot time field.\n+        // Below code compares the time type of both side:\n+        //   - if same, then directly push down.\n+        //   - if not same, then convert the literal time type to the field time type.\n+        //   - if not compatible time types, returns Optional.empty(), indicates no change has been made in this cast.\n+        // Take an example of comparing a `DATE` field to a `TIMESTAMP` literal:\n+        //   - Sample predicate: `WHERE eventDate < current_time`.\n+        //   - Input type is the `eventDate` field data type, which is `DATE`.\n+        //   - Expect type is the right side `literal type`, which means right side is `TIMESTAMP`.\n+        // The code below converts `current_time` from `millisSinceEpoch` value to `daysSinceEpoch` value, which is\n+        // comparable to values in `eventDate` column.\n+        Type inputType;\n+        Type expectedType;\n+        if (!isDateTimeConstantType(timeFieldExpression.getType()) || !isDateTimeConstantType(timeValueExpression.getType())) {\n+            return Optional.empty();\n+        }\n+        String timeValueString = timeValueExpression.accept(this, context).getDefinition();\n+        if (timeFieldExpression instanceof CallExpression) {\n+            // Handles cases like: `cast(eventDate as TIMESTAMP) <  DATE '2014-01-31'`\n+            // For cast function,\n+            // - inputType is the argument type,\n+            // - expectedType is the cast function return type.\n+            CallExpression callExpr = (CallExpression) timeFieldExpression;\n+            if (!standardFunctionResolution.isCastFunction(callExpr.getFunctionHandle())) {\n+                return Optional.empty();\n+            }\n+            if (callExpr.getArguments().size() != 1) {\n+                return Optional.empty();\n+            }\n+            inputType = callExpr.getArguments().get(0).getType();\n+            expectedType = callExpr.getType();\n+        }\n+        else if (timeFieldExpression instanceof VariableReferenceExpression) {\n+            // For VariableReferenceExpression,\n+            // Handles queries like: `eventDate <  TIMESTAMP '2014-01-31 00:00:00 UTC'`\n+            // - inputType is timeFieldExpression type,\n+            // - expectedType is the timeValueExpression type.\n+            inputType = timeFieldExpression.getType();\n+            expectedType = timeValueExpression.getType();\n+        }\n+        else if (timeFieldExpression instanceof ConstantExpression) {\n+            // timeFieldExpression is a ConstantExpression, directly return.\n+            return Optional.of(timeValueString);\n+        }\n+        else {", "originalCommit": "eeac2d1744b01f2233e41fbef704e6e09ac46e25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzIwMjI3Mg==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443202272", "bodyText": "this else block is needed, as some of above code blocks don't have return.", "author": "xiangfu0", "createdAt": "2020-06-21T09:49:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE5ODI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE5ODMxNg==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443198316", "bodyText": "planBuilder", "author": "highker", "createdAt": "2020-06-21T08:59:56Z", "path": "presto-pinot-toolkit/src/test/java/com/facebook/presto/pinot/query/TestPinotPlanOptimizer.java", "diffHunk": "@@ -207,6 +207,66 @@ public void testPartialPredicatePushdown()\n         assertPlanMatch(optimized, PlanMatchPattern.limit(50L, PlanMatchPattern.filter(\"lower(substr(city, 0, 3)) = 'del'\", tableScanMatcher)), typeProvider);\n     }\n \n+    @Test\n+    public void testDatePredicatePushdown()\n+    {\n+        PlanBuilder pb = createPlanBuilder(defaultSessionHolder);", "originalCommit": "eeac2d1744b01f2233e41fbef704e6e09ac46e25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzIwMjA5MA==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443202090", "bodyText": "done", "author": "xiangfu0", "createdAt": "2020-06-21T09:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE5ODMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE5ODM0MQ==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443198341", "bodyText": "same", "author": "highker", "createdAt": "2020-06-21T09:00:14Z", "path": "presto-pinot-toolkit/src/test/java/com/facebook/presto/pinot/query/TestPinotPlanOptimizer.java", "diffHunk": "@@ -207,6 +207,66 @@ public void testPartialPredicatePushdown()\n         assertPlanMatch(optimized, PlanMatchPattern.limit(50L, PlanMatchPattern.filter(\"lower(substr(city, 0, 3)) = 'del'\", tableScanMatcher)), typeProvider);\n     }\n \n+    @Test\n+    public void testDatePredicatePushdown()\n+    {\n+        PlanBuilder pb = createPlanBuilder(defaultSessionHolder);\n+        FilterNode filter = filter(pb, tableScan(pb, pinotTable, regionId, city, fare, daysSinceEpoch), getRowExpression(\"dayssinceepoch < DATE '2014-01-31'\", defaultSessionHolder));\n+        PlanNode originalPlan = limit(pb, 50L, filter);\n+        PlanNode optimized = getOptimizedPlan(pb, originalPlan);\n+        assertPlanMatch(optimized, PinotTableScanMatcher.match(pinotTable, Optional.of(\"SELECT regionId, city, fare, daysSinceEpoch FROM hybrid WHERE \\\\(daysSinceEpoch < 16101\\\\) LIMIT 50\"), Optional.of(false), originalPlan.getOutputVariables()), typeProvider);\n+    }\n+\n+    @Test\n+    public void testDateCastingPredicatePushdown()\n+    {\n+        PlanBuilder pb = createPlanBuilder(defaultSessionHolder);", "originalCommit": "eeac2d1744b01f2233e41fbef704e6e09ac46e25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzIwMjA5Mw==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443202093", "bodyText": "done", "author": "xiangfu0", "createdAt": "2020-06-21T09:47:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE5ODM0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE5ODM0Ng==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443198346", "bodyText": "same and all other places", "author": "highker", "createdAt": "2020-06-21T09:00:18Z", "path": "presto-pinot-toolkit/src/test/java/com/facebook/presto/pinot/query/TestPinotPlanOptimizer.java", "diffHunk": "@@ -207,6 +207,66 @@ public void testPartialPredicatePushdown()\n         assertPlanMatch(optimized, PlanMatchPattern.limit(50L, PlanMatchPattern.filter(\"lower(substr(city, 0, 3)) = 'del'\", tableScanMatcher)), typeProvider);\n     }\n \n+    @Test\n+    public void testDatePredicatePushdown()\n+    {\n+        PlanBuilder pb = createPlanBuilder(defaultSessionHolder);\n+        FilterNode filter = filter(pb, tableScan(pb, pinotTable, regionId, city, fare, daysSinceEpoch), getRowExpression(\"dayssinceepoch < DATE '2014-01-31'\", defaultSessionHolder));\n+        PlanNode originalPlan = limit(pb, 50L, filter);\n+        PlanNode optimized = getOptimizedPlan(pb, originalPlan);\n+        assertPlanMatch(optimized, PinotTableScanMatcher.match(pinotTable, Optional.of(\"SELECT regionId, city, fare, daysSinceEpoch FROM hybrid WHERE \\\\(daysSinceEpoch < 16101\\\\) LIMIT 50\"), Optional.of(false), originalPlan.getOutputVariables()), typeProvider);\n+    }\n+\n+    @Test\n+    public void testDateCastingPredicatePushdown()\n+    {\n+        PlanBuilder pb = createPlanBuilder(defaultSessionHolder);\n+        FilterNode filter = filter(pb, tableScan(pb, pinotTable, regionId, city, fare, daysSinceEpoch), getRowExpression(\"cast(dayssinceepoch as timestamp) < TIMESTAMP '2014-01-31 00:00:00 UTC'\", defaultSessionHolder));\n+        PlanNode originalPlan = limit(pb, 50L, filter);\n+        PlanNode optimized = getOptimizedPlan(pb, originalPlan);\n+        assertPlanMatch(optimized, PinotTableScanMatcher.match(pinotTable, Optional.of(\"SELECT regionId, city, fare, daysSinceEpoch FROM hybrid WHERE \\\\(daysSinceEpoch < 16101\\\\) LIMIT 50\"), Optional.of(false), originalPlan.getOutputVariables()), typeProvider);\n+    }\n+\n+    @Test\n+    public void testTimestampPredicatePushdown()\n+    {\n+        PlanBuilder pb = createPlanBuilder(defaultSessionHolder);", "originalCommit": "eeac2d1744b01f2233e41fbef704e6e09ac46e25", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzIwMjEwNw==", "url": "https://github.com/prestodb/presto/pull/14646#discussion_r443202107", "bodyText": "done", "author": "xiangfu0", "createdAt": "2020-06-21T09:47:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzE5ODM0Ng=="}], "type": "inlineReview"}, {"oid": "3507b3b0d1c8fd7000238b15f725cb838e7c98c5", "url": "https://github.com/prestodb/presto/commit/3507b3b0d1c8fd7000238b15f725cb838e7c98c5", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals.", "committedDate": "2020-06-21T09:47:10Z", "type": "forcePushed"}, {"oid": "33fac60ee6e81f29c2ec93b1ed59a1b43d8a994f", "url": "https://github.com/prestodb/presto/commit/33fac60ee6e81f29c2ec93b1ed59a1b43d8a994f", "message": "Adding support to pushdown predicate for DATE/TIMESTAMP/TIMESTAMP_WITH_TIME_ZONE literals.", "committedDate": "2020-06-21T10:31:30Z", "type": "forcePushed"}, {"oid": "42dc4034eab75adadee8939bd2003e070a99ab09", "url": "https://github.com/prestodb/presto/commit/42dc4034eab75adadee8939bd2003e070a99ab09", "message": "Adding time type support for Pinot predicate pushdown", "committedDate": "2020-06-23T04:16:02Z", "type": "forcePushed"}, {"oid": "991dcb325da67bad5356e3581e4b065c793a0315", "url": "https://github.com/prestodb/presto/commit/991dcb325da67bad5356e3581e4b065c793a0315", "message": "Adding time type support for Pinot predicate pushdown", "committedDate": "2020-06-23T05:58:57Z", "type": "forcePushed"}, {"oid": "e4863b029faed4f00482a9e86647a69747b51131", "url": "https://github.com/prestodb/presto/commit/e4863b029faed4f00482a9e86647a69747b51131", "message": "Adding time type support for Pinot predicate pushdown", "committedDate": "2020-06-23T07:23:28Z", "type": "forcePushed"}, {"oid": "18f2944946a3ded70efd81591aecc5af8c4daef4", "url": "https://github.com/prestodb/presto/commit/18f2944946a3ded70efd81591aecc5af8c4daef4", "message": "Adding time type support for Pinot predicate pushdown", "committedDate": "2020-06-23T10:27:49Z", "type": "forcePushed"}, {"oid": "d7720de564c2724171c4874f65aae9ef7b8c49b9", "url": "https://github.com/prestodb/presto/commit/d7720de564c2724171c4874f65aae9ef7b8c49b9", "message": "Adding time type support for Pinot predicate pushdown", "committedDate": "2020-06-23T11:51:55Z", "type": "commit"}, {"oid": "d7720de564c2724171c4874f65aae9ef7b8c49b9", "url": "https://github.com/prestodb/presto/commit/d7720de564c2724171c4874f65aae9ef7b8c49b9", "message": "Adding time type support for Pinot predicate pushdown", "committedDate": "2020-06-23T11:51:55Z", "type": "forcePushed"}]}