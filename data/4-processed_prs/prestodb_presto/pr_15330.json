{"pr_number": 15330, "pr_title": "Reserve memory for nested BlockBuilders in projection", "pr_createdAt": "2020-10-19T09:55:00Z", "pr_url": "https://github.com/prestodb/presto/pull/15330", "timeline": [{"oid": "1070724cbdbbad4a977294d417283b2df4750cc9", "url": "https://github.com/prestodb/presto/commit/1070724cbdbbad4a977294d417283b2df4750cc9", "message": "Reserve memory for nested BlockBuilders in projection\n\nIn bf4bf6a610 \"Reserve memory before projecting rows\" we created the\nBlockBuilders new every time. However, nested BlockBuilders for complex\ntypes would lose the status from previously created BlockBuilders such\nthat memory growth increased. For example, for an ARRAY(BIGINT)\nBlockBuilder, the nested LongArrayBlockBuilder would just have the same\nexpectedEntries as the ArrayBlockBuilder although the entries in the\nLongArrayBlockBuilder could be a lot more.\n\nThis commit uses the newly introduced newBlockBuilderLike() method that\nestimates the expectedEntries for nested BlockBuilders from previously\ncreated BlockBuilders. The following simple ArrayTransform query shows\nthe allocated long[] reduced from 118GB to 93GB on TPCH 100GB.\n\nselect transform(l_array, x-> x+1) from lineitem_map_array;", "committedDate": "2020-10-19T23:52:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MjQ4NQ==", "url": "https://github.com/prestodb/presto/pull/15330#discussion_r510552485", "bodyText": "can this lead to int overflow?", "author": "bhhari", "createdAt": "2020-10-23T01:57:33Z", "path": "presto-common/src/main/java/com/facebook/presto/common/block/ArrayBlockBuilder.java", "diffHunk": "@@ -292,6 +292,14 @@ public BlockBuilder newBlockBuilderLike(BlockBuilderStatus blockBuilderStatus)\n         return new ArrayBlockBuilder(blockBuilderStatus, values.newBlockBuilderLike(blockBuilderStatus), newSize);\n     }\n \n+    @Override\n+    public BlockBuilder newBlockBuilderLike(BlockBuilderStatus blockBuilderStatus, int expectedEntries)\n+    {\n+        int newSize = max(calculateBlockResetSize(positionCount), expectedEntries);\n+        int valueExpectedEntries = positionCount == 0 ? expectedEntries : (int) (((long) offsets[positionCount] * expectedEntries) / positionCount);", "originalCommit": "1070724cbdbbad4a977294d417283b2df4750cc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1NDQ2NQ==", "url": "https://github.com/prestodb/presto/pull/15330#discussion_r510554465", "bodyText": "Yes it can. offsets[positionCount] could be millions and expectedEntries could be thousands. The following code\n        int offset = 2000000;\n        int expectedEntries = 5000;\n        int positionCount = 1000;\n        int result1 = offset * expectedEntries / positionCount;\n        int result2 = (int) ((long)offset * expectedEntries / positionCount);\n        System.out.println( result1 + \" \" + result2 );\n\noutputs\n1410065 10000000", "author": "yingsu00", "createdAt": "2020-10-23T02:06:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MjQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1Mjg0OQ==", "url": "https://github.com/prestodb/presto/pull/15330#discussion_r510552849", "bodyText": "int overflow? also use Math.toExactInt", "author": "bhhari", "createdAt": "2020-10-23T01:59:11Z", "path": "presto-common/src/main/java/com/facebook/presto/common/block/VariableWidthBlockBuilder.java", "diffHunk": "@@ -381,6 +382,15 @@ public BlockBuilder newBlockBuilderLike(BlockBuilderStatus blockBuilderStatus)\n         return new VariableWidthBlockBuilder(blockBuilderStatus, calculateBlockResetSize(positions), calculateBlockResetBytes(currentSizeInBytes));\n     }\n \n+    @Override\n+    public BlockBuilder newBlockBuilderLike(BlockBuilderStatus blockBuilderStatus, int expectedEntries)\n+    {\n+        int currentSizeInBytes = offsets[positions];\n+        return new VariableWidthBlockBuilder(blockBuilderStatus,\n+                max(calculateBlockResetSize(positions), expectedEntries),\n+                max(calculateBlockResetBytes(currentSizeInBytes), positions == 0 ? currentSizeInBytes : (int) ((long) currentSizeInBytes * expectedEntries) / positions));", "originalCommit": "1070724cbdbbad4a977294d417283b2df4750cc9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MzQzNA==", "url": "https://github.com/prestodb/presto/pull/15330#discussion_r510553434", "bodyText": "curious, why does 1 long take 1800 bytes?", "author": "bhhari", "createdAt": "2020-10-23T02:01:37Z", "path": "presto-main/src/test/java/com/facebook/presto/block/TestBlockBuilder.java", "diffHunk": "@@ -80,6 +83,28 @@ public void testNewBlockBuilderLike()\n             assertEquals(newPageBuilder.getBlockBuilder(i).getPositionCount(), 0);\n             assertTrue(newPageBuilder.getBlockBuilder(i).getRetainedSizeInBytes() < pageBuilder.getBlockBuilder(i).getRetainedSizeInBytes());\n         }\n+\n+        BlockBuilder newBigintBlockBuilder = bigintBlockBuilder.newBlockBuilderLike(null, 200);\n+        assertEquals(newBigintBlockBuilder.getPositionCount(), 0);\n+        assertEquals(newBigintBlockBuilder.getRetainedSizeInBytes(), 80);\n+        newBigintBlockBuilder.writeLong(0);\n+        assertEquals(newBigintBlockBuilder.getPositionCount(), 1);\n+        assertEquals(newBigintBlockBuilder.getRetainedSizeInBytes(), 1880);", "originalCommit": "1070724cbdbbad4a977294d417283b2df4750cc9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU3NTU0OA==", "url": "https://github.com/prestodb/presto/pull/15330#discussion_r510575548", "bodyText": "@bhhari It's because the new newBlockBuilderLike(null, 200) reserved space for 200 elements. I added comments for these lines:\n        // Reserved 200 longs and booleans for nulls array\n        assertEquals(newBigintBlockBuilder.getRetainedSizeInBytes(), 1880);\n\n        ...\n        // Reserved 200 varchars of average length 5.9, and 201 ints for offsets and 200 booleans for nulls\n        assertEquals(newVarcharBlockBuilder.getRetainedSizeInBytes(), 2360);\n\n        ...\n        // Reserved 200 ARRAY(ARRAY(BIGINT)), and 201 ints for offsets and 200 booleans for nulls\n        assertEquals(newArrayBlockBuilder.getRetainedSizeInBytes(), 5848);", "author": "yingsu00", "createdAt": "2020-10-23T03:37:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDU1MzQzNA=="}], "type": "inlineReview"}, {"oid": "5037f3f241aed87bbcd03725d6f6165d06bc7cc2", "url": "https://github.com/prestodb/presto/commit/5037f3f241aed87bbcd03725d6f6165d06bc7cc2", "message": "Reserve memory for nested BlockBuilders in projection\n\nIn bf4bf6a610 \"Reserve memory before projecting rows\" we created the\nBlockBuilders new every time. However, nested BlockBuilders for complex\ntypes would lose the status from previously created BlockBuilders such\nthat memory growth increased. For example, for an ARRAY(BIGINT)\nBlockBuilder, the nested LongArrayBlockBuilder would just have the same\nexpectedEntries as the ArrayBlockBuilder although the entries in the\nLongArrayBlockBuilder could be a lot more.\n\nThis commit uses the newly introduced newBlockBuilderLike() method that\nestimates the expectedEntries for nested BlockBuilders from previously\ncreated BlockBuilders. The following simple ArrayTransform query shows\nthe allocated long[] reduced from 118GB to 93GB on TPCH 100GB.\n\nselect transform(l_array, x-> x+1) from lineitem_map_array;", "committedDate": "2020-10-23T03:35:31Z", "type": "forcePushed"}, {"oid": "1ecf2dcbd3c767987080febeec2336642a92b9c6", "url": "https://github.com/prestodb/presto/commit/1ecf2dcbd3c767987080febeec2336642a92b9c6", "message": "Introduce newBlockBuilderLike() with expectedEntries", "committedDate": "2020-10-23T03:42:24Z", "type": "commit"}, {"oid": "1212cfaa8c3e1d31caa5441ffd15fec428c8f28c", "url": "https://github.com/prestodb/presto/commit/1212cfaa8c3e1d31caa5441ffd15fec428c8f28c", "message": "Reserve memory for nested BlockBuilders in projection\n\nIn bf4bf6a610 \"Reserve memory before projecting rows\" we created the\nBlockBuilders new every time. However, nested BlockBuilders for complex\ntypes would lose the status from previously created BlockBuilders such\nthat memory growth increased. For example, for an ARRAY(BIGINT)\nBlockBuilder, the nested LongArrayBlockBuilder would just have the same\nexpectedEntries as the ArrayBlockBuilder although the entries in the\nLongArrayBlockBuilder could be a lot more.\n\nThis commit uses the newly introduced newBlockBuilderLike() method that\nestimates the expectedEntries for nested BlockBuilders from previously\ncreated BlockBuilders. The following simple ArrayTransform query shows\nthe allocated long[] reduced from 118GB to 93GB on TPCH 100GB.\n\nselect transform(l_array, x-> x+1) from lineitem_map_array;", "committedDate": "2020-10-23T03:42:24Z", "type": "commit"}, {"oid": "1212cfaa8c3e1d31caa5441ffd15fec428c8f28c", "url": "https://github.com/prestodb/presto/commit/1212cfaa8c3e1d31caa5441ffd15fec428c8f28c", "message": "Reserve memory for nested BlockBuilders in projection\n\nIn bf4bf6a610 \"Reserve memory before projecting rows\" we created the\nBlockBuilders new every time. However, nested BlockBuilders for complex\ntypes would lose the status from previously created BlockBuilders such\nthat memory growth increased. For example, for an ARRAY(BIGINT)\nBlockBuilder, the nested LongArrayBlockBuilder would just have the same\nexpectedEntries as the ArrayBlockBuilder although the entries in the\nLongArrayBlockBuilder could be a lot more.\n\nThis commit uses the newly introduced newBlockBuilderLike() method that\nestimates the expectedEntries for nested BlockBuilders from previously\ncreated BlockBuilders. The following simple ArrayTransform query shows\nthe allocated long[] reduced from 118GB to 93GB on TPCH 100GB.\n\nselect transform(l_array, x-> x+1) from lineitem_map_array;", "committedDate": "2020-10-23T03:42:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE5OTQ5NA==", "url": "https://github.com/prestodb/presto/pull/15330#discussion_r511199494", "bodyText": "Why not just use newSize? Are you trying to account for some fraction of rows being null?", "author": "mbasmanova", "createdAt": "2020-10-23T23:46:18Z", "path": "presto-common/src/main/java/com/facebook/presto/common/block/RowBlockBuilder.java", "diffHunk": "@@ -298,4 +300,16 @@ public BlockBuilder newBlockBuilderLike(BlockBuilderStatus blockBuilderStatus)\n         }\n         return new RowBlockBuilder(blockBuilderStatus, newBlockBuilders, new int[newSize + 1], new boolean[newSize]);\n     }\n+\n+    @Override\n+    public BlockBuilder newBlockBuilderLike(BlockBuilderStatus blockBuilderStatus, int expectedEntries)\n+    {\n+        int newSize = max(calculateBlockResetSize(getPositionCount()), expectedEntries);\n+        BlockBuilder[] newBlockBuilders = new BlockBuilder[numFields];\n+        int nestedExpectedEntries = positionCount == 0 ? expectedEntries : toIntExact((long) fieldBlockOffsets[positionCount] * newSize / positionCount);", "originalCommit": "1ecf2dcbd3c767987080febeec2336642a92b9c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjMzOTExNQ==", "url": "https://github.com/prestodb/presto/pull/15330#discussion_r512339115", "bodyText": "@mbasmanova It's because the positions could be nulls. For example, expectedEntries could be 100 but fieldBlockOffsets[positionCount] could be 0.\nI added the following comment:\n// We still calculate the new expected fieldBlockBuilders sizes because the positions could be nulls.", "author": "yingsu00", "createdAt": "2020-10-27T00:01:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTE5OTQ5NA=="}], "type": "inlineReview"}]}