{"pr_number": 14559, "pr_title": "Implement bucketed tables for Presto on Spark", "pr_createdAt": "2020-05-19T21:30:29Z", "pr_url": "https://github.com/prestodb/presto/pull/14559", "timeline": [{"oid": "a5297c339800fd28016ddaac141d98258333e1a3", "url": "https://github.com/prestodb/presto/commit/a5297c339800fd28016ddaac141d98258333e1a3", "message": "Reduce spark integration tests memory footprint", "committedDate": "2020-05-20T02:24:00Z", "type": "forcePushed"}, {"oid": "f73c3821001ed3e069c2a8e9f301cb8390c596a1", "url": "https://github.com/prestodb/presto/commit/f73c3821001ed3e069c2a8e9f301cb8390c596a1", "message": "Reduce spark integration tests memory footprint", "committedDate": "2020-05-20T02:31:46Z", "type": "forcePushed"}, {"oid": "76537e8d3d2f427c8048132ce2a35a18202bf3ad", "url": "https://github.com/prestodb/presto/commit/76537e8d3d2f427c8048132ce2a35a18202bf3ad", "message": "Enable collocated join for Presto on Spark", "committedDate": "2020-05-22T21:41:52Z", "type": "forcePushed"}, {"oid": "ecb7c56cc35eb5f2468c837483e8db92e0a19de2", "url": "https://github.com/prestodb/presto/commit/ecb7c56cc35eb5f2468c837483e8db92e0a19de2", "message": "Enable collocated join for Presto on Spark", "committedDate": "2020-06-02T18:30:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzMjU1Mg==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r436332552", "bodyText": "One theoretic caveat here is the number of buckets, returned by getBucketNodeMap and getBucketCount can be different if the number of nodes changed during the two method calls. Since nodeManager.getRequiredWorkerNodes() will return different list.\nHowever, this would only happen for 3 testing connector: BlackHole, TPCDS, TPCH as the \"partitioning handle\" is somewhat artificial in these connectors. For \"real\" connector partitioning handle, the number of buckets should be a constant property in the partitioning handle, thus. it's not a problem.\nI think the right long term solution is to allow connector partitioning handle to return the number of buckets :). So the current implementation looks OK.\nBTW: can we just throw in getBucketCount for BlackHole, TPCDS and TPCH connector?", "author": "wenleix", "createdAt": "2020-06-07T07:01:15Z", "path": "presto-tpcds/src/main/java/com/facebook/presto/tpcds/TpcdsNodePartitioningProvider.java", "diffHunk": "@@ -70,4 +70,12 @@ public BucketFunction getBucketFunction(ConnectorTransactionHandle transactionHa\n     {\n         throw new UnsupportedOperationException();\n     }\n+\n+    @Override\n+    public int getBucketCount(ConnectorTransactionHandle transactionHandle, ConnectorSession session, ConnectorPartitioningHandle partitioningHandle)\n+    {\n+        Set<Node> nodes = nodeManager.getRequiredWorkerNodes();", "originalCommit": "d3d04114b4123d0d3abb7bf84a090f25f543ad0c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTAzNzA3NQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439037075", "bodyText": "One theoretic caveat here is the number of buckets, returned by getBucketNodeMap and getBucketCount can be different if the number of nodes changed during the two method calls. Since nodeManager.getRequiredWorkerNodes() will return different list.\n\nYeah, that is in theory possible. However it is also possible that getBucketNodeMap called multiple times may return different bucket count. But I agree, that is a little brittle.\n\nBTW: can we just throw in getBucketCount for BlackHole, TPCDS and TPCH connector?\n\nI would prefer to keep it as is, as it is sometimes useful to have TPC-DC and TPC-H connectors enabled in Presto on Spark.", "author": "arhimondr", "createdAt": "2020-06-11T20:04:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzMjU1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzMDQ0MA==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439230440", "bodyText": "Yeah, that is in theory possible. However it is also possible that getBucketNodeMap called multiple times may return different bucket count. But I agree, that is a little brittle.\n\nRight. Long long ago (before grouped execution), getBucketNodeMap is only called once in execution. Now we already called once in PlanFragmenter, once in execution.\nAnyhow. :)", "author": "wenleix", "createdAt": "2020-06-12T06:27:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzMjU1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzMzIzOA==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r436333238", "bodyText": "nit: maybe call it SerializedPrestoSparkTaskSource? -- so when other Presto developers search for TaskSource, they don't need to worry about \"SerializedTaskSource\":", "author": "wenleix", "createdAt": "2020-06-07T07:10:56Z", "path": "presto-spark-classloader-interface/src/main/java/com/facebook/presto/spark/classloader_interface/SerializedTaskSource.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spark.classloader_interface;\n+\n+import java.io.Serializable;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+public class SerializedTaskSource", "originalCommit": "0ae646de13bb51d9f29786b85fb589ddca30b1a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzMzUxNw==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r436333517", "bodyText": "nit: do you mean set the number of output partitions?", "author": "wenleix", "createdAt": "2020-06-07T07:14:46Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/planner/PrestoSparkRddFactory.java", "diffHunk": "@@ -153,20 +152,10 @@ public PrestoSparkRddFactory(SplitManager splitManager, Metadata metadata, JsonC\n         // TODO: We should consider removing ARBITRARY_DISTRIBUTION.\n         checkArgument(!partitioning.equals(ARBITRARY_DISTRIBUTION), \"ARBITRARY_DISTRIBUTION is not expected to be set as a fragment distribution\");\n \n-        int hashPartitionCount = getHashPartitionCount(session);\n-\n-        // configure number of output partitions\n-        if (fragment.getPartitioningScheme().getPartitioning().getHandle().equals(FIXED_HASH_DISTRIBUTION)) {\n-            fragment = fragment.withBucketToPartition(Optional.of(IntStream.range(0, hashPartitionCount).toArray()));\n-        }\n-\n-        if (partitioning.equals(SINGLE_DISTRIBUTION) || partitioning.equals(FIXED_HASH_DISTRIBUTION)) {\n-            checkArgument(\n-                    fragment.getTableScanSchedulingOrder().isEmpty(),\n-                    \"Fragment with is not expected to have table scans. fragmentId: %s, fragment partitioning %s\",\n-                    fragment.getId(),\n-                    fragment.getPartitioning());\n+        // set's the number of output partitions", "originalCommit": "0ae646de13bb51d9f29786b85fb589ddca30b1a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNDEwMg==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r436334102", "bodyText": "As you might guess, I will use more \"plain\" style if,list,for-loop for line 290-303 \ud83d\ude03 . But it's personal taste.", "author": "wenleix", "createdAt": "2020-06-07T07:23:08Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/planner/PrestoSparkRddFactory.java", "diffHunk": "@@ -230,90 +217,97 @@ private static Partitioner createPartitioner(PartitioningHandle partitioning, in\n     {\n         checkInputs(fragment.getRemoteSourceNodes(), rddInputs, broadcastInputs);\n \n-        List<TableScanNode> tableScans = findTableScanNodes(fragment.getRoot());\n-        verify(tableScans.isEmpty(), \"no table scans is expected\");\n-\n-        PrestoSparkTaskDescriptor taskDescriptor = createIntermediateTaskDescriptor(session, tableWriteInfo, fragment);\n-        SerializedPrestoSparkTaskDescriptor serializedTaskDescriptor = new SerializedPrestoSparkTaskDescriptor(taskDescriptorJsonCodec.toJsonBytes(taskDescriptor));\n-\n-        if (rddInputs.size() == 0) {\n-            checkArgument(fragment.getPartitioning().equals(SINGLE_DISTRIBUTION), \"SINGLE_DISTRIBUTION partitioning is expected: %s\", fragment.getPartitioning());\n-            return sparkContext.parallelize(ImmutableList.of(serializedTaskDescriptor), 1)\n-                    .mapPartitionsToPair(createTaskProcessor(\n-                            executorFactoryProvider,\n-                            taskStatsCollector,\n-                            toTaskProcessorBroadcastInputs(broadcastInputs)));\n-        }\n+        PrestoSparkTaskDescriptor taskDescriptor = new PrestoSparkTaskDescriptor(\n+                session.toSessionRepresentation(),\n+                session.getIdentity().getExtraCredentials(),\n+                fragment,\n+                tableWriteInfo);\n+        SerializedPrestoSparkTaskDescriptor serializedTaskDescriptor = new SerializedPrestoSparkTaskDescriptor(\n+                taskDescriptorJsonCodec.toJsonBytes(taskDescriptor));\n \n+        Optional<Integer> numberOfInputPartitions = Optional.empty();\n         ImmutableList.Builder<String> fragmentIds = ImmutableList.builder();\n-        ImmutableList.Builder<RDD<Tuple2<Integer, PrestoSparkRow>>> rdds = ImmutableList.builder();\n+        ImmutableList.Builder<RDD<Tuple2<Integer, PrestoSparkRow>>> inputRdds = ImmutableList.builder();\n         for (Map.Entry<PlanFragmentId, JavaPairRDD<Integer, PrestoSparkRow>> input : rddInputs.entrySet()) {\n             fragmentIds.add(input.getKey().toString());\n-            rdds.add(input.getValue().rdd());\n+            RDD<Tuple2<Integer, PrestoSparkRow>> rdd = input.getValue().rdd();\n+            inputRdds.add(rdd);\n+            if (!numberOfInputPartitions.isPresent()) {\n+                numberOfInputPartitions = Optional.of(rdd.getNumPartitions());\n+            }\n+            else {\n+                checkArgument(\n+                        numberOfInputPartitions.get() == rdd.getNumPartitions(),\n+                        \"Incompatible number of input partitions: %s != %s\",\n+                        numberOfInputPartitions.get(),\n+                        rdd.getNumPartitions());\n+            }\n         }\n \n-        Function<List<Iterator<Tuple2<Integer, PrestoSparkRow>>>, Iterator<Tuple2<Integer, PrestoSparkRow>>> taskProcessor = createTaskProcessor(\n+        PrestoSparkTaskProcessor taskProcessor = new PrestoSparkTaskProcessor(\n                 executorFactoryProvider,\n                 serializedTaskDescriptor,\n                 fragmentIds.build(),\n                 taskStatsCollector,\n                 toTaskProcessorBroadcastInputs(broadcastInputs));\n \n+        Optional<RDD<SerializedTaskSource>> taskSourceRdd;\n+        List<TableScanNode> tableScans = findTableScanNodes(fragment.getRoot());\n+        if (!tableScans.isEmpty()) {\n+            PartitioningHandle partitioning = fragment.getPartitioning();\n+            taskSourceRdd = Optional.of(createTaskSourcesRdd(sparkContext, session, partitioning, tableScans, numberOfInputPartitions).rdd());\n+        }\n+        else if (rddInputs.size() == 0) {\n+            checkArgument(fragment.getPartitioning().equals(SINGLE_DISTRIBUTION), \"SINGLE_DISTRIBUTION partitioning is expected: %s\", fragment.getPartitioning());\n+            taskSourceRdd = Optional.of(new PrestoSparkTaskSourceRdd(sparkContext.sc(), ImmutableList.of(ImmutableList.of())));\n+        }\n+        else {\n+            taskSourceRdd = Optional.empty();\n+        }\n+\n         return JavaPairRDD.fromRDD(\n-                new PrestoSparkZipRdd(sparkContext.sc(), rdds.build(), taskProcessor),\n+                new PrestoSparkTaskRdd(sparkContext.sc(), taskSourceRdd, inputRdds.build(), taskProcessor),\n                 classTag(Integer.class),\n                 classTag(PrestoSparkRow.class));\n     }\n \n-    private JavaPairRDD<Integer, PrestoSparkRow> createSourceRdd(\n+    private JavaRDD<SerializedTaskSource> createTaskSourcesRdd(\n             JavaSparkContext sparkContext,\n             Session session,\n-            PlanFragment fragment,\n-            PrestoSparkTaskExecutorFactoryProvider executorFactoryProvider,\n-            CollectionAccumulator<SerializedTaskStats> taskStatsCollector,\n-            TableWriteInfo tableWriteInfo,\n-            Map<PlanFragmentId, Broadcast<List<PrestoSparkSerializedPage>>> broadcastInputs)\n+            PartitioningHandle partitioning,\n+            List<TableScanNode> tableScans,\n+            Optional<Integer> expectedNumberOfPartitions)\n     {\n-        checkInputs(fragment.getRemoteSourceNodes(), ImmutableMap.of(), broadcastInputs);\n-\n-        List<TableScanNode> tableScans = findTableScanNodes(fragment.getRoot());\n-        checkArgument(\n-                tableScans.size() == 1,\n-                \"exactly one table scan is expected in SOURCE_DISTRIBUTION fragment. fragmentId: %s, actual number of table scans: %s\",\n-                fragment.getId(),\n-                tableScans.size());\n-\n-        TableScanNode tableScan = getOnlyElement(tableScans);\n-\n-        List<ScheduledSplit> splits = getSplits(session, tableScan);\n-        shuffle(splits);\n-        int initialPartitionCount = getSparkInitialPartitionCount(session);\n-        int numTasks = Math.min(splits.size(), initialPartitionCount);\n-        if (numTasks == 0) {\n-            return JavaPairRDD.fromJavaRDD(sparkContext.emptyRDD());\n+        ListMultimap<Integer, TaskSource> taskSourcesMap = ArrayListMultimap.create();\n+        for (TableScanNode tableScan : tableScans) {\n+            List<ScheduledSplit> scheduledSplits = getSplits(session, tableScan);\n+            shuffle(scheduledSplits);\n+            SetMultimap<Integer, ScheduledSplit> assignedSplits = assignSplitsToTasks(session, partitioning, scheduledSplits);\n+            asMap(assignedSplits).forEach((partitionId, splits) ->\n+                    taskSourcesMap.put(partitionId, new TaskSource(tableScan.getId(), splits, true)));\n         }\n \n-        List<List<ScheduledSplit>> assignedSplits = assignSplitsToTasks(splits, numTasks);\n-\n-        // let the garbage collector reclaim the memory used by the decoded splits as soon as the task descriptor is encoded\n-        splits = null;\n-\n-        ImmutableList.Builder<SerializedPrestoSparkTaskDescriptor> serializedTaskDescriptors = ImmutableList.builder();\n-        for (int i = 0; i < assignedSplits.size(); i++) {\n-            List<ScheduledSplit> splitBatch = assignedSplits.get(i);\n-            PrestoSparkTaskDescriptor taskDescriptor = createSourceTaskDescriptor(session, tableWriteInfo, fragment, splitBatch);\n-            // TODO: consider more efficient serialization or apply compression to save precious memory on the Driver\n-            byte[] jsonSerializedTaskDescriptor = taskDescriptorJsonCodec.toJsonBytes(taskDescriptor);\n-            serializedTaskDescriptors.add(new SerializedPrestoSparkTaskDescriptor(jsonSerializedTaskDescriptor));\n-            // let the garbage collector reclaim the memory used by the decoded splits as soon as the task descriptor is encoded\n-            assignedSplits.set(i, null);\n+        IntStream partitions = expectedNumberOfPartitions", "originalCommit": "0ae646de13bb51d9f29786b85fb589ddca30b1a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA0MTc5MQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439041791", "bodyText": "I actually wanted to use IntStream specifically to avoid materializing IntStream.range(0, integer)", "author": "arhimondr", "createdAt": "2020-06-11T20:11:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNDEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzMDA4Ng==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439230086", "bodyText": "I actually wanted to use IntStream specifically to avoid materializing IntStream.range(0, integer)\n\nWhy not just using for loop? ...", "author": "wenleix", "createdAt": "2020-06-12T06:26:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNDEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM2MjI2OA==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439362268", "bodyText": "You will have to loop either over the partitions from taskSourcesMap or over all partitions provided by expectedNumberOfPartitions . With simple for loop it seems like you would have to duplicate the loop body twice.", "author": "arhimondr", "createdAt": "2020-06-12T11:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNDEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MTEyOQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439791129", "bodyText": "@arhimondr : Stream API often yields non-trivial performance overhead (see, for example #11374) . And I don't think this part of code is performance sensitive? (it's just doing plan once on Driver?)\nI personally prefer not using Stream API unless it's pretty clear (e.g. the classic .map().filter().XXX pattern. This has also been discussed in #11374 (comment) . And I also have expressed similar ideas in my other code reviews.\nI understand a general policy discussion about Stream API should be done by TSC.\nIn this specific case, I found it make hard for me to follow the core logic with Stream API \ud83d\ude15", "author": "wenleix", "createdAt": "2020-06-14T04:42:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNDEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MzMyMQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439793321", "bodyText": "@arhimondr : Java Stream API can also have non-trivial memory allocation overhead, see #13984", "author": "wenleix", "createdAt": "2020-06-14T05:27:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNDEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMwNDA3Ng==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r440304076", "bodyText": "Replaces with 2 branches and regular loops. Added comments.", "author": "arhimondr", "createdAt": "2020-06-15T16:36:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNDEwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNDEyNw==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r436334127", "bodyText": "Add a comment explain why eagerly remove the task sources (GC, right? )", "author": "wenleix", "createdAt": "2020-06-07T07:23:36Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/planner/PrestoSparkRddFactory.java", "diffHunk": "@@ -230,90 +217,97 @@ private static Partitioner createPartitioner(PartitioningHandle partitioning, in\n     {\n         checkInputs(fragment.getRemoteSourceNodes(), rddInputs, broadcastInputs);\n \n-        List<TableScanNode> tableScans = findTableScanNodes(fragment.getRoot());\n-        verify(tableScans.isEmpty(), \"no table scans is expected\");\n-\n-        PrestoSparkTaskDescriptor taskDescriptor = createIntermediateTaskDescriptor(session, tableWriteInfo, fragment);\n-        SerializedPrestoSparkTaskDescriptor serializedTaskDescriptor = new SerializedPrestoSparkTaskDescriptor(taskDescriptorJsonCodec.toJsonBytes(taskDescriptor));\n-\n-        if (rddInputs.size() == 0) {\n-            checkArgument(fragment.getPartitioning().equals(SINGLE_DISTRIBUTION), \"SINGLE_DISTRIBUTION partitioning is expected: %s\", fragment.getPartitioning());\n-            return sparkContext.parallelize(ImmutableList.of(serializedTaskDescriptor), 1)\n-                    .mapPartitionsToPair(createTaskProcessor(\n-                            executorFactoryProvider,\n-                            taskStatsCollector,\n-                            toTaskProcessorBroadcastInputs(broadcastInputs)));\n-        }\n+        PrestoSparkTaskDescriptor taskDescriptor = new PrestoSparkTaskDescriptor(\n+                session.toSessionRepresentation(),\n+                session.getIdentity().getExtraCredentials(),\n+                fragment,\n+                tableWriteInfo);\n+        SerializedPrestoSparkTaskDescriptor serializedTaskDescriptor = new SerializedPrestoSparkTaskDescriptor(\n+                taskDescriptorJsonCodec.toJsonBytes(taskDescriptor));\n \n+        Optional<Integer> numberOfInputPartitions = Optional.empty();\n         ImmutableList.Builder<String> fragmentIds = ImmutableList.builder();\n-        ImmutableList.Builder<RDD<Tuple2<Integer, PrestoSparkRow>>> rdds = ImmutableList.builder();\n+        ImmutableList.Builder<RDD<Tuple2<Integer, PrestoSparkRow>>> inputRdds = ImmutableList.builder();\n         for (Map.Entry<PlanFragmentId, JavaPairRDD<Integer, PrestoSparkRow>> input : rddInputs.entrySet()) {\n             fragmentIds.add(input.getKey().toString());\n-            rdds.add(input.getValue().rdd());\n+            RDD<Tuple2<Integer, PrestoSparkRow>> rdd = input.getValue().rdd();\n+            inputRdds.add(rdd);\n+            if (!numberOfInputPartitions.isPresent()) {\n+                numberOfInputPartitions = Optional.of(rdd.getNumPartitions());\n+            }\n+            else {\n+                checkArgument(\n+                        numberOfInputPartitions.get() == rdd.getNumPartitions(),\n+                        \"Incompatible number of input partitions: %s != %s\",\n+                        numberOfInputPartitions.get(),\n+                        rdd.getNumPartitions());\n+            }\n         }\n \n-        Function<List<Iterator<Tuple2<Integer, PrestoSparkRow>>>, Iterator<Tuple2<Integer, PrestoSparkRow>>> taskProcessor = createTaskProcessor(\n+        PrestoSparkTaskProcessor taskProcessor = new PrestoSparkTaskProcessor(\n                 executorFactoryProvider,\n                 serializedTaskDescriptor,\n                 fragmentIds.build(),\n                 taskStatsCollector,\n                 toTaskProcessorBroadcastInputs(broadcastInputs));\n \n+        Optional<RDD<SerializedTaskSource>> taskSourceRdd;\n+        List<TableScanNode> tableScans = findTableScanNodes(fragment.getRoot());\n+        if (!tableScans.isEmpty()) {\n+            PartitioningHandle partitioning = fragment.getPartitioning();\n+            taskSourceRdd = Optional.of(createTaskSourcesRdd(sparkContext, session, partitioning, tableScans, numberOfInputPartitions).rdd());\n+        }\n+        else if (rddInputs.size() == 0) {\n+            checkArgument(fragment.getPartitioning().equals(SINGLE_DISTRIBUTION), \"SINGLE_DISTRIBUTION partitioning is expected: %s\", fragment.getPartitioning());\n+            taskSourceRdd = Optional.of(new PrestoSparkTaskSourceRdd(sparkContext.sc(), ImmutableList.of(ImmutableList.of())));\n+        }\n+        else {\n+            taskSourceRdd = Optional.empty();\n+        }\n+\n         return JavaPairRDD.fromRDD(\n-                new PrestoSparkZipRdd(sparkContext.sc(), rdds.build(), taskProcessor),\n+                new PrestoSparkTaskRdd(sparkContext.sc(), taskSourceRdd, inputRdds.build(), taskProcessor),\n                 classTag(Integer.class),\n                 classTag(PrestoSparkRow.class));\n     }\n \n-    private JavaPairRDD<Integer, PrestoSparkRow> createSourceRdd(\n+    private JavaRDD<SerializedTaskSource> createTaskSourcesRdd(\n             JavaSparkContext sparkContext,\n             Session session,\n-            PlanFragment fragment,\n-            PrestoSparkTaskExecutorFactoryProvider executorFactoryProvider,\n-            CollectionAccumulator<SerializedTaskStats> taskStatsCollector,\n-            TableWriteInfo tableWriteInfo,\n-            Map<PlanFragmentId, Broadcast<List<PrestoSparkSerializedPage>>> broadcastInputs)\n+            PartitioningHandle partitioning,\n+            List<TableScanNode> tableScans,\n+            Optional<Integer> expectedNumberOfPartitions)\n     {\n-        checkInputs(fragment.getRemoteSourceNodes(), ImmutableMap.of(), broadcastInputs);\n-\n-        List<TableScanNode> tableScans = findTableScanNodes(fragment.getRoot());\n-        checkArgument(\n-                tableScans.size() == 1,\n-                \"exactly one table scan is expected in SOURCE_DISTRIBUTION fragment. fragmentId: %s, actual number of table scans: %s\",\n-                fragment.getId(),\n-                tableScans.size());\n-\n-        TableScanNode tableScan = getOnlyElement(tableScans);\n-\n-        List<ScheduledSplit> splits = getSplits(session, tableScan);\n-        shuffle(splits);\n-        int initialPartitionCount = getSparkInitialPartitionCount(session);\n-        int numTasks = Math.min(splits.size(), initialPartitionCount);\n-        if (numTasks == 0) {\n-            return JavaPairRDD.fromJavaRDD(sparkContext.emptyRDD());\n+        ListMultimap<Integer, TaskSource> taskSourcesMap = ArrayListMultimap.create();\n+        for (TableScanNode tableScan : tableScans) {\n+            List<ScheduledSplit> scheduledSplits = getSplits(session, tableScan);\n+            shuffle(scheduledSplits);\n+            SetMultimap<Integer, ScheduledSplit> assignedSplits = assignSplitsToTasks(session, partitioning, scheduledSplits);\n+            asMap(assignedSplits).forEach((partitionId, splits) ->\n+                    taskSourcesMap.put(partitionId, new TaskSource(tableScan.getId(), splits, true)));\n         }\n \n-        List<List<ScheduledSplit>> assignedSplits = assignSplitsToTasks(splits, numTasks);\n-\n-        // let the garbage collector reclaim the memory used by the decoded splits as soon as the task descriptor is encoded\n-        splits = null;\n-\n-        ImmutableList.Builder<SerializedPrestoSparkTaskDescriptor> serializedTaskDescriptors = ImmutableList.builder();\n-        for (int i = 0; i < assignedSplits.size(); i++) {\n-            List<ScheduledSplit> splitBatch = assignedSplits.get(i);\n-            PrestoSparkTaskDescriptor taskDescriptor = createSourceTaskDescriptor(session, tableWriteInfo, fragment, splitBatch);\n-            // TODO: consider more efficient serialization or apply compression to save precious memory on the Driver\n-            byte[] jsonSerializedTaskDescriptor = taskDescriptorJsonCodec.toJsonBytes(taskDescriptor);\n-            serializedTaskDescriptors.add(new SerializedPrestoSparkTaskDescriptor(jsonSerializedTaskDescriptor));\n-            // let the garbage collector reclaim the memory used by the decoded splits as soon as the task descriptor is encoded\n-            assignedSplits.set(i, null);\n+        IntStream partitions = expectedNumberOfPartitions\n+                .map(integer -> IntStream.range(0, integer))\n+                .orElseGet(() -> new ArrayList<>(taskSourcesMap.keySet()).stream().mapToInt(Integer::intValue));\n+\n+        List<List<SerializedTaskSource>> partitionedTaskSources = new ArrayList<>();\n+        partitions.forEach(partition -> {\n+            List<TaskSource> taskSources = taskSourcesMap.removeAll(partition);", "originalCommit": "0ae646de13bb51d9f29786b85fb589ddca30b1a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA0MjczNw==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439042737", "bodyText": "Added a comment", "author": "arhimondr", "createdAt": "2020-06-11T20:12:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNDEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNDM2NA==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r436334364", "bodyText": "curious: why using SetMultimap instead of ListMultimap?", "author": "wenleix", "createdAt": "2020-06-07T07:27:17Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/planner/PrestoSparkRddFactory.java", "diffHunk": "@@ -330,49 +324,24 @@ private static Partitioner createPartitioner(PartitioningHandle partitioning, in\n         return splits;\n     }\n \n-    private static List<List<ScheduledSplit>> assignSplitsToTasks(List<ScheduledSplit> splits, int numTasks)\n+    private SetMultimap<Integer, ScheduledSplit> assignSplitsToTasks(Session session, PartitioningHandle partitioning, List<ScheduledSplit> splits)", "originalCommit": "0ae646de13bb51d9f29786b85fb589ddca30b1a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA0MzE5Mw==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439043193", "bodyText": "TaskSource takes Set<ScheduledSplit> splits =\\", "author": "arhimondr", "createdAt": "2020-06-11T20:13:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNDM2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNDQ1Ng==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r436334456", "bodyText": "nit: why not just using a for-each loop? ;)", "author": "wenleix", "createdAt": "2020-06-07T07:28:38Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/planner/PrestoSparkRddFactory.java", "diffHunk": "@@ -230,90 +217,97 @@ private static Partitioner createPartitioner(PartitioningHandle partitioning, in\n     {\n         checkInputs(fragment.getRemoteSourceNodes(), rddInputs, broadcastInputs);\n \n-        List<TableScanNode> tableScans = findTableScanNodes(fragment.getRoot());\n-        verify(tableScans.isEmpty(), \"no table scans is expected\");\n-\n-        PrestoSparkTaskDescriptor taskDescriptor = createIntermediateTaskDescriptor(session, tableWriteInfo, fragment);\n-        SerializedPrestoSparkTaskDescriptor serializedTaskDescriptor = new SerializedPrestoSparkTaskDescriptor(taskDescriptorJsonCodec.toJsonBytes(taskDescriptor));\n-\n-        if (rddInputs.size() == 0) {\n-            checkArgument(fragment.getPartitioning().equals(SINGLE_DISTRIBUTION), \"SINGLE_DISTRIBUTION partitioning is expected: %s\", fragment.getPartitioning());\n-            return sparkContext.parallelize(ImmutableList.of(serializedTaskDescriptor), 1)\n-                    .mapPartitionsToPair(createTaskProcessor(\n-                            executorFactoryProvider,\n-                            taskStatsCollector,\n-                            toTaskProcessorBroadcastInputs(broadcastInputs)));\n-        }\n+        PrestoSparkTaskDescriptor taskDescriptor = new PrestoSparkTaskDescriptor(\n+                session.toSessionRepresentation(),\n+                session.getIdentity().getExtraCredentials(),\n+                fragment,\n+                tableWriteInfo);\n+        SerializedPrestoSparkTaskDescriptor serializedTaskDescriptor = new SerializedPrestoSparkTaskDescriptor(\n+                taskDescriptorJsonCodec.toJsonBytes(taskDescriptor));\n \n+        Optional<Integer> numberOfInputPartitions = Optional.empty();\n         ImmutableList.Builder<String> fragmentIds = ImmutableList.builder();\n-        ImmutableList.Builder<RDD<Tuple2<Integer, PrestoSparkRow>>> rdds = ImmutableList.builder();\n+        ImmutableList.Builder<RDD<Tuple2<Integer, PrestoSparkRow>>> inputRdds = ImmutableList.builder();\n         for (Map.Entry<PlanFragmentId, JavaPairRDD<Integer, PrestoSparkRow>> input : rddInputs.entrySet()) {\n             fragmentIds.add(input.getKey().toString());\n-            rdds.add(input.getValue().rdd());\n+            RDD<Tuple2<Integer, PrestoSparkRow>> rdd = input.getValue().rdd();\n+            inputRdds.add(rdd);\n+            if (!numberOfInputPartitions.isPresent()) {\n+                numberOfInputPartitions = Optional.of(rdd.getNumPartitions());\n+            }\n+            else {\n+                checkArgument(\n+                        numberOfInputPartitions.get() == rdd.getNumPartitions(),\n+                        \"Incompatible number of input partitions: %s != %s\",\n+                        numberOfInputPartitions.get(),\n+                        rdd.getNumPartitions());\n+            }\n         }\n \n-        Function<List<Iterator<Tuple2<Integer, PrestoSparkRow>>>, Iterator<Tuple2<Integer, PrestoSparkRow>>> taskProcessor = createTaskProcessor(\n+        PrestoSparkTaskProcessor taskProcessor = new PrestoSparkTaskProcessor(\n                 executorFactoryProvider,\n                 serializedTaskDescriptor,\n                 fragmentIds.build(),\n                 taskStatsCollector,\n                 toTaskProcessorBroadcastInputs(broadcastInputs));\n \n+        Optional<RDD<SerializedTaskSource>> taskSourceRdd;\n+        List<TableScanNode> tableScans = findTableScanNodes(fragment.getRoot());\n+        if (!tableScans.isEmpty()) {\n+            PartitioningHandle partitioning = fragment.getPartitioning();\n+            taskSourceRdd = Optional.of(createTaskSourcesRdd(sparkContext, session, partitioning, tableScans, numberOfInputPartitions).rdd());\n+        }\n+        else if (rddInputs.size() == 0) {\n+            checkArgument(fragment.getPartitioning().equals(SINGLE_DISTRIBUTION), \"SINGLE_DISTRIBUTION partitioning is expected: %s\", fragment.getPartitioning());\n+            taskSourceRdd = Optional.of(new PrestoSparkTaskSourceRdd(sparkContext.sc(), ImmutableList.of(ImmutableList.of())));\n+        }\n+        else {\n+            taskSourceRdd = Optional.empty();\n+        }\n+\n         return JavaPairRDD.fromRDD(\n-                new PrestoSparkZipRdd(sparkContext.sc(), rdds.build(), taskProcessor),\n+                new PrestoSparkTaskRdd(sparkContext.sc(), taskSourceRdd, inputRdds.build(), taskProcessor),\n                 classTag(Integer.class),\n                 classTag(PrestoSparkRow.class));\n     }\n \n-    private JavaPairRDD<Integer, PrestoSparkRow> createSourceRdd(\n+    private JavaRDD<SerializedTaskSource> createTaskSourcesRdd(\n             JavaSparkContext sparkContext,\n             Session session,\n-            PlanFragment fragment,\n-            PrestoSparkTaskExecutorFactoryProvider executorFactoryProvider,\n-            CollectionAccumulator<SerializedTaskStats> taskStatsCollector,\n-            TableWriteInfo tableWriteInfo,\n-            Map<PlanFragmentId, Broadcast<List<PrestoSparkSerializedPage>>> broadcastInputs)\n+            PartitioningHandle partitioning,\n+            List<TableScanNode> tableScans,\n+            Optional<Integer> expectedNumberOfPartitions)\n     {\n-        checkInputs(fragment.getRemoteSourceNodes(), ImmutableMap.of(), broadcastInputs);\n-\n-        List<TableScanNode> tableScans = findTableScanNodes(fragment.getRoot());\n-        checkArgument(\n-                tableScans.size() == 1,\n-                \"exactly one table scan is expected in SOURCE_DISTRIBUTION fragment. fragmentId: %s, actual number of table scans: %s\",\n-                fragment.getId(),\n-                tableScans.size());\n-\n-        TableScanNode tableScan = getOnlyElement(tableScans);\n-\n-        List<ScheduledSplit> splits = getSplits(session, tableScan);\n-        shuffle(splits);\n-        int initialPartitionCount = getSparkInitialPartitionCount(session);\n-        int numTasks = Math.min(splits.size(), initialPartitionCount);\n-        if (numTasks == 0) {\n-            return JavaPairRDD.fromJavaRDD(sparkContext.emptyRDD());\n+        ListMultimap<Integer, TaskSource> taskSourcesMap = ArrayListMultimap.create();\n+        for (TableScanNode tableScan : tableScans) {\n+            List<ScheduledSplit> scheduledSplits = getSplits(session, tableScan);\n+            shuffle(scheduledSplits);\n+            SetMultimap<Integer, ScheduledSplit> assignedSplits = assignSplitsToTasks(session, partitioning, scheduledSplits);\n+            asMap(assignedSplits).forEach((partitionId, splits) ->", "originalCommit": "0ae646de13bb51d9f29786b85fb589ddca30b1a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA0NDA1MQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439044051", "bodyText": "I like this style as you can give a key and a value a meaningful name\n\n(partitionId, splits) ->", "author": "arhimondr", "createdAt": "2020-06-11T20:14:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNDQ1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNDg2OA==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r436334868", "bodyText": "So now the anonymous lambda created in legacy TaskProcessors now has dedicated named class, this is great.\nCurious why this class has to stay in classloader_interface ?", "author": "wenleix", "createdAt": "2020-06-07T07:33:47Z", "path": "presto-spark-classloader-interface/src/main/java/com/facebook/presto/spark/classloader_interface/PrestoSparkTaskProcessor.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spark.classloader_interface;\n+\n+import org.apache.spark.TaskContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.util.CollectionAccumulator;\n+import scala.Tuple2;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Collections.unmodifiableMap;\n+import static java.util.Objects.requireNonNull;\n+\n+public class PrestoSparkTaskProcessor", "originalCommit": "0ae646de13bb51d9f29786b85fb589ddca30b1a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA0NDc4Ng==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439044786", "bodyText": "It has to be serializable. If it is loaded not by the Spark class loader it cannot get serialized =\\", "author": "arhimondr", "createdAt": "2020-06-11T20:15:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNDg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNDg3NQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r436334875", "bodyText": "maybe call it process? :)", "author": "wenleix", "createdAt": "2020-06-07T07:33:56Z", "path": "presto-spark-classloader-interface/src/main/java/com/facebook/presto/spark/classloader_interface/PrestoSparkTaskProcessor.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spark.classloader_interface;\n+\n+import org.apache.spark.TaskContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.util.CollectionAccumulator;\n+import scala.Tuple2;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Collections.unmodifiableMap;\n+import static java.util.Objects.requireNonNull;\n+\n+public class PrestoSparkTaskProcessor\n+        implements Serializable\n+{\n+    private final PrestoSparkTaskExecutorFactoryProvider taskExecutorFactoryProvider;\n+    private final SerializedPrestoSparkTaskDescriptor serializedTaskDescriptor;\n+    private final List<String> fragmentIds;\n+    private final CollectionAccumulator<SerializedTaskStats> taskStatsCollector;\n+    // fragmentId -> Broadcast\n+    private final Map<String, Broadcast<List<PrestoSparkSerializedPage>>> broadcastInputs;\n+\n+    public PrestoSparkTaskProcessor(\n+            PrestoSparkTaskExecutorFactoryProvider taskExecutorFactoryProvider,\n+            SerializedPrestoSparkTaskDescriptor serializedTaskDescriptor,\n+            List<String> fragmentIds,\n+            CollectionAccumulator<SerializedTaskStats> taskStatsCollector,\n+            Map<String, Broadcast<List<PrestoSparkSerializedPage>>> broadcastInputs)\n+    {\n+        this.taskExecutorFactoryProvider = requireNonNull(taskExecutorFactoryProvider, \"taskExecutorFactoryProvider is null\");\n+        this.serializedTaskDescriptor = requireNonNull(serializedTaskDescriptor, \"serializedTaskDescriptor is null\");\n+        this.fragmentIds = unmodifiableList(new ArrayList<>(requireNonNull(fragmentIds, \"fragmentIds is null\")));\n+        this.taskStatsCollector = requireNonNull(taskStatsCollector, \"taskStatsCollector is null\");\n+        this.broadcastInputs = unmodifiableMap(new HashMap<>(requireNonNull(broadcastInputs, \"broadcastInputs is null\")));\n+    }\n+\n+    public Iterator<Tuple2<Integer, PrestoSparkRow>> apply(", "originalCommit": "0ae646de13bb51d9f29786b85fb589ddca30b1a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNDk3NQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r436334975", "bodyText": "should there be a check that fragmentIds.size() == inputs.size() ?", "author": "wenleix", "createdAt": "2020-06-07T07:35:30Z", "path": "presto-spark-classloader-interface/src/main/java/com/facebook/presto/spark/classloader_interface/PrestoSparkTaskProcessor.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spark.classloader_interface;\n+\n+import org.apache.spark.TaskContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.util.CollectionAccumulator;\n+import scala.Tuple2;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Collections.unmodifiableMap;\n+import static java.util.Objects.requireNonNull;\n+\n+public class PrestoSparkTaskProcessor\n+        implements Serializable\n+{\n+    private final PrestoSparkTaskExecutorFactoryProvider taskExecutorFactoryProvider;\n+    private final SerializedPrestoSparkTaskDescriptor serializedTaskDescriptor;\n+    private final List<String> fragmentIds;\n+    private final CollectionAccumulator<SerializedTaskStats> taskStatsCollector;\n+    // fragmentId -> Broadcast\n+    private final Map<String, Broadcast<List<PrestoSparkSerializedPage>>> broadcastInputs;\n+\n+    public PrestoSparkTaskProcessor(\n+            PrestoSparkTaskExecutorFactoryProvider taskExecutorFactoryProvider,\n+            SerializedPrestoSparkTaskDescriptor serializedTaskDescriptor,\n+            List<String> fragmentIds,\n+            CollectionAccumulator<SerializedTaskStats> taskStatsCollector,\n+            Map<String, Broadcast<List<PrestoSparkSerializedPage>>> broadcastInputs)\n+    {\n+        this.taskExecutorFactoryProvider = requireNonNull(taskExecutorFactoryProvider, \"taskExecutorFactoryProvider is null\");\n+        this.serializedTaskDescriptor = requireNonNull(serializedTaskDescriptor, \"serializedTaskDescriptor is null\");\n+        this.fragmentIds = unmodifiableList(new ArrayList<>(requireNonNull(fragmentIds, \"fragmentIds is null\")));\n+        this.taskStatsCollector = requireNonNull(taskStatsCollector, \"taskStatsCollector is null\");\n+        this.broadcastInputs = unmodifiableMap(new HashMap<>(requireNonNull(broadcastInputs, \"broadcastInputs is null\")));\n+    }\n+\n+    public Iterator<Tuple2<Integer, PrestoSparkRow>> apply(\n+            Iterator<SerializedTaskSource> serializedTaskSources,\n+            List<Iterator<Tuple2<Integer, PrestoSparkRow>>> inputs)\n+    {\n+        int partitionId = TaskContext.get().partitionId();\n+        int attemptNumber = TaskContext.get().attemptNumber();\n+        Map<String, Iterator<Tuple2<Integer, PrestoSparkRow>>> inputsMap = new HashMap<>();\n+        for (int i = 0; i < fragmentIds.size(); i++) {", "originalCommit": "0ae646de13bb51d9f29786b85fb589ddca30b1a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNTI1MQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r436335251", "bodyText": "For now Looks like it's a wrapper over ParallelCollectionPartition . I assume it will have non-trivial functionality when colocated join is supported :)", "author": "wenleix", "createdAt": "2020-06-07T07:39:27Z", "path": "presto-spark-classloader-interface/src/main/java/com/facebook/presto/spark/classloader_interface/PrestoSparkTaskSourceRdd.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spark.classloader_interface;\n+\n+import org.apache.spark.Dependency;\n+import org.apache.spark.InterruptibleIterator;\n+import org.apache.spark.Partition;\n+import org.apache.spark.SparkContext;\n+import org.apache.spark.TaskContext;\n+import org.apache.spark.rdd.ParallelCollectionPartition;\n+import org.apache.spark.rdd.RDD;\n+import scala.collection.Iterator;\n+import scala.reflect.ClassTag;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.toList;\n+import static scala.collection.JavaConversions.asScalaBuffer;\n+\n+public class PrestoSparkTaskSourceRdd", "originalCommit": "0ae646de13bb51d9f29786b85fb589ddca30b1a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNjQyOQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r436336429", "bodyText": "In fact I need to take a closer look into this. Looks like it's more than just a wrapper :) (especially this getInputIterators method)", "author": "wenleix", "createdAt": "2020-06-07T07:54:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNTI1MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA0NzA3Mg==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439047072", "bodyText": "For now Looks like it's a wrapper over ParallelCollectionPartition . I assume it will have non-trivial functionality when colocated join is supported :)\n\nYeah. It provides us with a flexibility to manually assign TaskSource to spark partitions.  ParallelRdd (the result of parallelize) just does round robin.", "author": "arhimondr", "createdAt": "2020-06-11T20:18:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMzNTI1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE0MTkxMw==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r437141913", "bodyText": "nit: what about rename rddInputs to shuffleInputs?", "author": "wenleix", "createdAt": "2020-06-09T05:14:42Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/planner/PrestoSparkRddFactory.java", "diffHunk": "@@ -230,90 +230,97 @@ private static Partitioner createPartitioner(PartitioningHandle partitioning, in\n     {\n         checkInputs(fragment.getRemoteSourceNodes(), rddInputs, broadcastInputs);", "originalCommit": "ecb7c56cc35eb5f2468c837483e8db92e0a19de2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA0NzgyOA==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439047828", "bodyText": "I don't feel particularly strong. I can do this rename in a separate PR if you wish, it's been like that before.", "author": "arhimondr", "createdAt": "2020-06-11T20:19:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE0MTkxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzMTEzMQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439231131", "bodyText": "@arhimondr : Previously there is only one type of input (shuffle input). Now with two types of inputs, just saying rddInputs can be confusing when reading the code.\nFeel free to to it in a separate PR.", "author": "wenleix", "createdAt": "2020-06-12T06:29:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE0MTkxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE0MzUxMQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r437143511", "bodyText": "My understanding is this is for special case that the fragment only has VALUES input? -- still we need a dumb PrestoSparkTaskSourceRdd with empty list (instead of making taskSourceRdd to be Optional.empty(). This can be a bit confusing to read.\nIdeally we want to eliminate this dumb PrestoSparkTaskSourceRdd . But if it's required, my suggestions are:\n\nAdd comment explain why we cannot make taskSourceRdd to be simply Optional.empty\nMaybe have a factory method such as PrestoSparkTaskSourceRdd.createEmptyTaskSourceRdd?", "author": "wenleix", "createdAt": "2020-06-09T05:20:36Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/planner/PrestoSparkRddFactory.java", "diffHunk": "@@ -230,90 +230,97 @@ private static Partitioner createPartitioner(PartitioningHandle partitioning, in\n     {\n         checkInputs(fragment.getRemoteSourceNodes(), rddInputs, broadcastInputs);\n \n-        List<TableScanNode> tableScans = findTableScanNodes(fragment.getRoot());\n-        verify(tableScans.isEmpty(), \"no table scans is expected\");\n-\n-        PrestoSparkTaskDescriptor taskDescriptor = createIntermediateTaskDescriptor(session, tableWriteInfo, fragment);\n-        SerializedPrestoSparkTaskDescriptor serializedTaskDescriptor = new SerializedPrestoSparkTaskDescriptor(taskDescriptorJsonCodec.toJsonBytes(taskDescriptor));\n-\n-        if (rddInputs.size() == 0) {\n-            checkArgument(fragment.getPartitioning().equals(SINGLE_DISTRIBUTION), \"SINGLE_DISTRIBUTION partitioning is expected: %s\", fragment.getPartitioning());\n-            return sparkContext.parallelize(ImmutableList.of(serializedTaskDescriptor), 1)\n-                    .mapPartitionsToPair(createTaskProcessor(\n-                            executorFactoryProvider,\n-                            taskStatsCollector,\n-                            toTaskProcessorBroadcastInputs(broadcastInputs)));\n-        }\n+        PrestoSparkTaskDescriptor taskDescriptor = new PrestoSparkTaskDescriptor(\n+                session.toSessionRepresentation(),\n+                session.getIdentity().getExtraCredentials(),\n+                fragment,\n+                tableWriteInfo);\n+        SerializedPrestoSparkTaskDescriptor serializedTaskDescriptor = new SerializedPrestoSparkTaskDescriptor(\n+                taskDescriptorJsonCodec.toJsonBytes(taskDescriptor));\n \n+        Optional<Integer> numberOfInputPartitions = Optional.empty();\n         ImmutableList.Builder<String> fragmentIds = ImmutableList.builder();\n-        ImmutableList.Builder<RDD<Tuple2<Integer, PrestoSparkRow>>> rdds = ImmutableList.builder();\n+        ImmutableList.Builder<RDD<Tuple2<Integer, PrestoSparkRow>>> inputRdds = ImmutableList.builder();\n         for (Map.Entry<PlanFragmentId, JavaPairRDD<Integer, PrestoSparkRow>> input : rddInputs.entrySet()) {\n             fragmentIds.add(input.getKey().toString());\n-            rdds.add(input.getValue().rdd());\n+            RDD<Tuple2<Integer, PrestoSparkRow>> rdd = input.getValue().rdd();\n+            inputRdds.add(rdd);\n+            if (!numberOfInputPartitions.isPresent()) {\n+                numberOfInputPartitions = Optional.of(rdd.getNumPartitions());\n+            }\n+            else {\n+                checkArgument(\n+                        numberOfInputPartitions.get() == rdd.getNumPartitions(),\n+                        \"Incompatible number of input partitions: %s != %s\",\n+                        numberOfInputPartitions.get(),\n+                        rdd.getNumPartitions());\n+            }\n         }\n \n-        Function<List<Iterator<Tuple2<Integer, PrestoSparkRow>>>, Iterator<Tuple2<Integer, PrestoSparkRow>>> taskProcessor = createTaskProcessor(\n+        PrestoSparkTaskProcessor taskProcessor = new PrestoSparkTaskProcessor(\n                 executorFactoryProvider,\n                 serializedTaskDescriptor,\n                 fragmentIds.build(),\n                 taskStatsCollector,\n                 toTaskProcessorBroadcastInputs(broadcastInputs));\n \n+        Optional<RDD<SerializedTaskSource>> taskSourceRdd;\n+        List<TableScanNode> tableScans = findTableScanNodes(fragment.getRoot());\n+        if (!tableScans.isEmpty()) {\n+            PartitioningHandle partitioning = fragment.getPartitioning();\n+            taskSourceRdd = Optional.of(createTaskSourcesRdd(sparkContext, session, partitioning, tableScans, numberOfInputPartitions).rdd());\n+        }\n+        else if (rddInputs.size() == 0) {\n+            checkArgument(fragment.getPartitioning().equals(SINGLE_DISTRIBUTION), \"SINGLE_DISTRIBUTION partitioning is expected: %s\", fragment.getPartitioning());\n+            taskSourceRdd = Optional.of(new PrestoSparkTaskSourceRdd(sparkContext.sc(), ImmutableList.of(ImmutableList.of())));", "originalCommit": "ecb7c56cc35eb5f2468c837483e8db92e0a19de2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA0OTc0NA==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439049744", "bodyText": "We need to somehow create exactly 1 partition, so exactly one task is scheduled. Thats why we need this single partition input RDD. I agree that this is a bit of a hack, and in theory it is possible to create a single \"dummy\" partition of the PrestoSparkTaskRdd itself. But that might be a little messy, so I'm kinda trying to chose a lesser evil.", "author": "arhimondr", "createdAt": "2020-06-11T20:21:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE0MzUxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNjM5OA==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439236398", "bodyText": "@arhimondr : If the RDD becomes special enough in the case of SINGLE_DISTRIBUTION , a dedicated RDD might not be a bad idea, but you might have different opinions :) .\nIn any case, for now just explain in comment when the list is empty, it means exactly 1 partition (this is not intuitive to me), and perhaps a TODO about figure out less hacky approach? (We have 20% time assigned to Better Engineering).\nStill , what about have a factory method such as PrestoSparkTaskSourceRdd.createRddWithSingleDistribution so you hide the detail that creating a PrestoSparkTaskSourceRdd with ImmutableList.of(ImmutableList.of()) as task source?", "author": "wenleix", "createdAt": "2020-06-12T06:43:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE0MzUxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM2ODI5MA==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439368290", "bodyText": "@arhimondr : If the RDD becomes special enough in the case of SINGLE_DISTRIBUTION , a dedicated RDD might not be a bad idea, but you might have different opinions :) .\n\nI would prefer to have a single way of creating a presto task. Otherwise we would have to maintain multiple ways. I think that's the main motivation to stick with  only PrestoSparkTaskSourceRdd , PrestoSparkTaskRdd.\n\nPrestoSparkTaskSourceRdd.createRddWithSingleDistribution\n\nThen maybe createRddWithSingleEmptyPartition. But that might also be quite confusing. Let me leave a comment instead.", "author": "arhimondr", "createdAt": "2020-06-12T11:39:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE0MzUxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE0NDg1OA==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r437144858", "bodyText": "nit : what about getShuffleInputIterators", "author": "wenleix", "createdAt": "2020-06-09T05:25:33Z", "path": "presto-spark-classloader-interface/src/main/java/com/facebook/presto/spark/classloader_interface/PrestoSparkTaskRdd.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spark.classloader_interface;\n+\n+import org.apache.spark.Partition;\n+import org.apache.spark.SparkContext;\n+import org.apache.spark.TaskContext;\n+import org.apache.spark.rdd.RDD;\n+import org.apache.spark.rdd.ZippedPartitionsBaseRDD;\n+import org.apache.spark.rdd.ZippedPartitionsPartition;\n+import scala.Tuple2;\n+import scala.collection.Seq;\n+import scala.reflect.ClassTag;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyIterator;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+import static scala.collection.JavaConversions.asJavaIterator;\n+import static scala.collection.JavaConversions.asScalaBuffer;\n+import static scala.collection.JavaConversions.asScalaIterator;\n+import static scala.collection.JavaConversions.seqAsJavaList;\n+\n+public class PrestoSparkTaskRdd\n+        extends ZippedPartitionsBaseRDD<Tuple2<Integer, PrestoSparkRow>>\n+{\n+    private RDD<SerializedTaskSource> taskSourceRdd;\n+    private List<RDD<Tuple2<Integer, PrestoSparkRow>>> inputRdds;\n+    private PrestoSparkTaskProcessor taskProcessor;\n+\n+    public PrestoSparkTaskRdd(\n+            SparkContext context,\n+            Optional<RDD<SerializedTaskSource>> taskSourceRdd,\n+            List<RDD<Tuple2<Integer, PrestoSparkRow>>> inputRdds,\n+            PrestoSparkTaskProcessor taskProcessor)\n+    {\n+        super(context, getRDDSequence(taskSourceRdd, inputRdds), false, fakeClassTag());\n+        // Optional is not Java Serializable\n+        this.taskSourceRdd = taskSourceRdd.orElse(null);\n+        this.inputRdds = unmodifiableList(new ArrayList<>(inputRdds));\n+        this.taskProcessor = context.clean(requireNonNull(taskProcessor, \"taskProcessor is null\"), true);\n+    }\n+\n+    private static Seq<RDD<?>> getRDDSequence(Optional<RDD<SerializedTaskSource>> taskSourceRdd, List<RDD<Tuple2<Integer, PrestoSparkRow>>> inputRdds)\n+    {\n+        requireNonNull(taskSourceRdd, \"taskSourceRdd is null\");\n+        requireNonNull(inputRdds, \"inputRdds is null\");\n+        List<RDD<?>> list = new ArrayList<>();\n+        taskSourceRdd.ifPresent(list::add);\n+        list.addAll(inputRdds);\n+        return asScalaBuffer(list).toSeq();\n+    }\n+\n+    private static <T> ClassTag<T> fakeClassTag()\n+    {\n+        return scala.reflect.ClassTag$.MODULE$.apply(Tuple2.class);\n+    }\n+\n+    @Override\n+    public scala.collection.Iterator<Tuple2<Integer, PrestoSparkRow>> compute(Partition split, TaskContext context)\n+    {\n+        List<Partition> partitions = seqAsJavaList(((ZippedPartitionsPartition) split).partitions());\n+        int expectedPartitionsSize = (taskSourceRdd != null ? 1 : 0) + inputRdds.size();\n+        checkArgument(\n+                partitions.size() == expectedPartitionsSize,\n+                \"Unexpected partitions size. Expected: %s. Actual: %s.\",\n+                expectedPartitionsSize, partitions.size());\n+        return asScalaIterator(taskProcessor.apply(\n+                getTaskSourceIterator(partitions, context),\n+                getInputIterators(partitions, context)));\n+    }\n+\n+    private Iterator<SerializedTaskSource> getTaskSourceIterator(List<Partition> partitions, TaskContext context)\n+    {\n+        if (taskSourceRdd != null) {\n+            return asJavaIterator(taskSourceRdd.iterator(partitions.get(0), context));\n+        }\n+        return emptyIterator();\n+    }\n+\n+    private List<Iterator<Tuple2<Integer, PrestoSparkRow>>> getInputIterators(List<Partition> partitions, TaskContext context)", "originalCommit": "ecb7c56cc35eb5f2468c837483e8db92e0a19de2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE0ODAxOA==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r437148018", "bodyText": "why not just using PrestoSparkTaskSourceRdd here?", "author": "wenleix", "createdAt": "2020-06-09T05:36:32Z", "path": "presto-spark-classloader-interface/src/main/java/com/facebook/presto/spark/classloader_interface/PrestoSparkTaskRdd.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spark.classloader_interface;\n+\n+import org.apache.spark.Partition;\n+import org.apache.spark.SparkContext;\n+import org.apache.spark.TaskContext;\n+import org.apache.spark.rdd.RDD;\n+import org.apache.spark.rdd.ZippedPartitionsBaseRDD;\n+import org.apache.spark.rdd.ZippedPartitionsPartition;\n+import scala.Tuple2;\n+import scala.collection.Seq;\n+import scala.reflect.ClassTag;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyIterator;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+import static scala.collection.JavaConversions.asJavaIterator;\n+import static scala.collection.JavaConversions.asScalaBuffer;\n+import static scala.collection.JavaConversions.asScalaIterator;\n+import static scala.collection.JavaConversions.seqAsJavaList;\n+\n+public class PrestoSparkTaskRdd\n+        extends ZippedPartitionsBaseRDD<Tuple2<Integer, PrestoSparkRow>>\n+{\n+    private RDD<SerializedTaskSource> taskSourceRdd;", "originalCommit": "ecb7c56cc35eb5f2468c837483e8db92e0a19de2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1Mjk1MQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439052951", "bodyText": "Good point", "author": "arhimondr", "createdAt": "2020-06-11T20:27:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE0ODAxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE0ODg0OA==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r437148848", "bodyText": "unpartitioned split / partitioned split is kind of overloaded in Presto. Since in the task execution context, it often means \"splits from table scan source\" vs. \"splits from exchange source\".\nWhat about saying \"splits from unbucketed table\" vs. \"splits from bucketed table\"", "author": "wenleix", "createdAt": "2020-06-09T05:39:11Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/planner/PrestoSparkRddFactory.java", "diffHunk": "@@ -330,49 +337,61 @@ private static Partitioner createPartitioner(PartitioningHandle partitioning, in\n         return splits;\n     }\n \n-    private static List<List<ScheduledSplit>> assignSplitsToTasks(List<ScheduledSplit> splits, int numTasks)\n+    private SetMultimap<Integer, ScheduledSplit> assignSplitsToTasks(Session session, PartitioningHandle partitioning, List<ScheduledSplit> splits)\n     {\n-        checkArgument(numTasks > 0, \"numTasks must be greater then zero\");\n-        List<List<ScheduledSplit>> assignedSplits = new ArrayList<>();\n-        for (int i = 0; i < numTasks; i++) {\n-            assignedSplits.add(new ArrayList<>());\n+        // unpartitioned splits", "originalCommit": "ecb7c56cc35eb5f2468c837483e8db92e0a19de2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1MTE1NQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r437151155", "bodyText": "Add a comment explain the structure of partitionedTaskSources, also may consider rename it to taskSourcesByTaskId:\n// each element in taskSourcesByTaskId is a list of task sources assigned to the same Spark task. \n// When input tables are unbucketed, task sources are distributed randomly across all tasks. \n// When input tables are bucketed, each bucket in task sources will be assigned to one Spark task, and the assignment is compatible to potential shuffle inputs.", "author": "wenleix", "createdAt": "2020-06-09T05:46:29Z", "path": "presto-spark-classloader-interface/src/main/java/com/facebook/presto/spark/classloader_interface/PrestoSparkTaskSourceRdd.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spark.classloader_interface;\n+\n+import org.apache.spark.Dependency;\n+import org.apache.spark.InterruptibleIterator;\n+import org.apache.spark.Partition;\n+import org.apache.spark.SparkContext;\n+import org.apache.spark.TaskContext;\n+import org.apache.spark.rdd.ParallelCollectionPartition;\n+import org.apache.spark.rdd.RDD;\n+import scala.collection.Iterator;\n+import scala.reflect.ClassTag;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.toList;\n+import static scala.collection.JavaConversions.asScalaBuffer;\n+\n+public class PrestoSparkTaskSourceRdd\n+        extends RDD<SerializedTaskSource>\n+{\n+    private List<List<SerializedTaskSource>> partitionedTaskSources;", "originalCommit": "ecb7c56cc35eb5f2468c837483e8db92e0a19de2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1NDM4Ng==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439054386", "bodyText": "Renames to taskSourcesByPartitionId, it feels like it fits better, as then in the PrestoSparkTaskSourceRdd we are creating partitions and iterating over partitions.\nAdded a comment as well.", "author": "arhimondr", "createdAt": "2020-06-11T20:30:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1MTE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1MzMxMQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r437153311", "bodyText": "This partitions.get(0) is not easy to understand :).\nI have two thoughts:\n\nJust inline this getTaskSourceIterator method.\nAnother possibility is to consider change the signature of this method to be getTaskSourceIterator(Optional<Partition> partitions, TaskContext context). And let compute to decide whether to pass in Optional.empty() or partitions.get(0).", "author": "wenleix", "createdAt": "2020-06-09T05:53:14Z", "path": "presto-spark-classloader-interface/src/main/java/com/facebook/presto/spark/classloader_interface/PrestoSparkTaskRdd.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spark.classloader_interface;\n+\n+import org.apache.spark.Partition;\n+import org.apache.spark.SparkContext;\n+import org.apache.spark.TaskContext;\n+import org.apache.spark.rdd.RDD;\n+import org.apache.spark.rdd.ZippedPartitionsBaseRDD;\n+import org.apache.spark.rdd.ZippedPartitionsPartition;\n+import scala.Tuple2;\n+import scala.collection.Seq;\n+import scala.reflect.ClassTag;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyIterator;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+import static scala.collection.JavaConversions.asJavaIterator;\n+import static scala.collection.JavaConversions.asScalaBuffer;\n+import static scala.collection.JavaConversions.asScalaIterator;\n+import static scala.collection.JavaConversions.seqAsJavaList;\n+\n+public class PrestoSparkTaskRdd\n+        extends ZippedPartitionsBaseRDD<Tuple2<Integer, PrestoSparkRow>>\n+{\n+    private RDD<SerializedTaskSource> taskSourceRdd;\n+    private List<RDD<Tuple2<Integer, PrestoSparkRow>>> inputRdds;\n+    private PrestoSparkTaskProcessor taskProcessor;\n+\n+    public PrestoSparkTaskRdd(\n+            SparkContext context,\n+            Optional<RDD<SerializedTaskSource>> taskSourceRdd,\n+            List<RDD<Tuple2<Integer, PrestoSparkRow>>> inputRdds,\n+            PrestoSparkTaskProcessor taskProcessor)\n+    {\n+        super(context, getRDDSequence(taskSourceRdd, inputRdds), false, fakeClassTag());\n+        // Optional is not Java Serializable\n+        this.taskSourceRdd = taskSourceRdd.orElse(null);\n+        this.inputRdds = unmodifiableList(new ArrayList<>(inputRdds));\n+        this.taskProcessor = context.clean(requireNonNull(taskProcessor, \"taskProcessor is null\"), true);\n+    }\n+\n+    private static Seq<RDD<?>> getRDDSequence(Optional<RDD<SerializedTaskSource>> taskSourceRdd, List<RDD<Tuple2<Integer, PrestoSparkRow>>> inputRdds)\n+    {\n+        requireNonNull(taskSourceRdd, \"taskSourceRdd is null\");\n+        requireNonNull(inputRdds, \"inputRdds is null\");\n+        List<RDD<?>> list = new ArrayList<>();\n+        taskSourceRdd.ifPresent(list::add);\n+        list.addAll(inputRdds);\n+        return asScalaBuffer(list).toSeq();\n+    }\n+\n+    private static <T> ClassTag<T> fakeClassTag()\n+    {\n+        return scala.reflect.ClassTag$.MODULE$.apply(Tuple2.class);\n+    }\n+\n+    @Override\n+    public scala.collection.Iterator<Tuple2<Integer, PrestoSparkRow>> compute(Partition split, TaskContext context)\n+    {\n+        List<Partition> partitions = seqAsJavaList(((ZippedPartitionsPartition) split).partitions());\n+        int expectedPartitionsSize = (taskSourceRdd != null ? 1 : 0) + inputRdds.size();\n+        checkArgument(\n+                partitions.size() == expectedPartitionsSize,\n+                \"Unexpected partitions size. Expected: %s. Actual: %s.\",\n+                expectedPartitionsSize, partitions.size());\n+        return asScalaIterator(taskProcessor.apply(\n+                getTaskSourceIterator(partitions, context),\n+                getInputIterators(partitions, context)));\n+    }\n+\n+    private Iterator<SerializedTaskSource> getTaskSourceIterator(List<Partition> partitions, TaskContext context)\n+    {\n+        if (taskSourceRdd != null) {\n+            return asJavaIterator(taskSourceRdd.iterator(partitions.get(0), context));", "originalCommit": "ecb7c56cc35eb5f2468c837483e8db92e0a19de2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA1NjMxMA==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439056310", "bodyText": "Yeah, generally this class is a little messy, as it has to multiplex both, inputs with splits with inputs with rows. I was trying to meddle it around, but it seems that it is getting even worse.", "author": "arhimondr", "createdAt": "2020-06-11T20:34:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1MzMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzMjY5MQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439232691", "bodyText": "@arhimondr : What about the second option (let compute to decide whether to pass in Optional.empty() or partitions.get(0)\nIf it doesn't work (similar to #14559 (comment)), maybe add a comment about refactor and I can see if there is anything I can help later?", "author": "wenleix", "createdAt": "2020-06-12T06:33:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1MzMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM2NDkwOQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439364909", "bodyText": "Actually let me change this code to store source partitions as a last element. It might be easier to read it then.", "author": "arhimondr", "createdAt": "2020-06-12T11:30:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1MzMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1Njg3Ng==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r437156876", "bodyText": "Let's add some comment for this class. Feel free to adapt/modify the following:\n/**\n * PrestoSparkTaskRdd represents execution of Presto stage, it contains:\n *  - a list of shuffleInputRdds, each of the corresponding to a child stage.\n *  - an optional taskSourceRdd, which represents *ALL* the table scan inputs in this stage.\n *\n *  Table scan presents when join bucketed table with unbucketed table, for example:\n *        Join\n *        /  \\\n *    Scan  Remote\n *  In this case, bucket to Spark partition mapping has to be consistent with the Spark shuffle partition.\n *\n *  shuffleInputRdds can also be empty when the stage partitioning is SINGLE_DISTRIBUTION.\n *  TODO: Consider have dedicated RDD implementation for SINGLE_DISTRIBUTION.\n *\n *  The broadcast input is encapsulated in taskProcessor.\n */\n\nLet me know if the TODO suggestion (TODO: Consider have dedicated RDD implementation for SINGLE_DISTRIBUTION) makes sense. Since I personally found it difficult to reason when both shuffleInputRdds and taskSourceRdd can be empty.", "author": "wenleix", "createdAt": "2020-06-09T06:04:12Z", "path": "presto-spark-classloader-interface/src/main/java/com/facebook/presto/spark/classloader_interface/PrestoSparkTaskRdd.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spark.classloader_interface;\n+\n+import org.apache.spark.Partition;\n+import org.apache.spark.SparkContext;\n+import org.apache.spark.TaskContext;\n+import org.apache.spark.rdd.RDD;\n+import org.apache.spark.rdd.ZippedPartitionsBaseRDD;\n+import org.apache.spark.rdd.ZippedPartitionsPartition;\n+import scala.Tuple2;\n+import scala.collection.Seq;\n+import scala.reflect.ClassTag;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyIterator;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+import static scala.collection.JavaConversions.asJavaIterator;\n+import static scala.collection.JavaConversions.asScalaBuffer;\n+import static scala.collection.JavaConversions.asScalaIterator;\n+import static scala.collection.JavaConversions.seqAsJavaList;\n+\n+public class PrestoSparkTaskRdd", "originalCommit": "ecb7c56cc35eb5f2468c837483e8db92e0a19de2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA5NTIxNw==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439095217", "bodyText": "(TODO: Consider have dedicated RDD implementation for SINGLE_DISTRIBUTION)\n\nI'm not particularly convinced that a separate RDD specifically for single distribution makes a lot of sense, especially if sometimes single distributed fragment may still have inputs. It might make things even more confusing.", "author": "arhimondr", "createdAt": "2020-06-11T21:59:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1Njg3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MTIyNQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439791225", "bodyText": "@arhimondr : Yeah, let's make how to handle SINGLE_DISTRIBUTION as a future work :)", "author": "wenleix", "createdAt": "2020-06-14T04:43:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1Njg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1NzQ3OQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r437157479", "bodyText": "Here a implicit \"sublist\" is done and makes the code a bit difficult to follow (similar argument to getTaskSourceIterator). Would it make sense to do the partitions.subList(1, ...) in compute?", "author": "wenleix", "createdAt": "2020-06-09T06:05:50Z", "path": "presto-spark-classloader-interface/src/main/java/com/facebook/presto/spark/classloader_interface/PrestoSparkTaskRdd.java", "diffHunk": "@@ -0,0 +1,126 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spark.classloader_interface;\n+\n+import org.apache.spark.Partition;\n+import org.apache.spark.SparkContext;\n+import org.apache.spark.TaskContext;\n+import org.apache.spark.rdd.RDD;\n+import org.apache.spark.rdd.ZippedPartitionsBaseRDD;\n+import org.apache.spark.rdd.ZippedPartitionsPartition;\n+import scala.Tuple2;\n+import scala.collection.Seq;\n+import scala.reflect.ClassTag;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyIterator;\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+import static scala.collection.JavaConversions.asJavaIterator;\n+import static scala.collection.JavaConversions.asScalaBuffer;\n+import static scala.collection.JavaConversions.asScalaIterator;\n+import static scala.collection.JavaConversions.seqAsJavaList;\n+\n+public class PrestoSparkTaskRdd\n+        extends ZippedPartitionsBaseRDD<Tuple2<Integer, PrestoSparkRow>>\n+{\n+    private RDD<SerializedTaskSource> taskSourceRdd;\n+    private List<RDD<Tuple2<Integer, PrestoSparkRow>>> inputRdds;\n+    private PrestoSparkTaskProcessor taskProcessor;\n+\n+    public PrestoSparkTaskRdd(\n+            SparkContext context,\n+            Optional<RDD<SerializedTaskSource>> taskSourceRdd,\n+            List<RDD<Tuple2<Integer, PrestoSparkRow>>> inputRdds,\n+            PrestoSparkTaskProcessor taskProcessor)\n+    {\n+        super(context, getRDDSequence(taskSourceRdd, inputRdds), false, fakeClassTag());\n+        // Optional is not Java Serializable\n+        this.taskSourceRdd = taskSourceRdd.orElse(null);\n+        this.inputRdds = unmodifiableList(new ArrayList<>(inputRdds));\n+        this.taskProcessor = context.clean(requireNonNull(taskProcessor, \"taskProcessor is null\"), true);\n+    }\n+\n+    private static Seq<RDD<?>> getRDDSequence(Optional<RDD<SerializedTaskSource>> taskSourceRdd, List<RDD<Tuple2<Integer, PrestoSparkRow>>> inputRdds)\n+    {\n+        requireNonNull(taskSourceRdd, \"taskSourceRdd is null\");\n+        requireNonNull(inputRdds, \"inputRdds is null\");\n+        List<RDD<?>> list = new ArrayList<>();\n+        taskSourceRdd.ifPresent(list::add);\n+        list.addAll(inputRdds);\n+        return asScalaBuffer(list).toSeq();\n+    }\n+\n+    private static <T> ClassTag<T> fakeClassTag()\n+    {\n+        return scala.reflect.ClassTag$.MODULE$.apply(Tuple2.class);\n+    }\n+\n+    @Override\n+    public scala.collection.Iterator<Tuple2<Integer, PrestoSparkRow>> compute(Partition split, TaskContext context)\n+    {\n+        List<Partition> partitions = seqAsJavaList(((ZippedPartitionsPartition) split).partitions());\n+        int expectedPartitionsSize = (taskSourceRdd != null ? 1 : 0) + inputRdds.size();\n+        checkArgument(\n+                partitions.size() == expectedPartitionsSize,\n+                \"Unexpected partitions size. Expected: %s. Actual: %s.\",\n+                expectedPartitionsSize, partitions.size());\n+        return asScalaIterator(taskProcessor.apply(\n+                getTaskSourceIterator(partitions, context),\n+                getInputIterators(partitions, context)));\n+    }\n+\n+    private Iterator<SerializedTaskSource> getTaskSourceIterator(List<Partition> partitions, TaskContext context)\n+    {\n+        if (taskSourceRdd != null) {\n+            return asJavaIterator(taskSourceRdd.iterator(partitions.get(0), context));\n+        }\n+        return emptyIterator();\n+    }\n+\n+    private List<Iterator<Tuple2<Integer, PrestoSparkRow>>> getInputIterators(List<Partition> partitions, TaskContext context)\n+    {\n+        if (inputRdds.isEmpty()) {\n+            return emptyList();\n+        }\n+        int startIndex = taskSourceRdd != null ? 1 : 0;", "originalCommit": "ecb7c56cc35eb5f2468c837483e8db92e0a19de2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA5NTY3Mw==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439095673", "bodyText": "I remember I was trying to do something like that at the beginning, but it was still messy + it was more code. I would prefer to keep it as is for now. Let me know what you think?", "author": "arhimondr", "createdAt": "2020-06-11T22:00:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1NzQ3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNjgyNA==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439236824", "bodyText": "@arhimondr : I see. Maybe add a TODO about refactor and maybe I can look into that later? :)", "author": "wenleix", "createdAt": "2020-06-12T06:45:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1NzQ3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM2NTE0OA==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439365148", "bodyText": "Let me try to store taskSourceRdd  as a last element. It might make things a little bit less confusing.", "author": "arhimondr", "createdAt": "2020-06-12T11:31:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1NzQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1Nzc1OQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r437157759", "bodyText": "nit: shuffleInputs?", "author": "wenleix", "createdAt": "2020-06-09T06:06:35Z", "path": "presto-spark-classloader-interface/src/main/java/com/facebook/presto/spark/classloader_interface/PrestoSparkTaskProcessor.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spark.classloader_interface;\n+\n+import org.apache.spark.TaskContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.util.CollectionAccumulator;\n+import scala.Tuple2;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Collections.unmodifiableMap;\n+import static java.util.Objects.requireNonNull;\n+\n+public class PrestoSparkTaskProcessor\n+        implements Serializable\n+{\n+    private final PrestoSparkTaskExecutorFactoryProvider taskExecutorFactoryProvider;\n+    private final SerializedPrestoSparkTaskDescriptor serializedTaskDescriptor;\n+    private final List<String> fragmentIds;\n+    private final CollectionAccumulator<SerializedTaskStats> taskStatsCollector;\n+    // fragmentId -> Broadcast\n+    private final Map<String, Broadcast<List<PrestoSparkSerializedPage>>> broadcastInputs;\n+\n+    public PrestoSparkTaskProcessor(\n+            PrestoSparkTaskExecutorFactoryProvider taskExecutorFactoryProvider,\n+            SerializedPrestoSparkTaskDescriptor serializedTaskDescriptor,\n+            List<String> fragmentIds,\n+            CollectionAccumulator<SerializedTaskStats> taskStatsCollector,\n+            Map<String, Broadcast<List<PrestoSparkSerializedPage>>> broadcastInputs)\n+    {\n+        this.taskExecutorFactoryProvider = requireNonNull(taskExecutorFactoryProvider, \"taskExecutorFactoryProvider is null\");\n+        this.serializedTaskDescriptor = requireNonNull(serializedTaskDescriptor, \"serializedTaskDescriptor is null\");\n+        this.fragmentIds = unmodifiableList(new ArrayList<>(requireNonNull(fragmentIds, \"fragmentIds is null\")));\n+        this.taskStatsCollector = requireNonNull(taskStatsCollector, \"taskStatsCollector is null\");\n+        this.broadcastInputs = unmodifiableMap(new HashMap<>(requireNonNull(broadcastInputs, \"broadcastInputs is null\")));\n+    }\n+\n+    public Iterator<Tuple2<Integer, PrestoSparkRow>> apply(\n+            Iterator<SerializedTaskSource> serializedTaskSources,\n+            List<Iterator<Tuple2<Integer, PrestoSparkRow>>> inputs)", "originalCommit": "ecb7c56cc35eb5f2468c837483e8db92e0a19de2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1OTM1OQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r437159359", "bodyText": "nit: shuffleInputsMap or fragmentIdToShuffleInput?", "author": "wenleix", "createdAt": "2020-06-09T06:11:08Z", "path": "presto-spark-classloader-interface/src/main/java/com/facebook/presto/spark/classloader_interface/PrestoSparkTaskProcessor.java", "diffHunk": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spark.classloader_interface;\n+\n+import org.apache.spark.TaskContext;\n+import org.apache.spark.broadcast.Broadcast;\n+import org.apache.spark.util.CollectionAccumulator;\n+import scala.Tuple2;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Collections.unmodifiableMap;\n+import static java.util.Objects.requireNonNull;\n+\n+public class PrestoSparkTaskProcessor\n+        implements Serializable\n+{\n+    private final PrestoSparkTaskExecutorFactoryProvider taskExecutorFactoryProvider;\n+    private final SerializedPrestoSparkTaskDescriptor serializedTaskDescriptor;\n+    private final List<String> fragmentIds;\n+    private final CollectionAccumulator<SerializedTaskStats> taskStatsCollector;\n+    // fragmentId -> Broadcast\n+    private final Map<String, Broadcast<List<PrestoSparkSerializedPage>>> broadcastInputs;\n+\n+    public PrestoSparkTaskProcessor(\n+            PrestoSparkTaskExecutorFactoryProvider taskExecutorFactoryProvider,\n+            SerializedPrestoSparkTaskDescriptor serializedTaskDescriptor,\n+            List<String> fragmentIds,\n+            CollectionAccumulator<SerializedTaskStats> taskStatsCollector,\n+            Map<String, Broadcast<List<PrestoSparkSerializedPage>>> broadcastInputs)\n+    {\n+        this.taskExecutorFactoryProvider = requireNonNull(taskExecutorFactoryProvider, \"taskExecutorFactoryProvider is null\");\n+        this.serializedTaskDescriptor = requireNonNull(serializedTaskDescriptor, \"serializedTaskDescriptor is null\");\n+        this.fragmentIds = unmodifiableList(new ArrayList<>(requireNonNull(fragmentIds, \"fragmentIds is null\")));\n+        this.taskStatsCollector = requireNonNull(taskStatsCollector, \"taskStatsCollector is null\");\n+        this.broadcastInputs = unmodifiableMap(new HashMap<>(requireNonNull(broadcastInputs, \"broadcastInputs is null\")));\n+    }\n+\n+    public Iterator<Tuple2<Integer, PrestoSparkRow>> apply(\n+            Iterator<SerializedTaskSource> serializedTaskSources,\n+            List<Iterator<Tuple2<Integer, PrestoSparkRow>>> inputs)\n+    {\n+        int partitionId = TaskContext.get().partitionId();\n+        int attemptNumber = TaskContext.get().attemptNumber();\n+        Map<String, Iterator<Tuple2<Integer, PrestoSparkRow>>> inputsMap = new HashMap<>();", "originalCommit": "ecb7c56cc35eb5f2468c837483e8db92e0a19de2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1OTM5OQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r437159399", "bodyText": "So essentially, these two information are maintained in different classes:\n\nfragmentIds list is maintained in PrestoSparkTaskProcessor\nshuffleInput list is maintained in PrestoSparkTaskRdd.\n\nAnd these two lists are \"zipped\" when PrestoSparkTaskRdd#compute calls PrestoSparkTaskProcessor#apply.\nI am wondering if this \"zipping\" operation can be done in PrestoSparkTaskRdd#compute? -- Otherwise, it's a bit uneasy to reason the ordering of shuffleInput in PrestoSparkTaskRdd has to be consistent with the ordering of fragmentIds in PrestoSparkTaskProcessor...\nWhen I am reading the code, I have to traverse the code in the following way:\n\nOh, how to guarantee the ordering in this two list are consistent?\nok , shuffleInput is from PrestoSparkTaskRdd, and it's from PrestoSparkRddFactory\nAnd  the same PrestoSparkRddFactory provides the fragment id list when construct PrestoSparkTaskProcessor\nOK so these two lists are consistent...", "author": "wenleix", "createdAt": "2020-06-09T06:11:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1OTM1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA5NzM1NQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439097355", "bodyText": "I am wondering if this \"zipping\" operation can be done in PrestoSparkTaskRdd#compute?\n\nCould you please elaborate a little bit more. I believe I'm missing something. The list of shuffleInput  is only available as a parameter of process in PrestoSparkTaskProcessor. What zipping you think can be done in PrestoSparkTaskRdd?", "author": "arhimondr", "createdAt": "2020-06-11T22:04:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1OTM1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTIzNzQxMA==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439237410", "bodyText": "@arhimondr :\n\nCould you please elaborate a little bit more. I believe I'm missing something. The list of shuffleInput is only available as a parameter of process in PrestoSparkTaskProcessor.\n\nSo essentially, you are zipping fragmentIds and inputs into inputsMap. And fragmentIds is a field in PrestoSparkTaskProcessor, while inputs is passed as a parameter into PrestoSparkTaskProcessor#process", "author": "wenleix", "createdAt": "2020-06-12T06:46:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1OTM1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM2NTU2Ng==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439365566", "bodyText": "Yup", "author": "arhimondr", "createdAt": "2020-06-12T11:32:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1OTM1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MTUyOA==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439791528", "bodyText": "@arhimondr :\n\nYup\n\nBut it's not fixed. I mean, the \"zipped inputs\" are from two different source (one stay in PrestoSparkTaskProcessor as a field member, one provided through PrestoSparkTaskProcessor#process). And it's quite confusing. For example, can they both be provided from PrestoSparkTaskProcessor#process?\nI would leave this as a future discussion for now.", "author": "wenleix", "createdAt": "2020-06-14T04:50:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1OTM1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMxNTU0MA==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r440315540", "bodyText": "Nevermind, I'm being slow. I think I got your point now. Refactored. Good catch.", "author": "arhimondr", "createdAt": "2020-06-15T16:56:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE1OTM1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2ODA3Ng==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r437868076", "bodyText": "Two questions:\n\nIs it possible some partition is missing from the taskSourcesMap? (e.g. table contains empty bucket)\nWill it happen that expectedNumberOfPartitions is present but different from the number of partitions in taskSourcesMap?", "author": "wenleix", "createdAt": "2020-06-10T05:27:10Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/planner/PrestoSparkRddFactory.java", "diffHunk": "@@ -230,90 +217,97 @@ private static Partitioner createPartitioner(PartitioningHandle partitioning, in\n     {\n         checkInputs(fragment.getRemoteSourceNodes(), rddInputs, broadcastInputs);\n \n-        List<TableScanNode> tableScans = findTableScanNodes(fragment.getRoot());\n-        verify(tableScans.isEmpty(), \"no table scans is expected\");\n-\n-        PrestoSparkTaskDescriptor taskDescriptor = createIntermediateTaskDescriptor(session, tableWriteInfo, fragment);\n-        SerializedPrestoSparkTaskDescriptor serializedTaskDescriptor = new SerializedPrestoSparkTaskDescriptor(taskDescriptorJsonCodec.toJsonBytes(taskDescriptor));\n-\n-        if (rddInputs.size() == 0) {\n-            checkArgument(fragment.getPartitioning().equals(SINGLE_DISTRIBUTION), \"SINGLE_DISTRIBUTION partitioning is expected: %s\", fragment.getPartitioning());\n-            return sparkContext.parallelize(ImmutableList.of(serializedTaskDescriptor), 1)\n-                    .mapPartitionsToPair(createTaskProcessor(\n-                            executorFactoryProvider,\n-                            taskStatsCollector,\n-                            toTaskProcessorBroadcastInputs(broadcastInputs)));\n-        }\n+        PrestoSparkTaskDescriptor taskDescriptor = new PrestoSparkTaskDescriptor(\n+                session.toSessionRepresentation(),\n+                session.getIdentity().getExtraCredentials(),\n+                fragment,\n+                tableWriteInfo);\n+        SerializedPrestoSparkTaskDescriptor serializedTaskDescriptor = new SerializedPrestoSparkTaskDescriptor(\n+                taskDescriptorJsonCodec.toJsonBytes(taskDescriptor));\n \n+        Optional<Integer> numberOfInputPartitions = Optional.empty();\n         ImmutableList.Builder<String> fragmentIds = ImmutableList.builder();\n-        ImmutableList.Builder<RDD<Tuple2<Integer, PrestoSparkRow>>> rdds = ImmutableList.builder();\n+        ImmutableList.Builder<RDD<Tuple2<Integer, PrestoSparkRow>>> inputRdds = ImmutableList.builder();\n         for (Map.Entry<PlanFragmentId, JavaPairRDD<Integer, PrestoSparkRow>> input : rddInputs.entrySet()) {\n             fragmentIds.add(input.getKey().toString());\n-            rdds.add(input.getValue().rdd());\n+            RDD<Tuple2<Integer, PrestoSparkRow>> rdd = input.getValue().rdd();\n+            inputRdds.add(rdd);\n+            if (!numberOfInputPartitions.isPresent()) {\n+                numberOfInputPartitions = Optional.of(rdd.getNumPartitions());\n+            }\n+            else {\n+                checkArgument(\n+                        numberOfInputPartitions.get() == rdd.getNumPartitions(),\n+                        \"Incompatible number of input partitions: %s != %s\",\n+                        numberOfInputPartitions.get(),\n+                        rdd.getNumPartitions());\n+            }\n         }\n \n-        Function<List<Iterator<Tuple2<Integer, PrestoSparkRow>>>, Iterator<Tuple2<Integer, PrestoSparkRow>>> taskProcessor = createTaskProcessor(\n+        PrestoSparkTaskProcessor taskProcessor = new PrestoSparkTaskProcessor(\n                 executorFactoryProvider,\n                 serializedTaskDescriptor,\n                 fragmentIds.build(),\n                 taskStatsCollector,\n                 toTaskProcessorBroadcastInputs(broadcastInputs));\n \n+        Optional<RDD<SerializedTaskSource>> taskSourceRdd;\n+        List<TableScanNode> tableScans = findTableScanNodes(fragment.getRoot());\n+        if (!tableScans.isEmpty()) {\n+            PartitioningHandle partitioning = fragment.getPartitioning();\n+            taskSourceRdd = Optional.of(createTaskSourcesRdd(sparkContext, session, partitioning, tableScans, numberOfInputPartitions).rdd());\n+        }\n+        else if (rddInputs.size() == 0) {\n+            checkArgument(fragment.getPartitioning().equals(SINGLE_DISTRIBUTION), \"SINGLE_DISTRIBUTION partitioning is expected: %s\", fragment.getPartitioning());\n+            taskSourceRdd = Optional.of(new PrestoSparkTaskSourceRdd(sparkContext.sc(), ImmutableList.of(ImmutableList.of())));\n+        }\n+        else {\n+            taskSourceRdd = Optional.empty();\n+        }\n+\n         return JavaPairRDD.fromRDD(\n-                new PrestoSparkZipRdd(sparkContext.sc(), rdds.build(), taskProcessor),\n+                new PrestoSparkTaskRdd(sparkContext.sc(), taskSourceRdd, inputRdds.build(), taskProcessor),\n                 classTag(Integer.class),\n                 classTag(PrestoSparkRow.class));\n     }\n \n-    private JavaPairRDD<Integer, PrestoSparkRow> createSourceRdd(\n+    private JavaRDD<SerializedTaskSource> createTaskSourcesRdd(\n             JavaSparkContext sparkContext,\n             Session session,\n-            PlanFragment fragment,\n-            PrestoSparkTaskExecutorFactoryProvider executorFactoryProvider,\n-            CollectionAccumulator<SerializedTaskStats> taskStatsCollector,\n-            TableWriteInfo tableWriteInfo,\n-            Map<PlanFragmentId, Broadcast<List<PrestoSparkSerializedPage>>> broadcastInputs)\n+            PartitioningHandle partitioning,\n+            List<TableScanNode> tableScans,\n+            Optional<Integer> expectedNumberOfPartitions)\n     {\n-        checkInputs(fragment.getRemoteSourceNodes(), ImmutableMap.of(), broadcastInputs);\n-\n-        List<TableScanNode> tableScans = findTableScanNodes(fragment.getRoot());\n-        checkArgument(\n-                tableScans.size() == 1,\n-                \"exactly one table scan is expected in SOURCE_DISTRIBUTION fragment. fragmentId: %s, actual number of table scans: %s\",\n-                fragment.getId(),\n-                tableScans.size());\n-\n-        TableScanNode tableScan = getOnlyElement(tableScans);\n-\n-        List<ScheduledSplit> splits = getSplits(session, tableScan);\n-        shuffle(splits);\n-        int initialPartitionCount = getSparkInitialPartitionCount(session);\n-        int numTasks = Math.min(splits.size(), initialPartitionCount);\n-        if (numTasks == 0) {\n-            return JavaPairRDD.fromJavaRDD(sparkContext.emptyRDD());\n+        ListMultimap<Integer, TaskSource> taskSourcesMap = ArrayListMultimap.create();\n+        for (TableScanNode tableScan : tableScans) {\n+            List<ScheduledSplit> scheduledSplits = getSplits(session, tableScan);\n+            shuffle(scheduledSplits);\n+            SetMultimap<Integer, ScheduledSplit> assignedSplits = assignSplitsToTasks(session, partitioning, scheduledSplits);\n+            asMap(assignedSplits).forEach((partitionId, splits) ->\n+                    taskSourcesMap.put(partitionId, new TaskSource(tableScan.getId(), splits, true)));\n         }\n \n-        List<List<ScheduledSplit>> assignedSplits = assignSplitsToTasks(splits, numTasks);\n-\n-        // let the garbage collector reclaim the memory used by the decoded splits as soon as the task descriptor is encoded\n-        splits = null;\n-\n-        ImmutableList.Builder<SerializedPrestoSparkTaskDescriptor> serializedTaskDescriptors = ImmutableList.builder();\n-        for (int i = 0; i < assignedSplits.size(); i++) {\n-            List<ScheduledSplit> splitBatch = assignedSplits.get(i);\n-            PrestoSparkTaskDescriptor taskDescriptor = createSourceTaskDescriptor(session, tableWriteInfo, fragment, splitBatch);\n-            // TODO: consider more efficient serialization or apply compression to save precious memory on the Driver\n-            byte[] jsonSerializedTaskDescriptor = taskDescriptorJsonCodec.toJsonBytes(taskDescriptor);\n-            serializedTaskDescriptors.add(new SerializedPrestoSparkTaskDescriptor(jsonSerializedTaskDescriptor));\n-            // let the garbage collector reclaim the memory used by the decoded splits as soon as the task descriptor is encoded\n-            assignedSplits.set(i, null);\n+        IntStream partitions = expectedNumberOfPartitions\n+                .map(integer -> IntStream.range(0, integer))\n+                .orElseGet(() -> new ArrayList<>(taskSourcesMap.keySet()).stream().mapToInt(Integer::intValue));", "originalCommit": "0ae646de13bb51d9f29786b85fb589ddca30b1a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA5ODI5NQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439098295", "bodyText": "Is it possible some partition is missing from the taskSourcesMap? (e.g. table contains empty bucket)\n\nYes, it is possible. taskSourcesMap.removeAll(partition) would return an empty list then. Even if the splits are empty, we still need to provide a partition, as the number of partitions should be the same for all the inputs that are zipped for consistency.\n\nWill it happen that expectedNumberOfPartitions is present but different from the number of partitions in taskSourcesMap?\n\nIf it happens it means that the fragmented plan is wrong. The partitioning of the fragment should be consistent with partitioning of the TableScan.", "author": "arhimondr", "createdAt": "2020-06-11T22:07:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2ODA3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2ODQ0MA==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r437868440", "bodyText": "Curious what does this numberOfInputPartitions mean? -- Looks like it's decided by the partition number of other RDDs?", "author": "wenleix", "createdAt": "2020-06-10T05:28:35Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/planner/PrestoSparkRddFactory.java", "diffHunk": "@@ -230,90 +217,97 @@ private static Partitioner createPartitioner(PartitioningHandle partitioning, in\n     {\n         checkInputs(fragment.getRemoteSourceNodes(), rddInputs, broadcastInputs);\n \n-        List<TableScanNode> tableScans = findTableScanNodes(fragment.getRoot());\n-        verify(tableScans.isEmpty(), \"no table scans is expected\");\n-\n-        PrestoSparkTaskDescriptor taskDescriptor = createIntermediateTaskDescriptor(session, tableWriteInfo, fragment);\n-        SerializedPrestoSparkTaskDescriptor serializedTaskDescriptor = new SerializedPrestoSparkTaskDescriptor(taskDescriptorJsonCodec.toJsonBytes(taskDescriptor));\n-\n-        if (rddInputs.size() == 0) {\n-            checkArgument(fragment.getPartitioning().equals(SINGLE_DISTRIBUTION), \"SINGLE_DISTRIBUTION partitioning is expected: %s\", fragment.getPartitioning());\n-            return sparkContext.parallelize(ImmutableList.of(serializedTaskDescriptor), 1)\n-                    .mapPartitionsToPair(createTaskProcessor(\n-                            executorFactoryProvider,\n-                            taskStatsCollector,\n-                            toTaskProcessorBroadcastInputs(broadcastInputs)));\n-        }\n+        PrestoSparkTaskDescriptor taskDescriptor = new PrestoSparkTaskDescriptor(\n+                session.toSessionRepresentation(),\n+                session.getIdentity().getExtraCredentials(),\n+                fragment,\n+                tableWriteInfo);\n+        SerializedPrestoSparkTaskDescriptor serializedTaskDescriptor = new SerializedPrestoSparkTaskDescriptor(\n+                taskDescriptorJsonCodec.toJsonBytes(taskDescriptor));\n \n+        Optional<Integer> numberOfInputPartitions = Optional.empty();", "originalCommit": "0ae646de13bb51d9f29786b85fb589ddca30b1a2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTA5OTQyMg==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439099422", "bodyText": "It represents number of partitions that are expected by the rdd based on it's inputs. The number of partitions should be equal for all input rdds. If there's no shuffle inputs we don't have to create empty partitions if the splits are missing for some buckets. Think of it as of an optimization for a query like\nselect col, count(*)\nfrom table_bucketed_by_col\ngroup by col\n\nIf some buckets are missing we are free to not to create tasks for buckets that are missing.\nBut for a query like\nselect col, count(*)\nfrom table_bucketed_by_col t1\nRIGHT OUTER JOIN non_bucketed_table t2\nWHERE t1.col = t2.col\n\neven if some buckets are missing for t1 we still need to create a task for correctness", "author": "arhimondr", "createdAt": "2020-06-11T22:10:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2ODQ0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTI1MDIyMg==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439250222", "bodyText": "@arhimondr : I see. So essentially numberOfInputPartitions comes from the left-most join table right ?\ni.e. considering\n            JOIN\n          /   |   \\\n        A    B    C\n\nOnce rddA is created, the number of partitions in rddA will be populated to B and C as  the expected number of partitions?", "author": "wenleix", "createdAt": "2020-06-12T07:19:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2ODQ0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM2MTcwNA==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439361704", "bodyText": "I see. So essentially numberOfInputPartitions comes from the left-most join table right ?\n\nNo. It should be determined by the partitions produced by shuffle.\n           JOIN\n          /   |   \\\n        A    B    C\n\nIf table A and C are bucketed, but table B is non bucketed - we will have to shuffle table B. Thus the number of partitions will be present, and will be set to the number of partitions produced by the shuffle over B.\nIf all tables A, B and C are bucketed, and if bucket 0 is missing for all of them - there's no need to schedule a task for that bucket. This optimization cannot be done if at least one table is non bucketed, as there's no way to know in advance if there will be any rows for that bucket produced by the shuffle.", "author": "arhimondr", "createdAt": "2020-06-12T11:21:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2ODQ0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MTQzMw==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439791433", "bodyText": "@arhimondr : Maybe add some comments about the intention ofexpectedNumberOfPartitions (used to eliminate tasks when there are missing buckets), and its behavior when there are both bucketed table input and shuffle input, since it's not intuitive at first glance :)", "author": "wenleix", "createdAt": "2020-06-14T04:48:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2ODQ0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2OTIwNw==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r437869207", "bodyText": "nit: maybe say \"only probe side table is bucketed\"", "author": "wenleix", "createdAt": "2020-06-10T05:31:26Z", "path": "presto-spark-base/src/test/java/com/facebook/presto/spark/TestPrestoSparkQueryRunner.java", "diffHunk": "@@ -55,20 +55,77 @@ public void testTableWrite()\n                         \"FROM orders\");\n     }\n \n+    @Test\n+    public void testBucketedTableWrite()\n+    {\n+        // create from bucketed table\n+        assertUpdate(\n+                \"CREATE TABLE hive.hive_test.hive_orders_bucketed_1 WITH (bucketed_by=array['orderkey'], bucket_count=11) AS \" +\n+                        \"SELECT orderkey, custkey, orderstatus, totalprice, orderdate, orderpriority, clerk, shippriority, comment \" +\n+                        \"FROM orders_bucketed\",\n+                15000);\n+        assertQuery(\n+                \"SELECT count(*) \" +\n+                        \"FROM hive.hive_test.hive_orders_bucketed_1 \" +\n+                        \"WHERE \\\"$bucket\\\" = 1\",\n+                \"SELECT 1365\");\n+\n+        // create from non bucketed table\n+        assertUpdate(\n+                \"CREATE TABLE hive.hive_test.hive_orders_bucketed_2 WITH (bucketed_by=array['orderkey'], bucket_count=11) AS \" +\n+                        \"SELECT orderkey, custkey, orderstatus, totalprice, orderdate, orderpriority, clerk, shippriority, comment \" +\n+                        \"FROM orders\",\n+                15000);\n+        assertQuery(\n+                \"SELECT count(*) \" +\n+                        \"FROM hive.hive_test.hive_orders_bucketed_2 \" +\n+                        \"WHERE \\\"$bucket\\\" = 1\",\n+                \"SELECT 1365\");\n+    }\n+\n     @Test\n     public void testAggregation()\n     {\n         assertQuery(\"select partkey, count(*) c from lineitem where partkey % 10 = 1 group by partkey having count(*) = 42\");\n     }\n \n+    @Test\n+    public void testBucketedAggregation()\n+    {\n+        assertBucketedQuery(\"SELECT orderkey, count(*) c FROM lineitem_bucketed WHERE partkey % 10 = 1 GROUP BY orderkey\");\n+    }\n+\n     @Test\n     public void testJoin()\n     {\n-        assertQuery(\"SELECT l.orderkey, l.linenumber, o.orderstatus \" +\n-                \"FROM lineitem l \" +\n+        assertQuery(\"SELECT l.orderkey, l.linenumber, p.brand \" +\n+                \"FROM lineitem l, part p \" +\n+                \"WHERE l.partkey = p.partkey\");\n+    }\n+\n+    @Test\n+    public void testBucketedJoin()\n+    {\n+        // both tables are bucketed\n+        assertBucketedQuery(\"SELECT l.orderkey, l.linenumber, o.orderstatus \" +\n+                \"FROM lineitem_bucketed l \" +\n+                \"JOIN orders_bucketed o \" +\n+                \"ON l.orderkey = o.orderkey \" +\n+                \"WHERE l.orderkey % 223 = 42 AND l.linenumber = 4 and o.orderstatus = 'O'\");\n+\n+        // only one table is bucketed", "originalCommit": "ecb7c56cc35eb5f2468c837483e8db92e0a19de2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg2OTI1Ng==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r437869256", "bodyText": "ditto, \"only build side table is bucketed\"", "author": "wenleix", "createdAt": "2020-06-10T05:31:36Z", "path": "presto-spark-base/src/test/java/com/facebook/presto/spark/TestPrestoSparkQueryRunner.java", "diffHunk": "@@ -55,20 +55,77 @@ public void testTableWrite()\n                         \"FROM orders\");\n     }\n \n+    @Test\n+    public void testBucketedTableWrite()\n+    {\n+        // create from bucketed table\n+        assertUpdate(\n+                \"CREATE TABLE hive.hive_test.hive_orders_bucketed_1 WITH (bucketed_by=array['orderkey'], bucket_count=11) AS \" +\n+                        \"SELECT orderkey, custkey, orderstatus, totalprice, orderdate, orderpriority, clerk, shippriority, comment \" +\n+                        \"FROM orders_bucketed\",\n+                15000);\n+        assertQuery(\n+                \"SELECT count(*) \" +\n+                        \"FROM hive.hive_test.hive_orders_bucketed_1 \" +\n+                        \"WHERE \\\"$bucket\\\" = 1\",\n+                \"SELECT 1365\");\n+\n+        // create from non bucketed table\n+        assertUpdate(\n+                \"CREATE TABLE hive.hive_test.hive_orders_bucketed_2 WITH (bucketed_by=array['orderkey'], bucket_count=11) AS \" +\n+                        \"SELECT orderkey, custkey, orderstatus, totalprice, orderdate, orderpriority, clerk, shippriority, comment \" +\n+                        \"FROM orders\",\n+                15000);\n+        assertQuery(\n+                \"SELECT count(*) \" +\n+                        \"FROM hive.hive_test.hive_orders_bucketed_2 \" +\n+                        \"WHERE \\\"$bucket\\\" = 1\",\n+                \"SELECT 1365\");\n+    }\n+\n     @Test\n     public void testAggregation()\n     {\n         assertQuery(\"select partkey, count(*) c from lineitem where partkey % 10 = 1 group by partkey having count(*) = 42\");\n     }\n \n+    @Test\n+    public void testBucketedAggregation()\n+    {\n+        assertBucketedQuery(\"SELECT orderkey, count(*) c FROM lineitem_bucketed WHERE partkey % 10 = 1 GROUP BY orderkey\");\n+    }\n+\n     @Test\n     public void testJoin()\n     {\n-        assertQuery(\"SELECT l.orderkey, l.linenumber, o.orderstatus \" +\n-                \"FROM lineitem l \" +\n+        assertQuery(\"SELECT l.orderkey, l.linenumber, p.brand \" +\n+                \"FROM lineitem l, part p \" +\n+                \"WHERE l.partkey = p.partkey\");\n+    }\n+\n+    @Test\n+    public void testBucketedJoin()\n+    {\n+        // both tables are bucketed\n+        assertBucketedQuery(\"SELECT l.orderkey, l.linenumber, o.orderstatus \" +\n+                \"FROM lineitem_bucketed l \" +\n+                \"JOIN orders_bucketed o \" +\n+                \"ON l.orderkey = o.orderkey \" +\n+                \"WHERE l.orderkey % 223 = 42 AND l.linenumber = 4 and o.orderstatus = 'O'\");\n+\n+        // only one table is bucketed\n+        assertBucketedQuery(\"SELECT l.orderkey, l.linenumber, o.orderstatus \" +\n+                \"FROM lineitem_bucketed l \" +\n                 \"JOIN orders o \" +\n                 \"ON l.orderkey = o.orderkey \" +\n                 \"WHERE l.orderkey % 223 = 42 AND l.linenumber = 4 and o.orderstatus = 'O'\");\n+\n+        // only one table is bucketed", "originalCommit": "ecb7c56cc35eb5f2468c837483e8db92e0a19de2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "af4b4ef3cbaf43b3ad3da003d938ccf862866ae7", "url": "https://github.com/prestodb/presto/commit/af4b4ef3cbaf43b3ad3da003d938ccf862866ae7", "message": "Enable collocated join for Presto on Spark", "committedDate": "2020-06-11T22:46:41Z", "type": "forcePushed"}, {"oid": "44b0d924aea643efdafd6b7e7987c546fc82dc5c", "url": "https://github.com/prestodb/presto/commit/44b0d924aea643efdafd6b7e7987c546fc82dc5c", "message": "Enable collocated join for Presto on Spark", "committedDate": "2020-06-12T12:15:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MjQwMw==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r439792403", "bodyText": "Maybe emphasize both taskSourceRdd and shuffleInputRdds will be empty when the stage partitioning is SINGLE_DISTRIBUTION ?", "author": "wenleix", "createdAt": "2020-06-14T05:09:27Z", "path": "presto-spark-classloader-interface/src/main/java/com/facebook/presto/spark/classloader_interface/PrestoSparkTaskRdd.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spark.classloader_interface;\n+\n+import org.apache.spark.Partition;\n+import org.apache.spark.SparkContext;\n+import org.apache.spark.TaskContext;\n+import org.apache.spark.rdd.RDD;\n+import org.apache.spark.rdd.ZippedPartitionsBaseRDD;\n+import org.apache.spark.rdd.ZippedPartitionsPartition;\n+import scala.Tuple2;\n+import scala.collection.Seq;\n+import scala.reflect.ClassTag;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyIterator;\n+import static java.util.Objects.requireNonNull;\n+import static scala.collection.JavaConversions.asJavaIterator;\n+import static scala.collection.JavaConversions.asScalaBuffer;\n+import static scala.collection.JavaConversions.asScalaIterator;\n+import static scala.collection.JavaConversions.seqAsJavaList;\n+\n+/**\n+ * PrestoSparkTaskRdd represents execution of Presto stage, it contains:\n+ * - A list of shuffleInputRdds, each of the corresponding to a child stage.\n+ * - An optional taskSourceRdd, which represents ALL table scan inputs in this stage.\n+ * <p>\n+ * Table scan is present when joining a bucketed table with an unbucketed table, for example:\n+ * Join\n+ * /  \\\n+ * Scan  Remote Source\n+ * <p>\n+ * In this case, bucket to Spark partition mapping has to be consistent with the Spark shuffle partition.\n+ * <p>\n+ * shuffleInputRdds can also be empty when the stage partitioning is SINGLE_DISTRIBUTION.", "originalCommit": "c6bae2da1afcc0b42d69c95244dbaccf756e899e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDMxOTg4NQ==", "url": "https://github.com/prestodb/presto/pull/14559#discussion_r440319885", "bodyText": "Changed the comment to\n * When the stage partitioning is SINGLE_DISTRIBUTION and the shuffleInputRdds is empty,\n * the taskSourceRdd is expected to be present and contain exactly one empty partition.", "author": "arhimondr", "createdAt": "2020-06-15T17:03:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTc5MjQwMw=="}], "type": "inlineReview"}, {"oid": "04a5229d376640a099e909336730aa618c8aec99", "url": "https://github.com/prestodb/presto/commit/04a5229d376640a099e909336730aa618c8aec99", "message": "Add ConnectorNodePartitioningProvider#getBucketCount", "committedDate": "2020-06-15T15:48:08Z", "type": "commit"}, {"oid": "f5943042f89e42a1bfe238046b47a892296a7a69", "url": "https://github.com/prestodb/presto/commit/f5943042f89e42a1bfe238046b47a892296a7a69", "message": "Refactor PrestoSparkRddFactory\n\nConsolidate rdd creation for intermediate and source tasks.\n\nExtend PrestoSparkZipRdd into PrestoSparkTaskRdd.\nThe PrestoSparkTaskRdd now accepts PrestoSparkTaskProcessor and\nPrestoSparkTaskSourceRdd as its inputs.\n\nThis refactor is needed to support bucketed tables, as bucketed\nsplits have to be supplied to a task together with the shuffle inputs.", "committedDate": "2020-06-15T17:15:24Z", "type": "commit"}, {"oid": "1a92f02a3e1515e625b4416c6c2699ff81aeef99", "url": "https://github.com/prestodb/presto/commit/1a92f02a3e1515e625b4416c6c2699ff81aeef99", "message": "Add support for bucketed tables in Presto on Spark", "committedDate": "2020-06-15T17:15:24Z", "type": "commit"}, {"oid": "1f0c897bca86fe97c73ab141fb13fea02a48cab8", "url": "https://github.com/prestodb/presto/commit/1f0c897bca86fe97c73ab141fb13fea02a48cab8", "message": "Enable collocated join for Presto on Spark", "committedDate": "2020-06-15T17:15:24Z", "type": "commit"}, {"oid": "1f0c897bca86fe97c73ab141fb13fea02a48cab8", "url": "https://github.com/prestodb/presto/commit/1f0c897bca86fe97c73ab141fb13fea02a48cab8", "message": "Enable collocated join for Presto on Spark", "committedDate": "2020-06-15T17:15:24Z", "type": "forcePushed"}]}